(()=>{var __webpack_modules__={426:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(645);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, "\\r\\n* {\\r\\n    box-sizing: border-box;\\r\\n    background: #e5e5e5;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    font-family: \\"Poppins\\", sans-serif;\\r\\n    margin: 0;\\r\\n    /* background-image: url(\\"./slika.png\\"); */\\r\\n}\\r\\n\\r\\n.container {\\r\\n    display: flex;\\r\\n    justify-content: center;\\r\\n    flex-direction: column;\\r\\n    align-items: center;\\r\\n}\\r\\n\\r\\n.container__chart {\\r\\n    box-sizing: border-box;\\r\\n    width: 500px;\\r\\n}\\r\\n\\r\\n/* .input {\\r\\n    width: 50px;\\r\\n} */\\r\\n\\r\\n#container__input--form > label {\\r\\n    margin-top: 1rem;\\r\\n}\\r\\n\\r\\n#container__input--form {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n}\\r\\n\\r\\n.input[type=\\"text\\"] {\\r\\n    /* background: url(search-white.png) no-repeat 10px 6px #fcfcfc; */\\r\\n    border: 1px solid #d1d1d1;\\r\\n    font: bold 12px Arial,Helvetica,Sans-serif;\\r\\n    color: #3a3838;\\r\\n    width: 200px;\\r\\n    padding: 6px 15px 6px 35px;\\r\\n    -webkit-border-radius: 20px;\\r\\n    -moz-border-radius: 20px;\\r\\n    border-radius: 20px;\\r\\n    text-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);\\r\\n    -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    -webkit-transition: all 0.7s ease 0s;\\r\\n    -moz-transition: all 0.7s ease 0s;\\r\\n    -o-transition: all 0.7s ease 0s;\\r\\n    transition: all 0.7s ease 0s;\\r\\n    outline:none;\\r\\n}\\r\\n\\r\\n.submit__button {\\r\\n    border: 1px solid #d1d1d1;\\r\\n    font: bold 12px Arial,Helvetica,Sans-serif;\\r\\n    color: #3a3838;\\r\\n    /* width: 50px; */\\r\\n    /* margin-top: 1rem; */\\r\\n    height: 20px;\\r\\n    border-radius: 20px;\\r\\n    cursor: pointer;\\r\\n    margin-top: 1.5rem;\\r\\n    margin-bottom: 1.5rem;\\r\\n  }", "",{"version":3,"sources":["webpack://./src/style.css"],"names":[],"mappings":";AACA;IACI,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,kCAAkC;IAClC,SAAS;IACT,0CAA0C;AAC9C;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,sBAAsB;IACtB,YAAY;AAChB;;AAEA;;GAEG;;AAEH;IACI,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI,kEAAkE;IAClE,yBAAyB;IACzB,0CAA0C;IAC1C,cAAc;IACd,YAAY;IACZ,0BAA0B;IAC1B,2BAA2B;IAC3B,wBAAwB;IACxB,mBAAmB;IACnB,yCAAyC;IACzC,uDAAuD;IACvD,oDAAoD;IACpD,+CAA+C;IAC/C,oCAAoC;IACpC,iCAAiC;IACjC,+BAA+B;IAC/B,4BAA4B;IAC5B,YAAY;AAChB;;AAEA;IACI,yBAAyB;IACzB,0CAA0C;IAC1C,cAAc;IACd,iBAAiB;IACjB,sBAAsB;IACtB,YAAY;IACZ,mBAAmB;IACnB,eAAe;IACf,kBAAkB;IAClB,qBAAqB;EACvB","sourcesContent":["\\r\\n* {\\r\\n    box-sizing: border-box;\\r\\n    background: #e5e5e5;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    font-family: \\"Poppins\\", sans-serif;\\r\\n    margin: 0;\\r\\n    /* background-image: url(\\"./slika.png\\"); */\\r\\n}\\r\\n\\r\\n.container {\\r\\n    display: flex;\\r\\n    justify-content: center;\\r\\n    flex-direction: column;\\r\\n    align-items: center;\\r\\n}\\r\\n\\r\\n.container__chart {\\r\\n    box-sizing: border-box;\\r\\n    width: 500px;\\r\\n}\\r\\n\\r\\n/* .input {\\r\\n    width: 50px;\\r\\n} */\\r\\n\\r\\n#container__input--form > label {\\r\\n    margin-top: 1rem;\\r\\n}\\r\\n\\r\\n#container__input--form {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n}\\r\\n\\r\\n.input[type=\\"text\\"] {\\r\\n    /* background: url(search-white.png) no-repeat 10px 6px #fcfcfc; */\\r\\n    border: 1px solid #d1d1d1;\\r\\n    font: bold 12px Arial,Helvetica,Sans-serif;\\r\\n    color: #3a3838;\\r\\n    width: 200px;\\r\\n    padding: 6px 15px 6px 35px;\\r\\n    -webkit-border-radius: 20px;\\r\\n    -moz-border-radius: 20px;\\r\\n    border-radius: 20px;\\r\\n    text-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);\\r\\n    -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    -webkit-transition: all 0.7s ease 0s;\\r\\n    -moz-transition: all 0.7s ease 0s;\\r\\n    -o-transition: all 0.7s ease 0s;\\r\\n    transition: all 0.7s ease 0s;\\r\\n    outline:none;\\r\\n}\\r\\n\\r\\n.submit__button {\\r\\n    border: 1px solid #d1d1d1;\\r\\n    font: bold 12px Arial,Helvetica,Sans-serif;\\r\\n    color: #3a3838;\\r\\n    /* width: 50px; */\\r\\n    /* margin-top: 1rem; */\\r\\n    height: 20px;\\r\\n    border-radius: 20px;\\r\\n    cursor: pointer;\\r\\n    margin-top: 1.5rem;\\r\\n    margin-bottom: 1.5rem;\\r\\n  }"],"sourceRoot":""}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmFuaWxsYS1pbnRlZ3JhdGlvbi0yZC8uL3NyYy9zdHlsZS5jc3M/MjdhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcclxcbioge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZTVlNWU1O1xcclxcbn1cXHJcXG5cXHJcXG5ib2R5IHtcXHJcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJQb3BwaW5zXFxcIiwgc2Fucy1zZXJpZjtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICAvKiBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4vc2xpa2EucG5nXFxcIik7ICovXFxyXFxufVxcclxcblxcclxcbi5jb250YWluZXIge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbnRhaW5lcl9fY2hhcnQge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICB3aWR0aDogNTAwcHg7XFxyXFxufVxcclxcblxcclxcbi8qIC5pbnB1dCB7XFxyXFxuICAgIHdpZHRoOiA1MHB4O1xcclxcbn0gKi9cXHJcXG5cXHJcXG4jY29udGFpbmVyX19pbnB1dC0tZm9ybSA+IGxhYmVsIHtcXHJcXG4gICAgbWFyZ2luLXRvcDogMXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuI2NvbnRhaW5lcl9faW5wdXQtLWZvcm0ge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdIHtcXHJcXG4gICAgLyogYmFja2dyb3VuZDogdXJsKHNlYXJjaC13aGl0ZS5wbmcpIG5vLXJlcGVhdCAxMHB4IDZweCAjZmNmY2ZjOyAqL1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZDFkMWQxO1xcclxcbiAgICBmb250OiBib2xkIDEycHggQXJpYWwsSGVsdmV0aWNhLFNhbnMtc2VyaWY7XFxyXFxuICAgIGNvbG9yOiAjM2EzODM4O1xcclxcbiAgICB3aWR0aDogMjAwcHg7XFxyXFxuICAgIHBhZGRpbmc6IDZweCAxNXB4IDZweCAzNXB4O1xcclxcbiAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDIwcHg7XFxyXFxuICAgIC1tb3otYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgdGV4dC1zaGFkb3c6IDAgMnB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxyXFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNSkgaW5zZXQ7XFxyXFxuICAgIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNSkgaW5zZXQ7XFxyXFxuICAgIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTUpIGluc2V0O1xcclxcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjdzIGVhc2UgMHM7XFxyXFxuICAgIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgLW8tdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgb3V0bGluZTpub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uc3VibWl0X19idXR0b24ge1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZDFkMWQxO1xcclxcbiAgICBmb250OiBib2xkIDEycHggQXJpYWwsSGVsdmV0aWNhLFNhbnMtc2VyaWY7XFxyXFxuICAgIGNvbG9yOiAjM2EzODM4O1xcclxcbiAgICAvKiB3aWR0aDogNTBweDsgKi9cXHJcXG4gICAgLyogbWFyZ2luLXRvcDogMXJlbTsgKi9cXHJcXG4gICAgaGVpZ2h0OiAyMHB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIG1hcmdpbi10b3A6IDEuNXJlbTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMS41cmVtO1xcclxcbiAgfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQUNBO0lBQ0ksc0JBQXNCO0lBQ3RCLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLGtDQUFrQztJQUNsQyxTQUFTO0lBQ1QsMENBQTBDO0FBQzlDOztBQUVBO0lBQ0ksYUFBYTtJQUNiLHVCQUF1QjtJQUN2QixzQkFBc0I7SUFDdEIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksc0JBQXNCO0lBQ3RCLFlBQVk7QUFDaEI7O0FBRUE7O0dBRUc7O0FBRUg7SUFDSSxnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSxhQUFhO0lBQ2Isc0JBQXNCO0FBQzFCOztBQUVBO0lBQ0ksa0VBQWtFO0lBQ2xFLHlCQUF5QjtJQUN6QiwwQ0FBMEM7SUFDMUMsY0FBYztJQUNkLFlBQVk7SUFDWiwwQkFBMEI7SUFDMUIsMkJBQTJCO0lBQzNCLHdCQUF3QjtJQUN4QixtQkFBbUI7SUFDbkIseUNBQXlDO0lBQ3pDLHVEQUF1RDtJQUN2RCxvREFBb0Q7SUFDcEQsK0NBQStDO0lBQy9DLG9DQUFvQztJQUNwQyxpQ0FBaUM7SUFDakMsK0JBQStCO0lBQy9CLDRCQUE0QjtJQUM1QixZQUFZO0FBQ2hCOztBQUVBO0lBQ0kseUJBQXlCO0lBQ3pCLDBDQUEwQztJQUMxQyxjQUFjO0lBQ2QsaUJBQWlCO0lBQ2pCLHNCQUFzQjtJQUN0QixZQUFZO0lBQ1osbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixrQkFBa0I7SUFDbEIscUJBQXFCO0VBQ3ZCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcclxcbioge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZTVlNWU1O1xcclxcbn1cXHJcXG5cXHJcXG5ib2R5IHtcXHJcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJQb3BwaW5zXFxcIiwgc2Fucy1zZXJpZjtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICAvKiBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4vc2xpa2EucG5nXFxcIik7ICovXFxyXFxufVxcclxcblxcclxcbi5jb250YWluZXIge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbnRhaW5lcl9fY2hhcnQge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICB3aWR0aDogNTAwcHg7XFxyXFxufVxcclxcblxcclxcbi8qIC5pbnB1dCB7XFxyXFxuICAgIHdpZHRoOiA1MHB4O1xcclxcbn0gKi9cXHJcXG5cXHJcXG4jY29udGFpbmVyX19pbnB1dC0tZm9ybSA+IGxhYmVsIHtcXHJcXG4gICAgbWFyZ2luLXRvcDogMXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuI2NvbnRhaW5lcl9faW5wdXQtLWZvcm0ge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdIHtcXHJcXG4gICAgLyogYmFja2dyb3VuZDogdXJsKHNlYXJjaC13aGl0ZS5wbmcpIG5vLXJlcGVhdCAxMHB4IDZweCAjZmNmY2ZjOyAqL1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZDFkMWQxO1xcclxcbiAgICBmb250OiBib2xkIDEycHggQXJpYWwsSGVsdmV0aWNhLFNhbnMtc2VyaWY7XFxyXFxuICAgIGNvbG9yOiAjM2EzODM4O1xcclxcbiAgICB3aWR0aDogMjAwcHg7XFxyXFxuICAgIHBhZGRpbmc6IDZweCAxNXB4IDZweCAzNXB4O1xcclxcbiAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDIwcHg7XFxyXFxuICAgIC1tb3otYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgdGV4dC1zaGFkb3c6IDAgMnB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxyXFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNSkgaW5zZXQ7XFxyXFxuICAgIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNSkgaW5zZXQ7XFxyXFxuICAgIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTUpIGluc2V0O1xcclxcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjdzIGVhc2UgMHM7XFxyXFxuICAgIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgLW8tdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgb3V0bGluZTpub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uc3VibWl0X19idXR0b24ge1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZDFkMWQxO1xcclxcbiAgICBmb250OiBib2xkIDEycHggQXJpYWwsSGVsdmV0aWNhLFNhbnMtc2VyaWY7XFxyXFxuICAgIGNvbG9yOiAjM2EzODM4O1xcclxcbiAgICAvKiB3aWR0aDogNTBweDsgKi9cXHJcXG4gICAgLyogbWFyZ2luLXRvcDogMXJlbTsgKi9cXHJcXG4gICAgaGVpZ2h0OiAyMHB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIG1hcmdpbi10b3A6IDEuNXJlbTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMS41cmVtO1xcclxcbiAgfVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///426\n')},645:module=>{"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], " {").concat(content, "}");\n      }\n\n      return content;\n    }).join("");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === "string") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, ""]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZhbmlsbGEtaW50ZWdyYXRpb24tMmQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///645\n')},15:module=>{"use strict";eval('\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === "function") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n    var sourceMapping = "/*# ".concat(data, " */");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join("\\n");\n  }\n\n  return [content].join("\\n");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmFuaWxsYS1pbnRlZ3JhdGlvbi0yZC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzPzc1ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciAmJiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdKTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pIHtcbiAgdmFyIF9pdGVtID0gX3NsaWNlZFRvQXJyYXkoaXRlbSwgNCksXG4gICAgICBjb250ZW50ID0gX2l0ZW1bMV0sXG4gICAgICBjc3NNYXBwaW5nID0gX2l0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n')},684:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module, Function */\r\n\r\nif(true) {\r\n    var nerdamer = __webpack_require__(182);\r\n    __webpack_require__(238);\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    /*shortcuts*/\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            N = core.groups.N,\r\n            P = core.groups.P,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            keys = core.Utils.keys,\r\n            even = core.Utils.even,\r\n            variables = core.Utils.variables,\r\n            format = core.Utils.format,\r\n            round = core.Utils.round,\r\n            Frac = core.Frac,\r\n            isInt = core.Utils.isInt,\r\n            Symbol = core.Symbol,\r\n            CONST_HASH = core.Settings.CONST_HASH,\r\n            math = core.Utils.importFunctions(),\r\n            evaluate = core.Utils.evaluate;\r\n    //*************** CLASSES ***************//\r\n    /**\r\n     * Converts a symbol into an equivalent polynomial arrays of \r\n     * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n     * Univariate polymials only. \r\n     * @param {Symbol|Number} symbol\r\n     * @param {String} variable The variable name of the polynomial\r\n     * @param {int} order\r\n     */\r\n    function Polynomial(symbol, variable, order) {\r\n        if(core.Utils.isSymbol(symbol)) {\r\n            this.parse(symbol);\r\n            this.variable = this.variable || variable;\r\n        }\r\n        else if(!isNaN(symbol)) {\r\n            order = order || 0;\r\n            if(variable === undefined)\r\n                throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\r\n            this.coeffs = [];\r\n            this.coeffs[order] = symbol;\r\n            this.fill(symbol);\r\n        }\r\n        else if(typeof symbol === 'string') {\r\n            this.parse(_.parse(symbol));\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Polynomial given an array of coefficients\r\n     * @param {int[]} arr\r\n     * @param {String} variable\r\n     * @returns {Polynomial}\r\n     */\r\n    Polynomial.fromArray = function (arr, variable) {\r\n        if(typeof variable === 'undefined')\r\n            throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\r\n        var p = new Polynomial();\r\n        p.coeffs = arr;\r\n        p.variable = variable;\r\n        return p;\r\n    };\r\n\r\n    Polynomial.fit = function (c1, c2, n, base, p, variable) {\r\n        //after having looped through and mod 10 the number to get the matching factor\r\n        var terms = new Array(p + 1),\r\n                t = n - c2;\r\n        terms[0] = c2; //the constants is assumed to be correct\r\n        //constant for x^p is also assumed know so add\r\n        terms[p] = c1;\r\n        t -= c1 * Math.pow(base, p);\r\n        //start fitting\r\n        for(var i = p - 1; i > 0; i--) {\r\n            var b = Math.pow(base, i), //we want as many wholes as possible\r\n                    q = t / b,\r\n                    sign = Math.sign(q);\r\n            var c = sign * Math.floor(Math.abs(q));\r\n            t -= c * b;\r\n            terms[i] = c;\r\n        }\r\n        if(t !== 0)\r\n            return null;\r\n        for(var i = 0; i < terms.length; i++)\r\n            terms[i] = new Frac(terms[i]);\r\n\r\n        return Polynomial.fromArray(terms, variable);\r\n    };\r\n\r\n    Polynomial.prototype = {\r\n        /**\r\n         * Converts Symbol to Polynomial\r\n         * @param {Symbol} symbol\r\n         * @param {Array} c - a collector array\r\n         * @returns {Polynomial}\r\n         */\r\n        parse: function (symbol, c) {\r\n            this.variable = variables(symbol)[0];\r\n            if(!symbol.isPoly())\r\n                throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\r\n            c = c || [];\r\n            if(!symbol.power.absEquals(1))\r\n                symbol = _.expand(symbol);\r\n\r\n            if(symbol.group === core.groups.N) {\r\n                c[0] = symbol.multiplier;\r\n            }\r\n            else if(symbol.group === core.groups.S) {\r\n                c[symbol.power.toDecimal()] = symbol.multiplier;\r\n            }\r\n            else {\r\n                for(var x in symbol.symbols) {\r\n                    var sub = symbol.symbols[x],\r\n                            p = sub.power;\r\n                    if(core.Utils.isSymbol(p))\r\n                        throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\r\n\r\n                    p = sub.group === N ? 0 : p.toDecimal();\r\n                    if(sub.symbols) {\r\n                        this.parse(sub, c);\r\n                    }\r\n                    else {\r\n                        c[p] = sub.multiplier;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.coeffs = c;\r\n\r\n            this.fill();\r\n        },\r\n        /**\r\n         * Fills in the holes in a polynomial with zeroes\r\n         * @param {Number} x - The number to fill the holes with\r\n         */\r\n        fill: function (x) {\r\n            x = Number(x) || 0;\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(this.coeffs[i] === undefined) {\r\n                    this.coeffs[i] = new Frac(x);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Removes higher order zeros or a specific coefficient\r\n         * @returns {Array}\r\n         */\r\n        trim: function () {\r\n            var l = this.coeffs.length;\r\n            while(l--) {\r\n                var c = this.coeffs[l];\r\n                var equalsZero = c.equals(0);\r\n                if(c && equalsZero) {\r\n                    if(l === 0)\r\n                        break;\r\n                    this.coeffs.pop();\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /*\r\n         * Returns polynomial mod p **currently fails**\r\n         * @param {Number} p\r\n         * @returns {Polynomial}\r\n         */\r\n        modP: function (p) {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = this.coeffs[i];\r\n                if(c < 0) { //go borrow\r\n                    var b; //a coefficient > 0\r\n                    for(var j = i; j < l; j++) {//starting from where we left off\r\n                        if(this.coeffs[j] > 0) {\r\n                            b = this.coeffs[j];\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(b) { //if such a coefficient exists\r\n                        for(j; j > i; j--) { //go down the line and adjust using p\r\n                            this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\r\n                            this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\r\n                        }\r\n                        c = this.coeffs[i]; //reset c\r\n                    }\r\n                }\r\n\r\n                var d = c.mod(p);\r\n                var w = c.subtract(d).divide(p);\r\n                if(!w.equals(0)) {\r\n                    var up_one = i + 1;\r\n                    var next = this.coeffs[up_one] || new Frac(0);\r\n                    next = next.add(w);\r\n                    this.coeffs[up_one] = new Frac(next);\r\n                    this.coeffs[i] = new Frac(d);\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        add: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.add(b);\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        subtract: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.subtract(b);\r\n            }\r\n            return this;\r\n        },\r\n        divide: function (poly) {\r\n            var variable = this.variable,\r\n                    dividend = core.Utils.arrayClone(this.coeffs),\r\n                    divisor = core.Utils.arrayClone(poly.coeffs),\r\n                    n = dividend.length,\r\n                    mp = divisor.length - 1,\r\n                    quotient = [];\r\n\r\n            //loop through the dividend\r\n            for(var i = 0; i < n; i++) {\r\n                var p = n - (i + 1);\r\n                //get the difference of the powers\r\n                var d = p - mp;\r\n                //get the quotient of the coefficients\r\n                var q = dividend[p].divide(divisor[mp]);\r\n\r\n                if(d < 0)\r\n                    break;//the divisor is not greater than the dividend\r\n                //place it in the quotient\r\n                quotient[d] = q;\r\n\r\n                for(var j = 0; j <= mp; j++) {\r\n                    //reduce the dividend\r\n                    dividend[j + d] = dividend[j + d].subtract((divisor[j].multiply(q)));\r\n                }\r\n            }\r\n\r\n            //clean up\r\n            var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(), //pass in x for safety\r\n                    p2 = Polynomial.fromArray(quotient, variable || 'x');\r\n            return [p2, p1];\r\n        },\r\n        multiply: function (poly) {\r\n            var l1 = this.coeffs.length, l2 = poly.coeffs.length,\r\n                    c = []; //array to be returned\r\n            for(var i = 0; i < l1; i++) {\r\n                var x1 = this.coeffs[i];\r\n                for(var j = 0; j < l2; j++) {\r\n                    var k = i + j, //add the powers together\r\n                            x2 = poly.coeffs[j],\r\n                            e = c[k] || new Frac(0); //get the existing term from the new array\r\n                    c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\r\n                }\r\n            }\r\n            this.coeffs = c;\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks if a polynomial is zero\r\n         * @returns {Boolean}\r\n         */\r\n        isZero: function () {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /** \r\n         * Substitutes in a number n into the polynomial p(n)\r\n         * @param {Number} n\r\n         * @returns {Frac}\r\n         */\r\n        sub: function (n) {\r\n            var sum = new Frac(0), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var t = this.coeffs[i];\r\n                if(!t.equals(0))\r\n                    sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\r\n            }\r\n            return sum;\r\n        },\r\n        /**\r\n         * Returns a clone of the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        clone: function () {\r\n            var p = new Polynomial();\r\n            p.coeffs = this.coeffs;\r\n            p.variable = this.variable;\r\n            return p;\r\n        },\r\n        /**\r\n         * Gets the degree of the polynomial\r\n         * @returns {Number}\r\n         */\r\n        deg: function () {\r\n            this.trim();\r\n            return this.coeffs.length - 1;\r\n        },\r\n        /**\r\n         * Returns a lead coefficient\r\n         * @returns {Frac}\r\n         */\r\n        lc: function () {\r\n            return this.coeffs[this.deg()].clone();\r\n        },\r\n        /**\r\n         * Converts polynomial into a monic polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        monic: function () {\r\n            var lc = this.lc(), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++)\r\n                this.coeffs[i] = this.coeffs[i].divide(lc);\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the GCD of two polynomials\r\n         * @param {Polynomial} poly\r\n         * @returns {Polynomial}\r\n         */\r\n        gcd: function (poly) {\r\n            //get the maximum power of each\r\n            var mp1 = this.coeffs.length - 1,\r\n                    mp2 = poly.coeffs.length - 1,\r\n                    T;\r\n            //swap so we always have the greater power first\r\n            if(mp1 < mp2) {\r\n                return poly.gcd(this);\r\n            }\r\n            var a = this;\r\n\r\n            while(!poly.isZero()) {\r\n                var t = poly.clone();\r\n                a = a.clone();\r\n                T = a.divide(t);\r\n                poly = T[1];\r\n                a = t;\r\n            }\r\n\r\n            var gcd = core.Math2.QGCD.apply(null, a.coeffs);\r\n            if(!gcd.equals(1)) {\r\n                var l = a.coeffs.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    a.coeffs[i] = a.coeffs[i].divide(gcd);\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        /**\r\n         * Differentiates the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        diff: function () {\r\n            var new_array = [], l = this.coeffs.length;\r\n            for(var i = 1; i < l; i++)\r\n                new_array.push(this.coeffs[i].multiply(new Frac(i)));\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Integrates the polynomial\r\n         * @returns {Polynomial} \r\n         */\r\n        integrate: function () {\r\n            var new_array = [0], l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = new Frac(i + 1);\r\n                new_array[c] = this.coeffs[i].divide(c);\r\n            }\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the Greatest common factor of the polynomial\r\n         * @param {bool} toPolynomial - true if a polynomial is wanted\r\n         * @returns {Frac|Polynomial}\r\n         */\r\n        gcf: function (toPolynomial) {\r\n            //get the first nozero coefficient and returns its power\r\n            var fnz = function (a) {\r\n                for(var i = 0; i < a.length; i++)\r\n                    if(!a[i].equals(0))\r\n                        return i;\r\n            },\r\n                    ca = [];\r\n            for(var i = 0; i < this.coeffs.length; i++) {\r\n                var c = this.coeffs[i];\r\n                if(!c.equals(0) && ca.indexOf(c) === -1)\r\n                    ca.push(c);\r\n            }\r\n            var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\r\n\r\n            if(toPolynomial) {\r\n                var parr = [];\r\n                parr[p[1] - 1] = p[0];\r\n                p = Polynomial.fromArray(parr, this.variable).fill();\r\n            }\r\n\r\n            return p;\r\n        },\r\n        /**\r\n         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n         * @param {bool} incl_img - Include imaginary numbers \r\n         */\r\n        quad: function (incl_img) {\r\n            var roots = [];\r\n            if(this.coeffs.length > 3)\r\n                throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\r\n            if(this.coeffs.length === 0)\r\n                throw new Error('Polynomial array has no terms');\r\n            var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];\r\n            var dsc = b * b - 4 * a * c;\r\n            if(dsc < 0 && !incl_img)\r\n                return roots;\r\n            else {\r\n                roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\r\n                roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\r\n            }\r\n            return roots;\r\n        },\r\n        /**\r\n         * Makes polynomial square free\r\n         * @returns {Array}\r\n         */\r\n        squareFree: function () {\r\n\r\n            var a = this.clone(),\r\n                    i = 1,\r\n                    b = a.clone().diff(),\r\n                    c = a.clone().gcd(b),\r\n                    w = a.divide(c)[0];\r\n            var output = Polynomial.fromArray([new Frac(1)], a.variable);\r\n            while(!c.equalsNumber(1)) {\r\n                var y = w.gcd(c);\r\n                var z = w.divide(y)[0];\r\n                //one of the factors may have shown up since it's square but smaller than the \r\n                //one where finding\r\n                if(!z.equalsNumber(1) && i > 1) {\r\n                    var t = z.clone();\r\n                    for(var j = 1; j < i; j++)\r\n                        t.multiply(z.clone());\r\n                    z = t;\r\n                }\r\n                output = output.multiply(z);\r\n                i++;\r\n                w = y;\r\n                c = c.divide(y)[0];\r\n            }\r\n\r\n            return [output, w, i];\r\n        },\r\n        /**\r\n         * Converts polynomial to Symbol\r\n         * @returns {Symbol}\r\n         */\r\n        toSymbol: function () {\r\n            var l = this.coeffs.length,\r\n                    variable = this.variable;\r\n            if(l === 0)\r\n                return new core.Symbol(0);\r\n            var end = l - 1, str = '';\r\n\r\n            for(var i = 0; i < l; i++) {\r\n                //place the plus sign for all but the last one\r\n                var plus = i === end ? '' : '+',\r\n                        e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    str += (e + '*' + variable + '^' + i + plus);\r\n            }\r\n            return _.parse(str);\r\n        },\r\n        /**\r\n         * Checks if polynomial is equal to a number\r\n         * @param {Number} x\r\n         * @returns {Boolean}\r\n         */\r\n        equalsNumber: function (x) {\r\n            this.trim();\r\n            return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\r\n        },\r\n        toString: function () {\r\n            return this.toSymbol().toString();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * TODO\r\n     * ===================================================================================\r\n     * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n     * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n     * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n     * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n     * ===================================================================================\r\n     * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n     * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n     * so the symbol multiplier carries the coefficients for all contained symbols.\r\n     * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n     * @param {Array} c The coefficient array\r\n     * @param {boolean} with_order \r\n     * @return {Array}\r\n     */\r\n    Symbol.prototype.coeffs = function (c, with_order) {\r\n        if(with_order && !this.isPoly(true))\r\n            _.error('Polynomial expected when requesting coefficients with order');\r\n        c = c || [];\r\n        var s = this.clone().distributeMultiplier();\r\n        if(s.isComposite()) {\r\n            for(var x in s.symbols) {\r\n                var sub = s.symbols[x];\r\n                if(sub.isComposite()) {\r\n                    sub.clone().distributeMultiplier().coeffs(c, with_order);\r\n                }\r\n                else {\r\n                    if(with_order)\r\n                        c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;\r\n                    else {\r\n                        c.push(sub.multiplier);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if(with_order)\r\n                c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;\r\n            else {\r\n                if(s.group === CB && s.isImaginary()) {\r\n                    var m = new Symbol(s.multiplier);\r\n                    s.each(function (x) {\r\n                        //add the imaginary part\r\n                        if(x.isConstant(true) || x.imaginary)\r\n                            m = _.multiply(m, x);\r\n                    });\r\n                    c.push(m);\r\n                }\r\n                else\r\n                    c.push(s.multiplier);\r\n            }\r\n        }\r\n        //fill the holes\r\n        if(with_order) {\r\n            for(var i = 0; i < c.length; i++)\r\n                if(c[i] === undefined)\r\n                    c[i] = new Symbol(0);\r\n        }\r\n        return c;\r\n    };\r\n    Symbol.prototype.tBase = function (map) {\r\n        if(typeof map === 'undefined')\r\n            throw new Error('Symbol.tBase requires a map object!');\r\n        var terms = [];\r\n        var symbols = this.collectSymbols(null, null, null, true),\r\n                l = symbols.length;\r\n        for(var i = 0; i < l; i++) {\r\n            var symbol = symbols[i],\r\n                    g = symbol.group,\r\n                    nterm = new MVTerm(symbol.multiplier, [], map);\r\n            if(g === CB) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n                    nterm.terms[map[x]] = sym.power;\r\n                }\r\n            }\r\n            else {\r\n                nterm.terms[map[symbol.value]] = symbol.power;\r\n            }\r\n\r\n            terms.push(nterm.fill());\r\n            nterm.updateCount();\r\n        }\r\n        return terms;\r\n    };\r\n    Symbol.prototype.altVar = function (x) {\r\n        var m = this.multiplier.toString(), p = this.power.toString();\r\n        return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\r\n    };\r\n    /**\r\n     * Checks to see if the symbols contain the same variables\r\n     * @param {Symbol} symbol\r\n     * @returns {Boolean}\r\n     */\r\n    Symbol.prototype.sameVars = function (symbol) {\r\n        if(!(this.symbols || this.group === symbol.group))\r\n            return false;\r\n        for(var x in this.symbols) {\r\n            var a = this.symbols[x], b = symbol.symbols[x];\r\n            if(!b)\r\n                return false;\r\n            if(a.value !== b.value)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Groups the terms in a symbol with respect to a variable\r\n     * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n     * @returns {Factors}\r\n     */\r\n    Symbol.prototype.groupTerms = function (x) {\r\n        x = String(x);\r\n        var f, p, egrouped;\r\n        var grouped = [];\r\n        this.each(function (e) {\r\n            if(e.group === PL) {\r\n                egrouped = e.groupTerms(x);\r\n                for(var i = 0; i < egrouped.length; i++) {\r\n                    var el = egrouped[i];\r\n                    if(el)\r\n                        grouped[i] = el;\r\n                }\r\n            }\r\n            else {\r\n                f = core.Utils.decompose_fn(e, x, true);\r\n                p = f.x.value === x ? Number(f.x.power) : 0;\r\n                //check if there's an existing value\r\n                grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\r\n            }\r\n        });\r\n        return grouped;\r\n    };\r\n    /**\r\n     * Use this to collect Factors\r\n     * @returns {Symbol[]}\r\n     */\r\n    Symbol.prototype.collectFactors = function () {\r\n        var factors = [];\r\n        if(this.group === CB)\r\n            this.each(function (x) {\r\n                factors.push(x.clone());\r\n            });\r\n        else\r\n            factors.push(this.clone());\r\n        return factors;\r\n    };\r\n    /**\r\n     * A container class for factors\r\n     * @returns {Factors}\r\n     */\r\n    function Factors() {\r\n        this.factors = {};\r\n        this.length = 0;\r\n    }\r\n    ;\r\n    Factors.prototype.getNumberSymbolics = function () {\r\n        var n = 0;\r\n        this.each(function (x) {\r\n            if(!x.isConstant(true))\r\n                n++;\r\n        });\r\n        return n;\r\n    };\r\n    /**\r\n     * Adds the factors to the factor object\r\n     * @param {Symbo} s\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.add = function (s) {\r\n        if(s.equals(0))\r\n            return this; //nothing to add\r\n\r\n        //we don't want to carry -1 as a factor. If a factor already exists,\r\n        //then add the minus one to that factor and return.\r\n        if(s.equals(-1) && this.length > 0) {\r\n            var fo = core.Utils.firstObject(this.factors, null, true);\r\n            this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\r\n            delete this.factors[fo.key];\r\n            this.length--;\r\n            return this;\r\n        }\r\n\r\n        if(s.group === CB) {\r\n            var factors = this;\r\n            if(!s.multiplier.equals(1))\r\n                factors.add(new Symbol(s.multiplier));\r\n            s.each(function (x) {\r\n                factors.add(x);\r\n            });\r\n        }\r\n        else {\r\n            if(this.preAdd) //if a preAdd function was defined call it to do prep\r\n                s = this.preAdd(s);\r\n            if(this.pFactor) //if the symbol isn't linear add back the power\r\n                s = _.pow(s, new Symbol(this.pFactor));\r\n\r\n            var is_constant = s.isConstant();\r\n            if(is_constant && s.equals(1))\r\n                return this; //don't add 1\r\n            var v = is_constant ? s.value : s.text();\r\n            if(v in this.factors) {\r\n                this.factors[v] = _.multiply(this.factors[v], s);\r\n                //did the addition cancel out the existing factor? If so remove it and decrement the length\r\n                if(this.factors[v].equals(1)) {\r\n                    delete this.factors[v];\r\n                    this.length--;\r\n                }\r\n            }\r\n            else {\r\n                this.factors[v] = s;\r\n                this.length++;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the factor object to a Symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Factors.prototype.toSymbol = function () {\r\n        var factored = new Symbol(1);\r\n        var factors = Object.values(this.factors).sort(function (a, b) {\r\n            return a.group > b.group;\r\n        });\r\n\r\n        for(var i = 0, l = factors.length; i < l; i++) {\r\n            var f = factors[i];\r\n\r\n            //don't wrap group S or FN\r\n            var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */ ?\r\n                    _.symfunction(core.PARENTHESIS, [f]) : f;\r\n\r\n            factored = _.multiply(factored, factor);\r\n        }\r\n        if(factored.fname === '')\r\n            factored = Symbol.unwrapPARENS(factored);\r\n        return factored;\r\n    };\r\n    /**\r\n     * Merges 2 factor objects into one\r\n     * @param {Factor} o\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.merge = function (o) {\r\n        for(var x in o) {\r\n            if(x in this.factors)\r\n                this.factors[x] = _.multiply(this.factors[x], o[x]);\r\n            else\r\n                this.factors[x] = o[x];\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * The iterator for the factor object\r\n     * @param {Function} f - callback\r\n     * @returns {Factor}\r\n     */\r\n    Factors.prototype.each = function (f) {\r\n        for(var x in this.factors) {\r\n            var factor = this.factors[x];\r\n            if(factor.fname === core.PARENTHESIS && factor.isLinear())\r\n                factor = factor.args[0];\r\n            f.call(this, factor, x);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Return the number of factors contained in the factor object\r\n     * @returns {int}\r\n     */\r\n    Factors.prototype.count = function () {\r\n        return keys(this.factors).length;\r\n    };\r\n    /**\r\n     * Cleans up factors from -1\r\n     * @returns {undefined}\r\n     */\r\n    Factors.prototype.clean = function () {\r\n        try {\r\n            var h = core.Settings.CONST_HASH;\r\n            if(this.factors[h].lessThan(0)) {\r\n                if(this.factors[h].equals(-1))\r\n                    delete this.factors[h];\r\n                else\r\n                    this.factors[h].negate();\r\n                this.each(function (x) {\r\n                    x.negate();\r\n                });\r\n            }\r\n        }\r\n        catch(e) {\r\n        }\r\n        ;\r\n    };\r\n    Factors.prototype.toString = function () {\r\n        return this.toSymbol().toString();\r\n    };\r\n\r\n    //a wrapper for performing multivariate division\r\n    function MVTerm(coeff, terms, map) {\r\n        this.terms = terms || [];\r\n        this.coeff = coeff;\r\n        this.map = map; //careful! all maps are the same object\r\n        this.sum = new core.Frac(0);\r\n        this.image = undefined;\r\n    }\r\n    ;\r\n    MVTerm.prototype.updateCount = function () {\r\n        this.count = this.count || 0;\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            if(!this.terms[i].equals(0))\r\n                this.count++;\r\n        }\r\n        return this;\r\n    };\r\n    MVTerm.prototype.getVars = function () {\r\n        var vars = [];\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var term = this.terms[i],\r\n                    rev_map = this.getRevMap();\r\n            if(!term.equals(0))\r\n                vars.push(this.rev_map[i]);\r\n        }\r\n        return vars.join(' ');\r\n    };\r\n    MVTerm.prototype.len = function () {\r\n        if(typeof this.count === 'undefined') {\r\n            this.updateCount();\r\n        }\r\n        return this.count;\r\n    };\r\n    MVTerm.prototype.toSymbol = function (rev_map) {\r\n        rev_map = rev_map || this.getRevMap();\r\n        var symbol = new Symbol(this.coeff);\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var v = rev_map[i],\r\n                    t = this.terms[i];\r\n            if(t.equals(0) || v === CONST_HASH)\r\n                continue;\r\n            var mapped = new Symbol(v);\r\n            mapped.power = t;\r\n            symbol = _.multiply(symbol, mapped);\r\n        }\r\n        return symbol;\r\n    };\r\n    MVTerm.prototype.getRevMap = function () {\r\n        if(this.rev_map)\r\n            return this.rev_map;\r\n        var o = {};\r\n        for(var x in this.map)\r\n            o[this.map[x]] = x;\r\n        this.rev_map = o;\r\n        return o;\r\n    };\r\n    MVTerm.prototype.generateImage = function () {\r\n        this.image = this.terms.join(' ');\r\n        return this;\r\n    },\r\n            MVTerm.prototype.getImg = function () {\r\n                if(!this.image)\r\n                    this.generateImage();\r\n                return this.image;\r\n            },\r\n            MVTerm.prototype.fill = function () {\r\n                var l = this.map.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    if(typeof this.terms[i] === 'undefined')\r\n                        this.terms[i] = new core.Frac(0);\r\n                    else {\r\n                        this.sum = this.sum.add(this.terms[i]);\r\n                    }\r\n                }\r\n                return this;\r\n            };\r\n    MVTerm.prototype.divide = function (mvterm) {\r\n        var c = this.coeff.divide(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.multiply = function (mvterm) {\r\n        var c = this.coeff.multiply(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.isZero = function () {\r\n        return this.coeff.equals(0);\r\n    };\r\n    MVTerm.prototype.toString = function () {\r\n        return '{ coeff: ' + this.coeff.toString() + ', terms: [' +\r\n                this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\r\n    };\r\n\r\n    core.Utils.toMapObj = function (arr) {\r\n        var c = 0, o = {};\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var v = arr[i];\r\n            if(typeof o[v] === 'undefined') {\r\n                o[v] = c;\r\n                c++;\r\n            }\r\n        }\r\n        o.length = c;\r\n        return o;\r\n    };\r\n    core.Utils.filledArray = function (v, n, clss) {\r\n        var a = [];\r\n        while(n--) {\r\n            a[n] = clss ? new clss(v) : v;\r\n        }\r\n        return a;\r\n    };\r\n    core.Utils.arrSum = function (arr) {\r\n        var sum = 0, l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            sum += arr[i];\r\n        return sum;\r\n    };\r\n    /**\r\n     * Determines if 2 arrays have intersecting elements.\r\n     * @param {Array} a\r\n     * @param {Array} b\r\n     * @returns {Boolean} True if a and b have intersecting elements.\r\n     */\r\n    core.Utils.haveIntersection = function (a, b) {\r\n        var t;\r\n        if(b.length > a.length)\r\n            t = b, b = a, a = t; // indexOf to loop over shorter\r\n        return a.some(function (e) {\r\n            return b.indexOf(e) > -1;\r\n        });\r\n    };\r\n    /**\r\n     * Substitutes out functions as variables so they can be used in regular algorithms\r\n     * @param {Symbol} symbol\r\n     * @param {Object} map\r\n     * @returns {String} The expression string\r\n     */\r\n    core.Utils.subFunctions = function (symbol, map) {\r\n        map = map || {};\r\n        var subbed = [];\r\n        symbol.each(function (x) {\r\n            if(x.group === FN || x.previousGroup === FN) {\r\n                //we need a new variable name so why not use one of the existing\r\n                var val = core.Utils.text(x, 'hash'), tvar = map[val];\r\n                if(!tvar) {\r\n                    //generate a unique enough name\r\n                    var t = x.fname + keys(map).length;\r\n                    map[val] = t;\r\n                    subbed.push(x.altVar(t));\r\n                }\r\n                else\r\n                    subbed.push(x.altVar(tvar));\r\n            }\r\n            else if(x.group === CB || x.group === PL || x.group === CP) {\r\n                subbed.push(core.Utils.subFunctions(x, map));\r\n            }\r\n            else\r\n                subbed.push(x.text());\r\n        });\r\n        if(symbol.group === CP || symbol.group === PL)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\r\n        ;\r\n        if(symbol.group === CB)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\r\n        return symbol.text();\r\n    };\r\n    core.Utils.getFunctionsSubs = function (map) {\r\n        var subs = {};\r\n        //prepare substitutions\r\n        for(var x in map)\r\n            subs[map[x]] = _.parse(x);\r\n        return subs;\r\n    };\r\n\r\n    var __ = core.Algebra = {\r\n        version: '1.4.6',\r\n        proots: function (symbol, decp) {\r\n            //the roots will be rounded up to 7 decimal places.\r\n            //if this causes trouble you can explicitly pass in a different number of places\r\n            //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\r\n            decp = decp || 7;\r\n            var zeros = 0;\r\n            var known_roots = [];\r\n            var get_roots = function (rarr, powers, max) {\r\n                var roots = calcroots(rarr, powers, max).concat(known_roots);\r\n                for(var i = 0; i < zeros; i++)\r\n                    roots.unshift(0);\r\n                return roots;\r\n            };\r\n\r\n            if(symbol instanceof Symbol && symbol.isPoly()) {\r\n                symbol.distributeMultiplier();\r\n                //make it so the symbol has a constants as the lowest term\r\n                if(symbol.group === PL) {\r\n                    var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\r\n                    var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\r\n                    symbol = _.expand(_.divide(symbol, lowest_symbol));\r\n                    known_roots.push(0); //add zero since this is a known root\r\n                }\r\n                if(symbol.group === core.groups.S) {\r\n                    return [0];\r\n                }\r\n                else if(symbol.group === core.groups.PL) {\r\n                    var powers = keys(symbol.symbols),\r\n                            minpower = core.Utils.arrayMin(powers),\r\n                            symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\r\n                }\r\n\r\n                var variable = keys(symbol.symbols).sort().pop(),\r\n                        sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\r\n                        g = sym.group,\r\n                        powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\r\n                        rarr = [],\r\n                        max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\r\n\r\n                // Prepare the data\r\n                for(var i = 1; i <= max; i++) {\r\n                    var c = 0; //if there is no power then the hole must be filled with a zero\r\n                    if(powers.indexOf(i + '') !== -1) {\r\n                        if(g === S) {\r\n                            c = sym.multiplier;\r\n                        }\r\n                        else {\r\n                            c = sym.symbols[i].multiplier;\r\n                        }\r\n                    }\r\n                    // Insert the coeffient but from the front\r\n                    rarr.unshift(c);\r\n                }\r\n\r\n                rarr.push(symbol.symbols[CONST_HASH].multiplier);\r\n\r\n                if(sym.group === S)\r\n                    rarr[0] = sym.multiplier;//the symbol maybe of group CP with one variable\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else if(core.Utils.isArray(symbol)) {\r\n                var parr = symbol;\r\n                var rarr = [],\r\n                        powers = [],\r\n                        last_power = 0;\r\n                for(var i = 0; i < parr.length; i++) {\r\n\r\n                    var coeff = parr[i][0],\r\n                            pow = parr[i][1],\r\n                            d = pow - last_power - 1;\r\n                    //insert the zeros\r\n                    for(var j = 0; j < d; j++)\r\n                        rarr.unshift(0);\r\n\r\n                    rarr.unshift(coeff);\r\n                    if(pow !== 0)\r\n                        powers.push(pow);\r\n                    last_power = pow;\r\n                }\r\n                var max = Math.max.apply(undefined, powers);\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else {\r\n                throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\r\n            }\r\n\r\n            function calcroots(rarr, powers, max) {\r\n                var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\r\n\r\n                // Make a clone of the coefficients before appending the max power\r\n                var p = rarr.slice(0);\r\n\r\n                // Divide the string up into its individual entries, which--presumably--are separated by whitespace\r\n                rarr.unshift(max);\r\n\r\n                if(max > MAXDEGREE) {\r\n                    throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\r\n                }\r\n\r\n                var zeroi = [], // Vector of imaginary components of roots\r\n                        degreePar = {};    // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\r\n                degreePar.Degree = max;\r\n\r\n                for(i = 0; i < max; i++) {\r\n                    zeroi.push(0);\r\n                }\r\n                var zeror = zeroi.slice(0); // Vector of real components of roots\r\n\r\n                // Find the roots\r\n                //--\x3e Begin Jenkins-Traub\r\n\r\n                /*\r\n                 * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n                 */\r\n                function QuadSD_ak1(NN, u, v, p, q, iPar) {\r\n                    // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\r\n                    // iPar is a dummy variable for passing in the two parameters--a and b--by reference\r\n                    q[0] = iPar.b = p[0];\r\n                    q[1] = iPar.a = -(u * iPar.b) + p[1];\r\n\r\n                    for(var i = 2; i < NN; i++) {\r\n                        q[i] = -(u * iPar.a + v * iPar.b) + p[i];\r\n                        iPar.b = iPar.a;\r\n                        iPar.a = q[i];\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\r\n                    // This routine calculates scalar quantities used to compute the next K polynomial and\r\n                    // new estimates of the quadratic coefficients.\r\n                    // calcSC -\tinteger variable set here indicating how the calculations are normalized\r\n                    // to avoid overflow.\r\n                    // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\r\n\r\n                    // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\r\n                    var sdPar = new Object(),\r\n                            // TYPE = 3 indicates the quadratic is almost a factor of K\r\n                            dumFlag = 3;\r\n\r\n                    // Synthetic division of K by the quadratic 1, u, v\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(N, u, v, K, qk, sdPar);\r\n                    iPar.c = sdPar.a;\r\n                    iPar.d = sdPar.b;\r\n\r\n                    if(Math.abs(iPar.c) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 1]))) {\r\n                        if(Math.abs(iPar.d) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 2])))\r\n                            return dumFlag;\r\n                    }\r\n\r\n                    iPar.h = v * b;\r\n                    if(Math.abs(iPar.d) >= Math.abs(iPar.c)) {\r\n                        // TYPE = 2 indicates that all formulas are divided by d\r\n                        dumFlag = 2;\r\n                        iPar.e = a / (iPar.d);\r\n                        iPar.f = (iPar.c) / (iPar.d);\r\n                        iPar.g = u * b;\r\n                        iPar.a3 = (iPar.e) * ((iPar.g) + a) + (iPar.h) * (b / (iPar.d));\r\n                        iPar.a1 = -a + (iPar.f) * b;\r\n                        iPar.a7 = (iPar.h) + ((iPar.f) + u) * a;\r\n                    }\r\n                    else {\r\n                        // TYPE = 1 indicates that all formulas are divided by c;\r\n                        dumFlag = 1;\r\n                        iPar.e = a / (iPar.c);\r\n                        iPar.f = (iPar.d) / (iPar.c);\r\n                        iPar.g = (iPar.e) * u;\r\n                        iPar.a3 = (iPar.e) * a + ((iPar.g) + (iPar.h) / (iPar.c)) * b;\r\n                        iPar.a1 = -(a * ((iPar.d) / (iPar.c))) + b;\r\n                        iPar.a7 = (iPar.g) * (iPar.d) + (iPar.h) * (iPar.f) + a;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\r\n                    // Computes the next K polynomials using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\r\n                    var temp;\r\n                    if(tFlag == 3) {\t// Use unscaled form of the recurrence\r\n                        K[1] = K[0] = 0.0;\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = qk[i - 2];\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    temp = ((tFlag == 1) ? b : a);\r\n                    if(Math.abs(iPar.a1) > (10.0 * DBL_EPSILON * Math.abs(temp))) {\r\n                        // Use scaled form of the recurrence\r\n                        iPar.a7 /= iPar.a1;\r\n                        iPar.a3 /= iPar.a1;\r\n                        K[0] = qp[0];\r\n                        K[1] = -(qp[0] * iPar.a7) + qp[1];\r\n                        for(var i = 2; i < N; i++)\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\r\n                    }\r\n                    else {\r\n                        // If a1 is nearly zero, then use a special form of the recurrence\r\n                        K[0] = 0.0;\r\n                        K[1] = -(qp[0] * iPar.a7);\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\r\n                    // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\r\n                    // iPar.a = uu, iPar.b = vv\r\n\r\n                    var a4, a5, b1, b2, c1, c2, c3, c4, temp;\r\n                    iPar.b = iPar.a = 0.0;// The quadratic is zeroed\r\n\r\n                    if(tFlag != 3) {\r\n                        if(tFlag != 2) {\r\n                            a4 = a + u * b + h * f;\r\n                            a5 = c + (u + v * f) * d;\r\n                        }\r\n                        else {\r\n                            a4 = (a + g) * f + h;\r\n                            a5 = (f + u) * c + v * d;\r\n                        }\r\n\r\n                        // Evaluate new quadratic coefficients\r\n                        b1 = -(K[N - 1] / p[N]);\r\n                        b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\r\n                        c1 = v * b2 * a1;\r\n                        c2 = b1 * a7;\r\n                        c3 = b1 * b1 * a3;\r\n                        c4 = -(c2 + c3) + c1;\r\n                        temp = -c4 + a5 + b1 * a4;\r\n                        if(temp != 0.0) {\r\n                            iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\r\n                            iPar.b = v * (1.0 + c4 / temp);\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function Quad_ak1(a, b1, c, iPar) {\r\n                    // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\r\n                    // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\r\n                    // zeros are real and both zeros are complex. The smaller real zero is found directly from\r\n                    // the product of the zeros c/a.\r\n\r\n                    // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\r\n\r\n                    var b, d, e;\r\n                    iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\r\n\r\n                    if(a == 0) {\r\n                        iPar.sr = ((b1 != 0) ? -(c / b1) : iPar.sr);\r\n                        return;\r\n                    }\r\n                    if(c == 0) {\r\n                        iPar.lr = -(b1 / a);\r\n                        return;\r\n                    }\r\n\r\n                    // Compute discriminant avoiding overflow\r\n                    b = b1 / 2.0;\r\n                    if(Math.abs(b) < Math.abs(c)) {\r\n                        e = ((c >= 0) ? a : -a);\r\n                        e = -e + b * (b / Math.abs(c));\r\n                        d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\r\n                    }\r\n                    else {\r\n                        e = -((a / b) * (c / b)) + 1.0;\r\n                        d = Math.sqrt(Math.abs(e)) * (Math.abs(b));\r\n                    }\r\n\r\n                    if(e >= 0) {\r\n                        // Real zeros\r\n                        d = ((b >= 0) ? -d : d);\r\n                        iPar.lr = (-b + d) / a;\r\n                        iPar.sr = ((iPar.lr != 0) ? (c / (iPar.lr)) / a : iPar.sr);\r\n                    }\r\n                    else {\r\n                        // Complex conjugate zeros\r\n                        iPar.lr = iPar.sr = -(b / a);\r\n                        iPar.si = Math.abs(d / a);\r\n                        iPar.li = -(iPar.si);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\r\n                    // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\r\n                    // zeros are equimodular or nearly so.\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\r\n                    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\r\n\r\n                    // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\r\n                    var qPar = new Object(),\r\n                            ee, mp, omp, relstp, t, u, ui, v, vi, zm,\r\n                            i, j = 0, tFlag, triedFlag = 0;   // Integer variables\r\n\r\n                    iPar.NZ = 0;// Number of zeros found\r\n                    u = uu; // uu and vv are coefficients of the starting quadratic\r\n                    v = vv;\r\n\r\n                    do {\r\n                        qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                        Quad_ak1(1.0, u, v, qPar);\r\n                        iPar.szr = qPar.sr;\r\n                        iPar.szi = qPar.si;\r\n                        iPar.lzr = qPar.lr;\r\n                        iPar.lzi = qPar.li;\r\n\r\n                        // Return if roots of the quadratic are real and not close to multiple or nearly\r\n                        // equal and of opposite sign.\r\n                        if(Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))\r\n                            break;\r\n\r\n                        // Evaluate polynomial by quadratic synthetic division\r\n\r\n                        QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n\r\n                        mp = Math.abs(-((iPar.szr) * (sdPar.b)) + (sdPar.a)) + Math.abs((iPar.szi) * (sdPar.b));\r\n\r\n                        // Compute a rigorous bound on the rounding error in evaluating p\r\n\r\n                        zm = Math.sqrt(Math.abs(v));\r\n                        ee = 2.0 * Math.abs(qp[0]);\r\n                        t = -((iPar.szr) * (sdPar.b));\r\n\r\n                        for(i = 1; i < N; i++) {\r\n                            ee = ee * zm + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        ee = ee * zm + Math.abs(t + sdPar.a);\r\n                        ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs((sdPar.a) + t) + zm * Math.abs((sdPar.b)))) * DBL_EPSILON;\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\r\n                        if(mp <= 20.0 * ee) {\r\n                            iPar.NZ = 2;\r\n                            break;\r\n                        }\r\n\r\n                        j++;\r\n                        // Stop iteration after 20 steps\r\n                        if(j > 20)\r\n                            break;\r\n                        if(j >= 2) {\r\n                            if((relstp <= 0.01) && (mp >= omp) && (!triedFlag)) {\r\n                                // A cluster appears to be stalling the convergence. Five fixed shift\r\n                                // steps are taken with a u, v close to the cluster.\r\n                                relstp = ((relstp < DBL_EPSILON) ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp));\r\n                                u -= u * relstp;\r\n                                v += v * relstp;\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                for(i = 0; i < 5; i++) {\r\n                                    tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                                    nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                                }\r\n\r\n                                triedFlag = 1;\r\n                                j = 0;\r\n\r\n                            }\r\n                        }\r\n                        omp = mp;\r\n\r\n                        // Calculate next K polynomial and new u and v\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vi = sdPar.b;\r\n\r\n                        // If vi is zero, the iteration is not converging\r\n                        if(vi != 0) {\r\n                            relstp = Math.abs((-v + vi) / vi);\r\n                            u = ui;\r\n                            v = vi;\r\n                        }\r\n                    }\r\n                    while(vi != 0);\r\n                    return;\r\n                }\r\n\r\n                function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\r\n                    // Variable-shift H-polynomial iteration for a real zero\r\n                    // sss\t- starting iterate = sdPar.a\r\n                    // NZ\t\t- number of zeros found = iPar.NZ\r\n                    // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\r\n\r\n                    var ee, kv, mp, ms, omp, pv, s, t,\r\n                            dumFlag, i, j, nm1 = N - 1;   // Integer variables\r\n\r\n                    iPar.NZ = j = dumFlag = 0;\r\n                    s = sdPar.a;\r\n\r\n                    for(; ; ) {\r\n                        pv = p[0];\r\n\r\n                        // Evaluate p at s\r\n                        qp[0] = pv;\r\n                        for(i = 1; i < NN; i++) {\r\n                            qp[i] = pv = pv * s + p[i];\r\n                        }\r\n                        mp = Math.abs(pv);\r\n\r\n                        // Compute a rigorous bound on the error in evaluating p\r\n                        ms = Math.abs(s);\r\n                        ee = 0.5 * Math.abs(qp[0]);\r\n                        for(i = 1; i < NN; i++) {\r\n                            ee = ee * ms + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than\r\n                        // 20 times this bound\r\n                        if(mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\r\n                            iPar.NZ = 1;\r\n                            iPar.szr = s;\r\n                            iPar.szi = 0.0;\r\n                            break;\r\n                        }\r\n                        j++;\r\n                        // Stop iteration after 10 steps\r\n                        if(j > 10)\r\n                            break;\r\n\r\n                        if(j >= 2) {\r\n                            if((Math.abs(t) <= 0.001 * Math.abs(-t + s)) && (mp > omp)) {\r\n                                // A cluster of zeros near the real axis has been encountered.\r\n                                // Return with iFlag set to initiate a quadratic iteration.\r\n                                dumFlag = 1;\r\n                                iPar.a = s;\r\n                                break;\r\n                            } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\r\n                        } //End if (j >= 2)\r\n\r\n                        // Return if the polynomial value has increased significantly\r\n                        omp = mp;\r\n\r\n                        // Compute t, the next polynomial and the new iterate\r\n                        qk[0] = kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            qk[i] = kv = kv * s + K[i];\r\n                        }\r\n\r\n                        if(Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\r\n                            // Use the scaled form of the recurrence if the value of K at s is non-zero\r\n                            t = -(pv / kv);\r\n                            K[0] = qp[0];\r\n                            for(i = 1; i < N; i++) {\r\n                                K[i] = t * qk[i - 1] + qp[i];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Use unscaled form\r\n                            K[0] = 0.0;\r\n                            for(i = 1; i < N; i++)\r\n                                K[i] = qk[i - 1];\r\n                        }\r\n\r\n                        kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            kv = kv * s + K[i];\r\n                        }\r\n                        t = ((Math.abs(kv) > (Math.abs(K[nm1]) * 10.0 * DBL_EPSILON)) ? -(pv / kv) : 0.0);\r\n                        s += t;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\r\n\r\n                    // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\r\n                    // quadratic case. Initiates one of the variable shift iterations and returns with the\r\n                    // number of zeros found.\r\n                    // L2\tlimit of fixed shift steps\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // NZ\tnumber of zeros found\r\n                    var sdPar = new Object(), // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\r\n                            calcPar = new Object(),\r\n                            // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\r\n\r\n                            qk = new Array(MDP1),\r\n                            svk = new Array(MDP1),\r\n                            a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv,\r\n                            fflag, i, iFlag = 1, j, spass, stry, tFlag, vpass, vtry;     // Integer variables\r\n\r\n                    iPar.NZ = 0;\r\n                    betav = betas = 0.25;\r\n                    oss = sr;\r\n                    ovv = v;\r\n\r\n                    //Evaluate polynomial by synthetic division\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                    a = sdPar.a;\r\n                    b = sdPar.b;\r\n                    calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\r\n                    tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                    for(j = 0; j < L2; j++) {\r\n                        fflag = 1;\r\n\r\n                        // Calculate next K polynomial and estimate v\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                        // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\r\n                        // sdPar.a = ui, sdPar.b = vi\r\n                        newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vv = vi = sdPar.b;\r\n\r\n                        // Estimate s\r\n                        ss = ((K[N - 1] != 0.0) ? -(p[N] / K[N - 1]) : 0.0);\r\n                        ts = tv = 1.0;\r\n\r\n                        if((j != 0) && (tFlag != 3)) {\r\n                            // Compute relative measures of convergence of s and v sequences\r\n                            tv = ((vv != 0.0) ? Math.abs((vv - ovv) / vv) : tv);\r\n                            ts = ((ss != 0.0) ? Math.abs((ss - oss) / ss) : ts);\r\n\r\n                            // If decreasing, multiply the two most recent convergence measures\r\n                            tvv = ((tv < otv) ? tv * otv : 1.0);\r\n                            tss = ((ts < ots) ? ts * ots : 1.0);\r\n\r\n                            // Compare with convergence criteria\r\n                            vpass = ((tvv < betav) ? 1 : 0);\r\n                            spass = ((tss < betas) ? 1 : 0);\r\n\r\n                            if((spass) || (vpass)) {\r\n\r\n                                // At least one sequence has passed the convergence test.\r\n                                // Store variables before iterating\r\n\r\n                                for(i = 0; i < N; i++) {\r\n                                    svk[i] = K[i];\r\n                                }\r\n                                s = ss;\r\n\r\n                                // Choose iteration according to the fastest converging sequence\r\n\r\n                                stry = vtry = 0;\r\n\r\n                                for(; ; ) {\r\n                                    if((fflag && ((fflag = 0) == 0)) && ((spass) && (!vpass || (tss < tvv)))) {\r\n                                        ;// Do nothing. Provides a quick \"short circuit\".\r\n                                    }\r\n                                    else {\r\n                                        QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\r\n                                        a = sdPar.a;\r\n                                        b = sdPar.b;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Quadratic iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        iFlag = vtry = 1;\r\n                                        betav *= 0.25;\r\n\r\n                                        // Try linear iteration if it has not been tried and the s sequence is converging\r\n                                        if(stry || (!spass)) {\r\n                                            iFlag = 0;\r\n                                        }\r\n                                        else {\r\n                                            for(i = 0; i < N; i++)\r\n                                                K[i] = svk[i];\r\n                                        }\r\n                                    }\r\n                                    //fflag = 0;\r\n                                    if(iFlag != 0) {\r\n                                        // Use sdPar for passing in s instead of defining a brand-new variable.\r\n                                        // sdPar.a = s\r\n                                        sdPar.a = s;\r\n                                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\r\n                                        s = sdPar.a;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Linear iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        stry = 1;\r\n                                        betas *= 0.25;\r\n\r\n                                        if(iFlag != 0) {\r\n                                            // If linear iteration signals an almost double real zero, attempt quadratic iteration\r\n                                            ui = -(s + s);\r\n                                            vi = s * s;\r\n                                            continue;\r\n\r\n                                        }\r\n                                    }\r\n\r\n                                    // Restore variables\r\n                                    for(i = 0; i < N; i++)\r\n                                        K[i] = svk[i];\r\n\r\n                                    // Try quadratic iteration if it has not been tried and the v sequence is converging\r\n                                    if(!vpass || vtry)\r\n                                        break;\t\t// Break out of infinite for loop\r\n\r\n                                }\r\n\r\n                                // Re-compute qp and scalar values to continue the second stage\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                a = sdPar.a;\r\n                                b = sdPar.b;\r\n\r\n                                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n                            }\r\n                        }\r\n                        ovv = vv;\r\n                        oss = ss;\r\n                        otv = tv;\r\n                        ots = ts;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function rpSolve(degPar, p, zeror, zeroi) {\r\n                    var N = degPar.Degree,\r\n                            RADFAC = 3.14159265358979323846 / 180, // Degrees-to-radians conversion factor = PI/180\r\n                            LB2 = Math.LN2, // Dummy variable to avoid re-calculating this value in loop below\r\n                            MDP1 = degPar.Degree + 1,\r\n                            K = new Array(MDP1),\r\n                            pt = new Array(MDP1),\r\n                            qp = new Array(MDP1),\r\n                            temp = new Array(MDP1),\r\n                            // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\r\n                            qPar = new Object(),\r\n                            // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\r\n                            Fxshfr_Par = new Object(),\r\n                            bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm,\r\n                            aa, bb, cc, sr, t, u, xxx,\r\n                            j, jj, l, NM1, NN, zerok;// Integer variables\r\n\r\n                    // Calculate the machine epsilon and store in the variable DBL_EPSILON.\r\n                    // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\r\n                    aa = 1.0;\r\n                    do {\r\n                        DBL_EPSILON = aa;\r\n                        aa /= 2;\r\n                        bb = 1.0 + aa;\r\n                    }\r\n                    while(bb > 1.0);\r\n\r\n                    var LO = Number.MIN_VALUE / DBL_EPSILON,\r\n                            cosr = Math.cos(94.0 * RADFAC), // = -0.069756474\r\n                            sinr = Math.sin(94.0 * RADFAC), // = 0.99756405\r\n                            xx = Math.sqrt(0.5), // = 0.70710678\r\n                            yy = -xx;\r\n\r\n                    Fxshfr_Par.NZ = j = 0;\r\n                    Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\r\n\r\n                    // Remove zeros at the origin, if any\r\n                    while(p[N] == 0) {\r\n                        zeror[j] = zeroi[j] = 0;\r\n                        N--;\r\n                        j++;\r\n                    }\r\n                    NN = N + 1;\r\n\r\n                    // >>>>> Begin Main Loop <<<<<\r\n                    while(N >= 1) { // Main loop\r\n                        // Start the algorithm for one zero\r\n                        if(N <= 2) {\r\n                            // Calculate the final zero or pair of zeros\r\n                            if(N < 2) {\r\n                                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\r\n                                zeroi[degPar.Degree - 1] = 0;\r\n                            }\r\n                            else {\r\n                                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                                Quad_ak1(p[0], p[1], p[2], qPar);\r\n                                zeror[degPar.Degree - 2] = qPar.sr;\r\n                                zeroi[degPar.Degree - 2] = qPar.si;\r\n                                zeror[degPar.Degree - 1] = qPar.lr;\r\n                                zeroi[degPar.Degree - 1] = qPar.li;\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        // Find the largest and smallest moduli of the coefficients\r\n                        moduli_max = 0.0;\r\n                        moduli_min = Number.MAX_VALUE;\r\n\r\n                        for(i = 0; i < NN; i++) {\r\n                            x = Math.abs(p[i]);\r\n                            if(x > moduli_max)\r\n                                moduli_max = x;\r\n                            if((x != 0) && (x < moduli_min))\r\n                                moduli_min = x;\r\n                        }\r\n\r\n                        // Scale if there are large or very small coefficients\r\n                        // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\r\n                        // is done to avoid overflow and to avoid undetected underflow interfering with the\r\n                        // convergence criterion.\r\n                        // The factor is a power of the base.\r\n                        sc = LO / moduli_min;\r\n\r\n                        if(((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (Number.MAX_VALUE / sc >= moduli_max))) {\r\n                            sc = ((sc == 0) ? Number.MIN_VALUE : sc);\r\n                            l = Math.floor(Math.log(sc) / LB2 + 0.5);\r\n                            factor = Math.pow(2.0, l);\r\n                            if(factor != 1.0) {\r\n                                for(i = 0; i < NN; i++)\r\n                                    p[i] *= factor;\r\n                            }\r\n                        }\r\n\r\n                        // Compute lower bound on moduli of zeros\r\n                        for(var i = 0; i < NN; i++)\r\n                            pt[i] = Math.abs(p[i]);\r\n                        pt[N] = -(pt[N]);\r\n                        NM1 = N - 1;\r\n\r\n                        // Compute upper estimate of bound\r\n                        x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\r\n\r\n                        if(pt[NM1] != 0) {\r\n                            // If Newton step at the origin is better, use it\r\n                            xm = -pt[N] / pt[NM1];\r\n                            x = ((xm < x) ? xm : x);\r\n                        }\r\n\r\n                        // Chop the interval (0, x) until ff <= 0\r\n                        xm = x;\r\n                        do {\r\n                            x = xm;\r\n                            xm = 0.1 * x;\r\n                            ff = pt[0];\r\n                            for(var i = 1; i < NN; i++) {\r\n                                ff = ff * xm + pt[i];\r\n                            }\r\n                        }\r\n                        while(ff > 0); // End do-while loop\r\n\r\n                        dx = x;\r\n                        // Do Newton iteration until x converges to two decimal places\r\n\r\n                        do {\r\n                            df = ff = pt[0];\r\n                            for(var i = 1; i < N; i++) {\r\n                                ff = x * ff + pt[i];\r\n                                df = x * df + ff;\r\n                            } // End for i\r\n                            ff = x * ff + pt[N];\r\n                            dx = ff / df;\r\n                            x -= dx;\r\n                        }\r\n                        while(Math.abs(dx / x) > 0.005); // End do-while loop\r\n\r\n                        bnd = x;\r\n\r\n                        // Compute the derivative as the initial K polynomial and do 5 steps with no shift\r\n                        for(var i = 1; i < N; i++)\r\n                            K[i] = (N - i) * p[i] / N;\r\n                        K[0] = p[0];\r\n                        aa = p[N];\r\n                        bb = p[NM1];\r\n                        zerok = ((K[NM1] == 0) ? 1 : 0);\r\n\r\n                        for(jj = 0; jj < 5; jj++) {\r\n                            cc = K[NM1];\r\n                            if(zerok) {\r\n                                // Use unscaled form of recurrence\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = K[j - 1];\r\n                                } // End for i\r\n                                K[0] = 0;\r\n                                zerok = ((K[NM1] == 0) ? 1 : 0);\r\n                            }\r\n                            else {\r\n                                // Used scaled form of recurrence if value of K at 0 is nonzero\r\n                                t = -aa / cc;\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = t * K[j - 1] + p[j];\r\n                                } // End for i\r\n                                K[0] = p[0];\r\n                                zerok = ((Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0) ? 1 : 0);\r\n                            }\r\n                        }\r\n\r\n                        // Save K for restarts with new shifts\r\n                        for(var i = 0; i < N; i++)\r\n                            temp[i] = K[i];\r\n\r\n                        // Loop to select the quadratic corresponding to each new shift\r\n                        for(jj = 1; jj <= 20; jj++) {\r\n\r\n                            // Quadratic corresponds to a double shift to a non-real point and its\r\n                            // complex conjugate. The point has modulus BND and amplitude rotated\r\n                            // by 94 degrees from the previous shift.\r\n\r\n                            xxx = -(sinr * yy) + cosr * xx;\r\n                            yy = sinr * xx + cosr * yy;\r\n                            xx = xxx;\r\n                            sr = bnd * xx;\r\n                            u = -(2.0 * sr);\r\n\r\n                            // Second stage calculation, fixed quadratic\r\n                            Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\r\n\r\n                            if(Fxshfr_Par.NZ != 0) {\r\n                                // The second stage jumps directly to one of the third stage iterations and\r\n                                // returns here if successful. Deflate the polynomial, store the zero or\r\n                                // zeros, and return to the main algorithm.\r\n                                j = degPar.Degree - N;\r\n                                zeror[j] = Fxshfr_Par.szr;\r\n                                zeroi[j] = Fxshfr_Par.szi;\r\n                                NN = NN - Fxshfr_Par.NZ;\r\n                                N = NN - 1;\r\n                                for(var i = 0; i < NN; i++)\r\n                                    p[i] = qp[i];\r\n                                if(Fxshfr_Par.NZ != 1) {\r\n                                    zeror[j + 1] = Fxshfr_Par.lzr;\r\n                                    zeroi[j + 1] = Fxshfr_Par.lzi;\r\n                                }\r\n                                break;\r\n                            }\r\n                            else {\r\n                                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\r\n                                for(var i = 0; i < N; i++) {\r\n                                    K[i] = temp[i];\r\n                                }\r\n                            }\r\n                        }\r\n                        // Return with failure if no convergence with 20 shifts\r\n                        if(jj > 20) {\r\n                            degPar.Degree -= N;\r\n                            break;\r\n                        }\r\n                    }\r\n                    // >>>>> End Main Loop <<<<<\r\n                    return;\r\n                }\r\n                //--\x3e End Jenkins-Traub\r\n                rpSolve(degreePar, p, zeror, zeroi);\r\n\r\n                var l = zeroi.length;\r\n                //format the output\r\n                for(i = 0; i < l; i++) {\r\n                    // We round the imaginary part to avoid having something crazy like 5.67e-16.\r\n                    var img = round(zeroi[i], decp + 8),\r\n                            real = round(zeror[i], decp + 8);\r\n                    // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\r\n                    // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \r\n                    // the original otherwise the rounding was worth it.\r\n                    real = decp - String(real).length > 2 ? real : zeror[i];\r\n                    var sign = img < 0 ? '-' : '';\r\n\r\n                    // Remove the zeroes\r\n                    if(real === 0) {\r\n                        real = '';\r\n                    }\r\n                    if(img === 0) {\r\n                        img = '';\r\n                    }\r\n\r\n                    // Remove 1 as the multiplier and discard imaginary part if there isn't one.\r\n                    img = Math.abs(img) === 1 ? sign + 'i' : (img ? img + '*i' : '');\r\n\r\n                    var num = (real && img) ? real + '+' + img : real + img;\r\n                    zeror[i] = num.replace(/\\+\\-/g, '-');\r\n                }\r\n                return zeror;\r\n            }\r\n        },\r\n        roots: function (symbol) {\r\n\r\n            if(symbol.isConstant(true, true)) {\r\n                return core.Utils.nroots(symbol);\r\n            }\r\n            var roots = __.proots(symbol).map(function (x) {\r\n                return _.parse(x);\r\n            });\r\n            return core.Vector.fromArray(roots);\r\n        },\r\n        froot: function (f, guess, dx) {\r\n            var newtonraph = function (xn) {\r\n                var mesh = 1e-12,\r\n                        // If the derivative was already provided then don't recalculate.\r\n                        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\r\n                        // If the function was passed in as a function then don't recalculate.\r\n                        fn = f instanceof Function ? f : core.Utils.build(f),\r\n                        max = 10000,\r\n                        done = false,\r\n                        safety = 0;\r\n                while(!done) {\r\n                    var x = xn - (fn(xn) / df(xn));\r\n                    //absolute values for both x & xn ensures that we indeed have the radius    \r\n                    var r = Math.abs(x) - Math.abs(xn),\r\n                            delta = Math.abs(r);\r\n                    xn = x;\r\n\r\n                    if(delta < mesh)\r\n                        done = true;\r\n                    else if(safety > max) {\r\n                        xn = null;\r\n                        done = true;\r\n                    }\r\n\r\n                    safety++;\r\n                }\r\n                return xn;\r\n            };\r\n            return newtonraph(Number(guess));\r\n        },\r\n        quad: function (a, b, c) {\r\n            var q = function (a, b, c, sign) {\r\n                return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\r\n            };\r\n            return [q(a, b, c, 1), q(a, b, c, -1)];\r\n        },\r\n        sumProd: function (a, b) {\r\n            return __.quad(-b, a, -1).map(function (x) {\r\n                return x.invert();\r\n            });\r\n        },\r\n        coeffs: function (symbol, wrt, coeffs) {\r\n            wrt = String(wrt);\r\n            symbol = _.expand(symbol);\r\n            coeffs = coeffs || [new Symbol(0)];\r\n            //we cannot get coeffs for group EX\r\n            if(symbol.group === EX && symbol.contains(wrt, true))\r\n                _.error('Unable to get coefficients using expression ' + symbol.toString());\r\n            var vars = variables(symbol);\r\n            if(vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\r\n                var a = new Polynomial(symbol).coeffs.map(function (x) {\r\n                    return new Symbol(x);\r\n                });\r\n\r\n                for(var i = 0, l = a.length; i < l; i++) {\r\n                    var coeff = a[i],\r\n                            e = coeffs[i];\r\n                    if(e)\r\n                        coeff = _.add(e, coeff);\r\n                    coeffs[i] = coeff; //transfer it all over\r\n                }\r\n            }\r\n            else {\r\n                if(!wrt)\r\n                    _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\r\n                //if the variable isn't part of this polynomial then we're looking at x^0\r\n\r\n                if(vars.indexOf(wrt) === -1) {\r\n                    coeffs[0] = _.add(symbol, coeffs[0]);\r\n                }\r\n                else {\r\n                    coeffs = coeffs || [new Symbol(0)];\r\n                    if(symbol.group === CB) {\r\n                        var s = symbol.symbols[wrt];\r\n                        if(!s)\r\n                            _.error('Expression is not a polynomial!');\r\n                        var p = Number(s.power);\r\n                        coeff = _.divide(symbol.clone(), s.clone());\r\n                        if(coeff.contains(wrt, true) || p < 0 || !isInt(p))\r\n                            _.error('Expression is not a polynomial!');\r\n                        var e = coeffs[p];\r\n                        if(e)\r\n                            coeff = _.add(e, coeff);\r\n                        coeffs[p] = coeff;\r\n                    }\r\n                    else if(symbol.group === CP) {\r\n                        symbol.each(function (x) {\r\n                            __.coeffs(x.clone(), wrt, coeffs);\r\n                        }, true);\r\n                    }\r\n                }\r\n            }\r\n            //fill holes\r\n            for(var i = 0, l = coeffs.length; i < l; i++)\r\n                if(typeof coeffs[i] === 'undefined')\r\n                    coeffs[i] = new Symbol(0);\r\n\r\n            return coeffs;\r\n        },\r\n        /**\r\n         * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n         * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n         * @param {Symbol} e\r\n         * @param {String} for_variable\r\n         * @param {Array} powers\r\n         * @returns {Array} An array of the powers\r\n         */\r\n        //assumes you've already verified that it's a polynomial\r\n        polyPowers: function (e, for_variable, powers) {\r\n            powers = powers || [];\r\n            var g = g = e.group;\r\n            if(g === PL && for_variable === e.value) {\r\n                powers = powers.concat(keys(e.symbols));\r\n            }\r\n            else if(g === CP) {\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s];\r\n                    var g = symbol.group, v = symbol.value;\r\n                    if(g === S && for_variable === v)\r\n                        powers.push(symbol.power);\r\n                    else if(g === PL || g === CP)\r\n                        powers = __.polyPowers(symbol, for_variable, powers);\r\n                    else if(g === CB && symbol.contains(for_variable)) {\r\n                        var t = symbol.symbols[for_variable];\r\n                        if(t)\r\n                            powers.push((t.power));\r\n                    }\r\n                    else if(g === N || for_variable !== v)\r\n                        powers.push(0);\r\n                }\r\n            }\r\n            else if(g === CB && e.contains(for_variable)) {\r\n                powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\r\n            }\r\n            return core.Utils.arrayUnique(powers).sort();\r\n        },\r\n        //The factor object\r\n        Factor: {\r\n            //splits the symbol in symbol and constant\r\n            split: function (symbol) {\r\n                var c = new Symbol(1); //the constants part\r\n                var s = new Symbol(1); //the symbolic part\r\n                __.Factor.factor(symbol, new Factors()).each(function (x) {\r\n                    var t = _.parse(x);\r\n                    if(x.isConstant(true)) {\r\n                        c = _.multiply(c, t);\r\n                    }\r\n                    else {\r\n                        s = _.multiply(s, t);\r\n                    }\r\n                });\r\n                return [c, s];\r\n            },\r\n            mix: function (o, include_negatives) {\r\n                var factors = keys(o);\r\n                var l = factors.length;\r\n                var m = [];//create a row which we'r going to be mixing\r\n                for(var i = 0; i < l; i++) {\r\n                    var factor = factors[i],\r\n                            p = o[factor];\r\n                    var ll = m.length;\r\n                    for(var j = 0; j < ll; j++) {\r\n                        var t = m[j] * factor;\r\n                        m.push(t);\r\n                        if(include_negatives)\r\n                            m.push(-t);\r\n                    }\r\n\r\n                    for(var j = 1; j <= p; j++)\r\n                        m.push(Math.pow(factor, j));\r\n                }\r\n                return m;\r\n            },\r\n            //TODO: this method is to replace common factoring\r\n            common: function (symbol, factors) {\r\n                try {\r\n                    if(symbol.group === CP) {\r\n                        //this may have the unfortunate side effect of expanding and factoring again\r\n                        //to only end up with the same result. \r\n                        //TODO: try to avoid this\r\n                        //collect the symbols and sort to have the longest first. Thinking is that the longest terms \r\n                        //has to contain the variable in order for it to be factorable\r\n                        var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\r\n                            return (b.length || 1) - (a.length || 1);\r\n                        });\r\n\r\n                        var map = {}; //create a map of common factors\r\n                        var coeffs = [];\r\n                        for(var i = 0; i < symbols.length; i++) {\r\n                            var sym = symbols[i];\r\n                            coeffs.push(sym.multiplier.clone());\r\n                            sym.each(function (x) {\r\n                                var p = Number(x.power);\r\n                                //This check exits since we have a symbolic power.\r\n                                //For the future... think about removing this check and modify for symbolic powers\r\n                                if(isNaN(p))\r\n                                    throw new Error('exiting');\r\n                                //loop through the symbols and lump together common terms\r\n                                if(x.value in map) {\r\n                                    if(p < map[x.value][0])\r\n                                        map[x.value][0] = p;\r\n                                    map[x.value][1].push(x);\r\n                                }\r\n                                else\r\n                                    map[x.value] = [p, [x]];\r\n                            });\r\n                        }\r\n                        //the factor\r\n                        var factor = new Symbol(1);\r\n                        for(var x in map) {\r\n                            //if this factor is found in all terms since the length of \r\n                            //matching variable terms matches the number of original terms\r\n                            if(map[x][1].length === symbols.length) {\r\n                                //generate a symbol and multiply into the factor\r\n                                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\r\n                            }\r\n                        }\r\n                        //get coefficient factor\r\n                        var c = core.Math2.QGCD.apply(null, coeffs);\r\n\r\n                        if(!c.equals(1)) {\r\n                            factors.add(new Symbol(c));\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbols[i].multiplier = symbols[i].multiplier.divide(c);\r\n                            }\r\n                        }\r\n\r\n                        //if we actuall found any factors\r\n                        if(!factor.equals(1)) {\r\n                            factors.add(factor);\r\n                            symbol = new Symbol(0);\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            zeroes: function (symbol, factors) {\r\n                var exit = function () {\r\n                    throw new core.exceptions.ValueLimitExceededError('Exiting');\r\n                };\r\n                try {\r\n                    var vars, term, sum, p, e;\r\n                    symbol = _.expand(symbol.clone());\r\n                    e = symbol.toString();\r\n                    vars = variables(symbol);\r\n\r\n                    sum = new Symbol(0);\r\n\r\n                    var terms = [];\r\n                    var powers = [];\r\n\r\n                    //start setting each variable to zero\r\n                    for(var i = 0, l = vars.length; i < vars.length; i++) {\r\n                        var subs = {};\r\n                        //we want to create a subs object with all but the current variable set to zero\r\n                        for(var j = 0; j < l; j++)\r\n                            if(i !== j) //make sure we're not looking at the same variable\r\n                                subs[vars[j]] = 0;\r\n                        term = _.parse(e, subs);\r\n                        var tp = term.power;\r\n                        //the temporary power has to be an integer as well\r\n                        if(!isInt(tp))\r\n                            exit();\r\n                        terms.push(term);\r\n                        powers.push(term.power);\r\n                    }\r\n\r\n                    //get the gcd. This will be the p in (a^n+b^m)^p\r\n                    //if the gcd equals 1 meaning n = m then we need a tie breakder\r\n                    if(core.Utils.allSame(powers)) {\r\n                        //get p given x number of terms\r\n                        var n_terms = symbol.length;\r\n                        //the number of zeroes determines\r\n                        var n_zeroes = terms.length;\r\n                        if(n_zeroes === 2) {\r\n                            p = new Frac(powers[0] / (n_terms - 1));\r\n                        }\r\n                        if(n_zeroes === 3) {\r\n                            p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\r\n                        }\r\n                        /*\r\n                         //get the lowest possible power\r\n                         //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n                         symbol.each(function(x) {\r\n                         if(x.group === CB)\r\n                         x.each(function(y) {\r\n                         if(!p || y.power.lessThan(p))\r\n                         //p = Number(y.power);\r\n                         p = y.power;\r\n                         });\r\n                         else if(!p || x.power.lessThan(p))\r\n                         //p = Number(x.power);\r\n                         p = x.power;\r\n                         });\r\n                         */\r\n                    }\r\n                    else\r\n                        //p is just the gcd of the powers\r\n                        p = core.Math2.QGCD.apply(null, powers);\r\n\r\n                    //if we don't have an integer then exit\r\n                    if(!isInt(p))\r\n                        exit();\r\n\r\n                    //build the factor\r\n                    for(var i = 0; i < terms.length; i++) {\r\n                        var t = terms[i];\r\n                        var n = t.power.clone().divide(p);\r\n                        t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\r\n                        t.power = p.clone();\r\n                        sum = _.add(sum, t);\r\n                    }\r\n\r\n                    //by now we have the factor of zeroes. We'll know if we got it right because \r\n                    //we'll get a remainder of zero each time we divide by it\r\n                    if(sum.group !== CP)\r\n                        return symbol; //nothing to do\r\n\r\n                    while(true) {\r\n                        var d = __.div(symbol.clone(), sum.clone());\r\n                        if(d[1].equals(0)) {\r\n                            symbol = d[0];\r\n                            factors.add(sum.clone());\r\n                            if(symbol.equals(1)) //we've reached 1 so done.\r\n                                break;\r\n                        }\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                catch(e) {\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            },\r\n            factor: function (symbol, factors) {\r\n                // Don't try to factor constants\r\n                if(symbol.isConstant()) {\r\n                    return core.Math2.factor(symbol);\r\n                }\r\n\r\n                var _symbol = _.parse(symbol);\r\n                var retval = __.Factor._factor(_symbol, factors);\r\n                if(retval.equals(symbol)) {\r\n                    return retval;\r\n                }\r\n\r\n                if(retval.group === CB) {\r\n                    var t = new Symbol(1);\r\n                    var p = _.parse(retval.power);\r\n                    //store the multiplier and strip it\r\n                    var m = _.parse(retval.multiplier);\r\n\r\n                    retval.toUnitMultiplier();\r\n\r\n                    /* \r\n                     * NOTE: for sign issues with factor START DEBUGGING HERE\r\n                     */\r\n                    //move the sign to t\r\n                    if(retval.multiplier.lessThan(0)) {\r\n                        t.negate();\r\n                        retval.negate();\r\n                    }\r\n\r\n                    retval.each(function (x) {\r\n                        // Related to #566. Since the symbol's group may not have been properly\r\n                        // updated, it's easier to just parse the symbol and have the parser \r\n                        // do the update for us.\r\n                        var factored = _.parse(__.Factor._factor(x));\r\n\r\n                        if(factored.group === CB) {\r\n                            // Include the multiplier\r\n                            m = _.multiply(m, Symbol.create(factored.multiplier));\r\n                            factored.each(function (y) {\r\n                                var _factored = _.parse(__.Factor._factor(y));\r\n                                t = _.multiply(t, _factored);\r\n                                if(_factored.group === CB) {\r\n                                    m = _.multiply(m, Symbol.create(_factored.multiplier));\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            t = _.multiply(t, factored);\r\n                        }\r\n                    });\r\n\r\n                    //put back the multiplier and power\r\n                    retval = _.pow(_.multiply(m, t), p);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            quadFactor: function (symbol, factors) {\r\n                if(symbol.isPoly() && __.degree(symbol.equals(2))) {\r\n                    //We've  already checked that we're dealing with a polynomial\r\n                    var v = core.Utils.variables(symbol)[0]; //get the variable\r\n                    var coeffs = __.coeffs(symbol, v);\r\n                    //factor the lead coefficient\r\n                    var cf = __.Factor._factor(coeffs[2].clone());\r\n                    //check if we have factors\r\n                    if(cf.group === CB) {\r\n                        var symbols = cf.collectSymbols();\r\n                        //if the factors are greater than 2 we're done so exit\r\n                        if(symbols.length > 2)\r\n                            return symbol;\r\n                        //if we have two factors then attempt to factor the polynomial\r\n                        //let the factors be f1 and f1\r\n                        //let the factors be (ax+b)(cx+d)\r\n                        //let the coefficients be c1x^2+c2x+c3\r\n                        //then a(x1)+c(x2)=c2 and x1*x2=c3\r\n                        //we can solve for x1 and x2\r\n                        var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\r\n                        var b = _.parse(coeffs[1]).negate();\r\n                        var a = _.parse(symbols[1]);\r\n                        //solve the system\r\n                        var root = __.quad(a, b, c).filter(function (x) {\r\n                            if(core.Utils.isInt(x))\r\n                                return x;\r\n                        });\r\n                        //if we have one root then find the other one by dividing the constant\r\n                        if(root.length === 1) {\r\n                            var root1 = root[0];\r\n                            var root2 = _.divide(coeffs[0], _.parse(root1));\r\n                            if(core.Utils.isInt(root2)) {\r\n                                //we found them both\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            cubeFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var symbols = symbol.collectSymbols();\r\n                    // The symbol should be in the form of a^3+-b^3. The length\r\n                    // should therefore only be two. If it's any different from this\r\n                    // then we're done\r\n                    if(symbols.length === 2) {\r\n                        // Store the signs and then strip them from the symbols\r\n                        var sign_a = symbols[0].sign();\r\n                        var a = symbols[0].clone().abs();\r\n                        var sign_b = symbols[1].sign();\r\n                        var b = symbols[1].clone().abs();\r\n                        // Check if they're cube\r\n                        if(a.isCube() && b.isCube()) {\r\n                            // Keep the negative sign on the right, meaning b is always negative.\r\n                            if(sign_a < sign_b) {\r\n                                // Swap the signs and then the values\r\n                                [sign_a, sign_b] = [sign_b, sign_a];\r\n                                [a, b] = [b, a];\r\n                            }\r\n\r\n                            // Get teh roots\r\n                            var m_root_a = _.parse(a.getNth(3));\r\n                            var m_root_b = _.parse(b.getNth(3));\r\n\r\n                            // Remove the cube for both\r\n                            var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\r\n                            var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\r\n\r\n                            if(sign_a === 1 && sign_b === -1) {\r\n                                // Apply difference of cubes rule\r\n                                factors.add(_.parse(format('(({0})-({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                            else if(sign_a === 1 && sign_b === 1) {\r\n                                // Apply sum of cubes rule\r\n                                factors.add(_.parse(format('(({0})+({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            _factor: function (symbol, factors) {\r\n                //some items cannot be factored any further so return those right away\r\n                if(symbol.group === FN) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.group === S && arg.isSimple()) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n                else if(symbol.group === S && symbol.isSimple()) {\r\n                    return symbol;\r\n                }\r\n\r\n                // Expand the symbol to get it in a predictable form. If this step\r\n                // is skipped some factors are missed.\r\n                //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\r\n                if(symbol.group === CP) {\r\n                    symbol.distributeMultiplier(true);\r\n                    var t = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        if((x.group === CP && x.power.greaterThan(1) || x.group === CB))\r\n                            x = _.expand(x);\r\n                        t = _.add(t, x);\r\n                    });\r\n                    t.power = symbol.power;\r\n\r\n                    symbol = t;\r\n                }\r\n\r\n                if(symbol.group === FN && symbol.fname !== 'sqrt') {\r\n                    symbol = core.Utils.evaluate(symbol);\r\n                }\r\n\r\n                //make a copy of the symbol to return if something goes wrong\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    if(symbol.group === CB) {\r\n                        var p = _.parse(symbol.power);\r\n\r\n                        var den_array, num_array, den, num, dfact, nfact;\r\n                        //grab the denominator and strip the multiplier and power. Store them in an array\r\n                        den_array = __.Simplify.strip(symbol.getDenom());\r\n                        num_array = __.Simplify.strip(symbol.getNum());\r\n\r\n                        den = den_array.pop();\r\n                        num = num_array.pop();\r\n\r\n                        //if the numerator equals the symbol then we've hit the simplest form and then we're done\r\n                        if(num.equals(symbol)) {\r\n                            return symbol;\r\n                        }\r\n                        nfact = __.Factor.factor(num);\r\n                        dfact = __.Factor.factor(den);\r\n\r\n                        var n = __.Simplify.unstrip(num_array, nfact);\r\n                        var d = __.Simplify.unstrip(den_array, dfact);\r\n\r\n                        var retval = _.divide(n, d);\r\n\r\n                        return retval;\r\n                    }\r\n                    if(symbol.group === S) {\r\n                        return symbol; //absolutely nothing to do\r\n                    }\r\n\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol.equals(1))\r\n                            return symbol.clone();\r\n                        var ret = core.Math2.factor(symbol);\r\n                        return ret;\r\n                    }\r\n\r\n                    var p = symbol.power.clone();\r\n\r\n                    if(isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\r\n                        var sign = p.sign();\r\n                        symbol.toLinear();\r\n                        factors = factors || new Factors();\r\n                        var map = {};\r\n                        symbol = _.parse(core.Utils.subFunctions(symbol, map));\r\n                        if(keys(map).length > 0) { //it might have functions\r\n                            factors.preAdd = function (factor) {\r\n                                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\r\n                                return ret;\r\n                            };\r\n                        }\r\n\r\n                        //strip the power\r\n                        if(!symbol.isLinear()) {\r\n                            factors.pFactor = symbol.power.toString();\r\n                            symbol.toLinear();\r\n                        }\r\n\r\n                        var vars = variables(symbol);\r\n                        //bypass for imaginary. TODO: find a better solution\r\n                        if(symbol.isImaginary()) {\r\n                            vars.push(core.Settings.IMAGINARY);\r\n                        }\r\n                        var multiVar = vars.length > 1;\r\n\r\n                        //minor optimization. Seems to cut factor time by half in some cases.\r\n                        if(multiVar) {\r\n                            var all_S = true, all_unit = true;\r\n                            symbol.each(function (x) {\r\n                                if(x.group !== S)\r\n                                    all_S = false;\r\n                                if(!x.multiplier.equals(1))\r\n                                    all_unit = false;\r\n                            });\r\n\r\n                            if(all_S && all_unit) {\r\n                                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\r\n                            }\r\n                        }\r\n\r\n                        //factor the coefficients\r\n                        var coeff_factors = new Factors();\r\n\r\n                        symbol = __.Factor.coeffFactor(symbol, coeff_factors);\r\n\r\n                        coeff_factors.each(function (x) {\r\n                            // If the factor was negative but was within a square then it becomes positive\r\n                            if(even(p) && x.lessThan(0)) {\r\n                                x.negate();\r\n                            }\r\n\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        //factor the power\r\n                        var power_factors = new Factors();\r\n                        symbol = __.Factor.powerFactor(symbol, power_factors);\r\n                        power_factors.each(function (x) {\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        if(!multiVar) {\r\n                            //pass in vars[0] for safety\r\n                            var v = vars[0];\r\n\r\n                            symbol = __.Factor.squareFree(symbol, factors, v);\r\n\r\n                            var t_factors = new Factors();\r\n\r\n                            symbol = __.Factor.trialAndError(symbol, t_factors, v);\r\n\r\n                            //generate a symbol based off the last factors\r\n                            var tf_symbol = t_factors.toSymbol();\r\n                            //if nothing was factored then return the factors\r\n                            if(tf_symbol.equals(untouched)) {\r\n                                return tf_symbol;\r\n                            }\r\n\r\n                            for(var x in t_factors.factors) {\r\n                                //store the current factor in t_factor\r\n                                var t_factor = t_factors.factors[x];\r\n                                factors.add(_.pow(t_factor, _.parse(p)));\r\n                            }\r\n                            //if we still don't have a factor and it's quadratic then let's just do a quad factor\r\n                            if(symbol.equals(untouched)) {\r\n                                symbol = __.Factor.quadFactor(symbol, factors);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            // Try sum and difference of cubes\r\n                            symbol = __.Factor.cubeFactor(symbol, factors);\r\n\r\n                            symbol = __.Factor.mfactor(symbol, factors);\r\n\r\n                            //put back the sign of power\r\n                            factors.each(function (x) {\r\n                                if(sign < 0)\r\n                                    x.power.negate();\r\n                            });\r\n                        }\r\n\r\n                        //last minute clean up\r\n                        symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\r\n\r\n                        factors.add(_.pow(symbol, _.parse(p)));\r\n\r\n                        var retval = factors.toSymbol();\r\n\r\n                        return retval;\r\n                    }\r\n\r\n                    return symbol;\r\n                }\r\n                catch(e) {\r\n                    //no need to stop the show because something went wrong :). Just return the unfactored.\r\n                    return untouched;\r\n                }\r\n            },\r\n            reduce: function (symbol, factors) {\r\n                if(symbol.group === CP && symbol.length === 2) {\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return b.multiplier - a.multiplier;\r\n                    });\r\n                    if(symbols[0].power.equals(symbols[1].power)) {\r\n                        //x^n-a^n\r\n                        var n = _.parse(symbols[0].power),\r\n                                a = symbols[0].clone().toLinear(),\r\n                                b = symbols[1].clone().toLinear();\r\n\r\n                        //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\r\n                        factors.add(_.add(a.clone(), b.clone()));\r\n                        //flip the sign\r\n                        b.negate();\r\n                        //turn n into a number\r\n                        var nn = Number(n);\r\n                        //the remainder\r\n                        var result = new Symbol(0);\r\n                        for(var i = 1; i <= nn; i++) {\r\n                            var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\r\n                                    bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\r\n                            result = _.add(result, _.multiply(aa, bb));\r\n                        }\r\n                        return result;\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Makes Symbol square free\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @@param {String} variable The variable which is being factored \r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            squareFree: function (symbol, factors, variable) {\r\n                if(symbol.isConstant() || symbol.group === S)\r\n                    return symbol;\r\n\r\n                var poly = new Polynomial(symbol, variable);\r\n                var sqfr = poly.squareFree();\r\n                var p = sqfr[2];\r\n                //if we found a square then the p entry in the array will be non-unit\r\n                if(p !== 1) {\r\n                    //make sure the remainder doesn't have factors\r\n                    var t = sqfr[1].toSymbol();\r\n                    t.power = t.power.multiply(new Frac(p));\r\n                    //send the factor to be fatored to be sure it's completely factored\r\n                    factors.add(__.Factor.factor(t));\r\n\r\n                    var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\r\n\r\n                    return retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Factors the powers such that the lowest power is a constant\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            powerFactor: function (symbol, factors) {\r\n                //only PL need apply\r\n                if(symbol.group !== PL || symbol.previousGroup === EX)\r\n                    return symbol;\r\n                var k = keys(symbol.symbols);\r\n                //we expect only numeric powers so return all else\r\n                if(!core.Utils.allNumeric(k))\r\n                    return symbol;\r\n\r\n                var d = core.Utils.arrayMin(k);\r\n                var retval = new Symbol(0);\r\n                var q = _.parse(symbol.value + '^' + d);\r\n                symbol.each(function (x) {\r\n                    x = _.divide(x, q.clone());\r\n                    retval = _.add(retval, x);\r\n                });\r\n\r\n                factors.add(q);\r\n                return retval;\r\n            },\r\n            /**\r\n             * Removes GCD from coefficients\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @returns {Symbol}\r\n             */\r\n            coeffFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\r\n\r\n                    if(!gcd.equals(1)) {\r\n                        symbol.each(function (x) {\r\n                            if(x.isComposite()) {\r\n                                x.each(function (y) {\r\n                                    y.multiplier = y.multiplier.divide(gcd);\r\n                                });\r\n                            }\r\n                            else\r\n                                x.multiplier = x.multiplier.divide(gcd);\r\n                        });\r\n                        symbol.updateHash();\r\n                    }\r\n                    else {\r\n                        // TODO: This should probably go to the prototype\r\n                        var power = function (symbol) {\r\n                            var p;\r\n                            if(symbol.group === CB) {\r\n                                p = 0;\r\n                                symbol.each(function (x) {\r\n                                    p += x.power;\r\n                                });\r\n                            }\r\n                            else {\r\n                                p = Number(symbol.power);\r\n                            }\r\n                            return p;\r\n                        };\r\n                        // Factor out negatives from the lead term\r\n                        var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\r\n                            // Push constants to the back\r\n                            if(a.isConstant(true))\r\n                                return 1;\r\n                            return b.power - a.power;\r\n                        });\r\n\r\n                        var LT = terms[0];\r\n\r\n                        // Check if the LT is indeed the greatest\r\n                        if(power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\r\n                            if(LT.multiplier.lessThan(0)) {\r\n                                // Although the symbol should always be linear at this point, remove the negative for squares\r\n                                // to be safe.\r\n                                factors.add(new Symbol(-1));\r\n\r\n                                symbol.each(function (x) {\r\n                                    x.negate();\r\n                                }, true);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(factors) {\r\n                        factors.add(new Symbol(gcd));\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * The name says it all :)\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @@param {String} variable \r\n             * @returns {Symbol}\r\n             */\r\n            trialAndError: function (symbol, factors, variable) {\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    // At temp holder for the factors. If all goes well then\r\n                    // they'll be moved to the actual factors.\r\n                    var factor_array = [];\r\n\r\n                    if(symbol.isConstant() || symbol.group === S)\r\n                        return symbol;\r\n                    var poly = new Polynomial(symbol, variable),\r\n                            cnst = poly.coeffs[0],\r\n                            cfactors = core.Math2.ifactor(cnst),\r\n                            roots = __.proots(symbol);\r\n                    for(var i = 0; i < roots.length; i++) {\r\n                        var r = roots[i],\r\n                                p = 1;\r\n                        if(!isNaN(r)) { //if it's a number\r\n                            for(var x in cfactors) {\r\n                                //check it's raised to a power\r\n                                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\r\n                                if(isInt(n)) {\r\n                                    r = x; //x must be the root since n gave us a whole\r\n                                    p = n;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            var root = new Frac(r),\r\n                                    terms = [new Frac(root.num).negate()];\r\n                            terms[p] = new Frac(root.den);\r\n                            //convert to Frac. The den is coeff of LT and the num is coeff of constant\r\n                            var div = Polynomial.fromArray(terms, poly.variable).fill(),\r\n                                    t = poly.divide(div);\r\n                            if(t[1].equalsNumber(0)) { //if it's zero we have a root and divide it out\r\n                                poly = t[0];\r\n                                // factors.add(div.toSymbol());\r\n                                factor_array.push(div.toSymbol());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!poly.equalsNumber(1)) {\r\n                        poly = __.Factor.search(poly, factors);\r\n                    }\r\n\r\n                    // Move the factors over since all went well.\r\n                    factor_array.forEach(function (x) {\r\n                        factors.add(x);\r\n                    });\r\n\r\n                    return poly.toSymbol();\r\n                }\r\n                catch(e) {\r\n                    return untouched;\r\n                }\r\n            },\r\n            search: function (poly, factors, base) {\r\n                base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\r\n                var v = poly.variable; //the polynmial variable name\r\n                /**\r\n                 * Attempt to remove a root by division given a number by first creating\r\n                 * a polynomial fromt he given information\r\n                 * @param {int} c1 - coeffient for the constant\r\n                 * @param {int} c2 - coefficient for the LT\r\n                 * @param {int} n - the number to be used to construct the polynomial\r\n                 * @param {int} p - the power at which to create the polynomial\r\n                 * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n                 */\r\n                var check = function (c1, c2, n, p) {\r\n                    var candidate = Polynomial.fit(c1, c2, n, base, p, v);\r\n                    if(candidate && candidate.coeffs.length > 1) {\r\n                        var t = poly.divide(candidate);\r\n                        if(t[1].equalsNumber(0)) {\r\n                            factors.add(candidate.toSymbol());\r\n                            return [t[0], candidate];\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n                var cnst = poly.coeffs[0];\r\n                var cfactors = core.Math2.ifactor(cnst);\r\n                var lc = poly.lc();\r\n                var ltfactors = core.Math2.ifactor(lc);\r\n                var subbed = poly.sub(base);\r\n                var isubbed = core.Math2.ifactor(subbed);\r\n                var nfactors = __.Factor.mix(isubbed, subbed < 0);\r\n                var cp = Math.ceil(poly.coeffs.length / 2);\r\n                var lc_is_neg = lc.lessThan(0);\r\n                var cnst_is_neg = cnst.lessThan(0);\r\n                ltfactors['1'] = 1;\r\n                cfactors['1'] = 1;\r\n                while(cp--) {\r\n                    for(var x in ltfactors) {\r\n                        for(var y in cfactors) {\r\n                            for(var i = 0; i < nfactors.length; i++) {\r\n                                var factor_found = check(x, y, nfactors[i], cp);\r\n                                if(factor_found) {\r\n                                    poly = factor_found[0];\r\n                                    if(!core.Utils.isPrime(poly.sub(base)))\r\n                                        poly = __.Factor.search(poly, factors);\r\n                                    return poly;\r\n                                }\r\n                                else if(!factor_found) {\r\n                                    if(lc_is_neg && cnst_is_neg)\r\n                                        factor_found = check(-x, -y, nfactors[i], cp);\r\n                                    else if(lc_is_neg)\r\n                                        factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\r\n                                    else if(cnst_is_neg)\r\n                                        factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return poly;\r\n            },\r\n            /**\r\n             * Equivalent of square free factor for multivariate polynomials\r\n             * @param {type} symbol\r\n             * @param {type} factors\r\n             * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n             */\r\n            mSqfrFactor: function (symbol, factors) {\r\n                if(symbol.group !== FN) {\r\n                    var vars = variables(symbol).reverse();\r\n\r\n                    // Loop through all the variable and remove the partial derivatives\r\n                    for(var i = 0; i < vars.length; i++) {\r\n                        do {\r\n                            if(vars[i] === symbol.value) {\r\n                                //the derivative tells us nothing since this symbol is already the factor\r\n                                factors.add(symbol);\r\n                                symbol = new Symbol(1);\r\n                                continue;\r\n                            }\r\n\r\n                            var diff = core.Calculus.diff(symbol, vars[i]);\r\n\r\n                            var d = __.Factor.coeffFactor(diff);\r\n\r\n                            if(d.equals(0))\r\n                                break;\r\n\r\n                            //trial division to see if factors have whole numbers. \r\n                            //This can be optimized by stopping as soon as can_divide is false\r\n                            //this will also need utilize big number at some point\r\n                            var can_divide = true;\r\n                            if(d.isConstant() && symbol.isComposite()) {\r\n                                //check the coefficients\r\n\r\n                                symbol.each(function (x) {\r\n                                    if(x.multiplier % d !== 0)\r\n                                        can_divide = false;\r\n                                }, true);\r\n                            }\r\n\r\n                            //if we can divide then do so\r\n                            if(can_divide) {\r\n\r\n                                var div = __.div(symbol, d.clone()),\r\n                                        is_factor = div[1].equals(0);\r\n\r\n                                if(div[0].isConstant()) {\r\n                                    factors.add(div[0]);\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else\r\n                                is_factor = false;\r\n\r\n                            if(is_factor) {\r\n                                factors.add(div[0]);\r\n                                symbol = d;\r\n                            }\r\n                        }\r\n                        while(is_factor)\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //difference of squares factorization\r\n            sqdiff: function (symbol, factors) {\r\n                if(symbol.isConstant('all')) {\r\n                    // Nothing to do\r\n                    return symbol;\r\n                }\r\n\r\n                try {\r\n                    var remove_square = function (x) {\r\n                        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                            return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\r\n                        }, true);\r\n                    };\r\n                    var separated = core.Utils.separate(symbol.clone());\r\n\r\n                    var obj_array = [];\r\n\r\n                    //get the unique variables\r\n                    for(var x in separated) {\r\n                        if(x !== 'constants') {\r\n                            obj_array.push(separated[x]);\r\n                        }\r\n                    }\r\n                    obj_array.sort(function (a, b) {\r\n                        return b.power - a.power;\r\n                    });\r\n\r\n                    //if we have the same number of variables as unique variables then we can apply the difference of squares\r\n                    if(obj_array.length === 2) {\r\n                        var a, b;\r\n                        a = obj_array.pop();\r\n                        b = obj_array.pop();\r\n\r\n                        if(even(a.power) && even(b.power)\r\n                                && a.sign() === b.sign()\r\n                                && a.group === S && b.group === S) {\r\n                            throw new Error('Unable to factor');\r\n                        }\r\n                        ;\r\n\r\n                        if(a.isComposite() && b.power.equals(2)) {\r\n                            //remove the square from b\r\n                            b = remove_square(b);\r\n                            var f = __.Factor.factor(_.add(a, separated.constants));\r\n                            if(f.power.equals(2)) {\r\n                                f.toLinear();\r\n                                factors.add(_.subtract(f.clone(), b.clone()));\r\n                                factors.add(_.add(f, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                        else {\r\n                            a = a.powSimp();\r\n                            b = b.powSimp();\r\n\r\n                            if((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\r\n                                if(a.multiplier.lessThan(0)) {\r\n                                    var t = b;\r\n                                    b = a;\r\n                                    a = t;\r\n                                }\r\n                                if(a.multiplier.greaterThan(0)) {\r\n                                    a = remove_square(a);\r\n                                    b = remove_square(b);\r\n                                }\r\n\r\n                                factors.add(_.subtract(a.clone(), b.clone()));\r\n                                factors.add(_.add(a, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //factoring for multivariate\r\n            mfactor: function (symbol, factors) {\r\n\r\n                if(symbol.group === FN) {\r\n                    if(symbol.fname === 'sqrt') {\r\n                        var factors2 = new Factors(),\r\n                                arg = __.Factor.common(symbol.args[0].clone(), factors2);\r\n                        arg = __.Factor.coeffFactor(arg, factors2);\r\n                        symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\r\n                        factors2.each(function (x) {\r\n                            symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\r\n                        });\r\n                    }\r\n                    else\r\n                        factors.add(symbol);\r\n                }\r\n                else {\r\n\r\n                    //square free factorization\r\n                    symbol = __.Factor.mSqfrFactor(symbol, factors);\r\n\r\n                    //try factor out common factors\r\n                    //symbol = __.Factor.common(symbol, factors);\r\n\r\n                    var vars = variables(symbol),\r\n                            symbols = symbol.collectSymbols().map(function (x) {\r\n                        return Symbol.unwrapSQRT(x);\r\n                    }),\r\n                            sorted = {},\r\n                            maxes = {},\r\n                            l = vars.length, n = symbols.length;\r\n                    //take all the variables in the symbol and organize by variable name\r\n                    //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\r\n\r\n                    for(var i = 0; i < l; i++) {\r\n                        var v = vars[i];\r\n                        sorted[v] = new Symbol(0);\r\n                        for(var j = 0; j < n; j++) {\r\n                            var s = symbols[j];\r\n                            if(s.contains(v)) {\r\n                                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\r\n                                if(!maxes[v] || p < maxes[v])\r\n                                    maxes[v] = p;\r\n                                sorted[v] = _.add(sorted[v], s.clone());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    for(var x in sorted) {\r\n                        var r = _.parse(x + '^' + maxes[x]);\r\n                        var div = _.divide(sorted[x], r);\r\n                        var new_factor = _.expand(div);\r\n\r\n                        if(new_factor.equals(1))\r\n                            break; //why divide by one. Just move \r\n                        var divided = __.div(symbol.clone(), new_factor);\r\n\r\n                        if(divided[0].equals(0)) {\r\n                            //cant factor anymore\r\n                            break;\r\n                        }\r\n\r\n                        // We potentially ended up with fractional coefficients when the\r\n                        // trial division was performed. We need to remove \r\n                        // This check will more then likely become superfluous with improvements\r\n                        // to polynomial division\r\n                        if(divided[1].equals(0)) {\r\n                            var has_fractions = false;\r\n\r\n                            divided[0].each(function (x) {\r\n                                if(!isInt(x.multiplier)) {\r\n                                    has_fractions = true;\r\n                                }\r\n                            });\r\n\r\n                            // The factor isn't really a factor and needs to be put back\r\n                            if(has_fractions) {\r\n                                divided[1] = _.expand(_.multiply(divided[1], new_factor));\r\n                                // Since the new factor is not just one, we exit.\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\r\n\r\n                        if(divided[1].equals(0) && !neg_numeric_factor) { //we found at least one factor\r\n\r\n                            //factors.add(new_factor);\r\n                            var d = __.div(symbol.clone(), divided[0].clone());\r\n                            var r = d[0];\r\n\r\n                            // Nothing left to do since we didn't get a reduction\r\n                            if(r.equals(0)) {\r\n                                return symbol;\r\n                            }\r\n\r\n                            symbol = d[1];\r\n                            //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\r\n                            //and we just return the symbol;\r\n                            //If r equals zero then there's nothing left to do so we're done\r\n\r\n                            if(r.equals(-1) && !symbol.equals(0))\r\n                                return symbol;\r\n\r\n                            var factor = divided[0];\r\n\r\n                            if(symbol.equals(factor)) {\r\n                                var rem = __.Factor.reduce(factor, factors);\r\n\r\n                                if(!symbol.equals(rem))\r\n                                    return __.Factor.mfactor(rem, factors);\r\n\r\n                                return rem;\r\n                            }\r\n                            else {\r\n                                factors.add(factor);\r\n                                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\r\n                                if(symbol.equals(0))\r\n                                    return r;\r\n                            }\r\n\r\n                            if(r.isConstant('all')) {\r\n                                factors.add(r);\r\n                                return r;\r\n                            }\r\n\r\n                            return __.Factor.mfactor(r, factors);\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                //difference of squares factorization\r\n                symbol = __.Factor.sqdiff(symbol, factors);\r\n\r\n                //factors by fishing for zeroes\r\n                symbol = __.Factor.zeroes(symbol, factors);\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a set of \"equations\" is linear. \r\n         * @param {type} set\r\n         * @returns {Boolean}\r\n         */\r\n        allLinear: function (set) {\r\n            var l = set.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(!__.isLinear(set[i]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /*\r\n         * Checks to see if the \"equation\" is linear\r\n         * @param {Symbol} e\r\n         * @returns {boolean}\r\n         */\r\n        isLinear: function (e) {\r\n            var status = false, g = e.group;\r\n            if(g === PL || g === CP) {\r\n                status = true;\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s], sg = symbol.group;\r\n                    if(sg === FN || sg === EX) {\r\n                        status = false;\r\n                    }\r\n                    if(sg === CB) {\r\n                        //needs further checking since it might be imaginary\r\n                        status = variables(symbol).length === 1;\r\n                    }\r\n                    else {\r\n                        if(sg === PL || sg === CP)\r\n                            status = __.isLinear(symbol);\r\n                        else {\r\n                            if(symbol.group !== N && symbol.power.toString() !== '1') {\r\n                                status = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(g === S && e.power === 1)\r\n                status = true;\r\n            return status;\r\n        },\r\n        gcd: function () {\r\n            var args;\r\n            if(arguments.length === 1 && arguments[0] instanceof core.Vector)\r\n                args = arguments[0].elements;\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //short-circuit early\r\n            if(args.length === 0)\r\n                return new Symbol(1);\r\n            else if(args.length === 1)\r\n                return args[0];\r\n\r\n            var appeared = [], evaluate = false;\r\n            for(var i = 0; i < args.length; i++) {\r\n                if(args[i].group === FN && args[i].fname === 'gcd')\r\n                {\r\n                    //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\r\n                    args = args.concat(arguments[i].args);\r\n                    //do not keep gcd in args\r\n                    args.splice(i, 1);\r\n                }\r\n                else\r\n                {\r\n                    //Look if there are any common variables such that\r\n                    //gcd(a,b) => gcd(a,b); gcd(a,a) => a\r\n                    var vars = variables(args[i]);\r\n                    if(core.Utils.haveIntersection(vars, appeared))\r\n                    {\r\n                        //Ok, there are common variables\r\n                        evaluate = true;\r\n                        break;\r\n                    }\r\n                    else\r\n                        appeared = appeared.concat(vars);\r\n                }\r\n            }\r\n\r\n            //appeared.length is 0 when all arguments are group N\r\n            if(evaluate || appeared.length === 0) {\r\n                //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\r\n                if(args.every(function (symbol) {\r\n                    return symbol.getDenom().equals(1)\r\n                })) {\r\n                    var aggregate = args[0];\r\n\r\n                    for(var i = 1; i < args.length; i++) {\r\n                        aggregate = __.gcd_(args[i], aggregate);\r\n                    }\r\n                    return aggregate;\r\n                }\r\n                else {\r\n                    //gcd_ cannot handle denominators correctly\r\n                    return _.divide(__.gcd.apply(null, args.map(function (symbol) {\r\n                        return symbol.getNum();\r\n                    })),\r\n                            __.lcm.apply(null, args.map(function (symbol) {\r\n                                return symbol.getDenom();\r\n                            })));\r\n                }\r\n            }\r\n            else\r\n                return _.symfunction('gcd', args);\r\n        },\r\n        gcd_: function (a, b) {\r\n            if(a.group === FN || a.group === P)\r\n                a = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(a);\r\n                });\r\n\r\n            if(b.group === FN)\r\n                b = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(b);\r\n                });\r\n\r\n            if(a.isConstant() && b.isConstant()) {\r\n                // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\r\n                return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\r\n            }\r\n\r\n            var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\r\n            a = _.multiply(a.clone(), den.clone());\r\n            b = _.multiply(b.clone(), den.clone());\r\n\r\n            //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\r\n            a = _.expand(a);\r\n            b = _.expand(b);\r\n\r\n            if(a.group === CB || b.group === CB) {\r\n                var q = _.divide(a.clone(), b.clone()); //get the quotient\r\n                var t = _.multiply(b.clone(), q.getDenom().invert());//multiply by the denominator\r\n                //if they have a common factor then the result will not equal one \r\n                if(!t.equals(1))\r\n                    return t;\r\n            }\r\n\r\n            //just take the gcd of each component when either of them is in group EX\r\n            if(a.group === EX || b.group === EX)\r\n            {\r\n                var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\r\n                var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\r\n                var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\r\n                return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\r\n            }\r\n\r\n            if(a.length < b.length) { //swap'm\r\n                var t = a;\r\n                a = b;\r\n                b = t;\r\n            }\r\n            var vars_a = variables(a), vars_b = variables(b);\r\n            if((vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0])\r\n                    || vars_a.length === 1 && vars_b.length === 0\r\n                    || vars_a.length === 0 && vars_b.length === 1) {\r\n                a = new Polynomial(a);\r\n                b = new Polynomial(b);\r\n                return _.divide(a.gcd(b).toSymbol(), den);\r\n            }\r\n            else {\r\n                //get the gcd of the multipiers\r\n                //get rid of gcd in coeffs\r\n                var multipliers = [];\r\n                a.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n                b.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n\r\n                var T;\r\n                while(!b.equals(0)) {\r\n                    var t = b.clone();\r\n                    a = a.clone();\r\n                    T = __.div(a, t);\r\n\r\n                    b = T[1];\r\n                    if(T[0].equals(0)) {\r\n                        //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\r\n                        return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\r\n                    }\r\n                    a = t;\r\n                }\r\n\r\n                var gcd = core.Math2.QGCD.apply(undefined, multipliers);\r\n\r\n                if(!gcd.equals(1)) {\r\n                    a.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(gcd);\r\n                    });\r\n                }\r\n\r\n                //return symbolic function for gcd in indeterminate form\r\n                if(a.equals(1) && !a.isConstant() && !b.isConstant())\r\n                    return _.divide(_.symfunction('gcd', arguments), den);\r\n\r\n                return _.divide(a, den);\r\n            }\r\n        },\r\n        lcm: function () {\r\n            //https://math.stackexchange.com/a/319310\r\n            //generalization of the 2-variable formula of lcm\r\n\r\n            var args;\r\n            if(arguments.length === 1)\r\n                if(arguments[0] instanceof core.Vector)\r\n                    args = arguments[0].elements;\r\n                else\r\n                    _.error('lcm expects either 1 vector or 2 or more arguments');\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //product of all arguments\r\n            //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n            var numer = args.reduce(function (prev, curr) {\r\n                return _.multiply(prev, curr.clone())\r\n            }, new Symbol(1));\r\n\r\n            //gcd of complementary terms\r\n            var denom_args =\r\n                    //https://stackoverflow.com/a/18223072\r\n                //take all complementary terms, e.g.\r\n                //[a,b,c] => [a*b, b*c, a*c]\r\n                //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\r\n                (function (input, size) {\r\n                        size = Number(size);\r\n                        var results = [], result, mask, i, total = Math.pow(2, input.length);\r\n                        for(mask = size; mask < total; mask++) {\r\n                            result = [];\r\n                            i = input.length - 1;\r\n\r\n                            do {\r\n                                if((mask & (1 << i)) !== 0) {\r\n                                    result.push(input[i]);\r\n                                }\r\n                            }\r\n                            while(i--);\r\n\r\n                            if(result.length === size) {\r\n                                results.push(result);\r\n                            }\r\n                        }\r\n                        return results;\r\n                        //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n                    })(arguments, arguments.length - 1).map(function (x) {\r\n                return x.reduce(function (prev, curr) {\r\n                    return _.multiply(prev, curr.clone())\r\n                }, new Symbol(1))\r\n            });\r\n\r\n            var denom;\r\n            //don't eat the gcd term if all arguments are symbols\r\n            if(args.every(function (x) {\r\n                return core.Utils.isVariableSymbol(x)\r\n            }))\r\n                denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));\r\n            else\r\n                denom = __.gcd.apply(null, denom_args);\r\n            //divide product of all arguments by gcd of complementary terms\r\n            var div = _.divide(numer, denom);\r\n            return div;\r\n        },\r\n        /**\r\n         * Divides one expression by another\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Array}\r\n         */\r\n        divide: function (symbol1, symbol2) {\r\n            var result, remainder, factored, den;\r\n            factored = core.Algebra.Factor.factor(symbol1.clone());\r\n            den = factored.getDenom();\r\n            if(!den.isConstant('all')) {\r\n                symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\r\n            }\r\n            else\r\n                //reset the denominator since we're not dividing by it anymore\r\n                den = new Symbol(1);\r\n            result = __.div(symbol1, symbol2);\r\n            remainder = _.divide(result[1], symbol2);\r\n            return _.divide(_.add(result[0], remainder), den);\r\n        },\r\n        div: function (symbol1, symbol2) {\r\n            // If all else fails then assume that division failed with\r\n            // a remainder of zero and the original quotient\r\n            var fail = [new Symbol(0), symbol1.clone()];\r\n\r\n            try {\r\n\r\n                // Division by constants\r\n                if(symbol2.isConstant('all')) {\r\n                    symbol1.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(symbol2.multiplier);\r\n                    });\r\n                    return [symbol1, new Symbol(0)];\r\n                }\r\n                // So that factorized symbols don't affect the result\r\n                symbol1 = _.expand(symbol1);\r\n                symbol2 = _.expand(symbol2);\r\n                // Special case. May need revisiting\r\n                if(symbol1.group === S && symbol2.group === CP) {\r\n                    var x = symbol1.value;\r\n                    var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\r\n                    if(symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\r\n                        var k = Symbol.create(symbol1.multiplier);\r\n                        return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\r\n                    }\r\n                }\r\n                if(symbol1.group === S && symbol2.group === S) {\r\n                    var r = _.divide(symbol1.clone(), symbol2.clone());\r\n                    if(r.isConstant()) //we have a whole\r\n                        return [r, new Symbol(0)];\r\n                    return [new Symbol(0), symbol1.clone()];\r\n                }\r\n                var symbol1_has_func = symbol1.hasFunc(),\r\n                        symbol2_has_func = symbol2.hasFunc(),\r\n                        parse_funcs = false;\r\n\r\n                //substitute out functions so we can treat them as regular variables\r\n                if(symbol1_has_func || symbol2_has_func) {\r\n                    parse_funcs = true;\r\n                    var map = {},\r\n                            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\r\n                            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\r\n                            subs = core.Utils.getFunctionsSubs(map);\r\n                }\r\n                //get a list of the variables\r\n                var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\r\n                        quot, rem;\r\n\r\n                //treat imaginary numbers as variables\r\n                if(symbol1.isImaginary() || symbol2.isImaginary()) {\r\n                    vars.push(core.Settings.IMAGINARY);\r\n                }\r\n\r\n                if(vars.length === 1) {\r\n                    var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\r\n                    quot = q[0].toSymbol();\r\n                    rem = q[1].toSymbol();\r\n                }\r\n                else {\r\n                    vars.push(CONST_HASH); //this is for the numbers\r\n                    var reconvert = function (arr) {\r\n                        var symbol = new Symbol(0);\r\n                        for(var i = 0; i < arr.length; i++) {\r\n                            var x = arr[i].toSymbol();\r\n                            symbol = _.add(symbol, x);\r\n                        }\r\n                        return symbol;\r\n                    };\r\n\r\n                    // Silly Martin. This is why you document. I don't remember now\r\n                    var get_unique_max = function (term, any) {\r\n                        var max = Math.max.apply(null, term.terms),\r\n                                count = 0, idx;\r\n\r\n                        if(!any) {\r\n                            for(var i = 0; i < term.terms.length; i++) {\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    count++;\r\n                                }\r\n                                if(count > 1)\r\n                                    return;\r\n                            }\r\n                        }\r\n                        if(any) {\r\n                            for(i = 0; i < term.terms.length; i++)\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    break;\r\n                                }\r\n                        }\r\n                        return [max, idx, term];\r\n                    };\r\n\r\n                    // Tries to find an LT in the dividend that will satisfy division\r\n                    var get_det = function (s, lookat) {\r\n                        lookat = lookat || 0;\r\n                        var det = s[lookat], l = s.length;\r\n                        if(!det)\r\n                            return;\r\n                        //eliminate the first term if it doesn't apply\r\n                        var umax = get_unique_max(det);\r\n                        for(var i = lookat + 1; i < l; i++) {\r\n                            var term = s[i],\r\n                                    is_equal = det.sum.equals(term.sum);\r\n                            if(!is_equal && umax) {\r\n                                break;\r\n                            }\r\n                            if(is_equal) {\r\n                                // Check the differences of their maxes. The one with the biggest difference governs\r\n                                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\r\n                                var max1, max2, idx1, idx2, l2 = det.terms.length;\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var item1 = det.terms[j], item2 = term.terms[j];\r\n                                    if(typeof max1 === 'undefined' || item1.greaterThan(max1)) {\r\n                                        max1 = item1;\r\n                                        idx1 = j;\r\n                                    }\r\n                                    if(typeof max2 === 'undefined' || item2.greaterThan(max2)) {\r\n                                        max2 = item2;\r\n                                        idx2 = j;\r\n                                    }\r\n                                }\r\n                                //check their differences\r\n                                var d1 = max1.subtract(term.terms[idx1]),\r\n                                        d2 = max2.subtract(det.terms[idx2]);\r\n                                if(d2 > d1) {\r\n                                    umax = [max2, idx2, term];\r\n                                    break;\r\n                                }\r\n                                if(d1 > d2) {\r\n                                    umax = [max1, idx1, det];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                //check if it's a suitable pick to determine the order\r\n                                umax = get_unique_max(term);\r\n                                //if(umax) return umax;\r\n                                if(umax)\r\n                                    break;\r\n                            }\r\n                            umax = get_unique_max(term); //calculate a new unique max\r\n                        }\r\n\r\n                        //if still no umax then any will do since we have a tie\r\n                        if(!umax)\r\n                            return get_unique_max(s[0], true);\r\n                        var e, idx;\r\n                        for(var i = 0; i < s2.length; i++) {\r\n                            var cterm = s2[i].terms;\r\n                            //confirm that this is a good match for the denominator\r\n                            idx = umax[1];\r\n                            if(idx === cterm.length - 1)\r\n                                return;\r\n                            e = cterm[idx];\r\n                            if(!e.equals(0))\r\n                                break;\r\n                        }\r\n                        if(e.equals(0))\r\n                            return get_det(s, ++lookat); //look at the next term\r\n\r\n                        return umax;\r\n                    };\r\n\r\n                    var t_map = core.Utils.toMapObj(vars);\r\n                    var init_sort = function (a, b) {\r\n                        return b.sum.subtract(a.sum);\r\n                    };\r\n                    var is_larger = function (a, b) {\r\n                        if(!a || !b)\r\n                            return false; //it's empty so...\r\n                        for(var i = 0; i < a.terms.length; i++) {\r\n                            if(a.terms[i].lessThan(b.terms[i]))\r\n                                return false;\r\n                        }\r\n                        return true;\r\n                    };\r\n\r\n                    var s1 = symbol1.tBase(t_map).sort(init_sort),\r\n                            s2 = symbol2.tBase(t_map).sort(init_sort);\r\n                    var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\r\n                    var det = get_det(target);//we'll begin by assuming that this will let us know which term \r\n                    var quotient = [];\r\n                    if(det) {\r\n                        var lead_var = det[1];\r\n                        var can_divide = function (a, b) {\r\n                            if(a[0].sum.equals(b[0].sum))\r\n                                return a.length >= b.length;\r\n                            return true;\r\n                        };\r\n\r\n                        var try_better_lead_var = function (s1, s2, lead_var) {\r\n                            var checked = [];\r\n                            for(var i = 0; i < s1.length; i++) {\r\n                                var t = s1[i];\r\n                                for(var j = 0; j < t.terms.length; j++) {\r\n                                    var cf = checked[j], tt = t.terms[j];\r\n                                    if(i === 0)\r\n                                        checked[j] = tt; //add the terms for the first one\r\n                                    else if(cf && !cf.equals(tt))\r\n                                        checked[j] = undefined;\r\n                                }\r\n                            }\r\n                            for(var i = 0; i < checked.length; i++) {\r\n                                var t = checked[i];\r\n                                if(t && !t.equals(0))\r\n                                    return i;\r\n                            }\r\n                            return lead_var;\r\n                        };\r\n                        var sf = function (a, b) {\r\n                            var l1 = a.len(), l2 = b.len();\r\n                            var blv = b.terms[lead_var], alv = a.terms[lead_var];\r\n                            if(l2 > l1 && blv.greaterThan(alv))\r\n                                return l2 - l1;\r\n                            return blv.subtract(alv);\r\n                        };\r\n\r\n                        //check to see if there's a better lead_var\r\n                        lead_var = try_better_lead_var(s1, s2, lead_var);\r\n                        //reorder both according to the max power\r\n                        s1.sort(sf); //sort them both according to the leading variable power\r\n                        s2.sort(sf);\r\n\r\n                        //try to adjust if den is larger\r\n                        var fdt = s2[0], fnt = s1[0];\r\n\r\n                        var den = new MVTerm(new Frac(1), [], fnt.map);\r\n                        if(fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\r\n                            for(var i = 0; i < fnt.terms.length; i++) {\r\n                                var d = fdt.terms[i].subtract(fnt.terms[i]);\r\n                                if(!d.equals(0)) {\r\n                                    var nd = d.add(new Frac(1));\r\n                                    den.terms[i] = d;\r\n                                    for(var j = 0; j < s1.length; j++) {\r\n                                        s1[j].terms[i] = s1[j].terms[i].add(nd);\r\n                                    }\r\n                                }\r\n                                else\r\n                                    den.terms[i] = new Frac(0);\r\n                            }\r\n                        }\r\n\r\n                        var dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                        var safety = 0;\r\n                        var max = 200;\r\n\r\n                        while(dividend_larger && can_divide(s1, s2)) {\r\n                            if(safety++ > max) {\r\n                                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\r\n                            }\r\n\r\n                            var q = s1[0].divide(s2[0]);\r\n\r\n                            quotient.push(q); //add what's divided to the quotient\r\n                            s1.shift();//the first one is guaranteed to be gone so remove from dividend\r\n                            for(var i = 1; i < s2.length; i++) { //loop through the denominator\r\n                                var t = s2[i].multiply(q).generateImage(),\r\n                                        l2 = s1.length;\r\n                                //if we're subtracting from 0\r\n                                if(l2 === 0) {\r\n                                    t.coeff = t.coeff.neg();\r\n                                    s1.push(t);\r\n                                    s1.sort(sf);\r\n                                }\r\n\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var cur = s1[j];\r\n                                    if(cur.getImg() === t.getImg()) {\r\n                                        cur.coeff = cur.coeff.subtract(t.coeff);\r\n                                        if(cur.coeff.equals(0)) {\r\n                                            core.Utils.remove(s1, j);\r\n                                            j--; //adjust the iterator\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if(j === l2 - 1) {\r\n                                        t.coeff = t.coeff.neg();\r\n                                        s1.push(t);\r\n                                        s1.sort(sf);\r\n                                    }\r\n                                }\r\n                            }\r\n                            dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                            if(!dividend_larger && s1.length >= s2.length) {\r\n                                //One more try since there might be a terms that is larger than the LT of the divisor\r\n                                for(var i = 1; i < s1.length; i++) {\r\n                                    dividend_larger = is_larger(s1[i], s2[0]);\r\n                                    if(dividend_larger) {\r\n                                        //take it from its current position and move it to the front\r\n                                        s1.unshift(core.Utils.remove(s1, i));\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    quot = reconvert(quotient);\r\n                    rem = reconvert(s1);\r\n\r\n                    if(typeof den !== 'undefined') {\r\n                        den = den.toSymbol();\r\n                        quot = _.divide(quot, den.clone());\r\n                        rem = _.divide(rem, den);\r\n                    }\r\n                }\r\n\r\n                //put back the functions\r\n                if(parse_funcs) {\r\n                    quot = _.parse(quot.text(), subs);\r\n                    rem = _.parse(rem.text(), subs);\r\n                }\r\n\r\n                return [quot, rem];\r\n            }\r\n            catch(e) {\r\n                return fail;\r\n            }\r\n\r\n        },\r\n        line: function (v1, v2, x) {\r\n            if(core.Utils.isArray(v1))\r\n                v1 = core.Utils.convertToVector(v1);\r\n            if(core.Utils.isArray(v2))\r\n                v2 = core.Utils.convertToVector(v2);\r\n            x = _.parse(x || 'x');\r\n            if(!core.Utils.isVector(v1) || !core.Utils.isVector(v2))\r\n                _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\r\n            var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\r\n                    dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\r\n                    m = _.divide(dy, dx),\r\n                    a = _.multiply(x, m.clone()),\r\n                    b = _.multiply(v1.e(1).clone(), m);\r\n            return _.add(_.subtract(a, b), v1.e(2).clone());\r\n        },\r\n        PartFrac: {\r\n            createTemplate: function (den, denom_factors, f_array, v) {\r\n                //clean up the denominator function by factors so it reduces nicely\r\n                den = __.Factor.factor(den);\r\n\r\n                //clean up factors. This is so inefficient but factors are wrapped in parens for safety\r\n                den.each(function (x, key) {\r\n                    if(x.group === FN && x.fname === '' && x.args[0].group === S) {\r\n                        var y = x.args[0];\r\n                        if(this.symbols) {\r\n                            delete this.symbols[key];\r\n                            this.symbols[y.value] = y;\r\n                        }\r\n                        else {\r\n                            den = x.args[0];\r\n                        }\r\n                    }\r\n                });\r\n\r\n                var factors, factors_vec, f, p, deg, degrees, m;\r\n                factors = denom_factors.collectFactors();\r\n                factors_vec = []; //a vector for the template\r\n                degrees = [];\r\n                m = new Symbol(1);\r\n\r\n                for(var i = 0; i < factors.length; i++) { //loop through the factors\r\n                    var factor = Symbol.unwrapPARENS(factors[i]);\r\n                    //if in he for P^n where P is polynomial and n = integer\r\n                    if(factor.power.greaterThan(1)) {\r\n                        p = Number(factor.power);\r\n                        f = factor.clone().toLinear(); //remove the power so we have only the function\r\n                        deg = Number(__.degree(f, v)); //get the degree of f\r\n                        //expand the factor\r\n                        for(var j = 0; j < p; j++) {\r\n                            var efactor = _.pow(f.clone(), new Symbol(j + 1));\r\n                            f_array.push(efactor.clone());\r\n                            var d = _.divide(den.clone(), efactor.clone());\r\n                            degrees.push(deg);\r\n                            factors_vec.push(d);\r\n                        }\r\n                    }\r\n                    /*\r\n                     Possible bug.\r\n                     Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n                     else if(factor.isConstant('all')) {\r\n                     m = _.multiply(m, factor);\r\n                     }\r\n                     */\r\n                    else {\r\n                        //get the degree of the factor so we tack it on tot he factor. This should probably be an array\r\n                        //but for now we note it on the symbol\r\n                        deg = Number(__.degree(factor, v));\r\n                        f_array.push(factor);\r\n                        var d = _.divide(den.clone(), factor.clone());\r\n                        d = _.expand(Symbol.unwrapPARENS(d));\r\n                        degrees.push(deg);\r\n                        factors_vec.push(d);\r\n                    }\r\n                }\r\n                //put back the constant\r\n                f_array = f_array.map(function (x) {\r\n                    return _.multiply(x, m.clone());\r\n                });\r\n                return [f_array, factors_vec, degrees];\r\n            },\r\n            partfrac: function (symbol, v, as_array) {\r\n\r\n                var vars = variables(symbol);\r\n\r\n                v = v || _.parse(vars[0]); //make wrt optional and assume first variable\r\n                try {\r\n                    var num, den, factors, tfactors, ofactors, nterms, degrees,\r\n                            dterms, max, M, c, powers, div, r, factors_vec, ks,\r\n                            template, tfactors;\r\n                    num = _.expand(symbol.getNum());\r\n                    den = _.expand(symbol.getDenom().toUnitMultiplier());\r\n                    //move the entire multipier to the numerator\r\n                    num.multiplier = symbol.multiplier;\r\n                    //we only have a meaningful change if n factors > 1. This means that\r\n                    //the returned group will be a CB\r\n                    //collect the terms wrt the x\r\n                    nterms = num.groupTerms(v);\r\n                    //divide out wholes if top is larger\r\n                    if(Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\r\n                        div = __.div(num.clone(), _.expand(den.clone()));\r\n                        r = div[0]; //remove the wholes\r\n                        num = div[1]; //work with the remainder\r\n                        nterms = num.groupTerms(v); //recalculate the nterms\r\n                    }\r\n                    else\r\n                        r = new Symbol(0);\r\n\r\n                    if(Number(__.degree(den, v)) === 1) {\r\n                        var q = _.divide(num, den);\r\n                        if(as_array)\r\n                            return [r, q];\r\n                        return _.add(r, q);\r\n                    }\r\n                    //first factor the denominator. This means that the strength of this\r\n                    //algorithm depends on how well we can factor the denominator. \r\n                    ofactors = __.Factor.factor(den);\r\n                    //create the template. This method will create the template for solving \r\n                    //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\r\n                    template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\r\n                    tfactors = template[0]; //grab the factors\r\n                    factors_vec = template[1]; //grab the factor vectors\r\n                    degrees = template[2]; //grab the degrees\r\n                    //make note of the powers of each term\r\n                    powers = [nterms.length];\r\n                    //create the dterms vector\r\n                    dterms = [];\r\n                    factors = [];\r\n                    ks = [];\r\n                    var factor, deg;\r\n                    factors_vec.map(function (x, idx) {\r\n                        factor = tfactors[idx];\r\n                        deg = degrees[idx];\r\n                        for(var i = 0; i < deg; i++) {\r\n                            factors.push(factor.clone());\r\n                            var k = Symbol.create(v, i);\r\n                            var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\r\n                            //make a note of the power which corresponds to the length of the array\r\n                            var p = t.length;\r\n                            powers.push(p);\r\n                            dterms.push(t);\r\n                            ks.push(k.clone());\r\n                        }\r\n                    });\r\n                    //get the max power\r\n                    max = core.Utils.arrayMax(powers);\r\n\r\n                    //fill the holes and create a matrix\r\n                    c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\r\n                    //for each of the factors we do the same\r\n                    M = new core.Matrix();\r\n                    for(var i = 0; i < dterms.length; i++) {\r\n                        M.elements.push(core.Utils.fillHoles(dterms[i], max));\r\n                    }\r\n\r\n                    //solve the system of equations\r\n                    var partials = _.multiply(M.transpose().invert(), c);\r\n                    //the results are backwards to reverse it\r\n                    //partials.elements.reverse();\r\n                    //convert it all back\r\n                    var retval = as_array ? [r] : r;\r\n                    partials.each(function (e, i) {\r\n                        var term = _.multiply(ks[i], _.divide(e, factors[i]));\r\n                        if(as_array)\r\n                            retval.push(term);\r\n                        else\r\n                            retval = _.add(retval, term);\r\n                    });\r\n\r\n                    //done\r\n                    return retval;\r\n                }\r\n                catch(e) {\r\n                    //try to group symbols\r\n                    try {\r\n                        if(symbol.isComposite()) {\r\n                            //group denominators\r\n                            var denominators = {};\r\n\r\n                            symbol.each(function (x) {\r\n                                var d = x.getDenom();\r\n                                var n = x.getNum();\r\n                                var e = denominators[d];\r\n                                denominators[d] = e ? _.add(e, n) : n;\r\n                            });\r\n\r\n                            var t = new Symbol(0);\r\n\r\n                            for(var x in denominators) {\r\n                                t = _.add(t, _.divide(denominators[x], _.parse(x)));\r\n                            }\r\n\r\n                            symbol = t;\r\n                        }\r\n                    }\r\n                    catch(e2) {\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        degree: function (symbol, v, o) {\r\n            o = o || {\r\n                nd: [], //numeric\r\n                sd: [], //symbolic\r\n                depth: 0 //call depth\r\n            };\r\n\r\n            if(!v) {\r\n                var vars = variables(symbol);\r\n                //The user must specify the variable for multivariate\r\n                if(vars.length > 1)\r\n                    throw new Error('You must specify the variable for multivariate polynomials!');\r\n                //if it's empty then we're dealing with a constant\r\n                if(vars.length === 0)\r\n                    return new Symbol(0);\r\n                //assume the variable for univariate\r\n                v = _.parse(vars[0]);\r\n            }\r\n\r\n            //store the group\r\n            var g = symbol.group;\r\n            //we're going to trust the user and assume no EX. Calling isPoly \r\n            //would eliminate this but no sense in checking twice. \r\n            if(symbol.isComposite()) {\r\n                symbol = symbol.clone();\r\n                symbol.distributeExponent();\r\n                symbol.each(function (x) {\r\n                    o.depth++; //mark a depth increase\r\n                    __.degree(x, v, o);\r\n                    o.depth--; //we're back\r\n                });\r\n            }\r\n            else if(symbol.group === CB) {\r\n                symbol.each(function (x) {\r\n                    o.depth++;\r\n                    __.degree(x, v, o);\r\n                    o.depth++;\r\n                });\r\n            }\r\n            else if(g === EX && symbol.value === v.value) {\r\n                o.sd.push(symbol.power.clone());\r\n            }\r\n            else if(g === S && symbol.value === v.value) {\r\n                o.nd.push(_.parse(symbol.power));\r\n            }\r\n            else\r\n                o.nd.push(new Symbol(0));\r\n\r\n            //get the max out of the array\r\n            var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\r\n\r\n            if(o.depth === 0 && o.sd.length > 0) {\r\n                if(deg !== undefined)\r\n                    o.sd.unshift(deg);\r\n                return _.symfunction('max', o.sd);\r\n            }\r\n            if(!core.Utils.isSymbol(deg))\r\n                deg = _.parse(deg);\r\n            //return the degree\r\n            return deg;\r\n        },\r\n        /**\r\n         * Attempts to complete the square of a polynomial\r\n         * @param {type} symbol\r\n         * @param {type} v\r\n         * @param {type} raw\r\n         * @throws {Error} \r\n         * @returns {Object|Symbol[]}\r\n         */\r\n        sqComplete: function (symbol, v, raw) {\r\n            if(!core.Utils.isSymbol(v))\r\n                v = _.parse(v);\r\n            var stop = function (msg) {\r\n                msg = msg || 'Stopping';\r\n                throw new core.exceptions.ValueLimitExceededError(msg);\r\n            };\r\n            //if not CP then nothing to do\r\n            if(!symbol.isPoly(true))\r\n                stop('Must be a polynomial!');\r\n\r\n            //declare vars\r\n            var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\r\n\r\n            br = core.Utils.inBrackets;\r\n            //make a copy\r\n            symbol = symbol.clone();\r\n            deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\r\n            //must be in form ax^2 +/- bx +/- c\r\n            if(!deg.equals(2))\r\n                stop('Cannot complete square for degree ' + deg);\r\n            //get the coeffs\r\n            coeffs = core.Algebra.coeffs(symbol, v);\r\n            a = coeffs[2];\r\n            //store the sign\r\n            sign = coeffs[1].sign();\r\n            //divide the linear term by two and square it\r\n            b = _.divide(coeffs[1], new Symbol(2));\r\n            //add the difference to the constant\r\n            c = _.pow(b.clone(), new Symbol(2));\r\n            if(raw)\r\n                return [a, b, d];\r\n            sqrt_a = math.sqrt(a);\r\n            e = _.divide(math.sqrt(c), sqrt_a.clone());\r\n            //calculate d which is the constant\r\n            d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\r\n            //compute the square part\r\n            sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\r\n            return {\r\n                a: sym,\r\n                c: d,\r\n                f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\r\n            };\r\n        },\r\n        Simplify: {\r\n            strip: function (symbol) {\r\n                var c = _.parse(symbol.multiplier);\r\n                symbol.toUnitMultiplier();\r\n                var p = _.parse(symbol.power);\r\n                symbol.toLinear();\r\n                return [c, p, symbol];\r\n            },\r\n            unstrip: function (cp, symbol) {\r\n                var c = cp[0];\r\n                var p = cp[1];\r\n                return _.multiply(c, _.pow(symbol, p));\r\n            },\r\n            complexSimp: function (num, den) {\r\n                var ac, bd, bc, ad, cd, r1, r2, i1, i2;\r\n                r1 = num.realpart();\r\n                i1 = num.imagpart();\r\n                r2 = den.realpart();\r\n                i2 = den.imagpart();\r\n                //apply complex arithmatic rule\r\n                ac = _.multiply(r1.clone(), r2.clone());\r\n                bd = _.multiply(i1.clone(), i2.clone());\r\n                bc = _.multiply(r2.clone(), i1);\r\n                ad = _.multiply(r1, i2.clone());\r\n                cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\r\n\r\n                return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\r\n            },\r\n            trigSimp: function (symbol) {\r\n                if(symbol.containsFunction(['cos', 'sin', 'tan'])) {\r\n                    symbol = symbol.clone();\r\n                    //remove power and multiplier\r\n                    var sym_array = __.Simplify.strip(symbol);\r\n                    symbol = sym_array.pop();\r\n                    //the default return value is the symbol\r\n                    var retval = symbol.clone();\r\n\r\n                    //rewrite the symbol\r\n                    if(symbol.group === CP) {\r\n                        var sym = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            //rewrite the function\r\n                            var tr = __.Simplify.trigSimp(x.fnTransform());\r\n                            sym = _.add(sym, tr);\r\n                        }, true);\r\n\r\n                        //put back the power and multiplier and return\r\n                        retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\r\n                    }\r\n                    else if(symbol.group === CB) {\r\n\r\n                        var n = symbol.getNum();\r\n                        var d = symbol.getDenom();\r\n\r\n                        //try for tangent\r\n                        if(n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\r\n                            retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\r\n                        }\r\n                        if(retval.group === CB) {\r\n                            var t = new Symbol(1);\r\n                            retval.each(function (x) {\r\n                                if(x.fname === 'tan') {\r\n                                    x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\r\n                                }\r\n                                t = _.multiply(t, x);\r\n                            });\r\n                            retval = t;\r\n                        }\r\n                    }\r\n\r\n\r\n                    retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\r\n\r\n                    symbol = retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            fracSimp: function (symbol) {\r\n                //try a quick simplify of imaginary numbers\r\n                var den = symbol.getDenom();\r\n                var num = symbol.getNum();\r\n\r\n                if(num.isImaginary() && den.isImaginary())\r\n                    symbol = __.Simplify.complexSimp(num, den);\r\n\r\n                if(symbol.isComposite()) {\r\n                    if(symbol.power > 1) {\r\n                        symbol = _.expand(symbol);\r\n                    }\r\n\r\n                    var symbols = symbol.collectSymbols();\r\n                    //assumption 1.\r\n                    //since it's a composite, it has a length of at least 1\r\n                    var retval, a, b, d1, d2, n1, n2, x, y, c, den, num;\r\n                    a = symbols.pop(); //grab the first symbol\r\n                    //loop through each term and make denominator common\r\n                    while(symbols.length) {\r\n                        b = symbols.pop(); //grab the second symbol\r\n                        d1 = _.parse(a.getDenom());\r\n                        d2 = _.parse(b.getDenom());\r\n                        n1 = a.getNum();\r\n                        n2 = b.getNum();\r\n                        c = _.multiply(d1.clone(), d2.clone());\r\n                        x = _.multiply(n1, d2);\r\n                        y = _.multiply(n2, d1);\r\n                        a = _.divide(_.add(x, y), c);\r\n                    }\r\n                    den = _.expand(a.getDenom());\r\n                    num = _.expand(a.getNum());\r\n\r\n                    //simplify imaginary\r\n                    if(num.isImaginary() && den.isImaginary()) {\r\n                        retval = __.Simplify.complexSimp(num, den);\r\n                    }\r\n                    else {\r\n                        retval = _.divide(num, den);\r\n                    }\r\n\r\n                    //we've already hit the simplest form so return that\r\n                    if(retval.equals(symbol)) {\r\n                        return symbol;\r\n                    }\r\n\r\n                    //otherwise simplify it some more\r\n                    return __.Simplify.simplify(retval);\r\n                }\r\n                return symbol;\r\n            },\r\n            ratSimp: function (symbol) {\r\n                if(symbol.group === CB) {\r\n                    var den = symbol.getDenom();\r\n                    var num = symbol.getNum().distributeMultiplier();\r\n                    var d = __.Simplify.fracSimp(den);\r\n                    var n = __.Simplify.fracSimp(num);\r\n                    symbol = _.divide(n, d);\r\n                }\r\n                return symbol;\r\n            },\r\n            sqrtSimp: function (symbol, sym_array) {\r\n                var retval;\r\n                if(symbol.isSQRT()) {\r\n                    var factored = __.Factor.factor(symbol.args[0].clone());\r\n                    var m = _.parse(factored.multiplier);\r\n                    var sign = m.sign();\r\n\r\n                    var retval = _.sqrt(m.abs());\r\n                    var arg;\r\n\r\n                    if(isInt(retval)) {\r\n\r\n                        if(factored.group === CB) {\r\n                            var rem = new Symbol(1);\r\n\r\n                            factored.each(function (x) {\r\n                                if(x.group === N) {\r\n                                    var trial = _.sqrt(x.clone());\r\n\r\n                                    // Multiply back sqrt if it's an integer otherwise just put back the number\r\n                                    if(isInt(trial)) {\r\n                                        retval = _.multiply(retval, trial);\r\n                                    }\r\n                                    else {\r\n                                        rem = _.multiply(rem, x);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    rem = _.multiply(rem, x);\r\n                                }\r\n\r\n                            });\r\n                            var t = _.multiply(rem, _.parse(sign));\r\n                            arg = _.sqrt(t.clone());\r\n\r\n                            // Expand if it's imaginary\r\n                            if(arg.isImaginary) {\r\n                                arg = _.sqrt(_.expand(t.clone()));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Strip the multiplier\r\n                            arg = _.sqrt(factored.clone().toUnitMultiplier());\r\n                        }\r\n                        return _.multiply(retval, arg);\r\n\r\n                    }\r\n\r\n                }\r\n                else if(symbol.isComposite() && symbol.isLinear()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.Simplify.sqrtSimp(x));\r\n                    }, true);\r\n                    // Put back the multiplier\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    retval = _.parse(symbol.multiplier);\r\n                    symbol.each(function (x) {\r\n                        var simp = __.Simplify.sqrtSimp(x);\r\n                        retval = _.multiply(retval, simp);\r\n\r\n                    }, true);\r\n                    // Put back the power\r\n                    retval = _.pow(retval, _.parse(symbol.power));\r\n                }\r\n\r\n                return retval ? retval : _.parse(symbol);\r\n            },\r\n            /**\r\n             * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n             * @param {Symbol} symbol\r\n             * @return {Array} The symbol and the matched patterns\r\n             */\r\n            patternSub: function (symbol) {\r\n                var patterns = {};\r\n\r\n                var has_CP = function (symbol) {\r\n                    var found = false;\r\n                    symbol.each(function (x) {\r\n                        if(x.group === CP) {\r\n                            found = true;\r\n                        }\r\n                        else if(x.symbols) {\r\n                            found = has_CP(x);\r\n                        }\r\n                    });\r\n\r\n                    return found;\r\n                };\r\n\r\n                var collect = function (sym) {\r\n                    // We loop through each symbol looking for anything in the simplest\r\n                    // form of ax+byz+...\r\n                    sym.each(function (x) {\r\n                        // Items of group N,P,S, need to apply\r\n                        if(!x.symbols && x.group !== FN) {\r\n                            return;\r\n                        }\r\n\r\n                        // Check to see if it has any symbols of group CP\r\n                        // Get the patterns in that symbol instead if it has anything of group CP\r\n                        if(has_CP(x)) {\r\n                            collect(x);\r\n                        }\r\n                        else {\r\n                            if(!patterns[x.value]) {\r\n                                var u = core.Utils.getU(symbol);\r\n                                // Get a u value and mark it for subsitution\r\n                                patterns[x.value] = u;\r\n                                symbol = symbol.sub(x.value, u);\r\n                            }\r\n                        }\r\n                    }, true);\r\n                };\r\n\r\n                // Collect a list of patterns\r\n                collect(symbol);\r\n\r\n                return [symbol, patterns];\r\n            },\r\n            simplify: function (symbol) {\r\n                //remove the multiplier to make calculation easier;\r\n                var sym_array = __.Simplify.strip(symbol);\r\n                symbol = sym_array.pop();\r\n                //remove gcd from denominator\r\n                symbol = __.Simplify.fracSimp(symbol);\r\n\r\n                //nothing more to do\r\n                if(symbol.isConstant() || symbol.group === core.groups.S) {\r\n                    sym_array.push(symbol);\r\n                    var ret = __.Simplify.unstrip(sym_array, symbol);\r\n                    return ret;\r\n                }\r\n\r\n                //var patterns;\r\n\r\n                var simplified = symbol.clone(); //make a copy\r\n\r\n                //[simplified, patterns] = __.Simplify.patternSub(symbol);\r\n\r\n                // Simplify sqrt within the symbol\r\n//                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\r\n\r\n                // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\r\n                simplified = __.Simplify.trigSimp(simplified);\r\n\r\n                // Simplify common denominators\r\n                simplified = __.Simplify.ratSimp(simplified);\r\n\r\n                // First go for the \"cheapest\" simplification which may eliminate \r\n                // your problems right away. factor -> evaluate. Remember\r\n                // that there's no need to expand since factor already does that\r\n\r\n                simplified = __.Factor.factor(simplified);\r\n\r\n                //If the simplfied is a sum then we can make a few more simplifications\r\n                //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\r\n                if(simplified.group === core.groups.CP && simplified.isLinear()) {\r\n                    var m = simplified.multiplier.clone();\r\n                    simplified.toUnitMultiplier(); //strip the multiplier\r\n                    var r = new Symbol(0);\r\n                    //return the sum of simplifications\r\n                    simplified.each(function (x) {\r\n                        var s = __.Simplify.simplify(x);\r\n                        r = _.add(r, s);\r\n                    });\r\n                    simplified = r;\r\n                    //put back the multiplier\r\n                    r.multiplier = r.multiplier.multiply(m);\r\n                }\r\n\r\n                //place back multiplier and return\r\n                var retval = __.Simplify.unstrip(sym_array, simplified);\r\n\r\n                // Back substitute\r\n                /*\r\n                 for(var x in patterns) {\r\n                 retval = retval.sub(patterns[x], x);\r\n                 }\r\n                 */\r\n\r\n                return retval;\r\n            }\r\n        },\r\n\r\n        Classes: {\r\n            Polynomial: Polynomial,\r\n            Factors: Factors,\r\n            MVTerm: MVTerm\r\n        }\r\n    };\r\n\r\n    // Add a link to simplify\r\n    core.Expression.prototype.simplify = function () {\r\n        return __.Simplify.simplify(this.symbol);\r\n    };\r\n\r\n    nerdamer.useAlgebraDiv = function () {\r\n        var divide = __.divideFn = _.divide;\r\n        var calls = 0; //keep track of how many calls were made\r\n        _.divide = function (a, b) {\r\n            calls++;\r\n            var ans;\r\n            if(calls === 1) //check if this is the first call. If it is use algebra divide\r\n                ans = core.Algebra.divide(a, b);\r\n            else //otherwise use parser divide\r\n                ans = divide(a, b);\r\n            calls = 0; //reset the number of calls back to none\r\n            return ans;\r\n        };\r\n    };\r\n\r\n    nerdamer.useParserDiv = function () {\r\n        if(__.divideFn)\r\n            _.divide = __.divideFn;\r\n        delete __.divideFn;\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'factor',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Factor.factor;\r\n            }\r\n        },\r\n        {\r\n            name: 'simplify',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Simplify.simplify;\r\n            }\r\n        },\r\n        {\r\n            name: 'gcd',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.gcd;\r\n            }\r\n        },\r\n        {\r\n            name: 'lcm',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.lcm;\r\n            }\r\n        },\r\n        {\r\n            name: 'roots',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.roots;\r\n            }\r\n        },\r\n        {\r\n            name: 'divide',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.divide;\r\n            }\r\n        },\r\n        {\r\n            name: 'div',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.div;\r\n            }\r\n        },\r\n        {\r\n            name: 'partfrac',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.PartFrac.partfrac;\r\n            }\r\n        },\r\n        {\r\n            name: 'deg',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.degree;\r\n            }\r\n        },\r\n        {\r\n            name: 'coeffs',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function () {\r\n                    var coeffs = __.coeffs.apply(__, arguments);\r\n                    return new core.Vector(coeffs);\r\n                };\r\n                return f;\r\n            }\r\n        },\r\n        {\r\n            name: 'line',\r\n            visible: true,\r\n            numargs: [2, 3],\r\n            build: function () {\r\n                return __.line;\r\n            }\r\n        },\r\n        {\r\n            name: 'sqcomp',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function (x, v) {\r\n                    try {\r\n                        v = v || variables(x)[0];\r\n                        var sq = __.sqComplete(x.clone(), v);\r\n                        return sq.f;\r\n                    }\r\n                    catch(e) {\r\n                        return x;\r\n                    }\r\n                };\r\n                return f;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.api();\r\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92YW5pbGxhLWludGVncmF0aW9uLTJkLy4vbm9kZV9tb2R1bGVzL25lcmRhbWVyL0FsZ2VicmEuanM/YWVjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBBdXRob3IgOiBNYXJ0aW4gRG9ua1xyXG4gKiBXZWJzaXRlIDogaHR0cDovL3d3dy5uZXJkYW1lci5jb21cclxuICogRW1haWwgOiBtYXJ0aW4uci5kb25rQGdtYWlsLmNvbVxyXG4gKiBMaWNlbnNlIDogTUlUXHJcbiAqIFNvdXJjZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qaWdnenNvbi9uZXJkYW1lclxyXG4gKi9cclxuXHJcbi8qIGdsb2JhbCBtb2R1bGUsIEZ1bmN0aW9uICovXHJcblxyXG5pZigodHlwZW9mIG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB2YXIgbmVyZGFtZXIgPSByZXF1aXJlKCcuL25lcmRhbWVyLmNvcmUuanMnKTtcclxuICAgIHJlcXVpcmUoJy4vQ2FsY3VsdXMuanMnKTtcclxufVxyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIC8qc2hvcnRjdXRzKi9cclxuICAgIHZhciBjb3JlID0gbmVyZGFtZXIuZ2V0Q29yZSgpLFxyXG4gICAgICAgICAgICBfID0gY29yZS5QQVJTRVIsXHJcbiAgICAgICAgICAgIE4gPSBjb3JlLmdyb3Vwcy5OLFxyXG4gICAgICAgICAgICBQID0gY29yZS5ncm91cHMuUCxcclxuICAgICAgICAgICAgUyA9IGNvcmUuZ3JvdXBzLlMsXHJcbiAgICAgICAgICAgIEVYID0gY29yZS5ncm91cHMuRVgsXHJcbiAgICAgICAgICAgIEZOID0gY29yZS5ncm91cHMuRk4sXHJcbiAgICAgICAgICAgIFBMID0gY29yZS5ncm91cHMuUEwsXHJcbiAgICAgICAgICAgIENQID0gY29yZS5ncm91cHMuQ1AsXHJcbiAgICAgICAgICAgIENCID0gY29yZS5ncm91cHMuQ0IsXHJcbiAgICAgICAgICAgIGtleXMgPSBjb3JlLlV0aWxzLmtleXMsXHJcbiAgICAgICAgICAgIGV2ZW4gPSBjb3JlLlV0aWxzLmV2ZW4sXHJcbiAgICAgICAgICAgIHZhcmlhYmxlcyA9IGNvcmUuVXRpbHMudmFyaWFibGVzLFxyXG4gICAgICAgICAgICBmb3JtYXQgPSBjb3JlLlV0aWxzLmZvcm1hdCxcclxuICAgICAgICAgICAgcm91bmQgPSBjb3JlLlV0aWxzLnJvdW5kLFxyXG4gICAgICAgICAgICBGcmFjID0gY29yZS5GcmFjLFxyXG4gICAgICAgICAgICBpc0ludCA9IGNvcmUuVXRpbHMuaXNJbnQsXHJcbiAgICAgICAgICAgIFN5bWJvbCA9IGNvcmUuU3ltYm9sLFxyXG4gICAgICAgICAgICBDT05TVF9IQVNIID0gY29yZS5TZXR0aW5ncy5DT05TVF9IQVNILFxyXG4gICAgICAgICAgICBtYXRoID0gY29yZS5VdGlscy5pbXBvcnRGdW5jdGlvbnMoKSxcclxuICAgICAgICAgICAgZXZhbHVhdGUgPSBjb3JlLlV0aWxzLmV2YWx1YXRlO1xyXG4gICAgLy8qKioqKioqKioqKioqKiogQ0xBU1NFUyAqKioqKioqKioqKioqKiovL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIHN5bWJvbCBpbnRvIGFuIGVxdWl2YWxlbnQgcG9seW5vbWlhbCBhcnJheXMgb2YgXHJcbiAgICAgKiB0aGUgZm9ybSBbW2NvZWZmaWNpZW50XzEsIHBvd2VyXzFdLFtjb2VmZmljaWVudF8yLCBwb3dlcl8yXSwgLi4uIF1cclxuICAgICAqIFVuaXZhcmlhdGUgcG9seW1pYWxzIG9ubHkuIFxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x8TnVtYmVyfSBzeW1ib2xcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YXJpYWJsZSBUaGUgdmFyaWFibGUgbmFtZSBvZiB0aGUgcG9seW5vbWlhbFxyXG4gICAgICogQHBhcmFtIHtpbnR9IG9yZGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFBvbHlub21pYWwoc3ltYm9sLCB2YXJpYWJsZSwgb3JkZXIpIHtcclxuICAgICAgICBpZihjb3JlLlV0aWxzLmlzU3ltYm9sKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZShzeW1ib2wpO1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlID0gdGhpcy52YXJpYWJsZSB8fCB2YXJpYWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZighaXNOYU4oc3ltYm9sKSkge1xyXG4gICAgICAgICAgICBvcmRlciA9IG9yZGVyIHx8IDA7XHJcbiAgICAgICAgICAgIGlmKHZhcmlhYmxlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5leGNlcHRpb25zLkludmFsaWRWYXJpYWJsZU5hbWVFcnJvcignUG9seW5vbWlhbCBleHBlY3RzIGEgdmFyaWFibGUgbmFtZSB3aGVuIGNyZWF0aW5nIHVzaW5nIG9yZGVyJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29lZmZzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuY29lZmZzW29yZGVyXSA9IHN5bWJvbDtcclxuICAgICAgICAgICAgdGhpcy5maWxsKHN5bWJvbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodHlwZW9mIHN5bWJvbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZShfLnBhcnNlKHN5bWJvbCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIFBvbHlub21pYWwgZ2l2ZW4gYW4gYXJyYXkgb2YgY29lZmZpY2llbnRzXHJcbiAgICAgKiBAcGFyYW0ge2ludFtdfSBhcnJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YXJpYWJsZVxyXG4gICAgICogQHJldHVybnMge1BvbHlub21pYWx9XHJcbiAgICAgKi9cclxuICAgIFBvbHlub21pYWwuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFyciwgdmFyaWFibGUpIHtcclxuICAgICAgICBpZih0eXBlb2YgdmFyaWFibGUgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5leGNlcHRpb25zLkludmFsaWRWYXJpYWJsZU5hbWVFcnJvcignQSB2YXJpYWJsZSBuYW1lIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgcG9seW5vbWlhbCBmcm9tIGFycmF5Jyk7XHJcbiAgICAgICAgdmFyIHAgPSBuZXcgUG9seW5vbWlhbCgpO1xyXG4gICAgICAgIHAuY29lZmZzID0gYXJyO1xyXG4gICAgICAgIHAudmFyaWFibGUgPSB2YXJpYWJsZTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH07XHJcblxyXG4gICAgUG9seW5vbWlhbC5maXQgPSBmdW5jdGlvbiAoYzEsIGMyLCBuLCBiYXNlLCBwLCB2YXJpYWJsZSkge1xyXG4gICAgICAgIC8vYWZ0ZXIgaGF2aW5nIGxvb3BlZCB0aHJvdWdoIGFuZCBtb2QgMTAgdGhlIG51bWJlciB0byBnZXQgdGhlIG1hdGNoaW5nIGZhY3RvclxyXG4gICAgICAgIHZhciB0ZXJtcyA9IG5ldyBBcnJheShwICsgMSksXHJcbiAgICAgICAgICAgICAgICB0ID0gbiAtIGMyO1xyXG4gICAgICAgIHRlcm1zWzBdID0gYzI7IC8vdGhlIGNvbnN0YW50cyBpcyBhc3N1bWVkIHRvIGJlIGNvcnJlY3RcclxuICAgICAgICAvL2NvbnN0YW50IGZvciB4XnAgaXMgYWxzbyBhc3N1bWVkIGtub3cgc28gYWRkXHJcbiAgICAgICAgdGVybXNbcF0gPSBjMTtcclxuICAgICAgICB0IC09IGMxICogTWF0aC5wb3coYmFzZSwgcCk7XHJcbiAgICAgICAgLy9zdGFydCBmaXR0aW5nXHJcbiAgICAgICAgZm9yKHZhciBpID0gcCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBNYXRoLnBvdyhiYXNlLCBpKSwgLy93ZSB3YW50IGFzIG1hbnkgd2hvbGVzIGFzIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IHQgLyBiLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSBNYXRoLnNpZ24ocSk7XHJcbiAgICAgICAgICAgIHZhciBjID0gc2lnbiAqIE1hdGguZmxvb3IoTWF0aC5hYnMocSkpO1xyXG4gICAgICAgICAgICB0IC09IGMgKiBiO1xyXG4gICAgICAgICAgICB0ZXJtc1tpXSA9IGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHQgIT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGVybXNbaV0gPSBuZXcgRnJhYyh0ZXJtc1tpXSk7XHJcblxyXG4gICAgICAgIHJldHVybiBQb2x5bm9taWFsLmZyb21BcnJheSh0ZXJtcywgdmFyaWFibGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBQb2x5bm9taWFsLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBTeW1ib2wgdG8gUG9seW5vbWlhbFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBjIC0gYSBjb2xsZWN0b3IgYXJyYXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7UG9seW5vbWlhbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHN5bWJvbCwgYykge1xyXG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlID0gdmFyaWFibGVzKHN5bWJvbClbMF07XHJcbiAgICAgICAgICAgIGlmKCFzeW1ib2wuaXNQb2x5KCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBjb3JlLmV4Y2VwdGlvbnMuTmVyZGFtZXJUeXBlRXJyb3IoJ1BvbHlub21pYWwgRXhwZWN0ZWQhIFJlY2VpdmVkICcgKyBjb3JlLlV0aWxzLnRleHQoc3ltYm9sKSk7XHJcbiAgICAgICAgICAgIGMgPSBjIHx8IFtdO1xyXG4gICAgICAgICAgICBpZighc3ltYm9sLnBvd2VyLmFic0VxdWFscygxKSlcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLk4pIHtcclxuICAgICAgICAgICAgICAgIGNbMF0gPSBzeW1ib2wubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gY29yZS5ncm91cHMuUykge1xyXG4gICAgICAgICAgICAgICAgY1tzeW1ib2wucG93ZXIudG9EZWNpbWFsKCldID0gc3ltYm9sLm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gc3ltYm9sLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViID0gc3ltYm9sLnN5bWJvbHNbeF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gc3ViLnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaXNTeW1ib2wocCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLmV4Y2VwdGlvbnMuTmVyZGFtZXJUeXBlRXJyb3IoJ3Bvd2VyIGNhbm5vdCBiZSBhIFN5bWJvbCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwID0gc3ViLmdyb3VwID09PSBOID8gMCA6IHAudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ViLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZShzdWIsIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY1twXSA9IHN1Yi5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb2VmZnMgPSBjO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaWxscyBpbiB0aGUgaG9sZXMgaW4gYSBwb2x5bm9taWFsIHdpdGggemVyb2VzXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgbnVtYmVyIHRvIGZpbGwgdGhlIGhvbGVzIHdpdGhcclxuICAgICAgICAgKi9cclxuICAgICAgICBmaWxsOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB4ID0gTnVtYmVyKHgpIHx8IDA7XHJcbiAgICAgICAgICAgIHZhciBsID0gdGhpcy5jb2VmZnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNvZWZmc1tpXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmZnNbaV0gPSBuZXcgRnJhYyh4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgaGlnaGVyIG9yZGVyIHplcm9zIG9yIGEgc3BlY2lmaWMgY29lZmZpY2llbnRcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJpbTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUobC0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY29lZmZzW2xdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVxdWFsc1plcm8gPSBjLmVxdWFscygwKTtcclxuICAgICAgICAgICAgICAgIGlmKGMgJiYgZXF1YWxzWmVybykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGwgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJucyBwb2x5bm9taWFsIG1vZCBwICoqY3VycmVudGx5IGZhaWxzKipcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2x5bm9taWFsfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1vZFA6IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgICAgIHZhciBsID0gdGhpcy5jb2VmZnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHRoaXMuY29lZmZzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoYyA8IDApIHsgLy9nbyBib3Jyb3dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYjsgLy9hIGNvZWZmaWNpZW50ID4gMFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IGk7IGogPCBsOyBqKyspIHsvL3N0YXJ0aW5nIGZyb20gd2hlcmUgd2UgbGVmdCBvZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb2VmZnNbal0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5jb2VmZnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYikgeyAvL2lmIHN1Y2ggYSBjb2VmZmljaWVudCBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGo7IGogPiBpOyBqLS0pIHsgLy9nbyBkb3duIHRoZSBsaW5lIGFuZCBhZGp1c3QgdXNpbmcgcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmZnNbal0gPSB0aGlzLmNvZWZmc1tqXS5zdWJ0cmFjdChuZXcgRnJhYygxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmc1tqIC0gMV0gPSB0aGlzLmNvZWZmc1tqIC0gMV0uYWRkKG5ldyBGcmFjKHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jb2VmZnNbaV07IC8vcmVzZXQgY1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGMubW9kKHApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHcgPSBjLnN1YnRyYWN0KGQpLmRpdmlkZShwKTtcclxuICAgICAgICAgICAgICAgIGlmKCF3LmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cF9vbmUgPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuY29lZmZzW3VwX29uZV0gfHwgbmV3IEZyYWMoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQuYWRkKHcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZzW3VwX29uZV0gPSBuZXcgRnJhYyhuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmc1tpXSA9IG5ldyBGcmFjKGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgdG9nZXRoZXIgMiBwb2x5bm9taWFsc1xyXG4gICAgICAgICAqIEBwYXJhbSB7UG9seW5vbWlhbH0gcG9seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHBvbHkpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSBNYXRoLm1heCh0aGlzLmNvZWZmcy5sZW5ndGgsIHBvbHkuY29lZmZzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gKHRoaXMuY29lZmZzW2ldIHx8IG5ldyBGcmFjKDApKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IChwb2x5LmNvZWZmc1tpXSB8fCBuZXcgRnJhYygwKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmc1tpXSA9IGEuYWRkKGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyB0b2dldGhlciAyIHBvbHlub21pYWxzXHJcbiAgICAgICAgICogQHBhcmFtIHtQb2x5bm9taWFsfSBwb2x5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uIChwb2x5KSB7XHJcbiAgICAgICAgICAgIHZhciBsID0gTWF0aC5tYXgodGhpcy5jb2VmZnMubGVuZ3RoLCBwb2x5LmNvZWZmcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9ICh0aGlzLmNvZWZmc1tpXSB8fCBuZXcgRnJhYygwKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSAocG9seS5jb2VmZnNbaV0gfHwgbmV3IEZyYWMoMCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmZnNbaV0gPSBhLnN1YnRyYWN0KGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiAocG9seSkge1xyXG4gICAgICAgICAgICB2YXIgdmFyaWFibGUgPSB0aGlzLnZhcmlhYmxlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZW5kID0gY29yZS5VdGlscy5hcnJheUNsb25lKHRoaXMuY29lZmZzKSxcclxuICAgICAgICAgICAgICAgICAgICBkaXZpc29yID0gY29yZS5VdGlscy5hcnJheUNsb25lKHBvbHkuY29lZmZzKSxcclxuICAgICAgICAgICAgICAgICAgICBuID0gZGl2aWRlbmQubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIG1wID0gZGl2aXNvci5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gW107XHJcblxyXG4gICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCB0aGUgZGl2aWRlbmRcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBuIC0gKGkgKyAxKTtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBkaWZmZXJlbmNlIG9mIHRoZSBwb3dlcnNcclxuICAgICAgICAgICAgICAgIHZhciBkID0gcCAtIG1wO1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIHF1b3RpZW50IG9mIHRoZSBjb2VmZmljaWVudHNcclxuICAgICAgICAgICAgICAgIHZhciBxID0gZGl2aWRlbmRbcF0uZGl2aWRlKGRpdmlzb3JbbXBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihkIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsvL3RoZSBkaXZpc29yIGlzIG5vdCBncmVhdGVyIHRoYW4gdGhlIGRpdmlkZW5kXHJcbiAgICAgICAgICAgICAgICAvL3BsYWNlIGl0IGluIHRoZSBxdW90aWVudFxyXG4gICAgICAgICAgICAgICAgcXVvdGllbnRbZF0gPSBxO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPD0gbXA7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVkdWNlIHRoZSBkaXZpZGVuZFxyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZW5kW2ogKyBkXSA9IGRpdmlkZW5kW2ogKyBkXS5zdWJ0cmFjdCgoZGl2aXNvcltqXS5tdWx0aXBseShxKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2NsZWFuIHVwXHJcbiAgICAgICAgICAgIHZhciBwMSA9IFBvbHlub21pYWwuZnJvbUFycmF5KGRpdmlkZW5kLCB2YXJpYWJsZSB8fCAneCcpLnRyaW0oKSwgLy9wYXNzIGluIHggZm9yIHNhZmV0eVxyXG4gICAgICAgICAgICAgICAgICAgIHAyID0gUG9seW5vbWlhbC5mcm9tQXJyYXkocXVvdGllbnQsIHZhcmlhYmxlIHx8ICd4Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiBbcDIsIHAxXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAocG9seSkge1xyXG4gICAgICAgICAgICB2YXIgbDEgPSB0aGlzLmNvZWZmcy5sZW5ndGgsIGwyID0gcG9seS5jb2VmZnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBbXTsgLy9hcnJheSB0byBiZSByZXR1cm5lZFxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHgxID0gdGhpcy5jb2VmZnNbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrID0gaSArIGosIC8vYWRkIHRoZSBwb3dlcnMgdG9nZXRoZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0gcG9seS5jb2VmZnNbal0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gY1trXSB8fCBuZXcgRnJhYygwKTsgLy9nZXQgdGhlIGV4aXN0aW5nIHRlcm0gZnJvbSB0aGUgbmV3IGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgY1trXSA9IGUuYWRkKHgxLm11bHRpcGx5KHgyKSk7IC8vbXVsdGlwbHkgdGhlIGNvZWZmaWNpZW50cyBhbmQgYWRkIHRvIG5ldyBwb2x5bm9taWFsIGFycmF5XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb2VmZnMgPSBjO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiBhIHBvbHlub21pYWwgaXMgemVyb1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzWmVybzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNvZWZmc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKCFlLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogU3Vic3RpdHV0ZXMgaW4gYSBudW1iZXIgbiBpbnRvIHRoZSBwb2x5bm9taWFsIHAobilcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtGcmFjfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN1YjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgdmFyIHN1bSA9IG5ldyBGcmFjKDApLCBsID0gdGhpcy5jb2VmZnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMuY29lZmZzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoIXQuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bS5hZGQodC5tdWx0aXBseShuZXcgRnJhYyhNYXRoLnBvdyhuLCBpKSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBwb2x5bm9taWFsXHJcbiAgICAgICAgICogQHJldHVybnMge1BvbHlub21pYWx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHAgPSBuZXcgUG9seW5vbWlhbCgpO1xyXG4gICAgICAgICAgICBwLmNvZWZmcyA9IHRoaXMuY29lZmZzO1xyXG4gICAgICAgICAgICBwLnZhcmlhYmxlID0gdGhpcy52YXJpYWJsZTtcclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBkZWdyZWUgb2YgdGhlIHBvbHlub21pYWxcclxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRlZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaW0oKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbGVhZCBjb2VmZmljaWVudFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtGcmFjfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxjOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmc1t0aGlzLmRlZygpXS5jbG9uZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgcG9seW5vbWlhbCBpbnRvIGEgbW9uaWMgcG9seW5vbWlhbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2x5bm9taWFsfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG1vbmljOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsYyA9IHRoaXMubGMoKSwgbCA9IHRoaXMuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZzW2ldID0gdGhpcy5jb2VmZnNbaV0uZGl2aWRlKGxjKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBHQ0Qgb2YgdHdvIHBvbHlub21pYWxzXHJcbiAgICAgICAgICogQHBhcmFtIHtQb2x5bm9taWFsfSBwb2x5XHJcbiAgICAgICAgICogQHJldHVybnMge1BvbHlub21pYWx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2NkOiBmdW5jdGlvbiAocG9seSkge1xyXG4gICAgICAgICAgICAvL2dldCB0aGUgbWF4aW11bSBwb3dlciBvZiBlYWNoXHJcbiAgICAgICAgICAgIHZhciBtcDEgPSB0aGlzLmNvZWZmcy5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgIG1wMiA9IHBvbHkuY29lZmZzLmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgVDtcclxuICAgICAgICAgICAgLy9zd2FwIHNvIHdlIGFsd2F5cyBoYXZlIHRoZSBncmVhdGVyIHBvd2VyIGZpcnN0XHJcbiAgICAgICAgICAgIGlmKG1wMSA8IG1wMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvbHkuZ2NkKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlKCFwb2x5LmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHBvbHkuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIGEgPSBhLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBUID0gYS5kaXZpZGUodCk7XHJcbiAgICAgICAgICAgICAgICBwb2x5ID0gVFsxXTtcclxuICAgICAgICAgICAgICAgIGEgPSB0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZ2NkID0gY29yZS5NYXRoMi5RR0NELmFwcGx5KG51bGwsIGEuY29lZmZzKTtcclxuICAgICAgICAgICAgaWYoIWdjZC5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gYS5jb2VmZnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGEuY29lZmZzW2ldID0gYS5jb2VmZnNbaV0uZGl2aWRlKGdjZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaWZmZXJlbnRpYXRlcyB0aGUgcG9seW5vbWlhbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2x5bm9taWFsfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpZmY6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ld19hcnJheSA9IFtdLCBsID0gdGhpcy5jb2VmZnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgbmV3X2FycmF5LnB1c2godGhpcy5jb2VmZnNbaV0ubXVsdGlwbHkobmV3IEZyYWMoaSkpKTtcclxuICAgICAgICAgICAgdGhpcy5jb2VmZnMgPSBuZXdfYXJyYXk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZWdyYXRlcyB0aGUgcG9seW5vbWlhbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2x5bm9taWFsfSBcclxuICAgICAgICAgKi9cclxuICAgICAgICBpbnRlZ3JhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5ld19hcnJheSA9IFswXSwgbCA9IHRoaXMuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgRnJhYyhpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBuZXdfYXJyYXlbY10gPSB0aGlzLmNvZWZmc1tpXS5kaXZpZGUoYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb2VmZnMgPSBuZXdfYXJyYXk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgR3JlYXRlc3QgY29tbW9uIGZhY3RvciBvZiB0aGUgcG9seW5vbWlhbFxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gdG9Qb2x5bm9taWFsIC0gdHJ1ZSBpZiBhIHBvbHlub21pYWwgaXMgd2FudGVkXHJcbiAgICAgICAgICogQHJldHVybnMge0ZyYWN8UG9seW5vbWlhbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBnY2Y6IGZ1bmN0aW9uICh0b1BvbHlub21pYWwpIHtcclxuICAgICAgICAgICAgLy9nZXQgdGhlIGZpcnN0IG5vemVybyBjb2VmZmljaWVudCBhbmQgcmV0dXJucyBpdHMgcG93ZXJcclxuICAgICAgICAgICAgdmFyIGZueiA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZighYVtpXS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGNhID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmNvZWZmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNvZWZmc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKCFjLmVxdWFscygwKSAmJiBjYS5pbmRleE9mKGMpID09PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICBjYS5wdXNoKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwID0gW2NvcmUuTWF0aDIuUUdDRC5hcHBseSh1bmRlZmluZWQsIGNhKSwgZm56KHRoaXMuY29lZmZzKV0udG9EZWNpbWFsKCk7XHJcblxyXG4gICAgICAgICAgICBpZih0b1BvbHlub21pYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJyID0gW107XHJcbiAgICAgICAgICAgICAgICBwYXJyW3BbMV0gLSAxXSA9IHBbMF07XHJcbiAgICAgICAgICAgICAgICBwID0gUG9seW5vbWlhbC5mcm9tQXJyYXkocGFyciwgdGhpcy52YXJpYWJsZSkuZmlsbCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJhaXNlcyBhIHBvbHlub21pYWwgUCB0byBhIHBvd2VyIHAgLT4gUF5wLiBlLmcuICh4KzEpXjJcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IGluY2xfaW1nIC0gSW5jbHVkZSBpbWFnaW5hcnkgbnVtYmVycyBcclxuICAgICAgICAgKi9cclxuICAgICAgICBxdWFkOiBmdW5jdGlvbiAoaW5jbF9pbWcpIHtcclxuICAgICAgICAgICAgdmFyIHJvb3RzID0gW107XHJcbiAgICAgICAgICAgIGlmKHRoaXMuY29lZmZzLmxlbmd0aCA+IDMpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgcXVhZHJhdGljIG9yZGVyIG9mICcgKyAodGhpcy5jb2VmZnMubGVuZ3RoIC0gMSkpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmNvZWZmcy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvbHlub21pYWwgYXJyYXkgaGFzIG5vIHRlcm1zJyk7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5jb2VmZnNbMl0gfHwgMCwgYiA9IHRoaXMuY29lZmZzWzFdIHx8IDAsIGMgPSB0aGlzLmNvZWZmc1swXTtcclxuICAgICAgICAgICAgdmFyIGRzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xyXG4gICAgICAgICAgICBpZihkc2MgPCAwICYmICFpbmNsX2ltZylcclxuICAgICAgICAgICAgICAgIHJldHVybiByb290cztcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb290c1swXSA9ICgtYiArIE1hdGguc3FydChkc2MpKSAvICgyICogYSk7XHJcbiAgICAgICAgICAgICAgICByb290c1sxXSA9ICgtYiAtIE1hdGguc3FydChkc2MpKSAvICgyICogYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJvb3RzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFrZXMgcG9seW5vbWlhbCBzcXVhcmUgZnJlZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzcXVhcmVGcmVlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gMSxcclxuICAgICAgICAgICAgICAgICAgICBiID0gYS5jbG9uZSgpLmRpZmYoKSxcclxuICAgICAgICAgICAgICAgICAgICBjID0gYS5jbG9uZSgpLmdjZChiKSxcclxuICAgICAgICAgICAgICAgICAgICB3ID0gYS5kaXZpZGUoYylbMF07XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBQb2x5bm9taWFsLmZyb21BcnJheShbbmV3IEZyYWMoMSldLCBhLnZhcmlhYmxlKTtcclxuICAgICAgICAgICAgd2hpbGUoIWMuZXF1YWxzTnVtYmVyKDEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHcuZ2NkKGMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHogPSB3LmRpdmlkZSh5KVswXTtcclxuICAgICAgICAgICAgICAgIC8vb25lIG9mIHRoZSBmYWN0b3JzIG1heSBoYXZlIHNob3duIHVwIHNpbmNlIGl0J3Mgc3F1YXJlIGJ1dCBzbWFsbGVyIHRoYW4gdGhlIFxyXG4gICAgICAgICAgICAgICAgLy9vbmUgd2hlcmUgZmluZGluZ1xyXG4gICAgICAgICAgICAgICAgaWYoIXouZXF1YWxzTnVtYmVyKDEpICYmIGkgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSB6LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMTsgaiA8IGk7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5tdWx0aXBseSh6LmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHogPSB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0Lm11bHRpcGx5KHopO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgdyA9IHk7XHJcbiAgICAgICAgICAgICAgICBjID0gYy5kaXZpZGUoeSlbMF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbb3V0cHV0LCB3LCBpXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHBvbHlub21pYWwgdG8gU3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0b1N5bWJvbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuY29lZmZzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHRoaXMudmFyaWFibGU7XHJcbiAgICAgICAgICAgIGlmKGwgPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuU3ltYm9sKDApO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gbCAtIDEsIHN0ciA9ICcnO1xyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy9wbGFjZSB0aGUgcGx1cyBzaWduIGZvciBhbGwgYnV0IHRoZSBsYXN0IG9uZVxyXG4gICAgICAgICAgICAgICAgdmFyIHBsdXMgPSBpID09PSBlbmQgPyAnJyA6ICcrJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuY29lZmZzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoIWUuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAoZSArICcqJyArIHZhcmlhYmxlICsgJ14nICsgaSArIHBsdXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKHN0cik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgcG9seW5vbWlhbCBpcyBlcXVhbCB0byBhIG51bWJlclxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXF1YWxzTnVtYmVyOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaW0oKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmNvZWZmc1swXS50b0RlY2ltYWwoKSA9PT0gU3RyaW5nKHgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TeW1ib2woKS50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUT0RPXHJcbiAgICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICogVEhJUyBNRVRIT0QgSEFTIEEgTkFTVFkgSElEREVOIEJVRy4gSVQgSEFTIElOQ09OU0lTVEVOVCBSRVRVUk4gVFlQRVMgUFJJTUFSSUxZIERVRSBUTyBcclxuICAgICAqIFdST05HIEFTU1VNUFRJT05TIEFUIFRIRSBCRUdJTk5JTkcuIFRIRSBBU1NVTVBUSU9OIFdBUyBUSEFUIENPRUZGUyBXRVJFIEFMV0FZUyBHT0lORyBCRSBOVU1CRVJTXHJcbiAgICAgKiBOT1QgVEFLSU5HIElOVE8gQUNDT1VOVCBUSEFUIElNQUdJTkFSWSBOVU1CRVJTLiBGSVhJTkcgVEhJUyBCUkVBS1MgV0FZIFRPTyBNQU5ZIFRFU1RTIFxyXG4gICAgICogQVQgVEhFTSBNT01FTlQgV0hJQ0ggSSBET04nVCBIQVZFIFRPIEZJWFxyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqIElmIHRoZSBzeW1ib2xzIGlzIG9mIGdyb3VwIFBMIG9yIENQIGl0IHdpbGwgcmV0dXJuIHRoZSBtdWx0aXBsaWVycyBvZiBlYWNoIHN5bWJvbFxyXG4gICAgICogYXMgdGhlc2UgYXJlIHBvbHlub21pYWwgY29lZmZpY2llbnRzLiBDQiBzeW1ib2xzIGFyZSBnbHVlZCB0b2dldGhlciBieSBtdWx0aXBsaWNhdGlvblxyXG4gICAgICogc28gdGhlIHN5bWJvbCBtdWx0aXBsaWVyIGNhcnJpZXMgdGhlIGNvZWZmaWNpZW50cyBmb3IgYWxsIGNvbnRhaW5lZCBzeW1ib2xzLlxyXG4gICAgICogRm9yIFMgaXQganVzdCByZXR1cm5zIGl0J3Mgb3duIG11bHRpcGxpZXIuIFRoaXMgZnVuY3Rpb24gZG9lc24ndCBjYXJlIGlmIGl0J3MgYSBwb2x5bm9taWFsIG9yIG5vdFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYyBUaGUgY29lZmZpY2llbnQgYXJyYXlcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aF9vcmRlciBcclxuICAgICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAgICovXHJcbiAgICBTeW1ib2wucHJvdG90eXBlLmNvZWZmcyA9IGZ1bmN0aW9uIChjLCB3aXRoX29yZGVyKSB7XHJcbiAgICAgICAgaWYod2l0aF9vcmRlciAmJiAhdGhpcy5pc1BvbHkodHJ1ZSkpXHJcbiAgICAgICAgICAgIF8uZXJyb3IoJ1BvbHlub21pYWwgZXhwZWN0ZWQgd2hlbiByZXF1ZXN0aW5nIGNvZWZmaWNpZW50cyB3aXRoIG9yZGVyJyk7XHJcbiAgICAgICAgYyA9IGMgfHwgW107XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLmNsb25lKCkuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICBpZihzLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIHMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IHMuc3ltYm9sc1t4XTtcclxuICAgICAgICAgICAgICAgIGlmKHN1Yi5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViLmNsb25lKCkuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKS5jb2VmZnMoYywgd2l0aF9vcmRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih3aXRoX29yZGVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjW3N1Yi5pc0NvbnN0YW50KCkgPyAwIDogc3ViLnBvd2VyLnRvRGVjaW1hbCgpXSA9IHN1Yi5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLnB1c2goc3ViLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYod2l0aF9vcmRlcilcclxuICAgICAgICAgICAgICAgIGNbcy5pc0NvbnN0YW50KHRydWUpID8gMCA6IHMucG93ZXIudG9EZWNpbWFsKCldID0gcy5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKHMuZ3JvdXAgPT09IENCICYmIHMuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gbmV3IFN5bWJvbChzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGUgaW1hZ2luYXJ5IHBhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5pc0NvbnN0YW50KHRydWUpIHx8IHguaW1hZ2luYXJ5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IF8ubXVsdGlwbHkobSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5wdXNoKG0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGMucHVzaChzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vZmlsbCB0aGUgaG9sZXNcclxuICAgICAgICBpZih3aXRoX29yZGVyKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYoY1tpXSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNbaV0gPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH07XHJcbiAgICBTeW1ib2wucHJvdG90eXBlLnRCYXNlID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIGlmKHR5cGVvZiBtYXAgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bWJvbC50QmFzZSByZXF1aXJlcyBhIG1hcCBvYmplY3QhJyk7XHJcbiAgICAgICAgdmFyIHRlcm1zID0gW107XHJcbiAgICAgICAgdmFyIHN5bWJvbHMgPSB0aGlzLmNvbGxlY3RTeW1ib2xzKG51bGwsIG51bGwsIG51bGwsIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgbCA9IHN5bWJvbHMubGVuZ3RoO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IHN5bWJvbC5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICBudGVybSA9IG5ldyBNVlRlcm0oc3ltYm9sLm11bHRpcGxpZXIsIFtdLCBtYXApO1xyXG4gICAgICAgICAgICBpZihnID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHN5bWJvbC5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IHN5bWJvbC5zeW1ib2xzW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgIG50ZXJtLnRlcm1zW21hcFt4XV0gPSBzeW0ucG93ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBudGVybS50ZXJtc1ttYXBbc3ltYm9sLnZhbHVlXV0gPSBzeW1ib2wucG93ZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRlcm1zLnB1c2gobnRlcm0uZmlsbCgpKTtcclxuICAgICAgICAgICAgbnRlcm0udXBkYXRlQ291bnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRlcm1zO1xyXG4gICAgfTtcclxuICAgIFN5bWJvbC5wcm90b3R5cGUuYWx0VmFyID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgbSA9IHRoaXMubXVsdGlwbGllci50b1N0cmluZygpLCBwID0gdGhpcy5wb3dlci50b1N0cmluZygpO1xyXG4gICAgICAgIHJldHVybiAobSA9PT0gJzEnID8gJycgOiBtICsgJyonKSArIHggKyAocCA9PT0gJzEnID8gJycgOiAnXicgKyBwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHN5bWJvbHMgY29udGFpbiB0aGUgc2FtZSB2YXJpYWJsZXNcclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICovXHJcbiAgICBTeW1ib2wucHJvdG90eXBlLnNhbWVWYXJzID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgIGlmKCEodGhpcy5zeW1ib2xzIHx8IHRoaXMuZ3JvdXAgPT09IHN5bWJvbC5ncm91cCkpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5zeW1ib2xzW3hdLCBiID0gc3ltYm9sLnN5bWJvbHNbeF07XHJcbiAgICAgICAgICAgIGlmKCFiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZihhLnZhbHVlICE9PSBiLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdyb3VwcyB0aGUgdGVybXMgaW4gYSBzeW1ib2wgd2l0aCByZXNwZWN0IHRvIGEgdmFyaWFibGVcclxuICAgICAqIEZvciBpbnN0YW5jZSB0aGUgc3ltYm9sIHthKmJeMip4XjIrYSpiKnheMit4KzZ9IHJldHVybnMgWzYsMSxhKmIrYSpiXjJdXHJcbiAgICAgKiBAcmV0dXJucyB7RmFjdG9yc31cclxuICAgICAqL1xyXG4gICAgU3ltYm9sLnByb3RvdHlwZS5ncm91cFRlcm1zID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB4ID0gU3RyaW5nKHgpO1xyXG4gICAgICAgIHZhciBmLCBwLCBlZ3JvdXBlZDtcclxuICAgICAgICB2YXIgZ3JvdXBlZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICBpZihlLmdyb3VwID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgZWdyb3VwZWQgPSBlLmdyb3VwVGVybXMoeCk7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWdyb3VwZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBlZ3JvdXBlZFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihlbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFtpXSA9IGVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZiA9IGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuKGUsIHgsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcCA9IGYueC52YWx1ZSA9PT0geCA/IE51bWJlcihmLngucG93ZXIpIDogMDtcclxuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgZ3JvdXBlZFtwXSA9IF8uYWRkKGdyb3VwZWRbcF0gfHwgbmV3IFN5bWJvbCgwKSwgZi5hKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBncm91cGVkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoaXMgdG8gY29sbGVjdCBGYWN0b3JzXHJcbiAgICAgKiBAcmV0dXJucyB7U3ltYm9sW119XHJcbiAgICAgKi9cclxuICAgIFN5bWJvbC5wcm90b3R5cGUuY29sbGVjdEZhY3RvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcnMgPSBbXTtcclxuICAgICAgICBpZih0aGlzLmdyb3VwID09PSBDQilcclxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3JzLnB1c2goeC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBmYWN0b3JzLnB1c2godGhpcy5jbG9uZSgpKTtcclxuICAgICAgICByZXR1cm4gZmFjdG9ycztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEEgY29udGFpbmVyIGNsYXNzIGZvciBmYWN0b3JzXHJcbiAgICAgKiBAcmV0dXJucyB7RmFjdG9yc31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRmFjdG9ycygpIHtcclxuICAgICAgICB0aGlzLmZhY3RvcnMgPSB7fTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBGYWN0b3JzLnByb3RvdHlwZS5nZXROdW1iZXJTeW1ib2xpY3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG4gPSAwO1xyXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZigheC5pc0NvbnN0YW50KHRydWUpKVxyXG4gICAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgZmFjdG9ycyB0byB0aGUgZmFjdG9yIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtTeW1ib30gc1xyXG4gICAgICogQHJldHVybnMge0ZhY3RvcnN9XHJcbiAgICAgKi9cclxuICAgIEZhY3RvcnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgaWYocy5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvL25vdGhpbmcgdG8gYWRkXHJcblxyXG4gICAgICAgIC8vd2UgZG9uJ3Qgd2FudCB0byBjYXJyeSAtMSBhcyBhIGZhY3Rvci4gSWYgYSBmYWN0b3IgYWxyZWFkeSBleGlzdHMsXHJcbiAgICAgICAgLy90aGVuIGFkZCB0aGUgbWludXMgb25lIHRvIHRoYXQgZmFjdG9yIGFuZCByZXR1cm4uXHJcbiAgICAgICAgaWYocy5lcXVhbHMoLTEpICYmIHRoaXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgZm8gPSBjb3JlLlV0aWxzLmZpcnN0T2JqZWN0KHRoaXMuZmFjdG9ycywgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKF8uc3ltZnVuY3Rpb24oY29yZS5TZXR0aW5ncy5QQVJFTlRIRVNJUywgW2ZvLm9ial0pLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmFjdG9yc1tmby5rZXldO1xyXG4gICAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHMuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgIHZhciBmYWN0b3JzID0gdGhpcztcclxuICAgICAgICAgICAgaWYoIXMubXVsdGlwbGllci5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChuZXcgU3ltYm9sKHMubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICBzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKHgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJlQWRkKSAvL2lmIGEgcHJlQWRkIGZ1bmN0aW9uIHdhcyBkZWZpbmVkIGNhbGwgaXQgdG8gZG8gcHJlcFxyXG4gICAgICAgICAgICAgICAgcyA9IHRoaXMucHJlQWRkKHMpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnBGYWN0b3IpIC8vaWYgdGhlIHN5bWJvbCBpc24ndCBsaW5lYXIgYWRkIGJhY2sgdGhlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICBzID0gXy5wb3cocywgbmV3IFN5bWJvbCh0aGlzLnBGYWN0b3IpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpc19jb25zdGFudCA9IHMuaXNDb25zdGFudCgpO1xyXG4gICAgICAgICAgICBpZihpc19jb25zdGFudCAmJiBzLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvL2Rvbid0IGFkZCAxXHJcbiAgICAgICAgICAgIHZhciB2ID0gaXNfY29uc3RhbnQgPyBzLnZhbHVlIDogcy50ZXh0KCk7XHJcbiAgICAgICAgICAgIGlmKHYgaW4gdGhpcy5mYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY3RvcnNbdl0gPSBfLm11bHRpcGx5KHRoaXMuZmFjdG9yc1t2XSwgcyk7XHJcbiAgICAgICAgICAgICAgICAvL2RpZCB0aGUgYWRkaXRpb24gY2FuY2VsIG91dCB0aGUgZXhpc3RpbmcgZmFjdG9yPyBJZiBzbyByZW1vdmUgaXQgYW5kIGRlY3JlbWVudCB0aGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmZhY3RvcnNbdl0uZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmFjdG9yc1t2XTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWN0b3JzW3ZdID0gcztcclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmFjdG9yIG9iamVjdCB0byBhIFN5bWJvbFxyXG4gICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAqL1xyXG4gICAgRmFjdG9ycy5wcm90b3R5cGUudG9TeW1ib2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZhY3RvcmVkID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICB2YXIgZmFjdG9ycyA9IE9iamVjdC52YWx1ZXModGhpcy5mYWN0b3JzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLmdyb3VwID4gYi5ncm91cDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGZhY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gZmFjdG9yc1tpXTtcclxuXHJcbiAgICAgICAgICAgIC8vZG9uJ3Qgd3JhcCBncm91cCBTIG9yIEZOXHJcbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSBmLnBvd2VyLmVxdWFscygxKSAmJiBmLmZuYW1lICE9PSAnJyAvKiBkb24ndCB3cmFwIGl0IHR3aWNlICovID9cclxuICAgICAgICAgICAgICAgICAgICBfLnN5bWZ1bmN0aW9uKGNvcmUuUEFSRU5USEVTSVMsIFtmXSkgOiBmO1xyXG5cclxuICAgICAgICAgICAgZmFjdG9yZWQgPSBfLm11bHRpcGx5KGZhY3RvcmVkLCBmYWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmYWN0b3JlZC5mbmFtZSA9PT0gJycpXHJcbiAgICAgICAgICAgIGZhY3RvcmVkID0gU3ltYm9sLnVud3JhcFBBUkVOUyhmYWN0b3JlZCk7XHJcbiAgICAgICAgcmV0dXJuIGZhY3RvcmVkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTWVyZ2VzIDIgZmFjdG9yIG9iamVjdHMgaW50byBvbmVcclxuICAgICAqIEBwYXJhbSB7RmFjdG9yfSBvXHJcbiAgICAgKiBAcmV0dXJucyB7RmFjdG9yc31cclxuICAgICAqL1xyXG4gICAgRmFjdG9ycy5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGZvcih2YXIgeCBpbiBvKSB7XHJcbiAgICAgICAgICAgIGlmKHggaW4gdGhpcy5mYWN0b3JzKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWN0b3JzW3hdID0gXy5tdWx0aXBseSh0aGlzLmZhY3RvcnNbeF0sIG9beF0pO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZhY3RvcnNbeF0gPSBvW3hdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpdGVyYXRvciBmb3IgdGhlIGZhY3RvciBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgLSBjYWxsYmFja1xyXG4gICAgICogQHJldHVybnMge0ZhY3Rvcn1cclxuICAgICAqL1xyXG4gICAgRmFjdG9ycy5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuZmFjdG9ycykge1xyXG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gdGhpcy5mYWN0b3JzW3hdO1xyXG4gICAgICAgICAgICBpZihmYWN0b3IuZm5hbWUgPT09IGNvcmUuUEFSRU5USEVTSVMgJiYgZmFjdG9yLmlzTGluZWFyKCkpXHJcbiAgICAgICAgICAgICAgICBmYWN0b3IgPSBmYWN0b3IuYXJnc1swXTtcclxuICAgICAgICAgICAgZi5jYWxsKHRoaXMsIGZhY3RvciwgeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZmFjdG9ycyBjb250YWluZWQgaW4gdGhlIGZhY3RvciBvYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtpbnR9XHJcbiAgICAgKi9cclxuICAgIEZhY3RvcnMucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBrZXlzKHRoaXMuZmFjdG9ycykubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYW5zIHVwIGZhY3RvcnMgZnJvbSAtMVxyXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgRmFjdG9ycy5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGggPSBjb3JlLlNldHRpbmdzLkNPTlNUX0hBU0g7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZmFjdG9yc1toXS5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5mYWN0b3JzW2hdLmVxdWFscygtMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmFjdG9yc1toXTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY3RvcnNbaF0ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICB4Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICB9O1xyXG4gICAgRmFjdG9ycy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TeW1ib2woKS50b1N0cmluZygpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL2Egd3JhcHBlciBmb3IgcGVyZm9ybWluZyBtdWx0aXZhcmlhdGUgZGl2aXNpb25cclxuICAgIGZ1bmN0aW9uIE1WVGVybShjb2VmZiwgdGVybXMsIG1hcCkge1xyXG4gICAgICAgIHRoaXMudGVybXMgPSB0ZXJtcyB8fCBbXTtcclxuICAgICAgICB0aGlzLmNvZWZmID0gY29lZmY7XHJcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7IC8vY2FyZWZ1bCEgYWxsIG1hcHMgYXJlIHRoZSBzYW1lIG9iamVjdFxyXG4gICAgICAgIHRoaXMuc3VtID0gbmV3IGNvcmUuRnJhYygwKTtcclxuICAgICAgICB0aGlzLmltYWdlID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgTVZUZXJtLnByb3RvdHlwZS51cGRhdGVDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gdGhpcy5jb3VudCB8fCAwO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnRlcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnRlcm1zW2ldLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgIHRoaXMuY291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgTVZUZXJtLnByb3RvdHlwZS5nZXRWYXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YXJzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudGVybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHRlcm0gPSB0aGlzLnRlcm1zW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIHJldl9tYXAgPSB0aGlzLmdldFJldk1hcCgpO1xyXG4gICAgICAgICAgICBpZighdGVybS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICB2YXJzLnB1c2godGhpcy5yZXZfbWFwW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhcnMuam9pbignICcpO1xyXG4gICAgfTtcclxuICAgIE1WVGVybS5wcm90b3R5cGUubGVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLmNvdW50ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvdW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xyXG4gICAgfTtcclxuICAgIE1WVGVybS5wcm90b3R5cGUudG9TeW1ib2wgPSBmdW5jdGlvbiAocmV2X21hcCkge1xyXG4gICAgICAgIHJldl9tYXAgPSByZXZfbWFwIHx8IHRoaXMuZ2V0UmV2TWFwKCk7XHJcbiAgICAgICAgdmFyIHN5bWJvbCA9IG5ldyBTeW1ib2wodGhpcy5jb2VmZik7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudGVybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSByZXZfbWFwW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0aGlzLnRlcm1zW2ldO1xyXG4gICAgICAgICAgICBpZih0LmVxdWFscygwKSB8fCB2ID09PSBDT05TVF9IQVNIKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIHZhciBtYXBwZWQgPSBuZXcgU3ltYm9sKHYpO1xyXG4gICAgICAgICAgICBtYXBwZWQucG93ZXIgPSB0O1xyXG4gICAgICAgICAgICBzeW1ib2wgPSBfLm11bHRpcGx5KHN5bWJvbCwgbWFwcGVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgIH07XHJcbiAgICBNVlRlcm0ucHJvdG90eXBlLmdldFJldk1hcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZih0aGlzLnJldl9tYXApXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldl9tYXA7XHJcbiAgICAgICAgdmFyIG8gPSB7fTtcclxuICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5tYXApXHJcbiAgICAgICAgICAgIG9bdGhpcy5tYXBbeF1dID0geDtcclxuICAgICAgICB0aGlzLnJldl9tYXAgPSBvO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfTtcclxuICAgIE1WVGVybS5wcm90b3R5cGUuZ2VuZXJhdGVJbWFnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmltYWdlID0gdGhpcy50ZXJtcy5qb2luKCcgJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgICAgICAgICBNVlRlcm0ucHJvdG90eXBlLmdldEltZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmltYWdlKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIE1WVGVybS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gdGhpcy5tYXAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLnRlcm1zW2ldID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXJtc1tpXSA9IG5ldyBjb3JlLkZyYWMoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VtID0gdGhpcy5zdW0uYWRkKHRoaXMudGVybXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgTVZUZXJtLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAobXZ0ZXJtKSB7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNvZWZmLmRpdmlkZShtdnRlcm0uY29lZmYpLFxyXG4gICAgICAgICAgICAgICAgbCA9IHRoaXMudGVybXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbmV3X212dGVybSA9IG5ldyBNVlRlcm0oYywgW10sIHRoaXMubWFwKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5ld19tdnRlcm0udGVybXNbaV0gPSB0aGlzLnRlcm1zW2ldLnN1YnRyYWN0KG12dGVybS50ZXJtc1tpXSk7XHJcbiAgICAgICAgICAgIG5ld19tdnRlcm0uc3VtID0gbmV3X212dGVybS5zdW0uYWRkKG5ld19tdnRlcm0udGVybXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3X212dGVybTtcclxuICAgIH07XHJcbiAgICBNVlRlcm0ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKG12dGVybSkge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5jb2VmZi5tdWx0aXBseShtdnRlcm0uY29lZmYpLFxyXG4gICAgICAgICAgICAgICAgbCA9IHRoaXMudGVybXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgbmV3X212dGVybSA9IG5ldyBNVlRlcm0oYywgW10sIHRoaXMubWFwKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5ld19tdnRlcm0udGVybXNbaV0gPSB0aGlzLnRlcm1zW2ldLmFkZChtdnRlcm0udGVybXNbaV0pO1xyXG4gICAgICAgICAgICBuZXdfbXZ0ZXJtLnN1bSA9IG5ld19tdnRlcm0uc3VtLmFkZChuZXdfbXZ0ZXJtLnRlcm1zW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld19tdnRlcm07XHJcbiAgICB9O1xyXG4gICAgTVZUZXJtLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZmYuZXF1YWxzKDApO1xyXG4gICAgfTtcclxuICAgIE1WVGVybS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICd7IGNvZWZmOiAnICsgdGhpcy5jb2VmZi50b1N0cmluZygpICsgJywgdGVybXM6IFsnICtcclxuICAgICAgICAgICAgICAgIHRoaXMudGVybXMuam9pbignLCcpICsgJ106IHN1bTogJyArIHRoaXMuc3VtLnRvU3RyaW5nKCkgKyAnLCBjb3VudDogJyArIHRoaXMuY291bnQgKyAnfSc7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvcmUuVXRpbHMudG9NYXBPYmogPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgdmFyIGMgPSAwLCBvID0ge307XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IGFycltpXTtcclxuICAgICAgICAgICAgaWYodHlwZW9mIG9bdl0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBvW3ZdID0gYztcclxuICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBvLmxlbmd0aCA9IGM7XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9O1xyXG4gICAgY29yZS5VdGlscy5maWxsZWRBcnJheSA9IGZ1bmN0aW9uICh2LCBuLCBjbHNzKSB7XHJcbiAgICAgICAgdmFyIGEgPSBbXTtcclxuICAgICAgICB3aGlsZShuLS0pIHtcclxuICAgICAgICAgICAgYVtuXSA9IGNsc3MgPyBuZXcgY2xzcyh2KSA6IHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfTtcclxuICAgIGNvcmUuVXRpbHMuYXJyU3VtID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIHZhciBzdW0gPSAwLCBsID0gYXJyLmxlbmd0aDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgICBzdW0gKz0gYXJyW2ldO1xyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIDIgYXJyYXlzIGhhdmUgaW50ZXJzZWN0aW5nIGVsZW1lbnRzLlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgYSBhbmQgYiBoYXZlIGludGVyc2VjdGluZyBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgY29yZS5VdGlscy5oYXZlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICB2YXIgdDtcclxuICAgICAgICBpZihiLmxlbmd0aCA+IGEubGVuZ3RoKVxyXG4gICAgICAgICAgICB0ID0gYiwgYiA9IGEsIGEgPSB0OyAvLyBpbmRleE9mIHRvIGxvb3Agb3ZlciBzaG9ydGVyXHJcbiAgICAgICAgcmV0dXJuIGEuc29tZShmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYi5pbmRleE9mKGUpID4gLTE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzdGl0dXRlcyBvdXQgZnVuY3Rpb25zIGFzIHZhcmlhYmxlcyBzbyB0aGV5IGNhbiBiZSB1c2VkIGluIHJlZ3VsYXIgYWxnb3JpdGhtc1xyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGV4cHJlc3Npb24gc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGNvcmUuVXRpbHMuc3ViRnVuY3Rpb25zID0gZnVuY3Rpb24gKHN5bWJvbCwgbWFwKSB7XHJcbiAgICAgICAgbWFwID0gbWFwIHx8IHt9O1xyXG4gICAgICAgIHZhciBzdWJiZWQgPSBbXTtcclxuICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZih4Lmdyb3VwID09PSBGTiB8fCB4LnByZXZpb3VzR3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAvL3dlIG5lZWQgYSBuZXcgdmFyaWFibGUgbmFtZSBzbyB3aHkgbm90IHVzZSBvbmUgb2YgdGhlIGV4aXN0aW5nXHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gY29yZS5VdGlscy50ZXh0KHgsICdoYXNoJyksIHR2YXIgPSBtYXBbdmFsXTtcclxuICAgICAgICAgICAgICAgIGlmKCF0dmFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZW5lcmF0ZSBhIHVuaXF1ZSBlbm91Z2ggbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0geC5mbmFtZSArIGtleXMobWFwKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwW3ZhbF0gPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmJlZC5wdXNoKHguYWx0VmFyKHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBzdWJiZWQucHVzaCh4LmFsdFZhcih0dmFyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih4Lmdyb3VwID09PSBDQiB8fCB4Lmdyb3VwID09PSBQTCB8fCB4Lmdyb3VwID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgc3ViYmVkLnB1c2goY29yZS5VdGlscy5zdWJGdW5jdGlvbnMoeCwgbWFwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc3ViYmVkLnB1c2goeC50ZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ1AgfHwgc3ltYm9sLmdyb3VwID09PSBQTClcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5hbHRWYXIoY29yZS5VdGlscy5pbkJyYWNrZXRzKHN1YmJlZC5qb2luKCcrJykpKTtcclxuICAgICAgICA7XHJcbiAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBDQilcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5hbHRWYXIoY29yZS5VdGlscy5pbkJyYWNrZXRzKHN1YmJlZC5qb2luKCcqJykpKTtcclxuICAgICAgICByZXR1cm4gc3ltYm9sLnRleHQoKTtcclxuICAgIH07XHJcbiAgICBjb3JlLlV0aWxzLmdldEZ1bmN0aW9uc1N1YnMgPSBmdW5jdGlvbiAobWFwKSB7XHJcbiAgICAgICAgdmFyIHN1YnMgPSB7fTtcclxuICAgICAgICAvL3ByZXBhcmUgc3Vic3RpdHV0aW9uc1xyXG4gICAgICAgIGZvcih2YXIgeCBpbiBtYXApXHJcbiAgICAgICAgICAgIHN1YnNbbWFwW3hdXSA9IF8ucGFyc2UoeCk7XHJcbiAgICAgICAgcmV0dXJuIHN1YnM7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfXyA9IGNvcmUuQWxnZWJyYSA9IHtcclxuICAgICAgICB2ZXJzaW9uOiAnMS40LjYnLFxyXG4gICAgICAgIHByb290czogZnVuY3Rpb24gKHN5bWJvbCwgZGVjcCkge1xyXG4gICAgICAgICAgICAvL3RoZSByb290cyB3aWxsIGJlIHJvdW5kZWQgdXAgdG8gNyBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgLy9pZiB0aGlzIGNhdXNlcyB0cm91YmxlIHlvdSBjYW4gZXhwbGljaXRseSBwYXNzIGluIGEgZGlmZmVyZW50IG51bWJlciBvZiBwbGFjZXNcclxuICAgICAgICAgICAgLy9yYXJyIGZvciBwb2x5bm9taWFsIG9mIHBvd2VyIG4gaXMgb2YgZm9ybWF0IFtuLCBjb2VmZiB4Xm4sIGNvZWZmIHheKG4tMSksIC4uLiwgY29lZmYgeF4wXVxyXG4gICAgICAgICAgICBkZWNwID0gZGVjcCB8fCA3O1xyXG4gICAgICAgICAgICB2YXIgemVyb3MgPSAwO1xyXG4gICAgICAgICAgICB2YXIga25vd25fcm9vdHMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGdldF9yb290cyA9IGZ1bmN0aW9uIChyYXJyLCBwb3dlcnMsIG1heCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3RzID0gY2FsY3Jvb3RzKHJhcnIsIHBvd2VycywgbWF4KS5jb25jYXQoa25vd25fcm9vdHMpO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHplcm9zOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdHMudW5zaGlmdCgwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByb290cztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbCBpbnN0YW5jZW9mIFN5bWJvbCAmJiBzeW1ib2wuaXNQb2x5KCkpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgLy9tYWtlIGl0IHNvIHRoZSBzeW1ib2wgaGFzIGEgY29uc3RhbnRzIGFzIHRoZSBsb3dlc3QgdGVybVxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb3dlc3RfcG93ID0gY29yZS5VdGlscy5hcnJheU1pbihrZXlzKHN5bWJvbC5zeW1ib2xzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvd2VzdF9zeW1ib2wgPSBzeW1ib2wuc3ltYm9sc1tsb3dlc3RfcG93XS5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChfLmRpdmlkZShzeW1ib2wsIGxvd2VzdF9zeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgICAgICBrbm93bl9yb290cy5wdXNoKDApOyAvL2FkZCB6ZXJvIHNpbmNlIHRoaXMgaXMgYSBrbm93biByb290XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLlMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLlBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvd2VycyA9IGtleXMoc3ltYm9sLnN5bWJvbHMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlucG93ZXIgPSBjb3JlLlV0aWxzLmFycmF5TWluKHBvd2VycyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBjb3JlLlBBUlNFUi5kaXZpZGUoc3ltYm9sLCBjb3JlLlBBUlNFUi5wYXJzZShzeW1ib2wudmFsdWUgKyAnXicgKyBtaW5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IGtleXMoc3ltYm9sLnN5bWJvbHMpLnNvcnQoKS5wb3AoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltID0gc3ltYm9sLmdyb3VwID09PSBjb3JlLmdyb3Vwcy5QTCA/IHN5bWJvbC5zeW1ib2xzIDogc3ltYm9sLnN5bWJvbHNbdmFyaWFibGVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gc3ltLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3dlcnMgPSBnID09PSBTID8gW3N5bS5wb3dlci50b0RlY2ltYWwoKV0gOiBrZXlzKHN5bS5zeW1ib2xzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFyciA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBjb3JlLlV0aWxzLmFycmF5TWF4KHBvd2Vycyk7IC8vbWF4aW11bSBwb3dlciBhbmQgZGVncmVlIG9mIHBvbHlub21pYWwgdG8gYmUgc29sdmVkXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8PSBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gMDsgLy9pZiB0aGVyZSBpcyBubyBwb3dlciB0aGVuIHRoZSBob2xlIG11c3QgYmUgZmlsbGVkIHdpdGggYSB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgaWYocG93ZXJzLmluZGV4T2YoaSArICcnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZyA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHN5bS5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHN5bS5zeW1ib2xzW2ldLm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBjb2VmZmllbnQgYnV0IGZyb20gdGhlIGZyb250XHJcbiAgICAgICAgICAgICAgICAgICAgcmFyci51bnNoaWZ0KGMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJhcnIucHVzaChzeW1ib2wuc3ltYm9sc1tDT05TVF9IQVNIXS5tdWx0aXBsaWVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzeW0uZ3JvdXAgPT09IFMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmFyclswXSA9IHN5bS5tdWx0aXBsaWVyOy8vdGhlIHN5bWJvbCBtYXliZSBvZiBncm91cCBDUCB3aXRoIG9uZSB2YXJpYWJsZVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRfcm9vdHMocmFyciwgcG93ZXJzLCBtYXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoY29yZS5VdGlscy5pc0FycmF5KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJyID0gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhcnIgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfcG93ZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhcnIubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmID0gcGFycltpXVswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvdyA9IHBhcnJbaV1bMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gcG93IC0gbGFzdF9wb3dlciAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pbnNlcnQgdGhlIHplcm9zXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFyci51bnNoaWZ0KDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByYXJyLnVuc2hpZnQoY29lZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHBvdyAhPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJzLnB1c2gocG93KTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0X3Bvd2VyID0gcG93O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KHVuZGVmaW5lZCwgcG93ZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3Jvb3RzKHJhcnIsIHBvd2VycywgbWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLmV4Y2VwdGlvbnMuTmVyZGFtZXJUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgcm9vdHMuIFN5bWJvbCBtdXN0IGJlIGEgcG9seW5vbWlhbCEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gY2FsY3Jvb3RzKHJhcnIsIHBvd2VycywgbWF4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgTUFYREVHUkVFID0gMTAwOyAvLyBEZWdyZWUgb2YgbGFyZ2VzdCBwb2x5bm9taWFsIGFjY2VwdGVkIGJ5IHRoaXMgc2NyaXB0LlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBjbG9uZSBvZiB0aGUgY29lZmZpY2llbnRzIGJlZm9yZSBhcHBlbmRpbmcgdGhlIG1heCBwb3dlclxyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSByYXJyLnNsaWNlKDApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERpdmlkZSB0aGUgc3RyaW5nIHVwIGludG8gaXRzIGluZGl2aWR1YWwgZW50cmllcywgd2hpY2gtLXByZXN1bWFibHktLWFyZSBzZXBhcmF0ZWQgYnkgd2hpdGVzcGFjZVxyXG4gICAgICAgICAgICAgICAgcmFyci51bnNoaWZ0KG1heCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobWF4ID4gTUFYREVHUkVFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5WYWx1ZUxpbWl0RXhjZWVkZWRFcnJvcihcIlRoaXMgdXRpbGl0eSBhY2NlcHRzIHBvbHlub21pYWxzIG9mIGRlZ3JlZSB1cCB0byBcIiArIE1BWERFR1JFRSArIFwiLiBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHplcm9pID0gW10sIC8vIFZlY3RvciBvZiBpbWFnaW5hcnkgY29tcG9uZW50cyBvZiByb290c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWdyZWVQYXIgPSB7fTsgICAgLy8gZGVncmVlUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgdGhlIHBhcmFtZXRlciBQT0xZREVHUkVFIGJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgZGVncmVlUGFyLkRlZ3JlZSA9IG1heDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHplcm9pLnB1c2goMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgemVyb3IgPSB6ZXJvaS5zbGljZSgwKTsgLy8gVmVjdG9yIG9mIHJlYWwgY29tcG9uZW50cyBvZiByb290c1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJvb3RzXHJcbiAgICAgICAgICAgICAgICAvLy0tPiBCZWdpbiBKZW5raW5zLVRyYXViXHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAqIEEgdmVyYmF0aW0gY29weSBvZiBNci4gRGF2aWQgQmlubmVyJ3MgSmVua2lucy1UcmF1YiBwb3J0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFF1YWRTRF9hazEoTk4sIHUsIHYsIHAsIHEsIGlQYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEaXZpZGVzIHAgYnkgdGhlIHF1YWRyYXRpYyAxLCB1LCB2IHBsYWNpbmcgdGhlIHF1b3RpZW50IGluIHEgYW5kIHRoZSByZW1haW5kZXIgaW4gYSwgYlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyBpbiB0aGUgdHdvIHBhcmFtZXRlcnMtLWEgYW5kIGItLWJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIHFbMF0gPSBpUGFyLmIgPSBwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHFbMV0gPSBpUGFyLmEgPSAtKHUgKiBpUGFyLmIpICsgcFsxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMjsgaSA8IE5OOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcVtpXSA9IC0odSAqIGlQYXIuYSArIHYgKiBpUGFyLmIpICsgcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5iID0gaVBhci5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmEgPSBxW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FsY1NDX2FrMShEQkxfRVBTSUxPTiwgTiwgYSwgYiwgaVBhciwgSywgdSwgdiwgcWspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJvdXRpbmUgY2FsY3VsYXRlcyBzY2FsYXIgcXVhbnRpdGllcyB1c2VkIHRvIGNvbXB1dGUgdGhlIG5leHQgSyBwb2x5bm9taWFsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5ldyBlc3RpbWF0ZXMgb2YgdGhlIHF1YWRyYXRpYyBjb2VmZmljaWVudHMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsY1NDIC1cdGludGVnZXIgdmFyaWFibGUgc2V0IGhlcmUgaW5kaWNhdGluZyBob3cgdGhlIGNhbGN1bGF0aW9ucyBhcmUgbm9ybWFsaXplZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIG92ZXJmbG93LlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyBpbiB0aGUgbmluZSBwYXJhbWV0ZXJzLS1hMSwgYTMsIGE3LCBjLCBkLCBlLCBmLCBnLCBhbmQgaCAtLWJ5IHJlZmVyZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzZFBhciBpcyBhIGR1bW15IHZhcmlhYmxlIGZvciBwYXNzaW5nIHRoZSB0d28gcGFyYW1ldGVycy0tYyBhbmQgZC0taW50byBRdWFkU0RfYWsxIGJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZFBhciA9IG5ldyBPYmplY3QoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRZUEUgPSAzIGluZGljYXRlcyB0aGUgcXVhZHJhdGljIGlzIGFsbW9zdCBhIGZhY3RvciBvZiBLXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1GbGFnID0gMztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3ludGhldGljIGRpdmlzaW9uIG9mIEsgYnkgdGhlIHF1YWRyYXRpYyAxLCB1LCB2XHJcbiAgICAgICAgICAgICAgICAgICAgc2RQYXIuYiA9IHNkUGFyLmEgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgUXVhZFNEX2FrMShOLCB1LCB2LCBLLCBxaywgc2RQYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlQYXIuYyA9IHNkUGFyLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgaVBhci5kID0gc2RQYXIuYjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoaVBhci5jKSA8PSAoMTAwLjAgKiBEQkxfRVBTSUxPTiAqIE1hdGguYWJzKEtbTiAtIDFdKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoaVBhci5kKSA8PSAoMTAwLjAgKiBEQkxfRVBTSUxPTiAqIE1hdGguYWJzKEtbTiAtIDJdKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZHVtRmxhZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlQYXIuaCA9IHYgKiBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGlQYXIuZCkgPj0gTWF0aC5hYnMoaVBhci5jKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUWVBFID0gMiBpbmRpY2F0ZXMgdGhhdCBhbGwgZm9ybXVsYXMgYXJlIGRpdmlkZWQgYnkgZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1GbGFnID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5lID0gYSAvIChpUGFyLmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmYgPSAoaVBhci5jKSAvIChpUGFyLmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmcgPSB1ICogYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5hMyA9IChpUGFyLmUpICogKChpUGFyLmcpICsgYSkgKyAoaVBhci5oKSAqIChiIC8gKGlQYXIuZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmExID0gLWEgKyAoaVBhci5mKSAqIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuYTcgPSAoaVBhci5oKSArICgoaVBhci5mKSArIHUpICogYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRZUEUgPSAxIGluZGljYXRlcyB0aGF0IGFsbCBmb3JtdWxhcyBhcmUgZGl2aWRlZCBieSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkdW1GbGFnID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5lID0gYSAvIChpUGFyLmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmYgPSAoaVBhci5kKSAvIChpUGFyLmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmcgPSAoaVBhci5lKSAqIHU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuYTMgPSAoaVBhci5lKSAqIGEgKyAoKGlQYXIuZykgKyAoaVBhci5oKSAvIChpUGFyLmMpKSAqIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuYTEgPSAtKGEgKiAoKGlQYXIuZCkgLyAoaVBhci5jKSkpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5hNyA9IChpUGFyLmcpICogKGlQYXIuZCkgKyAoaVBhci5oKSAqIChpUGFyLmYpICsgYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR1bUZsYWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbmV4dEtfYWsxKERCTF9FUFNJTE9OLCBOLCB0RmxhZywgYSwgYiwgaVBhciwgSywgcWssIHFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIG5leHQgSyBwb2x5bm9taWFscyB1c2luZyB0aGUgc2NhbGFycyBjb21wdXRlZCBpbiBjYWxjU0NfYWsxXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaVBhciBpcyBhIGR1bW15IHZhcmlhYmxlIGZvciBwYXNzaW5nIGluIHRocmVlIHBhcmFtZXRlcnMtLWExLCBhMywgYW5kIGE3XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodEZsYWcgPT0gMykge1x0Ly8gVXNlIHVuc2NhbGVkIGZvcm0gb2YgdGhlIHJlY3VycmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgS1sxXSA9IEtbMF0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDI7IGkgPCBOOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbaV0gPSBxa1tpIC0gMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9ICgodEZsYWcgPT0gMSkgPyBiIDogYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoaVBhci5hMSkgPiAoMTAuMCAqIERCTF9FUFNJTE9OICogTWF0aC5hYnModGVtcCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBzY2FsZWQgZm9ybSBvZiB0aGUgcmVjdXJyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmE3IC89IGlQYXIuYTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuYTMgLz0gaVBhci5hMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgS1swXSA9IHFwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBLWzFdID0gLShxcFswXSAqIGlQYXIuYTcpICsgcXBbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDI7IGkgPCBOOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLW2ldID0gLShxcFtpIC0gMV0gKiBpUGFyLmE3KSArIHFrW2kgLSAyXSAqIGlQYXIuYTMgKyBxcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGExIGlzIG5lYXJseSB6ZXJvLCB0aGVuIHVzZSBhIHNwZWNpYWwgZm9ybSBvZiB0aGUgcmVjdXJyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBLWzBdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBLWzFdID0gLShxcFswXSAqIGlQYXIuYTcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAyOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLW2ldID0gLShxcFtpIC0gMV0gKiBpUGFyLmE3KSArIHFrW2kgLSAyXSAqIGlQYXIuYTM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5ld2VzdF9hazEodEZsYWcsIGlQYXIsIGEsIGExLCBhMywgYTcsIGIsIGMsIGQsIGYsIGcsIGgsIHUsIHYsIEssIE4sIHApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5ldyBlc3RpbWF0ZXMgb2YgdGhlIHF1YWRyYXRpYyBjb2VmZmljaWVudHMgdXNpbmcgdGhlIHNjYWxhcnMgY29tcHV0ZWQgaW4gY2FsY1NDX2FrMVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyBpbiB0aGUgdHdvIHBhcmFtZXRlcnMtLXV1IGFuZCB2di0tYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaVBhci5hID0gdXUsIGlQYXIuYiA9IHZ2XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhNCwgYTUsIGIxLCBiMiwgYzEsIGMyLCBjMywgYzQsIHRlbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaVBhci5iID0gaVBhci5hID0gMC4wOy8vIFRoZSBxdWFkcmF0aWMgaXMgemVyb2VkXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRGbGFnICE9IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodEZsYWcgIT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTQgPSBhICsgdSAqIGIgKyBoICogZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE1ID0gYyArICh1ICsgdiAqIGYpICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE0ID0gKGEgKyBnKSAqIGYgKyBoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTUgPSAoZiArIHUpICogYyArIHYgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBuZXcgcXVhZHJhdGljIGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiMSA9IC0oS1tOIC0gMV0gLyBwW05dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSAtKEtbTiAtIDJdICsgYjEgKiBwW04gLSAxXSkgLyBwW05dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjMSA9IHYgKiBiMiAqIGExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjMiA9IGIxICogYTc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMzID0gYjEgKiBiMSAqIGEzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjNCA9IC0oYzIgKyBjMykgKyBjMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IC1jNCArIGE1ICsgYjEgKiBhNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGVtcCAhPSAwLjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuYSA9IC0oKHUgKiAoYzMgKyBjMikgKyB2ICogKGIxICogYTEgKyBiMiAqIGE3KSkgLyB0ZW1wKSArIHU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmIgPSB2ICogKDEuMCArIGM0IC8gdGVtcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFF1YWRfYWsxKGEsIGIxLCBjLCBpUGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlcyB0aGUgemVyb3Mgb2YgdGhlIHF1YWRyYXRpYyBhKlpeMiArIGIxKlogKyBjXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHF1YWRyYXRpYyBmb3JtdWxhLCBtb2RpZmllZCB0byBhdm9pZCBvdmVyZmxvdywgaXMgdXNlZCB0byBmaW5kIHRoZSBsYXJnZXIgemVybyBpZiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyB6ZXJvcyBhcmUgcmVhbCBhbmQgYm90aCB6ZXJvcyBhcmUgY29tcGxleC4gVGhlIHNtYWxsZXIgcmVhbCB6ZXJvIGlzIGZvdW5kIGRpcmVjdGx5IGZyb21cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJvZHVjdCBvZiB0aGUgemVyb3MgYy9hLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgaW4gdGhlIGZvdXIgcGFyYW1ldGVycy0tc3IsIHNpLCBsciwgYW5kIGxpLS1ieSByZWZlcmVuY2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIsIGQsIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaVBhci5zciA9IGlQYXIuc2kgPSBpUGFyLmxyID0gaVBhci5saSA9IDAuMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuc3IgPSAoKGIxICE9IDApID8gLShjIC8gYjEpIDogaVBhci5zcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYyA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIubHIgPSAtKGIxIC8gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgZGlzY3JpbWluYW50IGF2b2lkaW5nIG92ZXJmbG93XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGIxIC8gMi4wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGIpIDwgTWF0aC5hYnMoYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9ICgoYyA+PSAwKSA/IGEgOiAtYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAtZSArIGIgKiAoYiAvIE1hdGguYWJzKGMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IE1hdGguc3FydChNYXRoLmFicyhlKSkgKiBNYXRoLnNxcnQoTWF0aC5hYnMoYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IC0oKGEgLyBiKSAqIChjIC8gYikpICsgMS4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5zcXJ0KE1hdGguYWJzKGUpKSAqIChNYXRoLmFicyhiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihlID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhbCB6ZXJvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gKChiID49IDApID8gLWQgOiBkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5sciA9ICgtYiArIGQpIC8gYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5zciA9ICgoaVBhci5sciAhPSAwKSA/IChjIC8gKGlQYXIubHIpKSAvIGEgOiBpUGFyLnNyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZXggY29uanVnYXRlIHplcm9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIubHIgPSBpUGFyLnNyID0gLShiIC8gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuc2kgPSBNYXRoLmFicyhkIC8gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIubGkgPSAtKGlQYXIuc2kpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gUXVhZElUX2FrMShEQkxfRVBTSUxPTiwgTiwgaVBhciwgdXUsIHZ2LCBxcCwgTk4sIHNkUGFyLCBwLCBxaywgY2FsY1BhciwgSykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlLXNoaWZ0IEstcG9seW5vbWlhbCBpdGVyYXRpb24gZm9yIGEgcXVhZHJhdGljIGZhY3RvciBjb252ZXJnZXMgb25seSBpZiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAvLyB6ZXJvcyBhcmUgZXF1aW1vZHVsYXIgb3IgbmVhcmx5IHNvLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyBpbiB0aGUgZml2ZSBwYXJhbWV0ZXJzLS1OWiwgbHppLCBsenIsIHN6aSwgYW5kIHN6ci0tYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2RQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyB0aGUgdHdvIHBhcmFtZXRlcnMtLWEgYW5kIGItLWluIGJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGNQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyB0aGUgbmluZSBwYXJhbWV0ZXJzLS1hMSwgYTMsIGE3LCBjLCBkLCBlLCBmLCBnLCBhbmQgaCAtLWluIGJ5IHJlZmVyZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBxUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgdGhlIGZvdXIgcGFyYW1ldGVycy0tc3pyLCBzemksIGx6ciwgYW5kIGx6aS0taW50byBRdWFkX2FrMSBieSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcVBhciA9IG5ldyBPYmplY3QoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVlLCBtcCwgb21wLCByZWxzdHAsIHQsIHUsIHVpLCB2LCB2aSwgem0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLCBqID0gMCwgdEZsYWcsIHRyaWVkRmxhZyA9IDA7ICAgLy8gSW50ZWdlciB2YXJpYWJsZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaVBhci5OWiA9IDA7Ly8gTnVtYmVyIG9mIHplcm9zIGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IHV1OyAvLyB1dSBhbmQgdnYgYXJlIGNvZWZmaWNpZW50cyBvZiB0aGUgc3RhcnRpbmcgcXVhZHJhdGljXHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IHZ2O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFQYXIubGkgPSBxUGFyLmxyID0gcVBhci5zaSA9IHFQYXIuc3IgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFF1YWRfYWsxKDEuMCwgdSwgdiwgcVBhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuc3pyID0gcVBhci5zcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5zemkgPSBxUGFyLnNpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmx6ciA9IHFQYXIubHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIubHppID0gcVBhci5saTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBpZiByb290cyBvZiB0aGUgcXVhZHJhdGljIGFyZSByZWFsIGFuZCBub3QgY2xvc2UgdG8gbXVsdGlwbGUgb3IgbmVhcmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVxdWFsIGFuZCBvZiBvcHBvc2l0ZSBzaWduLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhNYXRoLmFicyhpUGFyLnN6cikgLSBNYXRoLmFicyhpUGFyLmx6cikpID4gMC4wMSAqIE1hdGguYWJzKGlQYXIubHpyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgcG9seW5vbWlhbCBieSBxdWFkcmF0aWMgc3ludGhldGljIGRpdmlzaW9uXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBRdWFkU0RfYWsxKE5OLCB1LCB2LCBwLCBxcCwgc2RQYXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbXAgPSBNYXRoLmFicygtKChpUGFyLnN6cikgKiAoc2RQYXIuYikpICsgKHNkUGFyLmEpKSArIE1hdGguYWJzKChpUGFyLnN6aSkgKiAoc2RQYXIuYikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBhIHJpZ29yb3VzIGJvdW5kIG9uIHRoZSByb3VuZGluZyBlcnJvciBpbiBldmFsdWF0aW5nIHBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHptID0gTWF0aC5zcXJ0KE1hdGguYWJzKHYpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWUgPSAyLjAgKiBNYXRoLmFicyhxcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAtKChpUGFyLnN6cikgKiAoc2RQYXIuYikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZSA9IGVlICogem0gKyBNYXRoLmFicyhxcFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVlID0gZWUgKiB6bSArIE1hdGguYWJzKHQgKyBzZFBhci5hKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWUgPSAoOS4wICogZWUgKyAyLjAgKiBNYXRoLmFicyh0KSAtIDcuMCAqIChNYXRoLmFicygoc2RQYXIuYSkgKyB0KSArIHptICogTWF0aC5hYnMoKHNkUGFyLmIpKSkpICogREJMX0VQU0lMT047XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb24gaGFzIGNvbnZlcmdlZCBzdWZmaWNpZW50bHkgaWYgdGhlIHBvbHlub21pYWwgdmFsdWUgaXMgbGVzcyB0aGFuIDIwIHRpbWVzIHRoaXMgYm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobXAgPD0gMjAuMCAqIGVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUGFyLk5aID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgaXRlcmF0aW9uIGFmdGVyIDIwIHN0ZXBzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGogPiAyMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqID49IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKChyZWxzdHAgPD0gMC4wMSkgJiYgKG1wID49IG9tcCkgJiYgKCF0cmllZEZsYWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBjbHVzdGVyIGFwcGVhcnMgdG8gYmUgc3RhbGxpbmcgdGhlIGNvbnZlcmdlbmNlLiBGaXZlIGZpeGVkIHNoaWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuIHdpdGggYSB1LCB2IGNsb3NlIHRvIHRoZSBjbHVzdGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbHN0cCA9ICgocmVsc3RwIDwgREJMX0VQU0lMT04pID8gTWF0aC5zcXJ0KERCTF9FUFNJTE9OKSA6IE1hdGguc3FydChyZWxzdHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1IC09IHUgKiByZWxzdHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiArPSB2ICogcmVsc3RwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFkU0RfYWsxKE5OLCB1LCB2LCBwLCBxcCwgc2RQYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0RmxhZyA9IGNhbGNTQ19hazEoREJMX0VQU0lMT04sIE4sIHNkUGFyLmEsIHNkUGFyLmIsIGNhbGNQYXIsIEssIHUsIHYsIHFrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEtfYWsxKERCTF9FUFNJTE9OLCBOLCB0RmxhZywgc2RQYXIuYSwgc2RQYXIuYiwgY2FsY1BhciwgSywgcWssIHFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWVkRmxhZyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9tcCA9IG1wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG5leHQgSyBwb2x5bm9taWFsIGFuZCBuZXcgdSBhbmQgdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0RmxhZyA9IGNhbGNTQ19hazEoREJMX0VQU0lMT04sIE4sIHNkUGFyLmEsIHNkUGFyLmIsIGNhbGNQYXIsIEssIHUsIHYsIHFrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEtfYWsxKERCTF9FUFNJTE9OLCBOLCB0RmxhZywgc2RQYXIuYSwgc2RQYXIuYiwgY2FsY1BhciwgSywgcWssIHFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdEZsYWcgPSBjYWxjU0NfYWsxKERCTF9FUFNJTE9OLCBOLCBzZFBhci5hLCBzZFBhci5iLCBjYWxjUGFyLCBLLCB1LCB2LCBxayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2VzdF9hazEodEZsYWcsIHNkUGFyLCBzZFBhci5hLCBjYWxjUGFyLmExLCBjYWxjUGFyLmEzLCBjYWxjUGFyLmE3LCBzZFBhci5iLCBjYWxjUGFyLmMsIGNhbGNQYXIuZCwgY2FsY1Bhci5mLCBjYWxjUGFyLmcsIGNhbGNQYXIuaCwgdSwgdiwgSywgTiwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gc2RQYXIuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmkgPSBzZFBhci5iO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdmkgaXMgemVybywgdGhlIGl0ZXJhdGlvbiBpcyBub3QgY29udmVyZ2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2aSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxzdHAgPSBNYXRoLmFicygoLXYgKyB2aSkgLyB2aSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdWk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUodmkgIT0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFJlYWxJVF9hazEoREJMX0VQU0lMT04sIGlQYXIsIHNkUGFyLCBOLCBwLCBOTiwgcXAsIEssIHFrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFyaWFibGUtc2hpZnQgSC1wb2x5bm9taWFsIGl0ZXJhdGlvbiBmb3IgYSByZWFsIHplcm9cclxuICAgICAgICAgICAgICAgICAgICAvLyBzc3NcdC0gc3RhcnRpbmcgaXRlcmF0ZSA9IHNkUGFyLmFcclxuICAgICAgICAgICAgICAgICAgICAvLyBOWlx0XHQtIG51bWJlciBvZiB6ZXJvcyBmb3VuZCA9IGlQYXIuTlpcclxuICAgICAgICAgICAgICAgICAgICAvLyBkdW1GbGFnXHQtIGZsYWcgdG8gaW5kaWNhdGUgYSBwYWlyIG9mIHplcm9zIG5lYXIgcmVhbCBheGlzLCByZXR1cm5lZCB0byBpRmxhZ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWUsIGt2LCBtcCwgbXMsIG9tcCwgcHYsIHMsIHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1GbGFnLCBpLCBqLCBubTEgPSBOIC0gMTsgICAvLyBJbnRlZ2VyIHZhcmlhYmxlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpUGFyLk5aID0gaiA9IGR1bUZsYWcgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzZFBhci5hO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IoOyA7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdiA9IHBbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSBwIGF0IHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXBbMF0gPSBwdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgTk47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXBbaV0gPSBwdiA9IHB2ICogcyArIHBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbXAgPSBNYXRoLmFicyhwdik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGEgcmlnb3JvdXMgYm91bmQgb24gdGhlIGVycm9yIGluIGV2YWx1YXRpbmcgcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtcyA9IE1hdGguYWJzKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZSA9IDAuNSAqIE1hdGguYWJzKHFwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgTk47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWUgPSBlZSAqIG1zICsgTWF0aC5hYnMocXBbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRpb24gaGFzIGNvbnZlcmdlZCBzdWZmaWNpZW50bHkgaWYgdGhlIHBvbHlub21pYWwgdmFsdWUgaXMgbGVzcyB0aGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIwIHRpbWVzIHRoaXMgYm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobXAgPD0gMjAuMCAqIERCTF9FUFNJTE9OICogKDIuMCAqIGVlIC0gbXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUGFyLk5aID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuc3pyID0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuc3ppID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGl0ZXJhdGlvbiBhZnRlciAxMCBzdGVwc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqID4gMTApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGogPj0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoKE1hdGguYWJzKHQpIDw9IDAuMDAxICogTWF0aC5hYnMoLXQgKyBzKSkgJiYgKG1wID4gb21wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY2x1c3RlciBvZiB6ZXJvcyBuZWFyIHRoZSByZWFsIGF4aXMgaGFzIGJlZW4gZW5jb3VudGVyZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHdpdGggaUZsYWcgc2V0IHRvIGluaXRpYXRlIGEgcXVhZHJhdGljIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1GbGFnID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmEgPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBFbmQgaWYgKChmYWJzKHQpIDw9IDAuMDAxKmZhYnMocyAtIHQpKSAmJiAobXAgPiBvbXApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IC8vRW5kIGlmIChqID49IDIpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaWYgdGhlIHBvbHlub21pYWwgdmFsdWUgaGFzIGluY3JlYXNlZCBzaWduaWZpY2FudGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9tcCA9IG1wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0LCB0aGUgbmV4dCBwb2x5bm9taWFsIGFuZCB0aGUgbmV3IGl0ZXJhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcWtbMF0gPSBrdiA9IEtbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcWtbaV0gPSBrdiA9IGt2ICogcyArIEtbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGt2KSA+IE1hdGguYWJzKEtbbm0xXSkgKiAxMC4wICogREJMX0VQU0lMT04pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2NhbGVkIGZvcm0gb2YgdGhlIHJlY3VycmVuY2UgaWYgdGhlIHZhbHVlIG9mIEsgYXQgcyBpcyBub24temVyb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IC0ocHYgLyBrdik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLWzBdID0gcXBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCBOOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBLW2ldID0gdCAqIHFrW2kgLSAxXSArIHFwW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHVuc2NhbGVkIGZvcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbMF0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCBOOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1tpXSA9IHFrW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAga3YgPSBLWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCBOOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGt2ID0ga3YgKiBzICsgS1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKChNYXRoLmFicyhrdikgPiAoTWF0aC5hYnMoS1tubTFdKSAqIDEwLjAgKiBEQkxfRVBTSUxPTikpID8gLShwdiAvIGt2KSA6IDAuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR1bUZsYWc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gRnhzaGZyX2FrMShEQkxfRVBTSUxPTiwgTURQMSwgTDIsIHNyLCB2LCBLLCBOLCBwLCBOTiwgcXAsIHUsIGlQYXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZXMgdXAgdG8gTDIgZml4ZWQgc2hpZnQgSy1wb2x5bm9taWFscywgdGVzdGluZyBmb3IgY29udmVyZ2VuY2UgaW4gdGhlIGxpbmVhciBvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHF1YWRyYXRpYyBjYXNlLiBJbml0aWF0ZXMgb25lIG9mIHRoZSB2YXJpYWJsZSBzaGlmdCBpdGVyYXRpb25zIGFuZCByZXR1cm5zIHdpdGggdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHplcm9zIGZvdW5kLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEwyXHRsaW1pdCBvZiBmaXhlZCBzaGlmdCBzdGVwc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyBpbiB0aGUgZml2ZSBwYXJhbWV0ZXJzLS1OWiwgbHppLCBsenIsIHN6aSwgYW5kIHN6ci0tYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTlpcdG51bWJlciBvZiB6ZXJvcyBmb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZFBhciA9IG5ldyBPYmplY3QoKSwgLy8gc2RQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyB0aGUgdHdvIHBhcmFtZXRlcnMtLWEgYW5kIGItLWludG8gUXVhZFNEX2FrMSBieSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNQYXIgPSBuZXcgT2JqZWN0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWxjUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgdGhlIG5pbmUgcGFyYW1ldGVycy0tYTEsIGEzLCBhNywgYywgZCwgZSwgZiwgZywgYW5kIGggLS1pbnRvIGNhbGNTQ19hazEgYnkgcmVmZXJlbmNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcWsgPSBuZXcgQXJyYXkoTURQMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdmsgPSBuZXcgQXJyYXkoTURQMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLCBiLCBiZXRhcywgYmV0YXYsIG9zcywgb3RzLCBvdHYsIG92diwgcywgc3MsIHRzLCB0c3MsIHR2LCB0dnYsIHVpLCB2aSwgdnYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZmxhZywgaSwgaUZsYWcgPSAxLCBqLCBzcGFzcywgc3RyeSwgdEZsYWcsIHZwYXNzLCB2dHJ5OyAgICAgLy8gSW50ZWdlciB2YXJpYWJsZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaVBhci5OWiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYmV0YXYgPSBiZXRhcyA9IDAuMjU7XHJcbiAgICAgICAgICAgICAgICAgICAgb3NzID0gc3I7XHJcbiAgICAgICAgICAgICAgICAgICAgb3Z2ID0gdjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9FdmFsdWF0ZSBwb2x5bm9taWFsIGJ5IHN5bnRoZXRpYyBkaXZpc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIHNkUGFyLmIgPSBzZFBhci5hID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIFF1YWRTRF9hazEoTk4sIHUsIHYsIHAsIHFwLCBzZFBhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHNkUGFyLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHNkUGFyLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsY1Bhci5oID0gY2FsY1Bhci5nID0gY2FsY1Bhci5mID0gY2FsY1Bhci5lID0gY2FsY1Bhci5kID0gY2FsY1Bhci5jID0gY2FsY1Bhci5hNyA9IGNhbGNQYXIuYTMgPSBjYWxjUGFyLmExID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIHRGbGFnID0gY2FsY1NDX2FrMShEQkxfRVBTSUxPTiwgTiwgYSwgYiwgY2FsY1BhciwgSywgdSwgdiwgcWspO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCBMMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZmbGFnID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBuZXh0IEsgcG9seW5vbWlhbCBhbmQgZXN0aW1hdGUgdlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0S19hazEoREJMX0VQU0lMT04sIE4sIHRGbGFnLCBhLCBiLCBjYWxjUGFyLCBLLCBxaywgcXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0RmxhZyA9IGNhbGNTQ19hazEoREJMX0VQU0lMT04sIE4sIGEsIGIsIGNhbGNQYXIsIEssIHUsIHYsIHFrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBzZFBhciBmb3IgcGFzc2luZyBpbiB1dSBhbmQgdnYgaW5zdGVhZCBvZiBkZWZpbmluZyBhIGJyYW5kLW5ldyB2YXJpYWJsZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2RQYXIuYSA9IHVpLCBzZFBhci5iID0gdmlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3ZXN0X2FrMSh0RmxhZywgc2RQYXIsIGEsIGNhbGNQYXIuYTEsIGNhbGNQYXIuYTMsIGNhbGNQYXIuYTcsIGIsIGNhbGNQYXIuYywgY2FsY1Bhci5kLCBjYWxjUGFyLmYsIGNhbGNQYXIuZywgY2FsY1Bhci5oLCB1LCB2LCBLLCBOLCBwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSBzZFBhci5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2diA9IHZpID0gc2RQYXIuYjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVzdGltYXRlIHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3MgPSAoKEtbTiAtIDFdICE9IDAuMCkgPyAtKHBbTl0gLyBLW04gLSAxXSkgOiAwLjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cyA9IHR2ID0gMS4wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoKGogIT0gMCkgJiYgKHRGbGFnICE9IDMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHJlbGF0aXZlIG1lYXN1cmVzIG9mIGNvbnZlcmdlbmNlIG9mIHMgYW5kIHYgc2VxdWVuY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0diA9ICgodnYgIT0gMC4wKSA/IE1hdGguYWJzKCh2diAtIG92dikgLyB2dikgOiB0dik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cyA9ICgoc3MgIT0gMC4wKSA/IE1hdGguYWJzKChzcyAtIG9zcykgLyBzcykgOiB0cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVjcmVhc2luZywgbXVsdGlwbHkgdGhlIHR3byBtb3N0IHJlY2VudCBjb252ZXJnZW5jZSBtZWFzdXJlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHZ2ID0gKCh0diA8IG90dikgPyB0diAqIG90diA6IDEuMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0c3MgPSAoKHRzIDwgb3RzKSA/IHRzICogb3RzIDogMS4wKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHdpdGggY29udmVyZ2VuY2UgY3JpdGVyaWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZwYXNzID0gKCh0dnYgPCBiZXRhdikgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFzcyA9ICgodHNzIDwgYmV0YXMpID8gMSA6IDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKChzcGFzcykgfHwgKHZwYXNzKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCBsZWFzdCBvbmUgc2VxdWVuY2UgaGFzIHBhc3NlZCB0aGUgY29udmVyZ2VuY2UgdGVzdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB2YXJpYWJsZXMgYmVmb3JlIGl0ZXJhdGluZ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBOOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZrW2ldID0gS1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHNzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaG9vc2UgaXRlcmF0aW9uIGFjY29yZGluZyB0byB0aGUgZmFzdGVzdCBjb252ZXJnaW5nIHNlcXVlbmNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cnkgPSB2dHJ5ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKDsgOyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoKGZmbGFnICYmICgoZmZsYWcgPSAwKSA9PSAwKSkgJiYgKChzcGFzcykgJiYgKCF2cGFzcyB8fCAodHNzIDwgdHZ2KSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7Ly8gRG8gbm90aGluZy4gUHJvdmlkZXMgYSBxdWljayBcInNob3J0IGNpcmN1aXRcIi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1YWRJVF9hazEoREJMX0VQU0lMT04sIE4sIGlQYXIsIHVpLCB2aSwgcXAsIE5OLCBzZFBhciwgcCwgcWssIGNhbGNQYXIsIEspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHNkUGFyLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gc2RQYXIuYjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigoaVBhci5OWikgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWFkcmF0aWMgaXRlcmF0aW9uIGhhcyBmYWlsZWQuIEZsYWcgdGhhdCBpdCBoYXMgYmVlbiB0cmllZCBhbmQgZGVjcmVhc2UgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJnZW5jZSBjcml0ZXJpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlGbGFnID0gdnRyeSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXRhdiAqPSAwLjI1O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBsaW5lYXIgaXRlcmF0aW9uIGlmIGl0IGhhcyBub3QgYmVlbiB0cmllZCBhbmQgdGhlIHMgc2VxdWVuY2UgaXMgY29udmVyZ2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyeSB8fCAoIXNwYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlGbGFnID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IE47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1tpXSA9IHN2a1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZmbGFnID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaUZsYWcgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHNkUGFyIGZvciBwYXNzaW5nIGluIHMgaW5zdGVhZCBvZiBkZWZpbmluZyBhIGJyYW5kLW5ldyB2YXJpYWJsZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNkUGFyLmEgPSBzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZFBhci5hID0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlGbGFnID0gUmVhbElUX2FrMShEQkxfRVBTSUxPTiwgaVBhciwgc2RQYXIsIE4sIHAsIE5OLCBxcCwgSywgcWspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHNkUGFyLmE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoKGlQYXIuTlopID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGluZWFyIGl0ZXJhdGlvbiBoYXMgZmFpbGVkLiBGbGFnIHRoYXQgaXQgaGFzIGJlZW4gdHJpZWQgYW5kIGRlY3JlYXNlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVyZ2VuY2UgY3JpdGVyaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJ5ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJldGFzICo9IDAuMjU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaUZsYWcgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGxpbmVhciBpdGVyYXRpb24gc2lnbmFscyBhbiBhbG1vc3QgZG91YmxlIHJlYWwgemVybywgYXR0ZW1wdCBxdWFkcmF0aWMgaXRlcmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSAtKHMgKyBzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aSA9IHMgKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgTjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1tpXSA9IHN2a1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBxdWFkcmF0aWMgaXRlcmF0aW9uIGlmIGl0IGhhcyBub3QgYmVlbiB0cmllZCBhbmQgdGhlIHYgc2VxdWVuY2UgaXMgY29udmVyZ2luZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighdnBhc3MgfHwgdnRyeSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1x0XHQvLyBCcmVhayBvdXQgb2YgaW5maW5pdGUgZm9yIGxvb3BcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1jb21wdXRlIHFwIGFuZCBzY2FsYXIgdmFsdWVzIHRvIGNvbnRpbnVlIHRoZSBzZWNvbmQgc3RhZ2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVhZFNEX2FrMShOTiwgdSwgdiwgcCwgcXAsIHNkUGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gc2RQYXIuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gc2RQYXIuYjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdEZsYWcgPSBjYWxjU0NfYWsxKERCTF9FUFNJTE9OLCBOLCBhLCBiLCBjYWxjUGFyLCBLLCB1LCB2LCBxayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Z2ID0gdnY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9zcyA9IHNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdHYgPSB0djtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3RzID0gdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBycFNvbHZlKGRlZ1BhciwgcCwgemVyb3IsIHplcm9pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIE4gPSBkZWdQYXIuRGVncmVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUkFERkFDID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NiAvIDE4MCwgLy8gRGVncmVlcy10by1yYWRpYW5zIGNvbnZlcnNpb24gZmFjdG9yID0gUEkvMTgwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMQjIgPSBNYXRoLkxOMiwgLy8gRHVtbXkgdmFyaWFibGUgdG8gYXZvaWQgcmUtY2FsY3VsYXRpbmcgdGhpcyB2YWx1ZSBpbiBsb29wIGJlbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNRFAxID0gZGVnUGFyLkRlZ3JlZSArIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLID0gbmV3IEFycmF5KE1EUDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHQgPSBuZXcgQXJyYXkoTURQMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxcCA9IG5ldyBBcnJheShNRFAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBuZXcgQXJyYXkoTURQMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBxUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgdGhlIGZvdXIgcGFyYW1ldGVycy0tc3IsIHNpLCBsciwgYW5kIGxpLS1ieSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFQYXIgPSBuZXcgT2JqZWN0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGeHNoZnJfUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgcGFyYW1ldGVycyBieSByZWZlcmVuY2UgOiBOWiwgbHppLCBsenIsIHN6aSwgc3pyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZ4c2hmcl9QYXIgPSBuZXcgT2JqZWN0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibmQsIERCTF9FUFNJTE9OLCBkZiwgZHgsIGZhY3RvciwgZmYsIG1vZHVsaV9tYXgsIG1vZHVsaV9taW4sIHNjLCB4LCB4bSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFhLCBiYiwgY2MsIHNyLCB0LCB1LCB4eHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqLCBqaiwgbCwgTk0xLCBOTiwgemVyb2s7Ly8gSW50ZWdlciB2YXJpYWJsZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtYWNoaW5lIGVwc2lsb24gYW5kIHN0b3JlIGluIHRoZSB2YXJpYWJsZSBEQkxfRVBTSUxPTi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgdGhpcyB2YWx1ZSwganVzdCB1c2UgZXhpc3RpbmcgdmFyaWFibGVzIHJhdGhlciB0aGFuIGNyZWF0ZSBuZXcgb25lcyB0aGF0IHdpbGwgYmUgdXNlZCBvbmx5IGZvciB0aGlzIGNvZGUgYmxvY2tcclxuICAgICAgICAgICAgICAgICAgICBhYSA9IDEuMDtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERCTF9FUFNJTE9OID0gYWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhIC89IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJiID0gMS4wICsgYWE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGJiID4gMS4wKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIExPID0gTnVtYmVyLk1JTl9WQUxVRSAvIERCTF9FUFNJTE9OLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29zciA9IE1hdGguY29zKDk0LjAgKiBSQURGQUMpLCAvLyA9IC0wLjA2OTc1NjQ3NFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luciA9IE1hdGguc2luKDk0LjAgKiBSQURGQUMpLCAvLyA9IDAuOTk3NTY0MDVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh4ID0gTWF0aC5zcXJ0KDAuNSksIC8vID0gMC43MDcxMDY3OFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXkgPSAteHg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIEZ4c2hmcl9QYXIuTlogPSBqID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBGeHNoZnJfUGFyLnN6ciA9IEZ4c2hmcl9QYXIuc3ppID0gRnhzaGZyX1Bhci5senIgPSBGeHNoZnJfUGFyLmx6aSA9IDAuMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHplcm9zIGF0IHRoZSBvcmlnaW4sIGlmIGFueVxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHBbTl0gPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6ZXJvcltqXSA9IHplcm9pW2pdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTi0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIE5OID0gTiArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vID4+Pj4+IEJlZ2luIE1haW4gTG9vcCA8PDw8PFxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKE4gPj0gMSkgeyAvLyBNYWluIGxvb3BcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdGhlIGFsZ29yaXRobSBmb3Igb25lIHplcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoTiA8PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZpbmFsIHplcm8gb3IgcGFpciBvZiB6ZXJvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoTiA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJvcltkZWdQYXIuRGVncmVlIC0gMV0gPSAtKHBbMV0gLyBwWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJvaVtkZWdQYXIuRGVncmVlIC0gMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcVBhci5saSA9IHFQYXIubHIgPSBxUGFyLnNpID0gcVBhci5zciA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFkX2FrMShwWzBdLCBwWzFdLCBwWzJdLCBxUGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJvcltkZWdQYXIuRGVncmVlIC0gMl0gPSBxUGFyLnNyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9pW2RlZ1Bhci5EZWdyZWUgLSAyXSA9IHFQYXIuc2k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb3JbZGVnUGFyLkRlZ3JlZSAtIDFdID0gcVBhci5scjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJvaVtkZWdQYXIuRGVncmVlIC0gMV0gPSBxUGFyLmxpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3QgYW5kIHNtYWxsZXN0IG1vZHVsaSBvZiB0aGUgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsaV9tYXggPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsaV9taW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgTk47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGguYWJzKHBbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeCA+IG1vZHVsaV9tYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxpX21heCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigoeCAhPSAwKSAmJiAoeCA8IG1vZHVsaV9taW4pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsaV9taW4gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZSBpZiB0aGVyZSBhcmUgbGFyZ2Ugb3IgdmVyeSBzbWFsbCBjb2VmZmljaWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZXMgYSBzY2FsZSBmYWN0b3IgdG8gbXVsdGlwbHkgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcG9seW5vbWlhbC4gVGhlIHNjYWxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSB0byBhdm9pZCBvdmVyZmxvdyBhbmQgdG8gYXZvaWQgdW5kZXRlY3RlZCB1bmRlcmZsb3cgaW50ZXJmZXJpbmcgd2l0aCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVyZ2VuY2UgY3JpdGVyaW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmFjdG9yIGlzIGEgcG93ZXIgb2YgdGhlIGJhc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gTE8gLyBtb2R1bGlfbWluO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoKChzYyA8PSAxLjApICYmIChtb2R1bGlfbWF4ID49IDEwKSkgfHwgKChzYyA+IDEuMCkgJiYgKE51bWJlci5NQVhfVkFMVUUgLyBzYyA+PSBtb2R1bGlfbWF4KSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gKChzYyA9PSAwKSA/IE51bWJlci5NSU5fVkFMVUUgOiBzYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzYykgLyBMQjIgKyAwLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gTWF0aC5wb3coMi4wLCBsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZhY3RvciAhPSAxLjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBOTjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW2ldICo9IGZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBsb3dlciBib3VuZCBvbiBtb2R1bGkgb2YgemVyb3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IE5OOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdFtpXSA9IE1hdGguYWJzKHBbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdFtOXSA9IC0ocHRbTl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBOTTEgPSBOIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdXBwZXIgZXN0aW1hdGUgb2YgYm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGguZXhwKChNYXRoLmxvZygtcHRbTl0pIC0gTWF0aC5sb2cocHRbMF0pKSAvIE4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHRbTk0xXSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBOZXd0b24gc3RlcCBhdCB0aGUgb3JpZ2luIGlzIGJldHRlciwgdXNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bSA9IC1wdFtOXSAvIHB0W05NMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gKCh4bSA8IHgpID8geG0gOiB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hvcCB0aGUgaW50ZXJ2YWwgKDAsIHgpIHVudGlsIGZmIDw9IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgeG0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0geG07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4bSA9IDAuMSAqIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZiA9IHB0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IE5OOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZiA9IGZmICogeG0gKyBwdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShmZiA+IDApOyAvLyBFbmQgZG8td2hpbGUgbG9vcFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBOZXd0b24gaXRlcmF0aW9uIHVudGlsIHggY29udmVyZ2VzIHRvIHR3byBkZWNpbWFsIHBsYWNlc1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGYgPSBmZiA9IHB0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmID0geCAqIGZmICsgcHRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGYgPSB4ICogZGYgKyBmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gRW5kIGZvciBpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZiA9IHggKiBmZiArIHB0W05dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggPSBmZiAvIGRmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCAtPSBkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShNYXRoLmFicyhkeCAvIHgpID4gMC4wMDUpOyAvLyBFbmQgZG8td2hpbGUgbG9vcFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYm5kID0geDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGRlcml2YXRpdmUgYXMgdGhlIGluaXRpYWwgSyBwb2x5bm9taWFsIGFuZCBkbyA1IHN0ZXBzIHdpdGggbm8gc2hpZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IE47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbaV0gPSAoTiAtIGkpICogcFtpXSAvIE47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEtbMF0gPSBwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYSA9IHBbTl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJiID0gcFtOTTFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6ZXJvayA9ICgoS1tOTTFdID09IDApID8gMSA6IDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGpqID0gMDsgamogPCA1OyBqaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYyA9IEtbTk0xXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHplcm9rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHVuc2NhbGVkIGZvcm0gb2YgcmVjdXJyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBOTTE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gTk0xIC0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1tqXSA9IEtbaiAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gRW5kIGZvciBpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1swXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb2sgPSAoKEtbTk0xXSA9PSAwKSA/IDEgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgc2NhbGVkIGZvcm0gb2YgcmVjdXJyZW5jZSBpZiB2YWx1ZSBvZiBLIGF0IDAgaXMgbm9uemVyb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAtYWEgLyBjYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgTk0xOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IE5NMSAtIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbal0gPSB0ICogS1tqIC0gMV0gKyBwW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gRW5kIGZvciBpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1swXSA9IHBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb2sgPSAoKE1hdGguYWJzKEtbTk0xXSkgPD0gTWF0aC5hYnMoYmIpICogREJMX0VQU0lMT04gKiAxMC4wKSA/IDEgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBLIGZvciByZXN0YXJ0cyB3aXRoIG5ldyBzaGlmdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IE47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBbaV0gPSBLW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0byBzZWxlY3QgdGhlIHF1YWRyYXRpYyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggbmV3IHNoaWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqaiA9IDE7IGpqIDw9IDIwOyBqaisrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVhZHJhdGljIGNvcnJlc3BvbmRzIHRvIGEgZG91YmxlIHNoaWZ0IHRvIGEgbm9uLXJlYWwgcG9pbnQgYW5kIGl0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxleCBjb25qdWdhdGUuIFRoZSBwb2ludCBoYXMgbW9kdWx1cyBCTkQgYW5kIGFtcGxpdHVkZSByb3RhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSA5NCBkZWdyZWVzIGZyb20gdGhlIHByZXZpb3VzIHNoaWZ0LlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh4eCA9IC0oc2luciAqIHl5KSArIGNvc3IgKiB4eDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl5ID0gc2luciAqIHh4ICsgY29zciAqIHl5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeHggPSB4eHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzciA9IGJuZCAqIHh4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IC0oMi4wICogc3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlY29uZCBzdGFnZSBjYWxjdWxhdGlvbiwgZml4ZWQgcXVhZHJhdGljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGeHNoZnJfYWsxKERCTF9FUFNJTE9OLCBNRFAxLCAyMCAqIGpqLCBzciwgYm5kLCBLLCBOLCBwLCBOTiwgcXAsIHUsIEZ4c2hmcl9QYXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKEZ4c2hmcl9QYXIuTlogIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgc3RhZ2UganVtcHMgZGlyZWN0bHkgdG8gb25lIG9mIHRoZSB0aGlyZCBzdGFnZSBpdGVyYXRpb25zIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgaGVyZSBpZiBzdWNjZXNzZnVsLiBEZWZsYXRlIHRoZSBwb2x5bm9taWFsLCBzdG9yZSB0aGUgemVybyBvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHplcm9zLCBhbmQgcmV0dXJuIHRvIHRoZSBtYWluIGFsZ29yaXRobS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gZGVnUGFyLkRlZ3JlZSAtIE47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb3Jbal0gPSBGeHNoZnJfUGFyLnN6cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJvaVtqXSA9IEZ4c2hmcl9QYXIuc3ppO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5OID0gTk4gLSBGeHNoZnJfUGFyLk5aO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE4gPSBOTiAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IE5OOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbaV0gPSBxcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihGeHNoZnJfUGFyLk5aICE9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb3JbaiArIDFdID0gRnhzaGZyX1Bhci5senI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9pW2ogKyAxXSA9IEZ4c2hmcl9QYXIubHppO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVyYXRpb24gaXMgdW5zdWNjZXNzZnVsLCBhbm90aGVyIHF1YWRyYXRpYyBpcyBjaG9zZW4gYWZ0ZXIgcmVzdG9yaW5nIEtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbaV0gPSB0ZW1wW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gd2l0aCBmYWlsdXJlIGlmIG5vIGNvbnZlcmdlbmNlIHdpdGggMjAgc2hpZnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGpqID4gMjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZ1Bhci5EZWdyZWUgLT0gTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vID4+Pj4+IEVuZCBNYWluIExvb3AgPDw8PDxcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLy0tPiBFbmQgSmVua2lucy1UcmF1YlxyXG4gICAgICAgICAgICAgICAgcnBTb2x2ZShkZWdyZWVQYXIsIHAsIHplcm9yLCB6ZXJvaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSB6ZXJvaS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAvL2Zvcm1hdCB0aGUgb3V0cHV0XHJcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSByb3VuZCB0aGUgaW1hZ2luYXJ5IHBhcnQgdG8gYXZvaWQgaGF2aW5nIHNvbWV0aGluZyBjcmF6eSBsaWtlIDUuNjdlLTE2LlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbWcgPSByb3VuZCh6ZXJvaVtpXSwgZGVjcCArIDgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhbCA9IHJvdW5kKHplcm9yW2ldLCBkZWNwICsgOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlkIHRoZSByb3VuZGluZyBwYXkgb2ZmPyBJZiB0aGUgcm91bmRpbmcgZGlkIG5vdGhpbmcgbW9yZSB0aGFuIGNob3Agb2ZmIGEgZmV3IGRpZ2l0cyB0aGVuIG5vLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyByZXN1bHRzIGluIGEgYSBudW1iZXIgYXQgbGVhc3QgMyBkaWdpdHMgc2hvcnRlciB3ZSdsbCBrZWVwIGl0IGVsc2Ugd2UnbGwga2VlcCBcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb3RoZXJ3aXNlIHRoZSByb3VuZGluZyB3YXMgd29ydGggaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhbCA9IGRlY3AgLSBTdHJpbmcocmVhbCkubGVuZ3RoID4gMiA/IHJlYWwgOiB6ZXJvcltpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IGltZyA8IDAgPyAnLScgOiAnJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB6ZXJvZXNcclxuICAgICAgICAgICAgICAgICAgICBpZihyZWFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWwgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaW1nID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZyA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIDEgYXMgdGhlIG11bHRpcGxpZXIgYW5kIGRpc2NhcmQgaW1hZ2luYXJ5IHBhcnQgaWYgdGhlcmUgaXNuJ3Qgb25lLlxyXG4gICAgICAgICAgICAgICAgICAgIGltZyA9IE1hdGguYWJzKGltZykgPT09IDEgPyBzaWduICsgJ2knIDogKGltZyA/IGltZyArICcqaScgOiAnJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSAocmVhbCAmJiBpbWcpID8gcmVhbCArICcrJyArIGltZyA6IHJlYWwgKyBpbWc7XHJcbiAgICAgICAgICAgICAgICAgICAgemVyb3JbaV0gPSBudW0ucmVwbGFjZSgvXFwrXFwtL2csICctJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RzOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCh0cnVlLCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMubnJvb3RzKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJvb3RzID0gX18ucHJvb3RzKHN5bWJvbCkubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZSh4KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb3JlLlZlY3Rvci5mcm9tQXJyYXkocm9vdHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnJvb3Q6IGZ1bmN0aW9uIChmLCBndWVzcywgZHgpIHtcclxuICAgICAgICAgICAgdmFyIG5ld3RvbnJhcGggPSBmdW5jdGlvbiAoeG4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNoID0gMWUtMTIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkZXJpdmF0aXZlIHdhcyBhbHJlYWR5IHByb3ZpZGVkIHRoZW4gZG9uJ3QgcmVjYWxjdWxhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmID0gZHggPyBkeCA6IGNvcmUuVXRpbHMuYnVpbGQoY29yZS5DYWxjdWx1cy5kaWZmKGYuY2xvbmUoKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZnVuY3Rpb24gd2FzIHBhc3NlZCBpbiBhcyBhIGZ1bmN0aW9uIHRoZW4gZG9uJ3QgcmVjYWxjdWxhdGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gZiBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZiA6IGNvcmUuVXRpbHMuYnVpbGQoZiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IDEwMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmV0eSA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSghZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0geG4gLSAoZm4oeG4pIC8gZGYoeG4pKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2Fic29sdXRlIHZhbHVlcyBmb3IgYm90aCB4ICYgeG4gZW5zdXJlcyB0aGF0IHdlIGluZGVlZCBoYXZlIHRoZSByYWRpdXMgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmFicyh4KSAtIE1hdGguYWJzKHhuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhID0gTWF0aC5hYnMocik7XHJcbiAgICAgICAgICAgICAgICAgICAgeG4gPSB4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihkZWx0YSA8IG1lc2gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc2FmZXR5ID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhuID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzYWZldHkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB4bjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld3RvbnJhcGgoTnVtYmVyKGd1ZXNzKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWFkOiBmdW5jdGlvbiAoYSwgYiwgYykge1xyXG4gICAgICAgICAgICB2YXIgcSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBzaWduKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZSgnLSgnICsgYiArICcrJyArIHNpZ24gKyAnKnNxcnQoKCcgKyBiICsgJyleMi00KignICsgYSArICcpKignICsgYyArICcpKSkvKDIqJyArIGEgKyAnKScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gW3EoYSwgYiwgYywgMSksIHEoYSwgYiwgYywgLTEpXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN1bVByb2Q6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfXy5xdWFkKC1iLCBhLCAtMSkubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5pbnZlcnQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2VmZnM6IGZ1bmN0aW9uIChzeW1ib2wsIHdydCwgY29lZmZzKSB7XHJcbiAgICAgICAgICAgIHdydCA9IFN0cmluZyh3cnQpO1xyXG4gICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG4gICAgICAgICAgICBjb2VmZnMgPSBjb2VmZnMgfHwgW25ldyBTeW1ib2woMCldO1xyXG4gICAgICAgICAgICAvL3dlIGNhbm5vdCBnZXQgY29lZmZzIGZvciBncm91cCBFWFxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEVYICYmIHN5bWJvbC5jb250YWlucyh3cnQsIHRydWUpKVxyXG4gICAgICAgICAgICAgICAgXy5lcnJvcignVW5hYmxlIHRvIGdldCBjb2VmZmljaWVudHMgdXNpbmcgZXhwcmVzc2lvbiAnICsgc3ltYm9sLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB2YXIgdmFycyA9IHZhcmlhYmxlcyhzeW1ib2wpO1xyXG4gICAgICAgICAgICBpZih2YXJzLmxlbmd0aCA9PT0gMSAmJiB2YXJzWzBdID09PSB3cnQgJiYgIXN5bWJvbC5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBQb2x5bm9taWFsKHN5bWJvbCkuY29lZmZzLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKHgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmID0gYVtpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBjb2VmZnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29lZmYgPSBfLmFkZChlLCBjb2VmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29lZmZzW2ldID0gY29lZmY7IC8vdHJhbnNmZXIgaXQgYWxsIG92ZXJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKCF3cnQpXHJcbiAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignUG9seW5vbWlhbCBjb250YWlucyBtb3JlIHRoYW4gb25lIHZhcmlhYmxlLiBQbGVhc2Ugc3BlY2lmeSB3aGljaCB2YXJpYWJsZSBpcyB0byBiZSB1c2VkIScpO1xyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgdmFyaWFibGUgaXNuJ3QgcGFydCBvZiB0aGlzIHBvbHlub21pYWwgdGhlbiB3ZSdyZSBsb29raW5nIGF0IHheMFxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHZhcnMuaW5kZXhPZih3cnQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZWZmc1swXSA9IF8uYWRkKHN5bWJvbCwgY29lZmZzWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZWZmcyA9IGNvZWZmcyB8fCBbbmV3IFN5bWJvbCgwKV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHN5bWJvbC5zeW1ib2xzW3dydF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignRXhwcmVzc2lvbiBpcyBub3QgYSBwb2x5bm9taWFsIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE51bWJlcihzLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29lZmYgPSBfLmRpdmlkZShzeW1ib2wuY2xvbmUoKSwgcy5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29lZmYuY29udGFpbnMod3J0LCB0cnVlKSB8fCBwIDwgMCB8fCAhaXNJbnQocCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVycm9yKCdFeHByZXNzaW9uIGlzIG5vdCBhIHBvbHlub21pYWwhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gY29lZmZzW3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmYgPSBfLmFkZChlLCBjb2VmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmc1twXSA9IGNvZWZmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmNvZWZmcyh4LmNsb25lKCksIHdydCwgY29lZmZzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZmlsbCBob2xlc1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gY29lZmZzLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb2VmZnNbaV0gPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvZWZmc1tpXSA9IG5ldyBTeW1ib2woMCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29lZmZzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0J3MgYWxsIHRoZSBwb3dlcnMgb2YgYSBwYXJ0aWN1bGFyIHBvbHlub21pYWwgaW5jbHVkaW5nIHRoZSBkZW5vbWluYXRvcnMuIFRoZSBkZW5vbWluYXRvcnMgcG93ZXJzXHJcbiAgICAgICAgICogYXJlIHJldHVybmVkIGFzIG5lZ2F0aXZlLiBBbGwgcmVtYWluaW5nIHBvbHlub21pYWxzIGFyZSByZXR1cm5lZCBhcyB6ZXJvIG9yZGVyIHBvbHlub21pYWxzLlxyXG4gICAgICAgICAqIGZvciBleGFtcGxlIHBvbHlQb3dlcnMoeF4yKzEveCt5K3QpIHdpbGwgcmV0dXJuIFsgJy0xJywgMCwgJzInIF1cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gZVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JfdmFyaWFibGVcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwb3dlcnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBwb3dlcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICAvL2Fzc3VtZXMgeW91J3ZlIGFscmVhZHkgdmVyaWZpZWQgdGhhdCBpdCdzIGEgcG9seW5vbWlhbFxyXG4gICAgICAgIHBvbHlQb3dlcnM6IGZ1bmN0aW9uIChlLCBmb3JfdmFyaWFibGUsIHBvd2Vycykge1xyXG4gICAgICAgICAgICBwb3dlcnMgPSBwb3dlcnMgfHwgW107XHJcbiAgICAgICAgICAgIHZhciBnID0gZyA9IGUuZ3JvdXA7XHJcbiAgICAgICAgICAgIGlmKGcgPT09IFBMICYmIGZvcl92YXJpYWJsZSA9PT0gZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcG93ZXJzID0gcG93ZXJzLmNvbmNhdChrZXlzKGUuc3ltYm9scykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgcyBpbiBlLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gZS5zeW1ib2xzW3NdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gc3ltYm9sLmdyb3VwLCB2ID0gc3ltYm9sLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGcgPT09IFMgJiYgZm9yX3ZhcmlhYmxlID09PSB2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3dlcnMucHVzaChzeW1ib2wucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gUEwgfHwgZyA9PT0gQ1ApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvd2VycyA9IF9fLnBvbHlQb3dlcnMoc3ltYm9sLCBmb3JfdmFyaWFibGUsIHBvd2Vycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBDQiAmJiBzeW1ib2wuY29udGFpbnMoZm9yX3ZhcmlhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHN5bWJvbC5zeW1ib2xzW2Zvcl92YXJpYWJsZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3dlcnMucHVzaCgodC5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IE4gfHwgZm9yX3ZhcmlhYmxlICE9PSB2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3dlcnMucHVzaCgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IENCICYmIGUuY29udGFpbnMoZm9yX3ZhcmlhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgcG93ZXJzLnB1c2goY29yZS5VdGlscy5kZWNvbXBvc2VfZm4oZSwgZm9yX3ZhcmlhYmxlLCB0cnVlKS54LnBvd2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5hcnJheVVuaXF1ZShwb3dlcnMpLnNvcnQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vVGhlIGZhY3RvciBvYmplY3RcclxuICAgICAgICBGYWN0b3I6IHtcclxuICAgICAgICAgICAgLy9zcGxpdHMgdGhlIHN5bWJvbCBpbiBzeW1ib2wgYW5kIGNvbnN0YW50XHJcbiAgICAgICAgICAgIHNwbGl0OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBTeW1ib2woMSk7IC8vdGhlIGNvbnN0YW50cyBwYXJ0XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG5ldyBTeW1ib2woMSk7IC8vdGhlIHN5bWJvbGljIHBhcnRcclxuICAgICAgICAgICAgICAgIF9fLkZhY3Rvci5mYWN0b3Ioc3ltYm9sLCBuZXcgRmFjdG9ycygpKS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfLnBhcnNlKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHguaXNDb25zdGFudCh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gXy5tdWx0aXBseShjLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBfLm11bHRpcGx5KHMsIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCBzXTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWl4OiBmdW5jdGlvbiAobywgaW5jbHVkZV9uZWdhdGl2ZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmYWN0b3JzID0ga2V5cyhvKTtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gZmFjdG9ycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IFtdOy8vY3JlYXRlIGEgcm93IHdoaWNoIHdlJ3IgZ29pbmcgdG8gYmUgbWl4aW5nXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IGZhY3RvcnNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gb1tmYWN0b3JdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsbCA9IG0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBsbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbVtqXSAqIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5wdXNoKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpbmNsdWRlX25lZ2F0aXZlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucHVzaCgtdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAxOyBqIDw9IHA7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5wdXNoKE1hdGgucG93KGZhY3RvciwgaikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vVE9ETzogdGhpcyBtZXRob2QgaXMgdG8gcmVwbGFjZSBjb21tb24gZmFjdG9yaW5nXHJcbiAgICAgICAgICAgIGNvbW1vbjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBtYXkgaGF2ZSB0aGUgdW5mb3J0dW5hdGUgc2lkZSBlZmZlY3Qgb2YgZXhwYW5kaW5nIGFuZCBmYWN0b3JpbmcgYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90byBvbmx5IGVuZCB1cCB3aXRoIHRoZSBzYW1lIHJlc3VsdC4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogdHJ5IHRvIGF2b2lkIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb2xsZWN0IHRoZSBzeW1ib2xzIGFuZCBzb3J0IHRvIGhhdmUgdGhlIGxvbmdlc3QgZmlyc3QuIFRoaW5raW5nIGlzIHRoYXQgdGhlIGxvbmdlc3QgdGVybXMgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFzIHRvIGNvbnRhaW4gdGhlIHZhcmlhYmxlIGluIG9yZGVyIGZvciBpdCB0byBiZSBmYWN0b3JhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gXy5leHBhbmQoc3ltYm9sLmNsb25lKCksIHRydWUpLmNvbGxlY3RTeW1ib2xzKG51bGwsIG51bGwsIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGIubGVuZ3RoIHx8IDEpIC0gKGEubGVuZ3RoIHx8IDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSB7fTsgLy9jcmVhdGUgYSBtYXAgb2YgY29tbW9uIGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IHN5bWJvbHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2VmZnMucHVzaChzeW0ubXVsdGlwbGllci5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOdW1iZXIoeC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNoZWNrIGV4aXRzIHNpbmNlIHdlIGhhdmUgYSBzeW1ib2xpYyBwb3dlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0ZvciB0aGUgZnV0dXJlLi4uIHRoaW5rIGFib3V0IHJlbW92aW5nIHRoaXMgY2hlY2sgYW5kIG1vZGlmeSBmb3Igc3ltYm9saWMgcG93ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNOYU4ocCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhpdGluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIHRoZSBzeW1ib2xzIGFuZCBsdW1wIHRvZ2V0aGVyIGNvbW1vbiB0ZXJtc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHgudmFsdWUgaW4gbWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHAgPCBtYXBbeC52YWx1ZV1bMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBbeC52YWx1ZV1bMF0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBbeC52YWx1ZV1bMV0ucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBbeC52YWx1ZV0gPSBbcCwgW3hdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIG1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGlzIGZhY3RvciBpcyBmb3VuZCBpbiBhbGwgdGVybXMgc2luY2UgdGhlIGxlbmd0aCBvZiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWF0Y2hpbmcgdmFyaWFibGUgdGVybXMgbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIG9yaWdpbmFsIHRlcm1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtYXBbeF1bMV0ubGVuZ3RoID09PSBzeW1ib2xzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2VuZXJhdGUgYSBzeW1ib2wgYW5kIG11bHRpcGx5IGludG8gdGhlIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvciA9IF8ubXVsdGlwbHkoZmFjdG9yLCBfLnBvdyhuZXcgU3ltYm9sKHgpLCBuZXcgU3ltYm9sKG1hcFt4XVswXSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBjb2VmZmljaWVudCBmYWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBjb3JlLk1hdGgyLlFHQ0QuYXBwbHkobnVsbCwgY29lZmZzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQobmV3IFN5bWJvbChjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHNbaV0ubXVsdGlwbGllciA9IHN5bWJvbHNbaV0ubXVsdGlwbGllci5kaXZpZGUoYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgd2UgYWN0dWFsbCBmb3VuZCBhbnkgZmFjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZmFjdG9yLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoZmFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uYWRkKHN5bWJvbCwgXy5kaXZpZGUoc3ltYm9sc1tpXSwgZmFjdG9yLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgemVyb2VzOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5leGNlcHRpb25zLlZhbHVlTGltaXRFeGNlZWRlZEVycm9yKCdFeGl0aW5nJyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFycywgdGVybSwgc3VtLCBwLCBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBlID0gc3ltYm9sLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFycyA9IHZhcmlhYmxlcyhzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdW0gPSBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG93ZXJzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3RhcnQgc2V0dGluZyBlYWNoIHZhcmlhYmxlIHRvIHplcm9cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gdmFycy5sZW5ndGg7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2Ugd2FudCB0byBjcmVhdGUgYSBzdWJzIG9iamVjdCB3aXRoIGFsbCBidXQgdGhlIGN1cnJlbnQgdmFyaWFibGUgc2V0IHRvIHplcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGw7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkgIT09IGopIC8vbWFrZSBzdXJlIHdlJ3JlIG5vdCBsb29raW5nIGF0IHRoZSBzYW1lIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic1t2YXJzW2pdXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm0gPSBfLnBhcnNlKGUsIHN1YnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHAgPSB0ZXJtLnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSB0ZW1wb3JhcnkgcG93ZXIgaGFzIHRvIGJlIGFuIGludGVnZXIgYXMgd2VsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighaXNJbnQodHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtcy5wdXNoKHRlcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3dlcnMucHVzaCh0ZXJtLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBnY2QuIFRoaXMgd2lsbCBiZSB0aGUgcCBpbiAoYV5uK2JebSlecFxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIGdjZCBlcXVhbHMgMSBtZWFuaW5nIG4gPSBtIHRoZW4gd2UgbmVlZCBhIHRpZSBicmVha2RlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuYWxsU2FtZShwb3dlcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHAgZ2l2ZW4geCBudW1iZXIgb2YgdGVybXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5fdGVybXMgPSBzeW1ib2wubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBudW1iZXIgb2YgemVyb2VzIGRldGVybWluZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5femVyb2VzID0gdGVybXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuX3plcm9lcyA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG5ldyBGcmFjKHBvd2Vyc1swXSAvIChuX3Rlcm1zIC0gMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5femVyb2VzID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gbmV3IEZyYWMocG93ZXJzWzBdIC8gTWF0aC5yb3VuZCgoTWF0aC5zcXJ0KDggKiBuX3Rlcm1zIC0gMSkgLSAzKSAvIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGxvd2VzdCBwb3NzaWJsZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy9lLmcuIGdpdmVuIGJeNCsyKmFeMipiXjIrYV40LCB0aGUgcG93ZXIgd2UncmUgbG9va2luZyBmb3Igd291bGQgYmUgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24oeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gQ0IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB4LmVhY2goZnVuY3Rpb24oeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXAgfHwgeS5wb3dlci5sZXNzVGhhbihwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vcCA9IE51bWJlcih5LnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB5LnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKCFwIHx8IHgucG93ZXIubGVzc1RoYW4ocCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAvL3AgPSBOdW1iZXIoeC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwID0geC5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3AgaXMganVzdCB0aGUgZ2NkIG9mIHRoZSBwb3dlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGNvcmUuTWF0aDIuUUdDRC5hcHBseShudWxsLCBwb3dlcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIGRvbid0IGhhdmUgYW4gaW50ZWdlciB0aGVuIGV4aXRcclxuICAgICAgICAgICAgICAgICAgICBpZighaXNJbnQocCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9idWlsZCB0aGUgZmFjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRlcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGVybXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gdC5wb3dlci5jbG9uZSgpLmRpdmlkZShwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5tdWx0aXBsaWVyID0gbmV3IEZyYWMoTWF0aC5wb3codC5tdWx0aXBsaWVyLCAxIC8gbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LnBvd2VyID0gcC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gPSBfLmFkZChzdW0sIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ieSBub3cgd2UgaGF2ZSB0aGUgZmFjdG9yIG9mIHplcm9lcy4gV2UnbGwga25vdyBpZiB3ZSBnb3QgaXQgcmlnaHQgYmVjYXVzZSBcclxuICAgICAgICAgICAgICAgICAgICAvL3dlJ2xsIGdldCBhIHJlbWFpbmRlciBvZiB6ZXJvIGVhY2ggdGltZSB3ZSBkaXZpZGUgYnkgaXRcclxuICAgICAgICAgICAgICAgICAgICBpZihzdW0uZ3JvdXAgIT09IENQKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sOyAvL25vdGhpbmcgdG8gZG9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF9fLmRpdihzeW1ib2wuY2xvbmUoKSwgc3VtLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkWzFdLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gZFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKHN1bS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoMSkpIC8vd2UndmUgcmVhY2hlZCAxIHNvIGRvbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZhY3RvcjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdHJ5IHRvIGZhY3RvciBjb25zdGFudHNcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5NYXRoMi5mYWN0b3Ioc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgX3N5bWJvbCA9IF8ucGFyc2Uoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBfXy5GYWN0b3IuX2ZhY3Rvcihfc3ltYm9sLCBmYWN0b3JzKTtcclxuICAgICAgICAgICAgICAgIGlmKHJldHZhbC5lcXVhbHMoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF8ucGFyc2UocmV0dmFsLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3N0b3JlIHRoZSBtdWx0aXBsaWVyIGFuZCBzdHJpcCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gXy5wYXJzZShyZXR2YWwubXVsdGlwbGllcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIFxyXG4gICAgICAgICAgICAgICAgICAgICAqIE5PVEU6IGZvciBzaWduIGlzc3VlcyB3aXRoIGZhY3RvciBTVEFSVCBERUJVR0dJTkcgSEVSRVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbW92ZSB0aGUgc2lnbiB0byB0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocmV0dmFsLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVsYXRlZCB0byAjNTY2LiBTaW5jZSB0aGUgc3ltYm9sJ3MgZ3JvdXAgbWF5IG5vdCBoYXZlIGJlZW4gcHJvcGVybHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlZCwgaXQncyBlYXNpZXIgdG8ganVzdCBwYXJzZSB0aGUgc3ltYm9sIGFuZCBoYXZlIHRoZSBwYXJzZXIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIHRoZSB1cGRhdGUgZm9yIHVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yZWQgPSBfLnBhcnNlKF9fLkZhY3Rvci5fZmFjdG9yKHgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZhY3RvcmVkLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IF8ubXVsdGlwbHkobSwgU3ltYm9sLmNyZWF0ZShmYWN0b3JlZC5tdWx0aXBsaWVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JlZC5lYWNoKGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9mYWN0b3JlZCA9IF8ucGFyc2UoX18uRmFjdG9yLl9mYWN0b3IoeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLm11bHRpcGx5KHQsIF9mYWN0b3JlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoX2ZhY3RvcmVkLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gXy5tdWx0aXBseShtLCBTeW1ib2wuY3JlYXRlKF9mYWN0b3JlZC5tdWx0aXBsaWVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5tdWx0aXBseSh0LCBmYWN0b3JlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9wdXQgYmFjayB0aGUgbXVsdGlwbGllciBhbmQgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBvdyhfLm11bHRpcGx5KG0sIHQpLCBwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBxdWFkRmFjdG9yOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNQb2x5KCkgJiYgX18uZGVncmVlKHN5bWJvbC5lcXVhbHMoMikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9XZSd2ZSAgYWxyZWFkeSBjaGVja2VkIHRoYXQgd2UncmUgZGVhbGluZyB3aXRoIGEgcG9seW5vbWlhbFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gY29yZS5VdGlscy52YXJpYWJsZXMoc3ltYm9sKVswXTsgLy9nZXQgdGhlIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmcyA9IF9fLmNvZWZmcyhzeW1ib2wsIHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZmFjdG9yIHRoZSBsZWFkIGNvZWZmaWNpZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNmID0gX18uRmFjdG9yLl9mYWN0b3IoY29lZmZzWzJdLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgd2UgaGF2ZSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2YuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gY2YuY29sbGVjdFN5bWJvbHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgZmFjdG9ycyBhcmUgZ3JlYXRlciB0aGFuIDIgd2UncmUgZG9uZSBzbyBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbHMubGVuZ3RoID4gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgd2UgaGF2ZSB0d28gZmFjdG9ycyB0aGVuIGF0dGVtcHQgdG8gZmFjdG9yIHRoZSBwb2x5bm9taWFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbGV0IHRoZSBmYWN0b3JzIGJlIGYxIGFuZCBmMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xldCB0aGUgZmFjdG9ycyBiZSAoYXgrYikoY3grZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgdGhlIGNvZWZmaWNpZW50cyBiZSBjMXheMitjMngrYzNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGVuIGEoeDEpK2MoeDIpPWMyIGFuZCB4MSp4Mj1jM1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGNhbiBzb2x2ZSBmb3IgeDEgYW5kIHgyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gXy5tdWx0aXBseShfLnBhcnNlKGNvZWZmc1swXSksIF8ucGFyc2Uoc3ltYm9sc1swXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IF8ucGFyc2UoY29lZmZzWzFdKS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBfLnBhcnNlKHN5bWJvbHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NvbHZlIHRoZSBzeXN0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfXy5xdWFkKGEsIGIsIGMpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc0ludCh4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgd2UgaGF2ZSBvbmUgcm9vdCB0aGVuIGZpbmQgdGhlIG90aGVyIG9uZSBieSBkaXZpZGluZyB0aGUgY29uc3RhbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocm9vdC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290MSA9IHJvb3RbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdDIgPSBfLmRpdmlkZShjb2VmZnNbMF0sIF8ucGFyc2Uocm9vdDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaXNJbnQocm9vdDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBmb3VuZCB0aGVtIGJvdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnBhcnNlKGZvcm1hdCgnKHswfSkqKHsxfSkrKHsyfSknLCBzeW1ib2xzWzFdLCB2LCByb290MikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnBhcnNlKGZvcm1hdCgnKHswfSkqKHsxfSkrKHsyfSknLCBzeW1ib2xzWzBdLCB2LCByb290MSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3ViZUZhY3RvcjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IHN5bWJvbC5jb2xsZWN0U3ltYm9scygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzeW1ib2wgc2hvdWxkIGJlIGluIHRoZSBmb3JtIG9mIGFeMystYl4zLiBUaGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHRoZXJlZm9yZSBvbmx5IGJlIHR3by4gSWYgaXQncyBhbnkgZGlmZmVyZW50IGZyb20gdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBzaWducyBhbmQgdGhlbiBzdHJpcCB0aGVtIGZyb20gdGhlIHN5bWJvbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25fYSA9IHN5bWJvbHNbMF0uc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHN5bWJvbHNbMF0uY2xvbmUoKS5hYnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25fYiA9IHN5bWJvbHNbMV0uc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHN5bWJvbHNbMV0uY2xvbmUoKS5hYnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhleSdyZSBjdWJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEuaXNDdWJlKCkgJiYgYi5pc0N1YmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgbmVnYXRpdmUgc2lnbiBvbiB0aGUgcmlnaHQsIG1lYW5pbmcgYiBpcyBhbHdheXMgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzaWduX2EgPCBzaWduX2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2FwIHRoZSBzaWducyBhbmQgdGhlbiB0aGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NpZ25fYSwgc2lnbl9iXSA9IFtzaWduX2IsIHNpZ25fYV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2EsIGJdID0gW2IsIGFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0ZWggcm9vdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtX3Jvb3RfYSA9IF8ucGFyc2UoYS5nZXROdGgoMykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1fcm9vdF9iID0gXy5wYXJzZShiLmdldE50aCgzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjdWJlIGZvciBib3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IF8ubXVsdGlwbHkoXy5leHBhbmQoXy5wb3coYS5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKSwgXy5wYXJzZSgnMS8zJykpKSwgbV9yb290X2EpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBfLm11bHRpcGx5KF8uZXhwYW5kKF8ucG93KGIuY2xvbmUoKS50b1VuaXRNdWx0aXBsaWVyKCksIF8ucGFyc2UoJzEvMycpKSksIG1fcm9vdF9iKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzaWduX2EgPT09IDEgJiYgc2lnbl9iID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGRpZmZlcmVuY2Ugb2YgY3ViZXMgcnVsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKF8ucGFyc2UoZm9ybWF0KCcoKHswfSktKHsxfSkpJywgeCwgeSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnBhcnNlKGZvcm1hdCgnKCh7MH0pXjIrKHswfSkqKHsxfSkrKHsxfSleMiknLCB4LCB5KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc2lnbl9hID09PSAxICYmIHNpZ25fYiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHN1bSBvZiBjdWJlcyBydWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoXy5wYXJzZShmb3JtYXQoJygoezB9KSsoezF9KSknLCB4LCB5KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKF8ucGFyc2UoZm9ybWF0KCcoKHswfSleMi0oezB9KSooezF9KSsoezF9KV4yKScsIHgsIHkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF9mYWN0b3I6IGZ1bmN0aW9uIChzeW1ib2wsIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIC8vc29tZSBpdGVtcyBjYW5ub3QgYmUgZmFjdG9yZWQgYW55IGZ1cnRoZXIgc28gcmV0dXJuIHRob3NlIHJpZ2h0IGF3YXlcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXJnLmdyb3VwID09PSBTICYmIGFyZy5pc1NpbXBsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IFMgJiYgc3ltYm9sLmlzU2ltcGxlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4cGFuZCB0aGUgc3ltYm9sIHRvIGdldCBpdCBpbiBhIHByZWRpY3RhYmxlIGZvcm0uIElmIHRoaXMgc3RlcFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgc2tpcHBlZCBzb21lIGZhY3RvcnMgYXJlIG1pc3NlZC5cclxuICAgICAgICAgICAgICAgIC8vaWYoc3ltYm9sLmdyb3VwID09PSBDUCAmJiAhKGV2ZW4oc3ltYm9sLnBvd2VyKSAmJiBzeW1ib2wubXVsdGlwbGllci5sZXNzVGhhbigwKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZGlzdHJpYnV0ZU11bHRpcGxpZXIodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCh4Lmdyb3VwID09PSBDUCAmJiB4LnBvd2VyLmdyZWF0ZXJUaGFuKDEpIHx8IHguZ3JvdXAgPT09IENCKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBfLmV4cGFuZCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8uYWRkKHQsIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHQucG93ZXIgPSBzeW1ib2wucG93ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBGTiAmJiBzeW1ib2wuZm5hbWUgIT09ICdzcXJ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGNvcmUuVXRpbHMuZXZhbHVhdGUoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL21ha2UgYSBjb3B5IG9mIHRoZSBzeW1ib2wgdG8gcmV0dXJuIGlmIHNvbWV0aGluZyBnb2VzIHdyb25nXHJcbiAgICAgICAgICAgICAgICB2YXIgdW50b3VjaGVkID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfLnBhcnNlKHN5bWJvbC5wb3dlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVuX2FycmF5LCBudW1fYXJyYXksIGRlbiwgbnVtLCBkZmFjdCwgbmZhY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ3JhYiB0aGUgZGVub21pbmF0b3IgYW5kIHN0cmlwIHRoZSBtdWx0aXBsaWVyIGFuZCBwb3dlci4gU3RvcmUgdGhlbSBpbiBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5fYXJyYXkgPSBfXy5TaW1wbGlmeS5zdHJpcChzeW1ib2wuZ2V0RGVub20oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bV9hcnJheSA9IF9fLlNpbXBsaWZ5LnN0cmlwKHN5bWJvbC5nZXROdW0oKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW4gPSBkZW5fYXJyYXkucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IG51bV9hcnJheS5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIG51bWVyYXRvciBlcXVhbHMgdGhlIHN5bWJvbCB0aGVuIHdlJ3ZlIGhpdCB0aGUgc2ltcGxlc3QgZm9ybSBhbmQgdGhlbiB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG51bS5lcXVhbHMoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZmFjdCA9IF9fLkZhY3Rvci5mYWN0b3IobnVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGZhY3QgPSBfXy5GYWN0b3IuZmFjdG9yKGRlbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IF9fLlNpbXBsaWZ5LnVuc3RyaXAobnVtX2FycmF5LCBuZmFjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gX18uU2ltcGxpZnkudW5zdHJpcChkZW5fYXJyYXksIGRmYWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBfLmRpdmlkZShuLCBkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sOyAvL2Fic29sdXRlbHkgbm90aGluZyB0byBkb1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gY29yZS5NYXRoMi5mYWN0b3Ioc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gc3ltYm9sLnBvd2VyLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzSW50KHApICYmICEocC5sZXNzVGhhbigwKSAmJiBzeW1ib2wuZ3JvdXAgPT09IEZOKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHAuc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycyA9IGZhY3RvcnMgfHwgbmV3IEZhY3RvcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKGNvcmUuVXRpbHMuc3ViRnVuY3Rpb25zKHN5bWJvbCwgbWFwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGtleXMobWFwKS5sZW5ndGggPiAwKSB7IC8vaXQgbWlnaHQgaGF2ZSBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMucHJlQWRkID0gZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBfLnBhcnNlKGZhY3RvciwgY29yZS5VdGlscy5nZXRGdW5jdGlvbnNTdWJzKG1hcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3N0cmlwIHRoZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighc3ltYm9sLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMucEZhY3RvciA9IHN5bWJvbC5wb3dlci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0gdmFyaWFibGVzKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYnlwYXNzIGZvciBpbWFnaW5hcnkuIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcnMucHVzaChjb3JlLlNldHRpbmdzLklNQUdJTkFSWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11bHRpVmFyID0gdmFycy5sZW5ndGggPiAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9taW5vciBvcHRpbWl6YXRpb24uIFNlZW1zIHRvIGN1dCBmYWN0b3IgdGltZSBieSBoYWxmIGluIHNvbWUgY2FzZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG11bHRpVmFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsX1MgPSB0cnVlLCBhbGxfdW5pdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgIT09IFMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbF9TID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXgubXVsdGlwbGllci5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbF91bml0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhbGxfUyAmJiBhbGxfdW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBvdyhfLnBhcnNlKHN5bWJvbCwgY29yZS5VdGlscy5nZXRGdW5jdGlvbnNTdWJzKG1hcCkpLCBfLnBhcnNlKHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9mYWN0b3IgdGhlIGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29lZmZfZmFjdG9ycyA9IG5ldyBGYWN0b3JzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5GYWN0b3IuY29lZmZGYWN0b3Ioc3ltYm9sLCBjb2VmZl9mYWN0b3JzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmX2ZhY3RvcnMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZhY3RvciB3YXMgbmVnYXRpdmUgYnV0IHdhcyB3aXRoaW4gYSBzcXVhcmUgdGhlbiBpdCBiZWNvbWVzIHBvc2l0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihldmVuKHApICYmIHgubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZ24gPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZhY3RvciB0aGUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvd2VyX2ZhY3RvcnMgPSBuZXcgRmFjdG9ycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5GYWN0b3IucG93ZXJGYWN0b3Ioc3ltYm9sLCBwb3dlcl9mYWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJfZmFjdG9ycy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW11bHRpVmFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Bhc3MgaW4gdmFyc1swXSBmb3Igc2FmZXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHZhcnNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gX18uRmFjdG9yLnNxdWFyZUZyZWUoc3ltYm9sLCBmYWN0b3JzLCB2KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdF9mYWN0b3JzID0gbmV3IEZhY3RvcnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5GYWN0b3IudHJpYWxBbmRFcnJvcihzeW1ib2wsIHRfZmFjdG9ycywgdik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZW5lcmF0ZSBhIHN5bWJvbCBiYXNlZCBvZmYgdGhlIGxhc3QgZmFjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRmX3N5bWJvbCA9IHRfZmFjdG9ycy50b1N5bWJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBub3RoaW5nIHdhcyBmYWN0b3JlZCB0aGVuIHJldHVybiB0aGUgZmFjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGZfc3ltYm9sLmVxdWFscyh1bnRvdWNoZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRmX3N5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdF9mYWN0b3JzLmZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N0b3JlIHRoZSBjdXJyZW50IGZhY3RvciBpbiB0X2ZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0X2ZhY3RvciA9IHRfZmFjdG9ycy5mYWN0b3JzW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKF8ucG93KHRfZmFjdG9yLCBfLnBhcnNlKHApKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBmYWN0b3IgYW5kIGl0J3MgcXVhZHJhdGljIHRoZW4gbGV0J3MganVzdCBkbyBhIHF1YWQgZmFjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKHVudG91Y2hlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5GYWN0b3IucXVhZEZhY3RvcihzeW1ib2wsIGZhY3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBzdW0gYW5kIGRpZmZlcmVuY2Ugb2YgY3ViZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF9fLkZhY3Rvci5jdWJlRmFjdG9yKHN5bWJvbCwgZmFjdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gX18uRmFjdG9yLm1mYWN0b3Ioc3ltYm9sLCBmYWN0b3JzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3B1dCBiYWNrIHRoZSBzaWduIG9mIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5wb3dlci5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xhc3QgbWludXRlIGNsZWFuIHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2Uoc3ltYm9sLCBjb3JlLlV0aWxzLmdldEZ1bmN0aW9uc1N1YnMobWFwKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnBvdyhzeW1ib2wsIF8ucGFyc2UocCkpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBmYWN0b3JzLnRvU3ltYm9sKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL25vIG5lZWQgdG8gc3RvcCB0aGUgc2hvdyBiZWNhdXNlIHNvbWV0aGluZyB3ZW50IHdyb25nIDopLiBKdXN0IHJldHVybiB0aGUgdW5mYWN0b3JlZC5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW50b3VjaGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZWR1Y2U6IGZ1bmN0aW9uIChzeW1ib2wsIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ1AgJiYgc3ltYm9sLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gc3ltYm9sLmNvbGxlY3RTeW1ib2xzKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5tdWx0aXBsaWVyIC0gYS5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbHNbMF0ucG93ZXIuZXF1YWxzKHN5bWJvbHNbMV0ucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8veF5uLWFeblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IF8ucGFyc2Uoc3ltYm9sc1swXS5wb3dlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHN5bWJvbHNbMF0uY2xvbmUoKS50b0xpbmVhcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBzeW1ib2xzWzFdLmNsb25lKCkudG9MaW5lYXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgcnVsZTogKGEtYikqc3VtKGFeKG4taSkqYl4oaS0xKSwxLG4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKF8uYWRkKGEuY2xvbmUoKSwgYi5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmxpcCB0aGUgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3R1cm4gbiBpbnRvIGEgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubiA9IE51bWJlcihuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgcmVtYWluZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDw9IG5uOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYSA9IF8ucG93KGEuY2xvbmUoKSwgXy5zdWJ0cmFjdChuLmNsb25lKCksIG5ldyBTeW1ib2woaSkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmIgPSBfLnBvdyhiLmNsb25lKCksIF8uc3VidHJhY3QobmV3IFN5bWJvbChpKSwgbmV3IFN5bWJvbCgxKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5hZGQocmVzdWx0LCBfLm11bHRpcGx5KGFhLCBiYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1ha2VzIFN5bWJvbCBzcXVhcmUgZnJlZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RmFjdG9yc30gZmFjdG9yc1xyXG4gICAgICAgICAgICAgKiBAQHBhcmFtIHtTdHJpbmd9IHZhcmlhYmxlIFRoZSB2YXJpYWJsZSB3aGljaCBpcyBiZWluZyBmYWN0b3JlZCBcclxuICAgICAgICAgICAgICogQHJldHVybnMge1tTeW1ib2wsIEZhY3Rvcl19XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzcXVhcmVGcmVlOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzLCB2YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSB8fCBzeW1ib2wuZ3JvdXAgPT09IFMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcG9seSA9IG5ldyBQb2x5bm9taWFsKHN5bWJvbCwgdmFyaWFibGUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNxZnIgPSBwb2x5LnNxdWFyZUZyZWUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gc3FmclsyXTtcclxuICAgICAgICAgICAgICAgIC8vaWYgd2UgZm91bmQgYSBzcXVhcmUgdGhlbiB0aGUgcCBlbnRyeSBpbiB0aGUgYXJyYXkgd2lsbCBiZSBub24tdW5pdFxyXG4gICAgICAgICAgICAgICAgaWYocCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIHRoZSByZW1haW5kZXIgZG9lc24ndCBoYXZlIGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHNxZnJbMV0udG9TeW1ib2woKTtcclxuICAgICAgICAgICAgICAgICAgICB0LnBvd2VyID0gdC5wb3dlci5tdWx0aXBseShuZXcgRnJhYyhwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZW5kIHRoZSBmYWN0b3IgdG8gYmUgZmF0b3JlZCB0byBiZSBzdXJlIGl0J3MgY29tcGxldGVseSBmYWN0b3JlZFxyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKF9fLkZhY3Rvci5mYWN0b3IodCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gX18uRmFjdG9yLnNxdWFyZUZyZWUoc3FmclswXS50b1N5bWJvbCgpLCBmYWN0b3JzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmFjdG9ycyB0aGUgcG93ZXJzIHN1Y2ggdGhhdCB0aGUgbG93ZXN0IHBvd2VyIGlzIGEgY29uc3RhbnRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0ZhY3RvcnN9IGZhY3RvcnNcclxuICAgICAgICAgICAgICogQHJldHVybnMge1tTeW1ib2wsIEZhY3Rvcl19XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwb3dlckZhY3RvcjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgLy9vbmx5IFBMIG5lZWQgYXBwbHlcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCAhPT0gUEwgfHwgc3ltYm9sLnByZXZpb3VzR3JvdXAgPT09IEVYKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IGtleXMoc3ltYm9sLnN5bWJvbHMpO1xyXG4gICAgICAgICAgICAgICAgLy93ZSBleHBlY3Qgb25seSBudW1lcmljIHBvd2VycyBzbyByZXR1cm4gYWxsIGVsc2VcclxuICAgICAgICAgICAgICAgIGlmKCFjb3JlLlV0aWxzLmFsbE51bWVyaWMoaykpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGNvcmUuVXRpbHMuYXJyYXlNaW4oayk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgIHZhciBxID0gXy5wYXJzZShzeW1ib2wudmFsdWUgKyAnXicgKyBkKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IF8uZGl2aWRlKHgsIHEuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCB4KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKHEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgR0NEIGZyb20gY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGYWN0b3J9IGZhY3RvcnNcclxuICAgICAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGNvZWZmRmFjdG9yOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnY2QgPSBjb3JlLk1hdGgyLlFHQ0QuYXBwbHkobnVsbCwgc3ltYm9sLmNvZWZmcygpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWdjZC5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZWFjaChmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5Lm11bHRpcGxpZXIgPSB5Lm11bHRpcGxpZXIuZGl2aWRlKGdjZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5tdWx0aXBsaWVyID0geC5tdWx0aXBsaWVyLmRpdmlkZShnY2QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnVwZGF0ZUhhc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIHByb2JhYmx5IGdvIHRvIHRoZSBwcm90b3R5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvd2VyID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCArPSB4LnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IE51bWJlcihzeW1ib2wucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhY3RvciBvdXQgbmVnYXRpdmVzIGZyb20gdGhlIGxlYWQgdGVybVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVybXMgPSBzeW1ib2wuY29sbGVjdFN5bWJvbHMobnVsbCwgbnVsbCwgbnVsbCwgdHJ1ZSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVzaCBjb25zdGFudHMgdG8gdGhlIGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEuaXNDb25zdGFudCh0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnBvd2VyIC0gYS5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgTFQgPSB0ZXJtc1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBMVCBpcyBpbmRlZWQgdGhlIGdyZWF0ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBvd2VyKExUKSA+IHBvd2VyKHRlcm1zWzFdKSB8fCB0ZXJtc1sxXS5pc0NvbnN0YW50KHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihMVC5tdWx0aXBsaWVyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWx0aG91Z2ggdGhlIHN5bWJvbCBzaG91bGQgYWx3YXlzIGJlIGxpbmVhciBhdCB0aGlzIHBvaW50LCByZW1vdmUgdGhlIG5lZ2F0aXZlIGZvciBzcXVhcmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYmUgc2FmZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChuZXcgU3ltYm9sKC0xKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKG5ldyBTeW1ib2woZ2NkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbmFtZSBzYXlzIGl0IGFsbCA6KVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RmFjdG9yfSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAqIEBAcGFyYW0ge1N0cmluZ30gdmFyaWFibGUgXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0cmlhbEFuZEVycm9yOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzLCB2YXJpYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVudG91Y2hlZCA9IHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdCB0ZW1wIGhvbGRlciBmb3IgdGhlIGZhY3RvcnMuIElmIGFsbCBnb2VzIHdlbGwgdGhlblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXknbGwgYmUgbW92ZWQgdG8gdGhlIGFjdHVhbCBmYWN0b3JzLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JfYXJyYXkgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSB8fCBzeW1ib2wuZ3JvdXAgPT09IFMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvbHkgPSBuZXcgUG9seW5vbWlhbChzeW1ib2wsIHZhcmlhYmxlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNuc3QgPSBwb2x5LmNvZWZmc1swXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNmYWN0b3JzID0gY29yZS5NYXRoMi5pZmFjdG9yKGNuc3QpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHMgPSBfXy5wcm9vdHMoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcm9vdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSByb290c1tpXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWlzTmFOKHIpKSB7IC8vaWYgaXQncyBhIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIGNmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpdCdzIHJhaXNlZCB0byBhIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBjb3JlLlV0aWxzLnJvdW5kKE1hdGgubG9nKHgpIC8gTWF0aC5sb2coTWF0aC5hYnMocikpLCA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc0ludChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0geDsgLy94IG11c3QgYmUgdGhlIHJvb3Qgc2luY2UgbiBnYXZlIHVzIGEgd2hvbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gbmV3IEZyYWMociksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1zID0gW25ldyBGcmFjKHJvb3QubnVtKS5uZWdhdGUoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtc1twXSA9IG5ldyBGcmFjKHJvb3QuZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29udmVydCB0byBGcmFjLiBUaGUgZGVuIGlzIGNvZWZmIG9mIExUIGFuZCB0aGUgbnVtIGlzIGNvZWZmIG9mIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGl2ID0gUG9seW5vbWlhbC5mcm9tQXJyYXkodGVybXMsIHBvbHkudmFyaWFibGUpLmZpbGwoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHBvbHkuZGl2aWRlKGRpdik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0WzFdLmVxdWFsc051bWJlcigwKSkgeyAvL2lmIGl0J3MgemVybyB3ZSBoYXZlIGEgcm9vdCBhbmQgZGl2aWRlIGl0IG91dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHkgPSB0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhY3RvcnMuYWRkKGRpdi50b1N5bWJvbCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JfYXJyYXkucHVzaChkaXYudG9TeW1ib2woKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFwb2x5LmVxdWFsc051bWJlcigxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5ID0gX18uRmFjdG9yLnNlYXJjaChwb2x5LCBmYWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGZhY3RvcnMgb3ZlciBzaW5jZSBhbGwgd2VudCB3ZWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIGZhY3Rvcl9hcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seS50b1N5bWJvbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bnRvdWNoZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKHBvbHksIGZhY3RvcnMsIGJhc2UpIHtcclxuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlIHx8IDEwOyAvL0kgbGlrZSAxMCBiZWNhdXNlIG51bWJlcnMgZXhoaWJpdCBzaW1pbGFyIGJlaGF2aW91cnMgYXQgMTBcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gcG9seS52YXJpYWJsZTsgLy90aGUgcG9seW5taWFsIHZhcmlhYmxlIG5hbWVcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQXR0ZW1wdCB0byByZW1vdmUgYSByb290IGJ5IGRpdmlzaW9uIGdpdmVuIGEgbnVtYmVyIGJ5IGZpcnN0IGNyZWF0aW5nXHJcbiAgICAgICAgICAgICAgICAgKiBhIHBvbHlub21pYWwgZnJvbXQgaGUgZ2l2ZW4gaW5mb3JtYXRpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7aW50fSBjMSAtIGNvZWZmaWVudCBmb3IgdGhlIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2ludH0gYzIgLSBjb2VmZmljaWVudCBmb3IgdGhlIExUXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2ludH0gbiAtIHRoZSBudW1iZXIgdG8gYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHBvbHlub21pYWxcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7aW50fSBwIC0gdGhlIHBvd2VyIGF0IHdoaWNoIHRvIGNyZWF0ZSB0aGUgcG9seW5vbWlhbFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bGx8UG9seW5vbWlhbH0gLSByZXR1cm5zIHBvbHlub21pYWwgaWYgc3VjY2Vzc2Z1bCBvdGhlcndpc2UgbnVsbFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSBmdW5jdGlvbiAoYzEsIGMyLCBuLCBwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IFBvbHlub21pYWwuZml0KGMxLCBjMiwgbiwgYmFzZSwgcCwgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5jb2VmZnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHBvbHkuZGl2aWRlKGNhbmRpZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRbMV0uZXF1YWxzTnVtYmVyKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChjYW5kaWRhdGUudG9TeW1ib2woKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RbMF0sIGNhbmRpZGF0ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNuc3QgPSBwb2x5LmNvZWZmc1swXTtcclxuICAgICAgICAgICAgICAgIHZhciBjZmFjdG9ycyA9IGNvcmUuTWF0aDIuaWZhY3RvcihjbnN0KTtcclxuICAgICAgICAgICAgICAgIHZhciBsYyA9IHBvbHkubGMoKTtcclxuICAgICAgICAgICAgICAgIHZhciBsdGZhY3RvcnMgPSBjb3JlLk1hdGgyLmlmYWN0b3IobGMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YmJlZCA9IHBvbHkuc3ViKGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzdWJiZWQgPSBjb3JlLk1hdGgyLmlmYWN0b3Ioc3ViYmVkKTtcclxuICAgICAgICAgICAgICAgIHZhciBuZmFjdG9ycyA9IF9fLkZhY3Rvci5taXgoaXN1YmJlZCwgc3ViYmVkIDwgMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3AgPSBNYXRoLmNlaWwocG9seS5jb2VmZnMubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGNfaXNfbmVnID0gbGMubGVzc1RoYW4oMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY25zdF9pc19uZWcgPSBjbnN0Lmxlc3NUaGFuKDApO1xyXG4gICAgICAgICAgICAgICAgbHRmYWN0b3JzWycxJ10gPSAxO1xyXG4gICAgICAgICAgICAgICAgY2ZhY3RvcnNbJzEnXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB3aGlsZShjcC0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIGx0ZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHkgaW4gY2ZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuZmFjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JfZm91bmQgPSBjaGVjayh4LCB5LCBuZmFjdG9yc1tpXSwgY3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZhY3Rvcl9mb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5ID0gZmFjdG9yX2ZvdW5kWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighY29yZS5VdGlscy5pc1ByaW1lKHBvbHkuc3ViKGJhc2UpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHkgPSBfXy5GYWN0b3Iuc2VhcmNoKHBvbHksIGZhY3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZighZmFjdG9yX2ZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxjX2lzX25lZyAmJiBjbnN0X2lzX25lZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3Rvcl9mb3VuZCA9IGNoZWNrKC14LCAteSwgbmZhY3RvcnNbaV0sIGNwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihsY19pc19uZWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JfZm91bmQgPSBjaGVjaygteCwgeSwgbmZhY3RvcnNbaV0sIGNwKTsgLy9jaGVjayBhIG5lZ2F0aXZlIGxjXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY25zdF9pc19uZWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JfZm91bmQgPSBjaGVjayh4LCAteSwgbmZhY3RvcnNbaV0sIGNwKTsgLy9jaGVjayBhIG5lZ2F0aXZlIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvbHk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFcXVpdmFsZW50IG9mIHNxdWFyZSBmcmVlIGZhY3RvciBmb3IgbXVsdGl2YXJpYXRlIHBvbHlub21pYWxzXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7dHlwZX0gc3ltYm9sXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7dHlwZX0gZmFjdG9yc1xyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7QWxnZWJyYUwjMTguRmFjdG9yLm1TcWZyRmFjdG9yLnN5bWJvbHxBcnJheXxBbGdlYnJhTCMxOC5fXy5GYWN0b3IubVNxZnJGYWN0b3IuZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIG1TcWZyRmFjdG9yOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgIT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcnMgPSB2YXJpYWJsZXMoc3ltYm9sKS5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHZhcmlhYmxlIGFuZCByZW1vdmUgdGhlIHBhcnRpYWwgZGVyaXZhdGl2ZXNcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2YXJzW2ldID09PSBzeW1ib2wudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZXJpdmF0aXZlIHRlbGxzIHVzIG5vdGhpbmcgc2luY2UgdGhpcyBzeW1ib2wgaXMgYWxyZWFkeSB0aGUgZmFjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gY29yZS5DYWxjdWx1cy5kaWZmKHN5bWJvbCwgdmFyc1tpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfXy5GYWN0b3IuY29lZmZGYWN0b3IoZGlmZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZC5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cmlhbCBkaXZpc2lvbiB0byBzZWUgaWYgZmFjdG9ycyBoYXZlIHdob2xlIG51bWJlcnMuIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNhbiBiZSBvcHRpbWl6ZWQgYnkgc3RvcHBpbmcgYXMgc29vbiBhcyBjYW5fZGl2aWRlIGlzIGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgd2lsbCBhbHNvIG5lZWQgdXRpbGl6ZSBiaWcgbnVtYmVyIGF0IHNvbWUgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5fZGl2aWRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGQuaXNDb25zdGFudCgpICYmIHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayB0aGUgY29lZmZpY2llbnRzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHgubXVsdGlwbGllciAlIGQgIT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5fZGl2aWRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBjYW4gZGl2aWRlIHRoZW4gZG8gc29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbl9kaXZpZGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IF9fLmRpdihzeW1ib2wsIGQuY2xvbmUoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19mYWN0b3IgPSBkaXZbMV0uZXF1YWxzKDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkaXZbMF0uaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKGRpdlswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19mYWN0b3IgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc19mYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChkaXZbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoaXNfZmFjdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL2RpZmZlcmVuY2Ugb2Ygc3F1YXJlcyBmYWN0b3JpemF0aW9uXHJcbiAgICAgICAgICAgIHNxZGlmZjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoJ2FsbCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkb1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlX3NxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmJsb2NrKCdQT1NJVElWRV9NVUxUSVBMSUVSUycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2wudW53cmFwUEFSRU5TKG1hdGguc3FydChtYXRoLmFicyh4KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0ZWQgPSBjb3JlLlV0aWxzLnNlcGFyYXRlKHN5bWJvbC5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ial9hcnJheSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgdW5pcXVlIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBzZXBhcmF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoeCAhPT0gJ2NvbnN0YW50cycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ial9hcnJheS5wdXNoKHNlcGFyYXRlZFt4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqX2FycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIucG93ZXIgLSBhLnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHZhcmlhYmxlcyBhcyB1bmlxdWUgdmFyaWFibGVzIHRoZW4gd2UgY2FuIGFwcGx5IHRoZSBkaWZmZXJlbmNlIG9mIHNxdWFyZXNcclxuICAgICAgICAgICAgICAgICAgICBpZihvYmpfYXJyYXkubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhLCBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gb2JqX2FycmF5LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gb2JqX2FycmF5LnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXZlbihhLnBvd2VyKSAmJiBldmVuKGIucG93ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYS5zaWduKCkgPT09IGIuc2lnbigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYS5ncm91cCA9PT0gUyAmJiBiLmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmYWN0b3InKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhLmlzQ29tcG9zaXRlKCkgJiYgYi5wb3dlci5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBzcXVhcmUgZnJvbSBiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gcmVtb3ZlX3NxdWFyZShiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gX18uRmFjdG9yLmZhY3RvcihfLmFkZChhLCBzZXBhcmF0ZWQuY29uc3RhbnRzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmLnBvd2VyLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnN1YnRyYWN0KGYuY2xvbmUoKSwgYi5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoXy5hZGQoZiwgYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gYS5wb3dTaW1wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gYi5wb3dTaW1wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoKGEuZ3JvdXAgPT09IFMgfHwgYS5mbmFtZSA9PT0gJycpICYmIGEucG93ZXIuZXF1YWxzKDIpICYmIChiLmdyb3VwID09PSBTIHx8IGIuZm5hbWUgPT09ICcnKSAmJiBiLnBvd2VyLmVxdWFscygyKSAmJiAhc2VwYXJhdGVkLmNvbnN0YW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEubXVsdGlwbGllci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5tdWx0aXBsaWVyLmdyZWF0ZXJUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSByZW1vdmVfc3F1YXJlKGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gcmVtb3ZlX3NxdWFyZShiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKF8uc3VidHJhY3QoYS5jbG9uZSgpLCBiLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLmFkZChhLCBiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy9mYWN0b3JpbmcgZm9yIG11bHRpdmFyaWF0ZVxyXG4gICAgICAgICAgICBtZmFjdG9yOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5mbmFtZSA9PT0gJ3NxcnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JzMiA9IG5ldyBGYWN0b3JzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gX18uRmFjdG9yLmNvbW1vbihzeW1ib2wuYXJnc1swXS5jbG9uZSgpLCBmYWN0b3JzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IF9fLkZhY3Rvci5jb2VmZkZhY3RvcihhcmcsIGZhY3RvcnMyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5tdWx0aXBseShfLnN5bWZ1bmN0aW9uKCdzcXJ0JywgW2FyZ10pLCBfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMyLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ubXVsdGlwbHkoc3ltYm9sLCBfLnBhcnNlKGNvcmUuVXRpbHMuZm9ybWF0KCdzcXJ0KHswfSknLCB4KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3F1YXJlIGZyZWUgZmFjdG9yaXphdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF9fLkZhY3Rvci5tU3FmckZhY3RvcihzeW1ib2wsIGZhY3RvcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3RyeSBmYWN0b3Igb3V0IGNvbW1vbiBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zeW1ib2wgPSBfXy5GYWN0b3IuY29tbW9uKHN5bWJvbCwgZmFjdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0gdmFyaWFibGVzKHN5bWJvbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzID0gc3ltYm9sLmNvbGxlY3RTeW1ib2xzKCkubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2wudW53cmFwU1FSVCh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZCA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ZXMgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSB2YXJzLmxlbmd0aCwgbiA9IHN5bWJvbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGFrZSBhbGwgdGhlIHZhcmlhYmxlcyBpbiB0aGUgc3ltYm9sIGFuZCBvcmdhbml6ZSBieSB2YXJpYWJsZSBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgLy9lLmcuIGFeMithXjIrYiphIC0+IHthOiB7YV4zLCBhXjIsIGIqYX0sIGI6IHtiKmF9fVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdmFyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkW3ZdID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2xzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocy5jb250YWlucyh2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcy52YWx1ZSA9PT0gdiA/IHMucG93ZXIudG9EZWNpbWFsKCkgOiBzLnN5bWJvbHNbdl0ucG93ZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW1heGVzW3ZdIHx8IHAgPCBtYXhlc1t2XSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ZXNbdl0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFt2XSA9IF8uYWRkKHNvcnRlZFt2XSwgcy5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHNvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IF8ucGFyc2UoeCArICdeJyArIG1heGVzW3hdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IF8uZGl2aWRlKHNvcnRlZFt4XSwgcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdfZmFjdG9yID0gXy5leHBhbmQoZGl2KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5ld19mYWN0b3IuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vd2h5IGRpdmlkZSBieSBvbmUuIEp1c3QgbW92ZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdmlkZWQgPSBfXy5kaXYoc3ltYm9sLmNsb25lKCksIG5ld19mYWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGl2aWRlZFswXS5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FudCBmYWN0b3IgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHBvdGVudGlhbGx5IGVuZGVkIHVwIHdpdGggZnJhY3Rpb25hbCBjb2VmZmljaWVudHMgd2hlbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpYWwgZGl2aXNpb24gd2FzIHBlcmZvcm1lZC4gV2UgbmVlZCB0byByZW1vdmUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hlY2sgd2lsbCBtb3JlIHRoZW4gbGlrZWx5IGJlY29tZSBzdXBlcmZsdW91cyB3aXRoIGltcHJvdmVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBwb2x5bm9taWFsIGRpdmlzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpdmlkZWRbMV0uZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzX2ZyYWN0aW9ucyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmlkZWRbMF0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFpc0ludCh4Lm11bHRpcGxpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc19mcmFjdGlvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmYWN0b3IgaXNuJ3QgcmVhbGx5IGEgZmFjdG9yIGFuZCBuZWVkcyB0byBiZSBwdXQgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaGFzX2ZyYWN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmlkZWRbMV0gPSBfLmV4cGFuZChfLm11bHRpcGx5KGRpdmlkZWRbMV0sIG5ld19mYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbmV3IGZhY3RvciBpcyBub3QganVzdCBvbmUsIHdlIGV4aXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZWdfbnVtZXJpY19mYWN0b3IgPSBpc0ludChuZXdfZmFjdG9yKSAmJiBuZXdfZmFjdG9yLmxlc3NUaGFuKDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGl2aWRlZFsxXS5lcXVhbHMoMCkgJiYgIW5lZ19udW1lcmljX2ZhY3RvcikgeyAvL3dlIGZvdW5kIGF0IGxlYXN0IG9uZSBmYWN0b3JcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZhY3RvcnMuYWRkKG5ld19mYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfXy5kaXYoc3ltYm9sLmNsb25lKCksIGRpdmlkZWRbMF0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGRbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBsZWZ0IHRvIGRvIHNpbmNlIHdlIGRpZG4ndCBnZXQgYSByZWR1Y3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHIuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBkWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBkb24ndCB3YW50IHRvIGp1c3QgZmxpcCB0aGUgc2lnbi4gSWYgdGhlIHJlbWFpbmRlciBpcyAtMSB0aGVuIHdlIGFjY29tcGxpc2hlZCBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FuZCB3ZSBqdXN0IHJldHVybiB0aGUgc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiByIGVxdWFscyB6ZXJvIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gc28gd2UncmUgZG9uZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHIuZXF1YWxzKC0xKSAmJiAhc3ltYm9sLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBkaXZpZGVkWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoZmFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW0gPSBfXy5GYWN0b3IucmVkdWNlKGZhY3RvciwgZmFjdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFzeW1ib2wuZXF1YWxzKHJlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5GYWN0b3IubWZhY3RvcihyZW0sIGZhY3RvcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoZmFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSByZW1haW5kZXIgb2YgdGhlIHN5bWJvbCBpcyB6ZXJvIHRoZW4gd2UncmUgZG9uZS4gVE9ETzogUmV0aGluayB0aGlzIGxvZ2ljIGEgYml0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHIuaXNDb25zdGFudCgnYWxsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uRmFjdG9yLm1mYWN0b3IociwgZmFjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZGlmZmVyZW5jZSBvZiBzcXVhcmVzIGZhY3Rvcml6YXRpb25cclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF9fLkZhY3Rvci5zcWRpZmYoc3ltYm9sLCBmYWN0b3JzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2ZhY3RvcnMgYnkgZmlzaGluZyBmb3IgemVyb2VzXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5GYWN0b3IuemVyb2VzKHN5bWJvbCwgZmFjdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhIHNldCBvZiBcImVxdWF0aW9uc1wiIGlzIGxpbmVhci4gXHJcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSBzZXRcclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBhbGxMaW5lYXI6IGZ1bmN0aW9uIChzZXQpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSBzZXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZighX18uaXNMaW5lYXIoc2V0W2ldKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIFwiZXF1YXRpb25cIiBpcyBsaW5lYXJcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzTGluZWFyOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gZmFsc2UsIGcgPSBlLmdyb3VwO1xyXG4gICAgICAgICAgICBpZihnID09PSBQTCB8fCBnID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgcyBpbiBlLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gZS5zeW1ib2xzW3NdLCBzZyA9IHN5bWJvbC5ncm91cDtcclxuICAgICAgICAgICAgICAgICAgICBpZihzZyA9PT0gRk4gfHwgc2cgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzZyA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9uZWVkcyBmdXJ0aGVyIGNoZWNraW5nIHNpbmNlIGl0IG1pZ2h0IGJlIGltYWdpbmFyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSB2YXJpYWJsZXMoc3ltYm9sKS5sZW5ndGggPT09IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzZyA9PT0gUEwgfHwgc2cgPT09IENQKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gX18uaXNMaW5lYXIoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgIT09IE4gJiYgc3ltYm9sLnBvd2VyLnRvU3RyaW5nKCkgIT09ICcxJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gUyAmJiBlLnBvd2VyID09PSAxKVxyXG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdjZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncztcclxuICAgICAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBjb3JlLlZlY3RvcilcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF0uZWxlbWVudHM7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBjb3JlLlV0aWxzLmFyZ3VtZW50czJBcnJheShhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGVhcmx5XHJcbiAgICAgICAgICAgIGlmKGFyZ3MubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoYXJncy5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBhcHBlYXJlZCA9IFtdLCBldmFsdWF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYoYXJnc1tpXS5ncm91cCA9PT0gRk4gJiYgYXJnc1tpXS5mbmFtZSA9PT0gJ2djZCcpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb21wcmVzcyBnY2QoYSxnY2QoYixjKSkgaW50byBnY2QoYSxiLGMpXHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KGFyZ3VtZW50c1tpXS5hcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2RvIG5vdCBrZWVwIGdjZCBpbiBhcmdzXHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Mb29rIGlmIHRoZXJlIGFyZSBhbnkgY29tbW9uIHZhcmlhYmxlcyBzdWNoIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAvL2djZChhLGIpID0+IGdjZChhLGIpOyBnY2QoYSxhKSA9PiBhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcnMgPSB2YXJpYWJsZXMoYXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5VdGlscy5oYXZlSW50ZXJzZWN0aW9uKHZhcnMsIGFwcGVhcmVkKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vT2ssIHRoZXJlIGFyZSBjb21tb24gdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZWFyZWQgPSBhcHBlYXJlZC5jb25jYXQodmFycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vYXBwZWFyZWQubGVuZ3RoIGlzIDAgd2hlbiBhbGwgYXJndW1lbnRzIGFyZSBncm91cCBOXHJcbiAgICAgICAgICAgIGlmKGV2YWx1YXRlIHx8IGFwcGVhcmVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBkaXN0cmlidXRlIGV4cG9uZW50IHNvIHRoYXQgKGFeLTEqYl4tMSleLTEgPT4gYSpiXHJcbiAgICAgICAgICAgICAgICBpZihhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sLmdldERlbm9tKCkuZXF1YWxzKDEpXHJcbiAgICAgICAgICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZ2dyZWdhdGUgPSBhcmdzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGUgPSBfXy5nY2RfKGFyZ3NbaV0sIGFnZ3JlZ2F0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZ2dyZWdhdGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2djZF8gY2Fubm90IGhhbmRsZSBkZW5vbWluYXRvcnMgY29ycmVjdGx5XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKF9fLmdjZC5hcHBseShudWxsLCBhcmdzLm1hcChmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2wuZ2V0TnVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX18ubGNtLmFwcGx5KG51bGwsIGFyZ3MubWFwKGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sLmdldERlbm9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdnY2QnLCBhcmdzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdjZF86IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGlmKGEuZ3JvdXAgPT09IEZOIHx8IGEuZ3JvdXAgPT09IFApXHJcbiAgICAgICAgICAgICAgICBhID0gY29yZS5VdGlscy5ibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZihiLmdyb3VwID09PSBGTilcclxuICAgICAgICAgICAgICAgIGIgPSBjb3JlLlV0aWxzLmJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoYik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmKGEuaXNDb25zdGFudCgpICYmIGIuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gY29yZS5NYXRoMi5RR0NEKG5ldyBGcmFjKCthKSwgbmV3IEZyYWMoK2IpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKGNvcmUuTWF0aDIuUUdDRChuZXcgRnJhYygrYSksIG5ldyBGcmFjKCtiKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVuID0gXy5tdWx0aXBseShhLmdldERlbm9tKCkgfHwgbmV3IFN5bWJvbCgxKSwgYi5nZXREZW5vbSgpIHx8IG5ldyBTeW1ib2woMSkpLmludmVydCgpO1xyXG4gICAgICAgICAgICBhID0gXy5tdWx0aXBseShhLmNsb25lKCksIGRlbi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgYiA9IF8ubXVsdGlwbHkoYi5jbG9uZSgpLCBkZW4uY2xvbmUoKSk7XHJcblxyXG4gICAgICAgICAgICAvL2ZlZWxzIGNvdW50ZXIgaW50dWl0aXZlIGJ1dCBpdCB3b3Jrcy4gSXNzdWUgIzEyMyAobmVyZGFtZXIoXCJnY2QoeCt5LCh4K3kpXjIpXCIpKVxyXG4gICAgICAgICAgICBhID0gXy5leHBhbmQoYSk7XHJcbiAgICAgICAgICAgIGIgPSBfLmV4cGFuZChiKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGEuZ3JvdXAgPT09IENCIHx8IGIuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcSA9IF8uZGl2aWRlKGEuY2xvbmUoKSwgYi5jbG9uZSgpKTsgLy9nZXQgdGhlIHF1b3RpZW50XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IF8ubXVsdGlwbHkoYi5jbG9uZSgpLCBxLmdldERlbm9tKCkuaW52ZXJ0KCkpOy8vbXVsdGlwbHkgYnkgdGhlIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXkgaGF2ZSBhIGNvbW1vbiBmYWN0b3IgdGhlbiB0aGUgcmVzdWx0IHdpbGwgbm90IGVxdWFsIG9uZSBcclxuICAgICAgICAgICAgICAgIGlmKCF0LmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9qdXN0IHRha2UgdGhlIGdjZCBvZiBlYWNoIGNvbXBvbmVudCB3aGVuIGVpdGhlciBvZiB0aGVtIGlzIGluIGdyb3VwIEVYXHJcbiAgICAgICAgICAgIGlmKGEuZ3JvdXAgPT09IEVYIHx8IGIuZ3JvdXAgPT09IEVYKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2NkX20gPSBuZXcgU3ltYm9sKGNvcmUuTWF0aDIuR0NEKGEubXVsdGlwbGllciwgYi5tdWx0aXBsaWVyKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2NkX3YgPSBfXy5nY2RfKGEudmFsdWUgPT09IENPTlNUX0hBU0ggPyBuZXcgU3ltYm9sKDEpIDogXy5wYXJzZShhLnZhbHVlKSwgYi52YWx1ZSA9PT0gQ09OU1RfSEFTSCA/IG5ldyBTeW1ib2woMSkgOiBfLnBhcnNlKGIudmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIHZhciBnY2RfcCA9IF9fLmdjZF8oXy5wYXJzZShhLnBvd2VyKSwgXy5wYXJzZShiLnBvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShnY2RfbSwgXy5wb3coZ2NkX3YsIGdjZF9wKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGEubGVuZ3RoIDwgYi5sZW5ndGgpIHsgLy9zd2FwJ21cclxuICAgICAgICAgICAgICAgIHZhciB0ID0gYTtcclxuICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgYiA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhcnNfYSA9IHZhcmlhYmxlcyhhKSwgdmFyc19iID0gdmFyaWFibGVzKGIpO1xyXG4gICAgICAgICAgICBpZigodmFyc19hLmxlbmd0aCA9PT0gdmFyc19iLmxlbmd0aCAmJiB2YXJzX2EubGVuZ3RoID09PSAxICYmIHZhcnNfYVswXSA9PT0gdmFyc19iWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IHZhcnNfYS5sZW5ndGggPT09IDEgJiYgdmFyc19iLmxlbmd0aCA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgIHx8IHZhcnNfYS5sZW5ndGggPT09IDAgJiYgdmFyc19iLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgYSA9IG5ldyBQb2x5bm9taWFsKGEpO1xyXG4gICAgICAgICAgICAgICAgYiA9IG5ldyBQb2x5bm9taWFsKGIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKGEuZ2NkKGIpLnRvU3ltYm9sKCksIGRlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCB0aGUgZ2NkIG9mIHRoZSBtdWx0aXBpZXJzXHJcbiAgICAgICAgICAgICAgICAvL2dldCByaWQgb2YgZ2NkIGluIGNvZWZmc1xyXG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxpZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICBhLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVycy5wdXNoKHgubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGIuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXJzLnB1c2goeC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBUO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUoIWIuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBiLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGEuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBUID0gX18uZGl2KGEsIHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBiID0gVFsxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihUWzBdLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBfLm11bHRpcGx5KG5ldyBTeW1ib2woY29yZS5NYXRoMi5RR0NEKGEubXVsdGlwbGllciwgYi5tdWx0aXBsaWVyKSksIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUobmV3IFN5bWJvbChjb3JlLk1hdGgyLlFHQ0QoYS5tdWx0aXBsaWVyLCBiLm11bHRpcGxpZXIpKSwgZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGdjZCA9IGNvcmUuTWF0aDIuUUdDRC5hcHBseSh1bmRlZmluZWQsIG11bHRpcGxpZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZighZ2NkLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Lm11bHRpcGxpZXIgPSB4Lm11bHRpcGxpZXIuZGl2aWRlKGdjZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gc3ltYm9saWMgZnVuY3Rpb24gZm9yIGdjZCBpbiBpbmRldGVybWluYXRlIGZvcm1cclxuICAgICAgICAgICAgICAgIGlmKGEuZXF1YWxzKDEpICYmICFhLmlzQ29uc3RhbnQoKSAmJiAhYi5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKF8uc3ltZnVuY3Rpb24oJ2djZCcsIGFyZ3VtZW50cyksIGRlbik7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKGEsIGRlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxjbTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL2h0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzMxOTMxMFxyXG4gICAgICAgICAgICAvL2dlbmVyYWxpemF0aW9uIG9mIHRoZSAyLXZhcmlhYmxlIGZvcm11bGEgb2YgbGNtXHJcblxyXG4gICAgICAgICAgICB2YXIgYXJncztcclxuICAgICAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgIGlmKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIGNvcmUuVmVjdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF0uZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignbGNtIGV4cGVjdHMgZWl0aGVyIDEgdmVjdG9yIG9yIDIgb3IgbW9yZSBhcmd1bWVudHMnKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgYXJncyA9IGNvcmUuVXRpbHMuYXJndW1lbnRzMkFycmF5KGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAvL3Byb2R1Y3Qgb2YgYWxsIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAvL3N0YXJ0IHdpdGggbmV3IFN5bWJvbCgxKSBzbyB0aGF0IHByZXYuY2xvbmUoKSB3aGljaCBtYWtlcyB1bm5lc3Nlc2FyeSBjbG9uZXMgY2FuIGJlIGF2b2lkZWRcclxuICAgICAgICAgICAgdmFyIG51bWVyID0gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHByZXYsIGN1cnIuY2xvbmUoKSlcclxuICAgICAgICAgICAgfSwgbmV3IFN5bWJvbCgxKSk7XHJcblxyXG4gICAgICAgICAgICAvL2djZCBvZiBjb21wbGVtZW50YXJ5IHRlcm1zXHJcbiAgICAgICAgICAgIHZhciBkZW5vbV9hcmdzID1cclxuICAgICAgICAgICAgICAgICAgICAvL2h0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODIyMzA3MlxyXG4gICAgICAgICAgICAgICAgLy90YWtlIGFsbCBjb21wbGVtZW50YXJ5IHRlcm1zLCBlLmcuXHJcbiAgICAgICAgICAgICAgICAvL1thLGIsY10gPT4gW2EqYiwgYipjLCBhKmNdXHJcbiAgICAgICAgICAgICAgICAvL1thLGIsYyxkXSA9PiBbYSpiKmMsIGEqYipkLCBhKmMqZCwgYipjKmRdXHJcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKGlucHV0LCBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemUgPSBOdW1iZXIoc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gW10sIHJlc3VsdCwgbWFzaywgaSwgdG90YWwgPSBNYXRoLnBvdygyLCBpbnB1dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobWFzayA9IHNpemU7IG1hc2sgPCB0b3RhbDsgbWFzaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpbnB1dC5sZW5ndGggLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigobWFzayAmICgxIDw8IGkpKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbnB1dFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoaS0tKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQubGVuZ3RoID09PSBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RhcnQgd2l0aCBuZXcgU3ltYm9sKDEpIHNvIHRoYXQgcHJldi5jbG9uZSgpIHdoaWNoIG1ha2VzIHVubmVzc2VzYXJ5IGNsb25lcyBjYW4gYmUgYXZvaWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pKGFyZ3VtZW50cywgYXJndW1lbnRzLmxlbmd0aCAtIDEpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkocHJldiwgY3Vyci5jbG9uZSgpKVxyXG4gICAgICAgICAgICAgICAgfSwgbmV3IFN5bWJvbCgxKSlcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVub207XHJcbiAgICAgICAgICAgIC8vZG9uJ3QgZWF0IHRoZSBnY2QgdGVybSBpZiBhbGwgYXJndW1lbnRzIGFyZSBzeW1ib2xzXHJcbiAgICAgICAgICAgIGlmKGFyZ3MuZXZlcnkoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmlzVmFyaWFibGVTeW1ib2woeClcclxuICAgICAgICAgICAgfSkpXHJcbiAgICAgICAgICAgICAgICBkZW5vbSA9IF8uc3ltZnVuY3Rpb24oJ2djZCcsIGNvcmUuVXRpbHMuYXJyYXlVbmlxdWUoZGVub21fYXJncykpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBkZW5vbSA9IF9fLmdjZC5hcHBseShudWxsLCBkZW5vbV9hcmdzKTtcclxuICAgICAgICAgICAgLy9kaXZpZGUgcHJvZHVjdCBvZiBhbGwgYXJndW1lbnRzIGJ5IGdjZCBvZiBjb21wbGVtZW50YXJ5IHRlcm1zXHJcbiAgICAgICAgICAgIHZhciBkaXYgPSBfLmRpdmlkZShudW1lciwgZGVub20pO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGl2aWRlcyBvbmUgZXhwcmVzc2lvbiBieSBhbm90aGVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbDFcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sMlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaXZpZGU6IGZ1bmN0aW9uIChzeW1ib2wxLCBzeW1ib2wyKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHJlbWFpbmRlciwgZmFjdG9yZWQsIGRlbjtcclxuICAgICAgICAgICAgZmFjdG9yZWQgPSBjb3JlLkFsZ2VicmEuRmFjdG9yLmZhY3RvcihzeW1ib2wxLmNsb25lKCkpO1xyXG4gICAgICAgICAgICBkZW4gPSBmYWN0b3JlZC5nZXREZW5vbSgpO1xyXG4gICAgICAgICAgICBpZighZGVuLmlzQ29uc3RhbnQoJ2FsbCcpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wxID0gXy5leHBhbmQoU3ltYm9sLnVud3JhcFBBUkVOUyhfLm11bHRpcGx5KGZhY3RvcmVkLCBkZW4uY2xvbmUoKSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAvL3Jlc2V0IHRoZSBkZW5vbWluYXRvciBzaW5jZSB3ZSdyZSBub3QgZGl2aWRpbmcgYnkgaXQgYW55bW9yZVxyXG4gICAgICAgICAgICAgICAgZGVuID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gX18uZGl2KHN5bWJvbDEsIHN5bWJvbDIpO1xyXG4gICAgICAgICAgICByZW1haW5kZXIgPSBfLmRpdmlkZShyZXN1bHRbMV0sIHN5bWJvbDIpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoXy5hZGQocmVzdWx0WzBdLCByZW1haW5kZXIpLCBkZW4pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGl2OiBmdW5jdGlvbiAoc3ltYm9sMSwgc3ltYm9sMikge1xyXG4gICAgICAgICAgICAvLyBJZiBhbGwgZWxzZSBmYWlscyB0aGVuIGFzc3VtZSB0aGF0IGRpdmlzaW9uIGZhaWxlZCB3aXRoXHJcbiAgICAgICAgICAgIC8vIGEgcmVtYWluZGVyIG9mIHplcm8gYW5kIHRoZSBvcmlnaW5hbCBxdW90aWVudFxyXG4gICAgICAgICAgICB2YXIgZmFpbCA9IFtuZXcgU3ltYm9sKDApLCBzeW1ib2wxLmNsb25lKCldO1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEaXZpc2lvbiBieSBjb25zdGFudHNcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbDIuaXNDb25zdGFudCgnYWxsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wxLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5tdWx0aXBsaWVyID0geC5tdWx0aXBsaWVyLmRpdmlkZShzeW1ib2wyLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc3ltYm9sMSwgbmV3IFN5bWJvbCgwKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTbyB0aGF0IGZhY3Rvcml6ZWQgc3ltYm9scyBkb24ndCBhZmZlY3QgdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgc3ltYm9sMSA9IF8uZXhwYW5kKHN5bWJvbDEpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sMiA9IF8uZXhwYW5kKHN5bWJvbDIpO1xyXG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlLiBNYXkgbmVlZCByZXZpc2l0aW5nXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wxLmdyb3VwID09PSBTICYmIHN5bWJvbDIuZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBzeW1ib2wxLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gY29yZS5VdGlscy5kZWNvbXBvc2VfZm4oc3ltYm9sMi5jbG9uZSgpLCB4LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wxLmlzTGluZWFyKCkgJiYgZi54ICYmIGYueC5pc0xpbmVhcigpICYmIHN5bWJvbDIuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IFN5bWJvbC5jcmVhdGUoc3ltYm9sMS5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtfLmRpdmlkZShrLmNsb25lKCksIGYuYS5jbG9uZSgpKSwgXy5kaXZpZGUoXy5tdWx0aXBseShrLCBmLmIpLCBmLmEpLm5lZ2F0ZSgpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wxLmdyb3VwID09PSBTICYmIHN5bWJvbDIuZ3JvdXAgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IF8uZGl2aWRlKHN5bWJvbDEuY2xvbmUoKSwgc3ltYm9sMi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihyLmlzQ29uc3RhbnQoKSkgLy93ZSBoYXZlIGEgd2hvbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtyLCBuZXcgU3ltYm9sKDApXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBTeW1ib2woMCksIHN5bWJvbDEuY2xvbmUoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sMV9oYXNfZnVuYyA9IHN5bWJvbDEuaGFzRnVuYygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wyX2hhc19mdW5jID0gc3ltYm9sMi5oYXNGdW5jKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlX2Z1bmNzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zdWJzdGl0dXRlIG91dCBmdW5jdGlvbnMgc28gd2UgY2FuIHRyZWF0IHRoZW0gYXMgcmVndWxhciB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbDFfaGFzX2Z1bmMgfHwgc3ltYm9sMl9oYXNfZnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX2Z1bmNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wxID0gXy5wYXJzZShjb3JlLlV0aWxzLnN1YkZ1bmN0aW9ucyhzeW1ib2wxLCBtYXApKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbDIgPSBfLnBhcnNlKGNvcmUuVXRpbHMuc3ViRnVuY3Rpb25zKHN5bWJvbDIsIG1hcCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicyA9IGNvcmUuVXRpbHMuZ2V0RnVuY3Rpb25zU3VicyhtYXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9nZXQgYSBsaXN0IG9mIHRoZSB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgIHZhciB2YXJzID0gY29yZS5VdGlscy5hcnJheVVuaXF1ZSh2YXJpYWJsZXMoc3ltYm9sMSkuY29uY2F0KHZhcmlhYmxlcyhzeW1ib2wyKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdW90LCByZW07XHJcblxyXG4gICAgICAgICAgICAgICAgLy90cmVhdCBpbWFnaW5hcnkgbnVtYmVycyBhcyB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbDEuaXNJbWFnaW5hcnkoKSB8fCBzeW1ib2wyLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXJzLnB1c2goY29yZS5TZXR0aW5ncy5JTUFHSU5BUlkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHZhcnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUG9seW5vbWlhbChzeW1ib2wxKS5kaXZpZGUobmV3IFBvbHlub21pYWwoc3ltYm9sMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1b3QgPSBxWzBdLnRvU3ltYm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gcVsxXS50b1N5bWJvbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFycy5wdXNoKENPTlNUX0hBU0gpOyAvL3RoaXMgaXMgZm9yIHRoZSBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29udmVydCA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gYXJyW2ldLnRvU3ltYm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmFkZChzeW1ib2wsIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lsbHkgTWFydGluLiBUaGlzIGlzIHdoeSB5b3UgZG9jdW1lbnQuIEkgZG9uJ3QgcmVtZW1iZXIgbm93XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldF91bmlxdWVfbWF4ID0gZnVuY3Rpb24gKHRlcm0sIGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGVybS50ZXJtcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwLCBpZHg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighYW55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGVybS50ZXJtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRlcm0udGVybXNbaV0uZXF1YWxzKG1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY291bnQgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYW55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCB0ZXJtLnRlcm1zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRlcm0udGVybXNbaV0uZXF1YWxzKG1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWF4LCBpZHgsIHRlcm1dO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWVzIHRvIGZpbmQgYW4gTFQgaW4gdGhlIGRpdmlkZW5kIHRoYXQgd2lsbCBzYXRpc2Z5IGRpdmlzaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldF9kZXQgPSBmdW5jdGlvbiAocywgbG9va2F0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb2thdCA9IGxvb2thdCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGV0ID0gc1tsb29rYXRdLCBsID0gcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZWxpbWluYXRlIHRoZSBmaXJzdCB0ZXJtIGlmIGl0IGRvZXNuJ3QgYXBwbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVtYXggPSBnZXRfdW5pcXVlX21heChkZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSBsb29rYXQgKyAxOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVybSA9IHNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2VxdWFsID0gZGV0LnN1bS5lcXVhbHModGVybS5zdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWlzX2VxdWFsICYmIHVtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzX2VxdWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGRpZmZlcmVuY2VzIG9mIHRoZWlyIG1heGVzLiBUaGUgb25lIHdpdGggdGhlIGJpZ2dlc3QgZGlmZmVyZW5jZSBnb3Zlcm5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiB4XjIqeV4zIHZzIHheMip5XjMgaXMgdW5jbGVhciBidXQgdGhpcyBpc24ndCB0aGUgY2FzZSBpbiB4KnkgYW5kIHheMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXgxLCBtYXgyLCBpZHgxLCBpZHgyLCBsMiA9IGRldC50ZXJtcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGwyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0xID0gZGV0LnRlcm1zW2pdLCBpdGVtMiA9IHRlcm0udGVybXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBtYXgxID09PSAndW5kZWZpbmVkJyB8fCBpdGVtMS5ncmVhdGVyVGhhbihtYXgxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4MSA9IGl0ZW0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4MSA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIG1heDIgPT09ICd1bmRlZmluZWQnIHx8IGl0ZW0yLmdyZWF0ZXJUaGFuKG1heDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXgyID0gaXRlbTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHgyID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIHRoZWlyIGRpZmZlcmVuY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQxID0gbWF4MS5zdWJ0cmFjdCh0ZXJtLnRlcm1zW2lkeDFdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gbWF4Mi5zdWJ0cmFjdChkZXQudGVybXNbaWR4Ml0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGQyID4gZDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW1heCA9IFttYXgyLCBpZHgyLCB0ZXJtXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGQxID4gZDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW1heCA9IFttYXgxLCBpZHgxLCBkZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGl0J3MgYSBzdWl0YWJsZSBwaWNrIHRvIGRldGVybWluZSB0aGUgb3JkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bWF4ID0gZ2V0X3VuaXF1ZV9tYXgodGVybSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZih1bWF4KSByZXR1cm4gdW1heDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih1bWF4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVtYXggPSBnZXRfdW5pcXVlX21heCh0ZXJtKTsgLy9jYWxjdWxhdGUgYSBuZXcgdW5pcXVlIG1heFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHN0aWxsIG5vIHVtYXggdGhlbiBhbnkgd2lsbCBkbyBzaW5jZSB3ZSBoYXZlIGEgdGllXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF1bWF4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldF91bmlxdWVfbWF4KHNbMF0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSwgaWR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgczIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdGVybSA9IHMyW2ldLnRlcm1zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25maXJtIHRoYXQgdGhpcyBpcyBhIGdvb2QgbWF0Y2ggZm9yIHRoZSBkZW5vbWluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gdW1heFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlkeCA9PT0gY3Rlcm0ubGVuZ3RoIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gY3Rlcm1baWR4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFlLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRfZGV0KHMsICsrbG9va2F0KTsgLy9sb29rIGF0IHRoZSBuZXh0IHRlcm1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bWF4O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0X21hcCA9IGNvcmUuVXRpbHMudG9NYXBPYmoodmFycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRfc29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnN1bS5zdWJ0cmFjdChhLnN1bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNfbGFyZ2VyID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWEgfHwgIWIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vaXQncyBlbXB0eSBzby4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYS50ZXJtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS50ZXJtc1tpXS5sZXNzVGhhbihiLnRlcm1zW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMxID0gc3ltYm9sMS50QmFzZSh0X21hcCkuc29ydChpbml0X3NvcnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczIgPSBzeW1ib2wyLnRCYXNlKHRfbWFwKS5zb3J0KGluaXRfc29ydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGlzX2xhcmdlcihzMVswXSwgczJbMF0pICYmIHMxWzBdLmNvdW50ID4gczJbMF0uY291bnQgPyBzMiA6IHMxOyAvL3NpbmNlIHRoZSBudW0gaXMgYWxyZWFkeSBsYXJnZXIgdGhhbiB3ZSBjYW4gZ2V0IHRoZSBkZXQgZnJvbSBkZW5vbVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXQgPSBnZXRfZGV0KHRhcmdldCk7Ly93ZSdsbCBiZWdpbiBieSBhc3N1bWluZyB0aGF0IHRoaXMgd2lsbCBsZXQgdXMga25vdyB3aGljaCB0ZXJtIFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdW90aWVudCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGRldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVhZF92YXIgPSBkZXRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5fZGl2aWRlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFbMF0uc3VtLmVxdWFscyhiWzBdLnN1bSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID49IGIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJ5X2JldHRlcl9sZWFkX3ZhciA9IGZ1bmN0aW9uIChzMSwgczIsIGxlYWRfdmFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHMxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBzMVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdC50ZXJtcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2YgPSBjaGVja2VkW2pdLCB0dCA9IHQudGVybXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkW2pdID0gdHQ7IC8vYWRkIHRoZSB0ZXJtcyBmb3IgdGhlIGZpcnN0IG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNmICYmICFjZi5lcXVhbHModHQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZFtqXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2hlY2tlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gY2hlY2tlZFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ICYmICF0LmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVhZF92YXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZiA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbDEgPSBhLmxlbigpLCBsMiA9IGIubGVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmx2ID0gYi50ZXJtc1tsZWFkX3Zhcl0sIGFsdiA9IGEudGVybXNbbGVhZF92YXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobDIgPiBsMSAmJiBibHYuZ3JlYXRlclRoYW4oYWx2KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbDIgLSBsMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBibHYuc3VidHJhY3QoYWx2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBiZXR0ZXIgbGVhZF92YXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVhZF92YXIgPSB0cnlfYmV0dGVyX2xlYWRfdmFyKHMxLCBzMiwgbGVhZF92YXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Jlb3JkZXIgYm90aCBhY2NvcmRpbmcgdG8gdGhlIG1heCBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzMS5zb3J0KHNmKTsgLy9zb3J0IHRoZW0gYm90aCBhY2NvcmRpbmcgdG8gdGhlIGxlYWRpbmcgdmFyaWFibGUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgczIuc29ydChzZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RyeSB0byBhZGp1c3QgaWYgZGVuIGlzIGxhcmdlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmR0ID0gczJbMF0sIGZudCA9IHMxWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbiA9IG5ldyBNVlRlcm0obmV3IEZyYWMoMSksIFtdLCBmbnQubWFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmR0LnN1bS5ncmVhdGVyVGhhbihmbnQuc3VtKSAmJiBmbnQubGVuKCkgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZm50LnRlcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBmZHQudGVybXNbaV0uc3VidHJhY3QoZm50LnRlcm1zW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighZC5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5kID0gZC5hZGQobmV3IEZyYWMoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW4udGVybXNbaV0gPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgczEubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxW2pdLnRlcm1zW2ldID0gczFbal0udGVybXNbaV0uYWRkKG5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbi50ZXJtc1tpXSA9IG5ldyBGcmFjKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGl2aWRlbmRfbGFyZ2VyID0gaXNfbGFyZ2VyKHMxWzBdLCBzMlswXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZXR5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IDIwMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGRpdmlkZW5kX2xhcmdlciAmJiBjYW5fZGl2aWRlKHMxLCBzMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNhZmV0eSsrID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5JbmZpbml0ZUxvb3BFcnJvcignVW5hYmxlIHRvIGNvbXB1dGUhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBzMVswXS5kaXZpZGUoczJbMF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RpZW50LnB1c2gocSk7IC8vYWRkIHdoYXQncyBkaXZpZGVkIHRvIHRoZSBxdW90aWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczEuc2hpZnQoKTsvL3RoZSBmaXJzdCBvbmUgaXMgZ3VhcmFudGVlZCB0byBiZSBnb25lIHNvIHJlbW92ZSBmcm9tIGRpdmlkZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgczIubGVuZ3RoOyBpKyspIHsgLy9sb29wIHRocm91Z2ggdGhlIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBzMltpXS5tdWx0aXBseShxKS5nZW5lcmF0ZUltYWdlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsMiA9IHMxLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlJ3JlIHN1YnRyYWN0aW5nIGZyb20gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGwyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuY29lZmYgPSB0LmNvZWZmLm5lZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMS5wdXNoKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMS5zb3J0KHNmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBsMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXIgPSBzMVtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3VyLmdldEltZygpID09PSB0LmdldEltZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIuY29lZmYgPSBjdXIuY29lZmYuc3VidHJhY3QodC5jb2VmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjdXIuY29lZmYuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5yZW1vdmUoczEsIGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGotLTsgLy9hZGp1c3QgdGhlIGl0ZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihqID09PSBsMiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuY29lZmYgPSB0LmNvZWZmLm5lZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEucHVzaCh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxLnNvcnQoc2YpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2aWRlbmRfbGFyZ2VyID0gaXNfbGFyZ2VyKHMxWzBdLCBzMlswXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWRpdmlkZW5kX2xhcmdlciAmJiBzMS5sZW5ndGggPj0gczIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9PbmUgbW9yZSB0cnkgc2luY2UgdGhlcmUgbWlnaHQgYmUgYSB0ZXJtcyB0aGF0IGlzIGxhcmdlciB0aGFuIHRoZSBMVCBvZiB0aGUgZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBzMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZpZGVuZF9sYXJnZXIgPSBpc19sYXJnZXIoczFbaV0sIHMyWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGl2aWRlbmRfbGFyZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rha2UgaXQgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiBhbmQgbW92ZSBpdCB0byB0aGUgZnJvbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxLnVuc2hpZnQoY29yZS5VdGlscy5yZW1vdmUoczEsIGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBxdW90ID0gcmVjb252ZXJ0KHF1b3RpZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSByZWNvbnZlcnQoczEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZGVuICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW4gPSBkZW4udG9TeW1ib2woKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdCA9IF8uZGl2aWRlKHF1b3QsIGRlbi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gXy5kaXZpZGUocmVtLCBkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3B1dCBiYWNrIHRoZSBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgIGlmKHBhcnNlX2Z1bmNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVvdCA9IF8ucGFyc2UocXVvdC50ZXh0KCksIHN1YnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IF8ucGFyc2UocmVtLnRleHQoKSwgc3Vicyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtxdW90LCByZW1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluZTogZnVuY3Rpb24gKHYxLCB2MiwgeCkge1xyXG4gICAgICAgICAgICBpZihjb3JlLlV0aWxzLmlzQXJyYXkodjEpKVxyXG4gICAgICAgICAgICAgICAgdjEgPSBjb3JlLlV0aWxzLmNvbnZlcnRUb1ZlY3Rvcih2MSk7XHJcbiAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaXNBcnJheSh2MikpXHJcbiAgICAgICAgICAgICAgICB2MiA9IGNvcmUuVXRpbHMuY29udmVydFRvVmVjdG9yKHYyKTtcclxuICAgICAgICAgICAgeCA9IF8ucGFyc2UoeCB8fCAneCcpO1xyXG4gICAgICAgICAgICBpZighY29yZS5VdGlscy5pc1ZlY3Rvcih2MSkgfHwgIWNvcmUuVXRpbHMuaXNWZWN0b3IodjIpKVxyXG4gICAgICAgICAgICAgICAgXy5lcnJvcignTGluZSBleHBlY3RzIGEgdmVjdG9yISBSZWNlaXZlZCBcIicgKyB2MSArICdcIiAmIFwiJyArIHYyICsgJ1wiJyk7XHJcbiAgICAgICAgICAgIHZhciBkeCA9IF8uc3VidHJhY3QodjIuZSgxKS5jbG9uZSgpLCB2MS5lKDEpLmNsb25lKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gXy5zdWJ0cmFjdCh2Mi5lKDIpLmNsb25lKCksIHYxLmUoMikuY2xvbmUoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IF8uZGl2aWRlKGR5LCBkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IF8ubXVsdGlwbHkoeCwgbS5jbG9uZSgpKSxcclxuICAgICAgICAgICAgICAgICAgICBiID0gXy5tdWx0aXBseSh2MS5lKDEpLmNsb25lKCksIG0pO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5hZGQoXy5zdWJ0cmFjdChhLCBiKSwgdjEuZSgyKS5jbG9uZSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFBhcnRGcmFjOiB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVRlbXBsYXRlOiBmdW5jdGlvbiAoZGVuLCBkZW5vbV9mYWN0b3JzLCBmX2FycmF5LCB2KSB7XHJcbiAgICAgICAgICAgICAgICAvL2NsZWFuIHVwIHRoZSBkZW5vbWluYXRvciBmdW5jdGlvbiBieSBmYWN0b3JzIHNvIGl0IHJlZHVjZXMgbmljZWx5XHJcbiAgICAgICAgICAgICAgICBkZW4gPSBfXy5GYWN0b3IuZmFjdG9yKGRlbik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9jbGVhbiB1cCBmYWN0b3JzLiBUaGlzIGlzIHNvIGluZWZmaWNpZW50IGJ1dCBmYWN0b3JzIGFyZSB3cmFwcGVkIGluIHBhcmVucyBmb3Igc2FmZXR5XHJcbiAgICAgICAgICAgICAgICBkZW4uZWFjaChmdW5jdGlvbiAoeCwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gRk4gJiYgeC5mbmFtZSA9PT0gJycgJiYgeC5hcmdzWzBdLmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0geC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN5bWJvbHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sc1t5LnZhbHVlXSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW4gPSB4LmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9ycywgZmFjdG9yc192ZWMsIGYsIHAsIGRlZywgZGVncmVlcywgbTtcclxuICAgICAgICAgICAgICAgIGZhY3RvcnMgPSBkZW5vbV9mYWN0b3JzLmNvbGxlY3RGYWN0b3JzKCk7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3JzX3ZlYyA9IFtdOyAvL2EgdmVjdG9yIGZvciB0aGUgdGVtcGxhdGVcclxuICAgICAgICAgICAgICAgIGRlZ3JlZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIG0gPSBuZXcgU3ltYm9sKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmYWN0b3JzLmxlbmd0aDsgaSsrKSB7IC8vbG9vcCB0aHJvdWdoIHRoZSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IFN5bWJvbC51bndyYXBQQVJFTlMoZmFjdG9yc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBpbiBoZSBmb3IgUF5uIHdoZXJlIFAgaXMgcG9seW5vbWlhbCBhbmQgbiA9IGludGVnZXJcclxuICAgICAgICAgICAgICAgICAgICBpZihmYWN0b3IucG93ZXIuZ3JlYXRlclRoYW4oMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IE51bWJlcihmYWN0b3IucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gZmFjdG9yLmNsb25lKCkudG9MaW5lYXIoKTsgLy9yZW1vdmUgdGhlIHBvd2VyIHNvIHdlIGhhdmUgb25seSB0aGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVnID0gTnVtYmVyKF9fLmRlZ3JlZShmLCB2KSk7IC8vZ2V0IHRoZSBkZWdyZWUgb2YgZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2V4cGFuZCB0aGUgZmFjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBwOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZmFjdG9yID0gXy5wb3coZi5jbG9uZSgpLCBuZXcgU3ltYm9sKGogKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmX2FycmF5LnB1c2goZWZhY3Rvci5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gXy5kaXZpZGUoZGVuLmNsb25lKCksIGVmYWN0b3IuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWdyZWVzLnB1c2goZGVnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnNfdmVjLnB1c2goZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgUG9zc2libGUgYnVnLlxyXG4gICAgICAgICAgICAgICAgICAgICBSZW1vdmVkOiBjYXVzZXMgMS8oMjArMjQqeCs0KnheMikgdG8gcmVzdWx0IGluICgtMS82NCkqKDUreCleKC0xKSsoMS82NCkqKDEreCleKC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZhY3Rvci5pc0NvbnN0YW50KCdhbGwnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICBtID0gXy5tdWx0aXBseShtLCBmYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBkZWdyZWUgb2YgdGhlIGZhY3RvciBzbyB3ZSB0YWNrIGl0IG9uIHRvdCBoZSBmYWN0b3IuIFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGFuIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYnV0IGZvciBub3cgd2Ugbm90ZSBpdCBvbiB0aGUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZyA9IE51bWJlcihfXy5kZWdyZWUoZmFjdG9yLCB2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZfYXJyYXkucHVzaChmYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF8uZGl2aWRlKGRlbi5jbG9uZSgpLCBmYWN0b3IuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBfLmV4cGFuZChTeW1ib2wudW53cmFwUEFSRU5TKGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVncmVlcy5wdXNoKGRlZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnNfdmVjLnB1c2goZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9wdXQgYmFjayB0aGUgY29uc3RhbnRcclxuICAgICAgICAgICAgICAgIGZfYXJyYXkgPSBmX2FycmF5Lm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHgsIG0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZl9hcnJheSwgZmFjdG9yc192ZWMsIGRlZ3JlZXNdO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXJ0ZnJhYzogZnVuY3Rpb24gKHN5bWJvbCwgdiwgYXNfYXJyYXkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdmFycyA9IHZhcmlhYmxlcyhzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIHYgPSB2IHx8IF8ucGFyc2UodmFyc1swXSk7IC8vbWFrZSB3cnQgb3B0aW9uYWwgYW5kIGFzc3VtZSBmaXJzdCB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtLCBkZW4sIGZhY3RvcnMsIHRmYWN0b3JzLCBvZmFjdG9ycywgbnRlcm1zLCBkZWdyZWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHRlcm1zLCBtYXgsIE0sIGMsIHBvd2VycywgZGl2LCByLCBmYWN0b3JzX3ZlYywga3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZSwgdGZhY3RvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gXy5leHBhbmQoc3ltYm9sLmdldE51bSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBkZW4gPSBfLmV4cGFuZChzeW1ib2wuZ2V0RGVub20oKS50b1VuaXRNdWx0aXBsaWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbW92ZSB0aGUgZW50aXJlIG11bHRpcGllciB0byB0aGUgbnVtZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtLm11bHRpcGxpZXIgPSBzeW1ib2wubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICAvL3dlIG9ubHkgaGF2ZSBhIG1lYW5pbmdmdWwgY2hhbmdlIGlmIG4gZmFjdG9ycyA+IDEuIFRoaXMgbWVhbnMgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIHJldHVybmVkIGdyb3VwIHdpbGwgYmUgYSBDQlxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29sbGVjdCB0aGUgdGVybXMgd3J0IHRoZSB4XHJcbiAgICAgICAgICAgICAgICAgICAgbnRlcm1zID0gbnVtLmdyb3VwVGVybXModik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9kaXZpZGUgb3V0IHdob2xlcyBpZiB0b3AgaXMgbGFyZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoTnVtYmVyKF9fLmRlZ3JlZShudW0sIHYpKSA+PSBOdW1iZXIoX18uZGVncmVlKGRlbiwgdikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdiA9IF9fLmRpdihudW0uY2xvbmUoKSwgXy5leHBhbmQoZGVuLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IGRpdlswXTsgLy9yZW1vdmUgdGhlIHdob2xlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSBkaXZbMV07IC8vd29yayB3aXRoIHRoZSByZW1haW5kZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnRlcm1zID0gbnVtLmdyb3VwVGVybXModik7IC8vcmVjYWxjdWxhdGUgdGhlIG50ZXJtc1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihOdW1iZXIoX18uZGVncmVlKGRlbiwgdikpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gXy5kaXZpZGUobnVtLCBkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhc19hcnJheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbciwgcV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChyLCBxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBmYWN0b3IgdGhlIGRlbm9taW5hdG9yLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHN0cmVuZ3RoIG9mIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvL2FsZ29yaXRobSBkZXBlbmRzIG9uIGhvdyB3ZWxsIHdlIGNhbiBmYWN0b3IgdGhlIGRlbm9taW5hdG9yLiBcclxuICAgICAgICAgICAgICAgICAgICBvZmFjdG9ycyA9IF9fLkZhY3Rvci5mYWN0b3IoZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSB0aGUgdGVtcGxhdGUuIFRoaXMgbWV0aG9kIHdpbGwgY3JlYXRlIHRoZSB0ZW1wbGF0ZSBmb3Igc29sdmluZyBcclxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBwYXJ0aWFsIGZyYWN0aW9ucy4gU28gZ2l2ZW4geC8oeC0xKV4yIHRoZSB0ZW1wbGF0ZSBjcmVhdGVzIEEvKHgtMSkrQi8oeC0xKV4yXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBfXy5QYXJ0RnJhYy5jcmVhdGVUZW1wbGF0ZShkZW4uY2xvbmUoKSwgb2ZhY3RvcnMsIFtdLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICB0ZmFjdG9ycyA9IHRlbXBsYXRlWzBdOyAvL2dyYWIgdGhlIGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3JzX3ZlYyA9IHRlbXBsYXRlWzFdOyAvL2dyYWIgdGhlIGZhY3RvciB2ZWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgZGVncmVlcyA9IHRlbXBsYXRlWzJdOyAvL2dyYWIgdGhlIGRlZ3JlZXNcclxuICAgICAgICAgICAgICAgICAgICAvL21ha2Ugbm90ZSBvZiB0aGUgcG93ZXJzIG9mIGVhY2ggdGVybVxyXG4gICAgICAgICAgICAgICAgICAgIHBvd2VycyA9IFtudGVybXMubGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSB0aGUgZHRlcm1zIHZlY3RvclxyXG4gICAgICAgICAgICAgICAgICAgIGR0ZXJtcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBrcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IsIGRlZztcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3JzX3ZlYy5tYXAoZnVuY3Rpb24gKHgsIGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IgPSB0ZmFjdG9yc1tpZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWcgPSBkZWdyZWVzW2lkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkZWc7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5wdXNoKGZhY3Rvci5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gU3ltYm9sLmNyZWF0ZSh2LCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXy5leHBhbmQoXy5tdWx0aXBseSh4LCBrLmNsb25lKCkpKS5ncm91cFRlcm1zKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIGEgbm90ZSBvZiB0aGUgcG93ZXIgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3dlcnMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0ZXJtcy5wdXNoKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga3MucHVzaChrLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIG1heCBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNvcmUuVXRpbHMuYXJyYXlNYXgocG93ZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9maWxsIHRoZSBob2xlcyBhbmQgY3JlYXRlIGEgbWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBjb3JlLk1hdHJpeChjb3JlLlV0aWxzLmZpbGxIb2xlcyhudGVybXMsIG1heCkpLnRyYW5zcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZm9yIGVhY2ggb2YgdGhlIGZhY3RvcnMgd2UgZG8gdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgICAgICBNID0gbmV3IGNvcmUuTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGR0ZXJtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNLmVsZW1lbnRzLnB1c2goY29yZS5VdGlscy5maWxsSG9sZXMoZHRlcm1zW2ldLCBtYXgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc29sdmUgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbHMgPSBfLm11bHRpcGx5KE0udHJhbnNwb3NlKCkuaW52ZXJ0KCksIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIHJlc3VsdHMgYXJlIGJhY2t3YXJkcyB0byByZXZlcnNlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgLy9wYXJ0aWFscy5lbGVtZW50cy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IGl0IGFsbCBiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IGFzX2FycmF5ID8gW3JdIDogcjtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFscy5lYWNoKGZ1bmN0aW9uIChlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtID0gXy5tdWx0aXBseShrc1tpXSwgXy5kaXZpZGUoZSwgZmFjdG9yc1tpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhc19hcnJheSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbC5wdXNoKHRlcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIHRlcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RvbmVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdHJ5IHRvIGdyb3VwIHN5bWJvbHNcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ncm91cCBkZW5vbWluYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvcnMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0geC5nZXREZW5vbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0geC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGRlbm9taW5hdG9yc1tkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5vbWluYXRvcnNbZF0gPSBlID8gXy5hZGQoZSwgbikgOiBuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBkZW5vbWluYXRvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5hZGQodCwgXy5kaXZpZGUoZGVub21pbmF0b3JzW3hdLCBfLnBhcnNlKHgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaChlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVncmVlOiBmdW5jdGlvbiAoc3ltYm9sLCB2LCBvKSB7XHJcbiAgICAgICAgICAgIG8gPSBvIHx8IHtcclxuICAgICAgICAgICAgICAgIG5kOiBbXSwgLy9udW1lcmljXHJcbiAgICAgICAgICAgICAgICBzZDogW10sIC8vc3ltYm9saWNcclxuICAgICAgICAgICAgICAgIGRlcHRoOiAwIC8vY2FsbCBkZXB0aFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYoIXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YXJzID0gdmFyaWFibGVzKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAvL1RoZSB1c2VyIG11c3Qgc3BlY2lmeSB0aGUgdmFyaWFibGUgZm9yIG11bHRpdmFyaWF0ZVxyXG4gICAgICAgICAgICAgICAgaWYodmFycy5sZW5ndGggPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSB0aGUgdmFyaWFibGUgZm9yIG11bHRpdmFyaWF0ZSBwb2x5bm9taWFscyEnKTtcclxuICAgICAgICAgICAgICAgIC8vaWYgaXQncyBlbXB0eSB0aGVuIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICBpZih2YXJzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgIC8vYXNzdW1lIHRoZSB2YXJpYWJsZSBmb3IgdW5pdmFyaWF0ZVxyXG4gICAgICAgICAgICAgICAgdiA9IF8ucGFyc2UodmFyc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vc3RvcmUgdGhlIGdyb3VwXHJcbiAgICAgICAgICAgIHZhciBnID0gc3ltYm9sLmdyb3VwO1xyXG4gICAgICAgICAgICAvL3dlJ3JlIGdvaW5nIHRvIHRydXN0IHRoZSB1c2VyIGFuZCBhc3N1bWUgbm8gRVguIENhbGxpbmcgaXNQb2x5IFxyXG4gICAgICAgICAgICAvL3dvdWxkIGVsaW1pbmF0ZSB0aGlzIGJ1dCBubyBzZW5zZSBpbiBjaGVja2luZyB0d2ljZS4gXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5kaXN0cmlidXRlRXhwb25lbnQoKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgby5kZXB0aCsrOyAvL21hcmsgYSBkZXB0aCBpbmNyZWFzZVxyXG4gICAgICAgICAgICAgICAgICAgIF9fLmRlZ3JlZSh4LCB2LCBvKTtcclxuICAgICAgICAgICAgICAgICAgICBvLmRlcHRoLS07IC8vd2UncmUgYmFja1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uZGVwdGgrKztcclxuICAgICAgICAgICAgICAgICAgICBfXy5kZWdyZWUoeCwgdiwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgby5kZXB0aCsrO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihnID09PSBFWCAmJiBzeW1ib2wudmFsdWUgPT09IHYudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG8uc2QucHVzaChzeW1ib2wucG93ZXIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihnID09PSBTICYmIHN5bWJvbC52YWx1ZSA9PT0gdi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgby5uZC5wdXNoKF8ucGFyc2Uoc3ltYm9sLnBvd2VyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgby5uZC5wdXNoKG5ldyBTeW1ib2woMCkpO1xyXG5cclxuICAgICAgICAgICAgLy9nZXQgdGhlIG1heCBvdXQgb2YgdGhlIGFycmF5XHJcbiAgICAgICAgICAgIHZhciBkZWcgPSBvLm5kLmxlbmd0aCA+IDAgPyBjb3JlLlV0aWxzLmFycmF5TWF4KG8ubmQpIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgaWYoby5kZXB0aCA9PT0gMCAmJiBvLnNkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmKGRlZyAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIG8uc2QudW5zaGlmdChkZWcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ21heCcsIG8uc2QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFjb3JlLlV0aWxzLmlzU3ltYm9sKGRlZykpXHJcbiAgICAgICAgICAgICAgICBkZWcgPSBfLnBhcnNlKGRlZyk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIHRoZSBkZWdyZWVcclxuICAgICAgICAgICAgcmV0dXJuIGRlZztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF0dGVtcHRzIHRvIGNvbXBsZXRlIHRoZSBzcXVhcmUgb2YgYSBwb2x5bm9taWFsXHJcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IHZcclxuICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IHJhd1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fFN5bWJvbFtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNxQ29tcGxldGU6IGZ1bmN0aW9uIChzeW1ib2wsIHYsIHJhdykge1xyXG4gICAgICAgICAgICBpZighY29yZS5VdGlscy5pc1N5bWJvbCh2KSlcclxuICAgICAgICAgICAgICAgIHYgPSBfLnBhcnNlKHYpO1xyXG4gICAgICAgICAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChtc2cpIHtcclxuICAgICAgICAgICAgICAgIG1zZyA9IG1zZyB8fCAnU3RvcHBpbmcnO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5WYWx1ZUxpbWl0RXhjZWVkZWRFcnJvcihtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvL2lmIG5vdCBDUCB0aGVuIG5vdGhpbmcgdG8gZG9cclxuICAgICAgICAgICAgaWYoIXN5bWJvbC5pc1BvbHkodHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICBzdG9wKCdNdXN0IGJlIGEgcG9seW5vbWlhbCEnKTtcclxuXHJcbiAgICAgICAgICAgIC8vZGVjbGFyZSB2YXJzXHJcbiAgICAgICAgICAgIHZhciBkZWcsIGEsIGIsIGMsIGQsIGUsIGNvZWZmcywgc2lnbiwgYnIsIHN5bSwgc3FydF9hO1xyXG5cclxuICAgICAgICAgICAgYnIgPSBjb3JlLlV0aWxzLmluQnJhY2tldHM7XHJcbiAgICAgICAgICAgIC8vbWFrZSBhIGNvcHlcclxuICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGRlZyA9IGNvcmUuQWxnZWJyYS5kZWdyZWUoc3ltYm9sLCB2KTsgLy9nZXQgdGhlIGRlZ3JlZSBvZiBwb2x5bm9taWFsXHJcbiAgICAgICAgICAgIC8vbXVzdCBiZSBpbiBmb3JtIGF4XjIgKy8tIGJ4ICsvLSBjXHJcbiAgICAgICAgICAgIGlmKCFkZWcuZXF1YWxzKDIpKVxyXG4gICAgICAgICAgICAgICAgc3RvcCgnQ2Fubm90IGNvbXBsZXRlIHNxdWFyZSBmb3IgZGVncmVlICcgKyBkZWcpO1xyXG4gICAgICAgICAgICAvL2dldCB0aGUgY29lZmZzXHJcbiAgICAgICAgICAgIGNvZWZmcyA9IGNvcmUuQWxnZWJyYS5jb2VmZnMoc3ltYm9sLCB2KTtcclxuICAgICAgICAgICAgYSA9IGNvZWZmc1syXTtcclxuICAgICAgICAgICAgLy9zdG9yZSB0aGUgc2lnblxyXG4gICAgICAgICAgICBzaWduID0gY29lZmZzWzFdLnNpZ24oKTtcclxuICAgICAgICAgICAgLy9kaXZpZGUgdGhlIGxpbmVhciB0ZXJtIGJ5IHR3byBhbmQgc3F1YXJlIGl0XHJcbiAgICAgICAgICAgIGIgPSBfLmRpdmlkZShjb2VmZnNbMV0sIG5ldyBTeW1ib2woMikpO1xyXG4gICAgICAgICAgICAvL2FkZCB0aGUgZGlmZmVyZW5jZSB0byB0aGUgY29uc3RhbnRcclxuICAgICAgICAgICAgYyA9IF8ucG93KGIuY2xvbmUoKSwgbmV3IFN5bWJvbCgyKSk7XHJcbiAgICAgICAgICAgIGlmKHJhdylcclxuICAgICAgICAgICAgICAgIHJldHVybiBbYSwgYiwgZF07XHJcbiAgICAgICAgICAgIHNxcnRfYSA9IG1hdGguc3FydChhKTtcclxuICAgICAgICAgICAgZSA9IF8uZGl2aWRlKG1hdGguc3FydChjKSwgc3FydF9hLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAvL2NhbGN1bGF0ZSBkIHdoaWNoIGlzIHRoZSBjb25zdGFudFxyXG4gICAgICAgICAgICBkID0gXy5zdWJ0cmFjdChjb2VmZnNbMF0sIF8ucG93KGUuY2xvbmUoKSwgbmV3IFN5bWJvbCgyKSkpO1xyXG4gICAgICAgICAgICAvL2NvbXB1dGUgdGhlIHNxdWFyZSBwYXJ0XHJcbiAgICAgICAgICAgIHN5bSA9IF8ucGFyc2UoYnIoc3FydF9hLmNsb25lKCkgKyAnKicgKyB2ICsgKHNpZ24gPCAwID8gJy0nIDogJysnKSArIGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGE6IHN5bSxcclxuICAgICAgICAgICAgICAgIGM6IGQsXHJcbiAgICAgICAgICAgICAgICBmOiBfLmFkZChfLnBvdyhzeW0uY2xvbmUoKSwgbmV3IFN5bWJvbCgyKSksIGQuY2xvbmUoKSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFNpbXBsaWZ5OiB7XHJcbiAgICAgICAgICAgIHN0cmlwOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gXy5wYXJzZShzeW1ib2wucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2MsIHAsIHN5bWJvbF07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVuc3RyaXA6IGZ1bmN0aW9uIChjcCwgc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNwWzBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBjcFsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KGMsIF8ucG93KHN5bWJvbCwgcCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wbGV4U2ltcDogZnVuY3Rpb24gKG51bSwgZGVuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWMsIGJkLCBiYywgYWQsIGNkLCByMSwgcjIsIGkxLCBpMjtcclxuICAgICAgICAgICAgICAgIHIxID0gbnVtLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICBpMSA9IG51bS5pbWFncGFydCgpO1xyXG4gICAgICAgICAgICAgICAgcjIgPSBkZW4ucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgICAgIGkyID0gZGVuLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAvL2FwcGx5IGNvbXBsZXggYXJpdGhtYXRpYyBydWxlXHJcbiAgICAgICAgICAgICAgICBhYyA9IF8ubXVsdGlwbHkocjEuY2xvbmUoKSwgcjIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICBiZCA9IF8ubXVsdGlwbHkoaTEuY2xvbmUoKSwgaTIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICBiYyA9IF8ubXVsdGlwbHkocjIuY2xvbmUoKSwgaTEpO1xyXG4gICAgICAgICAgICAgICAgYWQgPSBfLm11bHRpcGx5KHIxLCBpMi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIGNkID0gXy5hZGQoXy5wb3cocjIsIG5ldyBTeW1ib2woMikpLCBfLnBvdyhpMiwgbmV3IFN5bWJvbCgyKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShfLmFkZChfLmFkZChhYywgYmQpLCBfLm11bHRpcGx5KF8uc3VidHJhY3QoYmMsIGFkKSwgU3ltYm9sLmltYWdpbmFyeSgpKSksIGNkKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHJpZ1NpbXA6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5jb250YWluc0Z1bmN0aW9uKFsnY29zJywgJ3NpbicsICd0YW4nXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBwb3dlciBhbmQgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1fYXJyYXkgPSBfXy5TaW1wbGlmeS5zdHJpcChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bV9hcnJheS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZWZhdWx0IHJldHVybiB2YWx1ZSBpcyB0aGUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IHN5bWJvbC5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Jld3JpdGUgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jld3JpdGUgdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSBfXy5TaW1wbGlmeS50cmlnU2ltcCh4LmZuVHJhbnNmb3JtKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltID0gXy5hZGQoc3ltLCB0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wdXQgYmFjayB0aGUgcG93ZXIgYW5kIG11bHRpcGxpZXIgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBvdyhfLm11bHRpcGx5KG5ldyBTeW1ib2woc3ltYm9sLm11bHRpcGxpZXIpLCBzeW0pLCBuZXcgU3ltYm9sKHN5bWJvbC5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gc3ltYm9sLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHN5bWJvbC5nZXREZW5vbSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90cnkgZm9yIHRhbmdlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobi5mbmFtZSA9PT0gJ3NpbicgJiYgZC5mbmFtZSA9PT0gJ2NvcycgJiYgbi5hcmdzWzBdLmVxdWFscyhkLmFyZ3NbMF0pICYmIG4ucG93ZXIuZXF1YWxzKGQucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGNvcmUuVXRpbHMuZm9ybWF0KCcoezB9KSooezF9KSp0YW4oezJ9KV4oezN9KScsIGQubXVsdGlwbGllciwgbi5tdWx0aXBsaWVyLCBuLmFyZ3NbMF0sIG4ucG93ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXR2YWwuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZm5hbWUgPT09ICd0YW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBfLnBhcnNlKGNvcmUuVXRpbHMuZm9ybWF0KCcoezB9KSpzaW4oezF9KV4oezJ9KS9jb3MoezF9KV4oezJ9KScsIHgubXVsdGlwbGllciwgX18uU2ltcGxpZnkuc2ltcGxpZnkoeC5hcmdzWzBdKSwgeC5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5tdWx0aXBseSh0LCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLlNpbXBsaWZ5LnVuc3RyaXAoc3ltX2FycmF5LCByZXR2YWwpLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHJldHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmcmFjU2ltcDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgLy90cnkgYSBxdWljayBzaW1wbGlmeSBvZiBpbWFnaW5hcnkgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbiA9IHN5bWJvbC5nZXREZW5vbSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHN5bWJvbC5nZXROdW0oKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihudW0uaXNJbWFnaW5hcnkoKSAmJiBkZW4uaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5TaW1wbGlmeS5jb21wbGV4U2ltcChudW0sIGRlbik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wucG93ZXIgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IHN5bWJvbC5jb2xsZWN0U3ltYm9scygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vYXNzdW1wdGlvbiAxLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2luY2UgaXQncyBhIGNvbXBvc2l0ZSwgaXQgaGFzIGEgbGVuZ3RoIG9mIGF0IGxlYXN0IDFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsLCBhLCBiLCBkMSwgZDIsIG4xLCBuMiwgeCwgeSwgYywgZGVuLCBudW07XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IHN5bWJvbHMucG9wKCk7IC8vZ3JhYiB0aGUgZmlyc3Qgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggZWFjaCB0ZXJtIGFuZCBtYWtlIGRlbm9taW5hdG9yIGNvbW1vblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBzeW1ib2xzLnBvcCgpOyAvL2dyYWIgdGhlIHNlY29uZCBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDEgPSBfLnBhcnNlKGEuZ2V0RGVub20oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gXy5wYXJzZShiLmdldERlbm9tKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuMSA9IGEuZ2V0TnVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gYi5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IF8ubXVsdGlwbHkoZDEuY2xvbmUoKSwgZDIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBfLm11bHRpcGx5KG4xLCBkMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBfLm11bHRpcGx5KG4yLCBkMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfLmRpdmlkZShfLmFkZCh4LCB5KSwgYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbiA9IF8uZXhwYW5kKGEuZ2V0RGVub20oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gXy5leHBhbmQoYS5nZXROdW0oKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2ltcGxpZnkgaW1hZ2luYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobnVtLmlzSW1hZ2luYXJ5KCkgJiYgZGVuLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uU2ltcGxpZnkuY29tcGxleFNpbXAobnVtLCBkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUobnVtLCBkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy93ZSd2ZSBhbHJlYWR5IGhpdCB0aGUgc2ltcGxlc3QgZm9ybSBzbyByZXR1cm4gdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHJldHZhbC5lcXVhbHMoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2Ugc2ltcGxpZnkgaXQgc29tZSBtb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLlNpbXBsaWZ5LnNpbXBsaWZ5KHJldHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByYXRTaW1wOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbiA9IHN5bWJvbC5nZXREZW5vbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSBzeW1ib2wuZ2V0TnVtKCkuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF9fLlNpbXBsaWZ5LmZyYWNTaW1wKGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBfXy5TaW1wbGlmeS5mcmFjU2ltcChudW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZGl2aWRlKG4sIGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3FydFNpbXA6IGZ1bmN0aW9uIChzeW1ib2wsIHN5bV9hcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc1NRUlQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JlZCA9IF9fLkZhY3Rvci5mYWN0b3Ioc3ltYm9sLmFyZ3NbMF0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBfLnBhcnNlKGZhY3RvcmVkLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gbS5zaWduKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBfLnNxcnQobS5hYnMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNJbnQocmV0dmFsKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmFjdG9yZWQuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtID0gbmV3IFN5bWJvbCgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JlZC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJpYWwgPSBfLnNxcnQoeC5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGJhY2sgc3FydCBpZiBpdCdzIGFuIGludGVnZXIgb3RoZXJ3aXNlIGp1c3QgcHV0IGJhY2sgdGhlIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc0ludCh0cmlhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCB0cmlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBfLm11bHRpcGx5KHJlbSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IF8ubXVsdGlwbHkocmVtLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8ubXVsdGlwbHkocmVtLCBfLnBhcnNlKHNpZ24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IF8uc3FydCh0LmNsb25lKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBpZiBpdCdzIGltYWdpbmFyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXJnLmlzSW1hZ2luYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gXy5zcXJ0KF8uZXhwYW5kKHQuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IF8uc3FydChmYWN0b3JlZC5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkocmV0dmFsLCBhcmcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfXy5TaW1wbGlmeS5zcXJ0U2ltcCh4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGJhY2sgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgXy5wYXJzZShzeW1ib2wubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpbXAgPSBfXy5TaW1wbGlmeS5zcXJ0U2ltcCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIHNpbXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQdXQgYmFjayB0aGUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBvdyhyZXR2YWwsIF8ucGFyc2Uoc3ltYm9sLnBvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbCA/IHJldHZhbCA6IF8ucGFyc2Uoc3ltYm9sKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVudXNlZC4gVGhlIGdvYWwgaXMgdG8gc3Vic3RpdHV0ZSBvdXQgcGF0dGVybnMgYnV0IGl0IGN1cnJlbnRseSBkb2Vzbid0IHdvcmsuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBzeW1ib2wgYW5kIHRoZSBtYXRjaGVkIHBhdHRlcm5zXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwYXR0ZXJuU3ViOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybnMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzX0NQID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih4LnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gaGFzX0NQKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3QgPSBmdW5jdGlvbiAoc3ltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbG9vcCB0aHJvdWdoIGVhY2ggc3ltYm9sIGxvb2tpbmcgZm9yIGFueXRoaW5nIGluIHRoZSBzaW1wbGVzdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcm0gb2YgYXgrYnl6Ky4uLlxyXG4gICAgICAgICAgICAgICAgICAgIHN5bS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0ZW1zIG9mIGdyb3VwIE4sUCxTLCBuZWVkIHRvIGFwcGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF4LnN5bWJvbHMgJiYgeC5ncm91cCAhPT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0IGhhcyBhbnkgc3ltYm9scyBvZiBncm91cCBDUFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBhdHRlcm5zIGluIHRoYXQgc3ltYm9sIGluc3RlYWQgaWYgaXQgaGFzIGFueXRoaW5nIG9mIGdyb3VwIENQXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGhhc19DUCh4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFwYXR0ZXJuc1t4LnZhbHVlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gY29yZS5VdGlscy5nZXRVKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgdSB2YWx1ZSBhbmQgbWFyayBpdCBmb3Igc3Vic2l0dXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuc1t4LnZhbHVlXSA9IHU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLnN1Yih4LnZhbHVlLCB1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb2xsZWN0IGEgbGlzdCBvZiBwYXR0ZXJuc1xyXG4gICAgICAgICAgICAgICAgY29sbGVjdChzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbc3ltYm9sLCBwYXR0ZXJuc107XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNpbXBsaWZ5OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgbXVsdGlwbGllciB0byBtYWtlIGNhbGN1bGF0aW9uIGVhc2llcjtcclxuICAgICAgICAgICAgICAgIHZhciBzeW1fYXJyYXkgPSBfXy5TaW1wbGlmeS5zdHJpcChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltX2FycmF5LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgZ2NkIGZyb20gZGVub21pbmF0b3JcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF9fLlNpbXBsaWZ5LmZyYWNTaW1wKHN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ub3RoaW5nIG1vcmUgdG8gZG9cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkgfHwgc3ltYm9sLmdyb3VwID09PSBjb3JlLmdyb3Vwcy5TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltX2FycmF5LnB1c2goc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gX18uU2ltcGxpZnkudW5zdHJpcChzeW1fYXJyYXksIHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3ZhciBwYXR0ZXJucztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2ltcGxpZmllZCA9IHN5bWJvbC5jbG9uZSgpOyAvL21ha2UgYSBjb3B5XHJcblxyXG4gICAgICAgICAgICAgICAgLy9bc2ltcGxpZmllZCwgcGF0dGVybnNdID0gX18uU2ltcGxpZnkucGF0dGVyblN1YihzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNpbXBsaWZ5IHNxcnQgd2l0aGluIHRoZSBzeW1ib2xcclxuLy8gICAgICAgICAgICAgICAgc2ltcGxpZmllZCA9IF9fLlNpbXBsaWZ5LnNxcnRTaW1wKHNpbXBsaWZpZWQsIHN5bV9hcnJheSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRyaWcgc2ltcGxpZmljYXRvbnMgZS5nLiBjb3MoeCleMitzaW4oeCleMlxyXG4gICAgICAgICAgICAgICAgc2ltcGxpZmllZCA9IF9fLlNpbXBsaWZ5LnRyaWdTaW1wKHNpbXBsaWZpZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNpbXBsaWZ5IGNvbW1vbiBkZW5vbWluYXRvcnNcclxuICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPSBfXy5TaW1wbGlmeS5yYXRTaW1wKHNpbXBsaWZpZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IGdvIGZvciB0aGUgXCJjaGVhcGVzdFwiIHNpbXBsaWZpY2F0aW9uIHdoaWNoIG1heSBlbGltaW5hdGUgXHJcbiAgICAgICAgICAgICAgICAvLyB5b3VyIHByb2JsZW1zIHJpZ2h0IGF3YXkuIGZhY3RvciAtPiBldmFsdWF0ZS4gUmVtZW1iZXJcclxuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhlcmUncyBubyBuZWVkIHRvIGV4cGFuZCBzaW5jZSBmYWN0b3IgYWxyZWFkeSBkb2VzIHRoYXRcclxuXHJcbiAgICAgICAgICAgICAgICBzaW1wbGlmaWVkID0gX18uRmFjdG9yLmZhY3RvcihzaW1wbGlmaWVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0lmIHRoZSBzaW1wbGZpZWQgaXMgYSBzdW0gdGhlbiB3ZSBjYW4gbWFrZSBhIGZldyBtb3JlIHNpbXBsaWZpY2F0aW9uc1xyXG4gICAgICAgICAgICAgICAgLy9lLmcuIHNpbXBsaWZ5KDEvKHgtMSkrMS8oMS14KSkgYXMgcGVyIGlzc3VlICM0MzFcclxuICAgICAgICAgICAgICAgIGlmKHNpbXBsaWZpZWQuZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLkNQICYmIHNpbXBsaWZpZWQuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gc2ltcGxpZmllZC5tdWx0aXBsaWVyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxpZmllZC50b1VuaXRNdWx0aXBsaWVyKCk7IC8vc3RyaXAgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhlIHN1bSBvZiBzaW1wbGlmaWNhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBzaW1wbGlmaWVkLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfXy5TaW1wbGlmeS5zaW1wbGlmeSh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IF8uYWRkKHIsIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPSByO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICByLm11bHRpcGxpZXIgPSByLm11bHRpcGxpZXIubXVsdGlwbHkobSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9wbGFjZSBiYWNrIG11bHRpcGxpZXIgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IF9fLlNpbXBsaWZ5LnVuc3RyaXAoc3ltX2FycmF5LCBzaW1wbGlmaWVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCYWNrIHN1YnN0aXR1dGVcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHBhdHRlcm5zKSB7XHJcbiAgICAgICAgICAgICAgICAgcmV0dmFsID0gcmV0dmFsLnN1YihwYXR0ZXJuc1t4XSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIENsYXNzZXM6IHtcclxuICAgICAgICAgICAgUG9seW5vbWlhbDogUG9seW5vbWlhbCxcclxuICAgICAgICAgICAgRmFjdG9yczogRmFjdG9ycyxcclxuICAgICAgICAgICAgTVZUZXJtOiBNVlRlcm1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEFkZCBhIGxpbmsgdG8gc2ltcGxpZnlcclxuICAgIGNvcmUuRXhwcmVzc2lvbi5wcm90b3R5cGUuc2ltcGxpZnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fLlNpbXBsaWZ5LnNpbXBsaWZ5KHRoaXMuc3ltYm9sKTtcclxuICAgIH07XHJcblxyXG4gICAgbmVyZGFtZXIudXNlQWxnZWJyYURpdiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGl2aWRlID0gX18uZGl2aWRlRm4gPSBfLmRpdmlkZTtcclxuICAgICAgICB2YXIgY2FsbHMgPSAwOyAvL2tlZXAgdHJhY2sgb2YgaG93IG1hbnkgY2FsbHMgd2VyZSBtYWRlXHJcbiAgICAgICAgXy5kaXZpZGUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBjYWxscysrO1xyXG4gICAgICAgICAgICB2YXIgYW5zO1xyXG4gICAgICAgICAgICBpZihjYWxscyA9PT0gMSkgLy9jaGVjayBpZiB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLiBJZiBpdCBpcyB1c2UgYWxnZWJyYSBkaXZpZGVcclxuICAgICAgICAgICAgICAgIGFucyA9IGNvcmUuQWxnZWJyYS5kaXZpZGUoYSwgYik7XHJcbiAgICAgICAgICAgIGVsc2UgLy9vdGhlcndpc2UgdXNlIHBhcnNlciBkaXZpZGVcclxuICAgICAgICAgICAgICAgIGFucyA9IGRpdmlkZShhLCBiKTtcclxuICAgICAgICAgICAgY2FsbHMgPSAwOyAvL3Jlc2V0IHRoZSBudW1iZXIgb2YgY2FsbHMgYmFjayB0byBub25lXHJcbiAgICAgICAgICAgIHJldHVybiBhbnM7XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgbmVyZGFtZXIudXNlUGFyc2VyRGl2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKF9fLmRpdmlkZUZuKVxyXG4gICAgICAgICAgICBfLmRpdmlkZSA9IF9fLmRpdmlkZUZuO1xyXG4gICAgICAgIGRlbGV0ZSBfXy5kaXZpZGVGbjtcclxuICAgIH07XHJcblxyXG4gICAgbmVyZGFtZXIucmVnaXN0ZXIoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2ZhY3RvcicsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDEsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uRmFjdG9yLmZhY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnc2ltcGxpZnknLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAxLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlNpbXBsaWZ5LnNpbXBsaWZ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdnY2QnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiBbMSwgXSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5nY2Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2xjbScsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IFsxLCBdLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLmxjbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAncm9vdHMnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAtMSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5yb290cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnZGl2aWRlJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogMixcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5kaXZpZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2RpdicsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDIsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uZGl2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdwYXJ0ZnJhYycsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IFsxLCAyXSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5QYXJ0RnJhYy5wYXJ0ZnJhYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnZGVnJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogWzEsIDJdLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLmRlZ3JlZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnY29lZmZzJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogWzEsIDJdLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmcyA9IF9fLmNvZWZmcy5hcHBseShfXywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuVmVjdG9yKGNvZWZmcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2xpbmUnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiBbMiwgM10sXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18ubGluZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnc3Fjb21wJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogWzEsIDJdLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoeCwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB2IHx8IHZhcmlhYmxlcyh4KVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNxID0gX18uc3FDb21wbGV0ZSh4LmNsb25lKCksIHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3EuZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuICAgIG5lcmRhbWVyLmFwaSgpO1xyXG59KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///684\n")},238:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("/* global module */\r\n\r\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\nif( true && typeof nerdamer === 'undefined') {\r\n    var nerdamer = __webpack_require__(182);\r\n    __webpack_require__(684);\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Frac = core.Frac,\r\n            Settings = core.Settings,\r\n            isSymbol = core.Utils.isSymbol,\r\n            FN = core.groups.FN,\r\n            Symbol = core.Symbol,\r\n            text = core.Utils.text,\r\n            inBrackets = core.Utils.inBrackets,\r\n            isInt = core.Utils.isInt,\r\n            format = core.Utils.format,\r\n            even = core.Utils.even,\r\n            evaluate = core.Utils.evaluate,\r\n            N = core.groups.N,\r\n            S = core.groups.S,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            EX = core.groups.EX,\r\n            P = core.groups.P,\r\n            LOG = Settings.LOG,\r\n            EXP = 'exp',\r\n            ABS = 'abs',\r\n            SQRT = 'sqrt',\r\n            SIN = 'sin',\r\n            COS = 'cos',\r\n            TAN = 'tan',\r\n            SEC = 'sec',\r\n            CSC = 'csc',\r\n            COT = 'cot',\r\n            ASIN = 'asin',\r\n            ACOS = 'acos',\r\n            ATAN = 'atan',\r\n            ASEC = 'asec',\r\n            ACSC = 'acsc',\r\n            ACOT = 'acot',\r\n            SINH = 'sinh',\r\n            COSH = 'cosh',\r\n            TANH = 'tanh',\r\n            CSCH = 'csch',\r\n            SECH = 'sech',\r\n            COTH = 'coth',\r\n            ASECH = 'asech',\r\n            ACSCH = 'acsch',\r\n            ACOTH = 'acoth';\r\n\r\n    //custom errors\r\n    function NoIntegralFound(msg) {\r\n        this.message = msg || \"\";\r\n    }\r\n    NoIntegralFound.prototype = new Error();\r\n\r\n    //Preparations\r\n    Symbol.prototype.hasIntegral = function () {\r\n        return this.containsFunction('integrate');\r\n    };\r\n    //transforms a function\r\n    Symbol.prototype.fnTransform = function () {\r\n        if(this.group !== FN)\r\n            return this;\r\n        var retval, a = this.args[0];\r\n        var m = new Symbol(this.multiplier);\r\n        var sym = this.clone().toUnitMultiplier();\r\n        if(this.isLinear()) {\r\n            switch(this.fname) {\r\n                case SINH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\r\n                    break;\r\n                case TAN:\r\n                    retval = _.parse(format('sin({0})/cos({0})', a));\r\n                    break;\r\n                case CSC:\r\n                    retval = _.parse(format('1/sin({0})', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('1/cos({0})', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.power.equals(2)) {\r\n            switch(this.fname) {\r\n                case SIN:\r\n                    retval = _.parse(format('1/2-cos(2*({0}))/2', a));\r\n                    break;\r\n                case COS:\r\n                    retval = _.parse(format('1/2+cos(2*({0}))/2', a));\r\n                    break;\r\n                case TAN:\r\n                    //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\r\n                    retval = _.parse(format('sin({0})^2/cos({0})^2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case SINH:\r\n                    retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.fname === SEC) {\r\n            retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === CSC) {\r\n            retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === TAN) {\r\n            if(this.power.lessThan(0)) {\r\n                retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\r\n            }\r\n            else {\r\n                retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\r\n            }\r\n        }\r\n        else if(this.fname === SIN && this.power.lessThan(0)) {\r\n            retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === COS && this.power.lessThan(0)) {\r\n            retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === SIN && this.power.equals(3)) {\r\n            retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\r\n        }\r\n        else if(this.fname === COS && this.power.equals(3)) {\r\n            retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\r\n        }\r\n        //cos(a*x)^(2*n) or sin(a*x)^(2*n)\r\n        else if((this.fname === COS || this.fname === SIN) && even(this.power)) {\r\n            var n = this.power / 2;\r\n            //convert to a double angle\r\n            var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\r\n            //raise to the n and expand\r\n            var transformed = _.expand(_.pow(double_angle, _.parse(n)));\r\n\r\n            retval = new Symbol(0);\r\n\r\n            transformed.each(function (s) {\r\n                var t = s.fnTransform();\r\n                retval = _.add(retval, t);\r\n            }, true);\r\n        }\r\n        else\r\n            retval = sym;\r\n\r\n        return _.multiply(retval, m);\r\n    };\r\n\r\n    Symbol.prototype.hasTrig = function () {\r\n        if(this.isConstant(true) || this.group === S)\r\n            return false;\r\n        if(this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))\r\n            return true;\r\n        if(this.symbols) {\r\n            for(var x in this.symbols)\r\n                if(this.symbols[x].hasTrig())\r\n                    return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    core.Expression.prototype.hasIntegral = function () {\r\n        return this.symbol.hasIntegral();\r\n    };\r\n    /**\r\n     * Attempts to rewrite a symbol under one common denominator\r\n     * @param {Symbol} symbol \r\n     */\r\n    core.Utils.toCommonDenominator = function (symbol) {\r\n        //transform x/a+x -> (ax+x)/a\r\n        if(symbol.isComposite() && symbol.isLinear()) {\r\n            var m = new Symbol(symbol.multiplier);\r\n            var denominator = new Symbol(1);\r\n            var numerator = new Symbol(0);\r\n            symbol.each(function (x) {\r\n                denominator = _.multiply(denominator, x.getDenom());\r\n            }, true);\r\n\r\n            //remove the denomitor in each term\r\n            symbol.each(function (x) {\r\n                var num = x.getNum();\r\n                var den = x.getDenom();\r\n                var factor = _.multiply(num, _.divide(denominator.clone(), den));\r\n                numerator = _.add(numerator, factor);\r\n            });\r\n            var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\r\n            return retval;\r\n        }\r\n        return symbol;\r\n    };\r\n    //A function to check if a function name is an inverse trig function\r\n    core.Utils.in_inverse_trig = function (x) {\r\n        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\r\n        return inv_trig_fns.indexOf(x) !== -1;\r\n    };\r\n    //A function to check if a function name is a trig function\r\n    core.Utils.in_trig = function (x) {\r\n        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    core.Utils.in_htrig = function (x) {\r\n        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    // Matrix functions\r\n    core.Matrix.jacobian = function (eqns, vars) {\r\n        var jacobian = new core.Matrix();\r\n        //get the variables if not supplied\r\n        if(!vars) {\r\n            vars = core.Utils.arrayGetVariables(eqns);\r\n        }\r\n\r\n        vars.forEach(function (v, i) {\r\n            eqns.forEach(function (eq, j) {\r\n                var e = core.Calculus.diff(eq.clone(), v);\r\n                jacobian.set(j, i, e);\r\n            });\r\n        });\r\n\r\n        return jacobian;\r\n    };\r\n\r\n    core.Matrix.prototype.max = function () {\r\n        var max = new Symbol(0);\r\n        this.each(function (x) {\r\n            var e = x.abs();\r\n            if(e.gt(max))\r\n                max = e;\r\n        });\r\n        return max;\r\n    };\r\n\r\n    core.Matrix.cMatrix = function (value, vars) {\r\n        var m = new core.Matrix();\r\n        //make an initial guess\r\n        vars.forEach(function (v, i) {\r\n            m.set(i, 0, _.parse(value));\r\n        });\r\n        return m;\r\n    };\r\n\r\n    var all_functions = core.Utils.all_functions = function (arr) {\r\n        for(var i = 0, l = arr.length; i < l; i++)\r\n            if(arr[i].group !== FN)\r\n                return false;\r\n        return true;\r\n    },\r\n            cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\r\n            },\r\n            cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\r\n                //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\r\n                //we technically know how to do this transform but more is needed for correct output\r\n                if(Number(symbol2.power) !== 1)\r\n                    return _.multiply(symbol1, symbol2);\r\n                var a;\r\n                a = symbol1.args[0];\r\n                return _.parse(format('(sin(2*({0})))/2', a));\r\n            },\r\n            sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\r\n            },\r\n            trigTransform = core.Utils.trigTransform = function (arr) {\r\n                var map = {}, symbol, t,\r\n                        retval = new Symbol(1);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    symbol = arr[i];\r\n\r\n                    if(symbol.group === FN) {\r\n                        var fname = symbol.fname;\r\n\r\n                        if(fname === COS && map[SIN]) {\r\n\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[SIN]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[SIN]);\r\n                            }\r\n                            delete map[SIN];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[COS]) {\r\n                            if(map[COS].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[COS]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[COS]);\r\n                            }\r\n                            delete map[COS];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[SIN]) {\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = sinAsinBtransform(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n                            else {\r\n                                //This should actually be redundant code but let's put just in case\r\n                                t = _.multiply(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n\r\n                            retval = t;\r\n                        }\r\n                        else {\r\n                            map[fname] = symbol;\r\n                        }\r\n                    }\r\n                    else\r\n                        retval = _.multiply(retval, symbol);\r\n                }\r\n\r\n                //put back the remaining functions\r\n                for(var x in map)\r\n                    retval = _.multiply(retval, map[x]);\r\n\r\n                return retval;\r\n\r\n            };\r\n\r\n    core.Settings.integration_depth = 10;\r\n\r\n    core.Settings.max_lim_depth = 10;\r\n\r\n    var __ = core.Calculus = {\r\n\r\n        version: '1.4.6',\r\n\r\n        sum: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                start = Number(start);\r\n                end = Number(end);\r\n                retval = core.Utils.block(modifier, function () {\r\n                    var f = fn.text(),\r\n                            subs = {'~': true}, //lock subs. Is this even being used?\r\n                            retval = new core.Symbol(0);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        var ans = _.parse(f, subs);\r\n                        retval = _.add(retval, ans);\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('sum', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        product: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                retval = core.Utils.block(modifier, function () {\r\n                    start = Number(start);\r\n                    end = Number(end.multiplier);\r\n\r\n                    var f = fn.text(),\r\n                            subs = {},\r\n                            retval = new core.Symbol(1);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        retval = _.multiply(retval, _.parse(f, subs));\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('product', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        diff: function (symbol, wrt, nth) {\r\n            if(core.Utils.isVector(symbol)) {\r\n                var vector = new core.Vector([]);\r\n                symbol.each(function (x) {\r\n                    vector.elements.push(__.diff(x, wrt, nth));\r\n                });\r\n                return vector;\r\n            }\r\n            else if(core.Utils.isMatrix(symbol)) {\r\n                var matrix = new core.Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    matrix.set(i, j, __.diff(x, wrt, nth));\r\n                });\r\n                return matrix;\r\n            }\r\n\r\n            var d = isSymbol(wrt) ? wrt.text() : wrt;\r\n            //the nth derivative\r\n            nth = isSymbol(nth) ? nth.multiplier : nth || 1;\r\n\r\n            if(d === undefined)\r\n                d = core.Utils.variables(symbol)[0];\r\n\r\n            //unwrap sqrt\r\n            if(symbol.group === FN && symbol.fname === SQRT) {\r\n                var s = symbol.args[0],\r\n                        sp = symbol.power.clone();\r\n                //these groups go to zero anyway so why waste time?\r\n                if(s.group !== N || s.group !== P) {\r\n                    s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\r\n                    s.multiplier = s.multiplier.multiply(symbol.multiplier);\r\n                }\r\n\r\n                symbol = s;\r\n            }\r\n\r\n            if(symbol.group === FN && !isSymbol(symbol.power)) {\r\n                var a = derive(_.parse(symbol));\r\n                var b = __.diff(symbol.args[0].clone(), d);\r\n                symbol = _.multiply(a, b);//chain rule\r\n            }\r\n            else {\r\n                symbol = derive(symbol);\r\n            }\r\n\r\n            if(nth > 1) {\r\n                nth--;\r\n                symbol = __.diff(symbol, wrt, nth);\r\n            }\r\n\r\n            return symbol;\r\n\r\n            // Equivalent to \"derivative of the outside\".\r\n            function polydiff(symbol) {\r\n                if(symbol.value === d || symbol.contains(d, true)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(symbol.power);\r\n                    symbol.power = symbol.power.subtract(new Frac(1));\r\n                    if(symbol.power.equals(0)) {\r\n                        symbol = Symbol(symbol.multiplier);\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            }\r\n            \r\n            function derive(symbol) {\r\n                var g = symbol.group, a, b, cp;\r\n\r\n                if(g === N || g === S && symbol.value !== d || g === P) {\r\n                    symbol = Symbol(0);\r\n                }\r\n                else if(g === S) {\r\n                    symbol = polydiff(symbol);\r\n                }\r\n                else if(g === CB) {\r\n                    var m = symbol.multiplier.clone();\r\n                    symbol.toUnitMultiplier();\r\n                    var retval = _.multiply(product_rule(symbol), polydiff(symbol));\r\n                    retval.multiplier = retval.multiplier.multiply(m);\r\n                    return retval;\r\n                }\r\n                else if(g === FN && symbol.power.equals(1)) {\r\n                    // Table of known derivatives\r\n                    switch(symbol.fname) {\r\n                        case LOG:\r\n                            cp = symbol.clone();\r\n                            symbol = symbol.args[0].clone();//get the arguments\r\n                            symbol.power = symbol.power.negate();\r\n                            symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\r\n                            break;\r\n                        case COS:\r\n                            //cos -> -sin\r\n                            symbol.fname = SIN;\r\n                            symbol.multiplier.negate();\r\n                            break;\r\n                        case SIN:\r\n                            //sin -> cos\r\n                            symbol.fname = COS;\r\n                            break;\r\n                        case TAN:\r\n                            //tan -> sec^2\r\n                            symbol.fname = SEC;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SEC:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, TAN);\r\n                            break;\r\n                        case CSC:\r\n                            symbol = qdiff(symbol, '-cot');\r\n                            break;\r\n                        case COT:\r\n                            symbol.fname = CSC;\r\n                            symbol.multiplier.negate();\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case ASIN:\r\n                            symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ACOS:\r\n                            symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ATAN:\r\n                            symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ABS:\r\n                            m = symbol.multiplier.clone();\r\n                            symbol.toUnitMultiplier();\r\n                            //depending on the complexity of the symbol it's easier to just parse it into a new symbol\r\n                            //this should really be readdressed soon\r\n                            b = symbol.args[0].clone();\r\n                            b.toUnitMultiplier();\r\n                            symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\r\n                            symbol.multiplier = m;\r\n                            break;\r\n                        case 'parens':\r\n                            //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\r\n                            //1*g'\r\n                            symbol = Symbol(1);\r\n                            break;\r\n                        case 'cosh':\r\n                            //cosh -> -sinh\r\n                            symbol.fname = 'sinh';\r\n                            break;\r\n                        case 'sinh':\r\n                            //sinh -> cosh\r\n                            symbol.fname = 'cosh';\r\n                            break;\r\n                        case TANH:\r\n                            //tanh -> sech^2\r\n                            symbol.fname = SECH;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SECH:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, '-tanh');\r\n                            break;\r\n                        case CSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\r\n                            break;\r\n                        case COTH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-csch(' + arg + ')^2');\r\n                            break;\r\n                        case 'asinh':\r\n                            symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'acosh':\r\n                            symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'atanh':\r\n                            symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ASECH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOTH:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\r\n                            break;\r\n                        case ACSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ASEC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACSC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOT:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\r\n                            break;\r\n                        case 'S':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'C':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'Si':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Shi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ci':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Chi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ei':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Li':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\r\n                            break;\r\n                        case 'erf':\r\n                            symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\r\n                            break;\r\n                        case 'atan2':\r\n                            var x_ = String(symbol.args[0]),\r\n                                    y_ = String(symbol.args[1]);\r\n                            symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\r\n                            break;\r\n                        case 'sign':\r\n                            symbol = new Symbol(0);\r\n                            break;\r\n                        case 'sinc':\r\n                            symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\r\n                            break;\r\n                        case Settings.LOG10:\r\n                            symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\r\n                            break;\r\n                        default:\r\n                            symbol = _.symfunction('diff', [symbol, wrt]);\r\n                    }\r\n                }\r\n                else if(g === EX || g === FN && isSymbol(symbol.power)) {\r\n                    var value;\r\n                    if(g === EX) {\r\n                        value = symbol.value;\r\n                    }\r\n                    else if(g === FN && symbol.contains(d)) {\r\n                        value = symbol.fname + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    else {\r\n                        value = symbol.value + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\r\n                    b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\r\n                    symbol = _.multiply(symbol, b);\r\n                }\r\n                else if(g === FN && !symbol.power.equals(1)) {\r\n                    b = symbol.clone();\r\n                    b.toLinear();\r\n                    b.toUnitMultiplier();\r\n                    symbol = _.multiply(polydiff(symbol.clone()), derive(b));\r\n                }\r\n                else if(g === CP || g === PL) {\r\n                    // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\r\n                    var c = symbol.clone();\r\n                    var result = new Symbol(0);\r\n                    for(var x in symbol.symbols) {\r\n                        result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\r\n                    }\r\n                    symbol = _.multiply(polydiff(c), result);\r\n                }\r\n\r\n                symbol.updateHash();\r\n\r\n                return symbol;\r\n            }\r\n            ;\r\n\r\n            function qdiff(symbol, val, altVal) {\r\n                return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\r\n            }\r\n            ;\r\n\r\n            function product_rule(symbol) {\r\n                //grab all the symbols within the CB symbol\r\n                var symbols = symbol.collectSymbols(),\r\n                        result = new Symbol(0),\r\n                        l = symbols.length;\r\n                //loop over all the symbols\r\n                for(var i = 0; i < l; i++) {\r\n                    var df = __.diff(symbols[i].clone(), d);\r\n                    for(var j = 0; j < l; j++) {\r\n                        //skip the symbol of which we just pulled the derivative\r\n                        if(i !== j) {\r\n                            //multiply out the remaining symbols\r\n                            df = _.multiply(df, symbols[j].clone());\r\n                        }\r\n                    }\r\n                    //add the derivative to the result\r\n                    result = _.add(result, df);\r\n                }\r\n                return result; //done\r\n            }\r\n            ;\r\n        },\r\n        integration: {\r\n            u_substitution: function (symbols, dx) {\r\n                function try_combo(a, b, f) {\r\n                    var d = __.diff(b, dx);\r\n                    var q = f ? f(a, b) : _.divide(a.clone(), d);\r\n                    if(!q.contains(dx, true))\r\n                        return q;\r\n                    return null;\r\n                }\r\n                function do_fn_sub(fname, arg) {\r\n                    var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\r\n                    subbed = subbed.sub(new Symbol(u), arg);\r\n                    subbed.updateHash();\r\n                    return subbed;\r\n                }\r\n\r\n                var a = symbols[0].clone(),\r\n                        b = symbols[1].clone(),\r\n                        g1 = a.group,\r\n                        g2 = b.group,\r\n                        //may cause problems if person is using this already. Will need\r\n                        //to find algorithm for detecting conflict\r\n                        u = '__u__',\r\n                        Q;\r\n                if(g1 === FN && g2 !== FN) {\r\n                    //e.g. 2*x*cos(x^2)\r\n                    var arg = a.args[0];\r\n                    Q = try_combo(b, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(a.fname, arg));\r\n                    Q = try_combo(b, a);\r\n                    if(Q) {\r\n                        return __.integration.poly_integrate(a);\r\n                    }\r\n                }\r\n                else if(g2 === FN && g1 !== FN) {\r\n                    //e.g. 2*(x+1)*cos((x+1)^2\r\n                    var arg = b.args[0];\r\n                    Q = try_combo(a, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(b.fname, arg));\r\n                }\r\n                else if(g1 === FN && g2 === FN) {\r\n                    Q = try_combo(a.clone(), b.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(b.clone(), a.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                }\r\n                else if(g1 === EX && g2 !== EX) {\r\n                    var p = a.power;\r\n                    Q = try_combo(b, p.clone());\r\n                    if(!Q) {\r\n                        //one more try\r\n                        var dc = __.integration.decompose_arg(p.clone(), dx);\r\n                        //consider the possibility of a^x^(n-1)*x^n dx\r\n                        var xp = __.diff(dc[2].clone(), dx);\r\n                        var dc2 = __.integration.decompose_arg(xp.clone(), dx);\r\n                        //if their powers equal, so if dx*p == b\r\n                        if(_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\r\n                            var m = _.divide(dc[0].clone(), dc2[0].clone());\r\n\r\n                            var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\r\n                            new_val = _.multiply(new_val, new Symbol(u));\r\n                            return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\r\n                        }\r\n\r\n                    }\r\n                    var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\r\n                            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n\r\n\r\n                    return retval;\r\n                }\r\n                else if(g2 === EX && g1 !== EX) {\r\n                    var p = b.power;\r\n                    Q = try_combo(a, p.clone());\r\n                    var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\r\n                    return _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n                }\r\n                else if(a.isComposite() || b.isComposite()) {\r\n                    var f = function (a, b) {\r\n                        var d = __.diff(b, dx);\r\n                        var A = core.Algebra.Factor.factor(a),\r\n                                B = core.Algebra.Factor.factor(d);\r\n                        var q = _.divide(A, B);\r\n                        return q;\r\n                    };\r\n                    var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\r\n                            f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\r\n                    Q = try_combo(f1.clone(), f2.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(f2.clone(), f1.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(a), Q);\r\n                }\r\n            },\r\n            //simple integration of a single polynomial x^(n+1)/(n+1)\r\n            poly_integrate: function (x) {\r\n                var p = x.power.toString(),\r\n                        m = x.multiplier.toDecimal(),\r\n                        s = x.toUnitMultiplier().toLinear();\r\n                if(Number(p) === -1) {\r\n                    return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\r\n                }\r\n                return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\r\n            },\r\n            //If we're just spinning wheels we want to stop. This is why we \r\n            //wrap integration in a try catch block and call this to stop.\r\n            stop: function (msg) {\r\n                msg = msg || 'Unable to compute integral!';\r\n                core.Utils.warn(msg);\r\n                throw new NoIntegralFound(msg);\r\n            },\r\n            partial_fraction: function (input, dx, depth, opt) {\r\n                //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\r\n                if(!isSymbol(dx))\r\n                    dx = _.parse(dx);\r\n\r\n                var result, partial_fractions;\r\n                result = new Symbol(0);\r\n                partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\r\n\r\n                if(partial_fractions.group === CB && partial_fractions.isLinear()) {\r\n                    //perform a quick check to make sure that all partial fractions are linear\r\n                    partial_fractions.each(function (x) {\r\n                        if(!x.isLinear())\r\n                            __.integration.stop();\r\n                    });\r\n                    partial_fractions.each(function (x) {\r\n                        result = _.add(result, __.integrate(x, dx, depth, opt));\r\n                    });\r\n                }\r\n                else {\r\n                    result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\r\n                }\r\n                return result;\r\n            },\r\n            get_udv: function (symbol) {\r\n                var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\r\n                //first we sort them \r\n                var setSymbol = function (x) {\r\n                    var g = x.group;\r\n                    if(g === FN) {\r\n                        var fname = x.fname;\r\n                        if(core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))\r\n                            parts[3].push(x);\r\n                        else if(core.Utils.in_inverse_trig(fname))\r\n                            parts[1].push(x);\r\n                        else if(fname === LOG)\r\n                            parts[0].push(x);\r\n                        else {\r\n                            __.integration.stop();\r\n                        }\r\n                    }\r\n                    else if(g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\r\n                        parts[2].push(x);\r\n                    }\r\n                    else if(g === EX || x.isComposite() && !x.isLinear())\r\n                        parts[4].push(x);\r\n                    else\r\n                        __.integration.stop();\r\n                };\r\n\r\n                if(symbol.group === CB)\r\n                    symbol.each(function (x) {\r\n                        setSymbol(Symbol.unwrapSQRT(x, true));\r\n                    });\r\n                else\r\n                    setSymbol(symbol);\r\n                var u, dv = new Symbol(1);\r\n                //compile u and dv\r\n                for(var i = 0; i < 5; i++) {\r\n                    var part = parts[i], t,\r\n                            l = part.length;\r\n                    if(l > 0) {\r\n                        if(l > 1) {\r\n                            t = new Symbol(1);\r\n                            for(var j = 0; j < l; j++)\r\n                                t = _.multiply(t, part[j].clone());\r\n                        }\r\n                        else\r\n                            t = part[0].clone();\r\n\r\n                        if(!u) {\r\n                            u = t;//the first u encountered gets chosen\r\n                            u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\r\n                        }\r\n                        else\r\n                            dv = _.multiply(dv, t); //everything else belongs to dv\r\n                    }\r\n                }\r\n\r\n                return [u, dv];\r\n            },\r\n\r\n            trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\r\n                parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\r\n                var b = parts[3],\r\n                        ax = parts[2],\r\n                        a = parts[0],\r\n                        x = parts[1];\r\n                if(x.power.equals(2) && a.greaterThan(0)) {\r\n                    //use tan(x)\r\n                    var t = core.Utils.getU(symbol), //get an appropriate u\r\n                            u = _.parse(TAN + inBrackets(t)), //u\r\n                            du = _.parse(SEC + inBrackets(t) + '^2'), //du\r\n                            f = _.multiply(symbol.sub(x, u), du);\r\n                    var integral = __.integrate(f, t, depth, opt).sub(u, x);\r\n                    core.Utils.clearU(u);\r\n                    return integral;\r\n                }\r\n            },\r\n\r\n            by_parts: function (symbol, dx, depth, o) {\r\n                o.previous = o.previous || [];\r\n                var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\r\n                //first LIATE\r\n                udv = __.integration.get_udv(symbol);\r\n                u = udv[0];\r\n                dv = udv[1];\r\n                du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\r\n                c = du.clone().stripVar(dx);\r\n                //strip any coefficients\r\n                du = _.divide(du, c.clone());\r\n                v = __.integrate(dv.clone(), dx, depth || 0);\r\n                vdu = _.multiply(v.clone(), du);\r\n                vdu_s = vdu.toString();\r\n                //currently only supports e^x*(some trig)\r\n                if(o.previous.indexOf(vdu_s) !== -1 && (core.Utils.in_trig(u.fname)) && dv.isE()) {\r\n                    //We're going to exploit the fact that vdu can never be constant\r\n                    //to work out way out of this cycle. We'll return the length of\r\n                    //the this.previous array until we're back at level one\r\n                    o.is_cyclic = true;\r\n                    //return the integral. \r\n                    return new Symbol(1);\r\n                }\r\n                else\r\n                    o.previous.push(vdu_s);\r\n\r\n                uv = _.multiply(u, v);\r\n                //clear the multiplier so we're dealing with a bare integral\r\n                m = vdu.multiplier.clone();\r\n                vdu.toUnitMultiplier();\r\n                integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\r\n                integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\r\n                retval = _.subtract(uv, integral_vdu);\r\n                //we know that there cannot be constants so they're a holdover from a cyclic integral\r\n                if(o.is_cyclic) {\r\n                    //start popping the previous stack so we know how deep in we are\r\n                    o.previous.pop();\r\n                    if(o.previous.length === 0) {\r\n                        retval = _.expand(retval);\r\n                        var rem = new Symbol(0);\r\n                        retval.each(function (x) {\r\n                            if(!x.contains(dx))\r\n                                rem = _.add(rem, x.clone());\r\n                        });\r\n                        //get the actual uv\r\n                        retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\r\n                    }\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            /*\r\n             * dependents: [Solve, integrate]\r\n             */\r\n            decompose_arg: core.Utils.decompose_fn\r\n        },\r\n        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\r\n        integrate: function (original_symbol, dt, depth, opt) {\r\n            //assume integration wrt independent variable if expression only has one variable\r\n            if(!dt) {\r\n                var vars = core.Utils.variables(original_symbol);\r\n                if(vars.length === 1)\r\n                    dt = vars[0];\r\n                //defaults to x\r\n                dt = dt || 'x';\r\n            }\r\n            //add support for integrating vectors\r\n            if(core.Utils.isVector(original_symbol)) {\r\n                var vector = new core.Vector([]);\r\n                original_symbol.each(function (x) {\r\n                    vector.elements.push(__.integrate(x, dt));\r\n                });\r\n                return vector;\r\n            }\r\n            if(!isNaN(dt))\r\n                _.error('variable expected but received ' + dt);\r\n            //get rid of constants right away\r\n            if(original_symbol.isConstant(true))\r\n                return _.multiply(original_symbol.clone(), _.parse(dt));\r\n\r\n            //configurations options for integral. This is needed for tracking extra options\r\n            //e.g. cyclic integrals or additional settings\r\n            opt = opt || {};\r\n            return core.Utils.block('PARSE2NUMBER', function () {\r\n                //make a note of the original symbol. Set only if undefined\r\n                depth = depth || 0;\r\n                var dx = isSymbol(dt) ? dt.toString() : dt,\r\n                        //we don't want the symbol in sqrt form. x^(1/2) is prefererred\r\n                        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\r\n                        g = symbol.group,\r\n                        retval;\r\n\r\n                try {\r\n                    //We stop integration after x amount of recursive calls\r\n                    if(++depth > core.Settings.integration_depth)\r\n                        __.integration.stop('Maximum depth reached. Exiting!');\r\n\r\n                    //constants. We first eliminate anything that doesn't have dx. Everything after this has \r\n                    //to have dx or else it would have been taken care of below\r\n                    if(!symbol.contains(dx, true)) {\r\n                        retval = _.multiply(symbol.clone(), _.parse(dx));\r\n                    }\r\n                    //e.g. 2*x\r\n                    else if(g === S) {\r\n                        retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                    }\r\n                    else if(g === EX) {\r\n                        if(symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS))\r\n                            __.integration.stop();\r\n                        //check the base\r\n                        if(symbol.contains(dx) && symbol.previousGroup !== FN) {\r\n                            //if the symbol also contains dx then we stop since we currently \r\n                            //don't know what to do with it e.g. x^x\r\n                            if(symbol.power.contains(dx))\r\n                                __.integration.stop();\r\n                            else {\r\n                                var t = __.diff(symbol.clone().toLinear(), dx);\r\n                                if(t.contains(dx))\r\n                                    __.integration.stop();\r\n                                //since at this point it's the base only then we do standard single poly integration\r\n                                //e.g. x^y\r\n                                retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                            }\r\n                        }\r\n                        //e.g. a^x or 9^x\r\n                        else {\r\n                            var a = __.diff(symbol.power.clone(), dx);\r\n                            if(a.contains(dx)) {\r\n                                var aa = a.stripVar(dx),\r\n                                        x = _.divide(a.clone(), aa.clone());\r\n                                if(x.group === S && x.isLinear()) {\r\n                                    aa.multiplier = aa.multiplier.divide(new Frac(2));\r\n                                    return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            if(symbol.isE()) {\r\n                                if(a.isLinear())\r\n                                    retval = symbol;\r\n                                else {\r\n                                    if(a.isE() && a.power.group === S && a.power.power.equals(1))\r\n                                        retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\r\n                                retval = _.divide(symbol, d);\r\n                            }\r\n                            retval = _.divide(retval, a);\r\n                        }\r\n                    }\r\n                    else if(symbol.isComposite() && symbol.isLinear()) {\r\n                        var m = _.parse(symbol.multiplier);\r\n                        symbol.toUnitMultiplier();\r\n                        retval = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            retval = _.add(retval, __.integrate(x, dx, depth));\r\n                        });\r\n                        retval = _.multiply(m, retval);\r\n                    }\r\n                    else if(g === CP) {\r\n                        if(symbol.power.greaterThan(1))\r\n                            symbol = _.expand(symbol);\r\n                        if(symbol.power.equals(1)) {\r\n                            retval = new Symbol(0);\r\n                            symbol.each(function (x) {\r\n                                retval = _.add(retval, __.integrate(x, dx, depth));\r\n                            }, true);\r\n                        }\r\n                        else {\r\n                            var p = Number(symbol.power),\r\n                                    m = symbol.multiplier.clone();//temporarily remove the multiplier\r\n                            symbol.toUnitMultiplier();\r\n                            var //below we consider the form ax+b\r\n                                    fn = symbol.clone().toLinear(), //get just the pure function without the power\r\n                                    decomp = __.integration.decompose_arg(fn, dx),\r\n                                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\r\n                                    b = decomp[3],\r\n                                    ax = decomp[2],\r\n                                    a = decomp[0],\r\n                                    x = decomp[1];\r\n                            if(p === -1 && x.group !== PL && x.power.equals(2)) {\r\n                                var b_is_positive = isInt(b) ? b > 0 : true;\r\n                                //we can now check for atan\r\n                                if(x.group === S && x.power.equals(2) && b_is_positive) {\r\n                                    ////then we have atan\r\n                                    //abs is redundants since the sign appears in both denom and num.\r\n                                    var unwrapAbs = function (s) {\r\n                                        var result = new Symbol(1);\r\n                                        s.each(function (x) {\r\n                                            result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\r\n                                        });\r\n                                        return result;\r\n                                    };\r\n                                    var A = a.clone(),\r\n                                            B = b.clone();\r\n                                    A = _.pow(A, new Symbol(1 / 2));\r\n                                    B = _.pow(B, new Symbol(1 / 2));\r\n                                    //unwrap abs\r\n\r\n                                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\r\n                                            f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\r\n                                    retval = _.divide(f, d);\r\n                                }\r\n                                else if(x.group === S && x.isLinear()) {\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                }\r\n                                else {\r\n                                    //1/(x^4+1)\r\n                                    if(x.power.equals(4)) {\r\n                                        //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\r\n                                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\r\n                                        var br = inBrackets;\r\n                                        //apply rule: ax^4+b = (ax^2+2abx+b)(ax^2-2abx+b)\r\n                                        //get quadratic factors\r\n                                        A = _.parse(SQRT + br(a) + '*' + dx + '^2');\r\n                                        B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        C = _.parse(SQRT + br(b));\r\n                                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\r\n                                        f2 = _.add(_.subtract(A, B), C);\r\n                                        //calculate numerators: [D+E, D-E] -> [2*b^(3/4)+bax, 2*b^(3/4)-bax]\r\n                                        D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\r\n                                        E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        //let F = 2b2b\r\n                                        F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4'));\r\n                                        //calculate the factors\r\n                                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\r\n                                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\r\n                                        retval = _.add(\r\n                                                __.integrate(L1, dx, depth, opt),\r\n                                                __.integrate(L2, dx, depth, opt)\r\n                                                );\r\n                                    }\r\n                                    else\r\n                                        //let's try partial fractions\r\n                                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                }\r\n                            }\r\n                            else if(p === -1 / 2) {\r\n                                //detect asin and atan\r\n                                if(x.group === S && x.power.equals(2)) {\r\n                                    if(ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\r\n                                        a.negate();\r\n                                        //it's asin\r\n                                        if(b.isConstant() && a.isConstant()) {\r\n                                            var d = _.symfunction(SQRT, [a.clone()]),\r\n                                                    d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\r\n                                            retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\r\n                                        }\r\n                                        //I'm not sure about this one. I'm trusting Wolfram Alpha here\r\n                                        else {\r\n                                            var sqrt_a = _.symfunction(SQRT, [a]),\r\n                                                    sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\r\n                                            retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\r\n                                        __.integration.stop();\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\r\n                                    __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                if(x.isLinear() && x.group !== PL)\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                else if(x.power.equals(2) && a.greaterThan(0)) {\r\n                                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\r\n                                    //1/(a*x^2+b^2)^n\r\n                                    //strip the value of b so b = 1\r\n                                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\r\n                                    sqb = _.parse(SQRT + inBrackets(b));\r\n                                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\r\n                                    bsqi = _.pow(b, new Symbol(symbol.power));\r\n                                    uv = core.Utils.getU(symbol);\r\n                                    u = _.multiply(aob, x.clone().toLinear());\r\n                                    v = _.parse(ATAN + inBrackets(u));\r\n                                    //the conversion will be 1+tan(x)^2 -> sec(x)^2\r\n                                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \r\n                                    //then the remaining sec will be (n-1)*2;\r\n                                    var n = (Math.abs(symbol.power) - 1) * 2;\r\n                                    //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\r\n                                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\r\n                                    core.Utils.clearU(uv);\r\n                                    return _.multiply(integral.sub(uv, v), bsqi);\r\n                                }\r\n                                else {\r\n                                    if(symbol.group !== CB && !symbol.power.lessThan(0)) {\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n                                    else {\r\n                                        var f = symbol.clone().toLinear();\r\n                                        var factored = core.Algebra.Factor.factor(f);\r\n                                        var was_factored = factored.toString() !== f.toString();\r\n                                        if(core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\r\n                                            try {\r\n                                                var f1, fx, u, sq;\r\n                                                sq = core.Algebra.sqComplete(f, dx);\r\n                                                u = core.Utils.getU(f);\r\n                                                f1 = sq.f.sub(sq.a, u);\r\n                                                fx = _.pow(f1, _.parse(symbol.power));\r\n                                                retval = __.integrate(fx, u).sub(u, sq.a);\r\n                                            }\r\n                                            catch(e) {\r\n                                                __.integration.stop();\r\n                                            }\r\n                                        }\r\n                                        else\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                    }\r\n                                }\r\n                            }\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === FN) {\r\n                        var arg = symbol.args[0],\r\n                                m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        var decomp = __.integration.decompose_arg(arg, dx);\r\n                        //easies way I can think of to get the coefficient and to make sure\r\n                        //that the symbol is linear wrt dx. I'm not actually trying to get the \r\n                        //derivative\r\n                        var a = decomp[0],\r\n                                x = decomp[1],\r\n                                fname = symbol.fname;\r\n                        //log is a special case that can be handled with integration by parts\r\n                        if(fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {\r\n                            /*integration by parts */\r\n                            var p = symbol.power.toString();\r\n                            if(isInt(p))\r\n                                depth = depth - p; //it needs more room to find the integral\r\n\r\n                            if(!arg.isComposite())\r\n                                retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));\r\n                            else {\r\n                                //integral u du\r\n                                var u = core.Utils.getU(symbol);\r\n                                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\r\n                                var du = __.diff(arg, dx);\r\n                                var u_du = _.multiply(f, du);\r\n                                var integral = __.integrate(u_du, u, depth, opt);\r\n                                retval = _.multiply(_.parse(m), integral.sub(u, arg));\r\n                            }\r\n\r\n                        }\r\n                        else if(fname === TAN && symbol.power.lessThan(0)) {\r\n                            //convert to cotangent\r\n                            var sym = symbol.clone();\r\n                            sym.power.negate();\r\n                            sym.fname = COT;\r\n                            return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\r\n                        }\r\n                        else {\r\n                            if(!a.contains(dx, true) && symbol.isLinear()) { //perform a deep search for safety\r\n                                //first handle the special cases \r\n                                if(fname === ABS) {\r\n                                    //REVISIT **TODO**\r\n                                    var x = _.divide(arg.clone(), a.clone());\r\n                                    if(x.group === S && !x.power.lessThan(0)) {\r\n                                        if(core.Utils.even(x.power)) {\r\n                                            retval = __.integrate(arg, dx, depth);\r\n                                        }\r\n                                        else {\r\n                                            var integrated = __.integrate(x, dx, depth);\r\n                                            integrated.power = integrated.power.subtract(new Frac(1));\r\n                                            retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                                else {\r\n                                    var ag = symbol.args[0].group,\r\n                                            decomposed = __.integration.decompose_arg(arg, dx);\r\n\r\n                                    if(!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())\r\n                                        __.integration.stop();\r\n                                    /**TODO**/ //ASIN, ACOS, ATAN\r\n                                    switch(fname) {\r\n                                        case COS:\r\n                                            retval = _.symfunction(SIN, [arg]);\r\n                                            break;\r\n                                        case SIN:\r\n                                            retval = _.symfunction(COS, [arg]);\r\n                                            retval.negate();\r\n                                            break;\r\n                                        case TAN:\r\n                                            retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\r\n                                            break;\r\n                                        case SEC:\r\n                                            retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\r\n                                            break;\r\n                                        case CSC:\r\n                                            retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\r\n                                            break;\r\n                                        case COT:\r\n                                            retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\r\n                                            break;\r\n                                        case SINH:\r\n                                            retval = _.symfunction(COSH, [arg]);\r\n                                            break;\r\n                                        case COSH:\r\n                                            retval = _.symfunction(SINH, [arg]);\r\n                                            break;\r\n                                        case TANH:\r\n                                            retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\r\n                                            break;\r\n                                        case ASEC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOT:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //inverse htrig\r\n                                        case ASECH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSCH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOTH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //end inverse htrig\r\n                                            //htrigh\r\n                                        case SECH:\r\n                                            retval = _.parse(format('atan(sinh({0}))', arg));\r\n                                            break;\r\n                                        case CSCH:\r\n                                            retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\r\n                                            break;\r\n                                        case COTH:\r\n                                            retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\r\n                                            break;\r\n                                            //end htrig\r\n                                        case EXP:\r\n                                            retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\r\n                                            break;\r\n                                        case 'S':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\r\n                                            break;\r\n                                        case 'C':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\r\n                                            break;\r\n                                        case 'erf':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\r\n                                            break;\r\n                                        case 'sign':\r\n                                            retval = _.multiply(symbol.clone(), arg.clone());\r\n                                            break;\r\n                                        default:\r\n                                            __.integration.stop();\r\n                                    }\r\n\r\n                                    retval = _.divide(retval, a);\r\n                                }\r\n                            }\r\n                            else if(x.isLinear()) {\r\n                                if(fname === COS || fname === SIN) {\r\n                                    var p = Number(symbol.power);\r\n                                    //check to see if it's negative and then just transform it to sec or csc\r\n                                    if(p < 0) {\r\n                                        symbol.fname = fname === SIN ? CSC : SEC;\r\n                                        symbol.invert().updateHash();\r\n                                        retval = __.integrate(symbol, dx, depth);\r\n                                    }\r\n                                    else {\r\n                                        var arg = symbol.args[0],\r\n                                                rd = symbol.clone(), //cos^(n-1)\r\n                                                rd2 = symbol.clone(), //cos^(n-2)\r\n                                                q = new Symbol((p - 1) / p), //\r\n                                                na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\r\n                                        rd.power = rd.power.subtract(new Frac(1));\r\n                                        rd2.power = rd2.power.subtract(new Frac(2));\r\n\r\n                                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\r\n                                        if(fname === SIN)\r\n                                            t.negate();\r\n                                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\r\n                                    }\r\n                                }\r\n                                //tan(x)^n or cot(x)^n\r\n                                else if(fname === TAN || fname === COT) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    if(symbol.args[0].isLinear(dx)) {\r\n                                        var n = symbol.power.subtract(new Frac(1)).toString(),\r\n                                                r = symbol.clone().toUnitMultiplier(),\r\n                                                w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\r\n                                        r.power = r.power.subtract(new Frac(2));\r\n                                        if(r.power.equals(0))\r\n                                            r = _.parse(r);\r\n                                        retval = _.subtract(w, __.integrate(r, dx, depth));\r\n                                    }\r\n                                }\r\n                                //sec(x)^n or csc(x)^n\r\n                                else if(fname === SEC || fname === CSC) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    var n1 = symbol.power.subtract(new Frac(1)).toString(),\r\n                                            n2 = symbol.power.subtract(new Frac(2)).toString(),\r\n                                            f2 = fname === SEC ? TAN : COT,\r\n                                            r = symbol.clone().toUnitMultiplier(),\r\n                                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\r\n                                            w = _.parse(parse_str);\r\n                                    r.power = r.power.subtract(new Frac(2));\r\n                                    if(r.power.equals(0))\r\n                                        r = _.parse(r);\r\n                                    retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\r\n                                }\r\n                                else if((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\r\n                                    retval = __.integrate(symbol.fnTransform(), dx, depth);\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            else\r\n                                __.integration.stop();\r\n\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === PL) {\r\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                    }\r\n                    else if(g === CB) {\r\n                        var den = symbol.getDenom();\r\n                        if(den.group === S)\r\n                            symbol = _.expand(symbol);\r\n\r\n                        //separate the coefficient since all we care about are symbols containing dx\r\n                        var coeff = symbol.stripVar(dx);\r\n                        //now get only those that apply\r\n                        var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\r\n                        //peform a correction for stripVar. This is a serious TODO!\r\n                        if(coeff.contains(dx)) {\r\n                            cfsymbol = _.multiply(cfsymbol, coeff);\r\n                            coeff = new Symbol(1);\r\n                        }\r\n\r\n                        //if we only have one symbol left then let's not waste time. Just pull the integral\r\n                        //and let the chips fall where they may\r\n                        if(cfsymbol.group !== CB) {\r\n                            if(cfsymbol.equals(1)) {\r\n                                return __.integrate(_.expand(symbol), dx, depth);\r\n                            }\r\n\r\n                            //only factor for multivariate which are polynomials\r\n                            if(cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\r\n                                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\r\n                            }\r\n\r\n                            retval = __.integrate(cfsymbol, dx, depth);\r\n                        }\r\n                        else {\r\n                            //we collect the symbols and sort them descending group, descending power, descending alpabethically\r\n                            var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\r\n                                if(a.group === b.group) {\r\n                                    if(Number(a.power) === Number(b.power))\r\n                                        if(a < b)\r\n                                            return 1; //I want sin first\r\n                                        else\r\n                                            return -1;\r\n                                    return b.power - a.power; //descending power\r\n                                }\r\n                                return b.group - a.group; //descending groups\r\n                            }).map(function (x) {\r\n                                var unwrapped = Symbol.unwrapSQRT(x, true);\r\n                                if(unwrapped.fname === EXP) {\r\n                                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\r\n                                }\r\n                                return unwrapped;\r\n                            });\r\n                            var l = symbols.length;\r\n                            if(symbol.power < 0) {\r\n                                if(l === 2) {\r\n                                    return __.integrate(_.expand(symbol), dx, depth, opt);\r\n                                }\r\n                            }\r\n                            //otherwise the denominator is one lumped together symbol \r\n                            else {\r\n                                //generate an image for \r\n                                if(l === 2) {\r\n                                    //try u substitution\r\n                                    try {\r\n                                        retval = __.integration.u_substitution(symbols, dx);\r\n                                    }\r\n                                    catch(e) {/* failed :`(*/\r\n                                        ;\r\n                                    }\r\n\r\n                                    if(!retval) {\r\n                                        //no success with u substitution so let's try known combinations\r\n                                        //are they two functions\r\n                                        var g1 = symbols[0].group,\r\n                                                g2 = symbols[1].group,\r\n                                                sym1 = symbols[0],\r\n                                                sym2 = symbols[1],\r\n                                                fn1 = sym1.fname,\r\n                                                fn2 = sym2.fname;\r\n                                        //reset the symbol minus the coeff\r\n                                        symbol = _.multiply(sym1.clone(), sym2.clone());\r\n                                        if(g1 === FN && g2 === FN) {\r\n                                            if(fn1 === LOG || fn2 === LOG) {\r\n                                                retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\r\n                                            }\r\n                                            else {\r\n                                                symbols.sort(function (a, b) {\r\n                                                    return b.fname > a.fname;\r\n                                                });\r\n                                                var arg1 = sym1.args[0];\r\n                                                //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\r\n                                                if(!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))\r\n                                                    __.integration.stop();\r\n\r\n                                                var decomp = __.integration.decompose_arg(arg1, dx);\r\n                                                x = decomp[1],\r\n                                                        a = decomp[0];\r\n                                                if(!x.isLinear()) //again... linear arguments only wrt x\r\n                                                    __.integration.stop();\r\n\r\n                                                //they have to have the same arguments and then we have cleared all the check to \r\n                                                //make sure we can integrate FN & FN\r\n                                                var arg2 = sym2.args[0];\r\n                                                //make sure that their argument matches\r\n                                                if(arg1.equals(arg2)) {\r\n                                                    if(fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\r\n                                                        if(sym1.power.lessThan(0))\r\n                                                            __.integration.stop();//we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\r\n                                                        //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\r\n                                                        if(fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\r\n                                                            sym1.fname = TAN;\r\n                                                            sym1.updateHash();\r\n                                                            retval = __.integrate(sym1, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            if(even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\r\n                                                                //transform sin^(2*n) to (1-cos^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else if(even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\r\n                                                                //transform cos^(2*n) to (1-sin^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else {\r\n                                                                var p1_even = core.Utils.even(sym1.power),\r\n                                                                        p2_even = core.Utils.even(sym2.power);\r\n                                                                retval = new Symbol(0);\r\n                                                                if(!p1_even || !p2_even) {\r\n                                                                    var u, r, trans;\r\n                                                                    //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\r\n                                                                    //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\r\n                                                                    if(!p1_even) {\r\n                                                                        //u = sin(x)\r\n                                                                        u = sym2;\r\n                                                                        r = sym1;\r\n                                                                    }\r\n                                                                    else {\r\n                                                                        u = sym1;\r\n                                                                        r = sym2;\r\n                                                                    }\r\n                                                                    //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\r\n                                                                    var sign = u.fname === COS ? -1 : 1,\r\n                                                                            n = r.power,\r\n                                                                            //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \r\n                                                                            //even powers afterwards which can be transformed\r\n                                                                            k = (n - 1) / 2,\r\n                                                                            //make the transformation cos(x)^2 = 1 - sin(x)^2\r\n                                                                            trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\r\n                                                                            sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\r\n                                                                    //we can now just loop through and integrate each since it's now just a polynomial with functions\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\r\n                                                                    });\r\n                                                                }\r\n                                                                else {\r\n                                                                    //performs double angle transformation\r\n                                                                    var double_angle = function (symbol) {\r\n                                                                        var p = symbol.power,\r\n                                                                                k = p / 2, e;\r\n                                                                        if(symbol.fname === COS)\r\n                                                                            e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n                                                                        else\r\n                                                                            e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n\r\n                                                                        return _.parse(e);\r\n                                                                    };\r\n                                                                    //they're both even so transform both using double angle identities and we'll just\r\n                                                                    //be able to integrate by the sum of integrals\r\n                                                                    var a = double_angle(sym1),\r\n                                                                            b = double_angle(sym2),\r\n                                                                            t = _.multiply(a, b);\r\n                                                                    var sym = _.expand(t);\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                                    });\r\n                                                                    return _.multiply(retval, coeff);\r\n                                                                }\r\n                                                            }\r\n                                                        }\r\n                                                    }\r\n                                                    //tan(x)*sec(x)^n \r\n                                                    else if(fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\r\n                                                        retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\r\n                                                    }\r\n                                                    else if(fn1 === TAN && fn2 === SEC && x.isLinear()) {\r\n                                                        //remaining: tan(x)^3*sec(x)^6\r\n                                                        if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                            retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\r\n                                                        }\r\n                                                        else if(even(sym1.power)) {\r\n                                                            var p = Number(sym1.power) / 2;\r\n                                                            //transform tangent\r\n                                                            var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\r\n                                                            retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\r\n                                                        }\r\n                                                        else\r\n                                                            __.integration.stop();\r\n                                                    }\r\n                                                    else if(fn1 === SEC && fn2 === COS) {\r\n                                                        sym1.fname = COS;\r\n                                                        sym1.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    else if(fn1 === SIN && fn2 === CSC) {\r\n                                                        sym2.fname = SIN;\r\n                                                        sym2.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    //tan/cos\r\n                                                    else if(fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2);\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                    else {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                }\r\n                                                //TODO: In progress\r\n                                                else if((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\r\n\r\n                                                    if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                        //if in the form cos(a*x)*sin(b*x)\r\n                                                        if(sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\r\n                                                            //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\r\n                                                            var ax, bx;\r\n                                                            if(fn2 === SIN) {\r\n                                                                ax = sym1.args[0];\r\n                                                                bx = sym2.args[0];\r\n                                                            }\r\n                                                            else {\r\n                                                                bx = sym1.args[0];\r\n                                                                ax = sym2.args[0];\r\n                                                            }\r\n\r\n                                                            //make the transformation\r\n                                                            f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\r\n\r\n                                                            //integrate it\r\n                                                            retval = __.integrate(f, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            var transformed = trigTransform(symbols);\r\n                                                            retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                    else {\r\n                                                        var transformed = new Symbol(1);\r\n                                                        symbols.map(function (sym) {\r\n                                                            var s = sym.fnTransform();\r\n                                                            transformed = _.multiply(transformed, s);\r\n                                                        });\r\n                                                        var t = _.expand(transformed);\r\n\r\n                                                        retval = __.integrate(t, dx, depth);\r\n\r\n                                                        if(retval.hasIntegral()) {\r\n                                                            retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                else {\r\n                                                    __.integration.stop();\r\n                                                }\r\n\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === FN && g2 === S) {\r\n                                            var sym1_is_linear = sym1.isLinear();\r\n                                            if(sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Ci', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COS && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Chi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COSH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Si', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SIN && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Shi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SINH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === LOG && sym2.power.equals(-1)) {\r\n                                                //log(x)^n/x = log(x)^(n+1)/(n+1)\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === 'erf') {\r\n                                                if(sym2.power.equals(1)) {\r\n                                                    var dc = __.integration.decompose_arg(sym1.args[0], dx),\r\n                                                            a_ = dc[0],\r\n                                                            x_ = dc[1],\r\n                                                            arg = sym1.args[0].toString();\r\n                                                    retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg))\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                //since group S is guaranteed convergence we need not worry about tracking depth of integration\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === EX && g2 === S) {\r\n                                            var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\r\n                                            if(sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\r\n                                                retval = _.symfunction('Ei', [sym1.power.clone()]);\r\n                                            }\r\n                                            else if(fn1 === LOG && x.value === sym2.value) {\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                        else if(g1 === PL && g2 === S) {\r\n                                            //first try to reduce the top\r\n                                            if(sym2.value === sym1.value && sym1.power.equals(-1)) {\r\n                                                //find the lowest power in the denominator\r\n                                                var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\r\n                                                //get the lowest common value between denominator and numerator\r\n                                                var pc = Math.min(pd, sym2.power);\r\n                                                //reduce both denominator and numerator by that factor\r\n                                                var factor = sym2.clone();\r\n                                                factor.power = new Frac(pc);\r\n                                                sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\r\n                                                var t = new Symbol(0);\r\n                                                sym1.each(function (x) {\r\n                                                    t = _.add(t, _.divide(x.clone(), factor.clone()));\r\n                                                });\r\n                                                t.multiplier = sym1.multiplier;\r\n                                                symbol = _.divide(sym2, t);\r\n                                            }\r\n                                            else {\r\n                                                symbol = _.expand(symbol);\r\n                                            }\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                        }\r\n                                        else if(g1 === CP && g2 === S) {\r\n                                            var f = sym1.clone().toLinear(),\r\n                                                    f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\r\n                                            //handle cases x^(2*n)/sqrt(1-x^2)\r\n                                            if(sym1.power.equals(-1 / 2)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\r\n                                                var a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\r\n                                                    //if the substitution \r\n                                                    var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)),\r\n                                                            _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])),\r\n                                                            _.pow(a.clone(), new Symbol(2)));\r\n                                                    c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\r\n                                                    var dummy = _.parse('sin(u)');\r\n                                                    dummy.power = dummy.power.multiply(sym2.power);\r\n                                                    var integral = __.integrate(dummy, 'u', depth);\r\n                                                    var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\r\n                                                    retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\r\n                                                }\r\n                                                else if(p1 === -1 / 2) {\r\n                                                    var u_transform = function (f, u) {\r\n                                                        var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\r\n                                                        if(!integral.hasIntegral())\r\n                                                            return integral;\r\n                                                    }\r\n                                                    if(p2 === -1) {\r\n                                                        retval = u_transform(\r\n                                                                _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                    else if(p2 === -2) {\r\n                                                        //apply transformation to see if it matches asin(x)\r\n                                                        retval = u_transform(\r\n                                                                _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            else if(sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\r\n                                                retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else if(!sym1.power.lessThan(0) && isInt(sym1.power)) {\r\n                                                //sum of integrals\r\n                                                var expanded = _.expand(sym1);\r\n                                                retval = new Symbol(0);\r\n                                                expanded.each(function (x) {\r\n                                                    if(x.group === PL) {\r\n                                                        x.each(function (y) {\r\n                                                            retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\r\n                                                        });\r\n                                                    }\r\n                                                    else\r\n                                                        retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\r\n                                                });\r\n                                            }\r\n                                            else if(sym1.power.lessThan(-2)) {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                            else if(sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                        a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        fn = sym1.clone().toLinear();\r\n\r\n                                                if(x.group !== PL && x.isLinear()) {\r\n                                                    var p = Number(sym2.power),\r\n                                                            du = '_u_',\r\n                                                            u = new Symbol(du),\r\n                                                            //pull the integral with the subsitution\r\n                                                            U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\r\n                                                            scope = {};\r\n\r\n                                                    //generate a scope for resubbing the symbol\r\n                                                    scope[du] = fn;\r\n                                                    var U2 = _.parse(U, scope);\r\n                                                    retval = __.integrate(U2, dx, 0);\r\n                                                }\r\n                                                else if(sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\r\n\r\n                                                    //factor out coefficients\r\n                                                    var factors = new core.Algebra.Classes.Factors();\r\n                                                    sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\r\n                                                    var div = core.Algebra.divide(sym2, sym1);\r\n                                                    //it assumed that the result will be of group CB\r\n                                                    if(div.group !== CB) {\r\n                                                        retval = new Symbol(0);\r\n                                                        div.each(function (t) {\r\n                                                            retval = _.add(retval, __.integrate(t, dx, depth));\r\n                                                        });\r\n                                                        //put back the factors\r\n                                                        factors.each(function (factor) {\r\n                                                            retval = _.divide(retval, factor);\r\n                                                        });\r\n\r\n                                                        retval = _.expand(retval);\r\n                                                    }\r\n                                                    else {\r\n                                                        //try something else\r\n                                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else {\r\n                                                //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \r\n                                                if(sym1.power.den.equals(2)) {\r\n                                                    //assume the function is in the form (a^2-b*x^n)^(m/2)\r\n                                                    var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                            //using the above definition\r\n                                                            a = dc[3], x = dc[1], b = dc[0], bx = dc[2];\r\n                                                    if(x.power.equals(2) && b.lessThan(0)) { //if n is even && b is negative\r\n                                                        //make a equal 1 so we can do a trig sub\r\n                                                        if(!a.equals(1)) { //divide a out of everything\r\n                                                            //move a to the coeff\r\n                                                            coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\r\n                                                        }\r\n                                                        var u = dx;\r\n                                                        var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\r\n                                                                du = _.symfunction(COS, [new Symbol(u)]),\r\n                                                                cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\r\n                                                                X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\r\n                                                                val = _.multiply(_.multiply(cosn, du), X),\r\n                                                                integral = __.integrate(val, u, depth);\r\n                                                        //but remember that u = asin(sqrt(b)*a*x)\r\n                                                        retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\r\n                                                    }\r\n                                                    else {\r\n                                                        retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else if(f_is_linear) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n                                        else if(sym1.isComposite() && sym2.isComposite()) {\r\n                                            //sum of integrals\r\n                                            retval = new Symbol(0);\r\n                                            if(sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\r\n                                                //combine and pull the integral of each\r\n                                                var sym = _.expand(symbol);\r\n                                                sym.each(function (x) {\r\n                                                    retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                }, true);\r\n                                            }\r\n                                            else {\r\n                                                var p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(p1 < 0 && p2 > 0) {\r\n                                                    //swap\r\n                                                    var t = sym1;\r\n                                                    sym1 = sym2;\r\n                                                    sym2 = t;\r\n                                                }\r\n                                                if(p1 === -1 && p2 === -1) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx);\r\n                                                }\r\n                                                else {\r\n                                                    sym1.each(function (x) {\r\n                                                        var k = _.multiply(x, sym2.clone());\r\n                                                        var integral = __.integrate(k, dx, depth);\r\n                                                        retval = _.add(retval, integral);\r\n                                                    });\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === CP && symbols[0].power.greaterThan(0)) {\r\n                                            sym1 = _.expand(sym1);\r\n                                            retval = new Symbol(0);\r\n                                            sym1.each(function (x) {\r\n                                                retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\r\n                                            }, true);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\r\n                                            sym1 = sym1.fnTransform();\r\n                                            retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\r\n                                            if(g2 === FN && g1 === CP) {\r\n                                                var t = sym1;\r\n                                                sym1 = sym2;\r\n                                                sym2 = t; //swap\r\n                                            }\r\n                                            var du, sym2_clone, p, q, sa, sb;\r\n                                            du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\r\n                                            sym2_clone = Symbol.unwrapSQRT(sym2, true);\r\n                                            if(du.power.equals(sym2_clone.power)) {\r\n                                                p = new Symbol(sym2.power);\r\n                                                sa = du.clone().toLinear();\r\n                                                sb = sym2.clone().toLinear();\r\n                                                q = core.Algebra.divide(sa.toLinear(), sb);\r\n                                                if(q.isConstant()) {\r\n                                                    var nq = _.pow(q, p.negate());\r\n                                                    retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            var syma = sym1.clone().toLinear();\r\n                                            var symb = sym2.clone().toLinear();\r\n                                            if(g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx)\r\n                                                    && !syma.contains(dx) && !symb.contains(dx)) {\r\n                                                retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))',\r\n                                                        syma.toString(),\r\n                                                        symb.toString(),\r\n                                                        sym1.power.multiplier.toString(),\r\n                                                        sym2.power.multiplier.toString(),\r\n                                                        dx\r\n                                                        ));\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\r\n                                    var first = symbols[0];\r\n                                    if(first.group === CP) { //TODO {support higher powers of x in the future}\r\n                                        if(first.power.greaterThan(1))\r\n                                            first = _.expand(first);\r\n                                        var r = _.multiply(symbols[1], symbols[2]);\r\n                                        retval = new Symbol(0);\r\n                                        first.each(function (x) {\r\n                                            var t = _.multiply(x, r.clone());\r\n                                            var intg = __.integrate(t, dx, depth);\r\n                                            retval = _.add(retval, intg);\r\n                                        }, true);\r\n                                    }\r\n                                    else {\r\n                                        //try integration by parts although technically it will never work\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n\r\n                                }\r\n                                else if(all_functions(symbols)) {\r\n                                    var t = new Symbol(1);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        t = _.multiply(t, symbols[i].fnTransform());\r\n                                    }\r\n                                    t = _.expand(t);\r\n                                    retval = __.integrate(t, dx, depth);\r\n                                }\r\n                                else {\r\n                                    //one more go\r\n                                    var transformed = trigTransform(symbols);\r\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        retval = _.multiply(retval, coeff);\r\n                    }\r\n                    //if an integral was found then we return it\r\n                    if(retval)\r\n                        return retval;\r\n                }\r\n\r\n                catch(error) {\r\n                    //do nothing if it's a NoIntegralFound error otherwise let it bubble\r\n                    if(!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))\r\n                        throw error;\r\n                }\r\n\r\n                //no symbol found so we return the integral again\r\n                return _.symfunction('integrate', [original_symbol, dt]);\r\n            }, false);\r\n        },\r\n        defint: function (symbol, from, to, dx) {\r\n            dx = dx || 'x'; //make x the default variable of integration\r\n            var get_value = function (integral, vars, point) {\r\n                try {\r\n                    return _.parse(integral, vars);\r\n                }\r\n                catch(e) {\r\n                    //it failed for some reason so return the limit\r\n                    var lim = __.Limit.limit(integral, dx, point);\r\n                    return lim;\r\n                }\r\n            };\r\n\r\n            var vars = core.Utils.variables(symbol),\r\n                    hasTrig = symbol.hasTrig();\r\n            var retval, integral;\r\n\r\n            // Fix #593 - Only assume the first variable if dx is not defined.\r\n            if(vars.length === 1 && !dx)\r\n                dx = vars[0];\r\n\r\n            if(!hasTrig) {\r\n                integral = __.integrate(symbol, dx);\r\n            }\r\n\r\n            if(!hasTrig && !integral.hasIntegral()) {\r\n                var upper = {},\r\n                        lower = {},\r\n                        a, b;\r\n                upper[dx] = to;\r\n                lower[dx] = from;\r\n\r\n                a = get_value(integral, upper, to, dx);\r\n                b = get_value(integral, lower, from, dx);\r\n                retval = _.subtract(a, b);\r\n            }\r\n            else if(vars.length === 1 && from.isConstant() && to.isConstant()) {\r\n\r\n                var f = core.Utils.build(symbol);\r\n                retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\r\n            }\r\n            else\r\n                retval = _.symfunction('defint', [symbol, from, to, dx]);\r\n            return retval;\r\n        },\r\n\r\n        Limit: {\r\n            interval: function (start, end) {\r\n                return _.parse(format('[{0}, {1}]', start, end));\r\n            },\r\n            diverges: function () {\r\n                return __.Limit.interval('-Infinity', 'Infinity');\r\n            },\r\n            divide: function (f, g, x, lim, depth) {\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                var fin = f.clone(), gin = g.clone();\r\n\r\n                //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\r\n                //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\r\n                //the two-sided limit.\r\n                //Known limit\r\n                if(g.fname === ABS) {\r\n                    var sign = f.sign();\r\n                    var lim_sign = lim.sign();\r\n\r\n                    if(lim.isInfinity)\r\n                        return _.multiply(new Symbol(sign), new Symbol(lim_sign));\r\n\r\n                    else if(lim.equals(0)) {\r\n                        var fm = _.parse(f.multiplier);\r\n                        var gm = _.parse(g.multiplier);\r\n                        return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\r\n                    }\r\n                    else {\r\n                        //TODO: Support more limits\r\n                        __.Limit.diverges();\r\n                    }\r\n                }\r\n\r\n                var isInfinity = function (L) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        for(var i = 0; i < L.elements.length; i++)\r\n                            if(!L.elements[i].isInfinity)\r\n                                return false;\r\n                        return true;\r\n                    }\r\n                    return L.isInfinity;\r\n                };\r\n\r\n                var equals = function (L, v) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        return false;\r\n                    }\r\n                    return L.equals(v);\r\n                };\r\n\r\n                var retval;\r\n                do {\r\n                    var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\r\n                    var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\r\n\r\n                    //if it's in indeterminate form apply L'Hospital's rule\r\n                    var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\r\n                    //pull the derivatives\r\n                    if(indeterminate) {\r\n                        var ft = __.diff(f.clone(), x);\r\n                        var gt = __.diff(g.clone(), x);\r\n\r\n                        var t_symbol = _.expand(_.divide(ft, gt));\r\n                        f = t_symbol.getNum();\r\n                        g = t_symbol.getDenom();\r\n\r\n                    }\r\n                }\r\n                while(indeterminate)\r\n\r\n                //REMEMBER: \r\n                //- 1/cos(x)\r\n                //n/0 is still possible since we only checked for 0/0\r\n                var den_is_zero = lim2.equals(0);\r\n                var p = Number(gin.power);\r\n\r\n                if(lim.isConstant(true) && den_is_zero) {\r\n                    retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\r\n                }\r\n                else if(den_is_zero) {\r\n                    retval = __.Limit.diverges();\r\n                }\r\n                else {\r\n                    retval = _.divide(lim1, lim2);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            rewriteToLog: function (symbol) {\r\n                var p = symbol.power.clone();\r\n                symbol.toLinear();\r\n                return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\r\n            },\r\n            getSubbed: function (f, x, lim) {\r\n                var retval;\r\n                //1. rewrite EX with base e\r\n                if(f.group === EX) {\r\n                    f = __.rewriteToLog(f);\r\n                }\r\n                //2. try simple substitution\r\n                try {\r\n                    retval = f.sub(x, lim);\r\n                }\r\n                catch(e) {\r\n                    //Nope. No go, so just return the unsubbed function so we can test the limit instead.\r\n                    retval = f;\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            isInterval: function (limit) {\r\n                return core.Utils.isVector(limit);\r\n            },\r\n            isConvergent: function (limit) {\r\n                //it's not convergent if it lies on the interval -Infinity to Infinity\r\n                if(\r\n                        //It lies on the interval -Infinity to Infinity\r\n                        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\r\n                        //We weren't able to calculate the limit\r\n                        limit.containsFunction('limit')\r\n                        ) {\r\n                    return false; //Then no\r\n                }\r\n                return true; //It is\r\n            },\r\n            limit: function (symbol, x, lim, depth) {\r\n                //Simplify the symbol\r\n                if(symbol.isLinear() && symbol.isComposite()) {\r\n\r\n                    //Apply sum of limits\r\n                    var limit = new Symbol(0);\r\n                    symbol.each(function (s) {\r\n                        limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\r\n                    }, true);\r\n\r\n                    return limit;\r\n                }\r\n                ;\r\n\r\n                symbol = core.Algebra.Simplify.simplify(symbol);\r\n\r\n                depth = depth || 1;\r\n\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                //store the multiplier\r\n                var m = _.parse(symbol.multiplier);\r\n                //strip the multiplier\r\n                symbol.toUnitMultiplier();\r\n                try {\r\n                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                    var retval;\r\n                    //we try the simplest option first where c is some limit\r\n                    //lim a as x->c = a where c \r\n                    if(symbol.isConstant(true)) {\r\n                        retval = symbol;\r\n                    }\r\n                    else {\r\n                        var point = {};\r\n                        point[x] = lim;\r\n                        //lim x as x->c = c where c\r\n\r\n                        try {\r\n\r\n                            //evaluate the function at the given limit\r\n                            var t = _.parse(symbol.sub(x, lim), point);\r\n\r\n                            //a constant or infinity is known so we're done\r\n                            if(t.isConstant(true) || t.isInfinity)\r\n                                retval = t;\r\n\r\n                        }\r\n                        catch(e) { /*Nothing. Maybe we tried to divide by zero.*/\r\n                        }\r\n                        ;\r\n\r\n                        if(!retval) {\r\n                            //split the symbol in the numerator and the denominator\r\n                            var num = symbol.getNum();\r\n                            var den = symbol.getDenom();\r\n\r\n                            if(den.isConstant(true)) {\r\n                                //We still don't have a limit so we generate tests.\r\n                                if(symbol.group === EX) {\r\n                                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                                    //Speed boost for exponentials by detecting patterns\r\n                                    var f = symbol.clone().toLinear();\r\n                                    var p = symbol.power.clone();\r\n                                    var _num = f.getNum();\r\n                                    var _den = f.getDenom();\r\n                                    var fn = core.Utils.decompose_fn(_den, x, true);\r\n                                    //start detection of pattern (x/(x+1))^x\r\n                                    if(_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\r\n                                        retval = _.parse(format('(1/e^({0}))', fn.b));\r\n                                    }\r\n                                    else {\r\n                                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());\r\n                                        //get the base\r\n                                        var pow = symbol_.power.clone();\r\n                                        var base = symbol_.clone().toLinear();\r\n                                        var lim_base = __.Limit.limit(base, x, lim, depth);\r\n                                        var lim_pow = __.Limit.limit(pow, x, lim, depth);\r\n                                        retval = _.pow(lim_base, lim_pow);\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === FN && symbol.args.length === 1) {\r\n                                    var evaluates;\r\n                                    //Squeeze theorem lim f(g(x)) = lim f(lim g))\r\n                                    var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\r\n                                    if(core.Utils.isVector(arg)) {\r\n                                        //get the limit over that interval\r\n                                        retval = arg.map(function (e) {\r\n                                            var clone = symbol.clone();\r\n                                            clone.args[0] = e;\r\n                                            return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\r\n                                        });\r\n\r\n                                        return _.multiply(m, retval);\r\n                                    }\r\n                                    //if the argument is constant then we're done\r\n                                    else if(arg.isConstant(true)) {\r\n\r\n                                        //double check that it evaluates\r\n                                        var trial = _.symfunction(symbol.fname, [arg]);\r\n                                        //trial evaluation\r\n                                        try {\r\n                                            evaluate(trial);\r\n                                            evaluates = true;\r\n                                        }\r\n                                        catch(e) {\r\n\r\n                                            evaluates = false;\r\n                                        }\r\n                                    }\r\n                                    if(evaluates) {\r\n                                        retval = trial;\r\n                                    }\r\n                                    else {\r\n                                        //if the limit converges. We'll deal with non-convergent ones later\r\n                                        if(__.Limit.isConvergent(arg)) {\r\n                                            if(symbol.fname === LOG) {\r\n                                                switch(arg.toString()) {\r\n                                                    //lim -> 0\r\n                                                    case '0':\r\n                                                        retval = Symbol.infinity().negate();\r\n                                                        break;\r\n                                                    case 'Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                    case '-Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else if((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\r\n                                                retval = __.Limit.interval(-1, 1);\r\n                                            }\r\n                                            else if((symbol.fname === TAN)) {\r\n                                                var s_arg = symbol.args[0];\r\n                                                var n = s_arg.getNum();\r\n                                                var d = s_arg.getDenom();\r\n                                                var pi = n.toUnitMultiplier();\r\n                                                if(lim.isInfinity || pi.equals('pi') && d.equals(2)) {\r\n                                                    retval = divergent();\r\n                                                }\r\n                                            }\r\n                                            else if(symbol.fname === Settings.FACTORIAL) {\r\n                                                if(arg.isInfinity)\r\n                                                    return Symbol.infinity();\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === S) {\r\n                                    if(symbol.power > 0)\r\n                                        //these functions always converge to the limit\r\n                                        return _.parse(symbol, point);\r\n                                    else {\r\n                                        //we're dealing with 1/x^n but remember that infinity has already been dealt\r\n                                        //with by substitution\r\n                                        if(core.Utils.even(symbol.power)) {\r\n                                            //even powers converge to infinity\r\n                                            retval = Symbol.infinity();\r\n                                        }\r\n                                        else {\r\n                                            //odd ones don't\r\n                                            retval = __.Limit.diverges();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === CB) {\r\n\r\n                                    var lim1, lim2;\r\n                                    //loop through all the symbols\r\n                                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\r\n                                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return a.group - b.group;\r\n                                    });\r\n\r\n                                    var f = symbols.pop();\r\n                                    //calculate the first limit so we can keep going down the list\r\n                                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\r\n\r\n                                    //reduces all the limits one at a time\r\n                                    while(symbols.length) {\r\n                                        //get the second limit\r\n                                        var g = symbols.pop();\r\n                                        //get the limit of g\r\n                                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\r\n\r\n                                        //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\r\n                                        if((lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2))) {\r\n                                            if(g.containsFunction(LOG)) {\r\n                                                //swap them\r\n                                                g = [f, f = g][0];\r\n                                            }\r\n                                            //invert the symbol\r\n                                            g.invert();\r\n\r\n                                            // Product of infinities\r\n                                            if(lim1.isInfinity && lim2.isInfinity) {\r\n                                                lim1 = Symbol.infinity()\r\n                                            }\r\n                                            else {\r\n                                                lim1 = __.Limit.divide(f, g, x, lim, depth);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            //lim f*g = (lim f)*(lim g)\r\n                                            lim1 = _.multiply(lim1, lim2);\r\n                                            //let f*g equal f and h equal g \r\n                                            f = _.multiply(f, g);\r\n                                        }\r\n                                    }\r\n\r\n                                    //Done, lim1 is the limit we're looking for     \r\n                                    retval = lim1;\r\n                                }\r\n                                else if(symbol.isComposite()) {\r\n                                    var _lim;\r\n                                    if(!symbol.isLinear())\r\n                                        symbol = _.expand(symbol);\r\n                                    //Apply lim f+g = (lim f)+(lim g)\r\n                                    retval = new Symbol(0);\r\n\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return b.group - a.group;\r\n                                    });\r\n\r\n                                    var _symbols = [];\r\n                                    //Analyze the functions first\r\n                                    var fns = new Symbol(0);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i].clone();\r\n                                        if(sym.group === FN || sym.group === CB && sym.hasFunc()) {\r\n                                            fns = _.add(fns, sym);\r\n                                        }\r\n                                        else\r\n                                            _symbols.push(sym);\r\n                                    }\r\n                                    _symbols.unshift(fns);\r\n\r\n                                    //make sure that we didn't just repackage the exact same symbol\r\n                                    if(_symbols.length !== 1) {\r\n                                        symbols = _symbols;\r\n                                    }\r\n\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i];\r\n                                        //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\r\n                                        try {\r\n                                            _lim = __.Limit.limit(sym, x, lim, depth);\r\n                                        }\r\n                                        catch(e) {\r\n                                            _lim = __.Limit.diverges();\r\n                                        }\r\n\r\n                                        try {\r\n                                            retval = _.add(retval, _lim);\r\n                                        }\r\n                                        catch(e) {\r\n                                            if(depth++ > Settings.max_lim_depth) {\r\n                                                return;\r\n                                            }\r\n                                            ;\r\n                                            retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                retval = __.Limit.divide(num, den, x, lim, depth);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //if we still don't have a solution\r\n                    if(!retval)\r\n                        //return it symbolically\r\n                        retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n                catch(e) {\r\n                    //if all else fails return the symbolic function\r\n                    retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n        },\r\n        Fresnel: {\r\n            S: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('S', arguments);\r\n            },\r\n            C: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('C', arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'diff',\r\n            visible: true,\r\n            numargs: [1, 3],\r\n            build: function () {\r\n                return __.diff;\r\n            }\r\n        },\r\n        {\r\n            name: 'sum',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.sum;\r\n            }\r\n        },\r\n        {\r\n            name: 'product',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.product;\r\n            }\r\n        },\r\n        {\r\n            name: 'integrate',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.integrate;\r\n            }\r\n        },\r\n        {\r\n            name: 'defint',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.defint;\r\n            }\r\n        },\r\n        {\r\n            name: 'S',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.S;\r\n            }\r\n        },\r\n        {\r\n            name: 'C',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.C;\r\n            }\r\n        },\r\n        {\r\n            name: 'limit',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.Limit.limit;\r\n            }\r\n        }\r\n    ]);\r\n    //link registered functions externally\r\n    nerdamer.api();\r\n\r\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmFuaWxsYS1pbnRlZ3JhdGlvbi0yZC8uL25vZGVfbW9kdWxlcy9uZXJkYW1lci9DYWxjdWx1cy5qcz80MDE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBtb2R1bGUgKi9cclxuXHJcbi8qXHJcbiAqIEF1dGhvciA6IE1hcnRpbiBEb25rXHJcbiAqIFdlYnNpdGUgOiBodHRwOi8vd3d3Lm5lcmRhbWVyLmNvbVxyXG4gKiBFbWFpbCA6IG1hcnRpbi5yLmRvbmtAZ21haWwuY29tXHJcbiAqIFNvdXJjZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qaWdnenNvbi9uZXJkYW1lclxyXG4gKi9cclxuXHJcbmlmKCh0eXBlb2YgbW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5lcmRhbWVyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgdmFyIG5lcmRhbWVyID0gcmVxdWlyZSgnLi9uZXJkYW1lci5jb3JlLmpzJyk7XHJcbiAgICByZXF1aXJlKCcuL0FsZ2VicmEuanMnKTtcclxufVxyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBjb3JlID0gbmVyZGFtZXIuZ2V0Q29yZSgpLFxyXG4gICAgICAgICAgICBfID0gY29yZS5QQVJTRVIsXHJcbiAgICAgICAgICAgIEZyYWMgPSBjb3JlLkZyYWMsXHJcbiAgICAgICAgICAgIFNldHRpbmdzID0gY29yZS5TZXR0aW5ncyxcclxuICAgICAgICAgICAgaXNTeW1ib2wgPSBjb3JlLlV0aWxzLmlzU3ltYm9sLFxyXG4gICAgICAgICAgICBGTiA9IGNvcmUuZ3JvdXBzLkZOLFxyXG4gICAgICAgICAgICBTeW1ib2wgPSBjb3JlLlN5bWJvbCxcclxuICAgICAgICAgICAgdGV4dCA9IGNvcmUuVXRpbHMudGV4dCxcclxuICAgICAgICAgICAgaW5CcmFja2V0cyA9IGNvcmUuVXRpbHMuaW5CcmFja2V0cyxcclxuICAgICAgICAgICAgaXNJbnQgPSBjb3JlLlV0aWxzLmlzSW50LFxyXG4gICAgICAgICAgICBmb3JtYXQgPSBjb3JlLlV0aWxzLmZvcm1hdCxcclxuICAgICAgICAgICAgZXZlbiA9IGNvcmUuVXRpbHMuZXZlbixcclxuICAgICAgICAgICAgZXZhbHVhdGUgPSBjb3JlLlV0aWxzLmV2YWx1YXRlLFxyXG4gICAgICAgICAgICBOID0gY29yZS5ncm91cHMuTixcclxuICAgICAgICAgICAgUyA9IGNvcmUuZ3JvdXBzLlMsXHJcbiAgICAgICAgICAgIEZOID0gY29yZS5ncm91cHMuRk4sXHJcbiAgICAgICAgICAgIFBMID0gY29yZS5ncm91cHMuUEwsXHJcbiAgICAgICAgICAgIENQID0gY29yZS5ncm91cHMuQ1AsXHJcbiAgICAgICAgICAgIENCID0gY29yZS5ncm91cHMuQ0IsXHJcbiAgICAgICAgICAgIEVYID0gY29yZS5ncm91cHMuRVgsXHJcbiAgICAgICAgICAgIFAgPSBjb3JlLmdyb3Vwcy5QLFxyXG4gICAgICAgICAgICBMT0cgPSBTZXR0aW5ncy5MT0csXHJcbiAgICAgICAgICAgIEVYUCA9ICdleHAnLFxyXG4gICAgICAgICAgICBBQlMgPSAnYWJzJyxcclxuICAgICAgICAgICAgU1FSVCA9ICdzcXJ0JyxcclxuICAgICAgICAgICAgU0lOID0gJ3NpbicsXHJcbiAgICAgICAgICAgIENPUyA9ICdjb3MnLFxyXG4gICAgICAgICAgICBUQU4gPSAndGFuJyxcclxuICAgICAgICAgICAgU0VDID0gJ3NlYycsXHJcbiAgICAgICAgICAgIENTQyA9ICdjc2MnLFxyXG4gICAgICAgICAgICBDT1QgPSAnY290JyxcclxuICAgICAgICAgICAgQVNJTiA9ICdhc2luJyxcclxuICAgICAgICAgICAgQUNPUyA9ICdhY29zJyxcclxuICAgICAgICAgICAgQVRBTiA9ICdhdGFuJyxcclxuICAgICAgICAgICAgQVNFQyA9ICdhc2VjJyxcclxuICAgICAgICAgICAgQUNTQyA9ICdhY3NjJyxcclxuICAgICAgICAgICAgQUNPVCA9ICdhY290JyxcclxuICAgICAgICAgICAgU0lOSCA9ICdzaW5oJyxcclxuICAgICAgICAgICAgQ09TSCA9ICdjb3NoJyxcclxuICAgICAgICAgICAgVEFOSCA9ICd0YW5oJyxcclxuICAgICAgICAgICAgQ1NDSCA9ICdjc2NoJyxcclxuICAgICAgICAgICAgU0VDSCA9ICdzZWNoJyxcclxuICAgICAgICAgICAgQ09USCA9ICdjb3RoJyxcclxuICAgICAgICAgICAgQVNFQ0ggPSAnYXNlY2gnLFxyXG4gICAgICAgICAgICBBQ1NDSCA9ICdhY3NjaCcsXHJcbiAgICAgICAgICAgIEFDT1RIID0gJ2Fjb3RoJztcclxuXHJcbiAgICAvL2N1c3RvbSBlcnJvcnNcclxuICAgIGZ1bmN0aW9uIE5vSW50ZWdyYWxGb3VuZChtc2cpIHtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2cgfHwgXCJcIjtcclxuICAgIH1cclxuICAgIE5vSW50ZWdyYWxGb3VuZC5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuXHJcbiAgICAvL1ByZXBhcmF0aW9uc1xyXG4gICAgU3ltYm9sLnByb3RvdHlwZS5oYXNJbnRlZ3JhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc0Z1bmN0aW9uKCdpbnRlZ3JhdGUnKTtcclxuICAgIH07XHJcbiAgICAvL3RyYW5zZm9ybXMgYSBmdW5jdGlvblxyXG4gICAgU3ltYm9sLnByb3RvdHlwZS5mblRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZih0aGlzLmdyb3VwICE9PSBGTilcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgdmFyIHJldHZhbCwgYSA9IHRoaXMuYXJnc1swXTtcclxuICAgICAgICB2YXIgbSA9IG5ldyBTeW1ib2wodGhpcy5tdWx0aXBsaWVyKTtcclxuICAgICAgICB2YXIgc3ltID0gdGhpcy5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICBpZih0aGlzLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgc3dpdGNoKHRoaXMuZm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgU0lOSDpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKGVeKHswfSktZV4oLSh7MH0pKSkvMicsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ09TSDpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKGVeKHswfSkrZV4oLSh7MH0pKSkvMicsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgVEFOSDpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKGVeKHswfSktZV4oLSh7MH0pKSkvKGVeKHswfSkrZV4oLSh7MH0pKSknLCBhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRBTjpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnc2luKHswfSkvY29zKHswfSknLCBhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENTQzpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnMS9zaW4oezB9KScsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU0VDOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcxL2Nvcyh7MH0pJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBzeW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLnBvd2VyLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICBzd2l0Y2godGhpcy5mbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTSU46XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJzEvMi1jb3MoMiooezB9KSkvMicsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ09TOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcxLzIrY29zKDIqKHswfSkpLzInLCBhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRBTjpcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoMS1jb3MoMiooezB9KSkpLygxK2NvcygyKih7MH0pKSknLCBhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJ3Npbih7MH0pXjIvY29zKHswfSleMicsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ09TSDpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnMS8yK2Nvc2goMiooezB9KSkvMicsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU0lOSDpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnLTEvMitjb3NoKDIqKHswfSkpLzInLCBhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRBTkg6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJygxK2Nvc2goMiooezB9KSkpLygtMStjb3NoKDIqKHswfSkpKScsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgU0VDOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoMS1jb3MoMiooezB9KSkpLygxK2NvcygyKih7MH0pKSkrMScsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gc3ltO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5mbmFtZSA9PT0gU0VDKSB7XHJcbiAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcxL2Nvcyh7MH0pXih7MX0pJywgdGhpcy5hcmdzWzBdLCB0aGlzLnBvd2VyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5mbmFtZSA9PT0gQ1NDKSB7XHJcbiAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcxL3Npbih7MH0pXih7MX0pJywgdGhpcy5hcmdzWzBdLCB0aGlzLnBvd2VyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5mbmFtZSA9PT0gVEFOKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucG93ZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCdjb3MoezB9KV4oLSh7MX0pKS9zaW4oezB9KV4oezF9KScsIHRoaXMuYXJnc1swXSwgdGhpcy5wb3dlci5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJ3Npbih7MH0pXih7MX0pL2Nvcyh7MH0pXih7MX0pJywgdGhpcy5hcmdzWzBdLCB0aGlzLnBvd2VyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmZuYW1lID09PSBTSU4gJiYgdGhpcy5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnY3NjKHswfSleKC0oezF9KSknLCB0aGlzLmFyZ3NbMF0sIHRoaXMucG93ZXIubmVnYXRlKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmZuYW1lID09PSBDT1MgJiYgdGhpcy5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnc2VjKHswfSleKC0oezF9KSknLCB0aGlzLmFyZ3NbMF0sIHRoaXMucG93ZXIubmVnYXRlKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmZuYW1lID09PSBTSU4gJiYgdGhpcy5wb3dlci5lcXVhbHMoMykpIHtcclxuICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJygzKnNpbih7MH0pLXNpbigzKih7MH0pKSkvNCcsIHRoaXMuYXJnc1swXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMuZm5hbWUgPT09IENPUyAmJiB0aGlzLnBvd2VyLmVxdWFscygzKSkge1xyXG4gICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKGNvcygzKih7MH0pKSszKmNvcyh7MH0pKS80JywgdGhpcy5hcmdzWzBdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29zKGEqeCleKDIqbikgb3Igc2luKGEqeCleKDIqbilcclxuICAgICAgICBlbHNlIGlmKCh0aGlzLmZuYW1lID09PSBDT1MgfHwgdGhpcy5mbmFtZSA9PT0gU0lOKSAmJiBldmVuKHRoaXMucG93ZXIpKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5wb3dlciAvIDI7XHJcbiAgICAgICAgICAgIC8vY29udmVydCB0byBhIGRvdWJsZSBhbmdsZVxyXG4gICAgICAgICAgICB2YXIgZG91YmxlX2FuZ2xlID0gXy5wb3codGhpcy5jbG9uZSgpLnRvTGluZWFyKCksIF8ucGFyc2UoMikpLmZuVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIC8vcmFpc2UgdG8gdGhlIG4gYW5kIGV4cGFuZFxyXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSBfLmV4cGFuZChfLnBvdyhkb3VibGVfYW5nbGUsIF8ucGFyc2UobikpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcblxyXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZC5lYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHMuZm5UcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgdCk7XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHZhbCA9IHN5bTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkocmV0dmFsLCBtKTtcclxuICAgIH07XHJcblxyXG4gICAgU3ltYm9sLnByb3RvdHlwZS5oYXNUcmlnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKHRoaXMuaXNDb25zdGFudCh0cnVlKSB8fCB0aGlzLmdyb3VwID09PSBTKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYodGhpcy5mbmFtZSAmJiAoY29yZS5VdGlscy5pbl90cmlnKHRoaXMuZm5hbWUpIHx8IGNvcmUuVXRpbHMuaW5faW52ZXJzZV90cmlnKHRoaXMuZm5hbWUpKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYodGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnN5bWJvbHNbeF0uaGFzVHJpZygpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvcmUuRXhwcmVzc2lvbi5wcm90b3R5cGUuaGFzSW50ZWdyYWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sLmhhc0ludGVncmFsKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0cyB0byByZXdyaXRlIGEgc3ltYm9sIHVuZGVyIG9uZSBjb21tb24gZGVub21pbmF0b3JcclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2wgXHJcbiAgICAgKi9cclxuICAgIGNvcmUuVXRpbHMudG9Db21tb25EZW5vbWluYXRvciA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAvL3RyYW5zZm9ybSB4L2EreCAtPiAoYXgreCkvYVxyXG4gICAgICAgIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpICYmIHN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gbmV3IFN5bWJvbChzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgIHZhciBudW1lcmF0b3IgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgZGVub21pbmF0b3IgPSBfLm11bHRpcGx5KGRlbm9taW5hdG9yLCB4LmdldERlbm9tKCkpO1xyXG4gICAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBkZW5vbWl0b3IgaW4gZWFjaCB0ZXJtXHJcbiAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0geC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZW4gPSB4LmdldERlbm9tKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gXy5tdWx0aXBseShudW0sIF8uZGl2aWRlKGRlbm9taW5hdG9yLmNsb25lKCksIGRlbikpO1xyXG4gICAgICAgICAgICAgICAgbnVtZXJhdG9yID0gXy5hZGQobnVtZXJhdG9yLCBmYWN0b3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9IF8ubXVsdGlwbHkobSwgY29yZS5BbGdlYnJhLmRpdmlkZShfLmV4cGFuZChudW1lcmF0b3IpLCBfLmV4cGFuZChkZW5vbWluYXRvcikpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgIH07XHJcbiAgICAvL0EgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBmdW5jdGlvbiBuYW1lIGlzIGFuIGludmVyc2UgdHJpZyBmdW5jdGlvblxyXG4gICAgY29yZS5VdGlscy5pbl9pbnZlcnNlX3RyaWcgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciBpbnZfdHJpZ19mbnMgPSBbQVNJTiwgQUNPUywgQVRBTiwgQUNTQywgQVNFQywgQUNPVF07XHJcbiAgICAgICAgcmV0dXJuIGludl90cmlnX2Zucy5pbmRleE9mKHgpICE9PSAtMTtcclxuICAgIH07XHJcbiAgICAvL0EgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSBmdW5jdGlvbiBuYW1lIGlzIGEgdHJpZyBmdW5jdGlvblxyXG4gICAgY29yZS5VdGlscy5pbl90cmlnID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgdHJpZ19mbnMgPSBbQ09TLCBTSU4sIFRBTiwgU0VDLCBDU0MsIENPVF07XHJcbiAgICAgICAgcmV0dXJuIHRyaWdfZm5zLmluZGV4T2YoeCkgIT09IC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb3JlLlV0aWxzLmluX2h0cmlnID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgdHJpZ19mbnMgPSBbU0lOSCwgQ09TSCwgVEFOSCwgQUNTQ0gsIEFTRUNILCBBQ09USF07XHJcbiAgICAgICAgcmV0dXJuIHRyaWdfZm5zLmluZGV4T2YoeCkgIT09IC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBNYXRyaXggZnVuY3Rpb25zXHJcbiAgICBjb3JlLk1hdHJpeC5qYWNvYmlhbiA9IGZ1bmN0aW9uIChlcW5zLCB2YXJzKSB7XHJcbiAgICAgICAgdmFyIGphY29iaWFuID0gbmV3IGNvcmUuTWF0cml4KCk7XHJcbiAgICAgICAgLy9nZXQgdGhlIHZhcmlhYmxlcyBpZiBub3Qgc3VwcGxpZWRcclxuICAgICAgICBpZighdmFycykge1xyXG4gICAgICAgICAgICB2YXJzID0gY29yZS5VdGlscy5hcnJheUdldFZhcmlhYmxlcyhlcW5zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhcnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICBlcW5zLmZvckVhY2goZnVuY3Rpb24gKGVxLCBqKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGNvcmUuQ2FsY3VsdXMuZGlmZihlcS5jbG9uZSgpLCB2KTtcclxuICAgICAgICAgICAgICAgIGphY29iaWFuLnNldChqLCBpLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBqYWNvYmlhbjtcclxuICAgIH07XHJcblxyXG4gICAgY29yZS5NYXRyaXgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWF4ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB4LmFicygpO1xyXG4gICAgICAgICAgICBpZihlLmd0KG1heCkpXHJcbiAgICAgICAgICAgICAgICBtYXggPSBlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtYXg7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvcmUuTWF0cml4LmNNYXRyaXggPSBmdW5jdGlvbiAodmFsdWUsIHZhcnMpIHtcclxuICAgICAgICB2YXIgbSA9IG5ldyBjb3JlLk1hdHJpeCgpO1xyXG4gICAgICAgIC8vbWFrZSBhbiBpbml0aWFsIGd1ZXNzXHJcbiAgICAgICAgdmFycy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIG0uc2V0KGksIDAsIF8ucGFyc2UodmFsdWUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGFsbF9mdW5jdGlvbnMgPSBjb3JlLlV0aWxzLmFsbF9mdW5jdGlvbnMgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgIGlmKGFycltpXS5ncm91cCAhPT0gRk4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgICAgICAgICBjb3NBc2luQnRyYW5zZm9ybSA9IGNvcmUuVXRpbHMuY29zQXNpbkJ0cmFuZm9ybSA9IGZ1bmN0aW9uIChzeW1ib2wxLCBzeW1ib2wyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgYjtcclxuICAgICAgICAgICAgICAgIGEgPSBzeW1ib2wxLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBiID0gc3ltYm9sMi5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcoc2luKCh7MH0pKyh7MX0pKS1zaW4oKHswfSktKHsxfSkpKS8yJywgYSwgYikpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb3NBc2luQXRyYW5zZm9ybSA9IGNvcmUuVXRpbHMuY29zQXNpbkF0cmFuZm9ybSA9IGZ1bmN0aW9uIChzeW1ib2wxLCBzeW1ib2wyKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE86IHRlbXBvcmFyeSBmaXggZm9yIGludGVncmF0ZShlXngqc2luKHgpKmNvcyh4KV4yKS5cclxuICAgICAgICAgICAgICAgIC8vd2UgdGVjaG5pY2FsbHkga25vdyBob3cgdG8gZG8gdGhpcyB0cmFuc2Zvcm0gYnV0IG1vcmUgaXMgbmVlZGVkIGZvciBjb3JyZWN0IG91dHB1dFxyXG4gICAgICAgICAgICAgICAgaWYoTnVtYmVyKHN5bWJvbDIucG93ZXIpICE9PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHN5bWJvbDEsIHN5bWJvbDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGE7XHJcbiAgICAgICAgICAgICAgICBhID0gc3ltYm9sMS5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcoc2luKDIqKHswfSkpKS8yJywgYSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzaW5Bc2luQnRyYW5zZm9ybSA9IGNvcmUuVXRpbHMuY29zQXNpbkJ0cmFuZm9ybSA9IGZ1bmN0aW9uIChzeW1ib2wxLCBzeW1ib2wyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgYjtcclxuICAgICAgICAgICAgICAgIGEgPSBzeW1ib2wxLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBiID0gc3ltYm9sMi5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcoY29zKCh7MH0pKyh7MX0pKS1jb3MoKHswfSktKHsxfSkpKS8yJywgYSwgYikpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0cmlnVHJhbnNmb3JtID0gY29yZS5VdGlscy50cmlnVHJhbnNmb3JtID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IHt9LCBzeW1ib2wsIHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGFycltpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5hbWUgPSBzeW1ib2wuZm5hbWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmbmFtZSA9PT0gQ09TICYmIG1hcFtTSU5dKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobWFwW1NJTl0uYXJnc1swXS50b1N0cmluZygpICE9PSBzeW1ib2wuYXJnc1swXS50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNvc0FzaW5CdHJhbnNmb3JtKHN5bWJvbCwgbWFwW1NJTl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNvc0FzaW5BdHJhbnNmb3JtKHN5bWJvbCwgbWFwW1NJTl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtTSU5dO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSBTSU4gJiYgbWFwW0NPU10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hcFtDT1NdLmFyZ3NbMF0udG9TdHJpbmcoKSAhPT0gc3ltYm9sLmFyZ3NbMF0udG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjb3NBc2luQnRyYW5zZm9ybShzeW1ib2wsIG1hcFtDT1NdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBjb3NBc2luQXRyYW5zZm9ybShzeW1ib2wsIG1hcFtDT1NdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbQ09TXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gU0lOICYmIG1hcFtTSU5dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtYXBbU0lOXS5hcmdzWzBdLnRvU3RyaW5nKCkgIT09IHN5bWJvbC5hcmdzWzBdLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gc2luQXNpbkJ0cmFuc2Zvcm0oc3ltYm9sLCBtYXBbU0lOXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtTSU5dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGlzIHNob3VsZCBhY3R1YWxseSBiZSByZWR1bmRhbnQgY29kZSBidXQgbGV0J3MgcHV0IGp1c3QgaW4gY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLm11bHRpcGx5KHN5bWJvbCwgbWFwW1NJTl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbU0lOXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW2ZuYW1lXSA9IHN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBtYXApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIG1hcFt4XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgY29yZS5TZXR0aW5ncy5pbnRlZ3JhdGlvbl9kZXB0aCA9IDEwO1xyXG5cclxuICAgIGNvcmUuU2V0dGluZ3MubWF4X2xpbV9kZXB0aCA9IDEwO1xyXG5cclxuICAgIHZhciBfXyA9IGNvcmUuQ2FsY3VsdXMgPSB7XHJcblxyXG4gICAgICAgIHZlcnNpb246ICcxLjQuNicsXHJcblxyXG4gICAgICAgIHN1bTogZnVuY3Rpb24gKGZuLCBpbmRleCwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICAgICBpZighKGluZGV4Lmdyb3VwID09PSBjb3JlLmdyb3Vwcy5TKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLmV4Y2VwdGlvbnMuTmVyZGFtZXJUeXBlRXJyb3IoJ0luZGV4IG11c3QgYmUgc3ltYm9sLiAnICsgdGV4dChpbmRleCkgKyAnIHByb3ZpZGVkJyk7XHJcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXgudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaXNOdW1lcmljU3ltYm9sKHN0YXJ0KSAmJiBjb3JlLlV0aWxzLmlzTnVtZXJpY1N5bWJvbChlbmQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZXIgPSBlbmQgLSBzdGFydCA8IDIwMCA/ICcnIDogJ1BBUlNFMk5VTUJFUic7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IE51bWJlcihzdGFydCk7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBOdW1iZXIoZW5kKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IGNvcmUuVXRpbHMuYmxvY2sobW9kaWZpZXIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZuLnRleHQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnMgPSB7J34nOiB0cnVlfSwgLy9sb2NrIHN1YnMuIElzIHRoaXMgZXZlbiBiZWluZyB1c2VkP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IGNvcmUuU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzW2luZGV4XSA9IG5ldyBTeW1ib2woaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbnMgPSBfLnBhcnNlKGYsIHN1YnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIGFucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ3N1bScsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwcm9kdWN0OiBmdW5jdGlvbiAoZm4sIGluZGV4LCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgICAgIGlmKCEoaW5kZXguZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLlMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5OZXJkYW1lclR5cGVFcnJvcignSW5kZXggbXVzdCBiZSBzeW1ib2wuICcgKyB0ZXh0KGluZGV4KSArICcgcHJvdmlkZWQnKTtcclxuICAgICAgICAgICAgaW5kZXggPSBpbmRleC52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc051bWVyaWNTeW1ib2woc3RhcnQpICYmIGNvcmUuVXRpbHMuaXNOdW1lcmljU3ltYm9sKGVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllciA9IGVuZCAtIHN0YXJ0IDwgMjAwID8gJycgOiAnUEFSU0UyTlVNQkVSJztcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IGNvcmUuVXRpbHMuYmxvY2sobW9kaWZpZXIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IE51bWJlcihzdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gTnVtYmVyKGVuZC5tdWx0aXBsaWVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmbi50ZXh0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgY29yZS5TeW1ib2woMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNbaW5kZXhdID0gbmV3IFN5bWJvbChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIF8ucGFyc2UoZiwgc3VicykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdwcm9kdWN0JywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpZmY6IGZ1bmN0aW9uIChzeW1ib2wsIHdydCwgbnRoKSB7XHJcbiAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaXNWZWN0b3Ioc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBjb3JlLlZlY3RvcihbXSk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvci5lbGVtZW50cy5wdXNoKF9fLmRpZmYoeCwgd3J0LCBudGgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGNvcmUuVXRpbHMuaXNNYXRyaXgoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBjb3JlLk1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGksIGosIF9fLmRpZmYoeCwgd3J0LCBudGgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGQgPSBpc1N5bWJvbCh3cnQpID8gd3J0LnRleHQoKSA6IHdydDtcclxuICAgICAgICAgICAgLy90aGUgbnRoIGRlcml2YXRpdmVcclxuICAgICAgICAgICAgbnRoID0gaXNTeW1ib2wobnRoKSA/IG50aC5tdWx0aXBsaWVyIDogbnRoIHx8IDE7XHJcblxyXG4gICAgICAgICAgICBpZihkID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBkID0gY29yZS5VdGlscy52YXJpYWJsZXMoc3ltYm9sKVswXTtcclxuXHJcbiAgICAgICAgICAgIC8vdW53cmFwIHNxcnRcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBGTiAmJiBzeW1ib2wuZm5hbWUgPT09IFNRUlQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gc3ltYm9sLmFyZ3NbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwID0gc3ltYm9sLnBvd2VyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAvL3RoZXNlIGdyb3VwcyBnbyB0byB6ZXJvIGFueXdheSBzbyB3aHkgd2FzdGUgdGltZT9cclxuICAgICAgICAgICAgICAgIGlmKHMuZ3JvdXAgIT09IE4gfHwgcy5ncm91cCAhPT0gUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMucG93ZXIgPSBpc1N5bWJvbChzLnBvd2VyKSA/IF8ubXVsdGlwbHkocy5wb3dlciwgXy5tdWx0aXBseShuZXcgU3ltYm9sKDEgLyAyKSksIHNwKSA6IHMucG93ZXIubXVsdGlwbHkobmV3IEZyYWMoMC41KSkubXVsdGlwbHkoc3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIHMubXVsdGlwbGllciA9IHMubXVsdGlwbGllci5tdWx0aXBseShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBGTiAmJiAhaXNTeW1ib2woc3ltYm9sLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBkZXJpdmUoXy5wYXJzZShzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gX18uZGlmZihzeW1ib2wuYXJnc1swXS5jbG9uZSgpLCBkKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ubXVsdGlwbHkoYSwgYik7Ly9jaGFpbiBydWxlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBkZXJpdmUoc3ltYm9sKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYobnRoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgbnRoLS07XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5kaWZmKHN5bWJvbCwgd3J0LCBudGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG5cclxuICAgICAgICAgICAgLy8gRXF1aXZhbGVudCB0byBcImRlcml2YXRpdmUgb2YgdGhlIG91dHNpZGVcIi5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcG9seWRpZmYoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wudmFsdWUgPT09IGQgfHwgc3ltYm9sLmNvbnRhaW5zKGQsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIgPSBzeW1ib2wubXVsdGlwbGllci5tdWx0aXBseShzeW1ib2wucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5wb3dlciA9IHN5bWJvbC5wb3dlci5zdWJ0cmFjdChuZXcgRnJhYygxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBTeW1ib2woc3ltYm9sLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBkZXJpdmUoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZyA9IHN5bWJvbC5ncm91cCwgYSwgYiwgY3A7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZyA9PT0gTiB8fCBnID09PSBTICYmIHN5bWJvbC52YWx1ZSAhPT0gZCB8fCBnID09PSBQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gcG9seWRpZmYoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHN5bWJvbC5tdWx0aXBsaWVyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gXy5tdWx0aXBseShwcm9kdWN0X3J1bGUoc3ltYm9sKSwgcG9seWRpZmYoc3ltYm9sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm11bHRpcGxpZXIgPSByZXR2YWwubXVsdGlwbGllci5tdWx0aXBseShtKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBGTiAmJiBzeW1ib2wucG93ZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGFibGUgb2Yga25vd24gZGVyaXZhdGl2ZXNcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goc3ltYm9sLmZuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTE9HOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AgPSBzeW1ib2wuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5hcmdzWzBdLmNsb25lKCk7Ly9nZXQgdGhlIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnBvd2VyID0gc3ltYm9sLnBvd2VyLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIgPSBjcC5tdWx0aXBsaWVyLmRpdmlkZShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDT1M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvcyAtPiAtc2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZm5hbWUgPSBTSU47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllci5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNJTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2luIC0+IGNvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmZuYW1lID0gQ09TO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVEFOOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90YW4gLT4gc2VjXjJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5mbmFtZSA9IFNFQztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5wb3dlciA9IG5ldyBGcmFjKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU0VDOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgY2xvbmUgaWYgdGhpcyBnaXZlcyBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHFkaWZmKHN5bWJvbCwgVEFOKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENTQzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHFkaWZmKHN5bWJvbCwgJy1jb3QnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5mbmFtZSA9IENTQztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnBvd2VyID0gbmV3IEZyYWMoMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBU0lOOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnKHNxcnQoMS0oJyArIHRleHQoc3ltYm9sLmFyZ3NbMF0pICsgJyleMikpXigtMSknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFDT1M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCctKHNxcnQoMS0oJyArIHRleHQoc3ltYm9sLmFyZ3NbMF0pICsgJyleMikpXigtMSknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFUQU46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCcoMSsoJyArIHRleHQoc3ltYm9sLmFyZ3NbMF0pICsgJyleMileKC0xKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQUJTOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHN5bWJvbC5tdWx0aXBsaWVyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kZXBlbmRpbmcgb24gdGhlIGNvbXBsZXhpdHkgb2YgdGhlIHN5bWJvbCBpdCdzIGVhc2llciB0byBqdXN0IHBhcnNlIGl0IGludG8gYSBuZXcgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgc2hvdWxkIHJlYWxseSBiZSByZWFkZHJlc3NlZCBzb29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gc3ltYm9sLmFyZ3NbMF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZShpbkJyYWNrZXRzKHRleHQoc3ltYm9sLmFyZ3NbMF0pKSArICcvYWJzJyArIGluQnJhY2tldHModGV4dChiKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIgPSBtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmVucyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NlZSBwcm9kdWN0IHJ1bGU6IGYnLmcgZ29lcyB0byB6ZXJvIHNpbmNlIGYnIHdpbGwgcmV0dXJuIHplcm8uIFRoaXMgd2F5IHdlIG9ubHkgZ2V0IGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMSpnJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvc2gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb3NoIC0+IC1zaW5oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZm5hbWUgPSAnc2luaCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2luaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NpbmggLT4gY29zaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmZuYW1lID0gJ2Nvc2gnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVEFOSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGFuaCAtPiBzZWNoXjJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5mbmFtZSA9IFNFQ0g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wucG93ZXIgPSBuZXcgRnJhYygyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNFQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBjbG9uZSBpZiB0aGlzIGdpdmVzIGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gcWRpZmYoc3ltYm9sLCAnLXRhbmgnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENTQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gU3RyaW5nKHN5bWJvbC5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKCctY290aCgnICsgYXJnICsgJykqY3NjaCgnICsgYXJnICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPVEg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gU3RyaW5nKHN5bWJvbC5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKCctY3NjaCgnICsgYXJnICsgJyleMicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FzaW5oJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJyhzcXJ0KDErKCcgKyB0ZXh0KHN5bWJvbC5hcmdzWzBdKSArICcpXjIpKV4oLTEpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWNvc2gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnKHNxcnQoLTErKCcgKyB0ZXh0KHN5bWJvbC5hcmdzWzBdKSArICcpXjIpKV4oLTEpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXRhbmgnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnKDEtKCcgKyB0ZXh0KHN5bWJvbC5hcmdzWzBdKSArICcpXjIpXigtMSknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFTRUNIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IFN0cmluZyhzeW1ib2wuYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCctMS8oc3FydCgxLygnICsgYXJnICsgJyleMi0xKSooJyArIGFyZyArICcpXjIpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBQ09USDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJy0xLygoJyArIHN5bWJvbC5hcmdzWzBdICsgJyleMi0xKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQUNTQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gU3RyaW5nKHN5bWJvbC5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJy0xLyhzcXJ0KDEvKCcgKyBhcmcgKyAnKV4yKzEpKignICsgYXJnICsgJyleMiknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFTRUM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gU3RyaW5nKHN5bWJvbC5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJzEvKHNxcnQoMS0xLygnICsgYXJnICsgJyleMikqKCcgKyBhcmcgKyAnKV4yKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQUNTQzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBTdHJpbmcoc3ltYm9sLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnLTEvKHNxcnQoMS0xLygnICsgYXJnICsgJyleMikqKCcgKyBhcmcgKyAnKV4yKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQUNPVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJy0xLygoJyArIHN5bWJvbC5hcmdzWzBdICsgJyleMisxKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IFN0cmluZyhzeW1ib2wuYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCdzaW4oKHBpKignICsgYXJnICsgJyleMikvMiknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdDJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBTdHJpbmcoc3ltYm9sLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnY29zKChwaSooJyArIGFyZyArICcpXjIpLzIpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnU2knOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnc2luKCcgKyBhcmcgKyAnKS8oJyArIGFyZyArICcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnU2hpJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBzeW1ib2wuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJ3NpbmgoJyArIGFyZyArICcpLygnICsgYXJnICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdDaSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCdjb3MoJyArIGFyZyArICcpLygnICsgYXJnICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdDaGknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnY29zaCgnICsgYXJnICsgJykvKCcgKyBhcmcgKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0VpJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBzeW1ib2wuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJ2VeKCcgKyBhcmcgKyAnKS8oJyArIGFyZyArICcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTGknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnMS8nICsgU2V0dGluZ3MuTE9HICsgJygnICsgYXJnICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlcmYnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnKDIqZV4oLSgnICsgc3ltYm9sLmFyZ3NbMF0gKyAnKV4yKSkvc3FydChwaSknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdGFuMic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeF8gPSBTdHJpbmcoc3ltYm9sLmFyZ3NbMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XyA9IFN0cmluZyhzeW1ib2wuYXJnc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCcoJyArIHlfICsgJykvKCgnICsgeV8gKyAnKV4yKygnICsgeF8gKyAnKV4yKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaW5jJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoZm9ybWF0KCcoKHswfSkqY29zKHswfSktc2luKHswfSkpKih7MH0pXigtMiknLCBzeW1ib2wuYXJnc1swXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2V0dGluZ3MuTE9HMTA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCcxLygoJyArIHN5bWJvbC5hcmdzWzBdICsgJykqJyArIFNldHRpbmdzLkxPRyArICcoMTApKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnN5bWZ1bmN0aW9uKCdkaWZmJywgW3N5bWJvbCwgd3J0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBFWCB8fCBnID09PSBGTiAmJiBpc1N5bWJvbChzeW1ib2wucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGcgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3ltYm9sLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IEZOICYmIHN5bWJvbC5jb250YWlucyhkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN5bWJvbC5mbmFtZSArIGluQnJhY2tldHModGV4dChzeW1ib2wuYXJnc1swXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzeW1ib2wudmFsdWUgKyBpbkJyYWNrZXRzKHRleHQoc3ltYm9sLmFyZ3NbMF0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IF8ubXVsdGlwbHkoXy5wYXJzZShMT0cgKyBpbkJyYWNrZXRzKHZhbHVlKSksIHN5bWJvbC5wb3dlci5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gX18uZGlmZihfLm11bHRpcGx5KF8ucGFyc2UoTE9HICsgaW5CcmFja2V0cyh2YWx1ZSkpLCBzeW1ib2wucG93ZXIuY2xvbmUoKSksIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ubXVsdGlwbHkoc3ltYm9sLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gRk4gJiYgIXN5bWJvbC5wb3dlci5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ubXVsdGlwbHkocG9seWRpZmYoc3ltYm9sLmNsb25lKCkpLCBkZXJpdmUoYikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBDUCB8fCBnID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IERvIG5vdCB1c2UgYHBhcnNlYCBzaW5jZSB0aGlzIHB1dHMgYmFjayB0aGUgc3FydCBhbmQgY2F1c2VzIGEgYnVnIGFzIGluICM2MTAuIFVzZSBjbG9uZS5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBzeW1ib2wuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLmFkZChyZXN1bHQsIF9fLmRpZmYoc3ltYm9sLnN5bWJvbHNbeF0uY2xvbmUoKSwgZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLm11bHRpcGx5KHBvbHlkaWZmKGMpLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHN5bWJvbC51cGRhdGVIYXNoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBxZGlmZihzeW1ib2wsIHZhbCwgYWx0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShzeW1ib2wsIF8ucGFyc2UodmFsICsgaW5CcmFja2V0cyhhbHRWYWwgfHwgdGV4dChzeW1ib2wuYXJnc1swXSkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcHJvZHVjdF9ydWxlKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgLy9ncmFiIGFsbCB0aGUgc3ltYm9scyB3aXRoaW4gdGhlIENCIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbHMgPSBzeW1ib2wuY29sbGVjdFN5bWJvbHMoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFN5bWJvbCgwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHN5bWJvbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgLy9sb29wIG92ZXIgYWxsIHRoZSBzeW1ib2xzXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRmID0gX18uZGlmZihzeW1ib2xzW2ldLmNsb25lKCksIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9za2lwIHRoZSBzeW1ib2wgb2Ygd2hpY2ggd2UganVzdCBwdWxsZWQgdGhlIGRlcml2YXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaSAhPT0gaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tdWx0aXBseSBvdXQgdGhlIHJlbWFpbmluZyBzeW1ib2xzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZiA9IF8ubXVsdGlwbHkoZGYsIHN5bWJvbHNbal0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhlIGRlcml2YXRpdmUgdG8gdGhlIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uYWRkKHJlc3VsdCwgZGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy9kb25lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW50ZWdyYXRpb246IHtcclxuICAgICAgICAgICAgdV9zdWJzdGl0dXRpb246IGZ1bmN0aW9uIChzeW1ib2xzLCBkeCkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdHJ5X2NvbWJvKGEsIGIsIGYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF9fLmRpZmYoYiwgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gZiA/IGYoYSwgYikgOiBfLmRpdmlkZShhLmNsb25lKCksIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFxLmNvbnRhaW5zKGR4LCB0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb19mbl9zdWIoZm5hbWUsIGFyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJiZWQgPSBfXy5pbnRlZ3JhdGUoXy5zeW1mdW5jdGlvbihmbmFtZSwgW25ldyBTeW1ib2wodSldKSwgdSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViYmVkID0gc3ViYmVkLnN1YihuZXcgU3ltYm9sKHUpLCBhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmJlZC51cGRhdGVIYXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmJlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHN5bWJvbHNbMF0uY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHN5bWJvbHNbMV0uY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZzEgPSBhLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnMiA9IGIuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWF5IGNhdXNlIHByb2JsZW1zIGlmIHBlcnNvbiBpcyB1c2luZyB0aGlzIGFscmVhZHkuIFdpbGwgbmVlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RvIGZpbmQgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY29uZmxpY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9ICdfX3VfXycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFE7XHJcbiAgICAgICAgICAgICAgICBpZihnMSA9PT0gRk4gJiYgZzIgIT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9lLmcuIDIqeCpjb3MoeF4yKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBhLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IHRyeV9jb21ibyhiLCBhcmcuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoUSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoUSwgZG9fZm5fc3ViKGEuZm5hbWUsIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgIFEgPSB0cnlfY29tYm8oYiwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoUSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uaW50ZWdyYXRpb24ucG9seV9pbnRlZ3JhdGUoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnMiA9PT0gRk4gJiYgZzEgIT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9lLmcuIDIqKHgrMSkqY29zKCh4KzEpXjJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gYi5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIFEgPSB0cnlfY29tYm8oYSwgYXJnLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KFEsIGRvX2ZuX3N1YihiLmZuYW1lLCBhcmcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZzEgPT09IEZOICYmIGcyID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgIFEgPSB0cnlfY29tYm8oYS5jbG9uZSgpLCBiLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKGIpLCBRKTtcclxuICAgICAgICAgICAgICAgICAgICBRID0gdHJ5X2NvbWJvKGIuY2xvbmUoKSwgYS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihRKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShiKSwgUSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcxID09PSBFWCAmJiBnMiAhPT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGEucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IHRyeV9jb21ibyhiLCBwLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFRKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vb25lIG1vcmUgdHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYyA9IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcocC5jbG9uZSgpLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc2lkZXIgdGhlIHBvc3NpYmlsaXR5IG9mIGFeeF4obi0xKSp4Xm4gZHhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhwID0gX18uZGlmZihkY1syXS5jbG9uZSgpLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYzIgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKHhwLmNsb25lKCksIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGVpciBwb3dlcnMgZXF1YWwsIHNvIGlmIGR4KnAgPT0gYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihfLm11bHRpcGx5KGRjWzFdLCBkYzJbMV0pLnBvd2VyLmVxdWFscyhiLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBfLmRpdmlkZShkY1swXS5jbG9uZSgpLCBkYzJbMF0uY2xvbmUoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld192YWwgPSBfLm11bHRpcGx5KG0uY2xvbmUoKSwgXy5wb3cobmV3IFN5bWJvbChhLnZhbHVlKSwgXy5tdWx0aXBseShkY1swXSwgbmV3IFN5bWJvbCh1KSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld192YWwgPSBfLm11bHRpcGx5KG5ld192YWwsIG5ldyBTeW1ib2wodSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKG5ld192YWwsIHUsIDAsIHt9KS5zdWIodSwgZGNbMV0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhdGVkID0gX18uaW50ZWdyYXRlKGEuc3ViKHAuY2xvbmUoKSwgbmV3IFN5bWJvbCh1KSksIHUsIDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShpbnRlZ3JhdGVkLnN1YihuZXcgU3ltYm9sKHUpLCBwKSwgUSk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnMiA9PT0gRVggJiYgZzEgIT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBiLnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIFEgPSB0cnlfY29tYm8oYSwgcC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZWdyYXRlZCA9IF9fLmludGVncmF0ZShiLnN1YihwLCBuZXcgU3ltYm9sKHUpKSwgdSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoaW50ZWdyYXRlZC5zdWIobmV3IFN5bWJvbCh1KSwgcCksIFEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhLmlzQ29tcG9zaXRlKCkgfHwgYi5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF9fLmRpZmYoYiwgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgQSA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEIgPSBjb3JlLkFsZ2VicmEuRmFjdG9yLmZhY3RvcihkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBfLmRpdmlkZShBLCBCKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZjEgPSBhLmlzQ29tcG9zaXRlKCkgPyBhLmNsb25lKCkudG9MaW5lYXIoKSA6IGEuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYyID0gYi5pc0NvbXBvc2l0ZSgpID8gYi5jbG9uZSgpLnRvTGluZWFyKCkgOiBiLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IHRyeV9jb21ibyhmMS5jbG9uZSgpLCBmMi5jbG9uZSgpLCBmKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihRKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShiKSwgUSk7XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IHRyeV9jb21ibyhmMi5jbG9uZSgpLCBmMS5jbG9uZSgpLCBmKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihRKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShhKSwgUSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vc2ltcGxlIGludGVncmF0aW9uIG9mIGEgc2luZ2xlIHBvbHlub21pYWwgeF4obisxKS8obisxKVxyXG4gICAgICAgICAgICBwb2x5X2ludGVncmF0ZTogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0geC5wb3dlci50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0geC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0geC50b1VuaXRNdWx0aXBsaWVyKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgIGlmKE51bWJlcihwKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShuZXcgU3ltYm9sKG0pLCBfLnN5bWZ1bmN0aW9uKExPRywgW3NdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJyh7MH0pKih7MX0pXigoezJ9KSsxKS8oKHsyfSkrMSknLCBtLCBzLCBwKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUganVzdCBzcGlubmluZyB3aGVlbHMgd2Ugd2FudCB0byBzdG9wLiBUaGlzIGlzIHdoeSB3ZSBcclxuICAgICAgICAgICAgLy93cmFwIGludGVncmF0aW9uIGluIGEgdHJ5IGNhdGNoIGJsb2NrIGFuZCBjYWxsIHRoaXMgdG8gc3RvcC5cclxuICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgbXNnID0gbXNnIHx8ICdVbmFibGUgdG8gY29tcHV0ZSBpbnRlZ3JhbCEnO1xyXG4gICAgICAgICAgICAgICAgY29yZS5VdGlscy53YXJuKG1zZyk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9JbnRlZ3JhbEZvdW5kKG1zZyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBhcnRpYWxfZnJhY3Rpb246IGZ1bmN0aW9uIChpbnB1dCwgZHgsIGRlcHRoLCBvcHQpIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETzogVGhpcyB3aG9sZSB0aGluZyBuZWVkcyB0byBiZSByb2xsZWQgaW50byBvbmUgYnV0IGZvciBub3cgSSdsbCBsZWF2ZSBpdCBhcyB0d28gc2VwYXJhdGUgcGFydHNcclxuICAgICAgICAgICAgICAgIGlmKCFpc1N5bWJvbChkeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgZHggPSBfLnBhcnNlKGR4KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LCBwYXJ0aWFsX2ZyYWN0aW9ucztcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICBwYXJ0aWFsX2ZyYWN0aW9ucyA9IGNvcmUuQWxnZWJyYS5QYXJ0RnJhYy5wYXJ0ZnJhYyhpbnB1dCwgZHgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHBhcnRpYWxfZnJhY3Rpb25zLmdyb3VwID09PSBDQiAmJiBwYXJ0aWFsX2ZyYWN0aW9ucy5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9wZXJmb3JtIGEgcXVpY2sgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHBhcnRpYWwgZnJhY3Rpb25zIGFyZSBsaW5lYXJcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsX2ZyYWN0aW9ucy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF4LmlzTGluZWFyKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbF9mcmFjdGlvbnMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLmFkZChyZXN1bHQsIF9fLmludGVncmF0ZSh4LCBkeCwgZGVwdGgsIG9wdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5hZGQocmVzdWx0LCBfXy5pbnRlZ3JhdGUocGFydGlhbF9mcmFjdGlvbnMsIGR4LCBkZXB0aCwgb3B0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRfdWR2OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBbWy8qTCovXSwgWy8qSSovXSwgWy8qQSovXSwgWy8qVCovXSwgWy8qRSovXV07XHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0IHdlIHNvcnQgdGhlbSBcclxuICAgICAgICAgICAgICAgIHZhciBzZXRTeW1ib2wgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0geC5ncm91cDtcclxuICAgICAgICAgICAgICAgICAgICBpZihnID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5hbWUgPSB4LmZuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmluX3RyaWcoZm5hbWUpIHx8IGNvcmUuVXRpbHMuaW5faHRyaWcoZm5hbWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbM10ucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjb3JlLlV0aWxzLmluX2ludmVyc2VfdHJpZyhmbmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1sxXS5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSBMT0cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1swXS5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IFMgfHwgeC5pc0NvbXBvc2l0ZSgpICYmIHguaXNMaW5lYXIoKSB8fCBnID09PSBDQiAmJiB4LmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbMl0ucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBFWCB8fCB4LmlzQ29tcG9zaXRlKCkgJiYgIXguaXNMaW5lYXIoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydHNbNF0ucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBDQilcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTeW1ib2woU3ltYm9sLnVud3JhcFNRUlQoeCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFN5bWJvbChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHUsIGR2ID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIC8vY29tcGlsZSB1IGFuZCBkdlxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV0sIHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gcGFydC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGw7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5tdWx0aXBseSh0LCBwYXJ0W2pdLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBwYXJ0WzBdLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHQ7Ly90aGUgZmlyc3QgdSBlbmNvdW50ZXJlZCBnZXRzIGNob3NlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdS5tdWx0aXBsaWVyID0gdS5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5tdWx0aXBsaWVyKTsgLy90aGUgZmlyc3Qgb25lIGdldHMgdGhlIG11dGxpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdiA9IF8ubXVsdGlwbHkoZHYsIHQpOyAvL2V2ZXJ5dGhpbmcgZWxzZSBiZWxvbmdzIHRvIGR2XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbdSwgZHZdO1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgdHJpZ19zdWI6IGZ1bmN0aW9uIChzeW1ib2wsIGR4LCBkZXB0aCwgb3B0LCBwYXJ0cywgc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgcGFydHMgPSBwYXJ0cyB8fCBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKHN5bWJvbC5jbG9uZSgpLnRvTGluZWFyKCksIGR4KTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gcGFydHNbM10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4ID0gcGFydHNbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBwYXJ0c1swXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBhcnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgaWYoeC5wb3dlci5lcXVhbHMoMikgJiYgYS5ncmVhdGVyVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlIHRhbih4KVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gY29yZS5VdGlscy5nZXRVKHN5bWJvbCksIC8vZ2V0IGFuIGFwcHJvcHJpYXRlIHVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBfLnBhcnNlKFRBTiArIGluQnJhY2tldHModCkpLCAvL3VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1ID0gXy5wYXJzZShTRUMgKyBpbkJyYWNrZXRzKHQpICsgJ14yJyksIC8vZHVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBfLm11bHRpcGx5KHN5bWJvbC5zdWIoeCwgdSksIGR1KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZWdyYWwgPSBfXy5pbnRlZ3JhdGUoZiwgdCwgZGVwdGgsIG9wdCkuc3ViKHUsIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuY2xlYXJVKHUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlZ3JhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGJ5X3BhcnRzOiBmdW5jdGlvbiAoc3ltYm9sLCBkeCwgZGVwdGgsIG8pIHtcclxuICAgICAgICAgICAgICAgIG8ucHJldmlvdXMgPSBvLnByZXZpb3VzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVkdiwgdSwgZHYsIGR1LCB2LCB2ZHUsIHV2LCByZXR2YWwsIGludGVncmFsX3ZkdSwgbSwgYywgdmR1X3M7XHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0IExJQVRFXHJcbiAgICAgICAgICAgICAgICB1ZHYgPSBfXy5pbnRlZ3JhdGlvbi5nZXRfdWR2KHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICB1ID0gdWR2WzBdO1xyXG4gICAgICAgICAgICAgICAgZHYgPSB1ZHZbMV07XHJcbiAgICAgICAgICAgICAgICBkdSA9IFN5bWJvbC51bndyYXBTUVJUKF8uZXhwYW5kKF9fLmRpZmYodS5jbG9uZSgpLCBkeCkpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGMgPSBkdS5jbG9uZSgpLnN0cmlwVmFyKGR4KTtcclxuICAgICAgICAgICAgICAgIC8vc3RyaXAgYW55IGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAgICAgICAgZHUgPSBfLmRpdmlkZShkdSwgYy5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIHYgPSBfXy5pbnRlZ3JhdGUoZHYuY2xvbmUoKSwgZHgsIGRlcHRoIHx8IDApO1xyXG4gICAgICAgICAgICAgICAgdmR1ID0gXy5tdWx0aXBseSh2LmNsb25lKCksIGR1KTtcclxuICAgICAgICAgICAgICAgIHZkdV9zID0gdmR1LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAvL2N1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGVeeCooc29tZSB0cmlnKVxyXG4gICAgICAgICAgICAgICAgaWYoby5wcmV2aW91cy5pbmRleE9mKHZkdV9zKSAhPT0gLTEgJiYgKGNvcmUuVXRpbHMuaW5fdHJpZyh1LmZuYW1lKSkgJiYgZHYuaXNFKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1dlJ3JlIGdvaW5nIHRvIGV4cGxvaXQgdGhlIGZhY3QgdGhhdCB2ZHUgY2FuIG5ldmVyIGJlIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy90byB3b3JrIG91dCB3YXkgb3V0IG9mIHRoaXMgY3ljbGUuIFdlJ2xsIHJldHVybiB0aGUgbGVuZ3RoIG9mXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgdGhpcy5wcmV2aW91cyBhcnJheSB1bnRpbCB3ZSdyZSBiYWNrIGF0IGxldmVsIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIG8uaXNfY3ljbGljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiB0aGUgaW50ZWdyYWwuIFxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG8ucHJldmlvdXMucHVzaCh2ZHVfcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdXYgPSBfLm11bHRpcGx5KHUsIHYpO1xyXG4gICAgICAgICAgICAgICAgLy9jbGVhciB0aGUgbXVsdGlwbGllciBzbyB3ZSdyZSBkZWFsaW5nIHdpdGggYSBiYXJlIGludGVncmFsXHJcbiAgICAgICAgICAgICAgICBtID0gdmR1Lm11bHRpcGxpZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHZkdS50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICBpbnRlZ3JhbF92ZHUgPSBfLm11bHRpcGx5KF9fLmludGVncmF0ZSh2ZHUuY2xvbmUoKSwgZHgsIGRlcHRoLCBvKSwgYyk7XHJcbiAgICAgICAgICAgICAgICBpbnRlZ3JhbF92ZHUubXVsdGlwbGllciA9IGludGVncmFsX3ZkdS5tdWx0aXBsaWVyLm11bHRpcGx5KG0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zdWJ0cmFjdCh1diwgaW50ZWdyYWxfdmR1KTtcclxuICAgICAgICAgICAgICAgIC8vd2Uga25vdyB0aGF0IHRoZXJlIGNhbm5vdCBiZSBjb25zdGFudHMgc28gdGhleSdyZSBhIGhvbGRvdmVyIGZyb20gYSBjeWNsaWMgaW50ZWdyYWxcclxuICAgICAgICAgICAgICAgIGlmKG8uaXNfY3ljbGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdGFydCBwb3BwaW5nIHRoZSBwcmV2aW91cyBzdGFjayBzbyB3ZSBrbm93IGhvdyBkZWVwIGluIHdlIGFyZVxyXG4gICAgICAgICAgICAgICAgICAgIG8ucHJldmlvdXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoby5wcmV2aW91cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5leHBhbmQocmV0dmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigheC5jb250YWlucyhkeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gXy5hZGQocmVtLCB4LmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGFjdHVhbCB1dlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShfLnN1YnRyYWN0KHJldHZhbCwgcmVtLmNsb25lKCkpLCBfLnN1YnRyYWN0KG5ldyBTeW1ib2woMSksIHJlbSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBkZXBlbmRlbnRzOiBbU29sdmUsIGludGVncmF0ZV1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGRlY29tcG9zZV9hcmc6IGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL1RPRE86IG5lcmRhbWVyLmludGVncmF0ZSgnLWVeKC1hKnQpKnNpbih0KScsICd0JykgLT4gZ2l2ZXMgaW5jb3JyZWN0IG91dHB1dFxyXG4gICAgICAgIGludGVncmF0ZTogZnVuY3Rpb24gKG9yaWdpbmFsX3N5bWJvbCwgZHQsIGRlcHRoLCBvcHQpIHtcclxuICAgICAgICAgICAgLy9hc3N1bWUgaW50ZWdyYXRpb24gd3J0IGluZGVwZW5kZW50IHZhcmlhYmxlIGlmIGV4cHJlc3Npb24gb25seSBoYXMgb25lIHZhcmlhYmxlXHJcbiAgICAgICAgICAgIGlmKCFkdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhcnMgPSBjb3JlLlV0aWxzLnZhcmlhYmxlcyhvcmlnaW5hbF9zeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgaWYodmFycy5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgZHQgPSB2YXJzWzBdO1xyXG4gICAgICAgICAgICAgICAgLy9kZWZhdWx0cyB0byB4XHJcbiAgICAgICAgICAgICAgICBkdCA9IGR0IHx8ICd4JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2FkZCBzdXBwb3J0IGZvciBpbnRlZ3JhdGluZyB2ZWN0b3JzXHJcbiAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaXNWZWN0b3Iob3JpZ2luYWxfc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IG5ldyBjb3JlLlZlY3RvcihbXSk7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbF9zeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvci5lbGVtZW50cy5wdXNoKF9fLmludGVncmF0ZSh4LCBkdCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFpc05hTihkdCkpXHJcbiAgICAgICAgICAgICAgICBfLmVycm9yKCd2YXJpYWJsZSBleHBlY3RlZCBidXQgcmVjZWl2ZWQgJyArIGR0KTtcclxuICAgICAgICAgICAgLy9nZXQgcmlkIG9mIGNvbnN0YW50cyByaWdodCBhd2F5XHJcbiAgICAgICAgICAgIGlmKG9yaWdpbmFsX3N5bWJvbC5pc0NvbnN0YW50KHRydWUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkob3JpZ2luYWxfc3ltYm9sLmNsb25lKCksIF8ucGFyc2UoZHQpKTtcclxuXHJcbiAgICAgICAgICAgIC8vY29uZmlndXJhdGlvbnMgb3B0aW9ucyBmb3IgaW50ZWdyYWwuIFRoaXMgaXMgbmVlZGVkIGZvciB0cmFja2luZyBleHRyYSBvcHRpb25zXHJcbiAgICAgICAgICAgIC8vZS5nLiBjeWNsaWMgaW50ZWdyYWxzIG9yIGFkZGl0aW9uYWwgc2V0dGluZ3NcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5ibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy9tYWtlIGEgbm90ZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sLiBTZXQgb25seSBpZiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGRlcHRoID0gZGVwdGggfHwgMDtcclxuICAgICAgICAgICAgICAgIHZhciBkeCA9IGlzU3ltYm9sKGR0KSA/IGR0LnRvU3RyaW5nKCkgOiBkdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBkb24ndCB3YW50IHRoZSBzeW1ib2wgaW4gc3FydCBmb3JtLiB4XigxLzIpIGlzIHByZWZlcmVycmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IFN5bWJvbC51bndyYXBTUVJUKG9yaWdpbmFsX3N5bWJvbC5jbG9uZSgpLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHN5bWJvbC5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9XZSBzdG9wIGludGVncmF0aW9uIGFmdGVyIHggYW1vdW50IG9mIHJlY3Vyc2l2ZSBjYWxsc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCsrZGVwdGggPiBjb3JlLlNldHRpbmdzLmludGVncmF0aW9uX2RlcHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCdNYXhpbXVtIGRlcHRoIHJlYWNoZWQuIEV4aXRpbmchJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3RhbnRzLiBXZSBmaXJzdCBlbGltaW5hdGUgYW55dGhpbmcgdGhhdCBkb2Vzbid0IGhhdmUgZHguIEV2ZXJ5dGhpbmcgYWZ0ZXIgdGhpcyBoYXMgXHJcbiAgICAgICAgICAgICAgICAgICAgLy90byBoYXZlIGR4IG9yIGVsc2UgaXQgd291bGQgaGF2ZSBiZWVuIHRha2VuIGNhcmUgb2YgYmVsb3dcclxuICAgICAgICAgICAgICAgICAgICBpZighc3ltYm9sLmNvbnRhaW5zKGR4LCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHN5bWJvbC5jbG9uZSgpLCBfLnBhcnNlKGR4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vZS5nLiAyKnhcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24ucG9seV9pbnRlZ3JhdGUoc3ltYm9sLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5wcmV2aW91c0dyb3VwID09PSBGTiAmJiAhKHN5bWJvbC5mbmFtZSA9PT0gJ3NxcnQnIHx8IHN5bWJvbC5mbmFtZSA9PT0gU2V0dGluZ3MuUEFSRU5USEVTSVMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIHRoZSBiYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5jb250YWlucyhkeCkgJiYgc3ltYm9sLnByZXZpb3VzR3JvdXAgIT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBzeW1ib2wgYWxzbyBjb250YWlucyBkeCB0aGVuIHdlIHN0b3Agc2luY2Ugd2UgY3VycmVudGx5IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kb24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aCBpdCBlLmcuIHheeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyLmNvbnRhaW5zKGR4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF9fLmRpZmYoc3ltYm9sLmNsb25lKCkudG9MaW5lYXIoKSwgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHQuY29udGFpbnMoZHgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zaW5jZSBhdCB0aGlzIHBvaW50IGl0J3MgdGhlIGJhc2Ugb25seSB0aGVuIHdlIGRvIHN0YW5kYXJkIHNpbmdsZSBwb2x5IGludGVncmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lLmcuIHheeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKHN5bWJvbCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2UuZy4gYV54IG9yIDleeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gX18uZGlmZihzeW1ib2wucG93ZXIuY2xvbmUoKSwgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5jb250YWlucyhkeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWEgPSBhLnN0cmlwVmFyKGR4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBfLmRpdmlkZShhLmNsb25lKCksIGFhLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IFMgJiYgeC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFhLm11bHRpcGxpZXIgPSBhYS5tdWx0aXBsaWVyLmRpdmlkZShuZXcgRnJhYygyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnKHsyfSkqKHNxcnQocGkpKmVyZihzcXJ0KC17MH0pKnsxfSkpLygyKnNxcnQoLXswfSkpJywgYWEsIGR4LCBzeW1ib2wubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEuaXNMaW5lYXIoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhLmlzRSgpICYmIGEucG93ZXIuZ3JvdXAgPT09IFMgJiYgYS5wb3dlci5wb3dlci5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KF8uc3ltZnVuY3Rpb24oJ0VpJywgW3N5bWJvbC5wb3dlci5jbG9uZSgpXSksIHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF8uc3ltZnVuY3Rpb24oTE9HLCBbXy5wYXJzZShzeW1ib2wudmFsdWUpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUoc3ltYm9sLCBkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKHJldHZhbCwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfXy5pbnRlZ3JhdGUoeCwgZHgsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KG0sIHJldHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyLmdyZWF0ZXJUaGFuKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5leHBhbmQoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfXy5pbnRlZ3JhdGUoeCwgZHgsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKHN5bWJvbC5wb3dlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBzeW1ib2wubXVsdGlwbGllci5jbG9uZSgpOy8vdGVtcG9yYXJpbHkgcmVtb3ZlIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8vYmVsb3cgd2UgY29uc2lkZXIgdGhlIGZvcm0gYXgrYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA9IHN5bWJvbC5jbG9uZSgpLnRvTGluZWFyKCksIC8vZ2V0IGp1c3QgdGhlIHB1cmUgZnVuY3Rpb24gd2l0aG91dCB0aGUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb21wID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhmbiwgZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0kgaGF2ZSBubyBpZGVhIHdoeSBJIHVzZWQgYngrYSBhbmQgbm90IGF4K2IuIFRPRE8gY2hhbmdlIHRoaXMgdG8gc29tZXRoaW5nIHRoYXQgbWFrZXMgc2Vuc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGRlY29tcFszXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXggPSBkZWNvbXBbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBkZWNvbXBbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkZWNvbXBbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwID09PSAtMSAmJiB4Lmdyb3VwICE9PSBQTCAmJiB4LnBvd2VyLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiX2lzX3Bvc2l0aXZlID0gaXNJbnQoYikgPyBiID4gMCA6IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBjYW4gbm93IGNoZWNrIGZvciBhdGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gUyAmJiB4LnBvd2VyLmVxdWFscygyKSAmJiBiX2lzX3Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy90aGVuIHdlIGhhdmUgYXRhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FicyBpcyByZWR1bmRhbnRzIHNpbmNlIHRoZSBzaWduIGFwcGVhcnMgaW4gYm90aCBkZW5vbSBhbmQgbnVtLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW53cmFwQWJzID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShyZXN1bHQsIHguZm5hbWUgPT09ICdhYnMnID8geC5hcmdzWzBdIDogeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBBID0gYS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEIgPSBiLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgPSBfLnBvdyhBLCBuZXcgU3ltYm9sKDEgLyAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEIgPSBfLnBvdyhCLCBuZXcgU3ltYm9sKDEgLyAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdW53cmFwIGFic1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfLm11bHRpcGx5KHVud3JhcEFicyhCKSwgdW53cmFwQWJzKEEpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gXy5zeW1mdW5jdGlvbihBVEFOLCBbXy5kaXZpZGUoXy5tdWx0aXBseShhLCB4LnRvTGluZWFyKCkpLCBkLmNsb25lKCkpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKGYsIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHguZ3JvdXAgPT09IFMgJiYgeC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKHN5bWJvbCksIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8xLyh4XjQrMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5wb3dlci5lcXVhbHMoNCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly93d3cuZnJlZW1hdGhoZWxwLmNvbS9mb3J1bS90aHJlYWRzLzU1Njc4LWRpZmZpY3VsdC1pbnRlZ3JhdGlvbi1pbnQtMS0oMS14LTQpLWR4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQSwgQiwgQywgRCwgRSwgRiwgZjEsIGYyLCBmMywgZjQsIEwxLCBMMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiciA9IGluQnJhY2tldHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IHJ1bGU6IGF4XjQrYiA9ICjiiJpheF4yK+KImjLiiJxh4oicYngr4oiaYiko4oiaYXheMi3iiJoy4oicYeKInGJ4K+KImmIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBxdWFkcmF0aWMgZmFjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSA9IF8ucGFyc2UoU1FSVCArIGJyKGEpICsgJyonICsgZHggKyAnXjInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEIgPSBfLnBhcnNlKFNRUlQgKyBicigyKSArICcqJyArIGJyKGEpICsgJ14nICsgYnIoJzEvNCcpICsgJyonICsgYnIoYikgKyAnXicgKyBicignMS80JykgKyAnKicgKyBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDID0gXy5wYXJzZShTUVJUICsgYnIoYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjEgPSBfLmFkZChfLmFkZChBLmNsb25lKCksIEIuY2xvbmUoKSksIEMuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmMiA9IF8uYWRkKF8uc3VidHJhY3QoQSwgQiksIEMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxjdWxhdGUgbnVtZXJhdG9yczogW0QrRSwgRC1FXSAtPiBb4oiaMipiXigzLzQpK+KImmLiiJxheCwg4oiaMipiXigzLzQpLeKImmLiiJxheF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEQgPSBfLnBhcnNlKFNRUlQgKyBicigyKSArICcqJyArIGJyKGIpICsgJ14nICsgYnIoJzMvNCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUgPSBfLnBhcnNlKFNRUlQgKyBicihiKSArICcqJyArIGJyKGIpICsgJ14nICsgYnIoJzEvNCcpICsgJyonICsgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgRiA9IDJi4oiaMuKInGJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEYgPSBfLnBhcnNlKDIgKyAnKicgKyBicihiKSArICcqJyArIFNRUlQgKyBicigyKSArICcqJyArIGJyKGIpICsgJ14nICsgYnIoJzEvNCcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHRoZSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMMSA9IF8uZGl2aWRlKF8uc3VidHJhY3QoRC5jbG9uZSgpLCBFLmNsb25lKCkpLCBfLm11bHRpcGx5KEYuY2xvbmUoKSwgZjIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwyID0gXy5kaXZpZGUoXy5hZGQoRCwgRSksIF8ubXVsdGlwbHkoRiwgZjEuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0ZShMMSwgZHgsIGRlcHRoLCBvcHQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGUoTDIsIGR4LCBkZXB0aCwgb3B0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbGV0J3MgdHJ5IHBhcnRpYWwgZnJhY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wYXJ0aWFsX2ZyYWN0aW9uKHN5bWJvbCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHAgPT09IC0xIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGFzaW4gYW5kIGF0YW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4Lmdyb3VwID09PSBTICYmIHgucG93ZXIuZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF4Lm11bHRpcGxpZXIubGVzc1RoYW4oMCkgJiYgIWIubXVsdGlwbGllci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaXQncyBhc2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihiLmlzQ29uc3RhbnQoKSAmJiBhLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gXy5zeW1mdW5jdGlvbihTUVJULCBbYS5jbG9uZSgpXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IF8uc3ltZnVuY3Rpb24oU1FSVCwgW18ubXVsdGlwbHkoYS5jbG9uZSgpLCBiKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKF8uc3ltZnVuY3Rpb24oQVNJTiwgW18uZGl2aWRlKGF4LnRvTGluZWFyKCksIGQyKV0pLCBkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSSdtIG5vdCBzdXJlIGFib3V0IHRoaXMgb25lLiBJJ20gdHJ1c3RpbmcgV29sZnJhbSBBbHBoYSBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3FydF9hID0gXy5zeW1mdW5jdGlvbihTUVJULCBbYV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3FydF9heCA9IF8ubXVsdGlwbHkoc3FydF9hLmNsb25lKCksIHguY2xvbmUoKS50b0xpbmVhcigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShfLnN5bWZ1bmN0aW9uKEFUQU4sIFtfLmRpdmlkZShzcXJ0X2F4LCBfLnN5bWZ1bmN0aW9uKFNRUlQsIFtmbi5jbG9uZSgpXSkpXSksIHNxcnRfYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKldIQVQgSEFQUEVOUyBIRVJFPz8/PyBlLmcuIGludGVncmF0ZSgzL3NxcnQoLWErYip4XjIpLHgpIG9yIGludGVncmF0ZSgzL3NxcnQoYStiKnheMikseCkqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RoaXMgd291bGQgYmUgYSBjYXNlIGxpa2UgMS8oc3FydCgxLXheMykgb3IgMS8oMS0oeCsxKV4yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5pc0xpbmVhcigpICYmIHguZ3JvdXAgIT09IFBMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShzeW1ib2wpLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHgucG93ZXIuZXF1YWxzKDIpICYmIGEuZ3JlYXRlclRoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNxYSwgc3FiLCBhb2IsIGJzcWksIG4sIGludGVncmFsLCB1LCB2LCB1djtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8xLyhhKnheMitiXjIpXm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zdHJpcCB0aGUgdmFsdWUgb2YgYiBzbyBiID0gMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcWEgPSBfLnBhcnNlKFNRUlQgKyBpbkJyYWNrZXRzKGEpKTsgLy9zdHJpcCBhIHNvIGIgPSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxYiA9IF8ucGFyc2UoU1FSVCArIGluQnJhY2tldHMoYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb2IgPSBfLm11bHRpcGx5KHNxYS5jbG9uZSgpLCBzcWIuY2xvbmUoKSkuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJzcWkgPSBfLnBvdyhiLCBuZXcgU3ltYm9sKHN5bWJvbC5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1diA9IGNvcmUuVXRpbHMuZ2V0VShzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gXy5tdWx0aXBseShhb2IsIHguY2xvbmUoKS50b0xpbmVhcigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IF8ucGFyc2UoQVRBTiArIGluQnJhY2tldHModSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBjb252ZXJzaW9uIHdpbGwgYmUgMSt0YW4oeCleMiAtPiBzZWMoeCleMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIHRoZSBkZW5vbWluYXRvciBpcyBub3cgKHNlYyh4KV4yKV5uIGFuZCB0aGUgbnVtZXJhdG9yIGlzIHNlYyh4KV4yIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZW4gdGhlIHJlbWFpbmluZyBzZWMgd2lsbCBiZSAobi0xKSoyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IChNYXRoLmFicyhzeW1ib2wucG93ZXIpIC0gMSkgKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLzEvc2VjKHgpXm4gY2FuIG5vdyBiZSBjb252ZXJ0ZWQgdG8gY29zKHgpXm4gYW5kIHdlIGNhbiBwdWxsIHRoZSBpbnRlZ3JhbCBvZiB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhbCA9IF9fLmludGVncmF0ZShfLnBhcnNlKENPUyArIGluQnJhY2tldHModXYpICsgJ14nICsgbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmNsZWFyVSh1dik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KGludGVncmFsLnN1Yih1diwgdiksIGJzcWkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwICE9PSBDQiAmJiAhc3ltYm9sLnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gc3ltYm9sLmNsb25lKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JlZCA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdhc19mYWN0b3JlZCA9IGZhY3RvcmVkLnRvU3RyaW5nKCkgIT09IGYudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuQWxnZWJyYS5kZWdyZWUoZiwgXy5wYXJzZShkeCkpLmVxdWFscygyKSAmJiAhd2FzX2ZhY3RvcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYxLCBmeCwgdSwgc3E7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxID0gY29yZS5BbGdlYnJhLnNxQ29tcGxldGUoZiwgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gY29yZS5VdGlscy5nZXRVKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmMSA9IHNxLmYuc3ViKHNxLmEsIHUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmeCA9IF8ucG93KGYxLCBfLnBhcnNlKHN5bWJvbC5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoZngsIHUpLnN1Yih1LCBzcS5hKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBhcnRpYWxfZnJhY3Rpb24oc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwubXVsdGlwbGllciA9IHJldHZhbC5tdWx0aXBsaWVyLm11bHRpcGx5KG0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBzeW1ib2wubXVsdGlwbGllci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb21wID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhhcmcsIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9lYXNpZXMgd2F5IEkgY2FuIHRoaW5rIG9mIHRvIGdldCB0aGUgY29lZmZpY2llbnQgYW5kIHRvIG1ha2Ugc3VyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoYXQgdGhlIHN5bWJvbCBpcyBsaW5lYXIgd3J0IGR4LiBJJ20gbm90IGFjdHVhbGx5IHRyeWluZyB0byBnZXQgdGhlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Rlcml2YXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBkZWNvbXBbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRlY29tcFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbmFtZSA9IHN5bWJvbC5mbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2cgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBjYW4gYmUgaGFuZGxlZCB3aXRoIGludGVncmF0aW9uIGJ5IHBhcnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZuYW1lID09PSBMT0cgfHwgKGZuYW1lID09PSBBU0lOIHx8IGZuYW1lID09PSBBQ09TIHx8IGZuYW1lID09PSBBVEFOICYmIHguaXNMaW5lYXIoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qaW50ZWdyYXRpb24gYnkgcGFydHMgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gc3ltYm9sLnBvd2VyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc0ludChwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGRlcHRoIC0gcDsgLy9pdCBuZWVkcyBtb3JlIHJvb20gdG8gZmluZCB0aGUgaW50ZWdyYWxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighYXJnLmlzQ29tcG9zaXRlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShfLnBhcnNlKG0pLCBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ludGVncmFsIHUgZHVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGNvcmUuVXRpbHMuZ2V0VShzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gXy5wb3coXy5wYXJzZShMT0cgKyBpbkJyYWNrZXRzKHUpKSwgbmV3IFN5bWJvbChwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1ID0gX18uZGlmZihhcmcsIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdV9kdSA9IF8ubXVsdGlwbHkoZiwgZHUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhbCA9IF9fLmludGVncmF0ZSh1X2R1LCB1LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KF8ucGFyc2UobSksIGludGVncmFsLnN1Yih1LCBhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gVEFOICYmIHN5bWJvbC5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IHRvIGNvdGFuZ2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltLnBvd2VyLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltLmZuYW1lID0gQ09UO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoXy5wYXJzZShtKSwgX18uaW50ZWdyYXRlKHN5bSwgZHgsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighYS5jb250YWlucyhkeCwgdHJ1ZSkgJiYgc3ltYm9sLmlzTGluZWFyKCkpIHsgLy9wZXJmb3JtIGEgZGVlcCBzZWFyY2ggZm9yIHNhZmV0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyc3QgaGFuZGxlIHRoZSBzcGVjaWFsIGNhc2VzIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZuYW1lID09PSBBQlMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9SRVZJU0lUICoqVE9ETyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gXy5kaXZpZGUoYXJnLmNsb25lKCksIGEuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IFMgJiYgIXgucG93ZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuZXZlbih4LnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShhcmcsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZWdyYXRlZCA9IF9fLmludGVncmF0ZSh4LCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmF0ZWQucG93ZXIgPSBpbnRlZ3JhdGVkLnBvd2VyLnN1YnRyYWN0KG5ldyBGcmFjKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KF8ubXVsdGlwbHkoXy5zeW1mdW5jdGlvbihBQlMsIFt4LnRvTGluZWFyKCldKSwgaW50ZWdyYXRlZCksIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZyA9IHN5bWJvbC5hcmdzWzBdLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcG9zZWQgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKGFyZywgZHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIShhZyA9PT0gQ1AgfHwgYWcgPT09IFMgfHwgYWcgPT09IENCKSB8fCAhZGVjb21wb3NlZFsxXS5wb3dlci5lcXVhbHMoMSkgfHwgYXJnLmhhc0Z1bmMoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqVE9ETyoqLyAvL0FTSU4sIEFDT1MsIEFUQU5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGZuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPUzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKFNJTiwgW2FyZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTSU46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbihDT1MsIFthcmddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRBTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChTZXR0aW5ncy5MT0cgKyAnKHNlYyh7MH0pKScsIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTRUM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoU2V0dGluZ3MuTE9HICsgJyh0YW4oezB9KStzZWMoezB9KSknLCBhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ1NDOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCctJyArIFNldHRpbmdzLkxPRyArICcoY3NjKHswfSkrY290KHswfSkpJywgYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChTZXR0aW5ncy5MT0cgKyAnKHNpbih7MH0pKScsIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTSU5IOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oQ09TSCwgW2FyZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDT1NIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oU0lOSCwgW2FyZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUQU5IOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KFNldHRpbmdzLkxPRyArICcoY29zaCh7MH0pKScsIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBU0VDOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBQ1NDOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBQ09UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaW52ZXJzZSBodHJpZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBU0VDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQUNTQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFDT1RIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZW5kIGludmVyc2UgaHRyaWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2h0cmlnaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTRUNIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCdhdGFuKHNpbmgoezB9KSknLCBhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ1NDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChTZXR0aW5ncy5MT0cgKyAnKHRhbmgoKHswfSkvMikpJywgYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPVEg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoU2V0dGluZ3MuTE9HICsgJyhzaW5oKHswfSkpJywgYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lbmQgaHRyaWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRVhQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLnBhcnNlKGZvcm1hdCgnZV4oezB9KScsIGFyZykpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYyA9IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcoYXJnLCBkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XyA9IGRjWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYV8gPSBkY1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYl8gPSBkY1szXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKGNvcygoMS8yKSpwaSooKHsxfSkrKHswfSkqKHsyfSkpXjIpK3BpKigoezF9KSsoezB9KSooezJ9KSkqUygoezF9KSsoezB9KSooezJ9KSkpLygoezB9KSpwaSknLCBhXywgYl8sIHgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBzeW1ib2wuYXJnc1swXS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGMgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKGFyZywgZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeF8gPSBkY1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFfID0gZGNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJfID0gZGNbM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJyhwaSooKHsxfSkrKHswfSkqKHsyfSkpKkMoKHsxfSkrKHswfSkqKHsyfSkpLXNpbigoMS8yKSpwaSooKHsxfSkrKHswfSkqKHsyfSkpXjIpKS8oKHswfSkqcGkpJywgYV8sIGJfLCB4XykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXJmJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF0uY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRjID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhhcmcsIGR4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhfID0gZGNbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhXyA9IGRjWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCdlXigtKCh7Mn0pKV4yKS8oKHswfSkqc3FydChwaSkpKygxLyh7MH0pKyh7MX0pKSplcmYoKHsyfSkpJywgYV8sIHhfLCBhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoc3ltYm9sLmNsb25lKCksIGFyZy5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShyZXR2YWwsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoeC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZm5hbWUgPT09IENPUyB8fCBmbmFtZSA9PT0gU0lOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgdG8gc2VlIGlmIGl0J3MgbmVnYXRpdmUgYW5kIHRoZW4ganVzdCB0cmFuc2Zvcm0gaXQgdG8gc2VjIG9yIGNzY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmZuYW1lID0gZm5hbWUgPT09IFNJTiA/IENTQyA6IFNFQztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5pbnZlcnQoKS51cGRhdGVIYXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoc3ltYm9sLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZCA9IHN5bWJvbC5jbG9uZSgpLCAvL2Nvc14obi0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZDIgPSBzeW1ib2wuY2xvbmUoKSwgLy9jb3NeKG4tMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IG5ldyBTeW1ib2woKHAgLSAxKSAvIHApLCAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYSA9IF8ubXVsdGlwbHkoYS5jbG9uZSgpLCBuZXcgU3ltYm9sKHApKS5pbnZlcnQoKTsgLy8xLyhuKmEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZC5wb3dlciA9IHJkLnBvd2VyLnN1YnRyYWN0KG5ldyBGcmFjKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJkMi5wb3dlciA9IHJkMi5wb3dlci5zdWJ0cmFjdChuZXcgRnJhYygyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfLnN5bWZ1bmN0aW9uKGZuYW1lID09PSBDT1MgPyBTSU4gOiBDT1MsIFthcmcuY2xvbmUoKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZm5hbWUgPT09IFNJTilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQoXy5tdWx0aXBseShfLm11bHRpcGx5KG5hLCByZCksIHQpLCBfLm11bHRpcGx5KHEsIF9fLmludGVncmF0ZShfLnBhcnNlKHJkMiksIGR4LCBkZXB0aCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rhbih4KV5uIG9yIGNvdCh4KV5uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gVEFOIHx8IGZuYW1lID09PSBDT1QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9odHRwOi8vd3d3LnNvc21hdGguY29tL2NhbGN1bHVzL2ludGVncmF0aW9uL21vcmV0cmlncG93ZXIvbW9yZXRyaWdwb3dlci5odG1sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5hcmdzWzBdLmlzTGluZWFyKGR4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBzeW1ib2wucG93ZXIuc3VidHJhY3QobmV3IEZyYWMoMSkpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBzeW1ib2wuY2xvbmUoKS50b1VuaXRNdWx0aXBsaWVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBfLnBhcnNlKGZvcm1hdCgoZm5hbWUgPT09IENPVCA/ICctJyA6ICcnKSArICcxLyh7Mn0qezB9KSp7M30oezF9KV4oezB9KScsIG4sIGFyZywgYSwgZm5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucG93ZXIgPSByLnBvd2VyLnN1YnRyYWN0KG5ldyBGcmFjKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHIucG93ZXIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBfLnBhcnNlKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zdWJ0cmFjdCh3LCBfXy5pbnRlZ3JhdGUociwgZHgsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZWMoeClebiBvciBjc2MoeCleblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IFNFQyB8fCBmbmFtZSA9PT0gQ1NDKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cDovL3d3dy5zb3NtYXRoLmNvbS9jYWxjdWx1cy9pbnRlZ3JhdGlvbi9tb3JldHJpZ3Bvd2VyL21vcmV0cmlncG93ZXIuaHRtbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbjEgPSBzeW1ib2wucG93ZXIuc3VidHJhY3QobmV3IEZyYWMoMSkpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbjIgPSBzeW1ib2wucG93ZXIuc3VidHJhY3QobmV3IEZyYWMoMikpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjIgPSBmbmFtZSA9PT0gU0VDID8gVEFOIDogQ09ULFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBzeW1ib2wuY2xvbmUoKS50b1VuaXRNdWx0aXBsaWVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Vfc3RyID0gZm9ybWF0KChmbmFtZSA9PT0gQ1NDID8gJy0nIDogJycpICsgJzEvKHswfSp7MX0pKns0fSh7M30pXih7Mn0pKns1fSh7M30pJywgYSwgbjEsIG4yLCBhcmcsIGZuYW1lLCBmMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9IF8ucGFyc2UocGFyc2Vfc3RyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5wb3dlciA9IHIucG93ZXIuc3VidHJhY3QobmV3IEZyYWMoMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyLnBvd2VyLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBfLnBhcnNlKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZCh3LCBfLm11bHRpcGx5KG5ldyBTeW1ib2wobjIgLyBuMSksIF9fLmludGVncmF0ZShyLCBkeCwgZGVwdGgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoKGZuYW1lID09PSBDT1NIIHx8IGZuYW1lID09PSBTSU5IKSAmJiBzeW1ib2wucG93ZXIuZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShzeW1ib2wuZm5UcmFuc2Zvcm0oKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbC5tdWx0aXBsaWVyID0gcmV0dmFsLm11bHRpcGxpZXIubXVsdGlwbHkobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wYXJ0aWFsX2ZyYWN0aW9uKHN5bWJvbCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVuID0gc3ltYm9sLmdldERlbm9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlbi5ncm91cCA9PT0gUylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NlcGFyYXRlIHRoZSBjb2VmZmljaWVudCBzaW5jZSBhbGwgd2UgY2FyZSBhYm91dCBhcmUgc3ltYm9scyBjb250YWluaW5nIGR4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZiA9IHN5bWJvbC5zdHJpcFZhcihkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbm93IGdldCBvbmx5IHRob3NlIHRoYXQgYXBwbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNmc3ltYm9sID0gXy5kaXZpZGUoc3ltYm9sLmNsb25lKCksIGNvZWZmLmNsb25lKCkpOyAvL2EgY29lZmYgZnJlZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wZWZvcm0gYSBjb3JyZWN0aW9uIGZvciBzdHJpcFZhci4gVGhpcyBpcyBhIHNlcmlvdXMgVE9ETyFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29lZmYuY29udGFpbnMoZHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZnN5bWJvbCA9IF8ubXVsdGlwbHkoY2ZzeW1ib2wsIGNvZWZmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBvbmx5IGhhdmUgb25lIHN5bWJvbCBsZWZ0IHRoZW4gbGV0J3Mgbm90IHdhc3RlIHRpbWUuIEp1c3QgcHVsbCB0aGUgaW50ZWdyYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hbmQgbGV0IHRoZSBjaGlwcyBmYWxsIHdoZXJlIHRoZXkgbWF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNmc3ltYm9sLmdyb3VwICE9PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2ZzeW1ib2wuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLmludGVncmF0ZShfLmV4cGFuZChzeW1ib2wpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25seSBmYWN0b3IgZm9yIG11bHRpdmFyaWF0ZSB3aGljaCBhcmUgcG9seW5vbWlhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNmc3ltYm9sLmNsb25lKCkudG9MaW5lYXIoKS5pc1BvbHkodHJ1ZSkgJiYgY29yZS5VdGlscy52YXJpYWJsZXMoY2ZzeW1ib2wpLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZnN5bWJvbCA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKGNmc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoY2ZzeW1ib2wsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGNvbGxlY3QgdGhlIHN5bWJvbHMgYW5kIHNvcnQgdGhlbSBkZXNjZW5kaW5nIGdyb3VwLCBkZXNjZW5kaW5nIHBvd2VyLCBkZXNjZW5kaW5nIGFscGFiZXRoaWNhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IGNmc3ltYm9sLmNvbGxlY3RTeW1ib2xzKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEuZ3JvdXAgPT09IGIuZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoTnVtYmVyKGEucG93ZXIpID09PSBOdW1iZXIoYi5wb3dlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhIDwgYilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTsgLy9JIHdhbnQgc2luIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5wb3dlciAtIGEucG93ZXI7IC8vZGVzY2VuZGluZyBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5ncm91cCAtIGEuZ3JvdXA7IC8vZGVzY2VuZGluZyBncm91cHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bndyYXBwZWQgPSBTeW1ib2wudW53cmFwU1FSVCh4LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih1bndyYXBwZWQuZm5hbWUgPT09IEVYUCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJyh7MX0pKmVeKHswfSknLCB1bndyYXBwZWQuYXJnc1swXSwgdW53cmFwcGVkLm11bHRpcGxpZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVud3JhcHBlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBzeW1ib2xzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5wb3dlciA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5pbnRlZ3JhdGUoXy5leHBhbmQoc3ltYm9sKSwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHRoZSBkZW5vbWluYXRvciBpcyBvbmUgbHVtcGVkIHRvZ2V0aGVyIHN5bWJvbCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2VuZXJhdGUgYW4gaW1hZ2UgZm9yIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGwgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnkgdSBzdWJzdGl0dXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnVfc3Vic3RpdHV0aW9uKHN5bWJvbHMsIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7LyogZmFpbGVkIDpgKCovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFyZXR2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbm8gc3VjY2VzcyB3aXRoIHUgc3Vic3RpdHV0aW9uIHNvIGxldCdzIHRyeSBrbm93biBjb21iaW5hdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXJlIHRoZXkgdHdvIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcxID0gc3ltYm9sc1swXS5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZzIgPSBzeW1ib2xzWzFdLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0xID0gc3ltYm9sc1swXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMiA9IHN5bWJvbHNbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuMSA9IHN5bTEuZm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuMiA9IHN5bTIuZm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IHRoZSBzeW1ib2wgbWludXMgdGhlIGNvZWZmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLm11bHRpcGx5KHN5bTEuY2xvbmUoKSwgc3ltMi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGcxID09PSBGTiAmJiBnMiA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmbjEgPT09IExPRyB8fCBmbjIgPT09IExPRykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wuY2xvbmUoKSwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9scy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5mbmFtZSA+IGEuZm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnMSA9IHN5bTEuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhlIGFyZ3VtZW50cyBhcmUgc3VpdGFibGUuIFdlIGRvbid0IGtub3cgaG93IHRvIGludGVncmF0ZSBub24tbGluZWFyIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighYXJnMS5pc0xpbmVhcigpIHx8ICEoYXJnMS5ncm91cCA9PT0gQ1AgfHwgYXJnMS5ncm91cCA9PT0gQ0IgfHwgYXJnMS5ncm91cCA9PT0gUykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb21wID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhhcmcxLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkZWNvbXBbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGRlY29tcFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXguaXNMaW5lYXIoKSkgLy9hZ2Fpbi4uLiBsaW5lYXIgYXJndW1lbnRzIG9ubHkgd3J0IHhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhleSBoYXZlIHRvIGhhdmUgdGhlIHNhbWUgYXJndW1lbnRzIGFuZCB0aGVuIHdlIGhhdmUgY2xlYXJlZCBhbGwgdGhlIGNoZWNrIHRvIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSB3ZSBjYW4gaW50ZWdyYXRlIEZOICYgRk5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZzIgPSBzeW0yLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIHRoYXQgdGhlaXIgYXJndW1lbnQgbWF0Y2hlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhcmcxLmVxdWFscyhhcmcyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZm4xID09PSBTSU4gJiYgZm4yID09PSBDT1MgfHwgZm4xID09PSBDT1MgJiYgZm4yID09PSBTSU4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0xLnBvd2VyLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7Ly93ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGUsIHNpbih4KV5uL2Nvcyh4KV5tIHdoZXJlIG0gPiBuLCAgeWV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGluIHRoZSBmb3JtIHNpbih4KV5uKmNvcyh4KV5uIHRoZW4gd2UgY2FuIGp1c3QgcmV0dXJuIHRhbih4KV5uIHdoaWNoIHdlIGtub3cgaG93IHRvIGludGVncmF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZuMSA9PT0gU0lOICYmIHN5bTEucG93ZXIuYWRkKHN5bTIucG93ZXIpLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0xLmZuYW1lID0gVEFOO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0xLnVwZGF0ZUhhc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKHN5bTEsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihldmVuKHN5bTEucG93ZXIpICYmIGZuMiA9PT0gQ09TICYmIHN5bTIucG93ZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJhbnNmb3JtIHNpbl4oMipuKSB0byAoMS1jb3NeMileblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBOdW1iZXIoc3ltMS5wb3dlcikgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfc3ltID0gXy5wYXJzZShmb3JtYXQoJygxLWNvcyh7MH0pXjIpXih7MX0pJywgc3ltMS5hcmdzWzBdLCBuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5leHBhbmQoXy5tdWx0aXBseShuZXdfc3ltLCBzeW0yLmNsb25lKCkpKSwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZXZlbihzeW0xLnBvd2VyKSAmJiBmbjIgPT09IFNJTiAmJiBzeW0yLnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyYW5zZm9ybSBjb3NeKDIqbikgdG8gKDEtc2luXjIpXm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gTnVtYmVyKHN5bTEucG93ZXIpIC8gMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3N5bSA9IF8ucGFyc2UoZm9ybWF0KCcoMS1zaW4oezB9KV4yKV4oezF9KScsIHN5bTEuYXJnc1swXSwgbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKF8uZXhwYW5kKF8ubXVsdGlwbHkobmV3X3N5bSwgc3ltMi5jbG9uZSgpKSksIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMV9ldmVuID0gY29yZS5VdGlscy5ldmVuKHN5bTEucG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMl9ldmVuID0gY29yZS5VdGlscy5ldmVuKHN5bTIucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFwMV9ldmVuIHx8ICFwMl9ldmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUsIHIsIHRyYW5zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2luY2UgY29zKHgpIGlzIG9kZCBpdCBjYXJyaWVzIGR1LiBJZiBzaW4gd2FzIG9kZCB0aGVuIGl0IHdvdWxkIGJlIHRoZSBvdGhlciB3YXkgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9rbm93IHRoYXQgcDEgc2F0aWZpZXMgdGhlIG9kZCBwb3J0aW9uIGluIHRoaXMgY2FzZS4gSWYgcDIgZGlkIHRoYW4gaXQgd291bGQgY29udGFpbiByXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXAxX2V2ZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91ID0gc2luKHgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBzeW0yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gc3ltMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBzeW0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gc3ltMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIHNpZ24gb2YgZHUuIEluIHRoaXMgY2FzZSByIGNhcnJpZXMgZHUgYXMgc3RhdGVkIGJlZm9yZSBhbmQgRChjb3MoeCkseCkgPSAtc2luKHgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSB1LmZuYW1lID09PSBDT1MgPyAtMSA6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gci5wb3dlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBkdSBlLmcuIGNvcyh4KV4yKnNpbih4KV4zIGR4IC0+IGNvcyh4KV4yKnNpbih4KV4yKnNpbih4KS4gV2UncmUgbGVmdCB3aXRoIHR3byBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXZlbiBwb3dlcnMgYWZ0ZXJ3YXJkcyB3aGljaCBjYW4gYmUgdHJhbnNmb3JtZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSAobiAtIDEpIC8gMixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSB0aGUgdHJhbnNmb3JtYXRpb24gY29zKHgpXjIgPSAxIC0gc2luKHgpXjJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zID0gXy5wYXJzZSgnKDEtJyArIHUuZm5hbWUgKyBjb3JlLlV0aWxzLmluQnJhY2tldHMoYXJnMSkgKyAnXjIpXicgKyBrKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bSA9IF8uZXhwYW5kKF8ubXVsdGlwbHkobmV3IFN5bWJvbChzaWduKSwgXy5tdWx0aXBseSh1LmNsb25lKCksIHRyYW5zKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgY2FuIG5vdyBqdXN0IGxvb3AgdGhyb3VnaCBhbmQgaW50ZWdyYXRlIGVhY2ggc2luY2UgaXQncyBub3cganVzdCBhIHBvbHlub21pYWwgd2l0aCBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKHguY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wZXJmb3JtcyBkb3VibGUgYW5nbGUgdHJhbnNmb3JtYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG91YmxlX2FuZ2xlID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHN5bWJvbC5wb3dlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrID0gcCAvIDIsIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5mbmFtZSA9PT0gQ09TKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9ICcoKDEvMikrKGNvcygyKignICsgc3ltYm9sLmFyZ3NbMF0gKyAnKSkvMikpXicgKyBrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gJygoMS8yKS0oY29zKDIqKCcgKyBzeW1ib2wuYXJnc1swXSArICcpKS8yKSleJyArIGs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhleSdyZSBib3RoIGV2ZW4gc28gdHJhbnNmb3JtIGJvdGggdXNpbmcgZG91YmxlIGFuZ2xlIGlkZW50aXRpZXMgYW5kIHdlJ2xsIGp1c3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2JlIGFibGUgdG8gaW50ZWdyYXRlIGJ5IHRoZSBzdW0gb2YgaW50ZWdyYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBkb3VibGVfYW5nbGUoc3ltMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gZG91YmxlX2FuZ2xlKHN5bTIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkoYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IF8uZXhwYW5kKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX18uaW50ZWdyYXRlKHgsIGR4LCBkZXB0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHJldHZhbCwgY29lZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90YW4oeCkqc2VjKHgpXm4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuMSA9PT0gU0VDICYmIGZuMiA9PT0gVEFOICYmIHguaXNMaW5lYXIoKSAmJiBzeW0yLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnc2VjKHswfSleKHsxfSkvKHsxfSknLCBzeW0xLmFyZ3NbMF0sIHN5bTEucG93ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm4xID09PSBUQU4gJiYgZm4yID09PSBTRUMgJiYgeC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1haW5pbmc6IHRhbih4KV4zKnNlYyh4KV42XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltMS5pc0xpbmVhcigpICYmIHN5bTIuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShfLnN5bWZ1bmN0aW9uKFNFQywgW2FyZzEuY2xvbmUoKV0pLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihldmVuKHN5bTEucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKHN5bTEucG93ZXIpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cmFuc2Zvcm0gdGFuZ2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8ucGFyc2UoZm9ybWF0KCcoc2VjKHswfSleMi0xKV4oezF9KScsIHN5bTEuYXJnc1swXSwgcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5leHBhbmQoXy5tdWx0aXBseSh0LCBzeW0yKSksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbjEgPT09IFNFQyAmJiBmbjIgPT09IENPUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEuZm5hbWUgPSBDT1M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMS5pbnZlcnQoKS51cGRhdGVIYXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKF8ubXVsdGlwbHkoc3ltMSwgc3ltMiksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuMSA9PT0gU0lOICYmIGZuMiA9PT0gQ1NDKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMi5mbmFtZSA9IFNJTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0yLmludmVydCgpLnVwZGF0ZUhhc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5tdWx0aXBseShzeW0xLCBzeW0yKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGFuL2Nvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbjEgPT09IFRBTiAmJiAoZm4yID09PSBDT1MgfHwgZm4yID09PSBTSU4pICYmIHN5bTIucG93ZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8ubXVsdGlwbHkoc3ltMS5mblRyYW5zZm9ybSgpLCBzeW0yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5leHBhbmQodCksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8ubXVsdGlwbHkoc3ltMS5mblRyYW5zZm9ybSgpLCBzeW0yLmZuVHJhbnNmb3JtKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLmV4cGFuZCh0KSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IEluIHByb2dyZXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoKGZuMSA9PT0gU0lOIHx8IGZuMSA9PT0gQ09TKSAmJiAoZm4yID09PSBTSU4gfHwgZm4yID09PSBDT1MpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltMS5pc0xpbmVhcigpICYmIHN5bTIuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgaW4gdGhlIGZvcm0gY29zKGEqeCkqc2luKGIqeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0xLmFyZ3NbMF0uaXNMaW5lYXIoKSAmJiBzeW0yLmFyZ3NbMF0uaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VzZSBpZGVudGl0eSAoc2luKGIqeCthKngpK3NpbihiKngtYSp4KSkvMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXgsIGJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmbjIgPT09IFNJTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXggPSBzeW0xLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieCA9IHN5bTIuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ4ID0gc3ltMS5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXggPSBzeW0yLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSB0aGUgdHJhbnNmb3JtYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IF8ucGFyc2UoZm9ybWF0KCcoc2luKCh7MX0pKyh7MH0pKStzaW4oKHsxfSktKHswfSkpKS8yJywgYXgudG9TdHJpbmcoKSwgYngudG9TdHJpbmcoKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pbnRlZ3JhdGUgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKGYsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0cmlnVHJhbnNmb3JtKHN5bWJvbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5leHBhbmQodHJhbnNmb3JtZWQpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9scy5tYXAoZnVuY3Rpb24gKHN5bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHN5bS5mblRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IF8ubXVsdGlwbHkodHJhbnNmb3JtZWQsIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXy5leHBhbmQodHJhbnNmb3JtZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUodCwgZHgsIGRlcHRoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmV0dmFsLmhhc0ludGVncmFsKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKHRyaWdUcmFuc2Zvcm0odHJhbnNmb3JtZWQuY29sbGVjdFN5bWJvbHMoKSksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZzEgPT09IEZOICYmIGcyID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bTFfaXNfbGluZWFyID0gc3ltMS5pc0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTEuZm5hbWUgPT09IENPUyAmJiBzeW0xX2lzX2xpbmVhciAmJiBzeW0yLnBvd2VyLmVxdWFscygtMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ0NpJywgW3N5bTEuYXJnc1swXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltMS5mbmFtZSA9PT0gQ09TICYmIHN5bTIucG93ZXIuZXF1YWxzKC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5tdWx0aXBseShzeW0xLmZuVHJhbnNmb3JtKCksIHN5bTIuY2xvbmUoKSksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltMS5mbmFtZSA9PT0gQ09TSCAmJiBzeW0xX2lzX2xpbmVhciAmJiBzeW0yLnBvd2VyLmVxdWFscygtMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ0NoaScsIFtzeW0xLmFyZ3NbMF1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEuZm5hbWUgPT09IENPU0ggJiYgc3ltMi5wb3dlci5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLm11bHRpcGx5KHN5bTEuZm5UcmFuc2Zvcm0oKSwgc3ltMi5jbG9uZSgpKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLmZuYW1lID09PSBTSU4gJiYgc3ltMV9pc19saW5lYXIgJiYgc3ltMi5wb3dlci5lcXVhbHMoLTEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdTaScsIFtzeW0xLmFyZ3NbMF1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEuZm5hbWUgPT09IFNJTiAmJiBzeW0yLnBvd2VyLmVxdWFscygtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKF8ubXVsdGlwbHkoc3ltMS5mblRyYW5zZm9ybSgpLCBzeW0yLmNsb25lKCkpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEuZm5hbWUgPT09IFNJTkggJiYgc3ltMV9pc19saW5lYXIgJiYgc3ltMi5wb3dlci5lcXVhbHMoLTEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdTaGknLCBbc3ltMS5hcmdzWzBdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLmZuYW1lID09PSBTSU5IICYmIHN5bTIucG93ZXIuZXF1YWxzKC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5tdWx0aXBseShzeW0xLmZuVHJhbnNmb3JtKCksIHN5bTIuY2xvbmUoKSksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltMS5mbmFtZSA9PT0gTE9HICYmIHN5bTIucG93ZXIuZXF1YWxzKC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xvZyh4KV5uL3ggPSBsb2coeCleKG4rMSkvKG4rMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24ucG9seV9pbnRlZ3JhdGUoc3ltMSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLmZuYW1lID09PSAnZXJmJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0yLnBvd2VyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRjID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhzeW0xLmFyZ3NbMF0sIGR4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYV8gPSBkY1swXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeF8gPSBkY1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gc3ltMS5hcmdzWzBdLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKGVeKC0oKHsyfSkpXjIpKihzcXJ0KHBpKSplXigoKHsyfSkpXjIpKigyKih7MH0pXjIqKHsxfSleMi0zKSplcmYoKHsyfSkpKzIqKHswfSkqKHsxfSktMikpLyg0KnNxcnQocGkpKih7MH0pXjIpJywgYV8sIHhfLCBhcmcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIGdyb3VwIFMgaXMgZ3VhcmFudGVlZCBjb252ZXJnZW5jZSB3ZSBuZWVkIG5vdCB3b3JyeSBhYm91dCB0cmFja2luZyBkZXB0aCBvZiBpbnRlZ3JhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcxID09PSBFWCAmJiBnMiA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gZm4xID09PSBMT0cgPyBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKHN5bTEuYXJnc1swXSwgZHgpWzFdIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0xLmlzRSgpICYmIChzeW0xLnBvd2VyLmdyb3VwID09PSBTIHx8IHN5bTEucG93ZXIuZ3JvdXAgPT09IENCKSAmJiBzeW0yLnBvd2VyLmVxdWFscygtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignRWknLCBbc3ltMS5wb3dlci5jbG9uZSgpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm4xID09PSBMT0cgJiYgeC52YWx1ZSA9PT0gc3ltMi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShzeW0xLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnMSA9PT0gUEwgJiYgZzIgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHRyeSB0byByZWR1Y2UgdGhlIHRvcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTIudmFsdWUgPT09IHN5bTEudmFsdWUgJiYgc3ltMS5wb3dlci5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgbG93ZXN0IHBvd2VyIGluIHRoZSBkZW5vbWluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGQgPSBNYXRoLm1pbi5hcHBseShudWxsLCBjb3JlLlV0aWxzLmtleXMoc3ltMS5zeW1ib2xzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBsb3dlc3QgY29tbW9uIHZhbHVlIGJldHdlZW4gZGVub21pbmF0b3IgYW5kIG51bWVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGMgPSBNYXRoLm1pbihwZCwgc3ltMi5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVkdWNlIGJvdGggZGVub21pbmF0b3IgYW5kIG51bWVyYXRvciBieSB0aGF0IGZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gc3ltMi5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IucG93ZXIgPSBuZXcgRnJhYyhwYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTIgPSBfLmRpdmlkZShzeW0yLCBmYWN0b3IuY2xvbmUoKSk7IC8vcmVkdWNlIHRoZSBkZW5vbWluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8uYWRkKHQsIF8uZGl2aWRlKHguY2xvbmUoKSwgZmFjdG9yLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQubXVsdGlwbGllciA9IHN5bTEubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5kaXZpZGUoc3ltMiwgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wYXJ0aWFsX2ZyYWN0aW9uKHN5bWJvbCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZzEgPT09IENQICYmIGcyID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBzeW0xLmNsb25lKCkudG9MaW5lYXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZfaXNfbGluZWFyID0gY29yZS5BbGdlYnJhLmRlZ3JlZShmLCBfLnBhcnNlKGR4KSkuZXF1YWxzKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFuZGxlIGNhc2VzIHheKDIqbikvc3FydCgxLXheMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0xLnBvd2VyLmVxdWFscygtMSAvIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNvbXAgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKHN5bTEuY2xvbmUoKS50b0xpbmVhcigpLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZGVjb21wWzBdLm5lZ2F0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkZWNvbXBbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGRlY29tcFszXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMSA9IE51bWJlcihzeW0xLnBvd2VyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IE51bWJlcihzeW0yLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNJbnQocDIpICYmIGNvcmUuVXRpbHMuZXZlbihwMikgJiYgeC5wb3dlci5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIHN1YnN0aXR1dGlvbiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gXy5kaXZpZGUoXy5tdWx0aXBseShfLnBvdyhiLmNsb25lKCksIG5ldyBTeW1ib2woMikpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnN5bWZ1bmN0aW9uKFNRUlQsIFtfLmRpdmlkZShiLmNsb25lKCksIGEuY2xvbmUoKSldKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8ucG93KGEuY2xvbmUoKSwgbmV3IFN5bWJvbCgyKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IF8ubXVsdGlwbHkoYywgXy5zeW1mdW5jdGlvbihTUVJULCBbYl0pLmludmVydCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1teSA9IF8ucGFyc2UoJ3Npbih1KScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbXkucG93ZXIgPSBkdW1teS5wb3dlci5tdWx0aXBseShzeW0yLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhbCA9IF9fLmludGVncmF0ZShkdW1teSwgJ3UnLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmtzdWIgPSBfLnBhcnNlKEFTSU4gKyAnKCcgKyBTUVJUICsgJygnICsgYSArICcvJyArIGIgKyAnKSonICsgZHggKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShjLCBpbnRlZ3JhbC5zdWIobmV3IFN5bWJvbCgndScpLCBia3N1YikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYocDEgPT09IC0xIC8gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVfdHJhbnNmb3JtID0gZnVuY3Rpb24gKGYsIHUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZWdyYWwgPSBfLnBhcnNlKF9fLmludGVncmF0ZShmLCBkeCwgZGVwdGgsIG9wdCkuc3ViKGR4LCBmb3JtYXQodSwgZHgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWludGVncmFsLmhhc0ludGVncmFsKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlZ3JhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHAyID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHVfdHJhbnNmb3JtKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5leHBhbmQoXy5leHBhbmQoXy5wb3coXy5tdWx0aXBseShzeW0xLmludmVydCgpLCBzeW0yLmludmVydCgpKSwgbmV3IFN5bWJvbCgyKSkpKS5pbnZlcnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcXJ0KDEtMS8oezB9KV4yKSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHAyID09PSAtMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgdHJhbnNmb3JtYXRpb24gdG8gc2VlIGlmIGl0IG1hdGNoZXMgYXNpbih4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHVfdHJhbnNmb3JtKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5zcXJ0KF8uZXhwYW5kKF8uZGl2aWRlKF8ucG93KHN5bWJvbCwgbmV3IFN5bWJvbCgyKSkuaW52ZXJ0KCksIF8ucG93KG5ldyBTeW1ib2woZHgpLCBuZXcgU3ltYm9sKDIpKSkubmVnYXRlKCkpKS5pbnZlcnQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcXJ0KDEtMS8oezB9KV4yKSdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLnBvd2VyLmVxdWFscygtMSkgJiYgc3ltMi5pc0xpbmVhcigpICYmIGZfaXNfbGluZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBhcnRpYWxfZnJhY3Rpb24oc3ltYm9sLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKCFzeW0xLnBvd2VyLmxlc3NUaGFuKDApICYmIGlzSW50KHN5bTEucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3VtIG9mIGludGVncmFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kZWQgPSBfLmV4cGFuZChzeW0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gUEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmVhY2goZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfXy5pbnRlZ3JhdGUoXy5tdWx0aXBseShzeW0yLmNsb25lKCksIHkpLCBkeCwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9fLmludGVncmF0ZShfLm11bHRpcGx5KHN5bTIuY2xvbmUoKSwgeCksIGR4LCBkZXB0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLnBvd2VyLmxlc3NUaGFuKC0yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLnBvd2VyLmxlc3NUaGFuKDApICYmIHN5bTIucG93ZXIuZ3JlYXRlclRoYW4oMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29tcCA9IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcoc3ltMS5jbG9uZSgpLnRvTGluZWFyKCksIGR4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gZGVjb21wWzBdLm5lZ2F0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkZWNvbXBbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGRlY29tcFszXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA9IHN5bTEuY2xvbmUoKS50b0xpbmVhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCAhPT0gUEwgJiYgeC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE51bWJlcihzeW0yLnBvd2VyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHUgPSAnX3VfJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IG5ldyBTeW1ib2woZHUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3B1bGwgdGhlIGludGVncmFsIHdpdGggdGhlIHN1YnNpdHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFUgPSBfLmV4cGFuZChfLmRpdmlkZShfLnBvdyhfLnN1YnRyYWN0KHUuY2xvbmUoKSwgYi5jbG9uZSgpKSwgbmV3IFN5bWJvbChwKSksIHUuY2xvbmUoKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2VuZXJhdGUgYSBzY29wZSBmb3IgcmVzdWJiaW5nIHRoZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlW2R1XSA9IGZuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFUyID0gXy5wYXJzZShVLCBzY29wZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoVTIsIGR4LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTIucG93ZXIuZ3JlYXRlclRoYW4oeC5wb3dlcikgfHwgc3ltMi5wb3dlci5lcXVhbHMoeC5wb3dlcikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZhY3RvciBvdXQgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9ycyA9IG5ldyBjb3JlLkFsZ2VicmEuQ2xhc3Nlcy5GYWN0b3JzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0xID0gY29yZS5BbGdlYnJhLkZhY3Rvci5jb2VmZkZhY3RvcihzeW0xLmludmVydCgpLCBmYWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBjb3JlLkFsZ2VicmEuZGl2aWRlKHN5bTIsIHN5bTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pdCBhc3N1bWVkIHRoYXQgdGhlIHJlc3VsdCB3aWxsIGJlIG9mIGdyb3VwIENCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkaXYuZ3JvdXAgIT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXYuZWFjaChmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9fLmludGVncmF0ZSh0LCBkeCwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3B1dCBiYWNrIHRoZSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5lYWNoKGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUocmV0dmFsLCBmYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmV4cGFuZChyZXR2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnkgc29tZXRoaW5nIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wYXJ0aWFsX2ZyYWN0aW9uKHN5bWJvbCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFuZGxlIGNhc2VzIHN1Y2ggYXMgKDEteF4yKV4obi8yKSp4XihtKSB3aGVyZSBuIGlzIG9kZCBfX18gY3JhY2tpbmcga251Y2tsZXMuLi4gVGhpcyBjYW4gZ2V0IGEgbGl0dGxlIGhhaXJ5IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0xLnBvd2VyLmRlbi5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXNzdW1lIHRoZSBmdW5jdGlvbiBpcyBpbiB0aGUgZm9ybSAoYV4yLWIqeF5uKV4obS8yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRjID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhzeW0xLmNsb25lKCkudG9MaW5lYXIoKSwgZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VzaW5nIHRoZSBhYm92ZSBkZWZpbml0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBkY1szXSwgeCA9IGRjWzFdLCBiID0gZGNbMF0sIGJ4ID0gZGNbMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4LnBvd2VyLmVxdWFscygyKSAmJiBiLmxlc3NUaGFuKDApKSB7IC8vaWYgbiBpcyBldmVuICYmIGIgaXMgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2UgYSBlcXVhbCAxIHNvIHdlIGNhbiBkbyBhIHRyaWcgc3ViXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWEuZXF1YWxzKDEpKSB7IC8vZGl2aWRlIGEgb3V0IG9mIGV2ZXJ5dGhpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tb3ZlIGEgdG8gdGhlIGNvZWZmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmID0gXy5tdWx0aXBseShjb2VmZiwgXy5wb3coYSwgbmV3IFN5bWJvbCgyKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gXy5kaXZpZGUoXy5wb3coYi5jbG9uZSgpLm5lZ2F0ZSgpLCBuZXcgU3ltYm9sKDEgLyAyKSksIF8ucG93KGEsIG5ldyBTeW1ib2woMSAvIDIpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdSA9IF8uc3ltZnVuY3Rpb24oQ09TLCBbbmV3IFN5bWJvbCh1KV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29zbiA9IF8ucG93KF8uc3ltZnVuY3Rpb24oQ09TLCBbbmV3IFN5bWJvbCh1KV0pLCBuZXcgU3ltYm9sKHN5bTEucG93ZXIubnVtKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBYID0gXy5wb3coXy5zeW1mdW5jdGlvbihTSU4sIFtuZXcgU3ltYm9sKHUpXSksIG5ldyBTeW1ib2woc3ltMi5wb3dlcikpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gXy5tdWx0aXBseShfLm11bHRpcGx5KGNvc24sIGR1KSwgWCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhbCA9IF9fLmludGVncmF0ZSh2YWwsIHUsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2J1dCByZW1lbWJlciB0aGF0IHUgPSBhc2luKHNxcnQoYikqYSp4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGludGVncmFsLnN1Yih1LCBfLnN5bWZ1bmN0aW9uKEFTSU4sIFtfLm11bHRpcGx5KG5ldyBTeW1ib2woZHgpLCBjKV0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBhcnRpYWxfZnJhY3Rpb24oc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmX2lzX2xpbmVhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24ucGFydGlhbF9mcmFjdGlvbihzeW1ib2wsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLmlzQ29tcG9zaXRlKCkgJiYgc3ltMi5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zdW0gb2YgaW50ZWdyYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0xLnBvd2VyLmdyZWF0ZXJUaGFuKDApICYmIHN5bTIucG93ZXIuZ3JlYXRlclRoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21iaW5lIGFuZCBwdWxsIHRoZSBpbnRlZ3JhbCBvZiBlYWNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBfLmV4cGFuZChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfXy5pbnRlZ3JhdGUoeCwgZHgsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAxID0gTnVtYmVyKHN5bTEucG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gTnVtYmVyKHN5bTIucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwMSA8IDAgJiYgcDIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N3YXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gc3ltMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEgPSBzeW0yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMiA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocDEgPT09IC0xICYmIHAyID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24ucGFydGlhbF9mcmFjdGlvbihzeW1ib2wsIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gXy5tdWx0aXBseSh4LCBzeW0yLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhbCA9IF9fLmludGVncmF0ZShrLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgaW50ZWdyYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcxID09PSBDUCAmJiBzeW1ib2xzWzBdLnBvd2VyLmdyZWF0ZXJUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMSA9IF8uZXhwYW5kKHN5bTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX18uaW50ZWdyYXRlKF8ubXVsdGlwbHkoeCwgc3ltMi5jbG9uZSgpKSwgZHgsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcxID09PSBGTiAmJiBnMiA9PT0gRVggJiYgY29yZS5VdGlscy5pbl9odHJpZyhzeW0xLmZuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEgPSBzeW0xLmZuVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKF8uZXhwYW5kKF8ubXVsdGlwbHkoc3ltMSwgc3ltMikpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnMSA9PT0gRk4gJiYgZzIgPT09IENQIHx8IGcyID09PSBGTiAmJiBnMSA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihnMiA9PT0gRk4gJiYgZzEgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gc3ltMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMSA9IHN5bTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTIgPSB0OyAvL3N3YXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1LCBzeW0yX2Nsb25lLCBwLCBxLCBzYSwgc2I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHUgPSBTeW1ib2wudW53cmFwU1FSVChfXy5kaWZmKHN5bTEuY2xvbmUoKSwgZHgpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0yX2Nsb25lID0gU3ltYm9sLnVud3JhcFNRUlQoc3ltMiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZHUucG93ZXIuZXF1YWxzKHN5bTJfY2xvbmUucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuZXcgU3ltYm9sKHN5bTIucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYSA9IGR1LmNsb25lKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2IgPSBzeW0yLmNsb25lKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGNvcmUuQWxnZWJyYS5kaXZpZGUoc2EudG9MaW5lYXIoKSwgc2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihxLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5xID0gXy5wb3cocSwgcC5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KG5xLCBfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShzeW0xLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWEgPSBzeW0xLmNsb25lKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYiA9IHN5bTIuY2xvbmUoKS50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGcxID09PSBFWCAmJiBnMiA9PT0gRVggJiYgc3ltMS5wb3dlci5jb250YWlucyhkeCkgJiYgc3ltMi5wb3dlci5jb250YWlucyhkeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFzeW1hLmNvbnRhaW5zKGR4KSAmJiAhc3ltYi5jb250YWlucyhkeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJygoezB9KV4oKHsyfSkqKHs0fSkpKih7MX0pXigoezN9KSooezR9KSkpLyhsb2coKHswfSleKHsyfSkpK2xvZygoezF9KV4oezN9KSkpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1hLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYi50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEucG93ZXIubXVsdGlwbGllci50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTIucG93ZXIubXVsdGlwbGllci50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihsID09PSAzICYmIChzeW1ib2xzWzJdLmdyb3VwID09PSBTICYmIHN5bWJvbHNbMl0ucG93ZXIubGVzc1RoYW4oMikgfHwgc3ltYm9sc1swXS5ncm91cCA9PT0gQ1ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHN5bWJvbHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZpcnN0Lmdyb3VwID09PSBDUCkgeyAvL1RPRE8ge3N1cHBvcnQgaGlnaGVyIHBvd2VycyBvZiB4IGluIHRoZSBmdXR1cmV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmaXJzdC5wb3dlci5ncmVhdGVyVGhhbigxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IF8uZXhwYW5kKGZpcnN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gXy5tdWx0aXBseShzeW1ib2xzWzFdLCBzeW1ib2xzWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfLm11bHRpcGx5KHgsIHIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGcgPSBfXy5pbnRlZ3JhdGUodCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIGludGcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyeSBpbnRlZ3JhdGlvbiBieSBwYXJ0cyBhbHRob3VnaCB0ZWNobmljYWxseSBpdCB3aWxsIG5ldmVyIHdvcmtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGFsbF9mdW5jdGlvbnMoc3ltYm9scykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gc3ltYm9scy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLm11bHRpcGx5KHQsIHN5bWJvbHNbaV0uZm5UcmFuc2Zvcm0oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8uZXhwYW5kKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUodCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb25lIG1vcmUgZ29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdHJpZ1RyYW5zZm9ybShzeW1ib2xzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKF8uZXhwYW5kKHRyYW5zZm9ybWVkKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgY29lZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIGFuIGludGVncmFsIHdhcyBmb3VuZCB0aGVuIHdlIHJldHVybiBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHJldHZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjYXRjaChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZyBpZiBpdCdzIGEgTm9JbnRlZ3JhbEZvdW5kIGVycm9yIG90aGVyd2lzZSBsZXQgaXQgYnViYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIShlcnJvciBpbnN0YW5jZW9mIE5vSW50ZWdyYWxGb3VuZCB8fCBlcnJvciBpbnN0YW5jZW9mIGNvcmUuZXhjZXB0aW9ucy5EaXZpc2lvbkJ5WmVybykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vbm8gc3ltYm9sIGZvdW5kIHNvIHdlIHJldHVybiB0aGUgaW50ZWdyYWwgYWdhaW5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdpbnRlZ3JhdGUnLCBbb3JpZ2luYWxfc3ltYm9sLCBkdF0pO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWZpbnQ6IGZ1bmN0aW9uIChzeW1ib2wsIGZyb20sIHRvLCBkeCkge1xyXG4gICAgICAgICAgICBkeCA9IGR4IHx8ICd4JzsgLy9tYWtlIHggdGhlIGRlZmF1bHQgdmFyaWFibGUgb2YgaW50ZWdyYXRpb25cclxuICAgICAgICAgICAgdmFyIGdldF92YWx1ZSA9IGZ1bmN0aW9uIChpbnRlZ3JhbCwgdmFycywgcG9pbnQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoaW50ZWdyYWwsIHZhcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaXQgZmFpbGVkIGZvciBzb21lIHJlYXNvbiBzbyByZXR1cm4gdGhlIGxpbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbSA9IF9fLkxpbWl0LmxpbWl0KGludGVncmFsLCBkeCwgcG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFycyA9IGNvcmUuVXRpbHMudmFyaWFibGVzKHN5bWJvbCksXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVHJpZyA9IHN5bWJvbC5oYXNUcmlnKCk7XHJcbiAgICAgICAgICAgIHZhciByZXR2YWwsIGludGVncmFsO1xyXG5cclxuICAgICAgICAgICAgLy8gRml4ICM1OTMgLSBPbmx5IGFzc3VtZSB0aGUgZmlyc3QgdmFyaWFibGUgaWYgZHggaXMgbm90IGRlZmluZWQuXHJcbiAgICAgICAgICAgIGlmKHZhcnMubGVuZ3RoID09PSAxICYmICFkeClcclxuICAgICAgICAgICAgICAgIGR4ID0gdmFyc1swXTtcclxuXHJcbiAgICAgICAgICAgIGlmKCFoYXNUcmlnKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlZ3JhbCA9IF9fLmludGVncmF0ZShzeW1ib2wsIGR4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIWhhc1RyaWcgJiYgIWludGVncmFsLmhhc0ludGVncmFsKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1cHBlciA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlciA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLCBiO1xyXG4gICAgICAgICAgICAgICAgdXBwZXJbZHhdID0gdG87XHJcbiAgICAgICAgICAgICAgICBsb3dlcltkeF0gPSBmcm9tO1xyXG5cclxuICAgICAgICAgICAgICAgIGEgPSBnZXRfdmFsdWUoaW50ZWdyYWwsIHVwcGVyLCB0bywgZHgpO1xyXG4gICAgICAgICAgICAgICAgYiA9IGdldF92YWx1ZShpbnRlZ3JhbCwgbG93ZXIsIGZyb20sIGR4KTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3VidHJhY3QoYSwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih2YXJzLmxlbmd0aCA9PT0gMSAmJiBmcm9tLmlzQ29uc3RhbnQoKSAmJiB0by5pc0NvbnN0YW50KCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGNvcmUuVXRpbHMuYnVpbGQoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woY29yZS5NYXRoMi5udW1faW50ZWdyYXRlKGYsIE51bWJlcihmcm9tKSwgTnVtYmVyKHRvKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2RlZmludCcsIFtzeW1ib2wsIGZyb20sIHRvLCBkeF0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIExpbWl0OiB7XHJcbiAgICAgICAgICAgIGludGVydmFsOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCdbezB9LCB7MX1dJywgc3RhcnQsIGVuZCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXZlcmdlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLkxpbWl0LmludGVydmFsKCctSW5maW5pdHknLCAnSW5maW5pdHknKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiAoZiwgZywgeCwgbGltLCBkZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYoZGVwdGgrKyA+IFNldHRpbmdzLm1heF9saW1fZGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbiA9IGYuY2xvbmUoKSwgZ2luID0gZy5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQnV0IGZpcnN0IGEgbGl0dGxlIFwiY2hlYXRpbmdcIi4geC98eHwgZW5kcyB1cCBpbiBhbiBpbmZpbml0ZSBsb29wIHNpbmNlIHRoZSBkL2R4IHx4fCAtPiB4L3x4fFxyXG4gICAgICAgICAgICAgICAgLy9UbyBicmVhayB0aGlzIGxvb3Agd2Ugc2ltcGx5IHByb3ZpZGUgdGhlIGFuc3dlci4gS2VlcCBpbiBtaW5kIHRoYXQgY3VycmVudGx5IGxpbWl0IG9ubHkgcHJvdmlkZXNcclxuICAgICAgICAgICAgICAgIC8vdGhlIHR3by1zaWRlZCBsaW1pdC5cclxuICAgICAgICAgICAgICAgIC8vS25vd24gbGltaXRcclxuICAgICAgICAgICAgICAgIGlmKGcuZm5hbWUgPT09IEFCUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gZi5zaWduKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbV9zaWduID0gbGltLnNpZ24oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYobGltLmlzSW5maW5pdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KG5ldyBTeW1ib2woc2lnbiksIG5ldyBTeW1ib2wobGltX3NpZ24pKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihsaW0uZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbSA9IF8ucGFyc2UoZi5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdtID0gXy5wYXJzZShnLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoXy5tdWx0aXBseShmbSwgX18uTGltaXQuaW50ZXJ2YWwoJy0xJywgJzEnKSksIGdtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogU3VwcG9ydCBtb3JlIGxpbWl0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfXy5MaW1pdC5kaXZlcmdlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaXNJbmZpbml0eSA9IGZ1bmN0aW9uIChMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc1ZlY3RvcihMKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgTC5lbGVtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFMLmVsZW1lbnRzW2ldLmlzSW5maW5pdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEwuaXNJbmZpbml0eTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVxdWFscyA9IGZ1bmN0aW9uIChMLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc1ZlY3RvcihMKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBMLmVxdWFscyh2KTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGltMSA9IGV2YWx1YXRlKF9fLkxpbWl0LmxpbWl0KGYuY2xvbmUoKSwgeCwgbGltLCBkZXB0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW0yID0gZXZhbHVhdGUoX18uTGltaXQubGltaXQoZy5jbG9uZSgpLCB4LCBsaW0sIGRlcHRoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaXQncyBpbiBpbmRldGVybWluYXRlIGZvcm0gYXBwbHkgTCdIb3NwaXRhbCdzIHJ1bGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXRlcm1pbmF0ZSA9IGlzSW5maW5pdHkobGltMSkgJiYgaXNJbmZpbml0eShsaW0yKSB8fCBlcXVhbHMobGltMSwgMCkgJiYgZXF1YWxzKGxpbTIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcHVsbCB0aGUgZGVyaXZhdGl2ZXNcclxuICAgICAgICAgICAgICAgICAgICBpZihpbmRldGVybWluYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdCA9IF9fLmRpZmYoZi5jbG9uZSgpLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGd0ID0gX18uZGlmZihnLmNsb25lKCksIHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRfc3ltYm9sID0gXy5leHBhbmQoXy5kaXZpZGUoZnQsIGd0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSB0X3N5bWJvbC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHRfc3ltYm9sLmdldERlbm9tKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlKGluZGV0ZXJtaW5hdGUpXHJcblxyXG4gICAgICAgICAgICAgICAgLy9SRU1FTUJFUjogXHJcbiAgICAgICAgICAgICAgICAvLy0gMS9jb3MoeClcclxuICAgICAgICAgICAgICAgIC8vbi8wIGlzIHN0aWxsIHBvc3NpYmxlIHNpbmNlIHdlIG9ubHkgY2hlY2tlZCBmb3IgMC8wXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVuX2lzX3plcm8gPSBsaW0yLmVxdWFscygwKTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKGdpbi5wb3dlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobGltLmlzQ29uc3RhbnQodHJ1ZSkgJiYgZGVuX2lzX3plcm8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBTeW1ib2wuaW5maW5pdHkoY29yZS5VdGlscy5ldmVuKHApICYmIGxpbTEubGVzc1RoYW4oMCkgPyAtMSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGRlbl9pc196ZXJvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uTGltaXQuZGl2ZXJnZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKGxpbTEsIGxpbTIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJld3JpdGVUb0xvZzogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBzeW1ib2wucG93ZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucG93KG5ldyBTeW1ib2woJ2UnKSwgXy5tdWx0aXBseShwLCBfLnN5bWZ1bmN0aW9uKFNldHRpbmdzLkxPRyArICcnLCBbc3ltYm9sXSkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0U3ViYmVkOiBmdW5jdGlvbiAoZiwgeCwgbGltKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgLy8xLiByZXdyaXRlIEVYIHdpdGggYmFzZSBlXHJcbiAgICAgICAgICAgICAgICBpZihmLmdyb3VwID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBfXy5yZXdyaXRlVG9Mb2coZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLzIuIHRyeSBzaW1wbGUgc3Vic3RpdHV0aW9uXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGYuc3ViKHgsIGxpbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Ob3BlLiBObyBnbywgc28ganVzdCByZXR1cm4gdGhlIHVuc3ViYmVkIGZ1bmN0aW9uIHNvIHdlIGNhbiB0ZXN0IHRoZSBsaW1pdCBpbnN0ZWFkLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNJbnRlcnZhbDogZnVuY3Rpb24gKGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5pc1ZlY3RvcihsaW1pdCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzQ29udmVyZ2VudDogZnVuY3Rpb24gKGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAvL2l0J3Mgbm90IGNvbnZlcmdlbnQgaWYgaXQgbGllcyBvbiB0aGUgaW50ZXJ2YWwgLUluZmluaXR5IHRvIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICBpZihcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JdCBsaWVzIG9uIHRoZSBpbnRlcnZhbCAtSW5maW5pdHkgdG8gSW5maW5pdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX18uTGltaXQuaXNJbnRlcnZhbChsaW1pdCkgJiYgbGltaXQuZWxlbWVudHNbMF0uaXNJbmZpbml0eSAmJiBsaW1pdC5lbGVtZW50c1sxXS5pc0luZmluaXR5IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vV2Ugd2VyZW4ndCBhYmxlIHRvIGNhbGN1bGF0ZSB0aGUgbGltaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQuY29udGFpbnNGdW5jdGlvbignbGltaXQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vVGhlbiBub1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vSXQgaXNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGltaXQ6IGZ1bmN0aW9uIChzeW1ib2wsIHgsIGxpbSwgZGVwdGgpIHtcclxuICAgICAgICAgICAgICAgIC8vU2ltcGxpZnkgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzTGluZWFyKCkgJiYgc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9BcHBseSBzdW0gb2YgbGltaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbWl0ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdCA9IF8uYWRkKGxpbWl0LCBfXy5MaW1pdC5saW1pdChzLCB4LCBsaW0sIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW1pdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDtcclxuXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBjb3JlLkFsZ2VicmEuU2ltcGxpZnkuc2ltcGxpZnkoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZXB0aCA9IGRlcHRoIHx8IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZGVwdGgrKyA+IFNldHRpbmdzLm1heF9saW1fZGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zdG9yZSB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIC8vc3RyaXAgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9saW1pdHNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vd2UgdHJ5IHRoZSBzaW1wbGVzdCBvcHRpb24gZmlyc3Qgd2hlcmUgYyBpcyBzb21lIGxpbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgLy9saW0gYSBhcyB4LT5jID0gYSB3aGVyZSBjIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFt4XSA9IGxpbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9saW0geCBhcyB4LT5jID0gYyB3aGVyZSBjXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXZhbHVhdGUgdGhlIGZ1bmN0aW9uIGF0IHRoZSBnaXZlbiBsaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfLnBhcnNlKHN5bWJvbC5zdWIoeCwgbGltKSwgcG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYSBjb25zdGFudCBvciBpbmZpbml0eSBpcyBrbm93biBzbyB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0LmlzQ29uc3RhbnQodHJ1ZSkgfHwgdC5pc0luZmluaXR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHsgLypOb3RoaW5nLiBNYXliZSB3ZSB0cmllZCB0byBkaXZpZGUgYnkgemVyby4qL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFyZXR2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3BsaXQgdGhlIHN5bWJvbCBpbiB0aGUgbnVtZXJhdG9yIGFuZCB0aGUgZGVub21pbmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSBzeW1ib2wuZ2V0TnVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVuID0gc3ltYm9sLmdldERlbm9tKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVuLmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1dlIHN0aWxsIGRvbid0IGhhdmUgYSBsaW1pdCBzbyB3ZSBnZW5lcmF0ZSB0ZXN0cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9saW1pdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TcGVlZCBib29zdCBmb3IgZXhwb25lbnRpYWxzIGJ5IGRldGVjdGluZyBwYXR0ZXJuc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHN5bWJvbC5jbG9uZSgpLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gc3ltYm9sLnBvd2VyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbnVtID0gZi5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9kZW4gPSBmLmdldERlbm9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuKF9kZW4sIHgsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0IGRldGVjdGlvbiBvZiBwYXR0ZXJuICh4Lyh4KzEpKV54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF9udW0uZ3JvdXAgPT09IFMgJiYgX251bS5tdWx0aXBsaWVyLmlzT25lKCkgJiYgZm4uYXguZ3JvdXAgPT09IFMgJiYgZm4uYi5pc0NvbnN0YW50KHRydWUpICYmIGZuLmEuaXNPbmUoKSAmJiBmbi5iLmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoMS9lXih7MH0pKScsIGZuLmIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xfID0gX18uTGltaXQucmV3cml0ZVRvTG9nKHN5bWJvbC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBiYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG93ID0gc3ltYm9sXy5wb3dlci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBzeW1ib2xfLmNsb25lKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW1fYmFzZSA9IF9fLkxpbWl0LmxpbWl0KGJhc2UsIHgsIGxpbSwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbV9wb3cgPSBfXy5MaW1pdC5saW1pdChwb3csIHgsIGxpbSwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wb3cobGltX2Jhc2UsIGxpbV9wb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBGTiAmJiBzeW1ib2wuYXJncy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2YWx1YXRlcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TcXVlZXplIHRoZW9yZW0gbGltIGYoZyh4KSkgPSBsaW0gZihsaW0gZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBfXy5MaW1pdC5saW1pdChzeW1ib2wuYXJnc1swXSwgeCwgbGltLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaXNWZWN0b3IoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGxpbWl0IG92ZXIgdGhhdCBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gYXJnLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lLmFyZ3NbMF0gPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5MaW1pdC5saW1pdChfLnN5bWZ1bmN0aW9uKHN5bWJvbC5mbmFtZSwgW2VdKSwgeCwgbGltLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShtLCByZXR2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIGFyZ3VtZW50IGlzIGNvbnN0YW50IHRoZW4gd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGFyZy5pc0NvbnN0YW50KHRydWUpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kb3VibGUgY2hlY2sgdGhhdCBpdCBldmFsdWF0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbCA9IF8uc3ltZnVuY3Rpb24oc3ltYm9sLmZuYW1lLCBbYXJnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyaWFsIGV2YWx1YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGUodHJpYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV2YWx1YXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gdHJpYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBsaW1pdCBjb252ZXJnZXMuIFdlJ2xsIGRlYWwgd2l0aCBub24tY29udmVyZ2VudCBvbmVzIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihfXy5MaW1pdC5pc0NvbnZlcmdlbnQoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5mbmFtZSA9PT0gTE9HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChhcmcudG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9saW0gLT4gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gU3ltYm9sLmluZmluaXR5KCkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdJbmZpbml0eSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gU3ltYm9sLmluZmluaXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctSW5maW5pdHknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IFN5bWJvbC5pbmZpbml0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoKHN5bWJvbC5mbmFtZSA9PT0gQ09TIHx8IHN5bWJvbC5mbmFtZSA9PT0gU0lOKSAmJiBsaW0uaXNJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5MaW1pdC5pbnRlcnZhbCgtMSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoKHN5bWJvbC5mbmFtZSA9PT0gVEFOKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc19hcmcgPSBzeW1ib2wuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBzX2FyZy5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBzX2FyZy5nZXREZW5vbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBuLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobGltLmlzSW5maW5pdHkgfHwgcGkuZXF1YWxzKCdwaScpICYmIGQuZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBkaXZlcmdlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5mbmFtZSA9PT0gU2V0dGluZ3MuRkFDVE9SSUFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFyZy5pc0luZmluaXR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbC5pbmZpbml0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wucG93ZXIgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGVzZSBmdW5jdGlvbnMgYWx3YXlzIGNvbnZlcmdlIHRvIHRoZSBsaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2Uoc3ltYm9sLCBwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSdyZSBkZWFsaW5nIHdpdGggMS94Xm4gYnV0IHJlbWVtYmVyIHRoYXQgaW5maW5pdHkgaGFzIGFscmVhZHkgYmVlbiBkZWFsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93aXRoIGJ5IHN1YnN0aXR1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5VdGlscy5ldmVuKHN5bWJvbC5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2V2ZW4gcG93ZXJzIGNvbnZlcmdlIHRvIGluZmluaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gU3ltYm9sLmluZmluaXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29kZCBvbmVzIGRvbid0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uTGltaXQuZGl2ZXJnZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaW0xLCBsaW0yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCBhbGwgdGhlIHN5bWJvbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aHVzID0+IGxpbSBmKmcqaCA9IGxpbSAoZipnKSpoID0gKGxpbSBmKmcpKihsaW0gaClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zeW1ib2xzIG9mIGxvd2VyIGdyb3VwcyBhcmUgZ2VuZXJhbGx5IGVhc2llciB0byBkaWZmZXJlbnRpYXRlZSBzbyBnZXQgdGhlbSB0byB0aGUgcmlnaHQgYnkgZmlyc3Qgc29ydGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IHN5bWJvbC5jb2xsZWN0U3ltYm9scygpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmdyb3VwIC0gYi5ncm91cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHN5bWJvbHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsY3VsYXRlIHRoZSBmaXJzdCBsaW1pdCBzbyB3ZSBjYW4ga2VlcCBnb2luZyBkb3duIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbTEgPSBldmFsdWF0ZShfXy5MaW1pdC5saW1pdChmLCB4LCBsaW0sIGRlcHRoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlZHVjZXMgYWxsIHRoZSBsaW1pdHMgb25lIGF0IGEgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIHNlY29uZCBsaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBzeW1ib2xzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGxpbWl0IG9mIGdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbTIgPSBldmFsdWF0ZShfXy5MaW1pdC5saW1pdChnLCB4LCBsaW0sIGRlcHRoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgbGltaXQgaXMgaW4gaW5kZXRlcm1pbmF0ZSBmb3JtIGFwbGx5IEwnSG9zcGl0YWwgYnkgaW52ZXJ0aW5nIGcgYW5kIHRoZW4gZi8oMS9nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoKGxpbTEuaXNJbmZpbml0eSB8fCAhX18uTGltaXQuaXNDb252ZXJnZW50KGxpbTEpICYmIGxpbTIuZXF1YWxzKDApIHx8IGxpbTEuZXF1YWxzKDApICYmIF9fLkxpbWl0LmlzQ29udmVyZ2VudChsaW0yKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihnLmNvbnRhaW5zRnVuY3Rpb24oTE9HKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N3YXAgdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gW2YsIGYgPSBnXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pbnZlcnQgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcuaW52ZXJ0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb2R1Y3Qgb2YgaW5maW5pdGllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxpbTEuaXNJbmZpbml0eSAmJiBsaW0yLmlzSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltMSA9IFN5bWJvbC5pbmZpbml0eSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW0xID0gX18uTGltaXQuZGl2aWRlKGYsIGcsIHgsIGxpbSwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbGltIGYqZyA9IChsaW0gZikqKGxpbSBnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbTEgPSBfLm11bHRpcGx5KGxpbTEsIGxpbTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbGV0IGYqZyBlcXVhbCBmIGFuZCBoIGVxdWFsIGcgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IF8ubXVsdGlwbHkoZiwgZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRG9uZSwgbGltMSBpcyB0aGUgbGltaXQgd2UncmUgbG9va2luZyBmb3IgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBsaW0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbGltO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighc3ltYm9sLmlzTGluZWFyKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0FwcGx5IGxpbSBmK2cgPSAobGltIGYpKyhsaW0gZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gc3ltYm9sLmNvbGxlY3RTeW1ib2xzKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIuZ3JvdXAgLSBhLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfc3ltYm9scyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0FuYWx5emUgdGhlIGZ1bmN0aW9ucyBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5zID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IHN5bWJvbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gc3ltYm9sc1tpXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltLmdyb3VwID09PSBGTiB8fCBzeW0uZ3JvdXAgPT09IENCICYmIHN5bS5oYXNGdW5jKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbnMgPSBfLmFkZChmbnMsIHN5bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N5bWJvbHMucHVzaChzeW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zeW1ib2xzLnVuc2hpZnQoZm5zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIHRoYXQgd2UgZGlkbid0IGp1c3QgcmVwYWNrYWdlIHRoZSBleGFjdCBzYW1lIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihfc3ltYm9scy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHMgPSBfc3ltYm9scztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IHN5bWJvbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gc3ltYm9sc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIGFkZGl0aW9uIG9mIHRoZSBsaW1pdHMgaXMgdW5kZWZpbmVkIHRoZW4gdGhlIGxpbWl0IGRpdmVyZ2VzIHNvIHJldHVybiAtaW5maW5pdHkgdG8gaW5maW5pdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xpbSA9IF9fLkxpbWl0LmxpbWl0KHN5bSwgeCwgbGltLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xpbSA9IF9fLkxpbWl0LmRpdmVyZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9saW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlcHRoKysgPiBTZXR0aW5ncy5tYXhfbGltX2RlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLkxpbWl0LmxpbWl0KF9fLmRpZmYoc3ltYm9sLCB4KSwgeCwgbGltLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5MaW1pdC5kaXZpZGUobnVtLCBkZW4sIHgsIGxpbSwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFyZXR2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGl0IHN5bWJvbGljYWxseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdsaW1pdCcsIFtzeW1ib2wsIHgsIGxpbV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgYWxsIGVsc2UgZmFpbHMgcmV0dXJuIHRoZSBzeW1ib2xpYyBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2xpbWl0JywgW3N5bWJvbCwgeCwgbGltXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkobSwgcmV0dmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgRnJlc25lbDoge1xyXG4gICAgICAgICAgICBTOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgaWYoeC5pc0NvbnN0YW50KHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLmRlZmludChfLnBhcnNlKCdzaW4ocGkqeF4yLzIpJyksIFN5bWJvbCgwKSwgeCwgJ3gnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdTJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgQzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGlmKHguaXNDb25zdGFudCh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5kZWZpbnQoXy5wYXJzZSgnY29zKHBpKnheMi8yKScpLCBTeW1ib2woMCksIHgsICd4Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignQycsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG5lcmRhbWVyLnJlZ2lzdGVyKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdkaWZmJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogWzEsIDNdLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLmRpZmY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3N1bScsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDQsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uc3VtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdwcm9kdWN0JyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogNCxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5wcm9kdWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdpbnRlZ3JhdGUnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiBbMSwgMl0sXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uaW50ZWdyYXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdkZWZpbnQnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiBbMywgNF0sXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uZGVmaW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdTJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogMSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5GcmVzbmVsLlM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ0MnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAxLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLkZyZXNuZWwuQztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiBbMywgNF0sXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uTGltaXQubGltaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuICAgIC8vbGluayByZWdpc3RlcmVkIGZ1bmN0aW9ucyBleHRlcm5hbGx5XHJcbiAgICBuZXJkYW1lci5hcGkoKTtcclxuXHJcbn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///238\n")},518:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module */\r\n\r\nif(true) {\r\n    var nerdamer = __webpack_require__(182);\r\n    __webpack_require__(238);\r\n    __webpack_require__(684);\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Symbol = core.Symbol,\r\n            format = core.Utils.format,\r\n            isVector = core.Utils.isVector,\r\n            isArray = core.Utils.isArray,\r\n            Vector = core.Vector,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            FN = core.groups.FN;\r\n    core.Settings.Laplace_integration_depth = 40;\r\n\r\n\r\n    Symbol.prototype.findFunction = function (fname) {\r\n        //this is what we're looking for\r\n        if(this.group === FN && this.fname === fname)\r\n            return this.clone();\r\n        var found;\r\n        if(this.symbols)\r\n            for(var x in this.symbols) {\r\n                found = this.symbols[x].findFunction(fname);\r\n                if(found)\r\n                    break;\r\n            }\r\n\r\n        return found;\r\n    };\r\n\r\n    var __ = core.Extra = {\r\n        version: '1.4.2',\r\n        //http://integral-table.com/downloads/LaplaceTable.pdf\r\n        //Laplace assumes all coefficients to be positive\r\n        LaPlace: {\r\n            //Using: integral_0^oo f(t)*e^(-s*t) dt\r\n            transform: function (symbol, t, s) {\r\n                symbol = symbol.clone();\r\n\r\n                t = t.toString();\r\n                //First try a lookup for a speed boost\r\n                symbol = Symbol.unwrapSQRT(symbol, true);\r\n                var retval,\r\n                        coeff = symbol.stripVar(t),\r\n                        g = symbol.group;\r\n\r\n                symbol = _.divide(symbol, coeff.clone());\r\n\r\n                if(symbol.isConstant() || !symbol.contains(t, true)) {\r\n                    retval = _.parse(format('({0})/({1})', symbol, s));\r\n                }\r\n                else if(g === S && core.Utils.isInt(symbol.power)) {\r\n                    var n = String(symbol.power);\r\n                    retval = _.parse(format('factorial({0})/({1})^({0}+1)', n, s));\r\n                }\r\n                else if(symbol.group === S && symbol.power.equals(1 / 2)) {\r\n                    retval = _.parse(format('sqrt(pi)/(2*({0})^(3/2))', s));\r\n                }\r\n                else if(symbol.isComposite()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.LaPlace.transform(x, t, s));\r\n                    }, true);\r\n                }\r\n                else if(symbol.isE() && (symbol.power.group === S || symbol.power.group === CB)) {\r\n                    var a = symbol.power.stripVar(t);\r\n                    retval = _.parse(format('1/(({1})-({0}))', a, s));\r\n                }\r\n                else {\r\n                    var fns = ['sin', 'cos', 'sinh', 'cosh'];\r\n                    //support for symbols in fns with arguments in the form a*t or n*t where a = symbolic and n = Number\r\n                    if(symbol.group === FN && fns.indexOf(symbol.fname) !== -1 && (symbol.args[0].group === S || symbol.args[0].group === CB)) {\r\n                        var a = symbol.args[0].stripVar(t);\r\n\r\n                        switch(symbol.fname) {\r\n                            case 'sin':\r\n                                retval = _.parse(format('({0})/(({1})^2+({0})^2)', a, s));\r\n                                break;\r\n                            case 'cos':\r\n                                retval = _.parse(format('({1})/(({1})^2+({0})^2)', a, s));\r\n                                break;\r\n                            case 'sinh':\r\n                                retval = _.parse(format('({0})/(({1})^2-({0})^2)', a, s));\r\n                                break;\r\n                            case 'cosh':\r\n                                retval = _.parse(format('({1})/(({1})^2-({0})^2)', a, s));\r\n                                break;\r\n                        }\r\n\r\n                    }\r\n                    else {\r\n                        //Try to integrate for a solution\r\n                        //we need at least the Laplace integration depth\r\n                        var depth_is_lower = core.Settings.integration_depth < core.Settings.Laplace_integration_depth;\r\n\r\n                        if(depth_is_lower) {\r\n                            var integration_depth = core.Settings.integration_depth; //save the depth\r\n                            core.Settings.integration_depth = core.Settings.Laplace_integration_depth; //transforms need a little more room\r\n                        }\r\n\r\n                        core.Utils.block('PARSE2NUMBER', function () {\r\n                            var u = t;\r\n                            var sym = symbol.sub(t, u);\r\n                            var integration_expr = _.parse('e^(-' + s + '*' + u + ')*' + sym);\r\n                            retval = core.Calculus.integrate(integration_expr, u);\r\n                            if(retval.hasIntegral())\r\n                                return _.symfunction('laplace', arguments);\r\n//                                _.error('Unable to compute transform');\r\n                            retval = retval.sub(t, 0);\r\n                            retval = _.expand(_.multiply(retval, new Symbol(-1)));\r\n                            retval = retval.sub(u, t);\r\n                        }, false);\r\n\r\n                        retval = core.Utils.block('PARSE2NUMBER', function () {\r\n                            return _.parse(retval);\r\n                        }, true);\r\n\r\n                        if(depth_is_lower)//put the integration depth as it was\r\n                            core.Settings.integration_depth = integration_depth;\r\n                    }\r\n\r\n                }\r\n\r\n                return _.multiply(retval, coeff);\r\n            },\r\n            inverse: function (symbol, s_, t) {\r\n                var input_symbol = symbol.clone();\r\n                return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                    //expand and get partial fractions\r\n                    if(symbol.group === CB) {\r\n                        symbol = core.Algebra.PartFrac.partfrac(_.expand(symbol), s_);\r\n                    }\r\n\r\n                    if(symbol.group === S || symbol.group === CB || symbol.isComposite()) {\r\n                        var finalize = function () {\r\n                            //put back the numerator\r\n                            retval = _.multiply(retval, num);\r\n                            retval.multiplier = retval.multiplier.multiply(symbol.multiplier);\r\n                            //put back a\r\n                            retval = _.divide(retval, f.a);\r\n                        };\r\n                        var num, den, s, retval, f, p, m, den_p, fe;\r\n                        //remove the multiplier\r\n                        m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        //get the numerator and denominator\r\n                        num = symbol.getNum();\r\n                        den = symbol.getDenom().toUnitMultiplier();\r\n\r\n                        //TODO: Make it so factor doesn't destroy pi\r\n                        //num = core.Algebra.Factor.factor(symbol.getNum());\r\n                        //den = core.Algebra.Factor.factor(symbol.getDenom().invert(null, true));\r\n\r\n                        if(den.group === CP) {\r\n                            den_p = den.power.clone();\r\n                            den.toLinear();\r\n                        }\r\n                        else {\r\n                            den_p = new core.Frac(1);\r\n                        }\r\n\r\n                        //convert s to a string\r\n                        s = s_.toString();\r\n                        //split up the denominator if in the form ax+b\r\n                        f = core.Utils.decompose_fn(den, s, true);\r\n                        //move the multiplier to the numerator\r\n                        fe = core.Utils.decompose_fn(_.expand(num.clone()), s, true);\r\n                        num.multiplier = num.multiplier.multiply(m);\r\n                        //store the parts in variables for easy recognition \r\n                        //check if in the form t^n where n = integer\r\n                        if((den.group === S || den.group === CB) && f.x.value === s && f.b.equals(0) && core.Utils.isInt(f.x.power)) {\r\n                            var fact, p;\r\n                            p = f.x.power - 1;\r\n                            fact = core.Math2.factorial(p);\r\n                            //  n!/s^(n-1)\r\n                            retval = _.divide(_.pow(t, new Symbol(p)), new Symbol(fact));\r\n                            //wrap it up\r\n                            finalize();\r\n                        }\r\n                        else if(den.group === CP && den_p.equals(1)) {\r\n                            if(f.x.group === core.groups.PL && core.Algebra.degree(den).equals(2)) {\r\n                                // Possibly in the form 1/(s^2+2*s+1)\r\n                                // Try factoring to get it in a more familiar form{\r\n                                // Apply inverse of F(s-a)\r\n                                var completed = core.Algebra.sqComplete(den, s);\r\n                                var u = core.Utils.getU(den);\r\n                                // Get a for the function above\r\n                                var a = core.Utils.decompose_fn(completed.a, s, true).b;\r\n                                var tf = __.LaPlace.inverse(_.parse(`1/((${u})^2+(${completed.c}))`), u, t);\r\n                                retval = _.multiply(tf, _.parse(`(${m})*e^(-(${a})*(${t}))`));\r\n                            }\r\n                            else {\r\n                                // a/(b*s-c) -> ae^(-bt)\r\n                                if(f.x.isLinear() && !num.contains(s)) {\r\n                                    t = _.divide(t, f.a.clone());\r\n\r\n                                    // Don't add factorial of one or zero\r\n                                    var p = den_p - 1;\r\n                                    var fact = p === 0 || p === 1 ? '1' : `(${den_p}-1)!`\r\n                                    retval = _.parse(format('(({0})^({3}-1)*e^(-(({2})*({0}))/({1})))/(({4})*({1})^({3}))', t, f.a, f.b, den_p, fact));\r\n                                    //wrap it up\r\n                                    finalize();\r\n                                }\r\n                                else {\r\n                                    if(f.x.group === S && f.x.power.equals(2)) {\r\n                                        if(!num.contains(s)) {\r\n                                            retval = _.parse(format('(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/sqrt(({2})*({3}))', t, num, f.a, f.b));\r\n                                        }\r\n                                        // a*s/(b*s^2+c^2)\r\n                                        else {\r\n                                            var a = new Symbol(1);\r\n                                            if(num.group === CB) {\r\n                                                var new_num = new Symbol(1);\r\n                                                num.each(function (x) {\r\n                                                    if(x.contains(s))\r\n                                                        new_num = _.multiply(new_num, x);\r\n                                                    else\r\n                                                        a = _.multiply(a, x);\r\n                                                });\r\n                                                num = new_num;\r\n                                            }\r\n\r\n                                            //we need more information about the denominator to decide\r\n                                            var f2 = core.Utils.decompose_fn(num, s, true);\r\n                                            var fn1, fn2, a_has_sin, b_has_cos, a_has_cos, b_has_sin;\r\n                                            fn1 = f2.a;\r\n                                            fn2 = f2.b;\r\n                                            a_has_sin = fn1.containsFunction('sin');\r\n                                            a_has_cos = fn1.containsFunction('cos');\r\n                                            b_has_cos = fn2.containsFunction('cos');\r\n                                            b_has_sin = fn2.containsFunction('sin');\r\n                                            if(f2.x.value === s && f2.x.isLinear() && !((a_has_sin && b_has_cos) || (a_has_cos || b_has_sin))) {\r\n                                                retval = _.parse(format('(({1})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})', t, f2.a, f.a, f.b));\r\n                                            }\r\n                                            else {\r\n                                                if(a_has_sin && b_has_cos) {\r\n                                                    var sin, cos;\r\n                                                    sin = fn1.findFunction('sin');\r\n                                                    cos = fn2.findFunction('cos');\r\n                                                    //who has the s?\r\n                                                    if(sin.args[0].equals(cos.args[0]) && !sin.args[0].contains(s)) {\r\n                                                        var b, c, d, e;\r\n                                                        b = _.divide(fn2, cos.toUnitMultiplier()).toString();\r\n                                                        c = sin.args[0].toString();\r\n                                                        d = f.b;\r\n                                                        e = _.divide(fn1, sin.toUnitMultiplier());\r\n                                                        exp = '(({1})*({2})*cos({3})*sin(sqrt({4})*({0})))/sqrt({4})+({1})*sin({3})*({5})*cos(sqrt({4})*({0}))';\r\n                                                        retval = _.parse(format(exp, t, a, b, c, d, e));\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else if(f.x.power.num && f.x.power.num.equals(3) && f.x.power.den.equals(2) && num.contains('sqrt(pi)') && !num.contains(s) && num.isLinear()) {\r\n                            var b = _.divide(num.clone(), _.parse('sqrt(pi)'));\r\n                            retval = _.parse(format('(2*({2})*sqrt({0}))/({1})', t, f.a, b, num));\r\n                        }\r\n                        else if(den_p.equals(2) && f.x.power.equals(2)) {\r\n                            var a, d, exp;\r\n                            if(!num.contains(s)) {\r\n                                a = _.divide(num, new Symbol(2));\r\n                                exp = '(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({3})*sqrt(({2})*({3})))-(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*({3}))';\r\n                                retval = _.parse(format(exp, t, a, f.a, f.b));\r\n                            }\r\n                            else {\r\n                                // Decompose the numerator to check value of s\r\n                                f2 = core.Utils.decompose_fn(_.expand(num.clone()), s, true);\r\n                                if(f2.x.isComposite()) {\r\n                                    var s_terms = [];\r\n                                    //first collect the factors e.g. (a)(bx)(cx^2+d)\r\n                                    var symbols = num.collectSymbols(function (x) {\r\n                                        x = Symbol.unwrapPARENS(x);\r\n                                        var t = core.Utils.decompose_fn(x, s, true);\r\n                                        t.symbol = x;\r\n                                        return t;\r\n                                    }).\r\n                                            //then sort them by power hightest to lowest\r\n                                            sort(function (a, b) {\r\n                                                var p1, p2;\r\n                                                p1 = a.x.value !== s ? 0 : a.x.power;\r\n                                                p2 = b.x.value !== s ? 0 : b.x.power;\r\n                                                return p2 - p1;\r\n                                            });\r\n                                    a = new Symbol(-1);\r\n                                    // Grab only the ones which have s\r\n                                    for(var i = 0; i < symbols.length; i++) {\r\n                                        var fc = symbols[i];\r\n                                        if(fc.x.value === s)\r\n                                            s_terms.push(fc);\r\n                                        else\r\n                                            a = _.multiply(a, fc.symbol);\r\n                                    }\r\n                                    // The following 2 assumptions are made\r\n                                    // 1. since the numerator was factored above then each s_term has a unique power\r\n                                    // 2. because the terms are sorted by descending powers then the first item \r\n                                    //    has the highest power\r\n                                    // We can now check for the next type s(s^2-a^2)/(s^2+a^2)^2\r\n                                    if(s_terms[0].x.power.equals(2) && s_terms[1].x.power.equals(1) && s_terms[1].b.equals(0) && !s_terms[0].b.equals(0)) {\r\n                                        b = s_terms[0].a.negate();\r\n                                        exp = '-(({1})*({2})*({5})*({0})*sin((sqrt(({4})*({5}))*({0}))/({4})))/' +\r\n                                                '(2*({4})^2*sqrt(({4})*({5})))-(({1})*({3})*({0})*sin((sqrt(({4})*({5}))*({0}))/({4})))' +\r\n                                                '/(2*({4})*sqrt(({4})*({5})))+(({1})*({2})*cos((sqrt(({4})*({5}))*({0}))/({4})))/({4})^2';\r\n                                        retval = _.parse(format(exp, t, a, b, s_terms[0].b, f.a, f.b));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if(f2.x.isLinear()) {\r\n                                        a = _.divide(f2.a, new Symbol(2));\r\n                                        exp = '(({1})*({0})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*sqrt(({2})*({3})))';\r\n                                        retval = _.parse(format(exp, t, a, f.a, f.b));\r\n                                    }\r\n                                    else if(f2.x.power.equals(2)) {\r\n                                        if(f2.b.equals(0)) {\r\n                                            a = _.divide(f2.a, new Symbol(2));\r\n                                            exp = '(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*sqrt(({2})*({3})))+(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})^2';\r\n                                            retval = _.parse(format(exp, t, a, f.a, f.b));\r\n                                        }\r\n                                        else {\r\n                                            a = _.divide(f2.a, new Symbol(2));\r\n                                            d = f2.b.negate();\r\n                                            exp = '-((({2})*({4})-2*({1})*({3}))*sin((sqrt(({2})*({3}))*({0}))/({2})))/(2*({2})*({3})*sqrt(({2})*({3})))+' +\r\n                                                    '(({4})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/(2*({2})*({3}))+(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})^2';\r\n                                            retval = _.parse(format(exp, t, a, f.a, f.b, d));\r\n\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else if(symbol.isComposite()) {\r\n                            // 1/(s+1)^2\r\n                            if(den_p.equals(2) && f.x.group === S) {\r\n                                retval = _.parse(`(${m})*(${t})*e^(-(${f.b})*(${t}))`);\r\n                            }\r\n                            else {\r\n                                retval = new Symbol(0);\r\n\r\n                                symbol.each(function (x) {\r\n                                    retval = _.add(retval, __.LaPlace.inverse(x, s_, t));\r\n                                }, true);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!retval) {\r\n                        retval = _.symfunction('ilt', [input_symbol, s_, t]);\r\n                    }\r\n\r\n                    return retval;\r\n                }, true);\r\n            }\r\n        },\r\n        Statistics: {\r\n            frequencyMap: function (arr) {\r\n                var map = {};\r\n                //get the frequency map\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    var e = arr[i],\r\n                            key = e.toString();\r\n                    if(!map[key]) //default it to zero\r\n                        map[key] = 0;\r\n                    map[key]++; //increment\r\n                }\r\n                return map;\r\n            },\r\n            sort: function (arr) {\r\n                return arr.sort(function (a, b) {\r\n                    if(!a.isConstant() || !b.isConstant())\r\n                        _.error('Unable to sort! All values must be numeric');\r\n                    return a.multiplier.subtract(b.multiplier);\r\n                });\r\n            },\r\n            count: function (arr) {\r\n                return new Symbol(arr.length);\r\n            },\r\n            sum: function (arr, x_) {\r\n                var sum = new Symbol(0);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    var xi = arr[i].clone();\r\n                    if(x_) {\r\n                        sum = _.add(_.pow(_.subtract(xi, x_.clone()), new Symbol(2)), sum);\r\n                    }\r\n                    else\r\n                        sum = _.add(xi, sum);\r\n                }\r\n\r\n                return sum;\r\n            },\r\n            mean: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.mean.apply(this, args[0].elements);\r\n                return  _.divide(__.Statistics.sum(args), __.Statistics.count(args));\r\n            },\r\n            median: function () {\r\n                var args = [].slice.call(arguments), retval;\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.median.apply(this, args[0].elements);\r\n                try {\r\n                    var sorted = __.Statistics.sort(args);\r\n                    var l = args.length;\r\n                    if(core.Utils.even(l)) {\r\n                        var mid = l / 2;\r\n                        retval = __.Statistics.mean(sorted[mid - 1], sorted[mid]);\r\n                    }\r\n                    else\r\n                        retval = sorted[Math.floor(l / 2)];\r\n                }\r\n                catch(e) {\r\n                    retval = _.symfunction('median', args);\r\n                }\r\n                return retval;\r\n            },\r\n            mode: function () {\r\n                var args = [].slice.call(arguments),\r\n                        retval;\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.mode.apply(this, args[0].elements);\r\n\r\n                var map = __.Statistics.frequencyMap(args);\r\n\r\n                //the mode of 1 item is that item as per issue #310 (verified by Happypig375). \r\n                if(core.Utils.keys(map).length === 1)\r\n                    retval = args[0];\r\n                else {\r\n                    //invert by arraning them according to their frequency\r\n                    var inverse = {};\r\n                    for(var x in map) {\r\n                        var freq = map[x];\r\n                        //check if it's in the inverse already\r\n                        if(!(freq in inverse))\r\n                            inverse[freq] = x;\r\n                        else {\r\n                            var e = inverse[freq];\r\n                            //if it's already an array then just add it\r\n                            if(isArray(e))\r\n                                e.push(x);\r\n                            //convert it to and array\r\n                            else\r\n                                inverse[freq] = [x, inverse[freq]];\r\n                        }\r\n                    }\r\n                    //the keys now represent the maxes. We want the max of those keys\r\n                    var max = inverse[Math.max.apply(null, core.Utils.keys(inverse))];\r\n                    //check it's an array. If it is then map over the results and convert \r\n                    //them to Symbol\r\n                    if(isArray(max)) {\r\n                        retval = _.symfunction('mode', max.sort());\r\n                    }\r\n                    else\r\n                        retval = _.parse(max);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            gVariance: function (k, args) {\r\n                var x_ = __.Statistics.mean.apply(__.Statistics, args),\r\n                        sum = __.Statistics.sum(args, x_);\r\n                return _.multiply(k, sum);\r\n            },\r\n            variance: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.variance.apply(this, args[0].elements);\r\n                var k = _.divide(new Symbol(1), __.Statistics.count(args));\r\n                return __.Statistics.gVariance(k, args);\r\n            },\r\n            sampleVariance: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.sampleVariance.apply(this, args[0].elements);\r\n\r\n                var k = _.divide(new Symbol(1), _.subtract(__.Statistics.count(args), new Symbol(1)));\r\n                return __.Statistics.gVariance(k, args);\r\n            },\r\n            standardDeviation: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.standardDeviation.apply(this, args[0].elements);\r\n                return _.pow(__.Statistics.variance.apply(__.Statistics, args), new Symbol(1 / 2));\r\n            },\r\n            sampleStandardDeviation: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.sampleStandardDeviation.apply(this, args[0].elements);\r\n                return _.pow(__.Statistics.sampleVariance.apply(__.Statistics, args), new Symbol(1 / 2));\r\n            },\r\n            zScore: function (x, mean, stdev) {\r\n                return _.divide(_.subtract(x, mean), stdev);\r\n            }\r\n        },\r\n        Units: {\r\n            table: {\r\n                foot: '12 inch',\r\n                meter: '100 cm',\r\n                decimeter: '10 cm',\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'laplace',\r\n            visible: true,\r\n            numargs: 3,\r\n            build: function () {\r\n                return __.LaPlace.transform;\r\n            }\r\n        },\r\n        {\r\n            name: 'ilt',\r\n            visible: true,\r\n            numargs: 3,\r\n            build: function () {\r\n                return __.LaPlace.inverse;\r\n            }\r\n        },\r\n        //statistical\r\n        {\r\n            name: 'mean',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.mean;\r\n            }\r\n        },\r\n        {\r\n            name: 'median',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.median;\r\n            }\r\n        },\r\n        {\r\n            name: 'mode',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.mode;\r\n            }\r\n        },\r\n        {\r\n            name: 'smpvar',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.sampleVariance;\r\n            }\r\n        },\r\n        {\r\n            name: 'variance',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.variance;\r\n            }\r\n        },\r\n        {\r\n            name: 'smpstdev',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.sampleStandardDeviation;\r\n            }\r\n        },\r\n        {\r\n            name: 'stdev',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.standardDeviation;\r\n            }\r\n        },\r\n        {\r\n            name: 'zscore',\r\n            visible: true,\r\n            numargs: 3,\r\n            build: function () {\r\n                return __.Statistics.zScore;\r\n            }\r\n        }\r\n    ]);\r\n\r\n    //link registered functions externally\r\n    nerdamer.api();\r\n}());\r\n\r\n// Added for all.min.js\r\nif(true) {\r\n    module.exports = nerdamer;\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmFuaWxsYS1pbnRlZ3JhdGlvbi0yZC8uL25vZGVfbW9kdWxlcy9uZXJkYW1lci9FeHRyYS5qcz8zY2EzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEF1dGhvciA6IE1hcnRpbiBEb25rXHJcbiAqIFdlYnNpdGUgOiBodHRwOi8vd3d3Lm5lcmRhbWVyLmNvbVxyXG4gKiBFbWFpbCA6IG1hcnRpbi5yLmRvbmtAZ21haWwuY29tXHJcbiAqIExpY2Vuc2UgOiBNSVRcclxuICogU291cmNlIDogaHR0cHM6Ly9naXRodWIuY29tL2ppZ2d6c29uL25lcmRhbWVyXHJcbiAqL1xyXG5cclxuLyogZ2xvYmFsIG1vZHVsZSAqL1xyXG5cclxuaWYoKHR5cGVvZiBtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdmFyIG5lcmRhbWVyID0gcmVxdWlyZSgnLi9uZXJkYW1lci5jb3JlLmpzJyk7XHJcbiAgICByZXF1aXJlKCcuL0NhbGN1bHVzJyk7XHJcbiAgICByZXF1aXJlKCcuL0FsZ2VicmEnKTtcclxufVxyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIHZhciBjb3JlID0gbmVyZGFtZXIuZ2V0Q29yZSgpLFxyXG4gICAgICAgICAgICBfID0gY29yZS5QQVJTRVIsXHJcbiAgICAgICAgICAgIFN5bWJvbCA9IGNvcmUuU3ltYm9sLFxyXG4gICAgICAgICAgICBmb3JtYXQgPSBjb3JlLlV0aWxzLmZvcm1hdCxcclxuICAgICAgICAgICAgaXNWZWN0b3IgPSBjb3JlLlV0aWxzLmlzVmVjdG9yLFxyXG4gICAgICAgICAgICBpc0FycmF5ID0gY29yZS5VdGlscy5pc0FycmF5LFxyXG4gICAgICAgICAgICBWZWN0b3IgPSBjb3JlLlZlY3RvcixcclxuICAgICAgICAgICAgUyA9IGNvcmUuZ3JvdXBzLlMsXHJcbiAgICAgICAgICAgIEVYID0gY29yZS5ncm91cHMuRVgsXHJcbiAgICAgICAgICAgIENQID0gY29yZS5ncm91cHMuQ1AsXHJcbiAgICAgICAgICAgIENCID0gY29yZS5ncm91cHMuQ0IsXHJcbiAgICAgICAgICAgIEZOID0gY29yZS5ncm91cHMuRk47XHJcbiAgICBjb3JlLlNldHRpbmdzLkxhcGxhY2VfaW50ZWdyYXRpb25fZGVwdGggPSA0MDtcclxuXHJcblxyXG4gICAgU3ltYm9sLnByb3RvdHlwZS5maW5kRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm5hbWUpIHtcclxuICAgICAgICAvL3RoaXMgaXMgd2hhdCB3ZSdyZSBsb29raW5nIGZvclxyXG4gICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IEZOICYmIHRoaXMuZm5hbWUgPT09IGZuYW1lKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBmb3VuZDtcclxuICAgICAgICBpZih0aGlzLnN5bWJvbHMpXHJcbiAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5zeW1ib2xzW3hdLmZpbmRGdW5jdGlvbihmbmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZihmb3VuZClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfXyA9IGNvcmUuRXh0cmEgPSB7XHJcbiAgICAgICAgdmVyc2lvbjogJzEuNC4yJyxcclxuICAgICAgICAvL2h0dHA6Ly9pbnRlZ3JhbC10YWJsZS5jb20vZG93bmxvYWRzL0xhcGxhY2VUYWJsZS5wZGZcclxuICAgICAgICAvL0xhcGxhY2UgYXNzdW1lcyBhbGwgY29lZmZpY2llbnRzIHRvIGJlIHBvc2l0aXZlXHJcbiAgICAgICAgTGFQbGFjZToge1xyXG4gICAgICAgICAgICAvL1VzaW5nOiBpbnRlZ3JhbF8wXm9vIGYodCkqZV4oLXMqdCkgZHRcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoc3ltYm9sLCB0LCBzKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0ID0gdC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgLy9GaXJzdCB0cnkgYSBsb29rdXAgZm9yIGEgc3BlZWQgYm9vc3RcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IFN5bWJvbC51bndyYXBTUVJUKHN5bWJvbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZiA9IHN5bWJvbC5zdHJpcFZhcih0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHN5bWJvbC5ncm91cDtcclxuXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmRpdmlkZShzeW1ib2wsIGNvZWZmLmNsb25lKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkgfHwgIXN5bWJvbC5jb250YWlucyh0LCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoezB9KS8oezF9KScsIHN5bWJvbCwgcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBTICYmIGNvcmUuVXRpbHMuaXNJbnQoc3ltYm9sLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gU3RyaW5nKHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJ2ZhY3RvcmlhbCh7MH0pLyh7MX0pXih7MH0rMSknLCBuLCBzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gUyAmJiBzeW1ib2wucG93ZXIuZXF1YWxzKDEgLyAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCdzcXJ0KHBpKS8oMiooezB9KV4oMy8yKSknLCBzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9fLkxhUGxhY2UudHJhbnNmb3JtKHgsIHQsIHMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzRSgpICYmIChzeW1ib2wucG93ZXIuZ3JvdXAgPT09IFMgfHwgc3ltYm9sLnBvd2VyLmdyb3VwID09PSBDQikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHN5bWJvbC5wb3dlci5zdHJpcFZhcih0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnMS8oKHsxfSktKHswfSkpJywgYSwgcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZucyA9IFsnc2luJywgJ2NvcycsICdzaW5oJywgJ2Nvc2gnXTtcclxuICAgICAgICAgICAgICAgICAgICAvL3N1cHBvcnQgZm9yIHN5bWJvbHMgaW4gZm5zIHdpdGggYXJndW1lbnRzIGluIHRoZSBmb3JtIGEqdCBvciBuKnQgd2hlcmUgYSA9IHN5bWJvbGljIGFuZCBuID0gTnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBGTiAmJiBmbnMuaW5kZXhPZihzeW1ib2wuZm5hbWUpICE9PSAtMSAmJiAoc3ltYm9sLmFyZ3NbMF0uZ3JvdXAgPT09IFMgfHwgc3ltYm9sLmFyZ3NbMF0uZ3JvdXAgPT09IENCKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHN5bWJvbC5hcmdzWzBdLnN0cmlwVmFyKHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKHN5bWJvbC5mbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2luJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKHswfSkvKCh7MX0pXjIrKHswfSleMiknLCBhLCBzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb3MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoezF9KS8oKHsxfSleMisoezB9KV4yKScsIGEsIHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmgnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoezB9KS8oKHsxfSleMi0oezB9KV4yKScsIGEsIHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvc2gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoezF9KS8oKHsxfSleMi0oezB9KV4yKScsIGEsIHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVHJ5IHRvIGludGVncmF0ZSBmb3IgYSBzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dlIG5lZWQgYXQgbGVhc3QgdGhlIExhcGxhY2UgaW50ZWdyYXRpb24gZGVwdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoX2lzX2xvd2VyID0gY29yZS5TZXR0aW5ncy5pbnRlZ3JhdGlvbl9kZXB0aCA8IGNvcmUuU2V0dGluZ3MuTGFwbGFjZV9pbnRlZ3JhdGlvbl9kZXB0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlcHRoX2lzX2xvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZWdyYXRpb25fZGVwdGggPSBjb3JlLlNldHRpbmdzLmludGVncmF0aW9uX2RlcHRoOyAvL3NhdmUgdGhlIGRlcHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLlNldHRpbmdzLmludGVncmF0aW9uX2RlcHRoID0gY29yZS5TZXR0aW5ncy5MYXBsYWNlX2ludGVncmF0aW9uX2RlcHRoOyAvL3RyYW5zZm9ybXMgbmVlZCBhIGxpdHRsZSBtb3JlIHJvb21cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5ibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IHN5bWJvbC5zdWIodCwgdSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZWdyYXRpb25fZXhwciA9IF8ucGFyc2UoJ2VeKC0nICsgcyArICcqJyArIHUgKyAnKSonICsgc3ltKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGNvcmUuQ2FsY3VsdXMuaW50ZWdyYXRlKGludGVncmF0aW9uX2V4cHIsIHUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmV0dmFsLmhhc0ludGVncmFsKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2xhcGxhY2UnLCBhcmd1bWVudHMpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignVW5hYmxlIHRvIGNvbXB1dGUgdHJhbnNmb3JtJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSByZXR2YWwuc3ViKHQsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5leHBhbmQoXy5tdWx0aXBseShyZXR2YWwsIG5ldyBTeW1ib2woLTEpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSByZXR2YWwuc3ViKHUsIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBjb3JlLlV0aWxzLmJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShyZXR2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlcHRoX2lzX2xvd2VyKS8vcHV0IHRoZSBpbnRlZ3JhdGlvbiBkZXB0aCBhcyBpdCB3YXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuU2V0dGluZ3MuaW50ZWdyYXRpb25fZGVwdGggPSBpbnRlZ3JhdGlvbl9kZXB0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHJldHZhbCwgY29lZmYpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnZlcnNlOiBmdW5jdGlvbiAoc3ltYm9sLCBzXywgdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucHV0X3N5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuYmxvY2soJ1BPU0lUSVZFX01VTFRJUExJRVJTJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZXhwYW5kIGFuZCBnZXQgcGFydGlhbCBmcmFjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGNvcmUuQWxnZWJyYS5QYXJ0RnJhYy5wYXJ0ZnJhYyhfLmV4cGFuZChzeW1ib2wpLCBzXyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IFMgfHwgc3ltYm9sLmdyb3VwID09PSBDQiB8fCBzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3B1dCBiYWNrIHRoZSBudW1lcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBudW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm11bHRpcGxpZXIgPSByZXR2YWwubXVsdGlwbGllci5tdWx0aXBseShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3B1dCBiYWNrIGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKHJldHZhbCwgZi5hKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bSwgZGVuLCBzLCByZXR2YWwsIGYsIHAsIG0sIGRlbl9wLCBmZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHN5bWJvbC5tdWx0aXBsaWVyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IHN5bWJvbC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuID0gc3ltYm9sLmdldERlbm9tKCkudG9Vbml0TXVsdGlwbGllcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBNYWtlIGl0IHNvIGZhY3RvciBkb2Vzbid0IGRlc3Ryb3kgcGlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9udW0gPSBjb3JlLkFsZ2VicmEuRmFjdG9yLmZhY3RvcihzeW1ib2wuZ2V0TnVtKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RlbiA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKHN5bWJvbC5nZXREZW5vbSgpLmludmVydChudWxsLCB0cnVlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkZW4uZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5fcCA9IGRlbi5wb3dlci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5fcCA9IG5ldyBjb3JlLkZyYWMoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29udmVydCBzIHRvIGEgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzXy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NwbGl0IHVwIHRoZSBkZW5vbWluYXRvciBpZiBpbiB0aGUgZm9ybSBheCtiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBjb3JlLlV0aWxzLmRlY29tcG9zZV9mbihkZW4sIHMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21vdmUgdGhlIG11bHRpcGxpZXIgdG8gdGhlIG51bWVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZSA9IGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuKF8uZXhwYW5kKG51bS5jbG9uZSgpKSwgcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bS5tdWx0aXBsaWVyID0gbnVtLm11bHRpcGxpZXIubXVsdGlwbHkobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgdGhlIHBhcnRzIGluIHZhcmlhYmxlcyBmb3IgZWFzeSByZWNvZ25pdGlvbiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBpbiB0aGUgZm9ybSB0Xm4gd2hlcmUgbiA9IGludGVnZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoKGRlbi5ncm91cCA9PT0gUyB8fCBkZW4uZ3JvdXAgPT09IENCKSAmJiBmLngudmFsdWUgPT09IHMgJiYgZi5iLmVxdWFscygwKSAmJiBjb3JlLlV0aWxzLmlzSW50KGYueC5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0LCBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGYueC5wb3dlciAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0ID0gY29yZS5NYXRoMi5mYWN0b3JpYWwocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgbiEvc14obi0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUoXy5wb3codCwgbmV3IFN5bWJvbChwKSksIG5ldyBTeW1ib2woZmFjdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93cmFwIGl0IHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZGVuLmdyb3VwID09PSBDUCAmJiBkZW5fcC5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGYueC5ncm91cCA9PT0gY29yZS5ncm91cHMuUEwgJiYgY29yZS5BbGdlYnJhLmRlZ3JlZShkZW4pLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvc3NpYmx5IGluIHRoZSBmb3JtIDEvKHNeMisyKnMrMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgZmFjdG9yaW5nIHRvIGdldCBpdCBpbiBhIG1vcmUgZmFtaWxpYXIgZm9ybXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBpbnZlcnNlIG9mIEYocy1hKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSBjb3JlLkFsZ2VicmEuc3FDb21wbGV0ZShkZW4sIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gY29yZS5VdGlscy5nZXRVKGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgZm9yIHRoZSBmdW5jdGlvbiBhYm92ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gY29yZS5VdGlscy5kZWNvbXBvc2VfZm4oY29tcGxldGVkLmEsIHMsIHRydWUpLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRmID0gX18uTGFQbGFjZS5pbnZlcnNlKF8ucGFyc2UoYDEvKCgke3V9KV4yKygke2NvbXBsZXRlZC5jfSkpYCksIHUsIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkodGYsIF8ucGFyc2UoYCgke219KSplXigtKCR7YX0pKigke3R9KSlgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhLyhiKnMtYykgLT4gYWVeKC1idClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmLnguaXNMaW5lYXIoKSAmJiAhbnVtLmNvbnRhaW5zKHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLmRpdmlkZSh0LCBmLmEuY2xvbmUoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgZmFjdG9yaWFsIG9mIG9uZSBvciB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gZGVuX3AgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdCA9IHAgPT09IDAgfHwgcCA9PT0gMSA/ICcxJyA6IGAoJHtkZW5fcH0tMSkhYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKCh7MH0pXih7M30tMSkqZV4oLSgoezJ9KSooezB9KSkvKHsxfSkpKS8oKHs0fSkqKHsxfSleKHszfSkpJywgdCwgZi5hLCBmLmIsIGRlbl9wLCBmYWN0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd3JhcCBpdCB1cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZi54Lmdyb3VwID09PSBTICYmIGYueC5wb3dlci5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFudW0uY29udGFpbnMocykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKCh7MX0pKnNpbigoc3FydCgoezJ9KSooezN9KSkqKHswfSkpLyh7Mn0pKSkvc3FydCgoezJ9KSooezN9KSknLCB0LCBudW0sIGYuYSwgZi5iKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhKnMvKGIqc14yK2NeMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihudW0uZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdfbnVtID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguY29udGFpbnMocykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X251bSA9IF8ubXVsdGlwbHkobmV3X251bSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF8ubXVsdGlwbHkoYSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW0gPSBuZXdfbnVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBuZWVkIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRlbm9taW5hdG9yIHRvIGRlY2lkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmMiA9IGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuKG51bSwgcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuMSwgZm4yLCBhX2hhc19zaW4sIGJfaGFzX2NvcywgYV9oYXNfY29zLCBiX2hhc19zaW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4xID0gZjIuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjIgPSBmMi5iO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFfaGFzX3NpbiA9IGZuMS5jb250YWluc0Z1bmN0aW9uKCdzaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhX2hhc19jb3MgPSBmbjEuY29udGFpbnNGdW5jdGlvbignY29zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYl9oYXNfY29zID0gZm4yLmNvbnRhaW5zRnVuY3Rpb24oJ2NvcycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJfaGFzX3NpbiA9IGZuMi5jb250YWluc0Z1bmN0aW9uKCdzaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmMi54LnZhbHVlID09PSBzICYmIGYyLnguaXNMaW5lYXIoKSAmJiAhKChhX2hhc19zaW4gJiYgYl9oYXNfY29zKSB8fCAoYV9oYXNfY29zIHx8IGJfaGFzX3NpbikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoKHsxfSkqY29zKChzcXJ0KCh7Mn0pKih7M30pKSooezB9KSkvKHsyfSkpKS8oezJ9KScsIHQsIGYyLmEsIGYuYSwgZi5iKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhX2hhc19zaW4gJiYgYl9oYXNfY29zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2luLCBjb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW4gPSBmbjEuZmluZEZ1bmN0aW9uKCdzaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcyA9IGZuMi5maW5kRnVuY3Rpb24oJ2NvcycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93aG8gaGFzIHRoZSBzP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2luLmFyZ3NbMF0uZXF1YWxzKGNvcy5hcmdzWzBdKSAmJiAhc2luLmFyZ3NbMF0uY29udGFpbnMocykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiwgYywgZCwgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gXy5kaXZpZGUoZm4yLCBjb3MudG9Vbml0TXVsdGlwbGllcigpKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBzaW4uYXJnc1swXS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBmLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IF8uZGl2aWRlKGZuMSwgc2luLnRvVW5pdE11bHRpcGxpZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwID0gJygoezF9KSooezJ9KSpjb3MoezN9KSpzaW4oc3FydCh7NH0pKih7MH0pKSkvc3FydCh7NH0pKyh7MX0pKnNpbih7M30pKih7NX0pKmNvcyhzcXJ0KHs0fSkqKHswfSkpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChleHAsIHQsIGEsIGIsIGMsIGQsIGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGYueC5wb3dlci5udW0gJiYgZi54LnBvd2VyLm51bS5lcXVhbHMoMykgJiYgZi54LnBvd2VyLmRlbi5lcXVhbHMoMikgJiYgbnVtLmNvbnRhaW5zKCdzcXJ0KHBpKScpICYmICFudW0uY29udGFpbnMocykgJiYgbnVtLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gXy5kaXZpZGUobnVtLmNsb25lKCksIF8ucGFyc2UoJ3NxcnQocGkpJykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJygyKih7Mn0pKnNxcnQoezB9KSkvKHsxfSknLCB0LCBmLmEsIGIsIG51bSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZGVuX3AuZXF1YWxzKDIpICYmIGYueC5wb3dlci5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhLCBkLCBleHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighbnVtLmNvbnRhaW5zKHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF8uZGl2aWRlKG51bSwgbmV3IFN5bWJvbCgyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwID0gJygoezF9KSpzaW4oKHNxcnQoKHsyfSkqKHszfSkpKih7MH0pKS8oezJ9KSkpLygoezN9KSpzcXJ0KCh7Mn0pKih7M30pKSktKCh7MX0pKih7MH0pKmNvcygoc3FydCgoezJ9KSooezN9KSkqKHswfSkpLyh7Mn0pKSkvKCh7Mn0pKih7M30pKSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoZXhwLCB0LCBhLCBmLmEsIGYuYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb21wb3NlIHRoZSBudW1lcmF0b3IgdG8gY2hlY2sgdmFsdWUgb2Ygc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYyID0gY29yZS5VdGlscy5kZWNvbXBvc2VfZm4oXy5leHBhbmQobnVtLmNsb25lKCkpLCBzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmMi54LmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNfdGVybXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBjb2xsZWN0IHRoZSBmYWN0b3JzIGUuZy4gKGEpKGJ4KShjeF4yK2QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gbnVtLmNvbGxlY3RTeW1ib2xzKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gU3ltYm9sLnVud3JhcFBBUkVOUyh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gY29yZS5VdGlscy5kZWNvbXBvc2VfZm4oeCwgcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnN5bWJvbCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGVuIHNvcnQgdGhlbSBieSBwb3dlciBoaWdodGVzdCB0byBsb3dlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwMSwgcDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gYS54LnZhbHVlICE9PSBzID8gMCA6IGEueC5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBiLngudmFsdWUgIT09IHMgPyAwIDogYi54LnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDIgLSBwMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IG5ldyBTeW1ib2woLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHcmFiIG9ubHkgdGhlIG9uZXMgd2hpY2ggaGF2ZSBzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmMgPSBzeW1ib2xzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmMueC52YWx1ZSA9PT0gcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzX3Rlcm1zLnB1c2goZmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfLm11bHRpcGx5KGEsIGZjLnN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyAyIGFzc3VtcHRpb25zIGFyZSBtYWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEuIHNpbmNlIHRoZSBudW1lcmF0b3Igd2FzIGZhY3RvcmVkIGFib3ZlIHRoZW4gZWFjaCBzX3Rlcm0gaGFzIGEgdW5pcXVlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuIGJlY2F1c2UgdGhlIHRlcm1zIGFyZSBzb3J0ZWQgYnkgZGVzY2VuZGluZyBwb3dlcnMgdGhlbiB0aGUgZmlyc3QgaXRlbSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgaGFzIHRoZSBoaWdoZXN0IHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBub3cgY2hlY2sgZm9yIHRoZSBuZXh0IHR5cGUgcyhzXjItYV4yKS8oc14yK2FeMileMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzX3Rlcm1zWzBdLngucG93ZXIuZXF1YWxzKDIpICYmIHNfdGVybXNbMV0ueC5wb3dlci5lcXVhbHMoMSkgJiYgc190ZXJtc1sxXS5iLmVxdWFscygwKSAmJiAhc190ZXJtc1swXS5iLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHNfdGVybXNbMF0uYS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cCA9ICctKCh7MX0pKih7Mn0pKih7NX0pKih7MH0pKnNpbigoc3FydCgoezR9KSooezV9KSkqKHswfSkpLyh7NH0pKSkvJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoMiooezR9KV4yKnNxcnQoKHs0fSkqKHs1fSkpKS0oKHsxfSkqKHszfSkqKHswfSkqc2luKChzcXJ0KCh7NH0pKih7NX0pKSooezB9KSkvKHs0fSkpKScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLygyKih7NH0pKnNxcnQoKHs0fSkqKHs1fSkpKSsoKHsxfSkqKHsyfSkqY29zKChzcXJ0KCh7NH0pKih7NX0pKSooezB9KSkvKHs0fSkpKS8oezR9KV4yJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KGV4cCwgdCwgYSwgYiwgc190ZXJtc1swXS5iLCBmLmEsIGYuYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmMi54LmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfLmRpdmlkZShmMi5hLCBuZXcgU3ltYm9sKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cCA9ICcoKHsxfSkqKHswfSkqc2luKChzcXJ0KCh7Mn0pKih7M30pKSooezB9KSkvKHsyfSkpKS8oKHsyfSkqc3FydCgoezJ9KSooezN9KSkpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KGV4cCwgdCwgYSwgZi5hLCBmLmIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGYyLngucG93ZXIuZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmMi5iLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfLmRpdmlkZShmMi5hLCBuZXcgU3ltYm9sKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHAgPSAnKCh7MX0pKnNpbigoc3FydCgoezJ9KSooezN9KSkqKHswfSkpLyh7Mn0pKSkvKCh7Mn0pKnNxcnQoKHsyfSkqKHszfSkpKSsoKHsxfSkqKHswfSkqY29zKChzcXJ0KCh7Mn0pKih7M30pKSooezB9KSkvKHsyfSkpKS8oezJ9KV4yJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChleHAsIHQsIGEsIGYuYSwgZi5iKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gXy5kaXZpZGUoZjIuYSwgbmV3IFN5bWJvbCgyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGYyLmIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwID0gJy0oKCh7Mn0pKih7NH0pLTIqKHsxfSkqKHszfSkpKnNpbigoc3FydCgoezJ9KSooezN9KSkqKHswfSkpLyh7Mn0pKSkvKDIqKHsyfSkqKHszfSkqc3FydCgoezJ9KSooezN9KSkpKycgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJygoezR9KSooezB9KSpjb3MoKHNxcnQoKHsyfSkqKHszfSkpKih7MH0pKS8oezJ9KSkpLygyKih7Mn0pKih7M30pKSsoKHsxfSkqKHswfSkqY29zKChzcXJ0KCh7Mn0pKih7M30pKSooezB9KSkvKHsyfSkpKS8oezJ9KV4yJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChleHAsIHQsIGEsIGYuYSwgZi5iLCBkKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEvKHMrMSleMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVuX3AuZXF1YWxzKDIpICYmIGYueC5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoYCgke219KSooJHt0fSkqZV4oLSgke2YuYn0pKigke3R9KSlgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX18uTGFQbGFjZS5pbnZlcnNlKHgsIHNfLCB0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFyZXR2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignaWx0JywgW2lucHV0X3N5bWJvbCwgc18sIHRdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgU3RhdGlzdGljczoge1xyXG4gICAgICAgICAgICBmcmVxdWVuY3lNYXA6IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBmcmVxdWVuY3kgbWFwXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gYXJyW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFtYXBba2V5XSkgLy9kZWZhdWx0IGl0IHRvIHplcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwW2tleV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcFtrZXldKys7IC8vaW5jcmVtZW50XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzb3J0OiBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZighYS5pc0NvbnN0YW50KCkgfHwgIWIuaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVycm9yKCdVbmFibGUgdG8gc29ydCEgQWxsIHZhbHVlcyBtdXN0IGJlIG51bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5tdWx0aXBsaWVyLnN1YnRyYWN0KGIubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY291bnQ6IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKGFyci5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdW06IGZ1bmN0aW9uIChhcnIsIHhfKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhpID0gYXJyW2ldLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gXy5hZGQoXy5wb3coXy5zdWJ0cmFjdCh4aSwgeF8uY2xvbmUoKSksIG5ldyBTeW1ib2woMikpLCBzdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSA9IF8uYWRkKHhpLCBzdW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1lYW46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBpZihpc1ZlY3RvcihhcmdzWzBdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5tZWFuLmFwcGx5KHRoaXMsIGFyZ3NbMF0uZWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICBfLmRpdmlkZShfXy5TdGF0aXN0aWNzLnN1bShhcmdzKSwgX18uU3RhdGlzdGljcy5jb3VudChhcmdzKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1lZGlhbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIC8vaGFuZGxlIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgaWYoaXNWZWN0b3IoYXJnc1swXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3MubWVkaWFuLmFwcGx5KHRoaXMsIGFyZ3NbMF0uZWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29ydGVkID0gX18uU3RhdGlzdGljcy5zb3J0KGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gYXJncy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5VdGlscy5ldmVuKGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaWQgPSBsIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uU3RhdGlzdGljcy5tZWFuKHNvcnRlZFttaWQgLSAxXSwgc29ydGVkW21pZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHNvcnRlZFtNYXRoLmZsb29yKGwgLyAyKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignbWVkaWFuJywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtb2RlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBpZihpc1ZlY3RvcihhcmdzWzBdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5tb2RlLmFwcGx5KHRoaXMsIGFyZ3NbMF0uZWxlbWVudHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBfXy5TdGF0aXN0aWNzLmZyZXF1ZW5jeU1hcChhcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3RoZSBtb2RlIG9mIDEgaXRlbSBpcyB0aGF0IGl0ZW0gYXMgcGVyIGlzc3VlICMzMTAgKHZlcmlmaWVkIGJ5IEhhcHB5cGlnMzc1KS4gXHJcbiAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmtleXMobWFwKS5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaW52ZXJ0IGJ5IGFycmFuaW5nIHRoZW0gYWNjb3JkaW5nIHRvIHRoZWlyIGZyZXF1ZW5jeVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIG1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJlcSA9IG1hcFt4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBpdCdzIGluIHRoZSBpbnZlcnNlIGFscmVhZHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIShmcmVxIGluIGludmVyc2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZVtmcmVxXSA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBpbnZlcnNlW2ZyZXFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGFscmVhZHkgYW4gYXJyYXkgdGhlbiBqdXN0IGFkZCBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNBcnJheShlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnZlcnQgaXQgdG8gYW5kIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52ZXJzZVtmcmVxXSA9IFt4LCBpbnZlcnNlW2ZyZXFdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBrZXlzIG5vdyByZXByZXNlbnQgdGhlIG1heGVzLiBXZSB3YW50IHRoZSBtYXggb2YgdGhvc2Uga2V5c1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBpbnZlcnNlW01hdGgubWF4LmFwcGx5KG51bGwsIGNvcmUuVXRpbHMua2V5cyhpbnZlcnNlKSldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaXQncyBhbiBhcnJheS4gSWYgaXQgaXMgdGhlbiBtYXAgb3ZlciB0aGUgcmVzdWx0cyBhbmQgY29udmVydCBcclxuICAgICAgICAgICAgICAgICAgICAvL3RoZW0gdG8gU3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNBcnJheShtYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ21vZGUnLCBtYXguc29ydCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKG1heCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ1ZhcmlhbmNlOiBmdW5jdGlvbiAoaywgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhfID0gX18uU3RhdGlzdGljcy5tZWFuLmFwcGx5KF9fLlN0YXRpc3RpY3MsIGFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gPSBfXy5TdGF0aXN0aWNzLnN1bShhcmdzLCB4Xyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShrLCBzdW0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB2YXJpYW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKGFyZ3NbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLnZhcmlhbmNlLmFwcGx5KHRoaXMsIGFyZ3NbMF0uZWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfLmRpdmlkZShuZXcgU3ltYm9sKDEpLCBfXy5TdGF0aXN0aWNzLmNvdW50KGFyZ3MpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLmdWYXJpYW5jZShrLCBhcmdzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2FtcGxlVmFyaWFuY2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBpZihpc1ZlY3RvcihhcmdzWzBdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5zYW1wbGVWYXJpYW5jZS5hcHBseSh0aGlzLCBhcmdzWzBdLmVsZW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IF8uZGl2aWRlKG5ldyBTeW1ib2woMSksIF8uc3VidHJhY3QoX18uU3RhdGlzdGljcy5jb3VudChhcmdzKSwgbmV3IFN5bWJvbCgxKSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3MuZ1ZhcmlhbmNlKGssIGFyZ3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdGFuZGFyZERldmlhdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKGFyZ3NbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLnN0YW5kYXJkRGV2aWF0aW9uLmFwcGx5KHRoaXMsIGFyZ3NbMF0uZWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucG93KF9fLlN0YXRpc3RpY3MudmFyaWFuY2UuYXBwbHkoX18uU3RhdGlzdGljcywgYXJncyksIG5ldyBTeW1ib2woMSAvIDIpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2FtcGxlU3RhbmRhcmREZXZpYXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBpZihpc1ZlY3RvcihhcmdzWzBdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5zYW1wbGVTdGFuZGFyZERldmlhdGlvbi5hcHBseSh0aGlzLCBhcmdzWzBdLmVsZW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnBvdyhfXy5TdGF0aXN0aWNzLnNhbXBsZVZhcmlhbmNlLmFwcGx5KF9fLlN0YXRpc3RpY3MsIGFyZ3MpLCBuZXcgU3ltYm9sKDEgLyAyKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHpTY29yZTogZnVuY3Rpb24gKHgsIG1lYW4sIHN0ZGV2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoXy5zdWJ0cmFjdCh4LCBtZWFuKSwgc3RkZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBVbml0czoge1xyXG4gICAgICAgICAgICB0YWJsZToge1xyXG4gICAgICAgICAgICAgICAgZm9vdDogJzEyIGluY2gnLFxyXG4gICAgICAgICAgICAgICAgbWV0ZXI6ICcxMDAgY20nLFxyXG4gICAgICAgICAgICAgICAgZGVjaW1ldGVyOiAnMTAgY20nLFxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbmVyZGFtZXIucmVnaXN0ZXIoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2xhcGxhY2UnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAzLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLkxhUGxhY2UudHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdpbHQnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAzLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLkxhUGxhY2UuaW52ZXJzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9zdGF0aXN0aWNhbFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ21lYW4nLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAtMSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLm1lYW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ21lZGlhbicsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IC0xLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3MubWVkaWFuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdtb2RlJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogLTEsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5tb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdzbXB2YXInLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAtMSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLnNhbXBsZVZhcmlhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICd2YXJpYW5jZScsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IC0xLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3MudmFyaWFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3NtcHN0ZGV2JyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogLTEsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5zYW1wbGVTdGFuZGFyZERldmlhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnc3RkZXYnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAtMSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLnN0YW5kYXJkRGV2aWF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICd6c2NvcmUnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAzLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3MuelNjb3JlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcblxyXG4gICAgLy9saW5rIHJlZ2lzdGVyZWQgZnVuY3Rpb25zIGV4dGVybmFsbHlcclxuICAgIG5lcmRhbWVyLmFwaSgpO1xyXG59KCkpO1xyXG5cclxuLy8gQWRkZWQgZm9yIGFsbC5taW4uanNcclxuaWYoKHR5cGVvZiBtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBuZXJkYW1lcjtcclxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///518\n")},322:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n/* global module */\r\n\r\nif(true) {\r\n    var nerdamer = __webpack_require__(182);\r\n    __webpack_require__(238);\r\n    __webpack_require__(684);\r\n}\r\n\r\n(function () {\r\n    //handle imports\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            _A = core.Algebra,\r\n            _C = core.Calculus,\r\n            explode = _C.integration.decompose_arg,\r\n            evaluate = core.Utils.evaluate,\r\n            remove = core.Utils.remove,\r\n            format = core.Utils.format,\r\n            build = core.Utils.build,\r\n            knownVariable = core.Utils.knownVariable,\r\n            Symbol = core.Symbol,\r\n            isSymbol = core.Utils.isSymbol,\r\n            variables = core.Utils.variables,\r\n            S = core.groups.S,\r\n            PL = core.groups.PL,\r\n            CB = core.groups.CB,\r\n            CP = core.groups.CP,\r\n            FN = core.groups.FN,\r\n            Settings = core.Settings,\r\n            range = core.Utils.range,\r\n            isArray = core.Utils.isArray;\r\n\r\n\r\n    // The search radius for the roots\r\n    core.Settings.SOLVE_RADIUS = 1000;\r\n    // The maximum number to fish for on each side of the zero\r\n    core.Settings.ROOTS_PER_SIDE = 10;\r\n    // Covert the number to multiples of pi if possible\r\n    core.Settings.make_pi_conversions = false;\r\n    // The step size\r\n    core.Settings.STEP_SIZE = 0.1;\r\n    // The epsilon size\r\n    core.Settings.EPSILON = 1e-13;\r\n    //the maximum iterations for Newton's method\r\n    core.Settings.MAX_NEWTON_ITERATIONS = 200;\r\n    //the maximum number of time non-linear solve tries another jump point\r\n    core.Settings.MAX_NON_LINEAR_TRIES = 12;\r\n    //the amount of iterations the function will start to jump at\r\n    core.Settings.NON_LINEAR_JUMP_AT = 50;\r\n    //the size of the jump\r\n    core.Settings.NON_LINEAR_JUMP_SIZE = 100;\r\n    //the original starting point for nonlinear solving\r\n    core.Settings.NON_LINEAR_START = 0.01;\r\n    //When points are generated as starting points for Newton's method, they are sliced into small\r\n    //slices to make sure that we have convergence on the right point. This defines the \r\n    //size of the slice\r\n    core.Settings.NEWTON_SLICES = 200;\r\n    //The epsilon used in Newton's iteration\r\n    core.Settings.NEWTON_EPSILON = Number.EPSILON * 2;\r\n    //The distance in which two solutions are deemed the same\r\n    core.Settings.SOLUTION_PROXIMITY = 1e-14;\r\n    //Indicate wheter to filter the solutions are not\r\n    core.Settings.FILTER_SOLUTIONS = true;\r\n    //the maximum number of recursive calls\r\n    core.Settings.MAX_SOLVE_DEPTH = 10;\r\n    // The tolerance that's considered close enough to zero\r\n    core.Settings.ZERO_EPSILON = 1e-9;\r\n    // The maximum iteration for the bisection method incase of some JS strangeness\r\n    core.Settings.MAX_BISECTION_ITER = 2000;\r\n    // The tolerance for the bisection method\r\n    core.Settings.BI_SECTION_EPSILON = 1e-12;\r\n\r\n\r\n    core.Symbol.prototype.hasTrig = function () {\r\n        return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\r\n    };\r\n\r\n    core.Symbol.prototype.hasNegativeTerms = function () {\r\n        if(this.isComposite()) {\r\n            for(var x in this.symbols) {\r\n                var sym = this.symbols[x];\r\n                if(sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\r\n     * As such we can have this data type be supported completely outside of the core.\r\n     * This is an equation that has a left hand side and a right hand side\r\n     */\r\n    function Equation(lhs, rhs) {\r\n        if(rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) || rhs.equals(core.Settings.IMAGINARY))\r\n            throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\r\n        this.LHS = lhs; //left hand side\r\n        this.RHS = rhs; //right and side\r\n    }\r\n    ;\r\n\r\n    //UTILS ##!!\r\n\r\n    Equation.prototype = {\r\n        toString: function () {\r\n            return this.LHS.toString() + '=' + this.RHS.toString();\r\n        },\r\n        text: function (option) {\r\n            return this.LHS.text(option) + '=' + this.RHS.text(option);\r\n        },\r\n        toLHS: function (expand) {\r\n            expand = typeof expand === 'undefined' ? true : false;\r\n            var eqn;\r\n            if(!expand) {\r\n                eqn = this.clone();\r\n            }\r\n            else {\r\n                eqn = this.removeDenom();\r\n            }\r\n            var a = eqn.LHS;\r\n            var b = eqn.RHS;\r\n            if(a.isConstant(true) && !b.isConstant(true)) {\r\n                // Swap them to avoid confusing parser and cause an infinite loop\r\n                [a, b] = [b, a];\r\n            }\r\n            var _t = _.subtract(a, b);\r\n            var retval = expand ? _.expand(_t) : _t;\r\n            return retval;\r\n        },\r\n        removeDenom: function () {\r\n            var a = this.LHS.clone();\r\n            var b = this.RHS.clone();\r\n            //remove the denominator on both sides\r\n            var den = _.multiply(a.getDenom(), b.getDenom());\r\n            a = _.expand(_.multiply(a, den.clone()));\r\n            b = _.expand(_.multiply(b, den));\r\n            //swap the groups\r\n            if(b.group === CP && b.group !== CP) {\r\n                var t = a;\r\n                a = b;\r\n                b = t; //swap\r\n            }\r\n\r\n            //scan to eliminate denominators\r\n            if(a.group === CB) {\r\n                var t = new Symbol(a.multiplier),\r\n                        newRHS = b.clone();\r\n                a.each(function (y) {\r\n                    if(y.power.lessThan(0))\r\n                        newRHS = _.divide(newRHS, y);\r\n                    else\r\n                        t = _.multiply(t, y);\r\n                });\r\n                a = t;\r\n                b = newRHS;\r\n\r\n            }\r\n            else if(a.group === CP) {\r\n                //the logic: loop through each and if it has a denominator then multiply it out on both ends\r\n                //and then start over\r\n                for(var x in a.symbols) {\r\n                    var sym = a.symbols[x];\r\n                    if(sym.group === CB) {\r\n                        for(var y in sym.symbols) {\r\n                            var sym2 = sym.symbols[y];\r\n                            if(sym2.power.lessThan(0)) {\r\n                                return new Equation(\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), a)),\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), b))\r\n                                        );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return new Equation(a, b);\r\n        },\r\n        clone: function () {\r\n            return new Equation(this.LHS.clone(), this.RHS.clone());\r\n        },\r\n        sub: function (x, y) {\r\n            var clone = this.clone();\r\n            clone.LHS = clone.LHS.sub(x.clone(), y.clone());\r\n            clone.RHS = clone.RHS.sub(x.clone(), y.clone());\r\n            return clone;\r\n        },\r\n        isZero: function () {\r\n            return core.Utils.evaluate(this.toLHS()).equals(0);\r\n        },\r\n        latex: function (option) {\r\n            return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\r\n        }\r\n    };\r\n    //overwrite the equals function\r\n    _.equals = function (a, b) {\r\n        return new Equation(a, b);\r\n    };\r\n\r\n    // Extend simplify\r\n    (function () {\r\n        var simplify = _.functions.simplify[0];\r\n        _.functions.simplify[0] = function (symbol) {\r\n            if(symbol instanceof Equation) {\r\n                symbol.LHS = simplify(symbol.LHS);\r\n                symbol.RHS = simplify(symbol.RHS);\r\n                return symbol;\r\n            }\r\n            // Just call the original simplify\r\n            return simplify(symbol);\r\n        };\r\n    })();\r\n\r\n    /**\r\n     * Sets two expressions equal\r\n     * @param {Symbol} symbol\r\n     * @returns {Expression}\r\n     */\r\n    core.Expression.prototype.equals = function (symbol) {\r\n        if(symbol instanceof core.Expression)\r\n            symbol = symbol.symbol; //grab the symbol if it's an expression\r\n        var eq = new Equation(this.symbol, symbol);\r\n        return eq;\r\n    };\r\n\r\n    core.Expression.prototype.solveFor = function (x) {\r\n        var symbol;\r\n        if(this.symbol instanceof Equation) {\r\n            //exit right away if we already have the answer\r\n            //check the LHS\r\n            if(this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x))\r\n                return new core.Expression(this.symbol.LHS);\r\n\r\n            //check the RHS\r\n            if(this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x))\r\n                return new core.Expression(this.symbol.RHS);\r\n\r\n            //otherwise just bring it to LHS\r\n            symbol = this.symbol.toLHS();\r\n        }\r\n        else {\r\n            symbol = this.symbol;\r\n        }\r\n\r\n        return solve(symbol, x).map(function (x) {\r\n            return new core.Expression(x);\r\n        });\r\n    };\r\n\r\n    core.Expression.prototype.expand = function () {\r\n        if(this.symbol instanceof Equation) {\r\n            var clone = this.symbol.clone();\r\n            clone.RHS = _.expand(clone.RHS);\r\n            clone.LHS = _.expand(clone.LHS);\r\n            return new core.Expression(clone);\r\n        }\r\n        return new core.Expression(_.expand(this.symbol));\r\n    };\r\n\r\n    core.Expression.prototype.variables = function () {\r\n        if(this.symbol instanceof Equation)\r\n            return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\r\n        return variables(this.symbol);\r\n    };\r\n\r\n\r\n\r\n    var setEq = function (a, b) {\r\n        return _.equals(a, b);\r\n    };\r\n\r\n    //link the Equation class back to the core\r\n    core.Equation = Equation;\r\n\r\n    //Loops through an array and attempts to fails a test. Stops if manages to fail.\r\n    var checkAll = core.Utils.checkAll = function (args, test) {\r\n        for(var i = 0; i < args.length; i++)\r\n            if(test(args[i]))\r\n                return false;\r\n        return true;\r\n    };\r\n\r\n    //version solve\r\n    var __ = core.Solve = {\r\n        version: '2.0.3',\r\n        solutions: [],\r\n        solve: function (eq, variable) {\r\n            var solution = solve(eq, String(variable));\r\n            return new core.Vector(solution);\r\n            //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\r\n        },\r\n        /**\r\n         * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\r\n         * @param {Equation|String} eqn\r\n         * @returns {Symbol}\r\n         */\r\n        toLHS: function (eqn, expand) {\r\n            if(isSymbol(eqn))\r\n                return eqn;\r\n            //If it's an equation then call its toLHS function instead\r\n            if(!(eqn instanceof Equation)) {\r\n                var es = eqn.split('=');\r\n                //convert falsey values to zero\r\n                es[1] = es[1] || '0';\r\n                eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\r\n            }\r\n            return eqn.toLHS(expand);\r\n        },\r\n//        getSystemVariables: function(eqns) {\r\n//            vars = variables(eqns[0], null, null, true);\r\n//\r\n//            //get all variables\r\n//            for (var i = 1, l=eqns.length; i < l; i++)\r\n//                vars = vars.concat(variables(eqns[i]));\r\n//            //remove duplicates\r\n//            vars = core.Utils.arrayUnique(vars).sort();\r\n//            \r\n//            //done\r\n//            return vars;\r\n//        },\r\n        /**\r\n         * Solve a set of circle equations. \r\n         * @param {Symbol[]} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveCircle: function (eqns, vars) {\r\n            // Convert the variables to symbols\r\n            var svars = vars.map(function (x) {\r\n                return _.parse(x)\r\n            });\r\n\r\n            var deg = [];\r\n\r\n            var solutions = [];\r\n\r\n            // Get the degree for the equations\r\n            for(var i = 0; i < eqns.length; i++) {\r\n                var d = [];\r\n                for(var j = 0; j < svars.length; j++) {\r\n                    d.push(Number(core.Algebra.degree(eqns[i], svars[j])));\r\n                }\r\n                // Store the total degree\r\n                d.push(core.Utils.arraySum(d, true));\r\n                deg.push(d);\r\n            }\r\n\r\n            var a = eqns[0];\r\n            var b = eqns[1];\r\n\r\n            if(deg[0][2] > deg[1][2]) {\r\n                [b, a] = [a, b];\r\n                [deg[1], deg[0]] = [deg[0], deg[1]];\r\n            }\r\n\r\n            // Only solve it's truly a circle\r\n            if(deg[0][0] === 1 && deg[0][2] === 2 && deg[1][0] === 2 && deg[1][2] === 4) {\r\n                // For clarity we'll refer to the variables as x and y\r\n                var x = vars[0];\r\n                var y = vars[1];\r\n\r\n                // We can now get the two points for y\r\n                var y_points = solve(_.parse(b, knownVariable(x, solve(_.parse(a), x)[0])), y).map(function (x) {\r\n                    return x.toString();\r\n                });\r\n\r\n                // Since we now know y we can get the two x points from the first equation\r\n                var x_points = [\r\n                    solve(_.parse(a, knownVariable(y, y_points[0])))[0].toString()\r\n                ];\r\n\r\n                if(y_points[1]) {\r\n                    x_points.push(solve(_.parse(a, knownVariable(y, y_points[1])))[0].toString());\r\n                }\r\n\r\n                if(Settings.SOLUTIONS_AS_OBJECT) {\r\n                    var solutions = {};\r\n                    solutions[x] = x_points;\r\n                    solutions[y] = y_points;\r\n                }\r\n                else {\r\n                    y_points.unshift(y);\r\n                    x_points.unshift(x);\r\n                    solutions = [x_points, y_points];\r\n                }\r\n            }\r\n\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solve a system of nonlinear equations\r\n         * @param {Symbol[]} eqns The array of equations\r\n         * @param {number} tries The maximum number of tries\r\n         * @param {number} start The starting point where to start looking for solutions\r\n         * @returns {Array}\r\n         */\r\n        solveNonLinearSystem: function (eqns, tries, start) {\r\n            if(tries < 0) {\r\n                return [];//can't find a solution\r\n            }\r\n\r\n            start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start;\r\n\r\n            //the maximum number of times to jump\r\n            var max_tries = core.Settings.MAX_NON_LINEAR_TRIES;\r\n\r\n            //halfway through the tries\r\n            var halfway = Math.floor(max_tries / 2);\r\n\r\n            //initialize the number of tries to 10 if not specified\r\n            tries = typeof tries === 'undefined' ? max_tries : tries;\r\n\r\n            //a point at which we check to see if we're converging. By inspection it seems that we can\r\n            //use around 20 iterations to see if we're converging. If not then we retry a jump of x\r\n            var jump_at = core.Settings.NON_LINEAR_JUMP_AT;\r\n\r\n            //we jump by this many points at each pivot point\r\n            var jump = core.Settings.NON_LINEAR_JUMP_SIZE;\r\n\r\n            //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\r\n            var found = true;\r\n\r\n            var create_subs = function (vars, matrix) {\r\n                return vars.map(function (x, i) {\r\n                    return Number(matrix.get(i, 0));\r\n                });\r\n            };\r\n\r\n            var vars = core.Utils.arrayGetVariables(eqns);\r\n            var jacobian = core.Matrix.jacobian(eqns, vars, function (x) {\r\n                return build(x, vars);\r\n            }, true);\r\n\r\n            var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\r\n            var o, y, iters, xn1, norm, lnorm, xn, d;\r\n\r\n            var f_eqns = eqns.map(function (eq) {\r\n                return build(eq, vars);\r\n            });\r\n\r\n            var J = jacobian.map(function (e) {\r\n                return build(e, vars);\r\n            }, true);\r\n            //initial values\r\n            xn1 = core.Matrix.cMatrix(0, vars);\r\n\r\n            //initialize the c matrix with something close to 0. \r\n            var c = core.Matrix.cMatrix(start, vars);\r\n\r\n            iters = 0;\r\n\r\n            //start of algorithm\r\n            do {\r\n                //if we've reached the max iterations then exit\r\n                if(iters > max_iter) {\r\n                    break;\r\n                    found = false;\r\n                }\r\n\r\n                //set the substitution object\r\n                o = create_subs(vars, c);\r\n\r\n                //set xn\r\n                xn = c.clone();\r\n\r\n                //make all the substitutions for each of the equations\r\n                f_eqns.forEach(function (f, i) {\r\n                    c.set(i, 0, f.apply(null, o));\r\n                });\r\n\r\n                var m = new core.Matrix();\r\n                J.each(function (fn, i, j) {\r\n                    var ans = fn.apply(null, o);\r\n                    m.set(i, j, ans);\r\n                });\r\n\r\n                m = m.invert();\r\n\r\n                //preform the elimination\r\n                y = _.multiply(m, c).negate();\r\n\r\n                //the callback is to avoid overflow in the coeffient denonimator\r\n                //it converts it to a decimal and then back to a fraction. Some precision\r\n                //is lost be it's better than overflow. \r\n                d = y.subtract(xn1, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                xn1 = xn.add(y, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                //move c is now xn1\r\n                c = xn1;\r\n\r\n                //get the norm\r\n\r\n                //the expectation is that we're converging to some answer as this point regardless of where we start\r\n                //this may have to be adjusted at some point because of erroneous assumptions\r\n                if(iters >= jump_at) {\r\n                    //check the norm. If the norm is greater than one then it's time to try another point\r\n                    if(norm > 1) {\r\n                        //reset the start point at halway\r\n                        if(tries === halfway)\r\n                            start = 0;\r\n                        var sign = tries > halfway ? 1 : -1; //which side are we incrementing\r\n                        //we increment +n at one side and -n at the other. \r\n                        n = (tries % Math.floor(halfway)) + 1;\r\n                        //adjust the start point\r\n                        start += (sign * n * jump);\r\n                        //call restart\r\n                        return __.solveNonLinearSystem(eqns, --tries, start);\r\n                    }\r\n                }\r\n                lnorm = norm;\r\n                iters++;\r\n                norm = d.max();\r\n\r\n                //exit early. Revisit if we get bugs\r\n                if(Number(norm) === Number(lnorm)) {\r\n                    break;\r\n                }\r\n            }\r\n            while(Number(norm) >= Number.EPSILON)\r\n\r\n            //return a blank set if nothing was found;\r\n            if(!found)\r\n                return [];\r\n\r\n            //return c since that's the answer\r\n            return __.systemSolutions(c, vars, true, function (x) {\r\n                return core.Utils.round(Number(x), 14);\r\n            });\r\n        },\r\n        systemSolutions: function (result, vars, expand_result, callback) {\r\n            var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\r\n\r\n            result.each(function (e, idx) {\r\n                var solution = (expand_result ? _.expand(e) : e).valueOf();\r\n                if(callback)\r\n                    solution = callback.call(e, solution);\r\n                var variable = vars[idx];\r\n                if(core.Settings.SOLUTIONS_AS_OBJECT) {\r\n                    solutions[variable] = solution;\r\n                }\r\n                else\r\n                    solutions.push([variable, solution]); /*NO*/\r\n            });\r\n            //done\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solves a system of equations by substitution. This is useful when\r\n         * no distinct solution exists. e.g. a line, plane, etc.\r\n         * @param {Array} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveSystemBySubstitution: function (eqns) {\r\n            // Assume at least 2 equations. The function variables will just return an empty array if undefined is provided\r\n            var vars_a = variables(eqns[0]);\r\n            var vars_b = variables(eqns[1]);\r\n            // Check if it's a circle equation\r\n            if(eqns.length === 2 && vars_a.length === 2 && core.Utils.arrayEqual(vars_a, vars_b)) {\r\n                return __.solveCircle(eqns, vars_a);\r\n            }\r\n\r\n            return []; // return an empty set\r\n        },\r\n\r\n        //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\r\n        /**\r\n         * Solves a systems of equations\r\n         * @param {Array} eqns An array of equations\r\n         * @param {Array} var_array An array of variables\r\n         * @returns {Array|object}\r\n         */\r\n        solveSystem: function (eqns, var_array) {\r\n            //check if a var_array was specified\r\n            //nerdamer.clearVars();// this deleted ALL variables: not what we want\r\n            //parse all the equations to LHS. Remember that they come in as strings\r\n            for(var i = 0; i < eqns.length; i++)\r\n                eqns[i] = __.toLHS(eqns[i]);\r\n\r\n            var l = eqns.length,\r\n                    m = new core.Matrix(),\r\n                    c = new core.Matrix(),\r\n                    expand_result = false,\r\n                    vars;\r\n\r\n            if(typeof var_array === 'undefined') {\r\n                //check to make sure that all the equations are linear\r\n                if(!_A.allLinear(eqns)) {\r\n                    try {\r\n                        return __.solveNonLinearSystem(eqns);\r\n                    }\r\n                    catch(e) {\r\n                        if(e instanceof core.exceptions.DivisionByZero) {\r\n                            return __.solveSystemBySubstitution(eqns);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vars = core.Utils.arrayGetVariables(eqns);\r\n\r\n                // Deal with redundant equations as expressed in #562\r\n                // The fix is to remove all but the number of equations equal to the number\r\n                // of variables. We then solve those and then evaluate the remaining equations\r\n                // with those solutions. If the all equal true then those are just redundant\r\n                // equations and we can return the solution set.\r\n                if(vars.length < eqns.length) {\r\n                    var reduced = [];\r\n                    var n = eqns.length;\r\n                    for(var i = 0; i < n - 1; i++) {\r\n                        reduced.push(_.parse(eqns[i]));\r\n                    }\r\n\r\n                    var knowns = {};\r\n                    var solutions = __.solveSystem(reduced, vars);\r\n                    // The solutions may have come back as an array\r\n                    if(Array.isArray(solutions)) {\r\n                        solutions.forEach(function (sol) {\r\n                            knowns[sol[0]] = sol[1];\r\n                        });\r\n                    }\r\n                    else {\r\n                        knowns = solutions;\r\n                    }\r\n\r\n                    // Start by assuming they will all evaluate to zero. If even one fails\r\n                    // then all zero will be false\r\n                    var all_zero = true;\r\n                    // Check if the last solution evalutes to zero given these solutions\r\n                    for(var i = n - 1; i < n; i++) {\r\n                        if(!_.parse(eqns[i], knowns).equals(0)) {\r\n                            all_zero = false;\r\n                        }\r\n                    }\r\n\r\n                    if(all_zero) {\r\n                        return solutions;\r\n                    }\r\n                }\r\n\r\n                // deletes only the variables of the linear equations in the nerdamer namespace\r\n                for(var i = 0; i < vars.length; i++) {\r\n                    nerdamer.setVar(vars[i], \"delete\");\r\n                }\r\n                // TODO: move this to cMatrix or something similar\r\n                // populate the matrix\r\n                for(var i = 0; i < l; i++) {\r\n                    var e = eqns[i]; //store the expression\r\n                    // Iterate over the columns\r\n                    for(var j = 0; j < vars.length; j++) {\r\n                        var v = vars[j];\r\n                        var coeffs = [];\r\n                        e.each(function (x) {\r\n                            if(x.contains(v)) {\r\n                                coeffs = coeffs.concat(x.coeffs());\r\n                            }\r\n                        });\r\n\r\n                        var cf = core.Utils.arraySum(coeffs);\r\n                        m.set(i, j, cf);\r\n                    }\r\n\r\n                    //strip the variables from the symbol so we're left with only the zeroth coefficient\r\n                    //start with the symbol and remove each variable and its coefficient\r\n                    var num = e.clone();\r\n                    vars.map(function (e) {\r\n                        num = num.stripVar(e, true);\r\n                    });\r\n                    c.set(i, 0, num.negate());\r\n                }\r\n            }\r\n            else {\r\n                /**\r\n                 * The idea is that we loop through each equation and then expand it. Afterwards we loop\r\n                 * through each term and see if and check to see if it matches one of the variables.\r\n                 * When a match is found we mark it. No other match should be found for that term. If it\r\n                 * is we stop since it's not linear.\r\n                 */\r\n                vars = var_array;\r\n                expand_result = true;\r\n                for(i = 0; i < l; i++) {\r\n                    //prefill\r\n                    c.set(i, 0, new Symbol(0));\r\n                    var e = _.expand(eqns[i]).collectSymbols(); //expand and store\r\n                    //go trough each of the variables\r\n                    for(var j = 0; j < var_array.length; j++) {\r\n                        m.set(i, j, new Symbol(0));\r\n                        var v = var_array[j];\r\n                        //go through the terms and sort the variables\r\n                        for(var k = 0; k < e.length; k++) {\r\n                            var term = e[k],\r\n                                    check = false;\r\n                            for(var z = 0; z < var_array.length; z++) {\r\n                                //check to see if terms contain multiple variables\r\n                                if(term.contains(var_array[z])) {\r\n                                    if(check)\r\n                                        core.err('Multiple variables found for term ' + term);\r\n                                    check = true;\r\n                                }\r\n                            }\r\n                            //we made sure that every term contains one variable so it's safe to assume that if the\r\n                            //variable is found then the remainder is the coefficient.\r\n                            if(term.contains(v)) {\r\n                                var tparts = explode(remove(e, k), v);\r\n                                m.set(i, j, _.add(m.get(i, j), tparts[0]));\r\n                            }\r\n                        }\r\n                    }\r\n                    //all the remaining terms go to the c matrix\r\n                    for(k = 0; k < e.length; k++) {\r\n                        c.set(i, 0, _.add(c.get(i, 0), e[k]));\r\n                    }\r\n                }\r\n                //consider case (a+b)*I+u\r\n            }\r\n\r\n            //check if the system has a distinct solution\r\n            if(vars.length !== eqns.length || m.determinant().equals(0)) {\r\n                // solve the system by hand\r\n                //return __.solveSystemBySubstitution(eqns, vars, m, c);\r\n                throw new core.exceptions.SolveError('System does not have a distinct solution');\r\n            }\r\n\r\n            // Use M^-1*c to solve system\r\n            m = m.invert();\r\n            var result = m.multiply(c);\r\n            //correct the sign as per issue #410\r\n            if(core.Utils.isArray(var_array))\r\n                result.each(function (x) {\r\n                    return x.negate();\r\n                });\r\n\r\n            return __.systemSolutions(result, vars, expand_result);\r\n        },\r\n        /**\r\n         * The quadratic function but only one side.\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Symbol}\r\n         */\r\n        quad: function (c, b, a) {\r\n            var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))/*b^2 - 4ac*/;\r\n            var det = _.pow(discriminant, Symbol(0.5));\r\n            var den = _.parse(_.multiply(new Symbol(2), a.clone()));\r\n            var retval = [\r\n                _.parse(format('(-({0})+({1}))/({2})', b, det, den)),\r\n                _.parse(format('(-({0})-({1}))/({2})', b, det, den))\r\n            ];\r\n\r\n            return retval;\r\n        },\r\n        /**\r\n         * The cubic equation\r\n         * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\r\n         * @param {Symbol} d_o\r\n         * @param {Symbol} c_o\r\n         * @param {Symbol} b_o\r\n         * @param {Symbol} a_o\r\n         * @returns {Array}\r\n         */\r\n        cubic: function (d_o, c_o, b_o, a_o) {\r\n            //convert everything to text\r\n            var a = a_o.text(), b = b_o.text(), c = c_o.text(), d = d_o.text();\r\n\r\n            var t = `(-(${b})^3/(27*(${a})^3)+(${b})*(${c})/(6*(${a})^2)-(${d})/(2*(${a})))`;\r\n            var u = `((${c})/(3*(${a}))-(${b})^2/(9*(${a})^2))`;\r\n            var v = `(${b})/(3*(${a}))`;\r\n            var x = `((${t})+sqrt((${t})^2+(${u})^3))^(1/3)+((${t})-sqrt((${t})^2+(${u})^3))^(1/3)-(${v})`;\r\n\r\n            // Convert a to one\r\n            var w = '1/2+sqrt(3)/2*i'; // Cube root of unity\r\n\r\n            return [\r\n                _.parse(x),\r\n                _.parse(`(${x})(${w})`),\r\n                _.parse(`(${x})(${w})^2`)\r\n            ];\r\n        },\r\n        /**\r\n         * The quartic equation\r\n         * @param {Symbol} e\r\n         * @param {Symbol} d\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Array}\r\n         */\r\n        quartic: function (e, d, c, b, a) {\r\n            var scope = {};\r\n            core.Utils.arrayUnique(variables(a).concat(variables(b))\r\n                    .concat(variables(c)).concat(variables(d)).concat(variables(e)))\r\n                    .map(function (x) {\r\n                        scope[x] = 1;\r\n                    });\r\n            a = a.toString();\r\n            b = b.toString();\r\n            c = c.toString();\r\n            d = d.toString();\r\n            e = e.toString();\r\n            var p, q, D, D0, D1, Q, x1, x2, x3, x4;\r\n            /*var D = core.Utils.block('PARSE2NUMBER', function() {\r\n             return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\r\n             \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\r\n             \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \r\n             a, b, c, d, e), scope);\r\n             });*/\r\n\r\n            p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\r\n            q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString();//a, b, c, d, e\r\n            D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\r\n            S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\r\n            x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            return [x1, x2, x3, x4];\r\n        },\r\n        /**\r\n         * Breaks the equation up in its factors and tries to solve the smaller parts\r\n         * @param {Symbol} symbol\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        divideAndConquer: function (symbol, solve_for) {\r\n            var sols = [];\r\n            //see if we can solve the factors\r\n            var factors = core.Algebra.Factor.factor(symbol);\r\n            if(factors.group === CB) {\r\n                factors.each(function (x) {\r\n                    x = Symbol.unwrapPARENS(x);\r\n                    sols = sols.concat(solve(x, solve_for));\r\n                });\r\n            }\r\n            return sols;\r\n        },\r\n        /**\r\n         * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\r\n         * @param {Symbol} eq\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        csolve: function (eq, solve_for) {\r\n            return core.Utils.block('IGNORE_E', function () {\r\n                var f, p, pn, n, pf, r, theta, sr, sp, roots;\r\n                roots = [];\r\n                f = core.Utils.decompose_fn(eq, solve_for, true);\r\n                if(f.x.group === S) {\r\n                    p = _.parse(f.x.power);\r\n                    pn = Number(p);\r\n                    n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\r\n                    pf = Symbol.toPolarFormArray(n);\r\n                    r = pf[0];\r\n                    theta = pf[1];\r\n                    sr = r.toString();\r\n                    sp = p.toString();\r\n                    var k, root, str;\r\n                    for(var i = 0; i < pn; i++) {\r\n                        k = i;\r\n                        str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\r\n                        root = _.parse(str);\r\n                        roots.push(root);\r\n                    }\r\n                }\r\n                return roots;\r\n            }, true);\r\n        },\r\n        /**\r\n         * Generates starting points for the Newton solver given an expression at zero.\r\n         * It beings by check if zero is a good point and starts expanding by a provided step size. \r\n         * Builds on the fact that if the sign changes over an interval then a zero\r\n         * must exist on that interval\r\n         * @param {Symbol} symbol\r\n         * @param {Number} step\r\n         * @param {Array} points\r\n         * @returns {Array}\r\n         */\r\n        getPoints: function (symbol, step, points) {\r\n            step = step || 0.01;\r\n            points = points || [];\r\n            var f = build(symbol);\r\n            var x0 = 0;\r\n\r\n            var start = Math.round(x0),\r\n                    last = f(start),\r\n                    last_sign = last / Math.abs(last),\r\n                    rside = core.Settings.ROOTS_PER_SIDE, // the max number of roots on right side\r\n                    lside = rside; // the max number of roots on left side\r\n            // check around the starting point\r\n            points.push(Math.floor(start / 2)); //half way from zero might be a good start\r\n            points.push(Math.abs(start)); //|f(0)| could be a good start\r\n            points.push(start);//|f(0)| could be a good start\r\n            //adjust for log. A good starting point to include for log is 0.1\r\n            symbol.each(function (x) {\r\n                if(x.containsFunction(core.Settings.LOG))\r\n                    points.push(0.1);\r\n            });\r\n\r\n            var left = range(-core.Settings.SOLVE_RADIUS, start, step),\r\n                    right = range(start, core.Settings.SOLVE_RADIUS, step);\r\n\r\n            var test_side = function (side, num_roots) {\r\n                var xi, val, sign;\r\n                var hits = [];\r\n                for(var i = 0, l = side.length; i < l; i++) {\r\n                    xi = side[i]; //the point being evaluated\r\n                    val = f(xi);\r\n                    sign = val / Math.abs(val);\r\n                    //Don't add non-numeric values\r\n                    if(isNaN(val) || !isFinite(val) || hits.length > num_roots) {\r\n                        continue;\r\n                    }\r\n\r\n                    //compare the signs. The have to be different if they cross a zero\r\n                    if(sign !== last_sign) {\r\n                        hits.push(xi); //take note of the possible zero location\r\n                    }\r\n                    last_sign = sign;\r\n                }\r\n\r\n                points = points.concat(hits);\r\n            };\r\n\r\n            test_side(left, lside);\r\n            test_side(right, rside);\r\n\r\n            return points;\r\n        },\r\n        /**\r\n         * Implements the bisection method. Returns undefined in no solution is found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @returns {undefined | number}\r\n         */\r\n        bisection: function (point, f) {\r\n            var left = point - 1;\r\n            var right = point + 1;\r\n            // First test if this point is even worth evaluating. It should\r\n            // be crossing the x axis so the signs should be different\r\n            if(Math.sign(f(left)) !== Math.sign(f(right))) {\r\n                var safety = 0;\r\n\r\n                var epsilon, middle;\r\n\r\n                do {\r\n                    epsilon = Math.abs(right - left);\r\n                    // Safety against an infinite loop\r\n                    if(safety++ > core.Settings.MAX_BISECTION_ITER || isNaN(epsilon)) {\r\n                        return;\r\n                    }\r\n                    // Calculate the middle point\r\n                    middle = (left + right) / 2;\r\n\r\n                    if(f(left) * f(middle) > 0) {\r\n                        left = middle;\r\n                    }\r\n                    else {\r\n                        right = middle;\r\n                    }\r\n                }\r\n                while(epsilon >= Settings.EPSILON);\r\n\r\n                var solution = (left + right) / 2;\r\n\r\n                // Test the solution to make sure that it's within tolerance\r\n                var x_point = f(solution);\r\n\r\n                if(!isNaN(x_point) && Math.abs(x_point) <= core.Settings.BI_SECTION_EPSILON) {\r\n                    // Returns too many junk solutions if not rounded at 13th place.\r\n                    return core.Utils.round(solution, 13);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Implements Newton's iterations. Returns undefined if no solutions if found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @param {function} fp\r\n         * @returns {undefined|number}\r\n         */\r\n        Newton: function (point, f, fp) {\r\n            var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\r\n                    iter = 0;\r\n            //first try the point itself. If it's zero viola. We're done\r\n            var x0 = point, x;\r\n            do {\r\n                var fx0 = f(x0); //store the result of the function\r\n                //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\r\n                if(x0 === 0 && fx0 === 0) {\r\n                    x = 0;\r\n                    break;\r\n                }\r\n\r\n                iter++;\r\n                if(iter > maxiter)\r\n                    return; //naximum iterations reached\r\n\r\n                x = x0 - fx0 / fp(x0);\r\n                var e = Math.abs(x - x0);\r\n                x0 = x;\r\n            }\r\n            while(e > Settings.NEWTON_EPSILON)\r\n\r\n            //check if the number is indeed zero. 1e-13 seems to give the most accurate results\r\n            if(Math.abs(f(x)) <= Settings.EPSILON)\r\n                return x;\r\n        },\r\n        rewrite: function (rhs, lhs, for_variable) {\r\n            lhs = lhs || new Symbol(0);\r\n            if(rhs.isComposite() && rhs.isLinear()) {\r\n                //try to isolate the square root\r\n                //container for the square roots\r\n                var sqrts = [];\r\n                //all else\r\n                var rem = [];\r\n                rhs.each(function (x) {\r\n                    x = x.clone();\r\n                    if(x.fname === 'sqrt' && x.contains(for_variable)) {\r\n                        sqrts.push(x);\r\n                    }\r\n                    else {\r\n                        rem.push(x);\r\n                    }\r\n                }, true);\r\n\r\n                if(sqrts.length === 1) {\r\n                    //move the remainder to the RHS\r\n                    lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2)));\r\n                    //square both sides\r\n                    rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\r\n                }\r\n            }\r\n            else {\r\n                rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\r\n            }\r\n\r\n            var c = 0, //a counter to see if we have all terms with the variable\r\n                    l = rhs.length;\r\n            //try to rewrite the whole thing\r\n            if(rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                rhs.distributeMultiplier();\r\n                var t = new Symbol(0);\r\n                //first bring all the terms containing the variable to the lhs\r\n                rhs.each(function (x) {\r\n                    if(x.contains(for_variable)) {\r\n                        c++;\r\n                        t = _.add(t, x.clone());\r\n                    }\r\n                    else\r\n                        lhs = _.subtract(lhs, x.clone());\r\n                });\r\n                rhs = t;\r\n\r\n                //if not all the terms contain the variable so it's in the form\r\n                //a*x^2+x\r\n                if(c !== l) {\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n                }\r\n                else {\r\n                    return [rhs, lhs];\r\n                }\r\n            }\r\n            else if(rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                if(rhs.multiplier.lessThan(0)) {\r\n                    rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\r\n                    lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\r\n                }\r\n                if(lhs.equals(0))\r\n                    return new Symbol(0);\r\n                else {\r\n                    var t = new Symbol(1);\r\n                    rhs.each(function (x) {\r\n                        if(x.contains(for_variable))\r\n                            t = _.multiply(t, x.clone());\r\n                        else\r\n                            lhs = _.divide(lhs, x.clone());\r\n                    });\r\n                    rhs = t;\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n\r\n                }\r\n            }\r\n            else if(!rhs.isLinear() && rhs.contains(for_variable)) {\r\n                var p = _.parse(rhs.power.clone().invert());\r\n                rhs = _.pow(rhs, p.clone());\r\n                lhs = _.pow(_.expand(lhs), p.clone());\r\n                return __.rewrite(rhs, lhs, for_variable);\r\n            }\r\n            else if(rhs.group === FN || rhs.group === S || rhs.group === PL) {\r\n                return [rhs, lhs];\r\n            }\r\n        },\r\n        sqrtSolve: function (symbol, v) {\r\n            var sqrts = new Symbol(0);\r\n            var rem = new Symbol(0);\r\n            if(symbol.isComposite()) {\r\n                symbol.each(function (x) {\r\n                    if(x.fname === 'sqrt' && x.contains(v)) {\r\n                        sqrts = _.add(sqrts, x.clone());\r\n                    }\r\n                    else {\r\n                        rem = _.add(rem, x.clone());\r\n                    }\r\n                });\r\n                //quick and dirty ATM\r\n                if(!sqrts.equals(0)) {\r\n                    var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2)))));\r\n                    //square both sides\r\n                    var solutions = solve(t, v);\r\n                    //test the points. The dumb way of getting the answers\r\n                    solutions = solutions.filter(function (e) {\r\n                        if(e.isImaginary())\r\n                            return e;\r\n                        var subs = {};\r\n                        subs[v] = e;\r\n                        var point = evaluate(symbol, subs);\r\n                        if(point.equals(0))\r\n                            return e;\r\n                    });\r\n                    return solutions;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     * \r\n     * @param {String[]|String|Equation} eqns\r\n     * @param {String} solve_for\r\n     * @param {Array} solutions\r\n     * @param {Number} depth\r\n     * @param {String|Equation} fn\r\n     * @returns {Array}\r\n     */\r\n    var solve = function (eqns, solve_for, solutions, depth, fn) {\r\n        depth = depth || 0;\r\n\r\n        if(depth++ > Settings.MAX_SOLVE_DEPTH) {\r\n            return solutions;\r\n        }\r\n\r\n        //make preparations if it's an Equation\r\n        if(eqns instanceof Equation) {\r\n            //if it's zero then we're done\r\n            if(eqns.isZero()) {\r\n                return [new Symbol(0)];\r\n            }\r\n            //if the lhs = x then we're done\r\n            if(eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\r\n                return [eqns.RHS];\r\n            }\r\n            //if the rhs = x then we're done\r\n            if(eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\r\n                return [eqns.LHS];\r\n            }\r\n        }\r\n\r\n        //unwrap the vector since what we want are the elements\r\n        if(eqns instanceof core.Vector)\r\n            eqns = eqns.elements;\r\n        solve_for = solve_for || 'x'; //assumes x by default\r\n        //If it's an array then solve it as a system of equations\r\n        if(isArray(eqns)) {\r\n            return __.solveSystem.apply(undefined, arguments);\r\n        }\r\n\r\n        // Parse out functions. Fix for issue #300\r\n        // eqns = core.Utils.evaluate(eqns);\r\n        solutions = solutions || [];\r\n        //mark existing solutions as not to have duplicates\r\n        var existing = {};\r\n\r\n        // Easy fail. If it's a rational function and the denominator is zero\r\n        // the we're done. Issue #555\r\n        var known = {};\r\n        known[solve_for] = 0;\r\n        if(isSymbol(eqns) && evaluate(eqns.getDenom(), known).equals(0) === true) {\r\n            return solutions;\r\n        }\r\n\r\n        // Is usued to add solutions to set. \r\n        // TODO: Set is now implemented and should be utilized\r\n        var add_to_result = function (r, has_trig) {\r\n            var r_is_symbol = isSymbol(r);\r\n            if(r === undefined || typeof r === 'number' && isNaN(r))\r\n                return;\r\n            if(isArray(r)) {\r\n                r.forEach(function (sol) {\r\n                    add_to_result(sol);\r\n                });\r\n            }\r\n            else {\r\n                if(r.valueOf() !== 'null') {\r\n                    // Call the pre-add function if defined. This could be useful for rounding\r\n                    if(typeof core.Settings.PRE_ADD_SOLUTION === 'function') {\r\n                        r = core.Settings.PRE_ADD_SOLUTION(r);\r\n                    }\r\n\r\n                    if(!r_is_symbol) {\r\n                        r = _.parse(r);\r\n                    }\r\n                    // try to convert the number to multiples of pi\r\n                    if(core.Settings.make_pi_conversions && has_trig) {\r\n                        var temp = _.divide(r.clone(), new Symbol(Math.PI)),\r\n                                m = temp.multiplier,\r\n                                a = Math.abs(m.num),\r\n                                b = Math.abs(m.den);\r\n                        if(a < 10 && b < 10)\r\n                            r = _.multiply(temp, new Symbol('pi'));\r\n                    }\r\n\r\n                    // And check if we get a number otherwise we might be throwing out symbolic solutions.\r\n                    var r_str = r.toString();\r\n\r\n                    if(!existing[r_str]) {\r\n                        solutions.push(r);\r\n                    }\r\n                    // Mark the answer as seen\r\n                    existing[r_str] = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        // Maybe we get lucky. Try the point at the function. If it works we have a point\r\n        // If not it failed\r\n        if(eqns.group === S && eqns.contains(solve_for)) {\r\n            try {\r\n                var o = {};\r\n                o[solve_for] = 0;\r\n                evaluate(fn, o, 'numer');\r\n                add_to_result(new Symbol(0));\r\n            }\r\n            catch(e) {\r\n                // Do nothing;\r\n            }\r\n\r\n            return solutions;\r\n        }\r\n        if(eqns.group === CB) {\r\n            // It suffices to solve for the numerator\r\n            var num = eqns.getNum();\r\n\r\n            if(num.group === CB) {\r\n                var sf = String(solve_for); //everything else belongs to the coeff\r\n                //get the denominator and make sure it doesn't have x since we don't know how to solve for those\r\n                num.each(function (x) {\r\n                    if(x.contains(sf))\r\n                        solve(x, solve_for, solutions, depth, eqns);\r\n                });\r\n\r\n                return solutions;\r\n            }\r\n\r\n            return solve(num, solve_for, solutions, depth, fn);\r\n        }\r\n\r\n        if(eqns.group === FN && eqns.fname === 'sqrt') {\r\n            eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\r\n        }\r\n        //pass in false to not expand equations such as (x+y)^5.\r\n        //It suffices to solve for the numerator since there's no value in the denominator which yields a zero for the function\r\n        var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(),\r\n                vars = core.Utils.variables(eq), //get a list of all the variables\r\n                numvars = vars.length;//how many variables are we dealing with\r\n\r\n        //it sufficient to solve (x+y) if eq is (x+y)^n since 0^n\r\n        if(core.Utils.isInt(eq.power) && eq.power > 0) {\r\n            eq = _.parse(eq).toLinear();\r\n        }\r\n\r\n        //if we're dealing with a single variable then we first check if it's a \r\n        //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \r\n        //Don't waste time\r\n        if(eq.group === S || eq.group === CB && eq.contains(solve_for)) {\r\n            return [new Symbol(0)];\r\n        }\r\n        //force to polynomial. We go through each and then we look at what it would \r\n        //take for its power to be an integer\r\n        //if the power is a fractional we divide by the fractional power\r\n        var fractionals = {},\r\n                cfact;\r\n\r\n        var correct_denom = function (symbol) {\r\n            symbol = _.expand(symbol, {\r\n                expand_denominator: true,\r\n                expand_functions: true\r\n            });\r\n            var original = symbol.clone(); //preserve the original\r\n\r\n            if(symbol.symbols) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n\r\n                    //get the denominator of the sub-symbol\r\n                    var den = sym.getDenom();\r\n\r\n                    if(!den.isConstant(true) && symbol.isComposite()) {\r\n                        var t = new Symbol(0);\r\n                        symbol.each(function (e) {\r\n                            t = _.add(t, _.multiply(e, den.clone()));\r\n                        });\r\n\r\n                        return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\r\n                    }\r\n\r\n                    var parts = explode(sym, solve_for);\r\n                    var is_sqrt = parts[1].fname === core.Settings.SQRT;\r\n                    var v = Symbol.unwrapSQRT(parts[1]);\r\n                    var p = v.power.clone();\r\n                    //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\r\n                    //this needs to be terminated if p = 1/2\r\n                    if(!isSymbol(p) && !p.equals(1 / 2)) {\r\n                        if(p.den.gt(1)) {\r\n                            if(is_sqrt) {\r\n                                symbol = _.subtract(symbol, sym.clone());\r\n                                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\r\n                                return correct_denom(symbol);\r\n                            }\r\n                            var c = fractionals[p.den];\r\n                            fractionals[p.den] = c ? c++ : 1;\r\n                        }\r\n                        else if(p.sign() === -1) {\r\n                            var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\r\n                            //unwrap the symbol's denoniator\r\n                            symbol.each(function (y, index) {\r\n                                if(y.contains(solve_for)) {\r\n                                    symbol.symbols[index] = _.multiply(y, factor.clone());\r\n                                }\r\n                            });\r\n                            fractionals = {};\r\n                            return correct_denom(_.parse(symbol));\r\n                        }\r\n                        else if(sym.group === PL) {\r\n                            var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\r\n                            if(min_p < 0) {\r\n                                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\r\n                                var corrected = new Symbol(0);\r\n                                original.each(function (x) {\r\n                                    corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\r\n                                }, true);\r\n                                return corrected;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return symbol;\r\n        };\r\n\r\n        //separate the equation\r\n        var separate = function (eq) {\r\n            var lhs = new Symbol(0),\r\n                    rhs = new Symbol(0);\r\n            eq.each(function (x) {\r\n                if(x.contains(solve_for, true))\r\n                    lhs = _.add(lhs, x.clone());\r\n                else\r\n                    rhs = _.subtract(rhs, x.clone());\r\n            });\r\n            return [lhs, rhs];\r\n        };\r\n\r\n        __.inverseFunctionSolve = function (name, lhs, rhs) {\r\n            //ax+b comes back as [a, x, ax, b];\r\n            var parts = explode(lhs.args[0], solve_for);\r\n            //check if x is by itself\r\n            var x = parts[1];\r\n            if(x.group === S) {\r\n                return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\r\n            }\r\n\r\n        };\r\n\r\n        //first remove any denominators\r\n        eq = correct_denom(eq);\r\n\r\n        if(eq.equals(0))\r\n            return [eq];\r\n        //correct fractionals. I can only handle one type right now\r\n        var fkeys = core.Utils.keys(fractionals);\r\n        if(fkeys.length === 1) {\r\n            //make a note of the factor\r\n            cfact = fkeys[0];\r\n            eq.each(function (x, index) {\r\n                if(x.contains(solve_for)) {\r\n                    var parts = explode(x, solve_for);\r\n                    var v = parts[1];\r\n                    var p = v.power;\r\n                    if(p.den.gt(1)) {\r\n                        v.power = p.multiply(new core.Frac(cfact));\r\n                        eq.symbols[index] = _.multiply(v, parts[0]);\r\n                    }\r\n                }\r\n            });\r\n            eq = _.parse(eq);\r\n        }\r\n\r\n        //try for nested sqrts as per issue #486\r\n        add_to_result(__.sqrtSolve(eq, solve_for));\r\n\r\n        //polynomial single variable\r\n        if(numvars === 1) {\r\n            if(eq.isPoly(true)) {\r\n                //try to factor and solve\r\n                var factors = new core.Algebra.Classes.Factors();\r\n\r\n                core.Algebra.Factor.factor(eq, factors);\r\n                //if the equation has more than one symbolic factor then solve those individually\r\n                if(factors.getNumberSymbolics() > 1) {\r\n                    for(var x in factors.factors) {\r\n                        add_to_result(solve(factors.factors[x], solve_for));\r\n                    }\r\n                }\r\n                else {\r\n                    var coeffs = core.Utils.getCoeffs(eq, solve_for),\r\n                            deg = coeffs.length - 1,\r\n                            was_calculated = false;\r\n                    if(vars[0] === solve_for) {\r\n                        //check to see if all the coefficients are constant\r\n                        if(checkAll(coeffs, function (x) {\r\n                            return x.group !== core.groups.N;\r\n                        })) {\r\n                            var roots = core.Algebra.proots(eq);\r\n                            //if all the roots are integers then return those\r\n                            if(checkAll(roots, function (x) {\r\n                                return !core.Utils.isInt(x);\r\n                            })) {\r\n                                //roots have been calculates\r\n                                was_calculated = true;\r\n                                roots.map(function (x) {\r\n                                    add_to_result(new Symbol(x));\r\n                                });\r\n                            }\r\n                        }\r\n\r\n                        if(!was_calculated) {\r\n                            eqns = _.parse(eqns);\r\n                            if(eqns instanceof core.Equation)\r\n                                eqns = eqns.toLHS();\r\n\r\n                            //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\r\n                            if(deg === 1)\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                            else if(deg === 2) {\r\n                                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\r\n                            }\r\n\r\n                            else if(deg === 3) {\r\n                                var solutions = []; //set to blank\r\n                                //first try to factor and solve\r\n                                var factored = core.Algebra.Factor.factor(eqns);\r\n\r\n                                //if it was successfully factored\r\n                                var solutions = [];\r\n                                if(solutions.length > 0)\r\n                                    add_to_result(solutions);\r\n                                else\r\n                                    add_to_result(__.cubic.apply(undefined, coeffs));\r\n                            }\r\n\r\n                            else {\r\n                                /*\r\n                                 var sym_roots = csolve(eq, solve_for); \r\n                                 if(sym_roots.length === 0)\r\n                                 sym_roots = divnconsolve(eq, solve_for);\r\n                                 if(sym_roots.length > 0) \r\n                                 add_to_result(sym_roots);\r\n                                 else\r\n                                 */\r\n                                _A.proots(eq).map(add_to_result);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    // Attempt Newton\r\n                    // Since it's not a polynomial then we'll try to look for a solution using Newton's method\r\n                    var has_trig = eq.hasTrig();\r\n                    // we get all the points where a possible zero might exist.\r\n                    var points1 = __.getPoints(eq, 0.1);\r\n                    var points2 = __.getPoints(eq, 0.05);\r\n                    var points3 = __.getPoints(eq, 0.01);\r\n                    var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function (a, b) {\r\n                        return a - b;\r\n                    });\r\n                    var i, point, solution;\r\n\r\n                    // Compile the function\r\n                    var f = build(eq.clone());\r\n\r\n                    // First try to eliminate some points using bisection\r\n                    var t_points = [];\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        // See if there's a solution at this point\r\n                        solution = __.bisection(point, f);\r\n\r\n                        // If there's no solution then add it to the array for further investigation\r\n                        if(typeof solution === 'undefined') {\r\n                            t_points.push(point);\r\n                            continue;\r\n                        }\r\n\r\n                        // Add the solution to the solution set\r\n                        add_to_result(solution, has_trig);\r\n                    }\r\n\r\n                    // Reset the points to the remaining points\r\n                    points = t_points;\r\n\r\n                    // Build the derivative and compile a function\r\n                    var d = _C.diff(eq.clone());\r\n                    var fp = build(d);\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        add_to_result(__.Newton(point, f, fp), has_trig);\r\n                    }\r\n                    solutions.sort();\r\n                }\r\n                catch(e) {\r\n                    console.log(e);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            //The idea here is to go through the equation and collect the coefficients\r\n            //place them in an array and call the quad or cubic function to get the results\r\n            if(!eq.hasFunc(solve_for) && eq.isComposite()) {\r\n                try {\r\n                    var factored = core.Algebra.Factor.factor(eq.clone());\r\n\r\n                    if(factored.group === CB) {\r\n                        factored.each(function (x) {\r\n                            add_to_result(solve(x, solve_for));\r\n                        });\r\n                    }\r\n                    else {\r\n                        var coeffs = core.Utils.getCoeffs(eq, solve_for);\r\n\r\n                        var l = coeffs.length,\r\n                                deg = l - 1; //the degree of the polynomial\r\n                        //get the denominator and make sure it doesn't have x\r\n\r\n                        //handle the problem based on the degree\r\n                        switch(deg) {\r\n                            case 0:\r\n                                var separated = separate(eq);\r\n                                var lhs = separated[0],\r\n                                        rhs = separated[1];\r\n                                if(lhs.group === core.groups.EX) {\r\n                                    add_to_result(_.parse(core.Utils.format(core.Settings.LOG + '(({0})/({2}))/' + core.Settings.LOG + '({1})', rhs, lhs.value, lhs.multiplier)));\r\n                                }\r\n                                break;\r\n                            case 1:\r\n                                //nothing to do but to return the quotient of the constant and the LT\r\n                                //e.g. 2*x-1\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                                break;\r\n                            case 2:\r\n                                add_to_result(__.quad.apply(undefined, coeffs));\r\n                                break;\r\n                            case 3:\r\n                                add_to_result(__.cubic.apply(undefined, coeffs));\r\n                                break;\r\n                            case 4:\r\n                                add_to_result(__.quartic.apply(undefined, coeffs));\r\n                                break;\r\n                            default:\r\n                                add_to_result(__.csolve(eq, solve_for));\r\n                                if(solutions.length === 0)\r\n                                    add_to_result(__.divideAndConquer(eq, solve_for));\r\n                        }\r\n\r\n                        if(solutions.length === 0) {\r\n                            //try factoring\r\n                            add_to_result(solve(factored, solve_for, solutions, depth));\r\n                        }\r\n                    }\r\n\r\n                }\r\n                catch(e) { /*something went wrong. EXITING*/\r\n                    ;\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    var rw = __.rewrite(eq, null, solve_for);\r\n                    var lhs = rw[0];\r\n                    var rhs = rw[1];\r\n                    if(lhs.group === FN) {\r\n                        if(lhs.fname === 'abs') {\r\n                            add_to_result([rhs.clone(), rhs.negate()]);\r\n                        }\r\n                        else if(lhs.fname === 'sin') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'cos') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'tan') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === core.Settings.LOG) {\r\n                            //ax+b comes back as [a, x, ax, b];\r\n                            var parts = explode(lhs.args[0], solve_for);\r\n                            //check if x is by itself\r\n                            var x = parts[1];\r\n                            if(x.group === S) {\r\n                                rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\r\n                                var eq = new Equation(x, rhs).toLHS();\r\n                                add_to_result(solve(eq, solve_for));\r\n                            }\r\n                        }\r\n                        else\r\n                            add_to_result(_.subtract(lhs, rhs));\r\n                    }\r\n                    else {\r\n                        var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\r\n\r\n                        if(neq.equals(eq))\r\n                            throw new Error('Stopping. No stop condition exists');\r\n                        add_to_result(solve(neq, solve_for));\r\n                    }\r\n                }\r\n                catch(error) {\r\n                    //Let's try this another way\r\n                    try {\r\n                        //1. if the symbol is in the form a*b*c*... then the solution is zero if \r\n                        //either a or b or c is zero.\r\n                        if(eq.group === CB)\r\n                            add_to_result(0);\r\n                        else if(eq.group === CP) {\r\n                            var separated = separate(eq);\r\n                            var lhs = separated[0],\r\n                                    rhs = separated[1];\r\n\r\n                            //reduce the equation\r\n                            if(lhs.group === core.groups.EX && lhs.value === solve_for) {\r\n                                //change the base of both sides\r\n                                var p = lhs.power.clone().invert();\r\n                                add_to_result(_.pow(rhs, p));\r\n                            }\r\n                        }\r\n                    }\r\n                    catch(error) {\r\n                        ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(cfact) {\r\n            solutions = solutions.map(function (x) {\r\n                return _.pow(x, new Symbol(cfact));\r\n            });\r\n        }\r\n\r\n        // Perform some cleanup but don't do it agains arrays, etc\r\n        // Check it actually evaluates to zero\r\n        if(isSymbol(eqns)) {\r\n            var knowns = {};\r\n            solutions = solutions.filter(function (x) {\r\n                try {\r\n                    knowns[solve_for] = x;\r\n                    var zero = Number(evaluate(eqns, knowns));\r\n\r\n                    // Allow symbolic answers\r\n                    if(isNaN(zero)) {\r\n                        return true;\r\n                    }\r\n                    return true;\r\n                }\r\n                catch(e) {\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n\r\n        return solutions;\r\n    };\r\n\r\n    //Register the functions for external use\r\n    nerdamer.register([\r\n        {\r\n            name: 'solveEquations',\r\n            parent: 'nerdamer',\r\n            numargs: -1,\r\n            visible: true,\r\n            build: function () {\r\n                return solve; //comment out to return a vector\r\n                /*\r\n                 return function() {\r\n                 return core.Utils.convertToVector(solve.apply(null, arguments));\r\n                 };\r\n                 */\r\n            }\r\n        },\r\n        {\r\n            name: 'solve',\r\n            parent: 'Solve',\r\n            numargs: 2,\r\n            visible: true,\r\n            build: function () {\r\n                return core.Solve.solve;\r\n            }\r\n        },\r\n        {\r\n            name: 'setEquation',\r\n            parent: 'Solve',\r\n            visible: true,\r\n            build: function () {\r\n                return setEq;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.api();\r\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZhbmlsbGEtaW50ZWdyYXRpb24tMmQvLi9ub2RlX21vZHVsZXMvbmVyZGFtZXIvU29sdmUuanM/NjA2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBBdXRob3IgOiBNYXJ0aW4gRG9ua1xyXG4gKiBXZWJzaXRlIDogaHR0cDovL3d3dy5uZXJkYW1lci5jb21cclxuICogRW1haWwgOiBtYXJ0aW4uci5kb25rQGdtYWlsLmNvbVxyXG4gKiBTb3VyY2UgOiBodHRwczovL2dpdGh1Yi5jb20vamlnZ3pzb24vbmVyZGFtZXJcclxuICovXHJcbi8qIGdsb2JhbCBtb2R1bGUgKi9cclxuXHJcbmlmKCh0eXBlb2YgbW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHZhciBuZXJkYW1lciA9IHJlcXVpcmUoJy4vbmVyZGFtZXIuY29yZS5qcycpO1xyXG4gICAgcmVxdWlyZSgnLi9DYWxjdWx1cy5qcycpO1xyXG4gICAgcmVxdWlyZSgnLi9BbGdlYnJhLmpzJyk7XHJcbn1cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICAvL2hhbmRsZSBpbXBvcnRzXHJcbiAgICB2YXIgY29yZSA9IG5lcmRhbWVyLmdldENvcmUoKSxcclxuICAgICAgICAgICAgXyA9IGNvcmUuUEFSU0VSLFxyXG4gICAgICAgICAgICBfQSA9IGNvcmUuQWxnZWJyYSxcclxuICAgICAgICAgICAgX0MgPSBjb3JlLkNhbGN1bHVzLFxyXG4gICAgICAgICAgICBleHBsb2RlID0gX0MuaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyxcclxuICAgICAgICAgICAgZXZhbHVhdGUgPSBjb3JlLlV0aWxzLmV2YWx1YXRlLFxyXG4gICAgICAgICAgICByZW1vdmUgPSBjb3JlLlV0aWxzLnJlbW92ZSxcclxuICAgICAgICAgICAgZm9ybWF0ID0gY29yZS5VdGlscy5mb3JtYXQsXHJcbiAgICAgICAgICAgIGJ1aWxkID0gY29yZS5VdGlscy5idWlsZCxcclxuICAgICAgICAgICAga25vd25WYXJpYWJsZSA9IGNvcmUuVXRpbHMua25vd25WYXJpYWJsZSxcclxuICAgICAgICAgICAgU3ltYm9sID0gY29yZS5TeW1ib2wsXHJcbiAgICAgICAgICAgIGlzU3ltYm9sID0gY29yZS5VdGlscy5pc1N5bWJvbCxcclxuICAgICAgICAgICAgdmFyaWFibGVzID0gY29yZS5VdGlscy52YXJpYWJsZXMsXHJcbiAgICAgICAgICAgIFMgPSBjb3JlLmdyb3Vwcy5TLFxyXG4gICAgICAgICAgICBQTCA9IGNvcmUuZ3JvdXBzLlBMLFxyXG4gICAgICAgICAgICBDQiA9IGNvcmUuZ3JvdXBzLkNCLFxyXG4gICAgICAgICAgICBDUCA9IGNvcmUuZ3JvdXBzLkNQLFxyXG4gICAgICAgICAgICBGTiA9IGNvcmUuZ3JvdXBzLkZOLFxyXG4gICAgICAgICAgICBTZXR0aW5ncyA9IGNvcmUuU2V0dGluZ3MsXHJcbiAgICAgICAgICAgIHJhbmdlID0gY29yZS5VdGlscy5yYW5nZSxcclxuICAgICAgICAgICAgaXNBcnJheSA9IGNvcmUuVXRpbHMuaXNBcnJheTtcclxuXHJcblxyXG4gICAgLy8gVGhlIHNlYXJjaCByYWRpdXMgZm9yIHRoZSByb290c1xyXG4gICAgY29yZS5TZXR0aW5ncy5TT0xWRV9SQURJVVMgPSAxMDAwO1xyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIHRvIGZpc2ggZm9yIG9uIGVhY2ggc2lkZSBvZiB0aGUgemVyb1xyXG4gICAgY29yZS5TZXR0aW5ncy5ST09UU19QRVJfU0lERSA9IDEwO1xyXG4gICAgLy8gQ292ZXJ0IHRoZSBudW1iZXIgdG8gbXVsdGlwbGVzIG9mIHBpIGlmIHBvc3NpYmxlXHJcbiAgICBjb3JlLlNldHRpbmdzLm1ha2VfcGlfY29udmVyc2lvbnMgPSBmYWxzZTtcclxuICAgIC8vIFRoZSBzdGVwIHNpemVcclxuICAgIGNvcmUuU2V0dGluZ3MuU1RFUF9TSVpFID0gMC4xO1xyXG4gICAgLy8gVGhlIGVwc2lsb24gc2l6ZVxyXG4gICAgY29yZS5TZXR0aW5ncy5FUFNJTE9OID0gMWUtMTM7XHJcbiAgICAvL3RoZSBtYXhpbXVtIGl0ZXJhdGlvbnMgZm9yIE5ld3RvbidzIG1ldGhvZFxyXG4gICAgY29yZS5TZXR0aW5ncy5NQVhfTkVXVE9OX0lURVJBVElPTlMgPSAyMDA7XHJcbiAgICAvL3RoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lIG5vbi1saW5lYXIgc29sdmUgdHJpZXMgYW5vdGhlciBqdW1wIHBvaW50XHJcbiAgICBjb3JlLlNldHRpbmdzLk1BWF9OT05fTElORUFSX1RSSUVTID0gMTI7XHJcbiAgICAvL3RoZSBhbW91bnQgb2YgaXRlcmF0aW9ucyB0aGUgZnVuY3Rpb24gd2lsbCBzdGFydCB0byBqdW1wIGF0XHJcbiAgICBjb3JlLlNldHRpbmdzLk5PTl9MSU5FQVJfSlVNUF9BVCA9IDUwO1xyXG4gICAgLy90aGUgc2l6ZSBvZiB0aGUganVtcFxyXG4gICAgY29yZS5TZXR0aW5ncy5OT05fTElORUFSX0pVTVBfU0laRSA9IDEwMDtcclxuICAgIC8vdGhlIG9yaWdpbmFsIHN0YXJ0aW5nIHBvaW50IGZvciBub25saW5lYXIgc29sdmluZ1xyXG4gICAgY29yZS5TZXR0aW5ncy5OT05fTElORUFSX1NUQVJUID0gMC4wMTtcclxuICAgIC8vV2hlbiBwb2ludHMgYXJlIGdlbmVyYXRlZCBhcyBzdGFydGluZyBwb2ludHMgZm9yIE5ld3RvbidzIG1ldGhvZCwgdGhleSBhcmUgc2xpY2VkIGludG8gc21hbGxcclxuICAgIC8vc2xpY2VzIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgY29udmVyZ2VuY2Ugb24gdGhlIHJpZ2h0IHBvaW50LiBUaGlzIGRlZmluZXMgdGhlIFxyXG4gICAgLy9zaXplIG9mIHRoZSBzbGljZVxyXG4gICAgY29yZS5TZXR0aW5ncy5ORVdUT05fU0xJQ0VTID0gMjAwO1xyXG4gICAgLy9UaGUgZXBzaWxvbiB1c2VkIGluIE5ld3RvbidzIGl0ZXJhdGlvblxyXG4gICAgY29yZS5TZXR0aW5ncy5ORVdUT05fRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OICogMjtcclxuICAgIC8vVGhlIGRpc3RhbmNlIGluIHdoaWNoIHR3byBzb2x1dGlvbnMgYXJlIGRlZW1lZCB0aGUgc2FtZVxyXG4gICAgY29yZS5TZXR0aW5ncy5TT0xVVElPTl9QUk9YSU1JVFkgPSAxZS0xNDtcclxuICAgIC8vSW5kaWNhdGUgd2hldGVyIHRvIGZpbHRlciB0aGUgc29sdXRpb25zIGFyZSBub3RcclxuICAgIGNvcmUuU2V0dGluZ3MuRklMVEVSX1NPTFVUSU9OUyA9IHRydWU7XHJcbiAgICAvL3RoZSBtYXhpbXVtIG51bWJlciBvZiByZWN1cnNpdmUgY2FsbHNcclxuICAgIGNvcmUuU2V0dGluZ3MuTUFYX1NPTFZFX0RFUFRIID0gMTA7XHJcbiAgICAvLyBUaGUgdG9sZXJhbmNlIHRoYXQncyBjb25zaWRlcmVkIGNsb3NlIGVub3VnaCB0byB6ZXJvXHJcbiAgICBjb3JlLlNldHRpbmdzLlpFUk9fRVBTSUxPTiA9IDFlLTk7XHJcbiAgICAvLyBUaGUgbWF4aW11bSBpdGVyYXRpb24gZm9yIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGluY2FzZSBvZiBzb21lIEpTIHN0cmFuZ2VuZXNzXHJcbiAgICBjb3JlLlNldHRpbmdzLk1BWF9CSVNFQ1RJT05fSVRFUiA9IDIwMDA7XHJcbiAgICAvLyBUaGUgdG9sZXJhbmNlIGZvciB0aGUgYmlzZWN0aW9uIG1ldGhvZFxyXG4gICAgY29yZS5TZXR0aW5ncy5CSV9TRUNUSU9OX0VQU0lMT04gPSAxZS0xMjtcclxuXHJcblxyXG4gICAgY29yZS5TeW1ib2wucHJvdG90eXBlLmhhc1RyaWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnNGdW5jdGlvbihbJ2NvcycsICdzaW4nLCAndGFuJywgJ2NvdCcsICdjc2MnLCAnc2VjJ10pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb3JlLlN5bWJvbC5wcm90b3R5cGUuaGFzTmVnYXRpdmVUZXJtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZih0aGlzLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN5bSA9IHRoaXMuc3ltYm9sc1t4XTtcclxuICAgICAgICAgICAgICAgIGlmKHN5bS5ncm91cCA9PT0gUEwgJiYgc3ltLmhhc05lZ2F0aXZlVGVybXMoKSB8fCB0aGlzLnN5bWJvbHNbeF0ucG93ZXIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKiBuZXJkYW1lciB2ZXJzaW9uIDAuNy54IGFuZCB1cCBhbGxvd3MgdXMgdG8gbWFrZSBiZXR0ZXIgdXNlIG9mIG9wZXJhdG9yIG92ZXJsb2FkaW5nXHJcbiAgICAgKiBBcyBzdWNoIHdlIGNhbiBoYXZlIHRoaXMgZGF0YSB0eXBlIGJlIHN1cHBvcnRlZCBjb21wbGV0ZWx5IG91dHNpZGUgb2YgdGhlIGNvcmUuXHJcbiAgICAgKiBUaGlzIGlzIGFuIGVxdWF0aW9uIHRoYXQgaGFzIGEgbGVmdCBoYW5kIHNpZGUgYW5kIGEgcmlnaHQgaGFuZCBzaWRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEVxdWF0aW9uKGxocywgcmhzKSB7XHJcbiAgICAgICAgaWYocmhzLmlzQ29uc3RhbnQoKSAmJiBsaHMuaXNDb25zdGFudCgpICYmICFsaHMuZXF1YWxzKHJocykgfHwgbGhzLmVxdWFscyhjb3JlLlNldHRpbmdzLklNQUdJTkFSWSkgfHwgcmhzLmVxdWFscyhjb3JlLlNldHRpbmdzLklNQUdJTkFSWSkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLmV4Y2VwdGlvbnMuTmVyZGFtZXJWYWx1ZUVycm9yKGxocy50b1N0cmluZygpICsgJyBkb2VzIG5vdCBlcXVhbCAnICsgcmhzLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHRoaXMuTEhTID0gbGhzOyAvL2xlZnQgaGFuZCBzaWRlXHJcbiAgICAgICAgdGhpcy5SSFMgPSByaHM7IC8vcmlnaHQgYW5kIHNpZGVcclxuICAgIH1cclxuICAgIDtcclxuXHJcbiAgICAvL1VUSUxTICMjISFcclxuXHJcbiAgICBFcXVhdGlvbi5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTEhTLnRvU3RyaW5nKCkgKyAnPScgKyB0aGlzLlJIUy50b1N0cmluZygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5MSFMudGV4dChvcHRpb24pICsgJz0nICsgdGhpcy5SSFMudGV4dChvcHRpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9MSFM6IGZ1bmN0aW9uIChleHBhbmQpIHtcclxuICAgICAgICAgICAgZXhwYW5kID0gdHlwZW9mIGV4cGFuZCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBlcW47XHJcbiAgICAgICAgICAgIGlmKCFleHBhbmQpIHtcclxuICAgICAgICAgICAgICAgIGVxbiA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVxbiA9IHRoaXMucmVtb3ZlRGVub20oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYSA9IGVxbi5MSFM7XHJcbiAgICAgICAgICAgIHZhciBiID0gZXFuLlJIUztcclxuICAgICAgICAgICAgaWYoYS5pc0NvbnN0YW50KHRydWUpICYmICFiLmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFN3YXAgdGhlbSB0byBhdm9pZCBjb25mdXNpbmcgcGFyc2VyIGFuZCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wXHJcbiAgICAgICAgICAgICAgICBbYSwgYl0gPSBbYiwgYV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIF90ID0gXy5zdWJ0cmFjdChhLCBiKTtcclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9IGV4cGFuZCA/IF8uZXhwYW5kKF90KSA6IF90O1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVtb3ZlRGVub206IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLkxIUy5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgYiA9IHRoaXMuUkhTLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBkZW5vbWluYXRvciBvbiBib3RoIHNpZGVzXHJcbiAgICAgICAgICAgIHZhciBkZW4gPSBfLm11bHRpcGx5KGEuZ2V0RGVub20oKSwgYi5nZXREZW5vbSgpKTtcclxuICAgICAgICAgICAgYSA9IF8uZXhwYW5kKF8ubXVsdGlwbHkoYSwgZGVuLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgYiA9IF8uZXhwYW5kKF8ubXVsdGlwbHkoYiwgZGVuKSk7XHJcbiAgICAgICAgICAgIC8vc3dhcCB0aGUgZ3JvdXBzXHJcbiAgICAgICAgICAgIGlmKGIuZ3JvdXAgPT09IENQICYmIGIuZ3JvdXAgIT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGE7XHJcbiAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgIGIgPSB0OyAvL3N3YXBcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9zY2FuIHRvIGVsaW1pbmF0ZSBkZW5vbWluYXRvcnNcclxuICAgICAgICAgICAgaWYoYS5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFN5bWJvbChhLm11bHRpcGxpZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSSFMgPSBiLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBhLmVhY2goZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih5LnBvd2VyLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSSFMgPSBfLmRpdmlkZShuZXdSSFMsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkodCwgeSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGEgPSB0O1xyXG4gICAgICAgICAgICAgICAgYiA9IG5ld1JIUztcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihhLmdyb3VwID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgLy90aGUgbG9naWM6IGxvb3AgdGhyb3VnaCBlYWNoIGFuZCBpZiBpdCBoYXMgYSBkZW5vbWluYXRvciB0aGVuIG11bHRpcGx5IGl0IG91dCBvbiBib3RoIGVuZHNcclxuICAgICAgICAgICAgICAgIC8vYW5kIHRoZW4gc3RhcnQgb3ZlclxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIGEuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBhLnN5bWJvbHNbeF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHkgaW4gc3ltLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW0yID0gc3ltLnN5bWJvbHNbeV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0yLnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcXVhdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZXhwYW5kKF8ubXVsdGlwbHkoc3ltMi5jbG9uZSgpLnRvTGluZWFyKCksIGEpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZXhwYW5kKF8ubXVsdGlwbHkoc3ltMi5jbG9uZSgpLnRvTGluZWFyKCksIGIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcXVhdGlvbihhLCBiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXF1YXRpb24odGhpcy5MSFMuY2xvbmUoKSwgdGhpcy5SSFMuY2xvbmUoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWI6IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgY2xvbmUuTEhTID0gY2xvbmUuTEhTLnN1Yih4LmNsb25lKCksIHkuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIGNsb25lLlJIUyA9IGNsb25lLlJIUy5zdWIoeC5jbG9uZSgpLCB5LmNsb25lKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1plcm86IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuZXZhbHVhdGUodGhpcy50b0xIUygpKS5lcXVhbHMoMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXRleDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuTEhTLmxhdGV4KG9wdGlvbiksIHRoaXMuUkhTLmxhdGV4KG9wdGlvbildLmpvaW4oJz0nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy9vdmVyd3JpdGUgdGhlIGVxdWFscyBmdW5jdGlvblxyXG4gICAgXy5lcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBuZXcgRXF1YXRpb24oYSwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEV4dGVuZCBzaW1wbGlmeVxyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2ltcGxpZnkgPSBfLmZ1bmN0aW9ucy5zaW1wbGlmeVswXTtcclxuICAgICAgICBfLmZ1bmN0aW9ucy5zaW1wbGlmeVswXSA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoc3ltYm9sIGluc3RhbmNlb2YgRXF1YXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5MSFMgPSBzaW1wbGlmeShzeW1ib2wuTEhTKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5SSFMgPSBzaW1wbGlmeShzeW1ib2wuUkhTKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSnVzdCBjYWxsIHRoZSBvcmlnaW5hbCBzaW1wbGlmeVxyXG4gICAgICAgICAgICByZXR1cm4gc2ltcGxpZnkoc3ltYm9sKTtcclxuICAgICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdHdvIGV4cHJlc3Npb25zIGVxdWFsXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn1cclxuICAgICAqL1xyXG4gICAgY29yZS5FeHByZXNzaW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgaWYoc3ltYm9sIGluc3RhbmNlb2YgY29yZS5FeHByZXNzaW9uKVxyXG4gICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuc3ltYm9sOyAvL2dyYWIgdGhlIHN5bWJvbCBpZiBpdCdzIGFuIGV4cHJlc3Npb25cclxuICAgICAgICB2YXIgZXEgPSBuZXcgRXF1YXRpb24odGhpcy5zeW1ib2wsIHN5bWJvbCk7XHJcbiAgICAgICAgcmV0dXJuIGVxO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb3JlLkV4cHJlc3Npb24ucHJvdG90eXBlLnNvbHZlRm9yID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgc3ltYm9sO1xyXG4gICAgICAgIGlmKHRoaXMuc3ltYm9sIGluc3RhbmNlb2YgRXF1YXRpb24pIHtcclxuICAgICAgICAgICAgLy9leGl0IHJpZ2h0IGF3YXkgaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBhbnN3ZXJcclxuICAgICAgICAgICAgLy9jaGVjayB0aGUgTEhTXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sLkxIUy5pc0NvbnN0YW50KCkgJiYgdGhpcy5zeW1ib2wuUkhTLmVxdWFscyh4KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29yZS5FeHByZXNzaW9uKHRoaXMuc3ltYm9sLkxIUyk7XHJcblxyXG4gICAgICAgICAgICAvL2NoZWNrIHRoZSBSSFNcclxuICAgICAgICAgICAgaWYodGhpcy5zeW1ib2wuUkhTLmlzQ29uc3RhbnQoKSAmJiB0aGlzLnN5bWJvbC5MSFMuZXF1YWxzKHgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLkV4cHJlc3Npb24odGhpcy5zeW1ib2wuUkhTKTtcclxuXHJcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGp1c3QgYnJpbmcgaXQgdG8gTEhTXHJcbiAgICAgICAgICAgIHN5bWJvbCA9IHRoaXMuc3ltYm9sLnRvTEhTKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzeW1ib2wgPSB0aGlzLnN5bWJvbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzb2x2ZShzeW1ib2wsIHgpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuRXhwcmVzc2lvbih4KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgY29yZS5FeHByZXNzaW9uLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYodGhpcy5zeW1ib2wgaW5zdGFuY2VvZiBFcXVhdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSB0aGlzLnN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBjbG9uZS5SSFMgPSBfLmV4cGFuZChjbG9uZS5SSFMpO1xyXG4gICAgICAgICAgICBjbG9uZS5MSFMgPSBfLmV4cGFuZChjbG9uZS5MSFMpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuRXhwcmVzc2lvbihjbG9uZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgY29yZS5FeHByZXNzaW9uKF8uZXhwYW5kKHRoaXMuc3ltYm9sKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvcmUuRXhwcmVzc2lvbi5wcm90b3R5cGUudmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKHRoaXMuc3ltYm9sIGluc3RhbmNlb2YgRXF1YXRpb24pXHJcbiAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmFycmF5VW5pcXVlKHZhcmlhYmxlcyh0aGlzLnN5bWJvbC5MSFMpLmNvbmNhdCh2YXJpYWJsZXModGhpcy5zeW1ib2wuUkhTKSkpO1xyXG4gICAgICAgIHJldHVybiB2YXJpYWJsZXModGhpcy5zeW1ib2wpO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuICAgIHZhciBzZXRFcSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uZXF1YWxzKGEsIGIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL2xpbmsgdGhlIEVxdWF0aW9uIGNsYXNzIGJhY2sgdG8gdGhlIGNvcmVcclxuICAgIGNvcmUuRXF1YXRpb24gPSBFcXVhdGlvbjtcclxuXHJcbiAgICAvL0xvb3BzIHRocm91Z2ggYW4gYXJyYXkgYW5kIGF0dGVtcHRzIHRvIGZhaWxzIGEgdGVzdC4gU3RvcHMgaWYgbWFuYWdlcyB0byBmYWlsLlxyXG4gICAgdmFyIGNoZWNrQWxsID0gY29yZS5VdGlscy5jaGVja0FsbCA9IGZ1bmN0aW9uIChhcmdzLCB0ZXN0KSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmKHRlc3QoYXJnc1tpXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vdmVyc2lvbiBzb2x2ZVxyXG4gICAgdmFyIF9fID0gY29yZS5Tb2x2ZSA9IHtcclxuICAgICAgICB2ZXJzaW9uOiAnMi4wLjMnLFxyXG4gICAgICAgIHNvbHV0aW9uczogW10sXHJcbiAgICAgICAgc29sdmU6IGZ1bmN0aW9uIChlcSwgdmFyaWFibGUpIHtcclxuICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gc29sdmUoZXEsIFN0cmluZyh2YXJpYWJsZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuVmVjdG9yKHNvbHV0aW9uKTtcclxuICAgICAgICAgICAgLy9yZXR1cm4gbmV3IGNvcmUuVmVjdG9yKHNvbHZlKGVxLnRvU3RyaW5nKCksIHZhcmlhYmxlID8gdmFyaWFibGUudG9TdHJpbmcoKSA6IHZhcmlhYmxlKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcmluZ3MgdGhlIGVxdWF0aW9uIHRvIExIUy4gQSBzdHJpbmcgY2FuIGJlIHN1cHBsaWVkIHdoaWNoIHdpbGwgYmUgY29udmVydGVkIHRvIGFuIEVxdWF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtFcXVhdGlvbnxTdHJpbmd9IGVxblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9MSFM6IGZ1bmN0aW9uIChlcW4sIGV4cGFuZCkge1xyXG4gICAgICAgICAgICBpZihpc1N5bWJvbChlcW4pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxbjtcclxuICAgICAgICAgICAgLy9JZiBpdCdzIGFuIGVxdWF0aW9uIHRoZW4gY2FsbCBpdHMgdG9MSFMgZnVuY3Rpb24gaW5zdGVhZFxyXG4gICAgICAgICAgICBpZighKGVxbiBpbnN0YW5jZW9mIEVxdWF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVzID0gZXFuLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgZmFsc2V5IHZhbHVlcyB0byB6ZXJvXHJcbiAgICAgICAgICAgICAgICBlc1sxXSA9IGVzWzFdIHx8ICcwJztcclxuICAgICAgICAgICAgICAgIGVxbiA9IG5ldyBFcXVhdGlvbihfLnBhcnNlKGVzWzBdKSwgXy5wYXJzZShlc1sxXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlcW4udG9MSFMoZXhwYW5kKTtcclxuICAgICAgICB9LFxyXG4vLyAgICAgICAgZ2V0U3lzdGVtVmFyaWFibGVzOiBmdW5jdGlvbihlcW5zKSB7XHJcbi8vICAgICAgICAgICAgdmFycyA9IHZhcmlhYmxlcyhlcW5zWzBdLCBudWxsLCBudWxsLCB0cnVlKTtcclxuLy9cclxuLy8gICAgICAgICAgICAvL2dldCBhbGwgdmFyaWFibGVzXHJcbi8vICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGw9ZXFucy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbi8vICAgICAgICAgICAgICAgIHZhcnMgPSB2YXJzLmNvbmNhdCh2YXJpYWJsZXMoZXFuc1tpXSkpO1xyXG4vLyAgICAgICAgICAgIC8vcmVtb3ZlIGR1cGxpY2F0ZXNcclxuLy8gICAgICAgICAgICB2YXJzID0gY29yZS5VdGlscy5hcnJheVVuaXF1ZSh2YXJzKS5zb3J0KCk7XHJcbi8vICAgICAgICAgICAgXHJcbi8vICAgICAgICAgICAgLy9kb25lXHJcbi8vICAgICAgICAgICAgcmV0dXJuIHZhcnM7XHJcbi8vICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNvbHZlIGEgc2V0IG9mIGNpcmNsZSBlcXVhdGlvbnMuIFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sW119IGVxbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc29sdmVDaXJjbGU6IGZ1bmN0aW9uIChlcW5zLCB2YXJzKSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhcmlhYmxlcyB0byBzeW1ib2xzXHJcbiAgICAgICAgICAgIHZhciBzdmFycyA9IHZhcnMubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZSh4KVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkZWcgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzb2x1dGlvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGVncmVlIGZvciB0aGUgZXF1YXRpb25zXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlcW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHN2YXJzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKE51bWJlcihjb3JlLkFsZ2VicmEuZGVncmVlKGVxbnNbaV0sIHN2YXJzW2pdKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHRvdGFsIGRlZ3JlZVxyXG4gICAgICAgICAgICAgICAgZC5wdXNoKGNvcmUuVXRpbHMuYXJyYXlTdW0oZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgZGVnLnB1c2goZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBhID0gZXFuc1swXTtcclxuICAgICAgICAgICAgdmFyIGIgPSBlcW5zWzFdO1xyXG5cclxuICAgICAgICAgICAgaWYoZGVnWzBdWzJdID4gZGVnWzFdWzJdKSB7XHJcbiAgICAgICAgICAgICAgICBbYiwgYV0gPSBbYSwgYl07XHJcbiAgICAgICAgICAgICAgICBbZGVnWzFdLCBkZWdbMF1dID0gW2RlZ1swXSwgZGVnWzFdXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT25seSBzb2x2ZSBpdCdzIHRydWx5IGEgY2lyY2xlXHJcbiAgICAgICAgICAgIGlmKGRlZ1swXVswXSA9PT0gMSAmJiBkZWdbMF1bMl0gPT09IDIgJiYgZGVnWzFdWzBdID09PSAyICYmIGRlZ1sxXVsyXSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGNsYXJpdHkgd2UnbGwgcmVmZXIgdG8gdGhlIHZhcmlhYmxlcyBhcyB4IGFuZCB5XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHZhcnNbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHZhcnNbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIG5vdyBnZXQgdGhlIHR3byBwb2ludHMgZm9yIHlcclxuICAgICAgICAgICAgICAgIHZhciB5X3BvaW50cyA9IHNvbHZlKF8ucGFyc2UoYiwga25vd25WYXJpYWJsZSh4LCBzb2x2ZShfLnBhcnNlKGEpLCB4KVswXSkpLCB5KS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugbm93IGtub3cgeSB3ZSBjYW4gZ2V0IHRoZSB0d28geCBwb2ludHMgZnJvbSB0aGUgZmlyc3QgZXF1YXRpb25cclxuICAgICAgICAgICAgICAgIHZhciB4X3BvaW50cyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBzb2x2ZShfLnBhcnNlKGEsIGtub3duVmFyaWFibGUoeSwgeV9wb2ludHNbMF0pKSlbMF0udG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih5X3BvaW50c1sxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhfcG9pbnRzLnB1c2goc29sdmUoXy5wYXJzZShhLCBrbm93blZhcmlhYmxlKHksIHlfcG9pbnRzWzFdKSkpWzBdLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlNPTFVUSU9OU19BU19PQkpFQ1QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zW3hdID0geF9wb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zW3ldID0geV9wb2ludHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB5X3BvaW50cy51bnNoaWZ0KHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhfcG9pbnRzLnVuc2hpZnQoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gW3hfcG9pbnRzLCB5X3BvaW50c107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTb2x2ZSBhIHN5c3RlbSBvZiBub25saW5lYXIgZXF1YXRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2xbXX0gZXFucyBUaGUgYXJyYXkgb2YgZXF1YXRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRyaWVzIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0cmllc1xyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnRpbmcgcG9pbnQgd2hlcmUgdG8gc3RhcnQgbG9va2luZyBmb3Igc29sdXRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNvbHZlTm9uTGluZWFyU3lzdGVtOiBmdW5jdGlvbiAoZXFucywgdHJpZXMsIHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGlmKHRyaWVzIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdOy8vY2FuJ3QgZmluZCBhIHNvbHV0aW9uXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdHlwZW9mIHN0YXJ0ID09PSAndW5kZWZpbmVkJyA/IGNvcmUuU2V0dGluZ3MuTk9OX0xJTkVBUl9TVEFSVCA6IHN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgLy90aGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXMgdG8ganVtcFxyXG4gICAgICAgICAgICB2YXIgbWF4X3RyaWVzID0gY29yZS5TZXR0aW5ncy5NQVhfTk9OX0xJTkVBUl9UUklFUztcclxuXHJcbiAgICAgICAgICAgIC8vaGFsZndheSB0aHJvdWdoIHRoZSB0cmllc1xyXG4gICAgICAgICAgICB2YXIgaGFsZndheSA9IE1hdGguZmxvb3IobWF4X3RyaWVzIC8gMik7XHJcblxyXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgdGhlIG51bWJlciBvZiB0cmllcyB0byAxMCBpZiBub3Qgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIHRyaWVzID0gdHlwZW9mIHRyaWVzID09PSAndW5kZWZpbmVkJyA/IG1heF90cmllcyA6IHRyaWVzO1xyXG5cclxuICAgICAgICAgICAgLy9hIHBvaW50IGF0IHdoaWNoIHdlIGNoZWNrIHRvIHNlZSBpZiB3ZSdyZSBjb252ZXJnaW5nLiBCeSBpbnNwZWN0aW9uIGl0IHNlZW1zIHRoYXQgd2UgY2FuXHJcbiAgICAgICAgICAgIC8vdXNlIGFyb3VuZCAyMCBpdGVyYXRpb25zIHRvIHNlZSBpZiB3ZSdyZSBjb252ZXJnaW5nLiBJZiBub3QgdGhlbiB3ZSByZXRyeSBhIGp1bXAgb2YgeFxyXG4gICAgICAgICAgICB2YXIganVtcF9hdCA9IGNvcmUuU2V0dGluZ3MuTk9OX0xJTkVBUl9KVU1QX0FUO1xyXG5cclxuICAgICAgICAgICAgLy93ZSBqdW1wIGJ5IHRoaXMgbWFueSBwb2ludHMgYXQgZWFjaCBwaXZvdCBwb2ludFxyXG4gICAgICAgICAgICB2YXIganVtcCA9IGNvcmUuU2V0dGluZ3MuTk9OX0xJTkVBUl9KVU1QX1NJWkU7XHJcblxyXG4gICAgICAgICAgICAvL3VzZWQgdG8gY2hlY2sgaWYgd2UgYWN0dWFsbHkgZm91bmQgYSBzb2x1dGlvbiBvciBpZiB3ZSBnYXZlIHVwLiBBc3N1bWUgd2Ugd2lsbCBmaW5kIGEgc29sdXRpb24uXHJcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB2YXIgY3JlYXRlX3N1YnMgPSBmdW5jdGlvbiAodmFycywgbWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFycy5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKG1hdHJpeC5nZXQoaSwgMCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgdmFycyA9IGNvcmUuVXRpbHMuYXJyYXlHZXRWYXJpYWJsZXMoZXFucyk7XHJcbiAgICAgICAgICAgIHZhciBqYWNvYmlhbiA9IGNvcmUuTWF0cml4LmphY29iaWFuKGVxbnMsIHZhcnMsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGQoeCwgdmFycyk7XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1heF9pdGVyID0gY29yZS5TZXR0aW5ncy5NQVhfTkVXVE9OX0lURVJBVElPTlM7XHJcbiAgICAgICAgICAgIHZhciBvLCB5LCBpdGVycywgeG4xLCBub3JtLCBsbm9ybSwgeG4sIGQ7XHJcblxyXG4gICAgICAgICAgICB2YXIgZl9lcW5zID0gZXFucy5tYXAoZnVuY3Rpb24gKGVxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGQoZXEsIHZhcnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBKID0gamFjb2JpYW4ubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGQoZSwgdmFycyk7XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAvL2luaXRpYWwgdmFsdWVzXHJcbiAgICAgICAgICAgIHhuMSA9IGNvcmUuTWF0cml4LmNNYXRyaXgoMCwgdmFycyk7XHJcblxyXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgdGhlIGMgbWF0cml4IHdpdGggc29tZXRoaW5nIGNsb3NlIHRvIDAuIFxyXG4gICAgICAgICAgICB2YXIgYyA9IGNvcmUuTWF0cml4LmNNYXRyaXgoc3RhcnQsIHZhcnMpO1xyXG5cclxuICAgICAgICAgICAgaXRlcnMgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy9zdGFydCBvZiBhbGdvcml0aG1cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSd2ZSByZWFjaGVkIHRoZSBtYXggaXRlcmF0aW9ucyB0aGVuIGV4aXRcclxuICAgICAgICAgICAgICAgIGlmKGl0ZXJzID4gbWF4X2l0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBzdWJzdGl0dXRpb24gb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBvID0gY3JlYXRlX3N1YnModmFycywgYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zZXQgeG5cclxuICAgICAgICAgICAgICAgIHhuID0gYy5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbWFrZSBhbGwgdGhlIHN1YnN0aXR1dGlvbnMgZm9yIGVhY2ggb2YgdGhlIGVxdWF0aW9uc1xyXG4gICAgICAgICAgICAgICAgZl9lcW5zLmZvckVhY2goZnVuY3Rpb24gKGYsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjLnNldChpLCAwLCBmLmFwcGx5KG51bGwsIG8pKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtID0gbmV3IGNvcmUuTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICBKLmVhY2goZnVuY3Rpb24gKGZuLCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFucyA9IGZuLmFwcGx5KG51bGwsIG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIG0uc2V0KGksIGosIGFucyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBtID0gbS5pbnZlcnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3ByZWZvcm0gdGhlIGVsaW1pbmF0aW9uXHJcbiAgICAgICAgICAgICAgICB5ID0gXy5tdWx0aXBseShtLCBjKS5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3RoZSBjYWxsYmFjayBpcyB0byBhdm9pZCBvdmVyZmxvdyBpbiB0aGUgY29lZmZpZW50IGRlbm9uaW1hdG9yXHJcbiAgICAgICAgICAgICAgICAvL2l0IGNvbnZlcnRzIGl0IHRvIGEgZGVjaW1hbCBhbmQgdGhlbiBiYWNrIHRvIGEgZnJhY3Rpb24uIFNvbWUgcHJlY2lzaW9uXHJcbiAgICAgICAgICAgICAgICAvL2lzIGxvc3QgYmUgaXQncyBiZXR0ZXIgdGhhbiBvdmVyZmxvdy4gXHJcbiAgICAgICAgICAgICAgICBkID0geS5zdWJ0cmFjdCh4bjEsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoTnVtYmVyKHgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHhuMSA9IHhuLmFkZCh5LCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKE51bWJlcih4KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL21vdmUgYyBpcyBub3cgeG4xXHJcbiAgICAgICAgICAgICAgICBjID0geG4xO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBub3JtXHJcblxyXG4gICAgICAgICAgICAgICAgLy90aGUgZXhwZWN0YXRpb24gaXMgdGhhdCB3ZSdyZSBjb252ZXJnaW5nIHRvIHNvbWUgYW5zd2VyIGFzIHRoaXMgcG9pbnQgcmVnYXJkbGVzcyBvZiB3aGVyZSB3ZSBzdGFydFxyXG4gICAgICAgICAgICAgICAgLy90aGlzIG1heSBoYXZlIHRvIGJlIGFkanVzdGVkIGF0IHNvbWUgcG9pbnQgYmVjYXVzZSBvZiBlcnJvbmVvdXMgYXNzdW1wdGlvbnNcclxuICAgICAgICAgICAgICAgIGlmKGl0ZXJzID49IGp1bXBfYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIHRoZSBub3JtLiBJZiB0aGUgbm9ybSBpcyBncmVhdGVyIHRoYW4gb25lIHRoZW4gaXQncyB0aW1lIHRvIHRyeSBhbm90aGVyIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobm9ybSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXNldCB0aGUgc3RhcnQgcG9pbnQgYXQgaGFsd2F5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRyaWVzID09PSBoYWxmd2F5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHRyaWVzID4gaGFsZndheSA/IDEgOiAtMTsgLy93aGljaCBzaWRlIGFyZSB3ZSBpbmNyZW1lbnRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBpbmNyZW1lbnQgK24gYXQgb25lIHNpZGUgYW5kIC1uIGF0IHRoZSBvdGhlci4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAodHJpZXMgJSBNYXRoLmZsb29yKGhhbGZ3YXkpKSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRqdXN0IHRoZSBzdGFydCBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCArPSAoc2lnbiAqIG4gKiBqdW1wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxsIHJlc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLnNvbHZlTm9uTGluZWFyU3lzdGVtKGVxbnMsIC0tdHJpZXMsIHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsbm9ybSA9IG5vcm07XHJcbiAgICAgICAgICAgICAgICBpdGVycysrO1xyXG4gICAgICAgICAgICAgICAgbm9ybSA9IGQubWF4KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9leGl0IGVhcmx5LiBSZXZpc2l0IGlmIHdlIGdldCBidWdzXHJcbiAgICAgICAgICAgICAgICBpZihOdW1iZXIobm9ybSkgPT09IE51bWJlcihsbm9ybSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZShOdW1iZXIobm9ybSkgPj0gTnVtYmVyLkVQU0lMT04pXHJcblxyXG4gICAgICAgICAgICAvL3JldHVybiBhIGJsYW5rIHNldCBpZiBub3RoaW5nIHdhcyBmb3VuZDtcclxuICAgICAgICAgICAgaWYoIWZvdW5kKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICAgICAgLy9yZXR1cm4gYyBzaW5jZSB0aGF0J3MgdGhlIGFuc3dlclxyXG4gICAgICAgICAgICByZXR1cm4gX18uc3lzdGVtU29sdXRpb25zKGMsIHZhcnMsIHRydWUsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5yb3VuZChOdW1iZXIoeCksIDE0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzeXN0ZW1Tb2x1dGlvbnM6IGZ1bmN0aW9uIChyZXN1bHQsIHZhcnMsIGV4cGFuZF9yZXN1bHQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBzb2x1dGlvbnMgPSBjb3JlLlNldHRpbmdzLlNPTFVUSU9OU19BU19PQkpFQ1QgPyB7fSA6IFtdO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LmVhY2goZnVuY3Rpb24gKGUsIGlkeCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gKGV4cGFuZF9yZXN1bHQgPyBfLmV4cGFuZChlKSA6IGUpLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uID0gY2FsbGJhY2suY2FsbChlLCBzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSB2YXJzW2lkeF07XHJcbiAgICAgICAgICAgICAgICBpZihjb3JlLlNldHRpbmdzLlNPTFVUSU9OU19BU19PQkpFQ1QpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnNbdmFyaWFibGVdID0gc29sdXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLnB1c2goW3ZhcmlhYmxlLCBzb2x1dGlvbl0pOyAvKk5PKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vZG9uZVxyXG4gICAgICAgICAgICByZXR1cm4gc29sdXRpb25zO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU29sdmVzIGEgc3lzdGVtIG9mIGVxdWF0aW9ucyBieSBzdWJzdGl0dXRpb24uIFRoaXMgaXMgdXNlZnVsIHdoZW5cclxuICAgICAgICAgKiBubyBkaXN0aW5jdCBzb2x1dGlvbiBleGlzdHMuIGUuZy4gYSBsaW5lLCBwbGFuZSwgZXRjLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVxbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc29sdmVTeXN0ZW1CeVN1YnN0aXR1dGlvbjogZnVuY3Rpb24gKGVxbnMpIHtcclxuICAgICAgICAgICAgLy8gQXNzdW1lIGF0IGxlYXN0IDIgZXF1YXRpb25zLiBUaGUgZnVuY3Rpb24gdmFyaWFibGVzIHdpbGwganVzdCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaWYgdW5kZWZpbmVkIGlzIHByb3ZpZGVkXHJcbiAgICAgICAgICAgIHZhciB2YXJzX2EgPSB2YXJpYWJsZXMoZXFuc1swXSk7XHJcbiAgICAgICAgICAgIHZhciB2YXJzX2IgPSB2YXJpYWJsZXMoZXFuc1sxXSk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBjaXJjbGUgZXF1YXRpb25cclxuICAgICAgICAgICAgaWYoZXFucy5sZW5ndGggPT09IDIgJiYgdmFyc19hLmxlbmd0aCA9PT0gMiAmJiBjb3JlLlV0aWxzLmFycmF5RXF1YWwodmFyc19hLCB2YXJzX2IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uc29sdmVDaXJjbGUoZXFucywgdmFyc19hKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyByZXR1cm4gYW4gZW1wdHkgc2V0XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy9odHRwczovL3d3dy5sYWtlaGVhZHUuY2Evc2l0ZXMvZGVmYXVsdC9maWxlcy91cGxvYWRzLzc3L2RvY3MvUmVtYW5pRmluYWwucGRmXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU29sdmVzIGEgc3lzdGVtcyBvZiBlcXVhdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBlcW5zIEFuIGFycmF5IG9mIGVxdWF0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhcl9hcnJheSBBbiBhcnJheSBvZiB2YXJpYWJsZXNcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl8b2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNvbHZlU3lzdGVtOiBmdW5jdGlvbiAoZXFucywgdmFyX2FycmF5KSB7XHJcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgYSB2YXJfYXJyYXkgd2FzIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAvL25lcmRhbWVyLmNsZWFyVmFycygpOy8vIHRoaXMgZGVsZXRlZCBBTEwgdmFyaWFibGVzOiBub3Qgd2hhdCB3ZSB3YW50XHJcbiAgICAgICAgICAgIC8vcGFyc2UgYWxsIHRoZSBlcXVhdGlvbnMgdG8gTEhTLiBSZW1lbWJlciB0aGF0IHRoZXkgY29tZSBpbiBhcyBzdHJpbmdzXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlcW5zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgZXFuc1tpXSA9IF9fLnRvTEhTKGVxbnNbaV0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGwgPSBlcW5zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBtID0gbmV3IGNvcmUuTWF0cml4KCksXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBjb3JlLk1hdHJpeCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZF9yZXN1bHQgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICB2YXJzO1xyXG5cclxuICAgICAgICAgICAgaWYodHlwZW9mIHZhcl9hcnJheSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIHRoZSBlcXVhdGlvbnMgYXJlIGxpbmVhclxyXG4gICAgICAgICAgICAgICAgaWYoIV9BLmFsbExpbmVhcihlcW5zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5zb2x2ZU5vbkxpbmVhclN5c3RlbShlcW5zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlIGluc3RhbmNlb2YgY29yZS5leGNlcHRpb25zLkRpdmlzaW9uQnlaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uc29sdmVTeXN0ZW1CeVN1YnN0aXR1dGlvbihlcW5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXJzID0gY29yZS5VdGlscy5hcnJheUdldFZhcmlhYmxlcyhlcW5zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggcmVkdW5kYW50IGVxdWF0aW9ucyBhcyBleHByZXNzZWQgaW4gIzU2MlxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZpeCBpcyB0byByZW1vdmUgYWxsIGJ1dCB0aGUgbnVtYmVyIG9mIGVxdWF0aW9ucyBlcXVhbCB0byB0aGUgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAvLyBvZiB2YXJpYWJsZXMuIFdlIHRoZW4gc29sdmUgdGhvc2UgYW5kIHRoZW4gZXZhbHVhdGUgdGhlIHJlbWFpbmluZyBlcXVhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vIHdpdGggdGhvc2Ugc29sdXRpb25zLiBJZiB0aGUgYWxsIGVxdWFsIHRydWUgdGhlbiB0aG9zZSBhcmUganVzdCByZWR1bmRhbnRcclxuICAgICAgICAgICAgICAgIC8vIGVxdWF0aW9ucyBhbmQgd2UgY2FuIHJldHVybiB0aGUgc29sdXRpb24gc2V0LlxyXG4gICAgICAgICAgICAgICAgaWYodmFycy5sZW5ndGggPCBlcW5zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWR1Y2VkID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBlcW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWR1Y2VkLnB1c2goXy5wYXJzZShlcW5zW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIga25vd25zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IF9fLnNvbHZlU3lzdGVtKHJlZHVjZWQsIHZhcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzb2x1dGlvbnMgbWF5IGhhdmUgY29tZSBiYWNrIGFzIGFuIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShzb2x1dGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtub3duc1tzb2xbMF1dID0gc29sWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtub3ducyA9IHNvbHV0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGJ5IGFzc3VtaW5nIHRoZXkgd2lsbCBhbGwgZXZhbHVhdGUgdG8gemVyby4gSWYgZXZlbiBvbmUgZmFpbHNcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGFsbCB6ZXJvIHdpbGwgYmUgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsX3plcm8gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBsYXN0IHNvbHV0aW9uIGV2YWx1dGVzIHRvIHplcm8gZ2l2ZW4gdGhlc2Ugc29sdXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gbiAtIDE7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIV8ucGFyc2UoZXFuc1tpXSwga25vd25zKS5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbF96ZXJvID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFsbF96ZXJvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZXMgb25seSB0aGUgdmFyaWFibGVzIG9mIHRoZSBsaW5lYXIgZXF1YXRpb25zIGluIHRoZSBuZXJkYW1lciBuYW1lc3BhY2VcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmVyZGFtZXIuc2V0VmFyKHZhcnNbaV0sIFwiZGVsZXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0aGlzIHRvIGNNYXRyaXggb3Igc29tZXRoaW5nIHNpbWlsYXJcclxuICAgICAgICAgICAgICAgIC8vIHBvcHVsYXRlIHRoZSBtYXRyaXhcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGVxbnNbaV07IC8vc3RvcmUgdGhlIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGNvbHVtbnNcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdmFycy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHZhcnNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4LmNvbnRhaW5zKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZzID0gY29lZmZzLmNvbmNhdCh4LmNvZWZmcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2YgPSBjb3JlLlV0aWxzLmFycmF5U3VtKGNvZWZmcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2V0KGksIGosIGNmKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3RyaXAgdGhlIHZhcmlhYmxlcyBmcm9tIHRoZSBzeW1ib2wgc28gd2UncmUgbGVmdCB3aXRoIG9ubHkgdGhlIHplcm90aCBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3RhcnQgd2l0aCB0aGUgc3ltYm9sIGFuZCByZW1vdmUgZWFjaCB2YXJpYWJsZSBhbmQgaXRzIGNvZWZmaWNpZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXJzLm1hcChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSBudW0uc3RyaXBWYXIoZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5zZXQoaSwgMCwgbnVtLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGlkZWEgaXMgdGhhdCB3ZSBsb29wIHRocm91Z2ggZWFjaCBlcXVhdGlvbiBhbmQgdGhlbiBleHBhbmQgaXQuIEFmdGVyd2FyZHMgd2UgbG9vcFxyXG4gICAgICAgICAgICAgICAgICogdGhyb3VnaCBlYWNoIHRlcm0gYW5kIHNlZSBpZiBhbmQgY2hlY2sgdG8gc2VlIGlmIGl0IG1hdGNoZXMgb25lIG9mIHRoZSB2YXJpYWJsZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBXaGVuIGEgbWF0Y2ggaXMgZm91bmQgd2UgbWFyayBpdC4gTm8gb3RoZXIgbWF0Y2ggc2hvdWxkIGJlIGZvdW5kIGZvciB0aGF0IHRlcm0uIElmIGl0XHJcbiAgICAgICAgICAgICAgICAgKiBpcyB3ZSBzdG9wIHNpbmNlIGl0J3Mgbm90IGxpbmVhci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFycyA9IHZhcl9hcnJheTtcclxuICAgICAgICAgICAgICAgIGV4cGFuZF9yZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9wcmVmaWxsXHJcbiAgICAgICAgICAgICAgICAgICAgYy5zZXQoaSwgMCwgbmV3IFN5bWJvbCgwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBfLmV4cGFuZChlcW5zW2ldKS5jb2xsZWN0U3ltYm9scygpOyAvL2V4cGFuZCBhbmQgc3RvcmVcclxuICAgICAgICAgICAgICAgICAgICAvL2dvIHRyb3VnaCBlYWNoIG9mIHRoZSB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdmFyX2FycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uc2V0KGksIGosIG5ldyBTeW1ib2woMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHZhcl9hcnJheVtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbyB0aHJvdWdoIHRoZSB0ZXJtcyBhbmQgc29ydCB0aGUgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBlLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVybSA9IGVba10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHogPSAwOyB6IDwgdmFyX2FycmF5Lmxlbmd0aDsgeisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayB0byBzZWUgaWYgdGVybXMgY29udGFpbiBtdWx0aXBsZSB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ZXJtLmNvbnRhaW5zKHZhcl9hcnJheVt6XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hlY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLmVycignTXVsdGlwbGUgdmFyaWFibGVzIGZvdW5kIGZvciB0ZXJtICcgKyB0ZXJtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgbWFkZSBzdXJlIHRoYXQgZXZlcnkgdGVybSBjb250YWlucyBvbmUgdmFyaWFibGUgc28gaXQncyBzYWZlIHRvIGFzc3VtZSB0aGF0IGlmIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXJpYWJsZSBpcyBmb3VuZCB0aGVuIHRoZSByZW1haW5kZXIgaXMgdGhlIGNvZWZmaWNpZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGVybS5jb250YWlucyh2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cGFydHMgPSBleHBsb2RlKHJlbW92ZShlLCBrKSwgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5zZXQoaSwgaiwgXy5hZGQobS5nZXQoaSwgaiksIHRwYXJ0c1swXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vYWxsIHRoZSByZW1haW5pbmcgdGVybXMgZ28gdG8gdGhlIGMgbWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGsgPSAwOyBrIDwgZS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLnNldChpLCAwLCBfLmFkZChjLmdldChpLCAwKSwgZVtrXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vY29uc2lkZXIgY2FzZSAoYStiKSpJK3VcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jaGVjayBpZiB0aGUgc3lzdGVtIGhhcyBhIGRpc3RpbmN0IHNvbHV0aW9uXHJcbiAgICAgICAgICAgIGlmKHZhcnMubGVuZ3RoICE9PSBlcW5zLmxlbmd0aCB8fCBtLmRldGVybWluYW50KCkuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzb2x2ZSB0aGUgc3lzdGVtIGJ5IGhhbmRcclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIF9fLnNvbHZlU3lzdGVtQnlTdWJzdGl0dXRpb24oZXFucywgdmFycywgbSwgYyk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5leGNlcHRpb25zLlNvbHZlRXJyb3IoJ1N5c3RlbSBkb2VzIG5vdCBoYXZlIGEgZGlzdGluY3Qgc29sdXRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXNlIE1eLTEqYyB0byBzb2x2ZSBzeXN0ZW1cclxuICAgICAgICAgICAgbSA9IG0uaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBtLm11bHRpcGx5KGMpO1xyXG4gICAgICAgICAgICAvL2NvcnJlY3QgdGhlIHNpZ24gYXMgcGVyIGlzc3VlICM0MTBcclxuICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc0FycmF5KHZhcl9hcnJheSkpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX18uc3lzdGVtU29sdXRpb25zKHJlc3VsdCwgdmFycywgZXhwYW5kX3Jlc3VsdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcXVhZHJhdGljIGZ1bmN0aW9uIGJ1dCBvbmx5IG9uZSBzaWRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBjXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcXVhZDogZnVuY3Rpb24gKGMsIGIsIGEpIHtcclxuICAgICAgICAgICAgdmFyIGRpc2NyaW1pbmFudCA9IF8uc3VidHJhY3QoXy5wb3coYi5jbG9uZSgpLCBTeW1ib2woMikpLCBfLm11bHRpcGx5KF8ubXVsdGlwbHkoYS5jbG9uZSgpLCBjLmNsb25lKCkpLCBTeW1ib2woNCkpKS8qYl4yIC0gNGFjKi87XHJcbiAgICAgICAgICAgIHZhciBkZXQgPSBfLnBvdyhkaXNjcmltaW5hbnQsIFN5bWJvbCgwLjUpKTtcclxuICAgICAgICAgICAgdmFyIGRlbiA9IF8ucGFyc2UoXy5tdWx0aXBseShuZXcgU3ltYm9sKDIpLCBhLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9IFtcclxuICAgICAgICAgICAgICAgIF8ucGFyc2UoZm9ybWF0KCcoLSh7MH0pKyh7MX0pKS8oezJ9KScsIGIsIGRldCwgZGVuKSksXHJcbiAgICAgICAgICAgICAgICBfLnBhcnNlKGZvcm1hdCgnKC0oezB9KS0oezF9KSkvKHsyfSknLCBiLCBkZXQsIGRlbikpXHJcbiAgICAgICAgICAgIF07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGN1YmljIGVxdWF0aW9uXHJcbiAgICAgICAgICogaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzYxNzI1L2lzLXRoZXJlLWEtc3lzdGVtYXRpYy13YXktb2Ytc29sdmluZy1jdWJpYy1lcXVhdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gZF9vXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGNfb1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiX29cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYV9vXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGN1YmljOiBmdW5jdGlvbiAoZF9vLCBjX28sIGJfbywgYV9vKSB7XHJcbiAgICAgICAgICAgIC8vY29udmVydCBldmVyeXRoaW5nIHRvIHRleHRcclxuICAgICAgICAgICAgdmFyIGEgPSBhX28udGV4dCgpLCBiID0gYl9vLnRleHQoKSwgYyA9IGNfby50ZXh0KCksIGQgPSBkX28udGV4dCgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHQgPSBgKC0oJHtifSleMy8oMjcqKCR7YX0pXjMpKygke2J9KSooJHtjfSkvKDYqKCR7YX0pXjIpLSgke2R9KS8oMiooJHthfSkpKWA7XHJcbiAgICAgICAgICAgIHZhciB1ID0gYCgoJHtjfSkvKDMqKCR7YX0pKS0oJHtifSleMi8oOSooJHthfSleMikpYDtcclxuICAgICAgICAgICAgdmFyIHYgPSBgKCR7Yn0pLygzKigke2F9KSlgO1xyXG4gICAgICAgICAgICB2YXIgeCA9IGAoKCR7dH0pK3NxcnQoKCR7dH0pXjIrKCR7dX0pXjMpKV4oMS8zKSsoKCR7dH0pLXNxcnQoKCR7dH0pXjIrKCR7dX0pXjMpKV4oMS8zKS0oJHt2fSlgO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBhIHRvIG9uZVxyXG4gICAgICAgICAgICB2YXIgdyA9ICcxLzIrc3FydCgzKS8yKmknOyAvLyBDdWJlIHJvb3Qgb2YgdW5pdHlcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBfLnBhcnNlKHgpLFxyXG4gICAgICAgICAgICAgICAgXy5wYXJzZShgKCR7eH0pKCR7d30pYCksXHJcbiAgICAgICAgICAgICAgICBfLnBhcnNlKGAoJHt4fSkoJHt3fSleMmApXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcXVhcnRpYyBlcXVhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBlXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGRcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gY1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGFcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcXVhcnRpYzogZnVuY3Rpb24gKGUsIGQsIGMsIGIsIGEpIHtcclxuICAgICAgICAgICAgdmFyIHNjb3BlID0ge307XHJcbiAgICAgICAgICAgIGNvcmUuVXRpbHMuYXJyYXlVbmlxdWUodmFyaWFibGVzKGEpLmNvbmNhdCh2YXJpYWJsZXMoYikpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh2YXJpYWJsZXMoYykpLmNvbmNhdCh2YXJpYWJsZXMoZCkpLmNvbmNhdCh2YXJpYWJsZXMoZSkpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVbeF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhID0gYS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBiID0gYi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjID0gYy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBkID0gZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBlID0gZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB2YXIgcCwgcSwgRCwgRDAsIEQxLCBRLCB4MSwgeDIsIHgzLCB4NDtcclxuICAgICAgICAgICAgLyp2YXIgRCA9IGNvcmUuVXRpbHMuYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KFwiMjU2Kih7MH0pXjMqKHs0fSleMy0xOTIqKHswfSleMiooezF9KSooezN9KSooezR9KV4yLTEyOCooezB9KV4yKih7Mn0pXjIqKHs0fSleMisxNDQqKHswfSleMiooezJ9KSooezN9KV4yKih7NH0pXCIrXHJcbiAgICAgICAgICAgICBcIi0yNyooezB9KV4yKih7M30pXjQrMTQ0Kih7MH0pKih7MX0pXjIqKHsyfSkqKHs0fSleMi02Kih7MH0pKih7MX0pXjIqKHszfSleMiooezR9KS04MCooezB9KSooezF9KSooezJ9KV4yKih7M30pKih7NH0pKzE4Kih7MH0pKih7MX0pKih7Mn0pKih7M30pXjNcIitcclxuICAgICAgICAgICAgIFwiKzE2Kih7MH0pKih7Mn0pXjQqKHs0fSktNCooezB9KSooezJ9KV4zKih7M30pXjItMjcqKHsxfSleNCooezR9KV4yKzE4Kih7MX0pXjMqKHsyfSkqKHszfSkqKHs0fSktNCooezF9KV4zKih7M30pXjMtNCooezF9KV4yKih7Mn0pXjMqKHs0fSkrKHsxfSleMiooezJ9KV4yKih7M30pXjJcIiwgXHJcbiAgICAgICAgICAgICBhLCBiLCBjLCBkLCBlKSwgc2NvcGUpO1xyXG4gICAgICAgICAgICAgfSk7Ki9cclxuXHJcbiAgICAgICAgICAgIHAgPSBfLnBhcnNlKGZvcm1hdChcIig4Kih7MH0pKih7Mn0pLTMqKHsxfSleMikvKDgqKHswfSleMilcIiwgYSwgYiwgYykpLnRvU3RyaW5nKCk7IC8vYSwgYiwgY1xyXG4gICAgICAgICAgICBxID0gXy5wYXJzZShmb3JtYXQoXCIoKHsxfSleMy00Kih7MH0pKih7MX0pKih7Mn0pKzgqKHswfSleMiooezN9KSkvKDgqKHswfSleMylcIiwgYSwgYiwgYywgZCkpLnRvU3RyaW5nKCk7Ly9hLCBiLCBjLCBkLCBlXHJcbiAgICAgICAgICAgIEQwID0gXy5wYXJzZShmb3JtYXQoXCIxMiooezB9KSooezR9KS0zKih7MX0pKih7M30pKyh7Mn0pXjJcIiwgYSwgYiwgYywgZCwgZSkpLnRvU3RyaW5nKCk7IC8vYSwgYiwgYywgZCwgZVxyXG4gICAgICAgICAgICBEMSA9IF8ucGFyc2UoZm9ybWF0KFwiMiooezJ9KV4zLTkqKHsxfSkqKHsyfSkqKHszfSkrMjcqKHsxfSleMiooezR9KSsyNyooezB9KSooezN9KV4yLTcyKih7MH0pKih7Mn0pKih7NH0pXCIsIGEsIGIsIGMsIGQsIGUpKS50b1N0cmluZygpOyAvL2EsIGIsIGMsIGQsIGVcclxuICAgICAgICAgICAgUSA9IF8ucGFyc2UoZm9ybWF0KFwiKCgoezF9KSsoKHsxfSleMi00Kih7MH0pXjMpXigxLzIpKS8yKV4oMS8zKVwiLCBEMCwgRDEpKS50b1N0cmluZygpOyAvL0QwLCBEMVxyXG4gICAgICAgICAgICBTID0gXy5wYXJzZShmb3JtYXQoXCIoMS8yKSooLSgyLzMpKih7MX0pKygxLygzKih7MH0pKSooKHsyfSkrKCh7M30pLyh7Mn0pKSkpKV4oMS8yKVwiLCBhLCBwLCBRLCBEMCkpLnRvU3RyaW5nKCk7IC8vYSwgcCwgUSwgRDBcclxuICAgICAgICAgICAgeDEgPSBfLnBhcnNlKGZvcm1hdChcIi0oKHsxfSkvKDQqKHswfSkpKS0oezR9KSsoMS8yKSpzcXJ0KC00Kih7NH0pXjItMiooezJ9KSsoKHszfSkvKHs0fSkpKVwiLCBhLCBiLCBwLCBxLCBTKSk7IC8vYSwgYiwgcCwgcSwgU1xyXG4gICAgICAgICAgICB4MiA9IF8ucGFyc2UoZm9ybWF0KFwiLSgoezF9KS8oNCooezB9KSkpLSh7NH0pLSgxLzIpKnNxcnQoLTQqKHs0fSleMi0yKih7Mn0pKygoezN9KS8oezR9KSkpXCIsIGEsIGIsIHAsIHEsIFMpKTsgLy9hLCBiLCBwLCBxLCBTXHJcbiAgICAgICAgICAgIHgzID0gXy5wYXJzZShmb3JtYXQoXCItKCh7MX0pLyg0Kih7MH0pKSkrKHs0fSkrKDEvMikqc3FydCgtNCooezR9KV4yLTIqKHsyfSktKCh7M30pLyh7NH0pKSlcIiwgYSwgYiwgcCwgcSwgUykpOyAvL2EsIGIsIHAsIHEsIFNcclxuICAgICAgICAgICAgeDQgPSBfLnBhcnNlKGZvcm1hdChcIi0oKHsxfSkvKDQqKHswfSkpKSsoezR9KS0oMS8yKSpzcXJ0KC00Kih7NH0pXjItMiooezJ9KS0oKHszfSkvKHs0fSkpKVwiLCBhLCBiLCBwLCBxLCBTKSk7IC8vYSwgYiwgcCwgcSwgU1xyXG4gICAgICAgICAgICByZXR1cm4gW3gxLCB4MiwgeDMsIHg0XTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyZWFrcyB0aGUgZXF1YXRpb24gdXAgaW4gaXRzIGZhY3RvcnMgYW5kIHRyaWVzIHRvIHNvbHZlIHRoZSBzbWFsbGVyIHBhcnRzXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb2x2ZV9mb3JcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGl2aWRlQW5kQ29ucXVlcjogZnVuY3Rpb24gKHN5bWJvbCwgc29sdmVfZm9yKSB7XHJcbiAgICAgICAgICAgIHZhciBzb2xzID0gW107XHJcbiAgICAgICAgICAgIC8vc2VlIGlmIHdlIGNhbiBzb2x2ZSB0aGUgZmFjdG9yc1xyXG4gICAgICAgICAgICB2YXIgZmFjdG9ycyA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIGlmKGZhY3RvcnMuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3JzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gU3ltYm9sLnVud3JhcFBBUkVOUyh4KTtcclxuICAgICAgICAgICAgICAgICAgICBzb2xzID0gc29scy5jb25jYXQoc29sdmUoeCwgc29sdmVfZm9yKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc29scztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEF0dGVtcHRzIHRvIHNvbHZlIHRoZSBlcXVhdGlvbiBhc3N1bWluZyBpdCdzIGEgcG9seW5vbWlhbCB3aXRoIG51bWVyaWMgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGVxXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNvbHZlX2ZvclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjc29sdmU6IGZ1bmN0aW9uIChlcSwgc29sdmVfZm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmJsb2NrKCdJR05PUkVfRScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmLCBwLCBwbiwgbiwgcGYsIHIsIHRoZXRhLCBzciwgc3AsIHJvb3RzO1xyXG4gICAgICAgICAgICAgICAgcm9vdHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGYgPSBjb3JlLlV0aWxzLmRlY29tcG9zZV9mbihlcSwgc29sdmVfZm9yLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmKGYueC5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBfLnBhcnNlKGYueC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcG4gPSBOdW1iZXIocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IF8ucG93KF8uZGl2aWRlKGYuYi5uZWdhdGUoKSwgZi5hKSwgcC5pbnZlcnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGYgPSBTeW1ib2wudG9Qb2xhckZvcm1BcnJheShuKTtcclxuICAgICAgICAgICAgICAgICAgICByID0gcGZbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhldGEgPSBwZlsxXTtcclxuICAgICAgICAgICAgICAgICAgICBzciA9IHIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBzcCA9IHAudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaywgcm9vdCwgc3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgPSBmb3JtYXQoJyh7MH0pKmVeKDIqezF9KnBpKnsyfSp7M30pJywgc3IsIGssIHAsIGNvcmUuU2V0dGluZ3MuSU1BR0lOQVJZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdCA9IF8ucGFyc2Uoc3RyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHMucHVzaChyb290KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdHM7XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhdGVzIHN0YXJ0aW5nIHBvaW50cyBmb3IgdGhlIE5ld3RvbiBzb2x2ZXIgZ2l2ZW4gYW4gZXhwcmVzc2lvbiBhdCB6ZXJvLlxyXG4gICAgICAgICAqIEl0IGJlaW5ncyBieSBjaGVjayBpZiB6ZXJvIGlzIGEgZ29vZCBwb2ludCBhbmQgc3RhcnRzIGV4cGFuZGluZyBieSBhIHByb3ZpZGVkIHN0ZXAgc2l6ZS4gXHJcbiAgICAgICAgICogQnVpbGRzIG9uIHRoZSBmYWN0IHRoYXQgaWYgdGhlIHNpZ24gY2hhbmdlcyBvdmVyIGFuIGludGVydmFsIHRoZW4gYSB6ZXJvXHJcbiAgICAgICAgICogbXVzdCBleGlzdCBvbiB0aGF0IGludGVydmFsXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFBvaW50czogZnVuY3Rpb24gKHN5bWJvbCwgc3RlcCwgcG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwIHx8IDAuMDE7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cyB8fCBbXTtcclxuICAgICAgICAgICAgdmFyIGYgPSBidWlsZChzeW1ib2wpO1xyXG4gICAgICAgICAgICB2YXIgeDAgPSAwO1xyXG5cclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5yb3VuZCh4MCksXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGYoc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3Rfc2lnbiA9IGxhc3QgLyBNYXRoLmFicyhsYXN0KSxcclxuICAgICAgICAgICAgICAgICAgICByc2lkZSA9IGNvcmUuU2V0dGluZ3MuUk9PVFNfUEVSX1NJREUsIC8vIHRoZSBtYXggbnVtYmVyIG9mIHJvb3RzIG9uIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgICAgICBsc2lkZSA9IHJzaWRlOyAvLyB0aGUgbWF4IG51bWJlciBvZiByb290cyBvbiBsZWZ0IHNpZGVcclxuICAgICAgICAgICAgLy8gY2hlY2sgYXJvdW5kIHRoZSBzdGFydGluZyBwb2ludFxyXG4gICAgICAgICAgICBwb2ludHMucHVzaChNYXRoLmZsb29yKHN0YXJ0IC8gMikpOyAvL2hhbGYgd2F5IGZyb20gemVybyBtaWdodCBiZSBhIGdvb2Qgc3RhcnRcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goTWF0aC5hYnMoc3RhcnQpKTsgLy98ZigwKXwgY291bGQgYmUgYSBnb29kIHN0YXJ0XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHN0YXJ0KTsvL3xmKDApfCBjb3VsZCBiZSBhIGdvb2Qgc3RhcnRcclxuICAgICAgICAgICAgLy9hZGp1c3QgZm9yIGxvZy4gQSBnb29kIHN0YXJ0aW5nIHBvaW50IHRvIGluY2x1ZGUgZm9yIGxvZyBpcyAwLjFcclxuICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGlmKHguY29udGFpbnNGdW5jdGlvbihjb3JlLlNldHRpbmdzLkxPRykpXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goMC4xKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHJhbmdlKC1jb3JlLlNldHRpbmdzLlNPTFZFX1JBRElVUywgc3RhcnQsIHN0ZXApLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmFuZ2Uoc3RhcnQsIGNvcmUuU2V0dGluZ3MuU09MVkVfUkFESVVTLCBzdGVwKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB0ZXN0X3NpZGUgPSBmdW5jdGlvbiAoc2lkZSwgbnVtX3Jvb3RzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeGksIHZhbCwgc2lnbjtcclxuICAgICAgICAgICAgICAgIHZhciBoaXRzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gc2lkZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB4aSA9IHNpZGVbaV07IC8vdGhlIHBvaW50IGJlaW5nIGV2YWx1YXRlZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGYoeGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSB2YWwgLyBNYXRoLmFicyh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRG9uJ3QgYWRkIG5vbi1udW1lcmljIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzTmFOKHZhbCkgfHwgIWlzRmluaXRlKHZhbCkgfHwgaGl0cy5sZW5ndGggPiBudW1fcm9vdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbXBhcmUgdGhlIHNpZ25zLiBUaGUgaGF2ZSB0byBiZSBkaWZmZXJlbnQgaWYgdGhleSBjcm9zcyBhIHplcm9cclxuICAgICAgICAgICAgICAgICAgICBpZihzaWduICE9PSBsYXN0X3NpZ24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGl0cy5wdXNoKHhpKTsgLy90YWtlIG5vdGUgb2YgdGhlIHBvc3NpYmxlIHplcm8gbG9jYXRpb25cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9zaWduID0gc2lnbjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGhpdHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdGVzdF9zaWRlKGxlZnQsIGxzaWRlKTtcclxuICAgICAgICAgICAgdGVzdF9zaWRlKHJpZ2h0LCByc2lkZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW1wbGVtZW50cyB0aGUgYmlzZWN0aW9uIG1ldGhvZC4gUmV0dXJucyB1bmRlZmluZWQgaW4gbm8gc29sdXRpb24gaXMgZm91bmRcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9pbnRcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXHJcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZCB8IG51bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBiaXNlY3Rpb246IGZ1bmN0aW9uIChwb2ludCwgZikge1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHBvaW50IC0gMTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gcG9pbnQgKyAxO1xyXG4gICAgICAgICAgICAvLyBGaXJzdCB0ZXN0IGlmIHRoaXMgcG9pbnQgaXMgZXZlbiB3b3J0aCBldmFsdWF0aW5nLiBJdCBzaG91bGRcclxuICAgICAgICAgICAgLy8gYmUgY3Jvc3NpbmcgdGhlIHggYXhpcyBzbyB0aGUgc2lnbnMgc2hvdWxkIGJlIGRpZmZlcmVudFxyXG4gICAgICAgICAgICBpZihNYXRoLnNpZ24oZihsZWZ0KSkgIT09IE1hdGguc2lnbihmKHJpZ2h0KSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzYWZldHkgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBlcHNpbG9uLCBtaWRkbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVwc2lsb24gPSBNYXRoLmFicyhyaWdodCAtIGxlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmV0eSBhZ2FpbnN0IGFuIGluZmluaXRlIGxvb3BcclxuICAgICAgICAgICAgICAgICAgICBpZihzYWZldHkrKyA+IGNvcmUuU2V0dGluZ3MuTUFYX0JJU0VDVElPTl9JVEVSIHx8IGlzTmFOKGVwc2lsb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtaWRkbGUgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICBtaWRkbGUgPSAobGVmdCArIHJpZ2h0KSAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGYobGVmdCkgKiBmKG1pZGRsZSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBtaWRkbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IG1pZGRsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZShlcHNpbG9uID49IFNldHRpbmdzLkVQU0lMT04pO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IChsZWZ0ICsgcmlnaHQpIC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUZXN0IHRoZSBzb2x1dGlvbiB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIHdpdGhpbiB0b2xlcmFuY2VcclxuICAgICAgICAgICAgICAgIHZhciB4X3BvaW50ID0gZihzb2x1dGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIWlzTmFOKHhfcG9pbnQpICYmIE1hdGguYWJzKHhfcG9pbnQpIDw9IGNvcmUuU2V0dGluZ3MuQklfU0VDVElPTl9FUFNJTE9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJucyB0b28gbWFueSBqdW5rIHNvbHV0aW9ucyBpZiBub3Qgcm91bmRlZCBhdCAxM3RoIHBsYWNlLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLnJvdW5kKHNvbHV0aW9uLCAxMyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcGxlbWVudHMgTmV3dG9uJ3MgaXRlcmF0aW9ucy4gUmV0dXJucyB1bmRlZmluZWQgaWYgbm8gc29sdXRpb25zIGlmIGZvdW5kXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50XHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZwXHJcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZHxudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmV3dG9uOiBmdW5jdGlvbiAocG9pbnQsIGYsIGZwKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXhpdGVyID0gY29yZS5TZXR0aW5ncy5NQVhfTkVXVE9OX0lURVJBVElPTlMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlciA9IDA7XHJcbiAgICAgICAgICAgIC8vZmlyc3QgdHJ5IHRoZSBwb2ludCBpdHNlbGYuIElmIGl0J3MgemVybyB2aW9sYS4gV2UncmUgZG9uZVxyXG4gICAgICAgICAgICB2YXIgeDAgPSBwb2ludCwgeDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZ4MCA9IGYoeDApOyAvL3N0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSB2YWx1ZSBpcyB6ZXJvIHRoZW4gd2UncmUgZG9uZSBiZWNhdXNlIDAgLSAoMC9kIGYoeDApKSA9IDBcclxuICAgICAgICAgICAgICAgIGlmKHgwID09PSAwICYmIGZ4MCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGl0ZXIrKztcclxuICAgICAgICAgICAgICAgIGlmKGl0ZXIgPiBtYXhpdGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy9uYXhpbXVtIGl0ZXJhdGlvbnMgcmVhY2hlZFxyXG5cclxuICAgICAgICAgICAgICAgIHggPSB4MCAtIGZ4MCAvIGZwKHgwKTtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gTWF0aC5hYnMoeCAtIHgwKTtcclxuICAgICAgICAgICAgICAgIHgwID0geDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZShlID4gU2V0dGluZ3MuTkVXVE9OX0VQU0lMT04pXHJcblxyXG4gICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSBudW1iZXIgaXMgaW5kZWVkIHplcm8uIDFlLTEzIHNlZW1zIHRvIGdpdmUgdGhlIG1vc3QgYWNjdXJhdGUgcmVzdWx0c1xyXG4gICAgICAgICAgICBpZihNYXRoLmFicyhmKHgpKSA8PSBTZXR0aW5ncy5FUFNJTE9OKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXdyaXRlOiBmdW5jdGlvbiAocmhzLCBsaHMsIGZvcl92YXJpYWJsZSkge1xyXG4gICAgICAgICAgICBsaHMgPSBsaHMgfHwgbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgaWYocmhzLmlzQ29tcG9zaXRlKCkgJiYgcmhzLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vdHJ5IHRvIGlzb2xhdGUgdGhlIHNxdWFyZSByb290XHJcbiAgICAgICAgICAgICAgICAvL2NvbnRhaW5lciBmb3IgdGhlIHNxdWFyZSByb290c1xyXG4gICAgICAgICAgICAgICAgdmFyIHNxcnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAvL2FsbCBlbHNlXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVtID0gW107XHJcbiAgICAgICAgICAgICAgICByaHMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeC5mbmFtZSA9PT0gJ3NxcnQnICYmIHguY29udGFpbnMoZm9yX3ZhcmlhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcXJ0cy5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3FydHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9tb3ZlIHRoZSByZW1haW5kZXIgdG8gdGhlIFJIU1xyXG4gICAgICAgICAgICAgICAgICAgIGxocyA9IF8uZXhwYW5kKF8ucG93KF8uc3VidHJhY3QobGhzLCBjb3JlLlV0aWxzLmFycmF5U3VtKHJlbSkpLCBuZXcgU3ltYm9sKDIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zcXVhcmUgYm90aCBzaWRlc1xyXG4gICAgICAgICAgICAgICAgICAgIHJocyA9IF8uZXhwYW5kKF8ucG93KFN5bWJvbC51bndyYXBTUVJUKHNxcnRzWzBdKSwgbmV3IFN5bWJvbCgyKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmhzID0gU3ltYm9sLnVud3JhcFNRUlQoXy5leHBhbmQocmhzKSk7IC8vZXhwYW5kIHRoZSB0ZXJtIGV4cHJlc3Npb24gZ28gZ2V0IHJpZCBvZiBxdW90aWVudHMgd2hlbiBwb3NzaWJsZVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYyA9IDAsIC8vYSBjb3VudGVyIHRvIHNlZSBpZiB3ZSBoYXZlIGFsbCB0ZXJtcyB3aXRoIHRoZSB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGwgPSByaHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAvL3RyeSB0byByZXdyaXRlIHRoZSB3aG9sZSB0aGluZ1xyXG4gICAgICAgICAgICBpZihyaHMuZ3JvdXAgPT09IENQICYmIHJocy5jb250YWlucyhmb3JfdmFyaWFibGUpICYmIHJocy5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICByaHMuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgIC8vZmlyc3QgYnJpbmcgYWxsIHRoZSB0ZXJtcyBjb250YWluaW5nIHRoZSB2YXJpYWJsZSB0byB0aGUgbGhzXHJcbiAgICAgICAgICAgICAgICByaHMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHguY29udGFpbnMoZm9yX3ZhcmlhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLmFkZCh0LCB4LmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxocyA9IF8uc3VidHJhY3QobGhzLCB4LmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByaHMgPSB0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgbm90IGFsbCB0aGUgdGVybXMgY29udGFpbiB0aGUgdmFyaWFibGUgc28gaXQncyBpbiB0aGUgZm9ybVxyXG4gICAgICAgICAgICAgICAgLy9hKnheMit4XHJcbiAgICAgICAgICAgICAgICBpZihjICE9PSBsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLnJld3JpdGUocmhzLCBsaHMsIGZvcl92YXJpYWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3JocywgbGhzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHJocy5ncm91cCA9PT0gQ0IgJiYgcmhzLmNvbnRhaW5zKGZvcl92YXJpYWJsZSkgJiYgcmhzLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmKHJocy5tdWx0aXBsaWVyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmhzLm11bHRpcGxpZXIgPSByaHMubXVsdGlwbGllci5tdWx0aXBseShuZXcgY29yZS5GcmFjKC0xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGhzLm11bHRpcGxpZXIgPSBsaHMubXVsdGlwbGllci5tdWx0aXBseShuZXcgY29yZS5GcmFjKC0xKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihsaHMuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJocy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguY29udGFpbnMoZm9yX3ZhcmlhYmxlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLm11bHRpcGx5KHQsIHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxocyA9IF8uZGl2aWRlKGxocywgeC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByaHMgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5yZXdyaXRlKHJocywgbGhzLCBmb3JfdmFyaWFibGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKCFyaHMuaXNMaW5lYXIoKSAmJiByaHMuY29udGFpbnMoZm9yX3ZhcmlhYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBfLnBhcnNlKHJocy5wb3dlci5jbG9uZSgpLmludmVydCgpKTtcclxuICAgICAgICAgICAgICAgIHJocyA9IF8ucG93KHJocywgcC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIGxocyA9IF8ucG93KF8uZXhwYW5kKGxocyksIHAuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18ucmV3cml0ZShyaHMsIGxocywgZm9yX3ZhcmlhYmxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHJocy5ncm91cCA9PT0gRk4gfHwgcmhzLmdyb3VwID09PSBTIHx8IHJocy5ncm91cCA9PT0gUEwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbcmhzLCBsaHNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcXJ0U29sdmU6IGZ1bmN0aW9uIChzeW1ib2wsIHYpIHtcclxuICAgICAgICAgICAgdmFyIHNxcnRzID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgdmFyIHJlbSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHguZm5hbWUgPT09ICdzcXJ0JyAmJiB4LmNvbnRhaW5zKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxcnRzID0gXy5hZGQoc3FydHMsIHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBfLmFkZChyZW0sIHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvL3F1aWNrIGFuZCBkaXJ0eSBBVE1cclxuICAgICAgICAgICAgICAgIGlmKCFzcXJ0cy5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8uZXhwYW5kKF8ubXVsdGlwbHkoXy5wYXJzZShzeW1ib2wubXVsdGlwbGllciksIF8uc3VidHJhY3QoXy5wb3cocmVtLCBuZXcgU3ltYm9sKDIpKSwgXy5wb3coc3FydHMsIG5ldyBTeW1ib2woMikpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc3F1YXJlIGJvdGggc2lkZXNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb25zID0gc29sdmUodCwgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90ZXN0IHRoZSBwb2ludHMuIFRoZSBkdW1iIHdheSBvZiBnZXR0aW5nIHRoZSBhbnN3ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zID0gc29sdXRpb25zLmZpbHRlcihmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic1t2XSA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGV2YWx1YXRlKHN5bWJvbCwgc3Vicyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBvaW50LmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfEVxdWF0aW9ufSBlcW5zXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc29sdmVfZm9yXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb2x1dGlvbnNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RXF1YXRpb259IGZuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHZhciBzb2x2ZSA9IGZ1bmN0aW9uIChlcW5zLCBzb2x2ZV9mb3IsIHNvbHV0aW9ucywgZGVwdGgsIGZuKSB7XHJcbiAgICAgICAgZGVwdGggPSBkZXB0aCB8fCAwO1xyXG5cclxuICAgICAgICBpZihkZXB0aCsrID4gU2V0dGluZ3MuTUFYX1NPTFZFX0RFUFRIKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL21ha2UgcHJlcGFyYXRpb25zIGlmIGl0J3MgYW4gRXF1YXRpb25cclxuICAgICAgICBpZihlcW5zIGluc3RhbmNlb2YgRXF1YXRpb24pIHtcclxuICAgICAgICAgICAgLy9pZiBpdCdzIHplcm8gdGhlbiB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgIGlmKGVxbnMuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFN5bWJvbCgwKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiB0aGUgbGhzID0geCB0aGVuIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgaWYoZXFucy5MSFMuZXF1YWxzKHNvbHZlX2ZvcikgJiYgIWVxbnMuUkhTLmNvbnRhaW5zKHNvbHZlX2ZvcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZXFucy5SSFNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgdGhlIHJocyA9IHggdGhlbiB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgIGlmKGVxbnMuUkhTLmVxdWFscyhzb2x2ZV9mb3IpICYmICFlcW5zLkxIUy5jb250YWlucyhzb2x2ZV9mb3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2VxbnMuTEhTXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy91bndyYXAgdGhlIHZlY3RvciBzaW5jZSB3aGF0IHdlIHdhbnQgYXJlIHRoZSBlbGVtZW50c1xyXG4gICAgICAgIGlmKGVxbnMgaW5zdGFuY2VvZiBjb3JlLlZlY3RvcilcclxuICAgICAgICAgICAgZXFucyA9IGVxbnMuZWxlbWVudHM7XHJcbiAgICAgICAgc29sdmVfZm9yID0gc29sdmVfZm9yIHx8ICd4JzsgLy9hc3N1bWVzIHggYnkgZGVmYXVsdFxyXG4gICAgICAgIC8vSWYgaXQncyBhbiBhcnJheSB0aGVuIHNvbHZlIGl0IGFzIGEgc3lzdGVtIG9mIGVxdWF0aW9uc1xyXG4gICAgICAgIGlmKGlzQXJyYXkoZXFucykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fLnNvbHZlU3lzdGVtLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBhcnNlIG91dCBmdW5jdGlvbnMuIEZpeCBmb3IgaXNzdWUgIzMwMFxyXG4gICAgICAgIC8vIGVxbnMgPSBjb3JlLlV0aWxzLmV2YWx1YXRlKGVxbnMpO1xyXG4gICAgICAgIHNvbHV0aW9ucyA9IHNvbHV0aW9ucyB8fCBbXTtcclxuICAgICAgICAvL21hcmsgZXhpc3Rpbmcgc29sdXRpb25zIGFzIG5vdCB0byBoYXZlIGR1cGxpY2F0ZXNcclxuICAgICAgICB2YXIgZXhpc3RpbmcgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gRWFzeSBmYWlsLiBJZiBpdCdzIGEgcmF0aW9uYWwgZnVuY3Rpb24gYW5kIHRoZSBkZW5vbWluYXRvciBpcyB6ZXJvXHJcbiAgICAgICAgLy8gdGhlIHdlJ3JlIGRvbmUuIElzc3VlICM1NTVcclxuICAgICAgICB2YXIga25vd24gPSB7fTtcclxuICAgICAgICBrbm93bltzb2x2ZV9mb3JdID0gMDtcclxuICAgICAgICBpZihpc1N5bWJvbChlcW5zKSAmJiBldmFsdWF0ZShlcW5zLmdldERlbm9tKCksIGtub3duKS5lcXVhbHMoMCkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElzIHVzdWVkIHRvIGFkZCBzb2x1dGlvbnMgdG8gc2V0LiBcclxuICAgICAgICAvLyBUT0RPOiBTZXQgaXMgbm93IGltcGxlbWVudGVkIGFuZCBzaG91bGQgYmUgdXRpbGl6ZWRcclxuICAgICAgICB2YXIgYWRkX3RvX3Jlc3VsdCA9IGZ1bmN0aW9uIChyLCBoYXNfdHJpZykge1xyXG4gICAgICAgICAgICB2YXIgcl9pc19zeW1ib2wgPSBpc1N5bWJvbChyKTtcclxuICAgICAgICAgICAgaWYociA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiByID09PSAnbnVtYmVyJyAmJiBpc05hTihyKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYoaXNBcnJheShyKSkge1xyXG4gICAgICAgICAgICAgICAgci5mb3JFYWNoKGZ1bmN0aW9uIChzb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KHNvbCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKHIudmFsdWVPZigpICE9PSAnbnVsbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBwcmUtYWRkIGZ1bmN0aW9uIGlmIGRlZmluZWQuIFRoaXMgY291bGQgYmUgdXNlZnVsIGZvciByb3VuZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb3JlLlNldHRpbmdzLlBSRV9BRERfU09MVVRJT04gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IGNvcmUuU2V0dGluZ3MuUFJFX0FERF9TT0xVVElPTihyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFyX2lzX3N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gXy5wYXJzZShyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgdGhlIG51bWJlciB0byBtdWx0aXBsZXMgb2YgcGlcclxuICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlNldHRpbmdzLm1ha2VfcGlfY29udmVyc2lvbnMgJiYgaGFzX3RyaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBfLmRpdmlkZShyLmNsb25lKCksIG5ldyBTeW1ib2woTWF0aC5QSSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB0ZW1wLm11bHRpcGxpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IE1hdGguYWJzKG0ubnVtKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gTWF0aC5hYnMobS5kZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhIDwgMTAgJiYgYiA8IDEwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IF8ubXVsdGlwbHkodGVtcCwgbmV3IFN5bWJvbCgncGknKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgY2hlY2sgaWYgd2UgZ2V0IGEgbnVtYmVyIG90aGVyd2lzZSB3ZSBtaWdodCBiZSB0aHJvd2luZyBvdXQgc3ltYm9saWMgc29sdXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByX3N0ciA9IHIudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWV4aXN0aW5nW3Jfc3RyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgYW5zd2VyIGFzIHNlZW5cclxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1tyX3N0cl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gTWF5YmUgd2UgZ2V0IGx1Y2t5LiBUcnkgdGhlIHBvaW50IGF0IHRoZSBmdW5jdGlvbi4gSWYgaXQgd29ya3Mgd2UgaGF2ZSBhIHBvaW50XHJcbiAgICAgICAgLy8gSWYgbm90IGl0IGZhaWxlZFxyXG4gICAgICAgIGlmKGVxbnMuZ3JvdXAgPT09IFMgJiYgZXFucy5jb250YWlucyhzb2x2ZV9mb3IpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgb1tzb2x2ZV9mb3JdID0gMDtcclxuICAgICAgICAgICAgICAgIGV2YWx1YXRlKGZuLCBvLCAnbnVtZXInKTtcclxuICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQobmV3IFN5bWJvbCgwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZXFucy5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgLy8gSXQgc3VmZmljZXMgdG8gc29sdmUgZm9yIHRoZSBudW1lcmF0b3JcclxuICAgICAgICAgICAgdmFyIG51bSA9IGVxbnMuZ2V0TnVtKCk7XHJcblxyXG4gICAgICAgICAgICBpZihudW0uZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2YgPSBTdHJpbmcoc29sdmVfZm9yKTsgLy9ldmVyeXRoaW5nIGVsc2UgYmVsb25ncyB0byB0aGUgY29lZmZcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBkZW5vbWluYXRvciBhbmQgbWFrZSBzdXJlIGl0IGRvZXNuJ3QgaGF2ZSB4IHNpbmNlIHdlIGRvbid0IGtub3cgaG93IHRvIHNvbHZlIGZvciB0aG9zZVxyXG4gICAgICAgICAgICAgICAgbnVtLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih4LmNvbnRhaW5zKHNmKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sdmUoeCwgc29sdmVfZm9yLCBzb2x1dGlvbnMsIGRlcHRoLCBlcW5zKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzb2x2ZShudW0sIHNvbHZlX2Zvciwgc29sdXRpb25zLCBkZXB0aCwgZm4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoZXFucy5ncm91cCA9PT0gRk4gJiYgZXFucy5mbmFtZSA9PT0gJ3NxcnQnKSB7XHJcbiAgICAgICAgICAgIGVxbnMgPSBfLnBvdyhTeW1ib2wudW53cmFwU1FSVChlcW5zKSwgbmV3IFN5bWJvbCgyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vcGFzcyBpbiBmYWxzZSB0byBub3QgZXhwYW5kIGVxdWF0aW9ucyBzdWNoIGFzICh4K3kpXjUuXHJcbiAgICAgICAgLy9JdCBzdWZmaWNlcyB0byBzb2x2ZSBmb3IgdGhlIG51bWVyYXRvciBzaW5jZSB0aGVyZSdzIG5vIHZhbHVlIGluIHRoZSBkZW5vbWluYXRvciB3aGljaCB5aWVsZHMgYSB6ZXJvIGZvciB0aGUgZnVuY3Rpb25cclxuICAgICAgICB2YXIgZXEgPSAoY29yZS5VdGlscy5pc1N5bWJvbChlcW5zKSA/IGVxbnMgOiBfXy50b0xIUyhlcW5zLCBmYWxzZSkpLmdldE51bSgpLFxyXG4gICAgICAgICAgICAgICAgdmFycyA9IGNvcmUuVXRpbHMudmFyaWFibGVzKGVxKSwgLy9nZXQgYSBsaXN0IG9mIGFsbCB0aGUgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICBudW12YXJzID0gdmFycy5sZW5ndGg7Ly9ob3cgbWFueSB2YXJpYWJsZXMgYXJlIHdlIGRlYWxpbmcgd2l0aFxyXG5cclxuICAgICAgICAvL2l0IHN1ZmZpY2llbnQgdG8gc29sdmUgKHgreSkgaWYgZXEgaXMgKHgreSlebiBzaW5jZSAwXm5cclxuICAgICAgICBpZihjb3JlLlV0aWxzLmlzSW50KGVxLnBvd2VyKSAmJiBlcS5wb3dlciA+IDApIHtcclxuICAgICAgICAgICAgZXEgPSBfLnBhcnNlKGVxKS50b0xpbmVhcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzaW5nbGUgdmFyaWFibGUgdGhlbiB3ZSBmaXJzdCBjaGVjayBpZiBpdCdzIGEgXHJcbiAgICAgICAgLy9wb2x5bm9taWFsIChpbmNsdWRpbmcgcmF0aW9uYWxzKS5JZiBpdCBpcyB0aGVuIHdlIHVzZSB0aGUgSmVua2lucy1UcmF1YmIgYWxnb3JpdGhtLiAgICAgXHJcbiAgICAgICAgLy9Eb24ndCB3YXN0ZSB0aW1lXHJcbiAgICAgICAgaWYoZXEuZ3JvdXAgPT09IFMgfHwgZXEuZ3JvdXAgPT09IENCICYmIGVxLmNvbnRhaW5zKHNvbHZlX2ZvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtuZXcgU3ltYm9sKDApXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9mb3JjZSB0byBwb2x5bm9taWFsLiBXZSBnbyB0aHJvdWdoIGVhY2ggYW5kIHRoZW4gd2UgbG9vayBhdCB3aGF0IGl0IHdvdWxkIFxyXG4gICAgICAgIC8vdGFrZSBmb3IgaXRzIHBvd2VyIHRvIGJlIGFuIGludGVnZXJcclxuICAgICAgICAvL2lmIHRoZSBwb3dlciBpcyBhIGZyYWN0aW9uYWwgd2UgZGl2aWRlIGJ5IHRoZSBmcmFjdGlvbmFsIHBvd2VyXHJcbiAgICAgICAgdmFyIGZyYWN0aW9uYWxzID0ge30sXHJcbiAgICAgICAgICAgICAgICBjZmFjdDtcclxuXHJcbiAgICAgICAgdmFyIGNvcnJlY3RfZGVub20gPSBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbCwge1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kX2Rlbm9taW5hdG9yOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZXhwYW5kX2Z1bmN0aW9uczogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gc3ltYm9sLmNsb25lKCk7IC8vcHJlc2VydmUgdGhlIG9yaWdpbmFsXHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHN5bWJvbC5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IHN5bWJvbC5zeW1ib2xzW3hdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgZGVub21pbmF0b3Igb2YgdGhlIHN1Yi1zeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVuID0gc3ltLmdldERlbm9tKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFkZW4uaXNDb25zdGFudCh0cnVlKSAmJiBzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5hZGQodCwgXy5tdWx0aXBseShlLCBkZW4uY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JyZWN0X2Rlbm9tKF8ubXVsdGlwbHkoXy5wYXJzZShzeW1ib2wubXVsdGlwbGllciksIHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGV4cGxvZGUoc3ltLCBzb2x2ZV9mb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc19zcXJ0ID0gcGFydHNbMV0uZm5hbWUgPT09IGNvcmUuU2V0dGluZ3MuU1FSVDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IFN5bWJvbC51bndyYXBTUVJUKHBhcnRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHYucG93ZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NpcmN1bGFyIGxvZ2ljIHdpdGggc3FydC4gU2luY2Ugc3FydCh4KSBiZWNvbWVzIHheKDEvMikgd2hpY2ggdGhlbiBiZWNvbWVzIHNxcnQoeCksIHRoaXMgY29udGludWVzIGZvcmV2ZXJcclxuICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbmVlZHMgdG8gYmUgdGVybWluYXRlZCBpZiBwID0gMS8yXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWlzU3ltYm9sKHApICYmICFwLmVxdWFscygxIC8gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocC5kZW4uZ3QoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzX3NxcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnN1YnRyYWN0KHN5bWJvbCwgc3ltLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uYWRkKHN5bWJvbCwgXy5tdWx0aXBseShwYXJ0c1swXS5jbG9uZSgpLCB2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RfZGVub20oc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gZnJhY3Rpb25hbHNbcC5kZW5dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25hbHNbcC5kZW5dID0gYyA/IGMrKyA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihwLnNpZ24oKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBfLnBhcnNlKHNvbHZlX2ZvciArICdeJyArIE1hdGguYWJzKHApKTsgLy90aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Vud3JhcCB0aGUgc3ltYm9sJ3MgZGVub25pYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHksIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeS5jb250YWlucyhzb2x2ZV9mb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5zeW1ib2xzW2luZGV4XSA9IF8ubXVsdGlwbHkoeSwgZmFjdG9yLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25hbHMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3JyZWN0X2Rlbm9tKF8ucGFyc2Uoc3ltYm9sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0uZ3JvdXAgPT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluX3AgPSBjb3JlLlV0aWxzLmFycmF5TWluKGNvcmUuVXRpbHMua2V5cyhzeW0uc3ltYm9scykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobWluX3AgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IF8ucGFyc2Uoc29sdmVfZm9yICsgJ14nICsgTWF0aC5hYnMobWluX3ApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29ycmVjdGVkID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3RlZCA9IF8uYWRkKGNvcnJlY3RlZCwgXy5tdWx0aXBseSh4LmNsb25lKCksIGZhY3Rvci5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvL3NlcGFyYXRlIHRoZSBlcXVhdGlvblxyXG4gICAgICAgIHZhciBzZXBhcmF0ZSA9IGZ1bmN0aW9uIChlcSkge1xyXG4gICAgICAgICAgICB2YXIgbGhzID0gbmV3IFN5bWJvbCgwKSxcclxuICAgICAgICAgICAgICAgICAgICByaHMgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICBlcS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBpZih4LmNvbnRhaW5zKHNvbHZlX2ZvciwgdHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgbGhzID0gXy5hZGQobGhzLCB4LmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJocyA9IF8uc3VidHJhY3QocmhzLCB4LmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFtsaHMsIHJoc107XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgX18uaW52ZXJzZUZ1bmN0aW9uU29sdmUgPSBmdW5jdGlvbiAobmFtZSwgbGhzLCByaHMpIHtcclxuICAgICAgICAgICAgLy9heCtiIGNvbWVzIGJhY2sgYXMgW2EsIHgsIGF4LCBiXTtcclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gZXhwbG9kZShsaHMuYXJnc1swXSwgc29sdmVfZm9yKTtcclxuICAgICAgICAgICAgLy9jaGVjayBpZiB4IGlzIGJ5IGl0c2VsZlxyXG4gICAgICAgICAgICB2YXIgeCA9IHBhcnRzWzFdO1xyXG4gICAgICAgICAgICBpZih4Lmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoXy5zeW1mdW5jdGlvbihuYW1lLCBbXy5kaXZpZGUocmhzLCBfLnBhcnNlKGxocy5tdWx0aXBsaWVyKSldKSwgcGFydHNbMF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vZmlyc3QgcmVtb3ZlIGFueSBkZW5vbWluYXRvcnNcclxuICAgICAgICBlcSA9IGNvcnJlY3RfZGVub20oZXEpO1xyXG5cclxuICAgICAgICBpZihlcS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgIHJldHVybiBbZXFdO1xyXG4gICAgICAgIC8vY29ycmVjdCBmcmFjdGlvbmFscy4gSSBjYW4gb25seSBoYW5kbGUgb25lIHR5cGUgcmlnaHQgbm93XHJcbiAgICAgICAgdmFyIGZrZXlzID0gY29yZS5VdGlscy5rZXlzKGZyYWN0aW9uYWxzKTtcclxuICAgICAgICBpZihma2V5cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgLy9tYWtlIGEgbm90ZSBvZiB0aGUgZmFjdG9yXHJcbiAgICAgICAgICAgIGNmYWN0ID0gZmtleXNbMF07XHJcbiAgICAgICAgICAgIGVxLmVhY2goZnVuY3Rpb24gKHgsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBpZih4LmNvbnRhaW5zKHNvbHZlX2ZvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBleHBsb2RlKHgsIHNvbHZlX2Zvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBwYXJ0c1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHYucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocC5kZW4uZ3QoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdi5wb3dlciA9IHAubXVsdGlwbHkobmV3IGNvcmUuRnJhYyhjZmFjdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcS5zeW1ib2xzW2luZGV4XSA9IF8ubXVsdGlwbHkodiwgcGFydHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGVxID0gXy5wYXJzZShlcSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RyeSBmb3IgbmVzdGVkIHNxcnRzIGFzIHBlciBpc3N1ZSAjNDg2XHJcbiAgICAgICAgYWRkX3RvX3Jlc3VsdChfXy5zcXJ0U29sdmUoZXEsIHNvbHZlX2ZvcikpO1xyXG5cclxuICAgICAgICAvL3BvbHlub21pYWwgc2luZ2xlIHZhcmlhYmxlXHJcbiAgICAgICAgaWYobnVtdmFycyA9PT0gMSkge1xyXG4gICAgICAgICAgICBpZihlcS5pc1BvbHkodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vdHJ5IHRvIGZhY3RvciBhbmQgc29sdmVcclxuICAgICAgICAgICAgICAgIHZhciBmYWN0b3JzID0gbmV3IGNvcmUuQWxnZWJyYS5DbGFzc2VzLkZhY3RvcnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb3JlLkFsZ2VicmEuRmFjdG9yLmZhY3RvcihlcSwgZmFjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBlcXVhdGlvbiBoYXMgbW9yZSB0aGFuIG9uZSBzeW1ib2xpYyBmYWN0b3IgdGhlbiBzb2x2ZSB0aG9zZSBpbmRpdmlkdWFsbHlcclxuICAgICAgICAgICAgICAgIGlmKGZhY3RvcnMuZ2V0TnVtYmVyU3ltYm9saWNzKCkgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIGZhY3RvcnMuZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KHNvbHZlKGZhY3RvcnMuZmFjdG9yc1t4XSwgc29sdmVfZm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmcyA9IGNvcmUuVXRpbHMuZ2V0Q29lZmZzKGVxLCBzb2x2ZV9mb3IpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVnID0gY29lZmZzLmxlbmd0aCAtIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNfY2FsY3VsYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhcnNbMF0gPT09IHNvbHZlX2Zvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIHRvIHNlZSBpZiBhbGwgdGhlIGNvZWZmaWNpZW50cyBhcmUgY29uc3RhbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hlY2tBbGwoY29lZmZzLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHguZ3JvdXAgIT09IGNvcmUuZ3JvdXBzLk47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdHMgPSBjb3JlLkFsZ2VicmEucHJvb3RzKGVxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgYWxsIHRoZSByb290cyBhcmUgaW50ZWdlcnMgdGhlbiByZXR1cm4gdGhvc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoZWNrQWxsKHJvb3RzLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY29yZS5VdGlscy5pc0ludCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yb290cyBoYXZlIGJlZW4gY2FsY3VsYXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc19jYWxjdWxhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290cy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChuZXcgU3ltYm9sKHgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXdhc19jYWxjdWxhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcW5zID0gXy5wYXJzZShlcW5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVxbnMgaW5zdGFuY2VvZiBjb3JlLkVxdWF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxbnMgPSBlcW5zLnRvTEhTKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBjYW4gc29sdmUgYWxnZWJyYWljYWxseSBmb3IgZGVncmVlcyAxLCAyLCAzLiBUaGUgcmVtYWluZGVyIHdlIHN3aXRjaCB0byBKZW5raW5zLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVnID09PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoXy5kaXZpZGUoY29lZmZzWzBdLCBjb2VmZnNbMV0ubmVnYXRlKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZGVnID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfLmV4cGFuZChfXy5xdWFkLmFwcGx5KHVuZGVmaW5lZCwgY29lZmZzKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZGVnID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdOyAvL3NldCB0byBibGFua1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyc3QgdHJ5IHRvIGZhY3RvciBhbmQgc29sdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yZWQgPSBjb3JlLkFsZ2VicmEuRmFjdG9yLmZhY3RvcihlcW5zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCB3YXMgc3VjY2Vzc2Z1bGx5IGZhY3RvcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNvbHV0aW9ucy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KHNvbHV0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KF9fLmN1YmljLmFwcGx5KHVuZGVmaW5lZCwgY29lZmZzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bV9yb290cyA9IGNzb2x2ZShlcSwgc29sdmVfZm9yKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bV9yb290cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bV9yb290cyA9IGRpdm5jb25zb2x2ZShlcSwgc29sdmVfZm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltX3Jvb3RzLmxlbmd0aCA+IDApIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KHN5bV9yb290cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfQS5wcm9vdHMoZXEpLm1hcChhZGRfdG9fcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCBOZXd0b25cclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBpdCdzIG5vdCBhIHBvbHlub21pYWwgdGhlbiB3ZSdsbCB0cnkgdG8gbG9vayBmb3IgYSBzb2x1dGlvbiB1c2luZyBOZXd0b24ncyBtZXRob2RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzX3RyaWcgPSBlcS5oYXNUcmlnKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZ2V0IGFsbCB0aGUgcG9pbnRzIHdoZXJlIGEgcG9zc2libGUgemVybyBtaWdodCBleGlzdC5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzMSA9IF9fLmdldFBvaW50cyhlcSwgMC4xKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzMiA9IF9fLmdldFBvaW50cyhlcSwgMC4wNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50czMgPSBfXy5nZXRQb2ludHMoZXEsIDAuMDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBjb3JlLlV0aWxzLmFycmF5VW5pcXVlKHBvaW50czEuY29uY2F0KHBvaW50czIpLmNvbmNhdChwb2ludHMzKSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIHBvaW50LCBzb2x1dGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGlsZSB0aGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGJ1aWxkKGVxLmNsb25lKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB0cnkgdG8gZWxpbWluYXRlIHNvbWUgcG9pbnRzIHVzaW5nIGJpc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0X3BvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBpZiB0aGVyZSdzIGEgc29sdXRpb24gYXQgdGhpcyBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbiA9IF9fLmJpc2VjdGlvbihwb2ludCwgZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHNvbHV0aW9uIHRoZW4gYWRkIGl0IHRvIHRoZSBhcnJheSBmb3IgZnVydGhlciBpbnZlc3RpZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzb2x1dGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRfcG9pbnRzLnB1c2gocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgc29sdXRpb24gdG8gdGhlIHNvbHV0aW9uIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KHNvbHV0aW9uLCBoYXNfdHJpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgcG9pbnRzIHRvIHRoZSByZW1haW5pbmcgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gdF9wb2ludHM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHRoZSBkZXJpdmF0aXZlIGFuZCBjb21waWxlIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF9DLmRpZmYoZXEuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZwID0gYnVpbGQoZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfXy5OZXd0b24ocG9pbnQsIGYsIGZwKSwgaGFzX3RyaWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMuc29ydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvL1RoZSBpZGVhIGhlcmUgaXMgdG8gZ28gdGhyb3VnaCB0aGUgZXF1YXRpb24gYW5kIGNvbGxlY3QgdGhlIGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAgICAvL3BsYWNlIHRoZW0gaW4gYW4gYXJyYXkgYW5kIGNhbGwgdGhlIHF1YWQgb3IgY3ViaWMgZnVuY3Rpb24gdG8gZ2V0IHRoZSByZXN1bHRzXHJcbiAgICAgICAgICAgIGlmKCFlcS5oYXNGdW5jKHNvbHZlX2ZvcikgJiYgZXEuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yZWQgPSBjb3JlLkFsZ2VicmEuRmFjdG9yLmZhY3RvcihlcS5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmFjdG9yZWQuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcmVkLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoc29sdmUoeCwgc29sdmVfZm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmcyA9IGNvcmUuVXRpbHMuZ2V0Q29lZmZzKGVxLCBzb2x2ZV9mb3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBjb2VmZnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZyA9IGwgLSAxOyAvL3RoZSBkZWdyZWUgb2YgdGhlIHBvbHlub21pYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGRlbm9taW5hdG9yIGFuZCBtYWtlIHN1cmUgaXQgZG9lc24ndCBoYXZlIHhcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFuZGxlIHRoZSBwcm9ibGVtIGJhc2VkIG9uIHRoZSBkZWdyZWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGRlZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0ZWQgPSBzZXBhcmF0ZShlcSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxocyA9IHNlcGFyYXRlZFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJocyA9IHNlcGFyYXRlZFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsaHMuZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLkVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoXy5wYXJzZShjb3JlLlV0aWxzLmZvcm1hdChjb3JlLlNldHRpbmdzLkxPRyArICcoKHswfSkvKHsyfSkpLycgKyBjb3JlLlNldHRpbmdzLkxPRyArICcoezF9KScsIHJocywgbGhzLnZhbHVlLCBsaHMubXVsdGlwbGllcikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3RoaW5nIHRvIGRvIGJ1dCB0byByZXR1cm4gdGhlIHF1b3RpZW50IG9mIHRoZSBjb25zdGFudCBhbmQgdGhlIExUXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lLmcuIDIqeC0xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfLmRpdmlkZShjb2VmZnNbMF0sIGNvZWZmc1sxXS5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoX18ucXVhZC5hcHBseSh1bmRlZmluZWQsIGNvZWZmcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoX18uY3ViaWMuYXBwbHkodW5kZWZpbmVkLCBjb2VmZnMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KF9fLnF1YXJ0aWMuYXBwbHkodW5kZWZpbmVkLCBjb2VmZnMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfXy5jc29sdmUoZXEsIHNvbHZlX2ZvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNvbHV0aW9ucy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoX18uZGl2aWRlQW5kQ29ucXVlcihlcSwgc29sdmVfZm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNvbHV0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IGZhY3RvcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChzb2x2ZShmYWN0b3JlZCwgc29sdmVfZm9yLCBzb2x1dGlvbnMsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkgeyAvKnNvbWV0aGluZyB3ZW50IHdyb25nLiBFWElUSU5HKi9cclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBydyA9IF9fLnJld3JpdGUoZXEsIG51bGwsIHNvbHZlX2Zvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxocyA9IHJ3WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByaHMgPSByd1sxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihsaHMuZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxocy5mbmFtZSA9PT0gJ2FicycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoW3Jocy5jbG9uZSgpLCByaHMubmVnYXRlKCldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGxocy5mbmFtZSA9PT0gJ3NpbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXNpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfXy5pbnZlcnNlRnVuY3Rpb25Tb2x2ZSgnYXNpbicsIGxocywgcmhzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihsaHMuZm5hbWUgPT09ICdjb3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FzaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoX18uaW52ZXJzZUZ1bmN0aW9uU29sdmUoJ2Fjb3MnLCBsaHMsIHJocykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYobGhzLmZuYW1lID09PSAndGFuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hc2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KF9fLmludmVyc2VGdW5jdGlvblNvbHZlKCdhdGFuJywgbGhzLCByaHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGxocy5mbmFtZSA9PT0gY29yZS5TZXR0aW5ncy5MT0cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXgrYiBjb21lcyBiYWNrIGFzIFthLCB4LCBheCwgYl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBleHBsb2RlKGxocy5hcmdzWzBdLCBzb2x2ZV9mb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiB4IGlzIGJ5IGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBwYXJ0c1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaHMgPSBfLmRpdmlkZShfLnN1YnRyYWN0KF8ucG93KGxocy5hcmdzLmxlbmd0aCA+IDEgPyBsaHMuYXJnc1sxXSA6IG5ldyBTeW1ib2woJ2UnKSwgXy5kaXZpZGUocmhzLCBfLnBhcnNlKGxocy5tdWx0aXBsaWVyKSkpLCBwYXJ0c1szXSksIHBhcnRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXEgPSBuZXcgRXF1YXRpb24oeCwgcmhzKS50b0xIUygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoc29sdmUoZXEsIHNvbHZlX2ZvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoXy5zdWJ0cmFjdChsaHMsIHJocykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5lcSA9IG5ldyBFcXVhdGlvbihsaHMsIHJocykudG9MSFMoKTsgLy9jcmVhdGUgYSBuZXcgZXF1YXRpb25cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5lcS5lcXVhbHMoZXEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdG9wcGluZy4gTm8gc3RvcCBjb25kaXRpb24gZXhpc3RzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoc29sdmUobmVxLCBzb2x2ZV9mb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTGV0J3MgdHJ5IHRoaXMgYW5vdGhlciB3YXlcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLzEuIGlmIHRoZSBzeW1ib2wgaXMgaW4gdGhlIGZvcm0gYSpiKmMqLi4uIHRoZW4gdGhlIHNvbHV0aW9uIGlzIHplcm8gaWYgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZWl0aGVyIGEgb3IgYiBvciBjIGlzIHplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVxLmdyb3VwID09PSBDQilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZXEuZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdGVkID0gc2VwYXJhdGUoZXEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxocyA9IHNlcGFyYXRlZFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmhzID0gc2VwYXJhdGVkWzFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVkdWNlIHRoZSBlcXVhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobGhzLmdyb3VwID09PSBjb3JlLmdyb3Vwcy5FWCAmJiBsaHMudmFsdWUgPT09IHNvbHZlX2Zvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hhbmdlIHRoZSBiYXNlIG9mIGJvdGggc2lkZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGxocy5wb3dlci5jbG9uZSgpLmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoXy5wb3cocmhzLCBwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoY2ZhY3QpIHtcclxuICAgICAgICAgICAgc29sdXRpb25zID0gc29sdXRpb25zLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucG93KHgsIG5ldyBTeW1ib2woY2ZhY3QpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQZXJmb3JtIHNvbWUgY2xlYW51cCBidXQgZG9uJ3QgZG8gaXQgYWdhaW5zIGFycmF5cywgZXRjXHJcbiAgICAgICAgLy8gQ2hlY2sgaXQgYWN0dWFsbHkgZXZhbHVhdGVzIHRvIHplcm9cclxuICAgICAgICBpZihpc1N5bWJvbChlcW5zKSkge1xyXG4gICAgICAgICAgICB2YXIga25vd25zID0ge307XHJcbiAgICAgICAgICAgIHNvbHV0aW9ucyA9IHNvbHV0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAga25vd25zW3NvbHZlX2Zvcl0gPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB6ZXJvID0gTnVtYmVyKGV2YWx1YXRlKGVxbnMsIGtub3ducykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBzeW1ib2xpYyBhbnN3ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNOYU4oemVybykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc29sdXRpb25zO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL1JlZ2lzdGVyIHRoZSBmdW5jdGlvbnMgZm9yIGV4dGVybmFsIHVzZVxyXG4gICAgbmVyZGFtZXIucmVnaXN0ZXIoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3NvbHZlRXF1YXRpb25zJyxcclxuICAgICAgICAgICAgcGFyZW50OiAnbmVyZGFtZXInLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAtMSxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb2x2ZTsgLy9jb21tZW50IG91dCB0byByZXR1cm4gYSB2ZWN0b3JcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmNvbnZlcnRUb1ZlY3Rvcihzb2x2ZS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcclxuICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3NvbHZlJyxcclxuICAgICAgICAgICAgcGFyZW50OiAnU29sdmUnLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAyLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuU29sdmUuc29sdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3NldEVxdWF0aW9uJyxcclxuICAgICAgICAgICAgcGFyZW50OiAnU29sdmUnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEVxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcbiAgICBuZXJkYW1lci5hcGkoKTtcclxufSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///322\n")},182:function(module,exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global trig, trigh, Infinity, define, arguments2Array, NaN */\r\n//externals ====================================================================\r\n/* BigInterger.js v1.6.40 https://github.com/peterolson/BigInteger.js/blob/master/LICENSE */\r\n//var nerdamerBigInt = typeof nerdamerBigInt !== 'undefined' ? nerdamerBigInt : require(\"big-integer\");\r\n/* big.js v5.2.2 https://github.com/MikeMcl/big.js/LICENCE */\r\n//var nerdamerBigDecimal = typeof nerdamerBigDecimal !== 'undefined' ? nerdamerBigDecimal : require('big.js');\r\n\r\nvar nerdamer = (function (imports) {\r\n    \"use strict\";\r\n\r\n//version ======================================================================\r\n    var version = '1.1.12';\r\n\r\n//inits ========================================================================\r\n    var _ = new Parser(); //nerdamer's parser\r\n\r\n    //import bigInt\r\n    var bigInt = imports.bigInt;\r\n    var bigDec = imports.bigDec;\r\n\r\n    //set the precision to js precision\r\n    bigDec.set({\r\n        precision: 250\r\n    });\r\n\r\n    var Groups = {};\r\n\r\n    //container of pregenerated primes\r\n    var PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113\r\n                , 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251,\r\n        257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\r\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557,\r\n        563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\r\n        709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\r\n        877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031,\r\n        1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171,\r\n        1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303,\r\n        1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471,\r\n        1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607,\r\n        1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753,\r\n        1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931,\r\n        1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083];\r\n\r\n//Settings =====================================================================\r\n    var CUSTOM_OPERATORS = {};\r\n\r\n    var Settings = {\r\n        //Enables/Disables call peekers. False means callPeekers are disabled and true means callPeekers are enabled.\r\n        callPeekers: false,\r\n\r\n        //the max number up to which to cache primes. Making this too high causes performance issues\r\n        init_primes: 1000,\r\n\r\n        exclude: [],\r\n        //If you don't care about division by zero for example then this can be set to true.\r\n        //Has some nasty side effects so choose carefully.\r\n        suppress_errors: false,\r\n        //the global used to invoke the libary to parse to a number. Normally cos(9) for example returns\r\n        //cos(9) for convenience but parse to number will always try to return a number if set to true.\r\n        PARSE2NUMBER: false,\r\n        //this flag forces the a clone to be returned when add, subtract, etc... is called\r\n        SAFE: false,\r\n        //the symbol to use for imaginary symbols\r\n        IMAGINARY: 'i',\r\n        //the modules used to link numeric function holders\r\n        FUNCTION_MODULES: [Math],\r\n        //Allow certain characters\r\n        ALLOW_CHARS: [''],\r\n        //Allow nerdamer to convert multi-character variables\r\n        USE_MULTICHARACTER_VARS: true,\r\n        //Allow changing of power operator\r\n        POWER_OPERATOR: '^',\r\n        //The variable validation regex\r\n        //VALIDATION_REGEX: /^[a-z_][a-z\\d\\_]*$/i\r\n        VALIDATION_REGEX: /^[a-z_ABEZHIKMNoOPTX][0-9a-z_ABEZHIKMNoOPTX]*$/i,\r\n        // The regex used to determine which characters should be included in implied multiplication\r\n        IMPLIED_MULTIPLICATION_REGEX: /([\\+\\-\\/\\*]*[0-9]+)([a-z_ABEZHIKMNoOPTX]+[\\+\\-\\/\\*]*)/gi,\r\n        //Aliases\r\n        ALIASES: {\r\n            '': 'pi',\r\n            '': 'Infinity'\r\n        },\r\n        POSITIVE_MULTIPLIERS: false,\r\n        //Cached items\r\n        CACHE: {},\r\n        //Print out warnings or not\r\n        SILENCE_WARNINGS: false,\r\n        //Precision\r\n        PRECISION: 21,\r\n        //function mappings\r\n        VECTOR: 'vector',\r\n        PARENTHESIS: 'parens',\r\n        SQRT: 'sqrt',\r\n        ABS: 'abs',\r\n        FACTORIAL: 'factorial',\r\n        DOUBLEFACTORIAL: 'dfactorial',\r\n        //reference pi and e\r\n        LONG_PI: '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214' +\r\n                '808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196',\r\n        LONG_E: '2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466' +\r\n                '39193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901',\r\n        PI: Math.PI,\r\n        E: Math.E,\r\n        LOG: 'log',\r\n        LOG10: 'log10',\r\n        LOG10_LATEX: 'log_{10}',\r\n        MAX_EXP: 200000,\r\n        //The number of scientific place to round to\r\n        SCIENTIFIC_MAX_DECIMAL_PLACES: 14,\r\n        //True if ints should not be converted to\r\n        SCIENTIFIC_IGNORE_ZERO_EXPONENTS: true\r\n    };\r\n\r\n    (function () {\r\n        Settings.CACHE.roots = {};\r\n        var x = 40,\r\n                y = 40;\r\n        for(var i = 2; i <= x; i++) {\r\n            for(var j = 2; j <= y; j++) {\r\n                var nthpow = bigInt(i).pow(j);\r\n                Settings.CACHE.roots[nthpow + '-' + j] = i;\r\n            }\r\n        }\r\n    })();\r\n\r\n    //Add the groups. These have been reorganized as of v0.5.1 to make CP the highest group\r\n    //The groups that help with organizing during parsing. Note that for FN is still a function even\r\n    //when it's raised to a symbol, which typically results in an EX\r\n    var N = Groups.N = 1, // A number\r\n            P = Groups.P = 2, // A number with a rational power e.g. 2^(3/5).\r\n            S = Groups.S = 3, // A single variable e.g. x.\r\n            EX = Groups.EX = 4, // An exponential\r\n            FN = Groups.FN = 5, // A function\r\n            PL = Groups.PL = 6, // A symbol/expression having same name with different powers e.g. 1/x + x^2\r\n            CB = Groups.CB = 7, // A symbol/expression composed of one or more variables through multiplication e.g. x*y\r\n            CP = Groups.CP = 8; // A symbol/expression composed of one variable and any other symbol or number x+1 or x+y\r\n\r\n    var CONST_HASH = Settings.CONST_HASH = '#';\r\n\r\n    var PARENTHESIS = Settings.PARENTHESIS;\r\n\r\n    var SQRT = Settings.SQRT;\r\n\r\n    var ABS = Settings.ABS;\r\n\r\n    var FACTORIAL = Settings.FACTORIAL;\r\n\r\n    var DOUBLEFACTORIAL = Settings.DOUBLEFACTORIAL;\r\n\r\n    //the storage container \"memory\" for parsed expressions\r\n    var EXPRESSIONS = [];\r\n\r\n    //variables\r\n    var VARS = {};\r\n\r\n    //the container used to store all the reserved functions\r\n    var RESERVED = [];\r\n\r\n    var WARNINGS = [];\r\n\r\n    /**\r\n     * Use this when errors are suppressible\r\n     * @param {String} msg\r\n     * @param {object} ErrorObj\r\n     */\r\n    var err = function (msg, ErrorObj) {\r\n        if(!Settings.suppress_errors) {\r\n            if(ErrorObj)\r\n                throw new ErrorObj(msg);\r\n            else\r\n                throw new Error(msg);\r\n        }\r\n    };\r\n\r\n//Utils ========================================================================\r\n    var customError = function (name) {\r\n        var E = function (message) {\r\n            this.name = name;\r\n            this.message = message !== undefined ? message : '';\r\n            var error = new Error(this.message);\r\n            error.name = this.name;\r\n            this.stack = error.stack;\r\n        }; //create an empty error\r\n        E.prototype = Object.create(Error.prototype);\r\n        return E;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if value is one of nerdamer's reserved names\r\n     * @param {String} value\r\n     * @return boolean\r\n     */\r\n    var isReserved = function (value) {\r\n        return RESERVED.indexOf(value) !== -1;\r\n    };\r\n\r\n    /**\r\n     * Checks to see that all symbols in array are the same\r\n     * @param {Symbol[]} arr\r\n     * @returns {bool}\r\n     */\r\n    var allSame = function (arr) {\r\n        var last = arr[0];\r\n        for(var i = 1, l = arr.length; i < l; i++)\r\n            if(!arr[i].equals(last))\r\n                return false;\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Used to pass warnings or low severity errors about the library\r\n     * @param msg\r\n     */\r\n    var warn = function (msg) {\r\n        WARNINGS.push(msg);\r\n        if(Settings.SHOW_WARNINGS && console && console.warn) {\r\n            console.warn(msg);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Enforces rule: \"must start with a letter or underscore and\r\n     * can have any number of underscores, letters, and numbers thereafter.\"\r\n     * @param name The name of the symbol being checked\r\n     * @param {String} typ - The type of symbols that's being validated\r\n     * @throws {Exception}  - Throws an exception on fail\r\n     */\r\n    var validateName = function (name, typ) {\r\n        typ = typ || 'variable';\r\n        if(Settings.ALLOW_CHARS.indexOf(name) !== -1)\r\n            return;\r\n        var regex = Settings.VALIDATION_REGEX;\r\n        if(!(regex.test(name))) {\r\n            throw new InvalidVariableNameError(name + ' is not a valid ' + typ + ' name');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Convert number from scientific format to decimal format\r\n     * @param {Number} num\r\n     */\r\n    var scientificToDecimal = function (num) {\r\n        var nsign = Math.sign(num);\r\n        //remove the sign\r\n        num = Math.abs(num);\r\n        //if the number is in scientific notation remove it\r\n        if(/\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num)) {\r\n            var zero = '0',\r\n                    parts = String(num).toLowerCase().split('e'), //split into coeff and exponent\r\n                    e = parts.pop(), //store the exponential part\r\n                    l = Math.abs(e), //get the number of zeros\r\n                    sign = e / l,\r\n                    coeff_array = parts[0].split('.');\r\n            if(sign === -1) {\r\n                l = l - coeff_array[0].length;\r\n                if(l < 0) {\r\n                    num = coeff_array[0].slice(0, l) + '.' + coeff_array[0].slice(l) + (coeff_array.length === 2 ? coeff_array[1] : '');\r\n                }\r\n                else {\r\n                    num = zero + '.' + new Array(l + 1).join(zero) + coeff_array.join('');\r\n                }\r\n            }\r\n            else {\r\n                var dec = coeff_array[1];\r\n                if(dec)\r\n                    l = l - dec.length;\r\n                if(l < 0) {\r\n                    num = coeff_array[0] + dec.slice(0, l) + '.' + dec.slice(l);\r\n                }\r\n                else {\r\n                    num = coeff_array.join('') + new Array(l + 1).join(zero);\r\n                }\r\n            }\r\n        }\r\n\r\n        return nsign < 0 ? '-' + num : num;\r\n    };\r\n    /**\r\n     * Checks if number is a prime number\r\n     * @param {Number} n - the number to be checked\r\n     */\r\n    var isPrime = function (n) {\r\n        var q = Math.floor(Math.sqrt(n));\r\n        for(var i = 2; i <= q; i++) {\r\n            if(n % i === 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Generates an object with known variable value for evaluation\r\n     * @param {String} variable\r\n     * @param {any} value Any stringifyable object\r\n     * @returns {Object} \r\n     */\r\n    var knownVariable = function (variable, value) {\r\n        var o = {};\r\n        o[variable] = value;\r\n        return o;\r\n    };\r\n\r\n    /**\r\n     * Checks if n is a number\r\n     * @param {any} n\r\n     */\r\n    var isNumber = function (n) {\r\n        return /^\\d+\\.?\\d*$/.test(n);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if an array contains only numeric values\r\n     * @param {Array} arr\r\n     */\r\n    var allNumeric = function (arr) {\r\n        for(var i = 0; i < arr.length; i++)\r\n            if(!isNumber(arr[i]))\r\n                return false;\r\n        return true;\r\n    };\r\n    /**\r\n     * Checks to see if a number or Symbol is a fraction\r\n     * @param {Number|Symbol} num\r\n     * @returns {boolean}\r\n     */\r\n    var isFraction = function (num) {\r\n        if(isSymbol(num))\r\n            return isFraction(num.multiplier.toDecimal());\r\n        return (num % 1 !== 0);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the object provided is a Symbol\r\n     * @param {Object} obj\r\n     */\r\n    var isSymbol = function (obj) {\r\n        return (obj instanceof Symbol);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the object provided is an Expression\r\n     * @param {Object} obj\r\n     */\r\n    var isExpression = function (obj) {\r\n        return (obj instanceof Expression);\r\n    };\r\n\r\n    /**\r\n     * This method traverses the symbol structure and grabs all the variables in a symbol. The variable\r\n     * names are then returned in alphabetical order.\r\n     * @param {Symbol} obj\r\n     * @param {Boolean} poly\r\n     * @param {Object} vars - An object containing the variables. Do not pass this in as it generated\r\n     * automatically. In the future this will be a Collector object.\r\n     * @returns {String[]} - An array containing variable names\r\n     */\r\n    var variables = function (obj, poly, vars) {\r\n        vars = vars || {\r\n            c: [],\r\n            add: function (value) {\r\n                if(this.c.indexOf(value) === -1 && isNaN(value))\r\n                    this.c.push(value);\r\n            }\r\n        };\r\n\r\n        if(isSymbol(obj)) {\r\n            var group = obj.group,\r\n                    prevgroup = obj.previousGroup;\r\n            if(group === EX)\r\n                variables(obj.power, poly, vars);\r\n\r\n            if(group === CP || group === CB || prevgroup === CP || prevgroup === CB) {\r\n                for(var x in obj.symbols) {\r\n                    variables(obj.symbols[x], poly, vars);\r\n                }\r\n            }\r\n            else if(group === S || prevgroup === S) {\r\n                //very crude needs fixing. TODO\r\n                if(!(obj.value === 'e' || obj.value === 'pi' || obj.value === Settings.IMAGINARY))\r\n                    vars.add(obj.value);\r\n            }\r\n            else if(group === PL || prevgroup === PL) {\r\n                variables(firstObject(obj.symbols), poly, vars);\r\n            }\r\n            else if(group === EX) {\r\n                if(!isNaN(obj.value))\r\n                    vars.add(obj.value);\r\n                variables(obj.power, poly, vars);\r\n            }\r\n            else if(group === FN && !poly) {\r\n                for(var i = 0; i < obj.args.length; i++) {\r\n                    variables(obj.args[i], poly, vars);\r\n                }\r\n            }\r\n        }\r\n\r\n        return vars.c.sort();\r\n    };\r\n\r\n    /**\r\n     * Returns the sum of an array\r\n     * @param {Array} arr\r\n     * @param {boolean} toNumber\r\n     * @returns {Symbol}\r\n     */\r\n    var arraySum = function (arr, toNumber) {\r\n        var sum = new Symbol(0);\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var x = arr[i];\r\n            // Convert to symbol if not\r\n            sum = _.add(sum, !isSymbol(x) ? _.parse(x) : x);\r\n        }\r\n\r\n        return toNumber ? Number(sum) : sum;\r\n    };\r\n\r\n    /**\r\n     * Separates out the variables into terms of variabls.\r\n     * e.g. x+y+x*y+sqrt(2)+pi returns\r\n     * {x: x, y: y, x y: x*y, constants: sqrt(2)+pi\r\n     * @param {type} symbol\r\n     * @param {type} o\r\n     * @returns {undefined}\r\n     * @throws {Error} for expontentials\r\n     */\r\n    var separate = function (symbol, o) {\r\n        symbol = _.expand(symbol);\r\n        o = o || {};\r\n        var insert = function (key, sym) {\r\n            if(!o[key])\r\n                o[key] = new Symbol(0);\r\n            o[key] = _.add(o[key], sym.clone());\r\n        };\r\n        symbol.each(function (x) {\r\n            if(x.isConstant('all')) {\r\n                insert('constants', x);\r\n            }\r\n            else if(x.group === S) {\r\n                insert(x.value, x);\r\n            }\r\n            else if(x.group === FN && (x.fname === ABS || x.fname === '')) {\r\n                separate(x.args[0]);\r\n            }\r\n            else if(x.group === EX || x.group === FN) {\r\n                throw new Error('Unable to separate. Term cannot be a function!');\r\n            }\r\n            else {\r\n                insert(variables(x).join(' '), x);\r\n            }\r\n        });\r\n\r\n        return o;\r\n    };\r\n\r\n    /**\r\n     * Fills holes in an array with zero symbol or generates one with n zeroes\r\n     * @param {Array} arr\r\n     * @param {Number} n\r\n     */\r\n    var fillHoles = function (arr, n) {\r\n        n = n || arr.length;\r\n        for(var i = 0; i < n; i++) {\r\n            var sym = arr[i];\r\n            if(!sym)\r\n                arr[i] = new Symbol(0);\r\n        }\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * Checks to see if the object provided is a Vector\r\n     * @param {Object} obj\r\n     */\r\n    var isVector = function (obj) {\r\n        return (obj instanceof Vector);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the object provided is a Matrix\r\n     * @param {Object} obj\r\n     */\r\n    var isMatrix = function (obj) {\r\n        return (obj instanceof Matrix);\r\n    };\r\n\r\n    var isSet = function (obj) {\r\n        return (obj instanceof Set);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a symbol is in group N\r\n     * @param {Symbol} symbol\r\n     */\r\n    var isNumericSymbol = function (symbol) {\r\n        return symbol.group === N || symbol.group === P;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a symbol is a variable with no multiplier nor power\r\n     * @param {Symbol} symbol\r\n     */\r\n    var isVariableSymbol = function (symbol) {\r\n        return symbol.group === S && symbol.multiplier.equals(1) && symbol.power.equals(1);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the object provided is an Array\r\n     * @param {Object} arr\r\n     */\r\n    var isArray = function (arr) {\r\n        return Array.isArray(arr);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a number is an integer\r\n     * @param {Number} num\r\n     */\r\n    var isInt = function (num) {\r\n        return /^[-+]?\\d+e?\\+?\\d*$/gim.test(num.toString());\r\n    };\r\n\r\n    /**\r\n     * @param {Number|Symbol} obj\r\n     * @returns {boolean}\r\n     */\r\n    var isNegative = function (obj) {\r\n        if(isSymbol(obj)) {\r\n            obj = obj.multiplier;\r\n        }\r\n        return obj.lessThan(0);\r\n    };\r\n    /**\r\n     * Safely stringify object\r\n     * @param o\r\n     */\r\n    var stringify = function (o) {\r\n        if(!o)\r\n            return o;\r\n        return String(o);\r\n    };\r\n\r\n    /**\r\n     * @param {String} str\r\n     * @returns {String} - returns a formatted string surrounded by brackets\r\n     */\r\n    var inBrackets = function (str) {\r\n        return '(' + str + ')';\r\n    };\r\n\r\n    /**\r\n     * A helper function to replace parts of string\r\n     * @param {String} str - The original string\r\n     * @param {Integer} from - The starting index\r\n     * @param {Integer} to - The ending index\r\n     * @param {String} with_str - The replacement string\r\n     * @returns {String} - A formatted string\r\n     */\r\n    var stringReplace = function (str, from, to, with_str) {\r\n        return str.substr(0, from) + with_str + str.substr(to, str.length);\r\n    };\r\n\r\n    /**\r\n     * the Parser uses this to check if it's allowed to convert the obj to type Symbol\r\n     * @param {Object} obj\r\n     * @returns {boolean}\r\n     */\r\n    var customType = function (obj) {\r\n        return obj !== undefined && obj.custom;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if numbers are both negative or are both positive\r\n     * @param {Number} a\r\n     * @param {Number} b\r\n     * @returns {boolean}\r\n     */\r\n    var sameSign = function (a, b) {\r\n        return (a < 0) === (b < 0);\r\n    };\r\n\r\n    /**\r\n     * A helper function to replace multiple occurences in a string. Takes multiple arguments\r\n     * @example format('{0} nice, {0} sweet', 'something')\r\n     * //returns 'something nice, something sweet'\r\n     */\r\n    var format = function () {\r\n        var args = [].slice.call(arguments),\r\n                str = args.shift();\r\n        var new_str = str.replace(/{(\\d+)}/g, function (match, index) {\r\n            var arg = args[index];\r\n            return typeof arg === 'function' ? arg() : arg;\r\n        });\r\n\r\n        return new_str;\r\n    };\r\n\r\n    /**\r\n     * Generates an array with values within a range. Multiplies by a step if provided\r\n     * @param {Number} start\r\n     * @param {Number} end\r\n     * @param {Number} step\r\n     */\r\n    var range = function (start, end, step) {\r\n        var arr = [];\r\n        step = step || 1;\r\n        for(var i = start; i <= end; i++)\r\n            arr.push(i * step);\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * Returns an array of all the keys in an array\r\n     * @param {Object} obj\r\n     * @returns {Array}\r\n     */\r\n    var keys = Object.keys;\r\n\r\n    /**\r\n     * Returns the first encountered item in an object. Items do not have a fixed order in objects\r\n     * so only use if you need any first random or if there's only one item in the object\r\n     * @param {Object} obj\r\n     * @param {String} key Return this key as first object\r\n     * @param {Boolean} both\r\n     * @returns {*}\r\n     */\r\n    var firstObject = function (obj, key, both) {\r\n        for(var x in obj)\r\n            break;\r\n        if(key)\r\n            return x;\r\n        if(both)\r\n            return {\r\n                key: x,\r\n                obj: obj[x]\r\n            };\r\n        return obj[x];\r\n    };\r\n\r\n    /**\r\n     * Substitutes out variables for two symbols, parses them to a number and them compares them numerically\r\n     * @param {Symbol} sym1\r\n     * @param {Symbol} sym2\r\n     * @param {String[]} vars - an optional array of variables to use\r\n     * @returns {bool}\r\n     */\r\n    var compare = function (sym1, sym2, vars) {\r\n        var n = 5; //a random number between 1 and 5 is good enough\r\n        var scope = {}; // scope object with random numbers generated using vars\r\n        var comparison;\r\n        for(var i = 0; i < vars.length; i++)\r\n            scope[vars[i]] = new Symbol(Math.floor(Math.random() * n) + 1);\r\n        block('PARSE2NUMBER', function () {\r\n            comparison = _.parse(sym1, scope).equals(_.parse(sym2, scope));\r\n        });\r\n        return comparison;\r\n    };\r\n\r\n    /**\r\n     * Is used to set a user defined function using the function assign operator\r\n     * @param {String} name\r\n     * @param {String[]} params_array\r\n     * @param {String} body\r\n     * @returns {Boolean}\r\n     */\r\n    var setFunction = function (name, params_array, body) {\r\n        validateName(name);\r\n        if(!isReserved(name)) {\r\n            params_array = params_array || variables(_.parse(body));\r\n            // The function gets set to PARSER.mapped function which is just\r\n            // a generic function call.\r\n            _.functions[name] = [_.mapped_function, params_array.length, {\r\n                    name: name,\r\n                    params: params_array,\r\n                    body: body\r\n                }];\r\n\r\n            return body;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Returns the minimum number in an array\r\n     * @param {Array} arr\r\n     * @returns {Number}\r\n     */\r\n    var arrayMax = function (arr) {\r\n        return Math.max.apply(undefined, arr);\r\n    };\r\n\r\n    /**\r\n     * Returns the maximum number in an array\r\n     * @param {Array} arr\r\n     * @returns {Number}\r\n     */\r\n    var arrayMin = function (arr) {\r\n        return Math.min.apply(undefined, arr);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if two arrays are equal\r\n     * @param {Array} arr1 \r\n     * @param {Array} arr2 \r\n     */\r\n    var arrayEqual = function (arr1, arr2) {\r\n        arr1.sort();\r\n        arr2.sort();\r\n\r\n        // The must be of the same length\r\n        if(arr1.length === arr2.length) {\r\n            for(var i = 0; i < arr1.length; i++) {\r\n                // If any two items don't match we're done\r\n                if(arr1[i] !== arr2[i]) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Otherwise they're equal\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Clones array with clonable items\r\n     * @param {Array} arr\r\n     * @returns {Array}\r\n     */\r\n    var arrayClone = function (arr) {\r\n        var new_array = [], l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            new_array[i] = arr[i].clone();\r\n        return new_array;\r\n    };\r\n\r\n    /**\r\n     * Fills numbers between array values\r\n     * @param {Numbers[]} arr\r\n     * @param {Integer} slices\r\n     */\r\n    var arrayAddSlices = function (arr, slices) {\r\n        slices = slices || 20;\r\n        var retval = [];\r\n        var c, delta, e;\r\n        retval.push(arr[0]); //push the beginning\r\n        for(var i = 0; i < arr.length - 1; i++) {\r\n            c = arr[i];\r\n            delta = arr[i + 1] - c; //get the difference\r\n            e = delta / slices; //chop it up in the desired number of slices\r\n            for(var j = 0; j < slices; j++) {\r\n                c += e; //add the mesh to the last slice\r\n                retval.push(c);\r\n            }\r\n        }\r\n\r\n        return retval;\r\n    };\r\n\r\n    /**\r\n     * Gets nth roots of a number\r\n     * @param {Symbol} symbol\r\n     * @returns {Vector}\r\n     */\r\n    var nroots = function (symbol) {\r\n        var a, b;\r\n\r\n        if(symbol.group === FN && symbol.fname === '') {\r\n            a = Symbol.unwrapPARENS(_.parse(symbol).toLinear());\r\n            b = _.parse(symbol.power);\r\n        }\r\n        else if(symbol.group === P) {\r\n            a = _.parse(symbol.value);\r\n            b = _.parse(symbol.power);\r\n        }\r\n\r\n        if(a && b && (a.group === N) && b.group === N && a.multiplier.isNegative()) {\r\n            var _roots = [];\r\n\r\n            var parts = Symbol.toPolarFormArray(evaluate(symbol));\r\n            var r = parts[0];\r\n\r\n            //var r = _.parse(a).abs().toString();\r\n\r\n            //https://en.wikipedia.org/wiki/De_Moivre%27s_formula\r\n            var x = _.arg(a);\r\n            var n = b.multiplier.den.toString();\r\n            var p = b.multiplier.num.toString();\r\n\r\n            var formula = '(({0})^({1})*(cos({3})+({2})*sin({3})))^({4})';\r\n\r\n            for(var i = 0; i < n; i++) {\r\n                var t = evaluate(_.parse(format(\"(({0})+2*pi*({1}))/({2})\", x, i, n))).multiplier.toDecimal();\r\n                _roots.push(evaluate(_.parse(format(formula, r, n, Settings.IMAGINARY, t, p))));\r\n            }\r\n            return Vector.fromArray(_roots);\r\n        }\r\n        else if(symbol.isConstant(true, true)) {\r\n            var sign = symbol.sign();\r\n            var x = evaluate(symbol.abs());\r\n            var root = _.sqrt(x);\r\n\r\n            var _roots = [root.clone(), root.negate()];\r\n\r\n            if(sign < 0)\r\n                _roots = _roots.map(function (x) {\r\n                    return _.multiply(x, Symbol.imaginary());\r\n                });\r\n\r\n        }\r\n        else {\r\n            _roots = [_.parse(symbol)];\r\n        }\r\n\r\n        return Vector.fromArray(_roots);\r\n    };\r\n\r\n    /**\r\n     * Sorts and array given 2 parameters\r\n     * @param {String} a\r\n     * @param {String} b\r\n     */\r\n    var comboSort = function (a, b) {\r\n        var l = a.length,\r\n                combined = []; //the linker\r\n        for(var i = 0; i < a.length; i++) {\r\n            combined.push([a[i], b[i]]); //create the map\r\n        }\r\n\r\n        combined.sort(function (x, y) {\r\n            return x[0] - y[0];\r\n        });\r\n\r\n        var na = [], nb = [];\r\n\r\n        for(i = 0; i < l; i++) {\r\n            na.push(combined[i][0]);\r\n            nb.push(combined[i][1]);\r\n        }\r\n\r\n        return [na, nb];\r\n    };\r\n    /**\r\n     * TODO: Pick a more descriptive name and better description\r\n     * Breaks a function down into it's parts wrt to a variable, mainly coefficients\r\n     * Example a*x^2+b wrt x\r\n     * @param {Symbol} fn\r\n     * @param {String} wrt\r\n     * @param {bool} as_obj\r\n     */\r\n    var decompose_fn = function (fn, wrt, as_obj) {\r\n        wrt = String(wrt); //convert to string\r\n        var ax, a, x, b;\r\n        if(fn.group === CP) {\r\n            var t = _.expand(fn.clone()).stripVar(wrt);\r\n            ax = _.subtract(fn.clone(), t.clone());\r\n            b = t;\r\n        }\r\n        else\r\n            ax = fn.clone();\r\n        a = ax.stripVar(wrt);\r\n        x = _.divide(ax.clone(), a.clone());\r\n        b = b || new Symbol(0);\r\n        if(as_obj)\r\n            return {\r\n                a: a,\r\n                x: x,\r\n                ax: ax,\r\n                b: b\r\n            };\r\n        return [a, x, ax, b];\r\n    };\r\n    /**\r\n     * Rounds a number up to x decimal places\r\n     * @param {Number} x\r\n     * @param {Number} s\r\n     */\r\n    var nround = function (x, s) {\r\n        if(isInt(x)) {\r\n            if(x >= Number.MAX_VALUE)\r\n                return x.toString();\r\n            return Number(x);\r\n        }\r\n\r\n        s = typeof s === 'undefined' ? 14 : s;\r\n        return Math.round(x * Math.pow(10, s)) / Math.pow(10, s);\r\n    };\r\n\r\n    /**\r\n     * Is used for u-substitution. Gets a suitable u for substitution. If for\r\n     * instance a is used in the symbol then it keeps going down the line until\r\n     * one is found that's not in use. If all letters are taken then it\r\n     * starts appending numbers.\r\n     * IMPORTANT! It assumes that the substitution will be undone\r\n     * beore the user gets to interact with the object again.\r\n     * @param {Symbol} symbol\r\n     */\r\n    var getU = function (symbol) {\r\n        //start with u\r\n        var u = 'u', //start with u\r\n                v = u, //init with u\r\n                c = 0, //postfix number\r\n                vars = variables(symbol);\r\n        //make sure this variable isn't reserved and isn't in the variable list\r\n        while(!(RESERVED.indexOf(v) === - 1 && vars.indexOf(v) === - 1))\r\n            v = u + c++;\r\n        //get an empty slot. It seems easier to just push but the\r\n        //problem is that we may have some which are created by clearU\r\n        for(var i = 0, l = RESERVED.length; i <= l; i++)\r\n            //reserved cannot equals false or 0 so we can safely check for a falsy type\r\n            if(!RESERVED[i]) {\r\n                RESERVED[i] = v; //reserve the variable\r\n                break;\r\n            }\r\n        return v;\r\n    };\r\n\r\n    /**\r\n     * Clears the u variable so it's no longer reserved\r\n     * @param {String} u\r\n     */\r\n    var clearU = function (u) {\r\n        var indx = RESERVED.indexOf(u);\r\n        if(indx !== -1)\r\n            RESERVED[indx] = undefined;\r\n    };\r\n\r\n    /**\r\n     * Loops through each item in object and calls function with item as param\r\n     * @param {Object|Array} obj\r\n     * @param {Function} fn\r\n     */\r\n    var each = function (obj, fn) {\r\n        if(isArray(obj)) {\r\n            var l = obj.length;\r\n            for(var i = 0; i < l; i++)\r\n                fn.call(obj, i);\r\n        }\r\n        else {\r\n            for(var x in obj)\r\n                if(obj.hasOwnProperty(x))\r\n                    fn.call(obj, x);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a number is an even number\r\n     * @param {Number} num\r\n     * @returns {boolean}\r\n     */\r\n    var even = function (num) {\r\n        return num % 2 === 0;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a fraction is divisible by 2\r\n     * @param {Number} num\r\n     * @returns {boolean}\r\n     */\r\n    var evenFraction = function (num) {\r\n        return 1 / (num % 1) % 2 === 0;\r\n    };\r\n\r\n    /**\r\n     * Strips duplicates out of an array\r\n     * @param {Array} arr\r\n     */\r\n    var arrayUnique = function (arr) {\r\n        var l = arr.length, a = [];\r\n        for(var i = 0; i < l; i++) {\r\n            var item = arr[i];\r\n            if(a.indexOf(item) === -1)\r\n                a.push(item);\r\n        }\r\n        return a;\r\n    };\r\n\r\n    /**\r\n     * Gets all the variables in an array of Symbols\r\n     * @param {Symbol[]} arr \r\n     */\r\n    var arrayGetVariables = function (arr) {\r\n        var vars = variables(arr[0], null, null, true);\r\n\r\n        //get all variables\r\n        for(var i = 1, l = arr.length; i < l; i++)\r\n            vars = vars.concat(variables(arr[i]));\r\n        //remove duplicates\r\n        vars = arrayUnique(vars).sort();\r\n\r\n        //done\r\n        return vars;\r\n    };\r\n\r\n    /**\r\n     * Removes duplicates from an array. Returns a new array\r\n     * @param {Array} arr\r\n     * @param {Function} condition\r\n     */\r\n    var removeDuplicates = function (arr, condition) {\r\n        var conditionType = typeof condition;\r\n\r\n        if(conditionType !== 'function' || conditionType === 'undefined') {\r\n            condition = function (a, b) {\r\n                return a === b;\r\n            };\r\n        }\r\n\r\n        var seen = [];\r\n\r\n        while(arr.length) {\r\n            var a = arr[0];\r\n            //only one element left so we're done\r\n            if(arr.length === 1) {\r\n                seen.push(a);\r\n                break;\r\n            }\r\n            var temp = [];\r\n            seen.push(a); //we already scanned these\r\n            for(var i = 1; i < arr.length; i++) {\r\n                var b = arr[i];\r\n                //if the number is outside the specified tolerance\r\n                if(!condition(a, b))\r\n                    temp.push(b);\r\n            }\r\n            //start over with the remainder\r\n            arr = temp;\r\n        }\r\n\r\n        return seen;\r\n    };\r\n\r\n    /**\r\n     * Reserves the names in an object so they cannot be used as function names\r\n     * @param {Object} obj\r\n     */\r\n    var reserveNames = function (obj) {\r\n        var add = function (item) {\r\n            if(RESERVED.indexOf(item) === -1)\r\n                RESERVED.push(item);\r\n        };\r\n\r\n        if(typeof obj === 'string')\r\n            add(obj);\r\n        else {\r\n            each(obj, function (x) {\r\n                add(x);\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Removes an item from either an array or an object. If the object is an array, the index must be\r\n     * specified after the array. If it's an object then the key must be specified\r\n     * @param {Object|Array} obj\r\n     * @param {Integer} indexOrKey\r\n     */\r\n    var remove = function (obj, indexOrKey) {\r\n        var result;\r\n        if(isArray(obj)) {\r\n            result = obj.splice(indexOrKey, 1)[0];\r\n        }\r\n        else {\r\n            result = obj[indexOrKey];\r\n            delete obj[indexOrKey];\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a temporary block in which one of the global settings is temporarily modified while\r\n     * the function is called. For instance if you want to parse directly to a number rather than have a symbolic\r\n     * answer for a period you would set PARSE2NUMBER to true in the block.\r\n     * @example block('PARSE2NUMBER', function(){//symbol being parsed to number}, true);\r\n     * @param {String} setting - The setting being accessed\r\n     * @param {Function} f\r\n     * @param {boolean} opt - The value of the setting in the block\r\n     * @param {String} obj - The obj of interest. Usually a Symbol but could be any object\r\n     */\r\n    var block = function (setting, f, opt, obj) {\r\n        var current_setting = Settings[setting];\r\n        Settings[setting] = opt === undefined ? true : !!opt;\r\n        var retval = f.call(obj);\r\n        Settings[setting] = current_setting;\r\n        return retval;\r\n    };\r\n\r\n    /**\r\n     * provide a mechanism for accessing functions directly. Not yet complete!!!\r\n     * Some functions will return undefined. This can maybe just remove the\r\n     * function object at some point when all functions are eventually\r\n     * housed in the global function object. Returns ALL parser available\r\n     * functions. Parser.functions may not contain all functions\r\n     */\r\n    var importFunctions = function () {\r\n        var o = {};\r\n        for(var x in _.functions)\r\n            o[x] = _.functions[x][0];\r\n        return o;\r\n    };\r\n\r\n    /**\r\n     * Converts function arguments to an array. Now used by gcd and lcm in Algebra.js :)\r\n     * @param {Array|object} obj\r\n     */\r\n    var arguments2Array = function (obj) {\r\n        return [].slice.call(obj);\r\n    };\r\n\r\n    /**\r\n     * Returns the coefficients of a symbol given a variable. Given ax^2+b^x+c, it divides\r\n     * each nth term by x^n.\r\n     * @param {Symbol} symbol\r\n     * @param {Symbol} wrt\r\n     */\r\n    var getCoeffs = function (symbol, wrt, info) {\r\n        var coeffs = [];\r\n        //we loop through the symbols and stick them in their respective\r\n        //containers e.g. y*x^2 goes to index 2\r\n        symbol.each(function (term) {\r\n            if(term.contains(wrt)) {\r\n                //we want only the coefficient which in this case will be everything but the variable\r\n                //e.g. a*b*x -> a*b if the variable to solve for is x\r\n                var coeff = term.stripVar(wrt),\r\n                        x = _.divide(term.clone(), coeff.clone()),\r\n                        p = x.power.toDecimal();\r\n            }\r\n            else {\r\n                coeff = term;\r\n                p = 0;\r\n            }\r\n            var e = coeffs[p];\r\n            //if it exists just add it to it\r\n            coeffs[p] = e ? _.add(e, coeff) : coeff;\r\n\r\n        }, true);\r\n\r\n        for(var i = 0; i < coeffs.length; i++)\r\n            if(!coeffs[i])\r\n                coeffs[i] = new Symbol(0);\r\n        //fill the holes\r\n        return coeffs;\r\n    };\r\n\r\n    /**\r\n     * As the name states. It forces evaluation of the expression\r\n     * @param {Symbol} symbol\r\n     * @param {Symbol} o\r\n     */\r\n    var evaluate = function (symbol, o) {\r\n        return block('PARSE2NUMBER', function () {\r\n            return _.parse(symbol, o);\r\n        }, true);\r\n    };\r\n\r\n    /**\r\n     * Converts an array to a vector. Consider moving this to Vector.fromArray\r\n     * @param {String[]|String|Symbol|Number|Number[]} x\r\n     */\r\n    var convertToVector = function (x) {\r\n        if(isArray(x)) {\r\n            var vector = new Vector([]);\r\n            for(var i = 0; i < x.length; i++)\r\n                vector.elements.push(convertToVector(x[i]));\r\n            return vector;\r\n        }\r\n        //Ensure that a nerdamer ready object is returned\r\n        if(!isSymbol(x))\r\n            return _.parse(x);\r\n        return x;\r\n    };\r\n\r\n    /**\r\n     * Generates prime numbers up to a specified number\r\n     * @param {Number} upto\r\n     */\r\n    var generatePrimes = function (upto) {\r\n        //get the last prime in the array\r\n        var last_prime = PRIMES[PRIMES.length - 1] || 2;\r\n        //no need to check if we've already encountered the number. Just check the cache.\r\n        for(var i = last_prime; i < upto; i++) {\r\n            if(isPrime(i))\r\n                PRIMES.push(i);\r\n        }\r\n    };\r\n    /**\r\n     * Checks to see if all arguments are numbers\r\n     * @param {object} args\r\n     */\r\n    var allNumbers = function (args) {\r\n        for(var i = 0; i < args.length; i++)\r\n            if(args[i].group !== N)\r\n                return false;\r\n        return true;\r\n    };\r\n    /*\r\n     * Checks if all arguments aren't just all number but if they\r\n     * are constants as well e.g. pi, e.\r\n     * @param {object} args\r\n     */\r\n    var allConstants = function (args) {\r\n        for(var i = 0; i < args.length; i++) {\r\n            if(args[i].isPi() || args[i].isE())\r\n                continue;\r\n            if(!args[i].isConstant(true))\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Used to multiply two expression in expanded form\r\n     * @param {Symbol} a\r\n     * @param {Symbol} b\r\n     */\r\n    var mix = function (a, b, opt) {\r\n        // Flip them if b is a CP or PL and a is not\r\n        if(b.isComposite() && !a.isComposite() || b.isLinear() && !a.isLinear()) {\r\n            [a, b] = [b, a];\r\n        }\r\n        // A temporary variable to hold the expanded terms\r\n        var t = new Symbol(0);\r\n        if(a.isLinear()) {\r\n            a.each(function (x) {\r\n                // If b is not a PL or a CP then simply multiply it\r\n                if(!b.isComposite()) {\r\n                    var term = _.multiply(_.parse(x), _.parse(b));\r\n                    t = _.add(t, _.expand(term, opt));\r\n                }\r\n                // Otherwise multiply out each term.\r\n                else if(b.isLinear()) {\r\n                    b.each(function (y) {\r\n                        var term = _.multiply(_.parse(x), _.parse(y));\r\n                        var expanded = _.expand(_.parse(term), opt);\r\n                        t = _.add(t, expanded);\r\n                    }, true);\r\n                }\r\n                else {\r\n                    t = _.add(t, _.multiply(x, _.parse(b)));\r\n                }\r\n            }, true);\r\n        }\r\n        else {\r\n            // Just multiply them together\r\n            t = _.multiply(a, b);\r\n        }\r\n\r\n        // The expanded function is now t\r\n        return t;\r\n    };\r\n\r\n//Exceptions ===================================================================\r\n    //Is thrown for division by zero\r\n    var DivisionByZero = customError('DivisionByZero');\r\n    // Is throw if an error occured during parsing\r\n    var ParseError = customError('ParseError');\r\n    // Is thrown if the expression results in undefined\r\n    var UndefinedError = customError('UndefinedError');\r\n    // Is throw input is out of the function domain\r\n    var OutOfFunctionDomainError = customError('OutOfFunctionDomainError');\r\n    // Is throw if a function exceeds x amount of iterations\r\n    var MaximumIterationsReached = customError('MaximumIterationsReached');\r\n    // Is thrown if the parser receives an incorrect type\r\n    var NerdamerTypeError = customError('NerdamerTypeError');\r\n    // Is thrown if bracket parity is not correct\r\n    var ParityError = customError('ParityError');\r\n    // Is thrown if an unexpectd or incorrect operator is encountered\r\n    var OperatorError = customError('OperatorError');\r\n    // Is thrown if an index is out of range.\r\n    var OutOfRangeError = customError('OutOfRangeError');\r\n    // Is thrown if dimensions are incorrect. Mostly for matrices\r\n    var DimensionError = customError('DimensionError');\r\n    // Is thrown if variable name violates naming rule\r\n    var InvalidVariableNameError = customError('InvalidVariableNameError');\r\n    // Is thrown if the limits of the library are exceeded for a function\r\n    // This can be that the function become unstable passed a value\r\n    var ValueLimitExceededError = customError('ValueLimitExceededError');\r\n    // Is throw if the value is an incorrect LH or RH value\r\n    var NerdamerValueError = customError('NerdamerValueError');\r\n    // Is thrown if the value is an incorrect LH or RH value\r\n    var SolveError = customError('SolveError');\r\n    // Is thrown for an infinite loop\r\n    var InfiniteLoopError = customError('InfiniteLoopError');\r\n    // Is thrown if an operator is found when there shouldn't be one\r\n    var UnexpectedTokenError = customError('UnexpectedTokenError');\r\n\r\n    var exceptions = {\r\n        DivisionByZero: DivisionByZero,\r\n        ParseError: ParseError,\r\n        OutOfFunctionDomainError: OutOfFunctionDomainError,\r\n        UndefinedError: UndefinedError,\r\n        MaximumIterationsReached: MaximumIterationsReached,\r\n        NerdamerTypeError: NerdamerTypeError,\r\n        ParityError: ParityError,\r\n        OperatorError: OperatorError,\r\n        OutOfRangeError: OutOfRangeError,\r\n        DimensionError: DimensionError,\r\n        InvalidVariableNameError: InvalidVariableNameError,\r\n        ValueLimitExceededError: ValueLimitExceededError,\r\n        NerdamerValueError: NerdamerValueError,\r\n        SolveError: SolveError,\r\n        InfiniteLoopError: InfiniteLoopError,\r\n        UnexpectedTokenError: UnexpectedTokenError\r\n    };\r\n//Math2 ========================================================================\r\n    //This object holds additional functions for nerdamer. Think of it as an extension of the Math object.\r\n    //I really don't like touching objects which aren't mine hence the reason for Math2. The names of the\r\n    //functions within are pretty self-explanatory.\r\n    //NOTE: DO NOT USE INLINE COMMENTS WITH THE MATH2 OBJECT! THIS BREAK DURING COMPILATION OF BUILDFUNCTION.\r\n    var Math2 = {\r\n        csc: function (x) {\r\n            return 1 / Math.sin(x);\r\n        },\r\n        sec: function (x) {\r\n            return 1 / Math.cos(x);\r\n        },\r\n        cot: function (x) {\r\n            return 1 / Math.tan(x);\r\n        },\r\n        acsc: function (x) {\r\n            return Math.asin(1 / x);\r\n        },\r\n        asec: function (x) {\r\n            return Math.acos(1 / x);\r\n        },\r\n        acot: function (x) {\r\n            return (Math.PI / 2) - Math.atan(x);\r\n        },\r\n        // https://gist.github.com/jiggzson/df0e9ae8b3b06ff3d8dc2aa062853bd8\r\n        erf: function (x) {\r\n            var t = 1 / (1 + 0.5 * Math.abs(x));\r\n            var result = 1 - t * Math.exp(-x * x - 1.26551223 +\r\n                    t * (1.00002368 +\r\n                            t * (0.37409196 +\r\n                                    t * (0.09678418 +\r\n                                            t * (-0.18628806 +\r\n                                                    t * (0.27886807 +\r\n                                                            t * (-1.13520398 +\r\n                                                                    t * (1.48851587 +\r\n                                                                            t * (-0.82215223 +\r\n                                                                                    t * (0.17087277)))))))))\r\n                    );\r\n            return x >= 0 ? result : -result;\r\n        },\r\n        diff: function (f) {\r\n            var h = 0.001;\r\n\r\n            var derivative = function (x) {\r\n                return (f(x + h) - f(x - h)) / (2 * h);\r\n            };\r\n\r\n            return derivative;\r\n        },\r\n        median: function (...values) {\r\n            values.sort(function (a, b) {\r\n                return a - b;\r\n            });\r\n\r\n            var half = Math.floor(values.length / 2);\r\n\r\n            if(values.length % 2)\r\n                return values[half];\r\n\r\n            return (values[half - 1] + values[half]) / 2.0;\r\n        },\r\n        /*\r\n         * Reverses continued fraction calculation\r\n         * @param {obj} contd\r\n         * @returns {Number}\r\n         */\r\n        fromContinued: function (contd) {\r\n            var arr = contd.fractions.slice();\r\n            var e = 1 / arr.pop();\r\n            for(var i = 0, l = arr.length; i < l; i++) {\r\n                e = 1 / (arr.pop() + e);\r\n            }\r\n            return contd.sign * (contd.whole + e);\r\n        },\r\n        /*\r\n         * Calculates continued fractions\r\n         * @param {Number} n\r\n         * @param {Number} x The number of places\r\n         * @returns {Number}\r\n         */\r\n        continuedFraction: function (n, x) {\r\n            x = x || 20;\r\n            var sign = Math.sign(n); /*store the sign*/\r\n            var absn = Math.abs(n); /*get the absolute value of the number*/\r\n            var whole = Math.floor(absn); /*get the whole*/\r\n            var ni = absn - whole; /*subtract the whole*/\r\n            var c = 0; /*the counter to keep track of iterations*/\r\n            var done = false;\r\n            var epsilon = 1e-14;\r\n            var max = 1e7;\r\n            var e, w;\r\n            var retval = {\r\n                whole: whole,\r\n                sign: sign,\r\n                fractions: []\r\n            };\r\n            /*start calculating*/\r\n            while(!done && ni !== 0) {\r\n                /*invert and get the whole*/\r\n                e = 1 / ni;\r\n                w = Math.floor(e);\r\n                if(w > max) {\r\n                    /*this signals that we may have already gone too far*/\r\n                    var d = Math2.fromContinued(retval) - n;\r\n                    if(d <= Number.EPSILON)\r\n                        break;\r\n                }\r\n                /*add to result*/\r\n                retval.fractions.push(w);\r\n                /*move the ni to the decimal*/\r\n                ni = e - w;\r\n                /*ni should always be a decimal. If we have a whole number then we're in the rounding errors*/\r\n                if(ni <= epsilon || c >= x - 1)\r\n                    done = true;\r\n                c++;\r\n            }\r\n            /*cleanup 1/(n+1/1) = 1/(n+1) so just move the last digit one over if it's one*/\r\n            var idx = retval.fractions.length - 1;\r\n            if(retval.fractions[idx] === 1) {\r\n                retval.fractions.pop();\r\n                /*increase the last one by one*/\r\n                retval.fractions[--idx]++;\r\n            }\r\n            return retval;\r\n        },\r\n        bigpow: function (n, p) {\r\n            if(!(n instanceof Frac))\r\n                n = Frac.create(n);\r\n            if(!(p instanceof Frac))\r\n                p = Frac.create(p);\r\n            var retval = new Frac(0);\r\n            if(p.isInteger()) {\r\n                retval.num = n.num.pow(p.toString());\r\n                retval.den = n.den.pow(p.toString());\r\n            }\r\n            else {\r\n                var num = Frac.create(Math.pow(n.num, p.num));\r\n                var den = Frac.create(Math.pow(n.den, p.num));\r\n\r\n                retval.num = Math2.nthroot(num, p.den.toString());\r\n                retval.den = Math2.nthroot(den, p.den);\r\n            }\r\n            return retval;\r\n        },\r\n        //http://stackoverflow.com/questions/15454183/how-to-make-a-function-that-computes-the-factorial-for-numbers-with-decimals\r\n        gamma: function (z) {\r\n            var g = 7;\r\n            var C = [\r\n                0.99999999999980993,\r\n                676.5203681218851,\r\n                -1259.1392167224028,\r\n                771.32342877765313,\r\n                -176.61502916214059,\r\n                12.507343278686905,\r\n                -0.13857109526572012,\r\n                9.9843695780195716e-6,\r\n                1.5056327351493116e-7]\r\n                    ;\r\n\r\n            if(z < 0.5)\r\n                return Math.PI / (Math.sin(Math.PI * z) * Math2.gamma(1 - z));\r\n            else {\r\n                z -= 1;\r\n\r\n                var x = C[0];\r\n                for(var i = 1; i < g + 2; i++)\r\n                    x += C[i] / (z + i);\r\n\r\n                var t = z + g + 0.5;\r\n                return Math.sqrt(2 * Math.PI) * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x;\r\n            }\r\n        },\r\n        //factorial\r\n        bigfactorial: function (x) {\r\n            var retval = new bigInt(1);\r\n            for(var i = 2; i <= x; i++)\r\n                retval = retval.times(i);\r\n            return new Frac(retval);\r\n        },\r\n        //https://en.wikipedia.org/wiki/Logarithm#Calculation\r\n        bigLog: function (x) {\r\n            var CACHE = [\"-253631954333118718762629409109262279926288908775918712466601196032/39970093576053625963957478139049824030906352922262642968060706375\", \"0\", \"24553090145869607172412918483124184864289170814122579923404694986469653261608528681589949629750677407356463601998534945057511664951799678336/35422621391945757431676178435630229283255250779216421054188228659061954317501699707236864189383591478024245495110561124597124995986978302375\", \"369017335340917140706044240090243368728616279239227943871048759140274862131699550043150713059889196223917527172547/335894053932612728969975338549993764554481173661218585876475837409922537622385232776657791604345125227005476864000\", \"24606853025626737903121303930100462245506322607985779603220820323211395607931699126390918477501325805513849611930008427268176602460462988972957593458726734897129954728102144/17750092415977639787139561330326170936321452137635322313122938207611787444311735251389066106937796085669460151963285086542745859461943369606018450213014148175716400146484375\", \"399073568781976806715759409052286641738926636328983929439450824555613704676637191564699164303012247386095942144825603522401740680808466858044/247958349743620302021733249049411604982786755454514947379317600613433680222511897950658049325685140346169718465773927872179874971908848116625\", \"1468102989495846944084741146947295378041808701256909016224309866143294556551407470861354311593351276612463858816796714569499021375899793849136855085849133702029337910502448189055357182595424959360/819363879309286303497217527375463120404739098260200279520788950777458900438307356738082930586032462601215802636320993648007907724899611296693997216938989854861043298494990214825163523387600982777\", \"5896704855274661767824574093605344871722790278354431422729640950821239030785642943033153793245906863203822369276271050164634206965056233097479117980782641839669/3030306850569309344013726745100070601277982132543905537366562638553198167007159067544789592089960911065181606283478843359856123992707598685058297067179343872000\", \"76631772943534985713873427262830314617912556928476573358548256872141516989538374761909611879922349479420014771499018155447198112155515453671128814488139633810493264352294560043912066253026059140653027326566801398784/36852092933388988649396042883218509607503204211148493545892849595498822817623842579026942621098851631842754395231561679671400197056377380063233740202370686144673585955581403046886083948450136247134308381940165804875\", \"3159076083816399509754948610929467278257473888282947311280653574634802580912280940686954763313882823327077171624015737719617373932318151594325834524000275847475866299387913048/1437757485694188822758304467756419845842037623148461107362957994816554782989250555362514354661961482939226272309026092009962414616417412938087494467254146002233028411865234375\", \"22266067259907364984531611601870291368272674573653403965630628996687370994139884833897773468149149664829922302484782423514167405397665098388400450149078982462318781750661005833037235183394221496186539779712428265837926417581952/9670030144664428565128962309657100138096047028794689249320859276197340398920725569428532293373676415359965773460364494998334259893079003125373872108770534788283842907318071170285038777091588292539102269617376180390982915567375\", \"14604654564989239958569331443385369522850975185358647132770022716433280072271007767111036877803328768910274400515590151934676819262085211828028638417329558229123989556376108454497813055/6090614019162516693013973409650613208227889078878781039105047015752493519149314227721984436973374032279421344818329285207124280297611253861173835238379831004010748379874393292231671808\", \"1901241885407696031217292877862925220917660047127261026827869027159993239567933534052663335498281439239753018507182016153657409777749792228538380379703411298411623469292891476969894084838876001545818141543890273256985768690847587711270930688/765116019778838839812655402103512685695769161212360553099732689795578904762091216998790589926057819838537805856579109910198553330075924857419395160755642371550113347465300208422126945265887065434116781678702741657275181694851670325469434625\", \"139459806786604751793737926146840623607010208216289543036026206208962059593900745886202214788747453279179283344350478734275973878932538430194363355795823581315329311220701640235653288975569812161436/54371368534412517053056101353618694718215711767266376573138772968257303578467926450212293233332401067673270853953399269852376592855992724934941173346260129257754416412476202526978443681584633116375\", \"1045669091124493070709683241190022970908640501171378776604126771144008324358233819560649021940145166254659028524319517244711645162132513416238958170819347361185944945680269442845829390112062101255500836072082817820950448463314034677353723256969344/396228259004446234921310936915931611736815598535963504660076315228798989932959459406702091180060429080345146735173591749448509810270759531977278642135591672189002006272326131885315743181289970885337574780897529347356567086535505950450897216796875\", \"9912919238915437302006264477931031611447467070103973106567538528951878797932559935860738745374437522819124347510590800370471910492338584284092534264608801221235029062881964101996762011296996851893455828946521/3660537472668264151218961634689665210933936249986285290553357254224360417386515311493310199319523687171757653216994741150377508234317025158302057758196429623723072084157928224798322861732880034847243894784000\", \"9263710175433181746575186369318246002919895649622127410824041370079225200282403368319370743363303164313395723904510539050157032684710468364067204876434546848634842333436957245275217583248805993142227630297924119330553308466662488683624783307023014909360640/3341177182697517248552428837661919299725031035849865632511882688786226888137634168024976033652753689210700218163621739078534353578510364301481093730054725078138658805025014615651043313990684347632166030359086885561104034510990826655289288319840595753002771\", \"5116082230713622171832327542439052727465114322479570603905499496221224653983960598946033081212909066917137546065542953865612718836914393275681318667667521726785633638189373998191090501201427906618075889744489190209584/1805752553736060443820406101277706970767657006346276183748749630179442318063568286372320188433843729960294965366346522303898609655762491623098453269916163621089005711823488749297418113474056676109581110715068124438875\", \"246569125619713282434448566970352231845414317018379160824176638351574938993535464763890962336882760882398479702237564384291290459961036068916857265499633061660562532011248501476114401629839742058389195725393702000011860799793778295606988057303225493814005789533570432/85307063020836305797178273029353623060860009152114361453434032434699636078115114412588719432277441055049132559782203988387794711585368296817222565434951256788867244687081233632650953850383220864394261763844194948389861147622944651546912394593164406926489862036343375\", \"133672026303452911046163998480860917119290576658330909785707604886881155606725822685088929236266583416708668502760907677019598002175122453170574729028452721476464728566191464897928696630979863154661704374206171469014225143/45398130975270785045482567762871405072140548998125471025451666500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"6041693953360002800224091673336562508913199995987479264605216252220579740134601435770085920869376641180763419907442721705887169884230643795126568815123647603047739799302562095542459344811429882053086550900803768964612193941424128649976704727183797495759082741166938351872/2016766992122395667828553277997478570503475626107286343497917705446132017125079612756035254750822860815515899557855166824523851779156336235294914777307802256439645525835223691751931866188957324792276149549076500784191791380803500156776088683900346065830066370370083309875\", \"705868391597244582764749229356331441978820024796066870551110486625729826111158236686696326058778874201639006234449557592353247542995871491078308187261304930042019640830629526023972693107193897009168955674240659026247094657679060/231848642748474339277532000336338632910990823562381469441716922006107433404523316252618490265927265734670539384485699132080062215196462178933963957679882342083893417545858074378754089719547920901917516016346211301054206383643383\", \"101832160604157943093944673541651013907278188571533075311673249923948856034633446617630054761681006062910980371900782781226979391765818325065031889334563981235894369036439929651260587335544056975715076598739977065390678221999918899003881778449092038750712969437519295878491018112/32944277910571666002449086492515464541550138004002141571670657643770713783329063548790202120805341989608877739811787937782240802963962520261844114327432160788193314874913687387269408387417806176202979244637915812905426565263196954203487934225589622864145960079736633434831996625\", \"10655703119271468913597640479490594180964700448340778168715956712130636958373270202484276402718566314881119559090842449610957974112230306343486091910217340665146602598568991520563987490686996746558858366002301982443029430290679385551/3398412687366638541233365137084722368200311117891192348532156645374786104142009695796409107380345795998400850838706661851176885183144928701608654514812261697598380070746520197171576610572921007069104300695592751543563472456384512000\", \"1903039332876763837419920240543738799531131775028971323439870868730321221615515008394327723508670975623498588291298064320786970626232668956372004004897872810230178526101184611242511193415796638694370503100219710864543168952682617801833318493436174387568067811938490953495819438108686336/598806534367503338307287246320963280558134937382149405305466709787179429317914803617527827862441615350396864359976273212272586892074799651088317544101755361439294687323233086696182687664637422796995789967075271448560870681210580691574924544896656175563265378514188341796398162841796875\", \"525573915563826130963525826191411949262846916750432019596028344808298471293378917508549164993368392834023782480702893643486699787870059946429810070222126260200026332874480239090370088123833491499400991181659445914352500247596757005142623368/163278727324937389095822405034435687776345799835442022795533783889356344755225815267819508608559076191292900367982490827396869405536484846115955581043091229202052407483776587687967125885665493681707461345895999542381476164157058393971431375\", \"9263815657177858787273494705338516861045771674838057329170239610953039987023429736752079544014780707408666628475997291124805562998227296677616204140605356257712022384368492575381355563976330347792504605666631512343447560301417325154003481040250148561839861837778597346623630046623751094400/2843321709948499955095590862256744532227698001408929142548057792217790532624003190447363578048562448168721539177458065482170148482375585867230123873178100117094533143052886527452665480614620123764036974180917207421482431983407742154634391264619615289225747664532332469783301704643254076601\", \"407959339726114455622180187758753007349209016396248763075759257357925636039752474207685682218422721827857994768023399625060206708378433960993946156803948655098667156937949174400873748557248801874735834957795040139401560494087476967548060208243867/123780218751812156744401121690996305978134694678934447237402511116731459214498784497436358160964198336874043702652746834763131444030185151143987331404604087778514863973633941401826334750268416015224906056576641018962863645043976537664227639296000\", \"2547676391598917379516698439971914695230548782904479778605691338364453606537643088857116141939170899135026552016969320061900926954008522781162186995856580955090548471448276736878300717869625651893741316530109438876067419826217901657017506157997588944233677467357220316084583383623602865379325184/764562034757392298786420374672266498815021229519853724850874576419885380830752931701831256959159800764672605004880389358601658343203513177084389490286723240185146570925957286083025676875197029662038213216541352875570101363668917766225709569356861275434470568767077844675593176178611021135573625\", \"186545352286463730559933346565311535598243666022232037054735807289501173444103692309735768703898330430135399033529355360391658728987379385732098960609744313878477967971557204207043802935782878745271859468248704012618254203101767841517569443555143252/55399179641621656233589820996143825959365789093262978988289445625153099592463372579496245442338653053662134699646413817866770218574795378644415019944304868289119443774932782235638737888469746745621382139263856603239588594078668393194675445556640625\", \"664884440164786473344854955309049113269357314957985265728106924238588705533437169796551912202931185746193155801905841712503407258166135075966280435780812714252670362202091663287095423712596462690753468682634261029392794173636943978404002804413009590005984736612421172979101972556772005594499779860608/195485517776407145286424460448995460754674039560651791192647586550615878988380153730602665795647187884543361218962125172808792176382956599256188706636727418572541254480798303566840010217729386905041217793614214518363859058348249961790104618910877813067510758225302884815410347238200133693756493703875\", \"2614957283934314904315471338485451166053664494383241929385424599389309215073267052860464009981063483440201193771607520572077231889699858482582363845275452280606276949653970992719332472370351170732899676316967244504534154616036371979031399425846100527685/761493664432749089312665480773496290658029971027686543404885407644062485746072719559288231362060149626237939029641098328278650939665665969011529293869562636656650999759724704272743235210867676873525147820749560155294022488994426729939894753293900972032\", \"124843380518493746761140367283007507854364503961156704095198010255465940085534099747297600085903814014415830785663764373057896014399822131175202342399536439284123918855893825207202244831315575594886675813256448846863723093240955901916229136393454605455444105444987028391748121054399538064686074523506176/36022228212051654395480210378626648518430280334458144892889271272122662467638331091863215146548048144675657239846337165813938424387499358852301016926312083940212100001220180762189978024821166744964908871443681332664798940660421469519997746775275873085770018269706847741064037876137315001228315806659875\", \"827992369063043155578730871896750570951766628472810506926098505028264552046829097082095665194000002802661600196840639204300804225352337632259980703832713031790922485730615305441309917696044954289187837653933158950774246017223571461858939407386087081525130831392/236805932823686534991153393869288530368011574665859226704279685567723830696754821658770176385138917722808377962346690757191122309876922069867472518117628639913077442806147910884267694879089753138429767401700283014143248445966474839193628309668702223994071394625\", \"17347276886878323736540051321582548724378497839789943634071026331001588645519865992773157565595886250230140452154269197770615097377486013097979087647774513500701793885978192218455687078883766086309728287172567466406449372659680040183273634701092561727514713494914793425407149186041796935055187281744386432/4919325621804683623339606849970832094714371903709195539440424738973575902329797546592497378000858196173718145883783709223158260700365224756081275272021856393735663399552166737690038832550853145831185979094979556715294990257315369124065787473707136464772247917156232366320267601622617803514003753662109375\", \"137984231830526866236186357461458917020538108058615632801298091031540729111527734872044790487396302545910108285921421417358113055522725197998483383380192391312304647004240060970929072498293210057120617332323445379424867965764749534125081131327565507524502163460761/38810445792642817561168950890315210470940006613819790543653745327778579787694809782601777514116858514049585074667085399925278459138508514838268321349069481334967221455722811414399738756151414906092225265355449011152267068726417045644222323488445626292574879744000\", \"746567120547823334914136339633766098626636643449144032626270358619125402826113269699709721071135471625588981126637674402048519990010499180844665151971356149292818375448504122545400227696621572263621729512461528550588108384619064912224884465737417596190735966915167530332762203074440688676123756162572829692160/208334337057923929636884170505570363171441147899816815785150954417598643614152856767186132467069365605496210036171429712485182162940460120834349006784956522600679357307849981862006710239311750261522832996877712350330290831638640913932265004107623954913155144975252743257846945609734368518424172846119306643431\", \"64649371728330695076928013661001819989330953381731372450140483779536126948957993261299287753791770622512248630224724990234903928056275080682537641377393210728546364176267034339221558641084730052304770498929958838997239635790469536857863963589118888238069738647239076/17903951498200212327802847425913723358452100686246224008745414214690047078122925247086521362329833307849817944645647750649290248110509395628305970523384831671737569872597295947593410067364379687588919135621621162007748635920864926867870502568935739725312687094047375\", \"2454918942158003099688922026016393688092399295166304634317616773083386087532869193458590448918958337530406410803840837646465522656670050113548208618655070231274778592766244282964463702354872753657766121825196898916725498553882689210280080206627916046484942827487726300822318764058084323314109595329304407466188383616/674880185931325925966586583820010578979699141814417326552629206140252348822939845006845669570885271576698771404162512001549922909048916000017837898649100825976232784446638776021483802989797501705685620612986771521390439936066527738682396560462899753657942715306792783283782238662155922082005591512296007820682995125\", \"74018558041066162916454010680594042518462756234254788158141115244349044958441521749277686851928706433556285971088455226217644009628399441967508838553345152310730562224910795446341601049647392069373970101491741830623078126344928804029524181578945586663110848142571149861/20204153620006780689923328634586091101021423979622170579036140596085566172775051595588438592742563923428900864000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"2127032036758045513335690185608563023954009095206088224487365541995326714285119384743928987635752931664240752323937321097955456543854943206092931247498833001499955456190701695430459583885125382086777607021670447795321669948733328973350279846928613949120929250312666393359442423066212311060931469017737106028339882830848/576612418511902928757340062840968526862381326698309578771238715462180282212422302261044980131594522407066369222998903808960617461164985318633518680304995784614308979881735537678182134128319596636920719106506829571072447362052319438091347699720147003209417806230149598345068078717948025207635448205253184540936478445125\", \"35289653975561083576641954928762116897061274899517309102784750384002335187117263273488751066569234386120759866204372398611196356888479036949053282301027789530999737306501029700128744408015642211359442183943916106790666114870974212159410284751571905275610921784716184508440/9503006066880728386808143045924119024212377150217533250562188228062174064693375135306438120385877320162710918716613546077156389583384656340709638430674364232343609717735574035535102953482366914421205216675248471695111720986346092738728929878538430662191272737183832556131\", \"102633551023964794485575491065909467125458972250222581133681080524371507544152979467328048718122409841060527545925136196267751819689935599599321090571687632103850847605493223603751038996548520557330016046032671961857623066292962260173840972332108111505971231021442896036760967107060309991355545554631003681544611731245475968/27459658121882266328752886605529964804078316737648012166874496015808620265471203512606463219297059547428855195782384236337998738233668399173746663289852416697917397644234441300570212555870401420579737973722145663287124151049692290432756231390864184491891697469874600345958989433125942336757049639797225309327019275689074625\", \"10034393558388390065766795008210457368713365491566387292163814915435906649268119060550511145023450790393353937124495488860451123302412204483570913557762460385297770427946219119911920640306914453207097103853766023934602534502476962159682750262143380527529536498215384467975023/2667919902603322771586358077760621955455470781865624844984169443739075976572061827709528710108877015489050369589117491611045518221354793418884447632063538994046714401229510497599783726376490260140723032102883617341970952663947646017489439179953454964374887388652792446976000\", \"248528145263843375390386172800048509380966183384567983242213959113927668429802237067505890436957693495616107089384741585283620097982859345081736730899912519273262934785992235852866637878831878448348444611412764161078458068549719800733237024285525816723480868704742804077255242682077291713092790250511567621735004237450946304/65676865669148624809340872151906045781446981664561196686217551358486802274698228825404698950974939545099727242259547145392352658637333562345477931951890984276718673618736565926663528625796412420753961231404680876558659735251469326707567479071881966875336951133475135427640218972722939427821842173216282390058040618896484375\", \"7805448718805635696495809414501206964843262114470109146341305656318015059743127114324245035489577134938579856003956861881125856595981500593426840968087618241785931128978516340812066502964561231235073012672356530509663384739132686548934288703179479011016719045530855033205271548/2050525178024039744126592505352202216905491833360272553169520915020715464206141942151086176509423406413311520838568324134077402841030113427309725873344806030836314500267104070131451720947531994814710189000076651895520222646974590481497382830325485174899169093049299764813276375\", \"3355325071293197839434119105039673324264765809771192815982246040415580387729382404624613875653005261578877047405365032178619450963731719777167015959920645055600439987161800547901539269321100559393048973255388860193948274255340335876890491746900991668165565729269698196233805991206691196045182214641935483083662356666996922240/876402579119117579582569839757462461050855174353108858954282915644790659429341853404829661899850841645529640454766173209897510988090318303454542547519850473808789222552969933222203420847859171250332350076509996295844203965564448154484566493395403967626596213792922784509892086361572955175655987334882030766001799867659814117\", \"218871061991045868372866381545267589365410350294028138778572466235486397478028823720846191998825628156716190463263492304639890659254282445466806224943413446008645087186307985343574807361972238230520975439736199291019544576443791916302825193643774360055545186783819367378492631806297/56849560726416896431557940314760680962653658127458002233782028041537121216487790008085876994020812492987733987414743604239935223783349870516284048368761617736127892160849065895223288023531930411718807065209903593668117085505482007061969339237404945180379460053180570404846043136000\", \"5008685108365226931582937964451700746853986170633433728409171904803795018146152804690759530990140552460596075588463394200510044617816085275660078502126507209302951286606953039953843685800941558212440519542602092919776366067720586295390886070120828199562643208637974347390938772070049344991272621102622931576339988103674070876518912/1293888539680354282541277646947380627241979967611883341823378331667976045287311988103163380651334828012840330710760757271860219584371109472132211215957402251594055009937397184768184517621978947384029376766290498101728971145633139541827544539988344772578184316843734267915665730981857376872622787627370859411909330227080697966353375\", \"15388340113525711660227566446101909585796746979396093776960989868457211684028149502578116456785221720682202816140911944661051001675127262774824593420825587319436537346311831003212424497488485098543512314062112948777572038731823948224734505930748371522309451168088057190162878224801232/3954220582960831691377435160890656173654063611768428458807273708040518769541211737927975894584024448193835165167801976423275767590502552964407494549049777006346189436817215329891530811451811864579644894987864267389290848598289794977382504890216219362031324635609053075313568115234375\", \"5099039333987561374222193551155323470675617979816941646196895589439391685938046865391119484510329634015275893520725135141878751153360264368353595348921951280561029028912953500944814771064409611917475818956659775131751121312316084465321917769679881052144364834485866477379437705913911371481828140817759401117780199246301705600020671104/1303503600297679371136943454060319958680553228879031326679449263682048703103464872914972900105569835004878963701599765030590097739639045890060548760692125546754294514068052902543220382104483822438283040090444827980927544440984823535260277595466339403795403200720622852069244768910603820007632395190204569927612348189089161551951106625\", \"4902837141334073026145827027361937996261324349722726869116185158777439337041263482852376194988371853413467559557923410949898048139830183335197992754748294810838187068126867611615800383834975563313220497573778480109264178673389149671194149749735833378557143135481387904961537942569904075/1247045310545991266291285730016853118981099516935251861146038369985109288084420528171217942065832292739130145780833406014673689119563698528225048800794718789218267628507713621235056538202070171596177775095071513194885568843375526804796016261173388452184505503341132236719484809714335744\", \"38114743522716832107917466438257616720476488812538316101658139632867788464381862291240727309611460187159930652186486096300862388591521625093237019662273764387591494074792574929490381910446287947994150655077877204446864004067956087975012773988833339521775463977233068498404144221045837190392670308437391686081418318624745039402145439223552/9647001083383999453668111809775451078976046488746916070976218645431946648087171586252172936600115032316383427265217993193444199863138429602138841976586190525451324093772097241349417938578878934577091671046050326087898259692917931230974174799815198493279413438192301437068820185757869608523761456160341754512329264442115351926967120404125\", \"573695055225225727008803730767518906490704995929177617646275646884555707960986625481944101622708415415988844740028718027554452662358957933526173824325955904005404113684003841990198157072540659184995738719040024647370869010473254071681533880576462368600901824622431045529064651675640055917092/144509482511118816399089096021290587489594541280398871255876563615464628718527634679330291741479135415168539765887291789615790513527330600394937614433502341116068305347468133950204152174094704092402978083370792135432486240914953928188835819767755172666693219213868545854371103120604946200875\", \"23876960329653589647925126180903391687666378233201794403339630995420215267415575142266707357255726330536094448314199602616026935251126469221925945960901748679919435908556550271504767784553484434363646489174587463466333864577705745452492395785557425904735048180164697040313528831173448025400634629163795223739061661461986923675833880378496/5986312408594306954013526197465608559068621248896320652512228238115589875514604632230098997609482248000888567135685167138762172475788060284232459813998201719590208742091697294562538265829954186149162974972471533202880368317237508987477069872431064075005305838801862900501819963793062041081601844759452202282545840716920793056488037109375\", \"58168289917567723171226992383559866214094157894992327555495441698028867727845766488121900626912848698952863438654895252811583144479300382761129433911280049009362667380001406579175563745824368613319103673817094498117944856004415812877213722455299491145649879676787079744410765053845551958756701/14517067289347903655500020160671113450349743650636953726251191692074385521975132268313263723831804150872238173602847065423463131917373356798750100313145228608894881457107689499956903046984443545789053438946050974567665049237414588435796381674590098629779384355275820782532479708807512981504000\", \"728621890568281859295409481422447012528302594365693410763821707074444799793690738137592101239862736313347273167450056625929591960610208335290882047413011571781161008296084630072829079783328937418641417642857196346026366370059522990813537731394823630207433267854616768658990289454635793326766697884798538576055949457122067828153655416688640/181030730759516991863708593747964787874073354051675597050399087612142539517308720603687322924426591889179726492403913356461908748733972707460063017057809060190437917851790767968877215795679844983288935075688219234885360839984681619084834228226744165610073685719017596630302462070188937998558312507638434329299017584329479516410907786681093\", \"86855946923438322218622470067224691860808273886184997065663554841573982963995340977083049132518812923329423480393306918856650577072525633920456721265953575424233701929892019410099166322511413146891121248381648145391642571638857576890568882512129960291171866772665863159474602604647289052079991768/21485753507365901947528588896402264670781310878547726104482740647554738151100954835784115119035980523529677083504495839730499664052882400915208251594384038810917282207449860876251558307288700200910747338758723324686939379138206117634546981163355060740270734146780942696291669461182599512320099625\", \"2158989152301022938148680102142188531448821359505188055264665167313418619665693092337665573150374231484840948447637297247277576415460889296724813940128955070240137590073233263168835678714131062764247434144994737610229909964847568491446606012581370840699582055341626266533733744293929658949697805855362114229666626620766245630122333733703618176/531794915405164005613733454597931482878479882704956110685223892325074211694837836221759995948610212818642789132749082430059593652854659130217225506942675608692701447738732031302987802196501895840510235161825501235133794449421919927396142470196961877376701957829921152848178076410141813926924749057304222282687697297216661687583257901415465125\", \"139432548574396829074586704387656697097760057897628994548358619815052936481650396157428747411173567801047221928593253479330480454469358220685854351236980383914223693722868233819483137401339800304943891968050399345430243790898955416907228948287367356990263740207046902209563417267686591994743547621/34201151688775214071963206765436083445901621442002061707492082843232231754829227303539041286301398668437202547003300396162741375435703188500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"11008517174872833286150985180322584448162884832099344969609291070844193524816852920942383850580217443209402836100467940651581092350600329145627967515818684442171571156446321228596914355704205623857871497315955269266498229823278800717909321269179839084452384509142712677235552103459737790674103994445173074670347080506698168482564009465276165824768/2689223396936080856855299215659204161946704205931885125148201643087176556822542895325191478283706585400237901215485150928036895428721912118467760766508162631903585126377676412573187912443878232521444786090510891599171741773242011017926658231638022943018461086517502584854390836347781674626615709751386455292026775663545470794167629144456268750125\", \"16108638074211260588800537540680707641986073914251424878121255234668558067988171568946079848860335948991834525552515669040163026131919804987340113244760738846884911038097907756220945883750502673899084880578229601870882631165510396775126850307838505063922101682333806284668762825609556049426829531780/3919363961344261777100658318137884299575193089462944554282218278496298610828757650104922583359642384253066896538203596057302203635134833545580869871333892935330950583664400555463557735723364497947986885146043017010159347046389604172186788902608216894094289769850517098027486468084407618748895626853\", \"34420755849180279597302103726180110022640946692592540634353734157479505420320000324260530767186132260970572450489530034440214259559325114511265075416512316229177952140217732655405289808326341696986755141965043719344169685611217958619102774617224847284122901023774956887687026904767714958090256282893003000752947427857703259704682455375442735857024/8342030311716679826889917494957593165464748884572298173556257652389845294530325764837124998293398445804458613956489096007564811101361266196542129764287084823604897187311540561857741285793447174119667215803837719660675298308873496219385226998078648428368061868944322478384684509466965129972030932418920415308276430355882329457342937549162000252625\", \"345888075261020004071220843714060353763382280664960929903544964118831237876694384053904571498830068831026644303797377762345709976595360421502594656308937649239978525713471393570536680412814805076323426256584504251728507416368609420882442293831684681071553766603478479006495757222912500012444787804577811/83505703731469734628961395063481893801938371516752417759131774530720075262459158384433785006689548434701904106312038822969658455364219435022841597243178757423598248565463985786213156556523685666430799283870548238467817226915680747412191245046634279766450629886904716776719219698922088211154187845632000\", \"1061717830619177527082296723099890392273896386613997004874669053445943252046748251883532634529759169500795452576392700472771365240996842610207274128102329096619028487369622001737128463631016494371635687841733644339636164570819431573829173533941056258744442930643735587780907310433371453992062647737259587563398111688659657406089003293576961475848704/255359631537215747979895955806995352799574790340218399351168178555478073997876110889483456972687438702262017800167048243754141722496276537685853311434069991222324039005160057724073156957530106623908696241268268096879569794431919729620178375212905203484165745866913773304319069321426245521467122472046370356725530914587807274074293673038482666015625\", \"274122944106300296738399632684955400761495830361663966466225652918683099779465438024846903286816813856490888796372134557295699980528187779624865098445756013563535339056233912394908544185885547842235097677765325396255649207317018754967666450708249125316192200151505568416495274671679500594656671785202496/65687592621976546250581560102201535533608158256953087745856906437400149205693427285162333502528793675585022025602144243543064185647792948495372442630333800126269123531636800213405254045262127593759539706750242430153456891792533267948231185296091297979933562727112487057234422009426868531651634706262125\", \"7842680480716516803148821198697967237136721860017131244266974996267074742248599085253569637183007740566941125452215834642683053334607896723447140851344501084122965014242091312411884985569341166545074688756440728922408743841592658677792796881188604773469108807869960161395759837407978596679911066586626885830991556090978327508459276025943279064965688960/1872528612245648675720382138045071131304652050696842872529163720558126655075937845539792108048310219395746259570506175902206215101518698490144716531697689534559827422735649881381597761684154409796315455445459537515308174919488497154409643876490472215352056502193150125644288086294418253309947229151074464928874881827227706992859640236086417889990541889\", \"5300824422251242070074569186825929119848111723012841627275830216301188228660779008353049603527567784119877706984722171178137272986345560485784907345500893648715341273841147320288851034078863843374665850852481747000237834238703248634174397792745914847774297223176674917912406659831206869442510948965571661/1261140476013707338477604677428573831791396352814802149994640617701773078174882455512668089072441176857892331468691160991310474734143842336092636848492066592397892638052212250229129355009939118431643425836944282456647571558383755315238500832868535816144280088644939696339160092963629012001958205063168000\", \"2220223718762215584659309059880106334425515875615107369399767892051551634000614327272260081056973863669004224981561870246078120862256383581012183852291444462730018546753183156982897386563561418424093883164027305254176874653780425452987066512563140531367766900610414277825262239199580925879453806414860409441845631158680721091621460775043562065815179617536/526383206607841251253861841374779803798480623722760367843070466043030228662340154304405180907941079883976168609082254331465595267209149963786388600028701073430773581228212441424400748220833542964971495005714483235359479470452593264280645360131482713147116366500300066771223383007216182988263355451923333319170174755334598973202740108032097242475554128875\", \"521891797109626296684891455959263713257353500867652268541535940159815152120871142196535233326890353914761242025931373491906127275561002910157909306979093246574207104081108188995072105948138299097848175016082947174156278439986705241571619793059501724269644447572323501261424770743329858038040685313621446524/123310256826873923765604825413207481739886340225713108649758575106598510022338480189649787216845041382860899099250547657534972156328080736149239332330143771138115695598493059325064119176038137294863053148618656356436332991079150723235214278848602671333076219529535123842212129829931654967367649078369140625\", \"66086044538329677372986118727999622900471937619891337714357792768200341519193500393739322894033303245376225584865369486696276607060432449792893028061817203932068085863800494054274423512956136695211796751845295921015953538329385253280866669403169919614982155350899648626481405781514434761541281229159396787287553493046927448595964103589100429722948913403008/15562137339474350565671240515273666798063901504051979980452491653975250630723677279081058884163396938548780856293034775459223871281049026140999055923743471466471830572672766633086347312178711643724485955576579988182546105048041649947277672869613992334541438784737993706482731696809943027528882927942967419447250586964258807454003775693567366165507144866375\", \"335377615394100148751647837967017467711612297170079949298328061159559939969228226474615711044891085626519877634842694983669611974807129333052471799687426665556738316626171408219730853872410792831871526174987402129691897433888027072807302411474690613948951673562473758814664346259109886876538510453475290967835/78715592752271462306588358880337347638000605031000575876214116610339827495261512281635361568951675037834544811575026718101166562072917855004822606752296233435017284127594847656529606648345533195437635894948829857913798336356647286032372695130461573940500785137424365840081503133157308796505622439791698116608\", \"20090879701618729602554170716780970848925039917987945471322994867171660307998603515745066411687983450400412739285577269751603921163835619296822801840348319742203974023505186187060251544248644338412667631232247108675504629538319425769464277309915502144443973397371136256151336255138506001292355330875114245901820438821732843540725116728866301271466614762497024/4700223519410528857298732096729483544820841497820611795617923063440946097326817340637303431283005509904481323205480729806879570430868897342398783028649633951362398196137429076844504529051072393709154483678349272930361110568616112723747726853614661953537957117231900032044221535502745676310313569997665352252492568100075191900969170979460298189170486601502625\", \"2904778979985524171206573028445379872240558084236464200857594814631031581387804621371822074061289363372523364167184697785570324832815972970658633551879143187709707164796663015180877412717910872234647704536817108676736661804878068078543241390828229923424191204586313620612539678930999769543756218765870513049986792/677408099044823641581658869221044375312077929976719183424865834811543737800956896926637625166844372424044003929341361734886232742770909683021563822987505236295727478159938135467975522336774471915167606673489722102077041330652185811196423400701795791669780695158730756241178262962515917389382302757366325768069625\", \"31270155809329751863885224732454397292230969002004953832354065319735530624996254695453061851449600345977646455072512400760539747054003851289540339425848681804190284451253462663731135337775088379954403740058084949675460445909826322297817535400604180338201322667139062500269285493417563095365899631360901732684124930296643108551710704785906431324876072470231424/7269578038000504017073007978844992319987411732848567116655821196644382777088703228960020894756722675887473977480537577509061256138261063926845643360849217556370868752909531088361229374467207196928745673402380473721018157327193509586295879051411183657185176812738231456253321187419224704301236205478184115996135940848503487199394612616742961108684539794921875\", \"432538822079707760382094121020421735679118830363764570640789368235407853152380328891350816400541189148550353337874309885334920995713154225799660601389784410911658967499100610376065640785585342035058364676314084595283850213942576431310823836792440218271879354669291052589804956435743500204185107215929849054782893113/100246574739326291035824954677502591279343311051719151327066341370995390423713403739043396503785261917771859220535505691760472395306543276314938287868734009582906895763073519374099272340577921671298878837400921045252035507925021904954445172372479744465666760762909731237634082051855588025732494461939980856983552000\", \"1914333673689206389116942789116917579088664511118582610293383428712902211612554212779880638065888518488492298586641997844141510832940409501694726851666478650414191249534733087933879981733561565249818572204932715347752949087800778646065986244657260832234479202201129845117955957242616947361016603702640821256099895469088229339240402478576285854783063612307200/442333801076281757298117784528962837115323835962460661601905131618341609371649347131724700192551574625400701487125984359494804828935577124602622582550626336986871791407398609915208114339012374456785705161994343348351473385887949809051796407340988735853810174589261300681030826392672282630613354461927208579993042968520650313621522933214063366558703422757071\", \"5704691626402072213006354545292364761246893919997531024861408248746241619817955824682639582830486790618668221530365426203424888737658778881721063941495350237419723855000515747725926735319471480027293210991869255971365522170749568996651406002311020883635577590045650037569906001924971041810547543163363976464780729932/1314240362076792592671773873754757443276256223533339004339330559325754574023619698171225777585408160438834449576526997055649849875516310105297894855264038450585295422343454458568152668980131977005808840141079502436391909349182185596381509091427752151860204235071122788499996991078935216686010888734471173124487937875\", \"451219364084386208718456142329444023337343409261545444643031014769484085278440612677813682892926852469540118625738238137458321112005189595703619178533263706811689687213128887082197330137502064260105387500552856851972124172206996205919556553246133218441769325133725631665593372188755090094541462474970525820334385058333756591222492801647110594428922046641945259392/103648250172203340865458115839764297558925693061798169434516001775068769911768281084188883278842546791612199025413573394167639925287068809631958006622842716869211374513136766899877504136929177267362862319748507372147243911522667591375015611312165464514308451222180272935398828092646393830572838772085366567154646425598388620105539619174837489536378605144891769625\", \"1591076564577634575701791393842535460875733974464805197283632670013516183281542903377750304419996681222758401497321278555686661981435637461350320471258386388843198706277657208526372100698700615835733712519332548607115875288787602084336341594576426630670911478276101702119972195558314357975365863803265163991961173/364433108410193393847203348728981296285742202617988970384277162225847256295865554341611171460436362780497179090329831885853324392923449579538286804729856000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"5307507148709435807261229345132535134848030343901300324623409721698217134932866488937772986386501538026693956121121771089740095760486362654754229904633476234090792827930433598453200536551779789049352131005222659995845427680686677324963223653949277037520711609343166926627713758990384011274777087968799793410506391884872456420041494598273703914689586637995139580794368/1212244290381524115082005575105703496583315188540177702780216570265159923654197746388568151706509243638302707511238539845531608313334248788980188054651601536067740709977678222790481348003085034888244447626347312094586389347535167903408519024105748523384932942441843118813819781347089702286481924493361058339731949844620763272778960860509570622673048786968660129650125\", \"3046577098843580578619955603029073328361298436129791931304665777036152915858575282362742008136721284817899542475666054101957899858138590963789072530710775790433466847100422875906866496318804986202089528198912098377828580031852152997907433335176267300286466072997014023120087988748396598176622765923059385876855303940720/693911859077752895978833241338902695755528613729508555938416419864772385336777924892434701804078893822446727762077537955240605927550548046309823051841326355655848406646248595628715185413852040295631448250459076043816328082561248420925930431777502622148019371383254316636979070731427737764160145097293260938978413488819\", \"155310926743873343426312607182060072939030765297630534544899230213054714482456829198485999782086944271490229412707980997432528653509945301574794242118433868747172279224118534460563400440670015323324602117517342201640016853927923976796453577048995243600967202462466681112804476672348206491490513419336308575442086511015101999847896197546900512764233674747415844045184/35278162986589659300679088538176070649273991865663041616088851923111175518405117391134863644540911005782372831496121355954470744169969774540892096320978686548284501139861783292226140413769665461494668479430833892857992401391262903582109993838728281915806394747833588629467613308837196269424421131934859079260185052081536487462257809987002198437182539441349474426375\", \"46729591025621874782758519074451728476386657576036360734358719976400940301493939192083339293779149127132651616972817165172116269307276487158069293114860391502484125554406945249728802484128756924044633825692779783425628292959170597009935305429239702926898931975023598456207165067568919757902764815108751735753431153581849/10585868084079030838651390738371141142245086465033459640458366146849314274285871375459898014414833295804139979016362796357043372316321872357817727821559232353993714062535883074661734509440994664726425399880995133711038483607773782532430879196405793694658185175583691180757783597895616920432527125993118171361116684288000\", \"3736372348124144720852190769710129461145889011598636925228657393934132828633132357232883470466940330848177425542748100211498184494252714616379450272611850068867816250209867530921278645286769418080018709947826876461419654782341309127709703626401211996255743831998918894661053669189312375159058718767082163156988766821194002596331826150321864927832618126580509732359424/844176851007504003627016945212023239308348428094023437269532743221937069345682900884618378849283002998220513307273333096775669556093005637615012750733216460458689282791632437851364674879152695438589692227159038555722539345972833161146108367329370564838671791241431125003401861887477969954740544092178721327724620450947646209914621007186497081420384347438812255859375\", \"1258774755828991281578968023382624723772927642002016270484090409043454336040857926581316994594109169123354553321469500848146015719851609220423736153365139804086413284787598253618361769125996755159571523632747129480387254164008968993734442164892486441152227433281625391753702577143985047832519062595123255569172968685060844/283659859661671181526547833415653453506477950678651675193210969173130116121017723360258249430884213011988678011357458727603413521688184521573094783291496368005697481333739504490647194454695504722542014845706216224432373442438242355188461951883454664693262684873988061018976711201351382163527093784753398257094429403691625\", \"84932063355292829988908961192574710493098897148701473172754949846455626381329456661808566365329266898990829247446356970454502007127269708487563279536825277374133681167235811080298134899629580318813382668399644553111080625918213250223197440426147821225593304993621451053135332451997633132772608233430131400186571793929377129211228689703376067763625568623535588709576320/19089978133324852910950469658566458037096027722326716800113107848115231563787455584278193954518442601810776347091253561956877155673550458955562102935555510392954425196165785410319126098393353878286400877305164869548380670204577544630353859009177051698096136470072137579698473017257397949994722015089768745013713383769765609613514021200888647472804720456494757423299627\", \"802638881530832431828249604040579750916118423833791608589560402449036920165704012070349537114920882938466635598602387718300074733476150548724726460209016834416094317724261857969955414000155807312852092720310159572547644569797512233899495300028159721348599816083166712365215075728968005941610056018023633235372936903015771583/179951197386119079732438617407921535065140503043429174394605652913879982486051627760652197484142547447000508189455126493868229565647284332735552462525598465192073558793335913005459266977086104359621022691931002488052727597513413492393525660272900161375677499228252863529934576881596384036401784035248649026076581302370304000\", \"25208742399375362881099811032135575360109715964024747212026245529087599633280142314962581193303683759605084995818253124445773115574470717199218828756449187055537877478033129862600982068782249943150019637186466260707552416433010545437321814115233841687700051830170191107127799355485920046505591193770164750886037885397478191534797655616745528343172318318678405576430544896/5637713398995569614196397857525646325234056219513202928587580534159596897880731043336790273040813044077153051260989730372846713618900145444802234629922717464041261370803598799826604841654608724727320798324006129524610666235998113655193642594744544226880944882342204407750193512869672849910003246504052298022468012594459974209940607450480609190841893267203392880360823875\", \"732332637178584560220688900268566130246820235956768724845747830959547501950765063982943061181526237061809052444110437930100210105274824607344902764184151030827266142225894655531497849161692760385938786736436977268616029862577293984376170905024712952813234949508186306774257035535805330366742322777611063402455261391021097128/163377988152179636922409938163005948596822656868040662831003991395905185823836089887990201522673196719628247106777881741843786365701135555917263285268753605514812568258179391272113405920369587922702002732667842511108732068683407168090725712401954314293193572654347237716691784386690948494003094992876867763698101043701171875\", \"22391374854299462107923583267570593886002658786775211597896252879708753450794332301142909715845151746786016535157797023153041007263258732991465037648536702217273897876864351559736449481285518249846264600935543582562018874574655740660800634883403597181876364712521253650744197321080655028374602772696770227741610874399454362583980465225235674816785988164157351243193265401728/4983275997188967758382167867656806681565521964135131710678447245984239733544941881418957694612909599261843693554043504855207170782744518943778096768859337980470219783210191765678908537645270392500777411134164918803949155037581108678968701961544979451081836872425574123683574475790997414488641534074873248802450108535183413970057319247033379016606809226547805269752123746375\", \"21252344995592269775107236774689012760750850598567799560343535731251766780016530978663079386453430272698006977668063208502408607227544322945446079708000304179073184745623740466334127867464883762843346619853325415963062181018736410570113171387891518398846617197097407612852037905687899800932343156979591740310928257766081697645/4718515378484509142377558412184183991357747235892194234377932213613746008373918923611236346330189287336493794499188640380975364991548794341177060325509698404571318037298112293926833877103554546466055612498927474225619680186119313129604319096374924037870803554153458104225741255753314955115645304948564151765516183663634546688\", \"76703085666560609319365659209445044957052359500745196718269665234646121134787807938680787341023203786904308047981099228357850016602203539979246579454229078497537148799349353250167621935384193502383187510928609818011142642954550330069991570983902841318203794113898871515702445720207144863877026526025447819537396146822201819435536435835285098485990260677737192230985069824/16989892821104122916312992616665764943723222199277412857053896319814438961475117951904867066845412639236790762432996309717924037467863024360211163971190006272168845197000304328480920483651558672879967350982199768255256753110375467976246339260326422891913564151453729285191351273342206198366624882195135056176502724912849575385576554208844814085228696838834665339811027625\", \"40153831166521391225489894857551838468150576827129133168972859441122728710165233865309084872159583787083130713473702296122465319276461991457173085312407612757280915853584698420083436946976844240063731333638150599017886937783470942007376523947840104246927580254612991191040951001539641947153847776050138532219595746056076776809812/8873576113581065493273519627544307418139908640325227196912114520903505426722086265723900326735989771660987609604507503750212298754414472822477243293638486047313990878348820573874809636084574108909615044524663712495422565151340037564156235745628465172219286664653343193162657374410926171153516871765680561505768223660055617934625\", \"200736374277835272485186523480177159453030082779872429648449412313247640312479214261681899286513818912991945046297334418102711629933437654377760028476767482162031641781499114859553677502002901248124750539270235098492377826240319766677856465093871367817683734079621359186477306173620331748496369122143019303740252461824523590096923561928354020960176605008889579578495073283712/44259440065125442964014453739391594153290923937737136823355312892557975399035370631521014554980129291582486968083228888083079118116286312583989433037097397252506140224404130371160608365777625538148303917306340620019882928744151294738308047800711028158277500317134537540772759486365658024194428796846364486187105343266398338060080611643110071184992193593643605709075927734375\", \"488459049325494693259159444507437983381645757291858092983371672334043029615965882574409808932509285079401239403272414271652617474184321852388397021836909585659327974611273820676128650810907598106588433939541654215766888212287311943387232664417347883717203611092450971786083806323404432266197250919880225892099146722474124874256523/107455855466267410923480140898552598306699341366032095904938430084768624148829473848763761936703072253841751966906142283640379336131083461646777390874405323298406517250231389493084918065243079819898691146841695350589992171102939046740169198394671965069747042621265775948217054519855346617967866614303497258042439052681849864192000\", \"8430374068596413768975326329313648683222744787097373111477788794692418932056901235174019333392845529821722488982447683794746518712070635063397464904489452840169472596494433874412726723065560358405027764015273789053064830528919091414531400589850704395887250756457780868677553068164933299802944396576360356896758745030955907258232257358056931680617626606715393885378887657377280/1850480358582748412767893656294669486390769246349349706200869446679212812264400876685764762211659843658541567071977813110496329850010288179702589501255367345935389050373021591572539260951149696801665953123597521983257852207280970577287472932167362521740230973547070264273850381896786822127290397075758780174083415923482640313277341120938690594859118603017930500014640169211239\", \"58273615882491925540881784328370957720539797010816130007322211512070634295154626813477498607761260613353633996451797686143131893884559909668805628269959901044961666535533876340116728982072626875010391195372759135469446048394835148654407846242721443845351855234347422256700864370273092971804207514736924787577569355949601385705517152/12763172138328432984573837529764902730448666594097466544652830703737195804747682450548488162227364538052585484418491914323658215406327363805353540266048943197822838925184942600367647278764952826664684839953902567694832690683467635727409976388280092262839126779730168889686628630302519063225007497707028600865624133968363921915016625\", \"2685278694947152969468407055109959900160804835228466214479525891103128459065131221736713585038130737099067040196326815283171857977706979990467444622550497565521863441617001097354649972660183038850033950647594754644997436624623325003537308428828750008305464174443210079059253920383411910911594636045517662796811001285984447671371943267419151220518726940455756833040934506414133888/586864816044968996825907488721678304211296267371936463272955488077666796280028127333229453342355554450708284934221461946991556216095213627059047984199091625921432110913096253352065238765240063555347292393427726758010888546427415276046238297382474708612526770055488323003698641493939145624184943388159614111350839555141202024991876221874110644879676602924730506882384603409121625\", \"27700345710264347957758638741952394530538598225904772664391173119594616680996031886665218221392453628824570256438960349220263575741495285780845399187013582169907518462437966962923592601721119258663490655013419675469864809004562272799012227293974254329929404036071055528766397079743200179924243479370594973626764330855493789112414191/6040997839051213541001279276287478343874107660287651711609067205111574718442229224212245187655300348484144001298428958025052162253854676210451657425437588244676589965820312500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"80160269787574270953020489212619791839643207793889009503234879683494928396231769167082355143564723274576166638869430572977442020236299319718643894871736539109822173538266278165276591962215927816541165548699380129014840956895931285215480350321259054359835472320394089646764361802445068798451796525897304221529850133401768027469126408090577121172238802281079916258951770135485696/17444957084936455555074876721808241311651668802091828589911310253709517226715880722948267977560381436307152342821304525073651379763144281678911047276389231713860392794975453518107055568765009486973017341479560154792340888780337029481646046233967923289468141293699236815196553819373828280398488966665994092877680860643266914861837639322607761804740256920429518434353839878280875\", \"2352816897072623416220002134476921108405735955266703519252095150412419264317091785317803024028565851487861978477208755211589867803009700996828082850796103789009194767813611798769297617674631277847910238088040257037678126316866517601388289837575778165301828137259948173292658462765645645868094197736382683775415645307647043205988394700/510973411316690313485681833991645423802776865720580280058344111363363091616558230182669376841383375321912553771027107891991318313938505988903735114191313214327683449514676737796942389784957658395806951715454372568523597420866050825822028817422805046287798054682484158011143949412956697442991898914560191411624040490122951328364833797\", \"6403295584873165688372907494046202150046769667837790834896334486679541887567517050446119511695248926941383207478170182650927368177009669717288184903306689332746127845953193587519575304974203099873732502605739219028995266139383163062837007982999189114810534856227848568800302527760100163350814120545587074865568436789021082619398126713943637898657861949091545516403987546145915409024/1387794272010111535893205703999712437783041553900341112488641528986385462810448493444968969845352401058333929711237978223214186693177251566069419805757440174840170213159651962686467523533938145629444468366235554597245713128812532716616087753947246800626006504878203666972651384731498770435755225220796872155249202960801768048854869001310722927230237083418017482134588865244642658875\", \"82993247683514419570466529457059660634483860665557779709153549045427987672829778520201315148149878525274005978368939092115193636113741972236218502664881450367443614971109677363668874484696543982239492409231870942414193419634675024621942196087473557914167832058111113476295926250739099284241826553737074679953551191767148712684157318697/17950946423927357725787689855263532224005643859095168852729513034456208872420513601894508438640531171097082516559962755244698695622824386001219435651555513795509616906355363573638916895074349491513539093024980575852693293474288638209680085037286354050958859425647536735341886663074581909148323105020337857959651624760873736590065664000\", \"584891611376763781852144397260140844977346305541197362434227194779766612939978629636198589818106137319267243431810481928639442343946346034433828599323416877248326356345631611148749005937144684862502198147087702668524450709118588741606955966569427636630159793409544653944608958808602551061186799401212712216156799273254257486955348236914237644151956226336750212957092204830385441792/126256710861549838395499078249922986417488985866522660521294610280820007499099176190820291214370699289977888813109514854178180265382471972583921477022411657285850911270389720508719377071949050253246021921916685716353393018411683757067093259101151481189635423399611625009617884983318141463140199839724797412514785751549277231259345923662499623640886881048572831787168979644775390625\", \"4743054867460856425399742072925732465660626340183690464743217147109403130730445842673866624947360862438925194786600531200056131309608642363389833474026007798643235346104937733349791667694862514383520689594596660275306247615314272223660862212527346572811422915223417783887717426641317921972456913534338708745549252254865615725859881457906376/1021840037832289788284691535543138164288462770384961802287250236519983887262771944174557087207566030730743075334169628971336358708580124427857321953981475719503574867471090607795242192417162791762511940848493176847925838738242153177311649130718886794249673254183907621449520415060660496225939963471753122766421338241291756892571824984344625\", \"3784664074155769467702999785016514468281913375341134899878893061325465790589101335015569840325786070795267055386681356241209412947116340524588831510768864231937929260236754881829005065056310226407358204278658699999612596866156294195316867934035877283950841910726224355461522065773816109849107487214275801829843762482082803559183694631856772777313673086715631547326400170962722842240/813783281473223559981291694175087508812520505931454895884442580280342455516154674683217348039336712901850738745276445107477919518905155156380620466135946654952837573797479076027688866326359448543065305071605591497778941561986579230698384305536224430794233462949056326864499827444363206162251104552740175503996670997705423888382328014210171324376593090187604268086334796245552762333\", \"1946671258536842642381655747294621776070051525209940130115769153666368932042152311477746728678182920842238801763565726086459485050237860693394471644023999467670017470376746609892484192072297938254898880354014176373253875722410186683852253828299669530022166361304397631667133689128358365296701757782382475692465977794960109690362462330857/417774039698408581013003883929127512062321623871486379101498968145670269174833505080260389860863417408848209525427705249526516766731427603641806256289098209429110794311660844125377702016056984573671024035213045475132134896835814746425864304907974005950155657789157496389234919107772201305672421982198984613601511388413381215220924416000\", \"328578487723377153600821813410631465225159589727320893988991729306688663770697528156625398176929288628930496338036815910669579019719633124832162035588583242320537435554101841406566009219059042888412893352417446437227440076869427577701706713564212185163005644118869496869980925214424591264870388237079776503547314587137721633918824664946974571838634860386893404364499977966899068777016064/70382695927096628347637455030970644630942872888311870124896575877585692281624151103204551947776906510366521972834357031777287506848887607457751667816514216907338309372900327919413372044625602555866294337672022362865161523684052940126509854895320132828009551012639156341878073682501185688461720664801829933689280752623773789373199210473995823367199793407048741191786377993390965297664875\", \"2617201476921368517857942326432090876874414269689140439151907982631768946799200744678055980827789859579196832718849393046147656447672531861353456343821196812881882023188898815179947651274131166835133965629115749368441605680383605331300030886676081418867305170012032824011912531673468215561506423833911621270680104083533917562622600478548/559567121085534865189976875600841717161617153776904752351231210970240323460800785728739412474960421770806162360125774000625035522428160837855944215417821324758873127567654244465281354654299068546570789547691342609793050301258532586131013585959164719533123826201937801986942606844854123769532447570107525081084531848318874835968017578125\", \"636225736038986537559880265988431731529837451289737542395494683393492040808565905376235074534207026537145408562785279823547657299565440309510931336394031904920056464959974743525662459433889398003683078967642651812081450227654478095420306880762753401111260630654049389197602389949892636943971690212484981672010398108426002137114819838399222096538921225458913266993881960732663394566024064/135776510176793971074115131648637508758953050390591773574951317807919051619690313331192027871176160424663811116849856489187562728496099757910540362703888937768555824513740118941387831822900198029266206334350448626733139136083404404120210893986654422850183837974770675600952078956326317698998103770833069712616832650406225828969036781514645731022616236082175582937900731419575337473384125\", \"266695771933124633677367149389643417608461366874310588884377151539325854547826373711099517873721616543570605935954334944030816383858485296542260152894035979141266909050267414072982042090341712035518685997484257326212454742816979806460287972757626105526907510197321350895873473656215941034605746494172316089636216915825022339855304925515685/56811706665210352283362623728191218698295056176625217939528332247537278605113496147630185544004654583441448319260578659922931798845493756189402805173037491645434052737405379674607517658118427614090338938517963215812444779184193933749520313676564187507594274551791388039139409235056119788261689087831209441779870873305232021728002651979776\", \"3511806683161697708497547617957719390189982761002154386881580160856792742952365159764830433511949678304281539875366378131195670004345568047690216126001067194904446295336734931691743477531830892015690816210752795806120303198745685394015161323982229908105397857791180342330098240702332072396030780386362735967021055250450666535422528637737695053315137238368787607412459874094164027214953984/746741569878639983491390741637813989978804202898438708743258000150996080386381281307609038830698579358879333079215327202911977568726258527646560497079622703052765164031089590965199628534477381843079892123440214378949632707668935001371616475282883095939750704292616758568964786737752325652839226013335092148777788733453702438432279149298482004122593243860829060557386699231448957232420125\", \"499543951252504651717279461487337168721376180441322735807713499521878076780205427598086756686061009718016175215146305489885835839673419698751530207404115002383180054704927695269921072232395828258826213554806570423602966743337801741633869267620843626804016742412046844770601322513184123515405692795346790813502805238635003099976693786012816/106032986203682550514602969462803214831559442358811656484036951559991322084935692953211120289352600484987931812632505499612220494311324679562152078883141464406938524087376964935494245010636163705698220308243980789514815579319533341929989455211613890905485981353837321342730307819060825125980500975023479813757024395422041501208805339176375\", \"8540849722242122835873311629952985285477986765819584558233324868363310302206006773828897816547299245727087876984857726652932481899766510637403577175623031467933486823994040576431755172220921921877192006685053572215922347418846423419683723609799729359551828522978186208983138345476801247634773975311405913274552616037005854836040162212761099347518242200807692224460514057530656658616850816/1809694575992816440924165741094996511361288430727981159314194000585536832192004274726651828760263522962868944612215633976203596150606503849595633388319338251977160257979846235995654357082321611719654136058257458753105122024859078420173515189641515736029725847315662215778251370398007468665986604529263071981040014321717598469319370651877296085250322599247141397427185438573360443115234375\", \"51377057693118720457387330519321684810411289582445982078756989158447711080414032055843805733348558621949380554029375294451303430269197115810494758213980833379214402452992657502777067850631862453239349835215260705131864911194740832694498014048717871429797341104227759557199716944554347879767916801106279081864127192611546757627038037780244683/10867246748205139797826516105458406878398263495890048637741584969144406206902037615496936724683237700974333817527350121106320991054058406504571347680049945745432432384570515723033245430148177097144850158758462968940525568041926860856763884474605057056550146491001458649244094211354153171337463406192651150028767064600270112838159624568832000\", \"2517199821548153657910904242290029026229621935918771922146425373057248090467388430999870036608278542449661971830076845113363443421757278612394167195431759807908413353743377586893872930828548256216510734912027450642648789925142482023713336937258932978503310551945630359646777080073329099268529064437120002567758664419443374110941824106727218341795100740316967386497091058915066147604481280/531524260324016969370728057738851340792702640911631807178654723224511108065633433027773388768889035083734041289308124943130099580765995149865288328550751289346866467755881013217287175392101334538392596956248952430438673292186779006015549928829953979591250274457658042926539541422697852390294886719770034058916886894408015624288115732154492554105512936468520265305162358665491880968652687\", \"937159485027553069020805864547349554547661693803137696125140510201297417077233061462068930061915381468160677500445535971818609631674361074587732183297775728389124966713749450996643183965795829780345678634356741756033039293590264355732129789110416943789326482663579413229893878422643110852069225671783017610387570935863228248464396615988222968188/197552642195166614912991396771845374656891854357948006221100585931656016640982345159207601253599235265353060942313995345483862152489766993442419668492877390774016299878943454249209917002169480134131612530977452579520564400124908392339263545911443803619972765231094502745980083350567509014991735227390978850048088378721210219321877150756855372125\", \"5119346675109082499980756672052066247676641510661024682574296075659671743397880591881419516307292610449161239233139088348510165442597278965718490070997173182184417648987611422446347235659085092530927312760229499083348217392125906851921500360553758600756698605047197529446594606336369425040236883171542367713951500007600355406492128741649090501989105696576697387613035366083536629358444229248/1077349190930018641197987339365056771667455373500846354778079878558146320193384166982231171317419356136237346389570422332278447217033773023556383420372685049620361481309067017697564760747047839930422553324681218253359586320952896352245366885171583221864112040038531116947187482413031483309534553461613717398523132176948321964066833901215878133594739833910960843185464241840039390204295097875\", \"58469980853327028628854378052548435225264353747414624620847476036979290604604988637469977624105451959796142112200285366199247075503424204044884512269071061176877225315884188402954249683107639777479663275428465242905314418930053869461904934138752031124685541853599407727446896558064252696813370692668496452783003306386669962110734257851955001481/12284458784412533668960387046583440199646081362484321078872891438551639470826582933879934711861551014258493898870867541349962531447724393381011633785884743889445407749238183080941846528000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"632694338036291086868292541736272151517212971647680989553388199374739841494700315711180961760384484042159533979873604395621016272772109619401112452105475906812313548587880899058905419220497456502543971131226430775692744506047039958551641270070996110661036371362526401525207493270590999387476275629412687473362310414634469788979236895300129227082421021999210841384596617452097273320509348159488/132710874087075221626157136110978536488168313127228703025408943153782802265472978945703742152954881438058373686972477195846162708986982742647038014147903817539418442869011995988024638278746664230046452545499722614320284478925059527086663455478374200352375121910000967044366831275681254530914306064535110528723482282501358749001657608122307686482720926189537227492041135055090784059994118192625\", \"2022422468242151190347511883185841333968390991430363660248687284021524206079162212007263606819387821055183192871951076644707111802972354128011904720586729919826758651167984507804867954970064938022106484656560866447290934136610214175516487579122328055482392137619829739560923807880779865442016530712986750711199998190148885726144596663143651240/423528009127070458603837580844559347493775236970253513203186912091140251858605354218715508091394564000304400858761758838182654201653901408046974668599216804223721114331085507752600832390227068985693006017591304916519540245902645712532993889000048992026931475754508248265356181099817467608863068068953756055334213584649136541490530849577363647\", \"150542201776735231618709653388506394887777837646651406023174643241783006776019388336318216053045300417086929061565868663031237502137150880313922488106751241006715449458736723129545400133450376339156062387859536289694727635468338235084533552501618659272047966040838509286942825414463511175531001410923014751124732748099355476332649458471135027773371541572374016038525336728276024676601778299264/31475618522527975728853391146702172347290819252268551219771201846701658848754300838383637247014705706066050673096278897933831272607774110183488615338021656923433335661890414740664480671162459271850877855521869741833030384682549648626038314686632195158507693321505500888988183270276134667071014075017317692121986144742473139078857816578133693776368882596780120407949076129685719314703426278875\", \"162664351499283182546788129866259011542529017155637405328005084357078048074065548349602626724265307733005745244338982661090506394708170105916177679714664432754153795772811389612700051002336719842784098507498286260450939289109123759859710248621544296008356071415713931721102824434964336667980062728653562369697289761913925215639430496443820411811651/33956433298509232632327667206936379248172049619640091186698677954874297837764235300806836350019565970550533206216590639008637925266405524715041372407701947953283803854153876844320283735281209725651036513491246238622967031979233265136280687995181375582844780830517825595245506321879177965868747546127685256867456319112247572348416655367667187712000\", \"27228583713734183629451808889147559240254570554044667607519238865891084165382075658707675405673276615039702916443152954157535195508033284355580742761569101934821088036084480297442018005972653124248838420021440899368869744141698556359295489470499243402799483082406238128875386939389123336303631993557844565927960009744780823166462314116039469622216263221278402673028225214534859076857413557466368/5675134787340359276387085910732530678163604187009567576895331134521132071092293139167824957253050637085885426100206370974479279292804959049999647539684766632278449357893560561608633329561385765035738071726214510832066885156767060324427330401967034889966727638276371320401053302413136551142103678412692111973028587922399670456670380189570979581674699102934733563330382821732200682163238525390625\", \"1340937726818688387636018677960518622106989311577445614347061615417831160296369500704524022869612973331444242000788110133157689786976834913297544087249593601420972111789552905846168933014570399562460789075871112224533723259660967481288525220689577290386781169316008987012566216235876842757183233207943071523447855623001920854571597886491163165150556/279054368814522483241446594911968519760869180429079780837994812436395792594449929617293503975169489945136244602350941695478861584261665582123038340824700224583170270427163469762789603657025958695551448477050958557681299495041994050951692916032501884523150972841782658389836059236040091605838583126400660344344601879969354053137568588338096589095875\", \"8910951660339249479517731530773509037034977353457185453617569046885132434552771722727442649095007828468878374139001808825741829728375370140505088133244952288239619141544661695065318568074863317054989982620944602245967155400712702259180443238473885690297281525960618905625084639870407113029712510345262279507055197024677292523214467306898573956604928730377318210588837126450942086527893437954864000/1851573255256476362977604759655284263358595254392797078730401113550522214182030016660458780180636930591149034499142464357511158868625309442843792189394292787657774627425816694628839987456477799348874853555586931850788645677998004186437300173080088839930384424797706381282430208961565555953254145002318893188197561315855286173276564036402546798318351229978103276843822345004757661005876638005274037\", \"84997663352987536417038496128111159210386455419431137931308301989414462311135708114322046234708053448098538629166672456703651524480738219822858469100454933583774404032968304328859365484249897913676382909050450855222567147661842184538302991526635974158862033287154321908483007506326807469239745851379559259262425675035790574846229470041596801343087041/17634687575122715507915388096857069366146981156897230620371714518707518105157483283253374797127075689236298114335734874553183291806268149747826050838089931351158483980735336772879045027213982661634865556129548356487722537193914986994283729746578044621115589195066212043187229606921062007047940293972381121200723292297716621231320254309060321476608000\", \"1648849257486312935416274009474520589799750757877252390543329851029437452988499485179026845292068377957697884739052491455807688429630524210823560524122596610276957537756142278585091315141096146341773982302888007751632401090642472506538817998043326415693840862261701364114923327286462650797963969289743571514890723145251583881752876340628073395708716735192690808352188867334842743895738955762067968/341580411902962140529547622267381834425264893226447658723654120920549166416114849731588552578626041597847002946105459812230979900480135423787717825697955152193526724029890829615845314765605770060975538542976523177976182401820926854406945392167140347444433885786340415437006775075196031433365827874254477351374236932624514469241634422312990555534789607377023339236417434574755566856489013828206625\", \"4899626659231633406569362199187192352933567344960498139854460545644210119722856870634652562532083546344965166340063297647520613455037240144734014575196764021102614748218834054157165781057405100578668000290493431869797883155764963238760612333048336953434663867580862692267574574465371615023999531030446250351305046572267686566999209229202587258144318592/1013522377571209303732207048597964555261512342860326827024786500686692475697570284120359840724596444209277948648863014479460188496587721578075151793081823795161404110811480269106846359964436993190293615381593756076515012514100289406862487971220020752628653845345780766244842386136740768474703009091552043945843632199999007070800871588289737701416015625\", \"362903847358088423032098939589019598036593525722040887883164115981767777873860799955715587436566233010543937498922435963385091400670303956612881974450548904906949032005878241638546734597308786514086678561900713741746905742866635779432216761799371793260025549698865319760786921444505323758235164807966277024031605673481480590193724980659448692487108892154809490199414370023696404259691299614147712/74959603173756091922435708504751461448318819548943586676159545028063979695880930926805574951275602951047845904770828900645717477098988124553474616764040938121171776556999069351772286262529729056288451037717198273521810585868307402693261479298923209587143468206907278220909447483738730657438961435587752873879244136801168836767273934997417156543866722171766794171623224855358640156858606843576125\", \"8521348154958613550574095745596657249924328336262127244827955886474742319277424381360677655239017583606851483318951440691757875270001283229585075137091617073509041644097526047127618954293881264113694362598157456878784814696577083997902588926421675843291157049153701100218784481406086810264243143337016042301806376864424632290226377881206765051896745/1757584673254145109614914862134217345456065873908262753169404848658913774363650863904627183104777337461445063704655164325930891269843669860409763569362863600932267319335889540453302785099532688264425988677082044905948179153286276609910158854349711054144968131934713419772852663860893241364433872853338630216232313607969790083448433666334742108176384\", \"1802461420562646993856730082999823508145602238125054717836501201545920604020389361370931345491160549787411668288359013059160331370751496329806488246135100776263777863399096485894306306621852596694700845918608199329091852956315870664531614358379176680326508877329862713333336188556181470928613423972314983964578645688876556351433429494008513812136152576866650152623510296911708111085518974142728903424/371238439252064016214448115231139360835481920731625321084601566992497057371416121407293286027832357816257507287295719261141426130159269433199862002841433235955835172774430690352481806933860390015899973299268361513643524088242973968537595085600335021120523852420135081643310663869327371821064862449426404044951571585406092523478861879148545678639697679215289523234342337347529225543852787599016265125\", \"88795280670112240977945082069219541902481768504536167808816453021962616596410396813316064685579412429940019071114917828928080181638058444302439626425155946562362550070187433083541414569447612195370911498321149367969974762244140788494955146280201020345849385865084095189982291190135293114489407801749533448443222584092575861096946605418438181411489276/18262596223069549313969288693970246663726147886364354584825624311486557881239003216971630599389642752648815377795018130449384513824927138566203714891090017787258920529990523519479383032564209629983810866231367438270859421572641494420831435563580050954867101292568399107965982704216434467243223964964535464624988344342084084237484262612100980519602625\", \"752911409358158070688133336918078236438086521781731735123294741731669530734909563155732092406099003582749182967246236657021875488130304108082404134004381196925042617909108654109138702993903561036987511410396567636331465803949049946947888490287210013788802287247422993384874670368649616782837096233384279817294778916419067404863458318451722971117669642134894906235066332205740872938406767767019265664/154635332883086377656813458754577288834216641577439356891585125701020579768315520324293435008561626926046988056302745604248220408154454267643222328696606367409715369481567213640103076112146615938180089303294709009813772509602954514391675152597458428326644988225555987883250642389550531163153338541870029415077982539614784206119074702022117790679351778993541426110436276530890609137713909149169921875\", \"15286089077439918584953144558775765002061832952090847117286473868694909713791678395221438112006475047633028543501632631679316850512797978594476229228325228403849089079675681042224057234415951253954044235099139983386056610384489202589484570852048157272551098909455253037561994944665563291526597323199530997923272894119350512727802414680772513760081360291/3135161418037836259442831302977219750614726139657718770206960776514822107155928800694375522572523712277389679035632531727155957120566617736817225541673148354829212969778664144907503411589126111888917929495106029890532891919001138770210977012708107496187227751496980000137223047079127096028939624830654227758737339725345681745847598157538483308068864000\", \"17723482381737693269787076798246423310802126092500438681864673375704464394105734049099094818738115345706100191580982712146882034618103161268453808819471603805345990162762722549964406042295355916458624836894291267553138041035528315839108252422478610879301656207772491548742981990469454529537049123948604931661837539943536878260665617524824604291547373872716194154198824107266275716083848262625068958720/3630091565725887087605600771358216927099748013831912080380983545872077197366172619225751217619097657405660172801849926220948413919823038425519006413005998509677472226729295278652284861834178791332630676772284971762683579047508016687969040658592436230062049051143001484384767836353233324570686249824980508520186643477313941054900197268584495128610811273834192099099592687485176400539748616360799518357\", \"39160514032490258389003214587901781721548011632821053230881239001436341012396166857515197251499460842954863342641015306304854226194551189224721257664420778416733889030680295206179109679627522113592373938602737416822981698362363553492610842201005420727750505681358595340127099855823746410663750133019743170700888375554918213182862789028531284364877435896/8009919337434786244380818390213546866794958389603666737562053423775386173149395943310276429895991903753441584557917565343673605019989336264748588735390182130334278887642569515202100870042209261561001627386525182096090194076839370589780431326097965428311786635366819094633651297179987340498215947144870164066409654464551017761658775207392803825996394875\", \"18188388167811476762477659006849121912679763597132233588170406666718758511478154418948855160838212151370453213943784067796172102916618102024199200086478021533171984254799008541948973652219533819511807681148179806051835318645591102296256347927018942348574774821478499092054497390790734798143983945096982240517058861467440217558586822663985584775920517755909444876443211404222400335500608733284461685888/3715278241795087610941547133490827711133909145414878217965273061493740719983191775105550559905283733134189195190321643965858771461560130864714477448011225816210219450040558581571206711791272284197614810026220745160693898421068168630870850392739817340370146186703867097982858560347971281142766235850971837330222970900661653800041795020382847588362774677568059355238174402415384788280852059532958121625\", \"46353430636874284402376008361176880938798775506236714098123916668545331718677407145199311191108199195405139575147933283523305343027297808443653460575141799729554209181454676876263582758919969948546918471128299522715691694855904535448703118221685887195383025133924852224568922999317583667985459047407473419196367812949579858081181660610155317911318937349/9455890179897829052705408931064120820559254220394152447502395298827357144081378513080398823188243663943177539817982481713456798757563952162598464929784370305696420245648035222083207596797327498500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"13607414211126412689435920170832779523235279308039712294681570127241403406455725064605210473923965685858012114332021572088551127762628892611459785625407107300355287623761046438724706918300976102581928643740596336865698485838431972050267114940079353996100620311097561405192365496385584164725035842307146351211183443267583872067352881387294766804298681841402861626441205037637282007810811602289501477350144/2772205947240095684743358245950494400934136973845543049938212403703005150954425087866758842625041409060217562878157900197951382737615822655863548356735553650755342108183641353142157728364469706919993519071329069805875834057743793434164720370026073143626055293058601124362130539040404491770346043977106988100969901297669523170508321703496903672333781306743488573086901583022550356345156457496396749797875\", \"23264350093315690507131500726914401771633259602904894387312742275462601574788485574913195967854009886824436237740789910851843045306673524324611130536719802717912615609109285261163220007241492964833933975789257681755002054890453747803418465119567389315754801791950553304034666399677630030683759466627797123971742061866928213780452325847848901682792886840980/4733430508316851445525799359992627142007028326865116523033957869609125212251136452396410236930025876982265915963089597825393317909648054808274488356887197933393799241941120691826916741647173843634076299630884655997401370400734954098249519111198509015387869462198674657171808841005212058822254513429836457539629035675822719720295352508916898476137111981397\", \"538960934807826161927564251064896730663918579817797131801326848839524373936888402762331254883505157846659830555799909822861853145306547699817986010353774500545305596630924815657016569444824389893996399550343022444937690798126189162954188680257730893424775303801562327757655350002001080811866451425665301674688928515041429654624970707803336800125648742168380676815769457467038849213225206824671025803392/109517448833211208909213522579666376007937648875042608355810687327424621469323788799169718267715808580775296460944943658428295481347915131091297305260674731651980547668762317138753250458639043477453950774629862540017034566407286963562574188172753764978963685535201028286359818524519980885827473904574840285411260037264057197155527809916623487144493019982419606308144576939532055057697567269576800542875\", \"24451481554350251656598350124163983489544445991992661049829014268366250968046589127810466483349378560701491445658725080497078590986743512397927747885285095846398852574219367580068049729894667374214861939897557930527646930793431512683750733092448862551580494245486308114129295467976874843852138144539250235632985676953662288536669286915983261820949386845806781/4962240683851186225340479316959605207278948397833849899236383273145853045488131674290332609876751222112917095096150531825255611911377071887145019702433883343849119017643117746273523770961304609989779231048095665388209125939879595509516490230961558353074751312876252070889983946768175488341370453053495319823381943793679003096504200440997908071027962806272000\", \"166591964685609920525429719961758335887941461052357297159523350448241484106515158310298216150030768812873781356326923214637847449893575074813991141092681107583183275003570804134461187213143832123628701876041315736048451374824101256980832991214945762266748755723551899001458245164317581617731332466039757786839492869211248064662857987111284518155462148044812626055842061283907063784492325693994911811072/33765943466859756347231737285768516240749714264564410814839966011490233598006227246396923594069488496368994857718734549787000213944990695920130591750377483911116845697231074543526982580529937081378303555262933800375576494067959129682770065443667091668104132884375840812635624862495548888467575848428463895756394050252457592540570490061561616914443009224917652440212112452400106121785938739776611328125\", \"142464729519206642943985715465196065680101634264787375740459792619754842396453535646509170066091478069799080172299369994438836484938378991283020978342879057271045033903518255546705211647900945143546293360496661466657600494787228476009216508124736254967761901224547269496682078470378676865981855568197705507111970901389105723589666709580851611656838285777566736/28839643075889294346635430272525349651555039807615358795334663734940126053968249608601725991946342449660829847322517564370606746964714098508298705743689729306507554363954348780144675937510900983622836770223945538844314468550644543502501484521561567788992156632892028591678742014134130878101553633195551605796158103033794695984958987367799607407626319024034625\", \"380457154857422076784416625436182734840012277442496600178664323821064977485271288502806124740204295811759917468598315932331219906040253463960961995849761235911145436552991677050565022181516596464968316292789048809559129516930574340710998611088996508613850407294743457197519091160170604426002924022923388338999324182261954685794522778833029950214443271526469607532589775916381786492089432407550224137344640/76922142291839859196033215395526448408989799722090330866256930898223012427332209054699494033511478050536463051459450844520020426942553107946282832072826069342120835351421637970462054707566481086202287686453371483126873188020538661871147778312986131920021929455276187425940666580158173676284545586944833678819622895550345083175685846944633982680908505900099388037050135210936852210263717185637166725605577\", \"79999800708369666670693340813609265988600461251844239982904928629083975986385235816587497657678297663151298709076884516168798694292862559083730259839524968813932151813233366175091317046758260934357096757322369138747731224414176608247605314668045838769433811781490030635374856042786947109101585097035794969502111354126773165391577217071956928171336060247633607/16154850265413610119312596299635391433380319311682208755390341659152160578366244774029302281068833963848811596545791104919556346810193385001196395489740571188884873246131813864782581356887110499639544662322008824704830818136660544673293865921754569356583698951612797219776290835161780326945625621758204931298948625885081325268123344406261740843197232316416000\", \"26517014004241498798848003208133111307300592620947908933072661812816683085261359696887064436611747292468717739609776825664344064024535028242737616786238200200498291226984541942836459188328346609549239724653950302145388877472274074665166631509490297630344351573245265440164082334092997307729007429218385933622623935704482371360985836659823269511115937443161532987660855490906546130131716829909388620539153152/5348257529530073524280989257577050878033239486885664777340947102417077875628238501791711336803418503616042922880218860266611595594400020206192599559925169589023339295256084579966533260861249529670141854632965231468533448709363477120437277477668173149958267956654411822360053335695956270719680086524322530514249891157439878407417971839744392044064720476417844056346174795601710447583861127956455406902139625\", \"71197348290771978405602732839537012310626009318133570890482364371056186523989330157966045289127980687764218363064941391483781008265266963537623770685390148810455244349859354857421474277963009857011653865476081389968122418691934354122230780300833008753686234433642072919923583176333668289998661499146617277981691372057042930131717336250309680764289256080895092/14342680993892886303954853579883363225921109635079605392320944523109187641283117181461662846411912306480691901515655220490850586434947504504317080144378185989596578890875561336496479576651516902048606328604696610314441229321219627021610788398730173161473456954861916116391687748151443335513249810808309201830214153565966339609616397865465842187404632568359375\", \"342401018754023891059352629509715357053454506037284788725127073168445189422181540408896452651232759821766616850264122591225331120588918865882061344322996688880669665450231982002597398732201789017495427566260651180470635467002453249479483900268320570004293679361696197905823690145326531180324429318916092471863347575533714871355651558610515931373080997536792242278529575700808878786732127630024064418468916608/68894647682461956089382461406499759613691148650738957016015844830333168307020284281532026442272618372290646283794122772122665531108484704223311663270836645399554940741928358317884620420886609705267248656765357348477857852684140561714900614303731786621656041881975328169543884661780531057279582784036689401206706069028229798913082362331334839997133771880514515972024899408556517159759907883793675672065360125\", \"190286571838805495686895463752492174798162827967490343625540320679760700551286395956241059969689020885714190883323266375067607282890063444652926151862650426323339187596278760962390404656342309737428214493422028545912504503974763216230927196187743439226243880933947417760147785405444976177822143722569696182520826218120595298059020305548681823408268556482981325/38242608291912408815838081993045123864617058390583394828737640036167893859507494091864963383596867701436244007905770284939991912884465101575490548813894148831966132970730263562113961685364216989999844961688441914455435934703797359360780356482629495214859917249465567846934284121032247250332634283689409883499295469118485912489058982596725212975311140618764288\", \"15345379701153714436938289567639102307887273898834051456693981514956329731572600026866162286097662958712922836383881840211072389867463987895894067288699955858337488812343674818565432780224654423872618380928462939482247900055572079914753652915184313685270722583926261499687728814560680092231526501970431280783177357735398580700300402036873780385926225005561766822479878280891130232036389707452005183370152749056/3080426623087819678602049171756961824196425548529619576972793653585089380165862889092832375934535464160425580449193072125955685099151500755278763306599307218302635233595329082702148677300945556130106197481236122437978375963261172524503625593066102601042060541617791008722569799735202779005407381267021641545644264334109052258081225159748043792288699674153722046659880085850980843460715080965607434114275256125\", \"36443601662144279337033484452272105547257065463167427418525882851507989449375452076227652634440476502702584889057376829320548464677623038648843251719168810701744338735202853412651160681259533015293997501525430222870696235141468274274064390273214484922080219643095978640300874086585386991338440415203863901714217818222666715642467237183267303214471854472286478344/7307237990148312451155090506264642657872224684879860008436735430879314349554023096366846856470375025555139219961666754780864835035902856314981482268319886395881809659368275720375576152008289949085453326722156553603358879420820012964006978808113307340321824660484441618487292138631579616351777191144073820686595597986548374588839763719082323114663844043046087375\", \"1575294930860663922843149113097927168024893739962464327016763741314068438447271326302129681931564068796631337571133444163024224071270063174829664848259482066723104251718808936762938249028582992557822551950212098797718627418782376027133576209718376784834456568694813577764300716139817031545408608110880973380162736536313173329973171844528083756524804574267826691156368696436273087171467254161930265910972517504/315498546654512047637461608750018349421492986465373840347519942494904200733840189483934245529561231604050629653992944140351106887747105945984325466452136415067807666316202346895657914393512001212656936450425268507235863153258769360296536050028695266363553141327896064944506216017933135251875087069031098099192325817395958019524956320840925176589616439477134480262100237057953933117460110224783420562744140625\", \"7692057599553133417225997786980128299372439542315125030077404519679450372805989755158000864378924877036225189784045171045139667691524763609840822628706422918926410377185494048355128046783294954373197082851501927410350313585640237550107070936498164597231431242858771457898152684298047446530220873884022213114819556822050178579707210264243087257050468000092842761/1538814487241112760739561704846381585063002784795057066438330325566843108114787083741788078680861495340026117682606689156065008672344707615420501964123121620401073675430690541617930520947170306763541251152854304975131871537939618684186766168376514664494488691311397307418298556185724993104760692216619178358268934740746932420562664234738576394742559349407744000\", \"15190836470550557926140012263310230378455340797095100474720776113765300081463960235506950799869073894127884189857505951314428810423734978025409205413789025720642609035117121385453856877706229778165533034683130064865256448444765902482146676668197546098809055341050873494446231793312407516463576380102073171090898973046611572020564659042146465345334273595086941562425006763960197801018796906114925005810069684480/3035556598829526968124942916297025416522606357010637652635799096498208643970273828496655227572100159414352020909846298817521082538898702393916708804775798552206401718323929157863173504795127180177622667376867235806208021329981136637175570409791442328468473111768140746895005561471574356889047981458002257872092408771959478275534098789982899056118498417649167444480913552548249005268380838457505944462494874581\", \"2923754549090941424546974281011770689534961442264350984393235983189168024079617848190236639328676436485460311093391982825027512234467853098757486086492333410753919927528867817406389678461354257841007722472106464785557179844602277350411593959136520732862935740433163383885526249897183805981219416420390137516812715245569037561966929572448247077578419534651990827044/583599691615378545100950777601104007812792435102945248411439102112424251478512952087517463400054567832353967731887062349496616445419782499817548928078665212077449420216892583997505908858360011413290038645573504472422610780073975450391707084016931661068694024023083417126286468909117254531307085545768412513447197205482285022417611018126886491416133665625891075125\", \"441922815213568908489589193556560586318864326425397702047965372289295962228254658331201274291697626694859414786292266008476137667843874780506886929181835469302142365772763129838217316953835831059616268288399119642314758261677639945004547833810080700127847214666763863338091523753898362699222880772298183760217731228628442782431573977490761665091005756534420789258276075174436091798475838370152192077494553263232/88113527373573049332749294663402406454524640221866407165839162576979477138694653404281889227416977618913249275712917582743426231744980461918772793673202077716234026090308791893409200158969108910565467273725064769890443408324386897017825489615600787634985397885230455168591240328585041836771921929567914891379235573982442311269392541694564675053636078990836491104116280492254795616055818375774141667319774630875\", \"91197133767962483852278456285591810579974783077874307589555559715577599604626819245000672929518645004771085106770784762994476973842713035791487204122653245797126906189270204029735872508462106527240320932458036231707311992868347221176460407003487373754014365881209649632547685657666691589606571865740595829983849941049450471212387808617247938941417000965198123059467/18163679611214677813643455199979098261849405189805364986036911945012016248297645596270602508015864371788974684317239728239847888960155365342460843559658233069613218442910226128113196984801126248862273503232000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"733396724434554481470656964167233690851279923085197144879644750437402627936723531635898542414136943003236478432848965516925891956615111678444586384493883113385335463639674699443808084827715994137410743992130712903997815471369201406683862985677774155704267039224546352414417632475628136460919900347977754644214725932476856018335195927604771408949980634142255497812566866795799230501026066145434755838336990365184/145912495644159810313026420025053989609942265686388630266226856650796088768164358961644113076809511566125145395699271530802891523741636707532676065833327082092521989958971154798465784847092870457944857590623097781956884297103961713362268264159015928554707158239398721416218953003215109202771651993622244788505649098445109438104466256408060944298437033058380804126574878377874459371251056800895394904459469832875\", \"167606423853658713615749101123336326908381619586838606922565378505211386185130407423587264776519589295420758009764678759213587906216543160801059029133457062067529468464636376639307690657945597847080706144898920305379653754920571797771178341550808041652360635584401789901525709166172283390177673009483341826911179861584213314395893323035527116283758445038413646757280/33310364848744488727470761889861069993071965180756187311178124887286133554324042422503263994717993129539448310743598138364172889305532401505890384806078790034557049074169245078416704866867380089103064821732673967120808611636618526737138435792818828990403374766228037003927569643972203993263329403469747342204808360947840103843317533210523853631711601450617095736473\", \"22466735478643771803624909352181817912387732117378538284107485621001246177152644141853604633676939694208131243081227668237716194316732125445041260568403752325416203858329469477774720998849334961751541191761521224644520742691981372782009394826739249604257098248751626957528543558542443122470657230835176462612530464044652140581367666271771882198747182114685116336512604038833327707163107207664705120728068987996560512/4460342260599110071819142535903990817893424192972341872394014748315090430999224107274777695306032783105944721337053156074851240201179902835353097683269298594190456286888326067932777720561181760369783486872666974623910515795208353605697065447942804414120030678603538761538385793829787734830129764152263691296719726909633580318897787729004972323599773548689272008712427926734258913271101899780538635213826239542884125\", \"1972862002066252798837977155272535342727415329632252213508267781390870646909686724955861608046325765650407340102472833428905279473185818898693854344138403744757857928883601637909604082588338869612221777263582365745419719805587946558326048087138197694016224613118304623864709183681172362693106460535117459192992832969130895829916210933710820035479169562970982784580861/391262854245936198649509275719624152305206807261382621390946060636032376057385723427601113233050260359684153963520782285097664628279596618521963444574543409076428660874564026651742234728997339844161514273669735686516761239076529088145208958938384732800586298943281728435207452253170935715239392534815683367114290676180839217919539381651841151674859715992309727232000\", \"25408691426286653276004556426513401767718328640048945917745783225459709487487356095164164652218100925888847689099153320777389381851598236046402124684511968385325107497047025485302333503075085562533472482645023963717347867696861885363417595298751490212495932766872748125111115039311507374363000062513977436921772096443948159289707996749061007112458126301618769295162649600673247799961118662602756889448152517364992/5033870770817104909025512331238419776407331281944565644457345507262881100618908405924951559853352841154730802006750688581603270849880756026262217651685813584900300357685874044482329601894134443542753690048962260914642678445058891387041919581376195543193199307524572671344323361282633828144708683536721118910549933336800461248338059209853766305058943888965279863852107507075916981165164543199352920055389404296875\", \"616565940481577765011174617619124841631603944267256178093555235591208387588894068005162766513720546626399308168923904625210748051788652328072241494243040185611373035059619136712559505023703153194815611268503291295059648269772663939137446253437248541496631852986499688052678961495116210133458596866684413931188348798244969797973846568160999564540652111599082181871436/122025682149627484528651507368051367620578469392233875493556828623437869650284356703295836998178256875766319508797903923638967073687991229708051285605187358616531926112736402511567721889845693991963610192161413692928378708223712791930113386840109729368772998347036090902364801014045328348830748307179590755723160142468563977011700764517880467116766150322736003147125\", \"979882056834583241477188686550561625289337025747787132773853690143359657519481397575561812727394470125172272246774578404543257210124412718725081536309818383310896102958167337333430555168671327992395916735022711297435263157670501117734412587691271084981140167017421900852550822579410636184333142944411060788723653596377015359036101170054828623669169047118551010102258802465554033173968468183492058271365801755986560/193732066620504775981759812703028757608600125742477178751189607602983198559778039141192492589734277739017909889924488699372940787977794555519474807920198944109549023547259912324279741006975129518191081373554817584214941629021088206977532599055014150433581544599721903881284581257812850697423350805715586436114842183295730680490110793225514602133304729484547181740290534056445482186430729398701311563285494964645419\", \"1138059441890428903336718712159907364975959482163004276901676063186939296217569849990951930955270849692775077813359573394435924934540269310629731801376134549169322946310756738187834128956671195358413024062230774111935109203207768898525882417078119314003162592087920755572050993355843681931139257303484526223461840939880759908449181135029327442039666513325916729112853/224777393704985303260433439401503507705148576727364388720387174977154204629336985298082893443205223017966145098064861566754244624732671470935725326043491911142467178027013112527668183783450932992534517827863293825061296257420183669383719043873666284378647952385401303733274771042385666436214517205678674213118374889121542369996042313879258622144464565403138392064000\", \"614262617634904509410555695398092190166323289787703954329113412647342230855826568873946233136303566178604275296873234926652080462259552775254755109931312516616838091852915397846984381183732773411263828600108443070778861986849272794442105107285234729077818614332155890946804257724112143631642663084660012362691100872465148864413343598067567142977134846266425075195546265101720326272502009234689388355365794889444257557504/121200854655310345878069155190734381476914416893031941761756379148622591310152793328910334357724762079139509813381997287954319983165971628429295803162563856219211627796200599196263868781937234015821367575512548522790158101892507996780675863234181700253545912643548466256938936835469646114659598727592390628209362096738343417775009361678599075671154405137663077798419897932404104579113056038271753988669813988076515476125\", \"106893445531995430131837569895703697604978445859412739331042151546083234373443601923983714252801103551874986033841637079479794895452077803182698291822629713500021995241940133037200268381793282318691568234728329378829301282121562652452936297422136961147432559766896143081059518238234777055931999714973999553456547746825617168005650221542417216291412324174772893635832/21070287546583154895102927029203125577385528350171457634203261197137238923923245382493868134869009844094435068284335909266152042903157700510534904847257436666980671067329084409346149729385625108233234542133838924281113454526471855573271066865534480974484196644173270141056470857666632902827625475719738076524047736123182255306429677688129231682978570461273193359375\", \"1112742798776748551928744983308584493817112400536084744850969025063360679785378789764875076529575583792571198510306186417773101346425704969671256564494135750783642910394213727189639661184379341961737135764570942961692159177189753139209638929302928699705042832922774012622017270172331722295881412111812933593370743210214549038212395941675257558442878012136484052827439007483777859391215222647499741572327725689840850048/219121905514652575155579185322367175400669386131891843382447432851122462422992147756333729893028362013318264155489537138133372703295804002840920402482110260590055749843170064921843460498824128274420925357547023876488939786863662801268798987685503391058250902634999352652063668663245829496836853509616873246554292796823779397317819134891873583857621623143253788854530146303641400986028503534408870194989478421253057625\", \"983995170259637497940121707857673268620603982844439610076334749792119502557380361624096960070148627663305171311646851566811683351232268240169848810658089698606409195744471343416197434926513684882439596141368794175162315633192028977211909698595778839497844847281262559899914504080092844816319298286511436690429175757804604673752838786852277255064434365401871903307643705/193579499709739777577893639665643417521924510242119561765932078835121983190401762561436208758210519231103767232899529457440602166918701550386152070813526760823513884391055054076485295945972185402977095815609448651316824455250005505410192101148149284756928250258632031981439345164037318129987999546683113483700660879431801728391911161900686707231543216283304182063038464\", \"30691013076836380319652884848585431917439358375118437035944950498156836885409110087616602043242747413728866747975631727566613593257623099549583001362246649928075859944695060947434885707102684568632559339383409378997568182445019183928058902445738702610436187907199482604867148445903921474846103586253320950728989228898324829144701782792767763794895137313050381112872972806712570559942583906619373159053654481250809168128/6031936190594376585238407905469035598668211679521553144958053099463931217856780171872253258738635531385711702176347575597387389685526098889278278029314982721284691198967204664771178761416891317672705719303088746953644978471289001577698554025410820041497108311270431130911021653860874238212040640737171103823631718483572464361276703378587106311153455557896527384426327053165214814954154328483257657424873929502112904625\", \"33633002641218571027682690377239300567277297301791434890431645909447040830457253186262970747405514897340315490970846553666201190386457221846694126637998462873786334837901001833771510353365825087187582807843940479192544772559118293851131234910638705258664901225494129023244916125545283621607920983287799648992632814461828998517949449887522866259724675318233522060729654796/6603800575190864815125307817934327053530311915572323544225173935830559756077637251538096164499112411672913910767032482188570876526606118068929913515497400397562722669603861813453418621246538114872330536044519242663538662076583511078523573320035084744399535581216815034837553165853576616422592790103728141443697362408727056813977234078214386771115586436985105038873998875\", \"9090550743395453237608373761422705922989356346696677314277463900103283296889488490217663400349361962695279888433677856471792856853109469433355422802663947305503479561493033851081993247556828544308258821557994512133708656174864544457143793106703578476914924328960109390350040954158797845288786321215010324565010420734044059968931558099077932776525974187717655105951506223649947806568984848883258144616897526257038550656/1783219994432430133950472014582130883873515063182143523712063859964133099770763874744121895885645346884371273930727450069430704145915261127061538288702855011220545530326588799412076879985026006593893648911637986337776174555198865379578424838210466703683642106934154603710587408512357351455891557594977191641529451749437270208258072920514602243985184744955476557012910446023911358037761232253615162335336208343505859375\", \"396226087129511787616470716244996965529391571019620342657409150252952330537366537352182763477820160355931003174946109480036915624974500187179367618457008802667089004678925595775249725629495848146669773574395699032785024522882892752987825063933573399691764866816284097232869198405981830106568826923407996367321353003569052419999880089180418759265274331299787468134974811/77651132902382550540201641628906752945078964002822585000619340261128555048628863996784740469908853602590877726845475670110127527874088625214912598995012971630852593597027649154487264595100300180591016581254965295280089902497540043916128232871685159131211213497239568483141031137909208031392464815187505714066235868748950184065923236670418822911614780061752905170944000\", \"1288523130900767412477856952035690867153496584747510253984686336382980221603917538996138294311274357713893956725672062832264871415025750136690143411884111580335458539824573239771267043414225271729141508235839982033182605445173050590151912297720800168687369852280323356691345317649445843078291369394324862039143247087442309135074453265658730028145500871559458519282433012494054724678302957276371418936282902434203225600/252284450515080370603949213084529993395050575951188044032908270470514999880554862449223347761507020354321422785760279154913310488296485989979706208254206974075438570521939826124860483842758137231373182496438568202110337751291106165654945352183167578675508602832478752400011567482434301614269579368882858973850914513870297071866544875650189106576672289734326492492059816669288907018095832842249738081022227281715919357\", \"559506782175368748187145067236900803925823792088293851453005882621173124590368101213652371965740365119375069053747415415684193092607523211636912074219215053809881814859129515591479780669511533619258835199715146655774919418434080807837587396115955105126806762961292429904380132116986984435528307613054828929294602185927322238461491059740342387266084431988727321711184308176/109446188216864405154936682374609448082436347600301765944233278303643744736544109262794383069197271409398615846380701459882784547857821831816863216080069944818453908760476475874319791512782445408136169878207358663250499628002971644430164185578966399908622640732411885568638054229180673755690889471388585521113862492432946110902070139679164884208988489955874131206343597375\", \"365842109776085256207829452385781129402656684569922320812625438296958174120084800064669048017227033185969596458778213306152397766619692644694641677223213185977626940193107608138827771259334379895020377700759789774994800008933137569543592829220611543060189849601828342989023692876182148818363689293009174358168826340010491728715549904988196347316703985894355217235339548078187164176255405596310602921647203428200269666176/71497266937783826306774367225149833789788300609530680399994804704196212252148324552193149332755057982662844988588678159610516634667597707204818296457616315484973288944637139939912166034691155272078609876888919170894915224022982785138928008133003473320018151370486895637936102520353951511525996197267572355782608352075229547764732602557133494648237258900273354364050662921889937355682486287799239363976556848320046933875\", \"59378684894605773397070783936113244261297966863668546282887298999811950599772732377979382620766180662159460666220894896896564357533604962977968843474062092083279165837424210591042655271577974272394203253875965589611493384384257117088518521598379301169916060951350650621757237206805037261878212424267780312614942173870651684587166691539909068452932891649554575072205080763/11593916877920131260484148322810317629326850763057953025674154928920977965095141485536566217873796019006709247938019404840440511433467040918770165456925609124166970862430104329357419669175323763143377917913760028500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"440706629842402075137926797732405268015915199334341565218443748798479563505125605478061664327658137598204192554352688830679475840386882350034150077506804799859586772904929402683276898098601814091430598259347980573084686932949502809068565420937301632494387691284902026088950093888426872222813857928092871267130505744095697172494119689779474840037266295586359244899477781345249657455186847452249040895151288114085352974933708544/85971876318334010542313048056773419567285701852816309711738644074302467763075671531248793080425349570584102078764464196653843973936119037322000695949209283327606280423406302517302874806092835694196353778161663338667091195199032831587897410329509487165187753418615356836636352319310103639079123698118997500068644500893282438137614420288839230827096109835206605385673197123994357393257304049093683934224826006704198171592304125\", \"13220371178312284248107863849287558696210741535280184003301555188086761767176560823174196915070378763091889333203635784037294769747641959860810039816533609140662043493962707445564057197150603226797446933532133956054671103942520142568674339411250001585991743608723150284270101326419464088290151483823061613403673956918458456165552482913079283537536214967294211244361353060/2576683013797055224377707713704899315377379548630511095136568220145808780162671473907260623503552385384482723173913562423316997528913651044277418227616447815609873991028073011738113927961824632868956802271260292075825561646156680740323686126811928372672670917332613490241615850953660246271541592056143611581223295045062157404996958100136358649109693659623847024011265147\", \"1538372578072246705266078247950089219881197139399081643650271348770110178217959856819170325400476655944115553238940541695152110949081675985299189913515975242840473616169775880272489805123124548256666658584129873597192213080038937409046114908719298170078476325423466734429870048697383304265342125425087105698152643145531760853127801123272389134514333752173173161562273487752064850461823726948588221913540799816489566883798912/299566102446745552813544808169323270315327122249327394279467999308669285416179486075255023523726449428151807672528368606071047812907935426406886253284580296349349558797128593446316786243666290649442956134448480598303527795996222703837663605600624271807461605295956674925277658331760000117761013381199880905748188151556184620779667670278558839116983636972680749836497346863752662521197700717702790359162307617024566689271625\", \"281696937222363685333688097915539146272117417024070728031063821781398985795813333650547982965341298894634762289669256129805545549280355643122501181852136332529515756074502902204877664395456278205770206019663082511098956468724829475220996427130295010430751942126263620206886404244432409164651524408198286831329682605959881993845189585640874220032515465014097345759490750307207/54806274927935495596891312029173862473687610099325998583092091915101265393157631244775387832621032230434007486602816972765210205596482942091518459849775458089575743699797096697542306049628939919466378189656065461708686421130956996965004776108499273871055615413566043083634090083096967567965373203683231171594922347812966905149873265654962896456451681332216735396249206784000\", \"228506238533410805238253122961471637501498406104430046727793420497895852412513560203475440156216063574654372726194215013407325207763369075250819386897086702757125418327084312933061738392406321003231853349865003322697360659712771167066453430309997639548320673279964210730701373707765051246595806673865646607841876463608039111252607452843372970797479959213447237540830563469297144446069689149549515457318899981763489792/44418759813188470246596822974281932219088697005123285598909329328419879212164564561558656547678211265529803086702843380128457744445765859393426675396393053094588240457569380155526179040891009717323059641035189017918495485630657360525410506453554255734005459614858972904374739673834145083512160883402151636664208253116362089211658645312778404886460203600762546810897889629330022309705583438699250109493732452392578125\", \"2396110297187570506257836426251930521245117960980667897194680897478996322590925380310917400763581787981992131769075961259393685331523600287377841990678117113566991100720996059187144934569703045966210306282348527729533806882408323961336166190162075154579344185244957673138372347997134388801085788353482276257401005734929059700346687783400772331280644647089520646562669857652648/465370154262863030800729180763091967573522779260407615567563274096037297593764955820626213827962697601334935773802201919483657310282236100250543992334865461800976838791035335861420892967699843608855185710753433852279737724446294443337363478679601049432404435672469098850676302728116369979460222148206944323730586138087862719386327396334468302608499235112520318322763857676375\", \"1188272888075247520453568790651819187486389546755745961952033150576243575862120569399808467067800830890874391487822723879717525264875722720416173276963170672622214121308038530968291758445510982186014289745026439477197148445087614813262170975056866881909056450023324743409114115141145340480846088869807540798073417035168139476153897066325127540609756310068558610112731607522096096821938163134080426356894899245575410494080/230586762395914863625709048789913840511134004337945700368117795195769576856434588144361459740833007125516905017415184787078710001969815416281381427387949263792200577791644278234661952852149216540491852757174842146376788280677956350901082838474705227642420261641783722891948710833898248566893322144435457967452449965772543077421407816225704952270697016152452032506898311260979594550143344971416786595888053149375287120733\", \"1072184299258468249004114536023934869518152618369895613271618698908405514630154819453979477077738526673716264830106745031385951736108376866253955319711026042389282009348594845497252059906901748860111986811345742998968284077119165082435598381810306691078037018432766116865792677955520465319184311529667642995217214507658693259694586107847099911341219913576038605872218680562047/207882129535607118520818565811162643811811563516006836924341123976848022970024793004700710992938987476728640943834012473687892481059618823520721737479364352887178017866425027953255856440099446112508663603319745066750522936408781591578321031173620445865113295407603090322283539974563690157418931060565698315406021569491751612761888641141446406531645379264720684248398299136000\", \"158094023904374464057702010126993231151433474361820266584020400101533651587072432728050776506672527718975042616651177034635188178967462982926261516748842073587981953038445977514446838733557926696939591069712397947055261777416704028506441173540338327591514650398349069348381309688677335132100441905603664282735310299686268721634369502296867409514777359935022301425165750780988231639828675424239931533849896744198012747670272/30626384366513923671063955469537776291182594080083494737341604579575446319190916924682809546024369330706012653799783122328775875399363759308193432327358837772825609356553955350401725689682838701996446404559005896479618311357573203081153855961484398360670837599853294627153740224543175497655414585918231215639906924313779933211774291565425360415684556655021031131349317390382320286092667852173815259422737956767922154798375\", \"12216278924286401897470540169822542417611356797676160128176706721343511598951866107858729405615631246003458062949723290192242594609994613705183460814797527214549142043573863947658832694800184691222426521703728394203722420336773310908687071670107794543022567943478843065246011544888390757810534211554666736239506503613750756246364621509359804902243487113673014588325806249988332/2364584127734680580481708368927921125934330000162935118371174269642831409084634375654239735054363928748162229294829526339927907778510530444646754603322373712788147193691037688552857183116332292048731726305451516954679277320777955342295564000586923227775208580772868590742136150431152495718132142742153643081187691849828217592954519485869135930755646768375299870967864990234375\", \"578939195017447864385837341975558679292903716580114421030538728778491606282153588930983966100514147976321305616196463174070345884292672842497715966933722088536619333912687108737657068701352918582656105418491672377271304970407730786932913490869797471081081431072836814581099271832696990064828717287258860166842791984158634684078346453202928137987930328826212011774670396356151265781053547412633310327737900786639842674288716416/111966291649651600701875186827360807558960817589719096407887999108024557254221008849510152469119211567152616745769256123968832250104006560061907741567034087109512483357851919402017950812795426393415409198268246337542639470834168040295134130657073201020340432236723824670803498949071870597039309004562024033656488150406105175401372709011082725359382691270659245312133919518760328422827067578306005644825927050994860723405473375\", \"8041514821545833865350873212853873042112343327573364523948780030849543753072688526717886590013028227714585965095216381829914996539132359247488639692828639170075726301411777307168737667077730792892326979446426349813642680537699905651125068091362135055902152994216233622733424128982011248923051410141033146604688083721413402395290842738021365861670415833356403364696759583009635/1553937833499559104910551811592138833189892464446761247731330672284191313590708439680460540329836344767557599746234213006493842842879398684745864919973051635127080738612248150108793397855113122368507483429209127035263504194847798809612278864438287815470711036548695032421148125849669175729331459149833945183228413961985381338162155596008680906676498435954178226973272371625984\", \"12059659399309169167301353842123191409306995788633965680414620302285606896146667751472818541537183787935352700725982053536032930866708413010971856856768384974849695774437178790890015242323873769697407411558706626105140596160049735605389301414460825674631122462760014451298494875244754354054447697502521388381253293175367558014453865905104467382184997528879171136492277222127399012368677604910497789360212571238146627048080568400384/2328494054002703067219004484782931471919751585969487160602269605916676223315055450845942763690581877771159615428854802721943114463834992106300185328876910271612375509166975628540839858771078495267566008071532876816826751069408153323840515037497664871689085370699991860738368371510578076683395101062439493831773194498579620513073693022191702398601471237166387045790480861932005012807234071429628725981935147069738988682858417182625\", \"683009426705008850682549700382901603742691705123356866338951397347368059105140826655486518416578697931244347554322654428162554903861783227680935341690740579867651545205562690172425016836559678937794312287639193745517811234257062356826622207475918293015140472942579713388671782202262396642735640315948612572908444501108579457520714632371056288874351015666995549139003946314085696/131769214246522869780429817236150406548549044658474416909806179734873399109656411633488099249198882165279745627038984487365589625562901914030850178330133080409420340227179447548044572594184601425691821617928130423410997853384425373999967759499571890326740433081063424903098252502791477854302204200941376983295622430177445507316706609802292121282957519571162158620971952084486375\", \"1418116259749091420309271913909337143756589314597557128553117870573928055109322864794169592355058370891251425125187770724828108988587888087023982451205475980371440423992838481547236638456717520835668859093413956339261802305597694403381021863258753441889536361061407579332570493634254542013337999844407181346815549594836374497512447969751514466481466717590255369810506813543577735080228718660747940956248427356785784199073569408/273368882980516556922532339653303822104510203916024760371844491705599093435133738774975538364241630079468712981056336655766117378160822393876348755370711942273876284944422610974149712212944211513462921649872232656449940987552227525504529710373144228818606127541937831103642415534318303187393593236209298242574677293352798419428712873685798636474667204083938875672934235816396371477146089168375198141802684403955936431884765625\", \"546411077581845999248238069684194831621691193366466972898628141511422317954477211865167402284211971296286346492698354214043840080181702652132835681239302798339667835439189275457116051279366194551632712819028177402221815140045210690908631767786711675029194359998826252332434573121740830827417293557234891406021102083555472155479148332697839972702631641910213821827820374586459319/105246945889799140338072754365901705544530661781295362563214285953881890233987516230568663143342952799036341701952267011236663118111226623815975847494372076420199418712941018288738590264475520229651370015377608638075866459684692488079223686296541020897904588347083045723167762682959422858996673894180805702299907478685374065593161226849447131100462022089783265346597553176576000\", \"2398330640958841474772606439916070050977544535580605737383995160447105736276950196885906408317628083110923322157113892928963237845914017845444295040924101784423382681801754191301860383927129006953354739240926643562987838836997453985855576402628166875869041032631651591871962852884189548538272285387092843044669499688035134181859376665409767886188304314888753894905317929877238322615838524354191263502347881033855441181420399360/461588070868590122892265681879734295007029130965626060552783760068897000195207878227714842617470320231527222074701444349530952699708435668339712860464533455345665068841333232359698449088497137068713309811942968433868609329301082001752617420002377892756821532220676085014874112083615054550278903960627185675459015343606391094523511117705747842645927349130302549554534056269331809016770715819934970200483161548527932617036185253\", \"6041015879424725383006424536130409209607854044642113747266098198777011981328765528361630516108680392500990580908509403483891763219659726090675140672989657743882183951954294745396417829943469201306594018454995862321821016087416840247422350906412007336103086620396467456181771583200365740253389107968122850063607085957109965406634738740996318415514360956028575560979203447735121436/1161752799109428422288020947061281540989708937450568100764830251908850596717606701047413407636907934320789870175907792017513896999208892282137299070761467096211814586909598705615312819596495636017728313513520193786266452836805291464826226833593878504804389728477191170027729963773716267868284479768397603444919008915279522376004326398403851684761808785381609370767169521034383625\", \"13240077436443988749179508462267267187169441948722358165090554769250505713747934643200804819418670147225695324432684266924694524337920816452346599774452681831320005286326986675907899608537972384924882996757503264622991355949039882526389342174307168805166215838138277557052303430492669193939212362638263582899713198716541723383138016564027766560215944409353427176135895982596327685665844815618402881202645610620284792793420780517248/2544223084468158291883698813309541801455311468982232546872485444308211415529998472787377800559884210837213042932180479090277285630234238711851480232520137856848809986631784843528381778520727465146661792797924458540957133423665746229799675650290296217658444899605236550972043549278128087645211909479009099766619355677984218929672461506691980442071860591767266913041147587815452007726513853820116629482732060593116624596368806566625\", \"1953999166296955830935495158735359200362904181792947794529339487489730042568305997099959302322956898299616194932283060554261566410988618045107398092345476532371402134206635235570281738377188438407703089325315446371127042537576093536896282955524842632708645655481028161471313608974238110718242273935956977555610147714316158486553633871312187084618154014921190595222799283957140353/375191165084882521037046014569185165885459082629136124177286500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"];\r\n            if(CACHE[x]) {\r\n                return Frac.quick.apply(null, CACHE[x].split('/'));\r\n            }\r\n            x = new Frac(x);\r\n            var n = 80;\r\n            var retval = new Frac(0);\r\n            var a = x.subtract(new Frac(1));\r\n            var b = x.add(new Frac(1));\r\n            for(var i = 0; i < n; i++) {\r\n                var t = new Frac(2 * i + 1);\r\n                var k = Math2.bigpow(a.divide(b), t);\r\n                var r = t.clone().invert().multiply(k);\r\n                retval = retval.add(r);\r\n\r\n            }\r\n            return retval.multiply(new Frac(2));\r\n        },\r\n        //the factorial function but using the big library instead\r\n        factorial: function (x) {\r\n            var is_int = x % 1 === 0;\r\n\r\n            /*factorial for negative integers is complex infinity according to Wolfram Alpha*/\r\n            if(is_int && x < 0)\r\n                return NaN;\r\n\r\n            if(!is_int)\r\n                return Math2.gamma(x + 1);\r\n\r\n            var retval = 1;\r\n            for(var i = 2; i <= x; i++)\r\n                retval = retval * i;\r\n            return retval;\r\n        },\r\n        //double factorial\r\n        //http://mathworld.wolfram.com/DoubleFactorial.html\r\n        dfactorial: function (x) {\r\n            if(isInt(x)) {\r\n                var even = x % 2 === 0;\r\n                /* If x = even then n = x/2 else n = (x-1)/2*/\r\n                var n = even ? x / 2 : (x + 1) / 2;\r\n                /*the return value*/\r\n                var r = new Frac(1);\r\n                /*start the loop*/\r\n                if(even)\r\n                    for(var i = 1; i <= n; i++)\r\n                        r = r.multiply(new Frac(2).multiply(new Frac(i)));\r\n                else\r\n                    for(var i = 1; i <= n; i++)\r\n                        r = r.multiply(new Frac(2).multiply(new Frac(i)).subtract(new Frac(1)));\r\n            }\r\n            else {\r\n                /*Not yet extended to bigNum*/\r\n                r = Math.pow(2, (1 + 2 * x - Math.cos(Math.PI * x)) / 4) * Math.pow(Math.PI, (Math.cos(Math.PI * x) - 1) / 4) * Math2.gamma(1 + x / 2);\r\n            }\r\n\r\n            /*done*/\r\n            return r;\r\n        },\r\n        GCD: function () {\r\n            var args = arrayUnique([].slice.call(arguments)\r\n                    .map(function (x) {\r\n                        return Math.abs(x);\r\n                    })).sort(),\r\n                    a = Math.abs(args.shift()),\r\n                    n = args.length;\r\n\r\n            while(n-- > 0) {\r\n                var b = Math.abs(args.shift());\r\n                while(true) {\r\n                    a %= b;\r\n                    if(a === 0) {\r\n                        a = b;\r\n                        break;\r\n                    }\r\n                    b %= a;\r\n                    if(b === 0)\r\n                        break;\r\n                    ;\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        QGCD: function () {\r\n            var args = [].slice.call(arguments);\r\n            var a = args[0];\r\n            for(var i = 1; i < args.length; i++) {\r\n                var b = args[i];\r\n                var sign = a.isNegative() && b.isNegative() ? -1 : 1;\r\n                a = b.gcd(a);\r\n                if(sign < 0)\r\n                    a.negate();\r\n            }\r\n            return a;\r\n        },\r\n        LCM: function (a, b) {\r\n            return (a * b) / Math2.GCD(a, b);\r\n        },\r\n        //pow but with the handling of negative numbers\r\n        //http://stackoverflow.com/questions/12810765/calculating-cubic-root-for-negative-number\r\n        pow: function (b, e) {\r\n            if(b < 0) {\r\n                if(Math.abs(e) < 1) {\r\n                    /*nth root of a negative number is imaginary when n is even*/\r\n                    if(1 / e % 2 === 0)\r\n                        return NaN;\r\n                    return -Math.pow(Math.abs(b), e);\r\n                }\r\n            }\r\n            return Math.pow(b, e);\r\n        },\r\n        factor: function (n) {\r\n            n = Number(n);\r\n            var sign = Math.sign(n); /*store the sign*/\r\n            /*move the number to absolute value*/\r\n            n = Math.abs(n);\r\n            var ifactors = Math2.ifactor(n);\r\n            var factors = new Symbol();\r\n            factors.symbols = {};\r\n            factors.group = CB;\r\n            for(var x in ifactors) {\r\n                var factor = new Symbol(1);\r\n                factor.group = P; /*cheat a little*/\r\n                factor.value = x;\r\n                factor.power = new Symbol(ifactors[x]);\r\n                factors.symbols[x] = factor;\r\n            }\r\n            factors.updateHash();\r\n\r\n            if(n === 1) {\r\n                factors = new Symbol(n);\r\n            }\r\n\r\n            /*put back the sign*/\r\n            if(sign < 0)\r\n                factors.negate();\r\n\r\n            return factors;\r\n        },\r\n        /**\r\n         * Uses trial division\r\n         * @param {Integer} n - the number being factored\r\n         * @param {object} factors -  the factors object\r\n         * @returns {object}\r\n         */\r\n        sfactor: function (n, factors) {\r\n            factors = factors || {};\r\n            var r = Math.floor(Math.sqrt(n));\r\n            var lcprime = PRIMES[PRIMES.length - 1];\r\n            /*a one-time cost... Hopefully ... And don't bother for more than a million*/\r\n            /*takes too long*/\r\n            if(r > lcprime && n < 1e6)\r\n                generatePrimes(r);\r\n            var l = PRIMES.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var prime = PRIMES[i];\r\n                /*trial division*/\r\n                while(n % prime === 0) {\r\n                    n = n / prime;\r\n                    factors[prime] = (factors[prime] || 0) + 1;\r\n                }\r\n            }\r\n            if(n > 1)\r\n                factors[n] = 1;\r\n            return factors;\r\n        },\r\n        /**\r\n         * Pollard's rho\r\n         * @param {Integer} n\r\n         * @returns {object}\r\n         */\r\n        ifactor: function (n) {\r\n            var input = new bigInt(n);\r\n\r\n            n = String(n);\r\n\r\n            if(n === '0')\r\n                return {'0': 1};\r\n            n = new bigInt(n); /*convert to bigInt for safety*/\r\n            var sign = n.sign ? -1 : 1;\r\n            n = n.abs();\r\n            var factors = {}; /*factor object being returned.*/\r\n            if(n.lt('65536')) { /*less than 2^16 just use trial division*/\r\n                factors = Math2.sfactor(n, factors);\r\n            }\r\n            else {\r\n                var add = function (e) {\r\n                    if(!e.isPrime()) {\r\n                        factors = Math2.sfactor(e, factors);\r\n                    }\r\n                    else\r\n                        factors[e] = (factors[e] || 0) + 1;\r\n                };\r\n\r\n                try {\r\n                    //set a safety\r\n                    var max = 1e3;\r\n                    var safety = 0;\r\n\r\n                    while(!n.abs().equals(1)) {\r\n                        if(n.isPrime()) {\r\n                            add(n);\r\n                            break;\r\n                        }\r\n                        else {\r\n                            function rho(c) {\r\n                                var xf = new bigInt(c),\r\n                                        cz = 2,\r\n                                        x = new bigInt(c),\r\n                                        factor = new bigInt(1);\r\n\r\n                                while(factor.equals(1)) {\r\n                                    for(var i = 0; i <= cz && factor.equals(1); i++) {\r\n                                        //trigger the safety\r\n                                        if(safety++ > max)\r\n                                            throw new Error('stopping');\r\n\r\n                                        x = x.pow(2).add(1).mod(n);\r\n                                        factor = bigInt.gcd(x.minus(xf).abs(), n);\r\n                                    }\r\n\r\n                                    cz = cz * 2;\r\n                                    xf = x;\r\n                                }\r\n                                if(factor.equals(n)) {\r\n                                    return rho(c + 1);\r\n                                }\r\n                                return factor;\r\n                            }\r\n                            var factor = rho(2);\r\n                            add(factor);\r\n                            /*divide out the factor*/\r\n                            n = n.divide(factor);\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    //reset factors\r\n                    factors = {};\r\n                    add(input);\r\n                }\r\n\r\n            }\r\n\r\n            /*put the sign back*/\r\n            if(sign === -1) {\r\n                var sm = arrayMin(keys(factors)); /*/get the smallest number*/\r\n                factors['-' + sm] = factors[sm];\r\n                delete factors[sm];\r\n            }\r\n\r\n            return factors;\r\n        },\r\n        //factors a number into rectangular box. If sides are primes that this will be\r\n        //their prime factors. e.g. 21 -> (7)(3), 133 -> (7)(19)\r\n        boxfactor: function (n, max) {\r\n            max = max || 200; //stop after this number of iterations\r\n            var c, r,\r\n                    d = Math.floor((5 / 12) * n), //the divisor\r\n                    i = 0, //number of iterations\r\n                    safety = false;\r\n            while(true) {\r\n                c = Math.floor(n / d);\r\n                r = n % d;\r\n                if(r === 0)\r\n                    break; //we're done\r\n                if(safety)\r\n                    return [n, 1];\r\n                d = Math.max(r, d - r);\r\n                i++;\r\n                safety = i > max;\r\n            }\r\n            return [c, d, i];\r\n        },\r\n        fib: function (n) {\r\n            var sign = Math.sign(n);\r\n            n = Math.abs(n);\r\n            sign = even(n) ? sign : Math.abs(sign);\r\n            var a = 0, b = 1, f = 1;\r\n            for(var i = 2; i <= n; i++) {\r\n                f = a + b;\r\n                a = b;\r\n                b = f;\r\n            }\r\n            return f * sign;\r\n        },\r\n        mod: function (x, y) {\r\n            return x % y;\r\n        },\r\n        //http://mathworld.wolfram.com/IntegerPart.html\r\n        integer_part: function (x) {\r\n            var sign = Math.sign(x);\r\n            return sign * Math.floor(Math.abs(x));\r\n        },\r\n        simpson: function (f, a, b, step) {\r\n            var get_value = function (f, x, side) {\r\n                var v = f(x);\r\n                var d = 0.000000000001;\r\n                if(isNaN(v)) {\r\n                    v = f(side === 1 ? x + d : x - d);\r\n                }\r\n                return v;\r\n            };\r\n\r\n            step = step || 0.0001;\r\n            //calculate the number of intervals\r\n            var n = Math.abs(Math.floor((b - a) / step));\r\n            //simpson's rule requires an even number of intervals. If it's not then add 1\r\n            if(n % 2 !== 0)\r\n                n++;\r\n            //get the interval size\r\n            var dx = (b - a) / n;\r\n            //get x0\r\n            var retval = get_value(f, a, 1);\r\n\r\n            //get the middle part 4x1+2x2+4x3 ...\r\n            //but first set a flag to see if it's even or odd.\r\n            //The first one is odd so we start there\r\n            var even = false;\r\n            //get x1\r\n            var xi = a + dx;\r\n            //the coefficient\r\n            var c, k;\r\n            //https://en.wikipedia.org/wiki/Simpson%27s_rule\r\n            for(var i = 1; i < n; i++) {\r\n                c = even ? 2 : 4;\r\n                k = c * get_value(f, xi, 1);\r\n                retval += k;\r\n                //flip the even flag\r\n                even = !even;\r\n                //increment xi\r\n                xi += dx;\r\n            }\r\n\r\n            //add xn\r\n            return (retval + get_value(f, xi, 2)) * (dx / 3);\r\n\r\n        },\r\n        /**\r\n         * https://github.com/scijs/integrate-adaptive-simpson\r\n         * @param {Function} f - the function being integrated\r\n         * @param {Number} a - lower bound\r\n         * @param {Number} b - upper bound\r\n         * @param {Number} tol - step width\r\n         * @param {Number} maxdepth\r\n         * @returns {Number}\r\n         */\r\n        num_integrate: function (f, a, b, tol, maxdepth) {\r\n            if(maxdepth < 0)\r\n                throw new Error('max depth cannot be negative');\r\n\r\n            /* This algorithm adapted from pseudocode in:*/\r\n            /* http://www.math.utk.edu/~ccollins/refs/Handouts/rich.pdf*/\r\n            function adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, depth, state) {\r\n                if(state.nanEncountered) {\r\n                    return NaN;\r\n                }\r\n                var h, f1, f2, sl, sr, s2, m, V1, V2, err;\r\n                h = b - a;\r\n                f1 = f(a + h * 0.25);\r\n                f2 = f(b - h * 0.25);\r\n                /* Simple check for NaN:*/\r\n                if(isNaN(f1)) {\r\n                    state.nanEncountered = true;\r\n                    return;\r\n                }\r\n                /* Simple check for NaN:*/\r\n                if(isNaN(f2)) {\r\n                    state.nanEncountered = true;\r\n                    return;\r\n                }\r\n\r\n                sl = h * (fa + 4 * f1 + fm) / 12;\r\n                sr = h * (fm + 4 * f2 + fb) / 12;\r\n                s2 = sl + sr;\r\n                err = (s2 - V0) / 15;\r\n\r\n                if(state.maxDepthCount > 1000 * maxdepth) {\r\n                    return;\r\n                }\r\n\r\n\r\n                if(depth > maxdepth) {\r\n                    state.maxDepthCount++;\r\n                    return s2 + err;\r\n                }\r\n                else if(Math.abs(err) < tol) {\r\n                    return s2 + err;\r\n                }\r\n                else {\r\n                    m = a + h * 0.5;\r\n                    V1 = adsimp(f, a, m, fa, f1, fm, sl, tol * 0.5, maxdepth, depth + 1, state);\r\n                    if(isNaN(V1)) {\r\n                        state.nanEncountered = true;\r\n                        return NaN;\r\n                    }\r\n                    V2 = adsimp(f, m, b, fm, f2, fb, sr, tol * 0.5, maxdepth, depth + 1, state);\r\n\r\n                    if(isNaN(V2)) {\r\n                        state.nanEncountered = true;\r\n                        return NaN;\r\n                    }\r\n\r\n                    return V1 + V2;\r\n                }\r\n            }\r\n\r\n            function integrate(f, a, b, tol, maxdepth) {\r\n                var state = {\r\n                    maxDepthCount: 0,\r\n                    nanEncountered: false\r\n                };\r\n\r\n                if(tol === undefined) {\r\n                    tol = 1e-9;\r\n                }\r\n                if(maxdepth === undefined) {\r\n                    /*Issue #458 - This was lowered because of performance issues. */\r\n                    /*This was suspected from before but is now confirmed with this issue*/\r\n                    maxdepth = 45;\r\n                }\r\n\r\n                var fa = f(a);\r\n                var fm = f(0.5 * (a + b));\r\n                var fb = f(b);\r\n\r\n                var V0 = (fa + 4 * fm + fb) * (b - a) / 6;\r\n\r\n                var result = adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, 1, state);\r\n\r\n                if(state.maxDepthCount > 0) {\r\n                    warn('integrate-adaptive-simpson: Warning: maximum recursion depth (' + maxdepth + ') reached ' + state.maxDepthCount + ' times');\r\n                }\r\n\r\n                if(state.nanEncountered) {\r\n                    throw new Error('Function does not converge over interval!');\r\n                }\r\n\r\n                return result;\r\n            }\r\n            var retval;\r\n\r\n            try {\r\n                retval = integrate(f, a, b, tol, maxdepth);\r\n            }\r\n            catch(e) {\r\n                /*fallback to non-adaptive*/\r\n                return Math2.simpson(f, a, b);\r\n            }\r\n            return nround(retval, 12);\r\n        },\r\n        //https://en.wikipedia.org/wiki/Trigonometric_integral\r\n        //CosineIntegral\r\n        Ci: function (x) {\r\n            var n = 20,\r\n                    /*roughly EulerMascheroni*/\r\n                    g = 0.5772156649015329,\r\n                    sum = 0;\r\n            for(var i = 1; i < n; i++) {\r\n                /*cache 2n*/\r\n                var n2 = 2 * i;\r\n                sum += (Math.pow(-1, i) * Math.pow(x, n2)) / (n2 * Math2.factorial(n2));\r\n            }\r\n            return Math.log(x) + g + sum;\r\n        },\r\n        /*SineIntegral*/\r\n        Si: function (x) {\r\n            var n = 20,\r\n                    sum = 0;\r\n            for(var i = 0; i < n; i++) {\r\n                var n2 = 2 * i;\r\n                sum += (Math.pow(-1, i) * Math.pow(x, n2 + 1)) / ((n2 + 1) * Math2.factorial(n2 + 1));\r\n            }\r\n            return sum;\r\n        },\r\n        /*ExponentialIntegral*/\r\n        Ei: function (x) {\r\n            if(Number(x) === 0)\r\n                return -Infinity;\r\n            var n = 30,\r\n                    g = 0.5772156649015328606, /*roughly EulerMascheroni*/\r\n                    sum = 0;\r\n            for(var i = 1; i < n; i++) {\r\n                sum += Math.pow(x, i) / (i * Math2.factorial(i));\r\n            }\r\n            return g + Math.abs(Math.log(x)) + sum;\r\n        },\r\n        /*Hyperbolic Sine Integral*/\r\n        /*http://mathworld.wolfram.com/Shi.html*/\r\n        Shi: function (x) {\r\n            var n = 30,\r\n                    sum = 0,\r\n                    k, t;\r\n            for(var i = 0; i < n; i++) {\r\n                k = 2 * i;\r\n                t = k + 1;\r\n                sum += Math.pow(x, t) / (t * t * Math2.factorial(k));\r\n            }\r\n            return sum;\r\n        },\r\n        /*the cosine integral function*/\r\n        Chi: function (x) {\r\n            var dx, g, f;\r\n            dx = 0.001;\r\n            g = 0.5772156649015328606;\r\n            f = function (t) {\r\n                return (Math.cosh(t) - 1) / t;\r\n            };\r\n            return Math.log(x) + g + Math2.num_integrate(f, 0.002, x, dx);\r\n        },\r\n        /*the log integral*/\r\n        Li: function (x) {\r\n            return Math2.Ei(Math2.bigLog(x));\r\n        },\r\n        /*the gamma incomplete function*/\r\n        gamma_incomplete: function (n, x) {\r\n            var t = n - 1,\r\n                    sum = 0,\r\n                    x = x || 0;\r\n            for(var i = 0; i < t; i++) {\r\n                sum += Math.pow(x, i) / Math2.factorial(i);\r\n            }\r\n            return Math2.factorial(t) * Math.exp(-x) * sum;\r\n        },\r\n        /*\r\n         * Heaviside step function - Moved from Special.js (originally contributed by Brosnan Yuen)\r\n         * Specification : http://mathworld.wolfram.com/HeavisideStepFunction.html\r\n         * if x > 0 then 1\r\n         * if x == 0 then 1/2\r\n         * if x < 0 then 0\r\n         */\r\n        step: function (x) {\r\n            if(x > 0)\r\n                return 1;\r\n            if(x < 0)\r\n                return 0;\r\n            return 0.5;\r\n        },\r\n        /*\r\n         * Rectangle function - Moved from Special.js (originally contributed by Brosnan Yuen)\r\n         * Specification : http://mathworld.wolfram.com/RectangleFunction.html\r\n         * if |x| > 1/2 then 0\r\n         * if |x| == 1/2 then 1/2\r\n         * if |x| < 1/2 then 1\r\n         */\r\n        rect: function (x) {\r\n            var x = Math.abs(x);\r\n            if(x === 0.5)\r\n                return x;\r\n            if(x > 0.5)\r\n                return 0;\r\n            return 1;\r\n        },\r\n        /*\r\n         * Sinc function - Moved from Special.js (originally contributed by Brosnan Yuen)\r\n         * Specification : http://mathworld.wolfram.com/SincFunction.html\r\n         * if x == 0 then 1\r\n         * otherwise sin(x)/x\r\n         */\r\n        sinc: function (x) {\r\n            if(x.equals(0))\r\n                return 1;\r\n            return Math.sin(x) / x;\r\n        },\r\n        /*\r\n         * Triangle function - Moved from Special.js (originally contributed by Brosnan Yuen)\r\n         * Specification : http://mathworld.wolfram.com/TriangleFunction.html\r\n         * if |x| >= 1 then 0\r\n         * if |x| < then 1-|x|\r\n         */\r\n        tri: function (x) {\r\n            x = Math.abs(x);\r\n            if(x >= 1)\r\n                return 0;\r\n            return 1 - x;\r\n        },\r\n        //https://en.wikipedia.org/wiki/Nth_root_algorithm\r\n        nthroot: function (A, n) {\r\n            /*make sure the input is of type Frac*/\r\n            if(!(A instanceof Frac))\r\n                A = new Frac(A.toString());\r\n            if(!(n instanceof Frac))\r\n                n = new Frac(n.toString());\r\n            if(n.equals(1))\r\n                return A;\r\n            /*begin algorithm*/\r\n            var xk = A.divide(new Frac(2)); /*x0*/\r\n            var e = new Frac(1e-15);\r\n            var dk, dk0, d0;\r\n            var a = n.clone().invert(),\r\n                    b = n.subtract(new Frac(1));\r\n            do {\r\n                var powb = Math2.bigpow(xk, b);\r\n                var dk_dec = a.multiply(A.divide(powb).subtract(xk)).toDecimal(25);\r\n                dk = Frac.create(dk_dec);\r\n                if(d0)\r\n                    break;\r\n\r\n                xk = xk.add(dk);\r\n                /*check to see if there's no change from the last xk*/\r\n                var dk_dec = dk.toDecimal();\r\n                d0 = dk0 ? dk0 === dk_dec : false;\r\n                dk0 = dk_dec;\r\n            }\r\n            while(dk.abs().gte(e))\r\n\r\n            return xk;\r\n        },\r\n        /*https://gist.github.com/jiggzson/0c5b33cbcd7b52b36132b1e96573285f*/\r\n        /*Just the square root function but big :)*/\r\n        sqrt: function (n) {\r\n            if(!(n instanceof Frac))\r\n                n = new Frac(n);\r\n            var xn, d, ld, same_delta;\r\n            var c = 0; /*counter*/\r\n            var done = false;\r\n            var delta = new Frac(1e-20);\r\n            xn = n.divide(new Frac(2));\r\n            var safety = 1000;\r\n            do {\r\n                /*break if we're not converging*/\r\n                if(c > safety)\r\n                    throw new Error('Unable to calculate square root for ' + n);\r\n                xn = xn.add(n.divide(xn)).divide(new Frac(2));\r\n                xn = new Frac(xn.decimal(30));\r\n                /*get the difference from the true square*/\r\n                d = n.subtract(xn.multiply(xn));\r\n                /*if the square of the calculated number is close enough to the number*/\r\n                /*we're getting the square root or the last delta was the same as the new delta*/\r\n                /*then we're done*/\r\n                same_delta = ld ? ld.equals(d) : false;\r\n                if(d.clone().abs().lessThan(delta) || same_delta)\r\n                    done = true;\r\n                /*store the calculated delta*/\r\n                ld = d;\r\n                c++; /*increase the counter*/\r\n            }\r\n            while(!done)\r\n\r\n            return xn;\r\n        }\r\n    };\r\n    //link the Math2 object to Settings.FUNCTION_MODULES\r\n    Settings.FUNCTION_MODULES.push(Math2);\r\n    reserveNames(Math2); //reserve the names in Math2\r\n\r\n\r\n//Polyfills ====================================================================\r\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/\r\n    Math.sign = Math.sign || function (x) {\r\n        x = +x; // convert to a number\r\n        if(x === 0 || isNaN(x)) {\r\n            return x;\r\n        }\r\n        return x > 0 ? 1 : -1;\r\n    };\r\n\r\n    Math.cosh = Math.cosh || function (x) {\r\n        var y = Math.exp(x);\r\n        return (y + 1 / y) / 2;\r\n    };\r\n\r\n    Math.sech = Math.sech || function (x) {\r\n        return 1 / Math.cosh(x);\r\n    };\r\n\r\n    Math.csch = Math.csch || function (x) {\r\n        return 1 / Math.sinh(x);\r\n    };\r\n\r\n    Math.coth = Math.coth || function (x) {\r\n        return 1 / Math.tanh(x);\r\n    };\r\n\r\n    Math.sinh = Math.sinh || function (x) {\r\n        var y = Math.exp(x);\r\n        return (y - 1 / y) / 2;\r\n    };\r\n\r\n    Math.tanh = Math.tanh || function (x) {\r\n        if(x === Infinity) {\r\n            return 1;\r\n        }\r\n        else if(x === -Infinity) {\r\n            return -1;\r\n        }\r\n        else {\r\n            var y = Math.exp(2 * x);\r\n            return (y - 1) / (y + 1);\r\n        }\r\n    };\r\n\r\n    Math.asinh = Math.asinh || function (x) {\r\n        if(x === -Infinity) {\r\n            return x;\r\n        }\r\n        else {\r\n            return Math.log(x + Math.sqrt(x * x + 1));\r\n        }\r\n    };\r\n\r\n    Math.acosh = Math.acosh || function (x) {\r\n        return Math.log(x + Math.sqrt(x * x - 1));\r\n    };\r\n\r\n    Math.atanh = Math.atanh || function (x) {\r\n        return Math.log((1 + x) / (1 - x)) / 2;\r\n    };\r\n\r\n    Math.log10 = Math.log10 || function (x) {\r\n        return Math.log(x) * Math.LOG10E;\r\n    };\r\n\r\n    Math.trunc = Math.trunc || function (x) {\r\n        if(isNaN(x)) {\r\n            return NaN;\r\n        }\r\n        if(x > 0) {\r\n            return Math.floor(x);\r\n        }\r\n        return Math.ceil(x);\r\n    };\r\n\r\n//Global functions =============================================================\r\n    /**\r\n     * This method will return a hash or a text representation of a Symbol, Matrix, or Vector.\r\n     * If all else fails it *assumes* the object has a toString method and will call that.\r\n     *\r\n     * @param {Object} obj\r\n     * @param {String} option get is as a hash\r\n     * @param {int} useGroup\r\n     * @returns {String}\r\n     */\r\n    function text(obj, option, useGroup, decp) {\r\n        var asHash = option === 'hash',\r\n                //whether to wrap numbers in brackets\r\n                wrapCondition = undefined,\r\n                opt = asHash ? undefined : option,\r\n                asDecimal = opt === 'decimal' || opt === 'decimals';\r\n\r\n        if(asDecimal && typeof decp === 'undefined')\r\n            decp = 16;\r\n\r\n        function toString(obj) {\r\n            switch(option)\r\n            {\r\n                case 'decimals':\r\n                case 'decimal':\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return false;\r\n                    };\r\n                    return obj.valueOf();\r\n                case 'recurring':\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return str.indexOf(\"'\") !== -1;\r\n                    };\r\n\r\n                    var str = obj.toString();\r\n                    //verify that the string is actually a fraction\r\n                    var frac = /^-?\\d+(?:\\/\\d+)?$/.exec(str);\r\n                    if(frac.length === 0)\r\n                        return str;\r\n\r\n                    //split the fraction into the numerator and denominator\r\n                    var parts = frac[0].split('/');\r\n                    var negative = false;\r\n                    var m = Number(parts[0]);\r\n                    if(m < 0) {\r\n                        m = -m;\r\n                        negative = true;\r\n                    }\r\n                    var n = Number(parts[1]);\r\n                    if(!n)\r\n                        n = 1;\r\n\r\n                    //https://softwareengineering.stackexchange.com/questions/192070/what-is-a-efficient-way-to-find-repeating-decimal#comment743574_192081\r\n                    var quotient = Math.floor(m / n), c = 10 * (m - quotient * n);\r\n                    quotient = quotient.toString() + \".\";\r\n                    while(c && c < n) {\r\n                        c *= 10;\r\n                        quotient += \"0\";\r\n                    }\r\n                    var digits = \"\", passed = [], i = 0;\r\n                    while(true) {\r\n                        if(typeof passed[c] !== 'undefined') {\r\n                            var prefix = digits.slice(0, passed[c]),\r\n                                    cycle = digits.slice(passed[c]),\r\n                                    result = quotient + prefix + \"'\" + cycle + \"'\";\r\n                            return (negative ? \"-\" : \"\") + result.replace(\"'0'\", \"\").replace(/\\.$/, \"\");\r\n                        }\r\n                        var q = Math.floor(c / n), r = c - q * n;\r\n                        passed[c] = i;\r\n                        digits += q.toString();\r\n                        i += 1;\r\n                        c = 10 * r;\r\n                    }\r\n                case 'mixed':\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return str.indexOf('/') !== -1;\r\n                    };\r\n\r\n                    var str = obj.toString();\r\n                    //verify that the string is actually a fraction\r\n                    var frac = /^-?\\d+(?:\\/\\d+)?$/.exec(str);\r\n                    if(frac.length === 0)\r\n                        return str;\r\n\r\n                    //split the fraction into the numerator and denominator\r\n                    var parts = frac[0].split('/');\r\n                    var numer = new bigInt(parts[0]);\r\n                    var denom = new bigInt(parts[1]);\r\n                    if(denom.equals(0))\r\n                        denom = new bigInt(1);\r\n\r\n                    //return the quotient plus the remainder\r\n                    var divmod = numer.divmod(denom);\r\n                    var quotient = divmod.quotient;\r\n                    var remainder = divmod.remainder;\r\n                    var operator = parts[0][0] === '-' || quotient.equals(0) || remainder.equals(0) ? '' : '+';\r\n                    return (quotient.equals(0) ? '' : quotient.toString()) + operator + (remainder.equals(0) ? '' : (remainder.toString() + '/' + parts[1]));\r\n                case 'scientific':\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return false;\r\n                    }\r\n                    return new Scientific(obj.valueOf()).toString(Settings.SCIENTIFIC_MAX_DECIMAL_PLACES);\r\n                default:\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return str.indexOf('/') !== -1;\r\n                    };\r\n\r\n                    return obj.toString();\r\n            }\r\n        }\r\n\r\n        //if the object is a symbol\r\n        if(isSymbol(obj)) {\r\n            var multiplier = '',\r\n                    power = '',\r\n                    sign = '',\r\n                    group = obj.group || useGroup,\r\n                    value = obj.value;\r\n\r\n            //if the value is to be used as a hash then the power and multiplier need to be suppressed\r\n            if(!asHash) {\r\n                //use asDecimal to get the object back as a decimal\r\n                var om = toString(obj.multiplier);\r\n                if(om == '-1' && String(obj.multiplier) === '-1') {\r\n                    sign = '-';\r\n                    om = '1';\r\n                }\r\n                //only add the multiplier if it's not 1\r\n                if(om != '1')\r\n                    multiplier = om;\r\n                //use asDecimal to get the object back as a decimal\r\n                var p = obj.power ? toString(obj.power) : '';\r\n                //only add the multiplier\r\n                if(p != '1') {\r\n                    //is it a symbol\r\n                    if(isSymbol(p)) {\r\n                        power = text(p, opt);\r\n                    }\r\n                    else {\r\n                        power = p;\r\n                    }\r\n                }\r\n            }\r\n\r\n            switch(group) {\r\n                case N:\r\n                    multiplier = '';\r\n                    //round if requested\r\n                    var m = decp && asDecimal ? obj.multiplier.toDecimal(decp) : toString(obj.multiplier);\r\n                    //if it's numerical then all we need is the multiplier\r\n                    value = String(obj.multiplier) == '-1' ? '1' : m;\r\n                    power = '';\r\n                    break;\r\n                case PL:\r\n                    value = obj.collectSymbols().map(function (x) {\r\n                        var txt = text(x, opt, useGroup, decp);\r\n                        if(txt == '0')\r\n                            txt = '';\r\n                        return txt;\r\n                    }).sort().join('+').replace(/\\+\\-/g, '-');\r\n                    break;\r\n                case CP:\r\n                    value = obj.collectSymbols().map(function (x) {\r\n                        var txt = text(x, opt, useGroup, decp);\r\n                        if(txt == '0')\r\n                            txt = '';\r\n                        return txt;\r\n                    }).sort().join('+').replace(/\\+\\-/g, '-');\r\n                    break;\r\n                case CB:\r\n                    value = obj.collectSymbols(function (symbol) {\r\n                        var g = symbol.group;\r\n                        //both groups will already be in brackets if their power is greater than 1\r\n                        //so skip it.\r\n                        if((g === PL || g === CP) && (symbol.power.equals(1) && symbol.multiplier.equals(1))) {\r\n                            return inBrackets(text(symbol, opt));\r\n                        }\r\n                        return text(symbol, opt);\r\n                    }).join('*');\r\n                    break;\r\n                case EX:\r\n                    var pg = obj.previousGroup,\r\n                            pwg = obj.power.group;\r\n\r\n                    //PL are the exception. It's simpler to just collect and set the value\r\n                    if(pg === PL)\r\n                        value = obj.collectSymbols(text, opt).join('+').replace('+-', '-');\r\n                    if(!(pg === N || pg === S || pg === FN) && !asHash) {\r\n                        value = inBrackets(value);\r\n                    }\r\n\r\n                    if((pwg === CP || pwg === CB || pwg === PL || obj.power.multiplier.toString() != '1') && power) {\r\n                        power = inBrackets(power);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if(group === FN) {\r\n                value = obj.fname + inBrackets(obj.args.map(function (symbol) {\r\n                    return text(symbol, opt);\r\n                }).join(','));\r\n            }\r\n            //TODO: Needs to be more efficient. Maybe.\r\n            if(group === FN && obj.fname in CUSTOM_OPERATORS) {\r\n                var a = text(obj.args[0]);\r\n                var b = text(obj.args[1]);\r\n                if(obj.args[0].isComposite()) //preserve the brackets\r\n                    a = inBrackets(a);\r\n                if(obj.args[1].isComposite()) //preserve the brackets\r\n                    b = inBrackets(b);\r\n                value = a + CUSTOM_OPERATORS[obj.fname] + b;\r\n            }\r\n            //wrap the power since / is less than ^\r\n            //TODO: introduce method call isSimple\r\n            if(power && group !== EX && wrapCondition(power)) {\r\n                power = inBrackets(power);\r\n            }\r\n\r\n            //the following groups are held together by plus or minus. They can be raised to a power or multiplied\r\n            //by a multiplier and have to be in brackets to preserve the order of precedence\r\n            if(((group === CP || group === PL) && (multiplier && multiplier != '1' || sign === '-'))\r\n                    || ((group === CB || group === CP || group === PL) && (power && power != '1'))\r\n                    || !asHash && group === P && value == -1\r\n                    || obj.fname === PARENTHESIS) {\r\n\r\n                value = inBrackets(value);\r\n            }\r\n\r\n            if(decp && (option === 'decimal' || option === 'decimals' && multiplier)) {\r\n                multiplier = nround(multiplier, decp);\r\n            }\r\n\r\n\r\n            //add the sign back\r\n            var c = sign + multiplier;\r\n\r\n            if(multiplier && wrapCondition(multiplier))\r\n                c = inBrackets(c);\r\n\r\n            if(power < 0)\r\n                power = inBrackets(power);\r\n\r\n            //add the multiplication back\r\n            if(multiplier)\r\n                c = c + '*';\r\n\r\n            if(power) {\r\n                if(value === 'e' && Settings.E_TO_EXP) {\r\n                    return c + 'exp' + inBrackets(power);\r\n                }\r\n                power = Settings.POWER_OPERATOR + power;\r\n            }\r\n\r\n            //this needs serious rethinking. Must fix\r\n            if(group === EX && value.charAt(0) === '-') {\r\n                value = inBrackets(value);\r\n            }\r\n\r\n            var cv = c + value;\r\n\r\n            if(obj.parens) {\r\n                cv = inBrackets(cv);\r\n            }\r\n\r\n            return cv + power;\r\n        }\r\n        else if(isVector(obj)) {\r\n            var l = obj.elements.length,\r\n                    c = [];\r\n            for(var i = 0; i < l; i++)\r\n                c.push(obj.elements[i].text(option));\r\n            return '[' + c.join(',') + ']';\r\n        }\r\n        else {\r\n            try {\r\n                return obj.toString();\r\n            }\r\n            catch(e) {\r\n                return '';\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Calculates prime factors for a number. It first checks if the number\r\n     * is a prime number. If it's not then it will calculate all the primes \r\n     * for that number.\r\n     * @param {int} num\r\n     * @returns {Array}\r\n     */\r\n\r\n    function primeFactors(num) {\r\n        if(isPrime(num)) {\r\n            return [num];\r\n        }\r\n\r\n        var l = num, i = 1, factors = [],\r\n                epsilon = 2.2204460492503130808472633361816E-16;\r\n        while(i < l) {\r\n            var quotient = num / i;\r\n            var whole = Math.floor(quotient);\r\n            var remainder = quotient - whole;\r\n\r\n            if(remainder <= epsilon && i > 1) {\r\n                // If the prime wasn't found but calculated then save it and\r\n                // add it as a factor.\r\n                if(isPrime(i)) {\r\n                    if(PRIMES.indexOf(i) === -1) {\r\n                        PRIMES.push(i);\r\n                    }\r\n                    factors.push(i);\r\n                }\r\n\r\n                // Check if the remainder is a prime\r\n                if(isPrime(whole)) {\r\n                    factors.push(whole);\r\n                    break;\r\n                }\r\n\r\n                l = whole;\r\n            }\r\n            i++;\r\n        }\r\n\r\n        return factors.sort(function (a, b) {\r\n            return a - b;\r\n        });\r\n    }\r\n    ;\r\n    primeFactors(314146179365)\r\n//Expression ===================================================================\r\n    /**\r\n     * This is what nerdamer returns. It's sort of a wrapper around the symbol class and\r\n     * provides the user with some useful functions. If you want to provide the user with extra\r\n     * library functions then add them to this class's prototype.\r\n     * @param {Symbol} symbol\r\n     * @returns {Expression} wraps around the Symbol class\r\n     */\r\n    function Expression(symbol) {\r\n        //we don't want arrays wrapped\r\n        this.symbol = symbol;\r\n    }\r\n    /**\r\n     * Returns stored expression at index. For first index use 1 not 0.\r\n     * @param {bool} asType\r\n     * @param {Integer} expression_number\r\n     */\r\n    Expression.getExpression = function (expression_number, asType) {\r\n        if(expression_number === 'last' || !expression_number)\r\n            expression_number = EXPRESSIONS.length;\r\n        if(expression_number === 'first')\r\n            expression_number = 1;\r\n        var index = expression_number - 1,\r\n                expression = EXPRESSIONS[index],\r\n                retval = expression ? new Expression(expression) : expression;\r\n        return retval;\r\n    };\r\n    Expression.prototype = {\r\n        /**\r\n         * Returns the text representation of the expression\r\n         * @param {String} opt - option of formatting numbers\r\n         * @param {Number} n The number of significant figures\r\n         * @returns {String}\r\n         */\r\n        text: function (opt, n) {\r\n            n = n || 19;\r\n            opt = opt || 'decimals';\r\n            if(this.symbol.text_)\r\n                return this.symbol.text_(opt);\r\n\r\n            return text(this.symbol, opt, undefined, n);\r\n        },\r\n        /**\r\n         * Returns the latex representation of the expression\r\n         * @param {String} option - option for formatting numbers\r\n         * @returns {String}\r\n         */\r\n        latex: function (option) {\r\n            if(this.symbol.latex)\r\n                return this.symbol.latex(option);\r\n            return LaTeX.latex(this.symbol, option);\r\n        },\r\n        valueOf: function () {\r\n            return this.symbol.valueOf();\r\n        },\r\n\r\n        /**\r\n         * Evaluates the expression and tries to reduce it to a number if possible.\r\n         * If an argument is given in the form of %{integer} it will evaluate that expression.\r\n         * Other than that it will just use it's own text and reparse\r\n         * @returns {Expression}\r\n         */\r\n        evaluate: function () {\r\n\r\n            // Don't evaluate an empty vector\r\n            if(isVector(this.symbol) && this.symbol.dimensions() === 0) {\r\n                return this;\r\n            }\r\n\r\n            var first_arg = arguments[0], expression, idx = 1;\r\n\r\n            //Enable getting of expressions using the % so for example %1 should get the first expression\r\n            if(typeof first_arg === 'string') {\r\n                expression = (first_arg.charAt(0) === '%') ? Expression.getExpression(first_arg.substr(1)).text() : first_arg;\r\n            }\r\n            else if(first_arg instanceof Expression || isSymbol(first_arg)) {\r\n                expression = first_arg.text();\r\n            }\r\n            else {\r\n                expression = this.symbol.text();\r\n                idx--;\r\n            }\r\n\r\n            var subs = arguments[idx] || {};\r\n\r\n            var retval = new Expression(block('PARSE2NUMBER', function () {\r\n                return _.parse(expression, subs);\r\n            }, true));\r\n\r\n            return retval;\r\n        },\r\n        /**\r\n         * Converts a symbol to a JS function. Pass in an array of variables to use that order instead of\r\n         * the default alphabetical order\r\n         * @param vars {Array}\r\n         */\r\n        buildFunction: function (vars) {\r\n            return Build.build(this.symbol, vars);\r\n        },\r\n        /**\r\n         * Checks to see if the expression is just a plain old number\r\n         * @returns {boolean}\r\n         */\r\n        isNumber: function () {\r\n            return isNumericSymbol(this.symbol);\r\n        },\r\n        /**\r\n         * Checks to see if the expression is infinity\r\n         * @returns {boolean}\r\n         */\r\n        isInfinity: function () {\r\n            return Math.abs(this.symbol.multiplier) === Infinity;\r\n        },\r\n        /**\r\n         * Checks to see if the expression contains imaginary numbers\r\n         * @returns {boolean}\r\n         */\r\n        isImaginary: function () {\r\n            return evaluate(_.parse(this.symbol)).isImaginary();\r\n        },\r\n        /**\r\n         * Returns all the variables in the expression\r\n         * @returns {Array}\r\n         */\r\n        variables: function () {\r\n            return variables(this.symbol);\r\n        },\r\n\r\n        toString: function () {\r\n            try {\r\n                if(isArray(this.symbol))\r\n                    return '[' + this.symbol.toString() + ']';\r\n                return this.symbol.toString();\r\n            }\r\n            catch(e) {\r\n                return '';\r\n            }\r\n        },\r\n        //forces the symbol to be returned as a decimal\r\n        toDecimal: function (prec) {\r\n            Settings.precision = prec;\r\n            var dec = text(this.symbol, 'decimals');\r\n            Settings.precision = undefined;\r\n            return dec;\r\n        },\r\n        //checks to see if the expression is a fraction\r\n        isFraction: function () {\r\n            return isFraction(this.symbol);\r\n        },\r\n        //checks to see if the symbol is a multivariate polynomial\r\n        isPolynomial: function () {\r\n            return this.symbol.isPoly();\r\n        },\r\n        //performs a substitution\r\n        sub: function (symbol, for_symbol) {\r\n            return new Expression(this.symbol.sub(_.parse(symbol), _.parse(for_symbol)));\r\n        },\r\n        operation: function (otype, symbol) {\r\n            if(isExpression(symbol))\r\n                symbol = symbol.symbol;\r\n            else if(!isSymbol(symbol))\r\n                symbol = _.parse(symbol);\r\n            return new Expression(_[otype](this.symbol.clone(), symbol.clone()));\r\n        },\r\n        add: function (symbol) {\r\n            return this.operation('add', symbol);\r\n        },\r\n        subtract: function (symbol) {\r\n            return this.operation('subtract', symbol);\r\n        },\r\n        multiply: function (symbol) {\r\n            return this.operation('multiply', symbol);\r\n        },\r\n        divide: function (symbol) {\r\n            return this.operation('divide', symbol);\r\n        },\r\n        pow: function (symbol) {\r\n            return this.operation('pow', symbol);\r\n        },\r\n        expand: function () {\r\n            return new Expression(_.expand(this.symbol));\r\n        },\r\n        each: function (callback, i) {\r\n            if(this.symbol.each)\r\n                this.symbol.each(callback, i);\r\n            else if(isArray(this.symbol)) {\r\n                for(var i = 0; i < this.symbol.length; i++)\r\n                    callback.call(this.symbol, this.symbol[i], i);\r\n            }\r\n            else\r\n                callback.call(this.symbol);\r\n        },\r\n        eq: function (value) {\r\n            if(!isSymbol(value))\r\n                value = _.parse(value);\r\n            try {\r\n                var d = _.subtract(this.symbol.clone(), value);\r\n                return d.equals(0);\r\n            }\r\n            catch(e) {\r\n                return false;\r\n            }\r\n            ;\r\n        },\r\n        lt: function (value) {\r\n            if(!isSymbol(value))\r\n                value = _.parse(value);\r\n            try {\r\n                var d = evaluate(_.subtract(this.symbol.clone(), value));\r\n                return d.lessThan(0);\r\n            }\r\n            catch(e) {\r\n                return false;\r\n            }\r\n            ;\r\n        },\r\n        gt: function (value) {\r\n            if(!isSymbol(value))\r\n                value = _.parse(value);\r\n            try {\r\n                var d = evaluate(_.subtract(this.symbol.clone(), value));\r\n                return d.greaterThan(0);\r\n            }\r\n            catch(e) {\r\n                return false;\r\n            }\r\n        },\r\n        gte: function (value) {\r\n            return this.gt(value) || this.eq(value);\r\n        },\r\n        lte: function (value) {\r\n            return this.lt(value) || this.eq(value);\r\n        },\r\n\r\n        numerator: function () {\r\n            return new Expression(this.symbol.getNum());\r\n        },\r\n        denominator: function () {\r\n            return new Expression(this.symbol.getDenom());\r\n        },\r\n        hasFunction: function (f) {\r\n            return this.symbol.containsFunction(f);\r\n        },\r\n        contains: function (variable) {\r\n            return this.symbol.contains(variable);\r\n        }\r\n    };\r\n    //Aliases\r\n    Expression.prototype.toTeX = Expression.prototype.latex;\r\n\r\n//Scientific ===================================================================\r\n    function Scientific(num) {\r\n        if(!(this instanceof Scientific))\r\n            return new Scientific(num);\r\n\r\n        num = String(typeof num === 'undefined' ? 0 : num); //convert to a string\r\n\r\n        //remove the sign\r\n        if(num.startsWith('-')) {\r\n            this.sign = -1;\r\n            //remove the sign\r\n            num = num.substr(1, num.length);\r\n        }\r\n        else {\r\n            this.sign = 1;\r\n        }\r\n\r\n        if(Scientific.isScientific(num)) {\r\n            this.fromScientific(num);\r\n        }\r\n        else {\r\n            this.convert(num);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    Scientific.prototype = {\r\n        fromScientific: function (num) {\r\n            var parts = String(num).toLowerCase().split('e');\r\n            this.coeff = parts[0];\r\n            this.exponent = parts[1];\r\n\r\n            return this;\r\n        },\r\n        convert: function (num) {\r\n            //get wholes and decimals\r\n            var parts = num.split('.');\r\n            //make zero go away\r\n            var w = parts[0] || '';\r\n            var d = parts[1] || '';\r\n            //convert zero to blank strings\r\n            w = Scientific.removeLeadingZeroes(w);\r\n            d = Scientific.removeTrailingZeroes(d);\r\n            //find the location of the decimal place which is right after the wholes\r\n            var dot_location = w.length;\r\n            //add them together so we can move the dot\r\n            var n = w + d;\r\n            //find the next number\r\n            var zeroes = Scientific.leadingZeroes(n).length;\r\n            //set the exponent\r\n            this.exponent = dot_location - (zeroes + 1);\r\n            //set the coeff but first remove leading zeroes\r\n            var coeff = Scientific.removeLeadingZeroes(n);\r\n            this.coeff = coeff.charAt(0) + '.' + (coeff.substr(1, coeff.length) || '0');\r\n\r\n            return this;\r\n        },\r\n        round: function (num) {\r\n            var n = this.copy();\r\n\r\n            num = Number(num); //cast to number for safety\r\n            //since we know it guaranteed to be in the format {digit}{optional dot}{optional digits}\r\n            //we can round based on this\r\n            if(num === 0)\r\n                n.coeff = n.coeff.charAt(0);\r\n            else {\r\n                //get up to n-1 digits\r\n                var rounded = this.coeff.substring(0, num + 1);\r\n                //get the next two\r\n                var next_two = this.coeff.substring(num + 1, num + 3);\r\n                //the extra digit\r\n                var ed = next_two.charAt(0);\r\n\r\n                if(next_two.charAt(1) > 4)\r\n                    ed++;\r\n\r\n                n.coeff = rounded + ed;\r\n            }\r\n\r\n            return n;\r\n        },\r\n        copy: function () {\r\n            var n = new Scientific(0);\r\n            n.coeff = this.coeff;\r\n            n.exponent = this.exponent;\r\n            n.sign = this.sign;\r\n            return n;\r\n        },\r\n        toString: function (n) {\r\n            var coeff = typeof n === 'undefined' ? this.coeff : Scientific.round(this.coeff, n);\r\n\r\n            var c;\r\n            if(this.exponent === 0 && Settings.SCIENTIFIC_IGNORE_INTS) {\r\n                c = this.coeff;\r\n            }\r\n            else {\r\n                c = coeff + 'e' + this.exponent;\r\n            }\r\n            return (this.sign === -1 ? '-' : '') + c;\r\n        }\r\n    };\r\n\r\n    Scientific.isScientific = function (num) {\r\n        return /\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num);\r\n    };\r\n    Scientific.leadingZeroes = function (num) {\r\n        var match = num.match(/^(0*).*$/);\r\n        return match ? match[1] : '';\r\n    };\r\n    Scientific.removeLeadingZeroes = function (num) {\r\n        var match = num.match(/^0*(.*)$/);\r\n        return match ? match[1] : '';\r\n    };\r\n\r\n    Scientific.removeTrailingZeroes = function (num) {\r\n        var match = num.match(/0*$/);\r\n        return match ? num.substring(0, num.length - match[0].length) : '';\r\n    };\r\n    Scientific.round = function (c, n) {\r\n        var coeff = nround(c, n);\r\n        var m = String(coeff).split('.').pop();\r\n        var d = n - m.length;\r\n        //if we're asking for more significant figures\r\n        if(d > 0) {\r\n            coeff = coeff + (new Array(d + 1).join(0));\r\n        }\r\n        return coeff;\r\n    };\r\n\r\n//Scientific ===================================================================\r\n    /*\r\n     * Javascript has the toExponential method but this allows you to work with string and therefore any number of digits of your choosing\r\n     * For example Scientific('464589498449496467924197545625247695464569568959124568489548454');\r\n     */\r\n\r\n    function Scientific(num) {\r\n        if(!(this instanceof Scientific))\r\n            return new Scientific(num);\r\n\r\n        num = String(typeof num === 'undefined' ? 0 : num); //convert to a string\r\n\r\n        //remove the sign\r\n        if(num.startsWith('-')) {\r\n            this.sign = -1;\r\n            //remove the sign\r\n            num = num.substr(1, num.length);\r\n        }\r\n        else {\r\n            this.sign = 1;\r\n        }\r\n\r\n        if(Scientific.isScientific(num)) {\r\n            this.fromScientific(num);\r\n        }\r\n        else {\r\n            this.convert(num);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    Scientific.prototype = {\r\n        fromScientific: function (num) {\r\n            var parts = String(num).toLowerCase().split('e');\r\n            this.coeff = parts[0];\r\n            this.exponent = parts[1];\r\n\r\n            return this;\r\n        },\r\n        convert: function (num) {\r\n            //get wholes and decimals\r\n            var parts = num.split('.');\r\n            //make zero go away\r\n            var w = parts[0] || '';\r\n            var d = parts[1] || '';\r\n            //convert zero to blank strings\r\n            w = Scientific.removeLeadingZeroes(w);\r\n            d = Scientific.removeTrailingZeroes(d);\r\n            //find the location of the decimal place which is right after the wholes\r\n            var dot_location = w.length;\r\n            //add them together so we can move the dot\r\n            var n = w + d;\r\n            //find the next number\r\n            var zeroes = Scientific.leadingZeroes(n).length;\r\n            //set the exponent\r\n            this.exponent = dot_location - (zeroes + 1);\r\n            //set the coeff but first remove leading zeroes\r\n            var coeff = Scientific.removeLeadingZeroes(n);\r\n            this.coeff = coeff.charAt(0) + '.' + (coeff.substr(1, coeff.length) || '0');\r\n\r\n            //the coeff decimal places\r\n            var dec = this.coeff.split('.')[1] || ''; //if it's undefined or zero it's going to blank\r\n\r\n            this.decp = dec === '0' ? 0 : dec.length;\r\n            //decimals\r\n            this.dec = d;\r\n            //wholes\r\n            this.wholes = w;\r\n\r\n            return this;\r\n        },\r\n        round: function (num) {\r\n            var n = this.copy();\r\n\r\n            num = Number(num); //cast to number for safety\r\n            //since we know it guaranteed to be in the format {digit}{optional dot}{optional digits}\r\n            //we can round based on this\r\n            if(num === 0)\r\n                n.coeff = n.coeff.charAt(0);\r\n            else {\r\n                //get up to n-1 digits\r\n                var rounded = this.coeff.substring(0, num + 1);\r\n                //get the next two\r\n                var next_two = this.coeff.substring(num + 1, num + 3);\r\n                //the extra digit\r\n                var ed = next_two.charAt(0);\r\n\r\n                if(next_two.charAt(1) > 4)\r\n                    ed++;\r\n\r\n                n.coeff = rounded + ed;\r\n            }\r\n\r\n            return n;\r\n        },\r\n        copy: function () {\r\n            var n = new Scientific(0);\r\n            n.coeff = this.coeff;\r\n            n.exponent = this.exponent;\r\n            n.sign = this.sign;\r\n            return n;\r\n        },\r\n        toString: function (n) {\r\n            var retval;\r\n\r\n            if(Settings.SCIENTIFIC_IGNORE_ZERO_EXPONENTS && this.exponent === 0 && this.decp < n) {\r\n                if(this.decp === 0)\r\n                    retval = this.wholes;\r\n                else\r\n                    retval = this.coeff;\r\n            }\r\n            else {\r\n                var coeff = typeof n === 'undefined' ? this.coeff : Scientific.round(this.coeff, Math.min(n, this.decp || 1));\r\n                retval = this.exponent === 0 ? coeff : coeff + 'e' + this.exponent;\r\n            }\r\n\r\n            return (this.sign === -1 ? '-' : '') + retval;\r\n        }\r\n    };\r\n\r\n    Scientific.isScientific = function (num) {\r\n        return /\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num);\r\n    };\r\n    Scientific.leadingZeroes = function (num) {\r\n        var match = num.match(/^(0*).*$/);\r\n        return match ? match[1] : '';\r\n    };\r\n    Scientific.removeLeadingZeroes = function (num) {\r\n        var match = num.match(/^0*(.*)$/);\r\n        return match ? match[1] : '';\r\n    };\r\n\r\n    Scientific.removeTrailingZeroes = function (num) {\r\n        var match = num.match(/0*$/);\r\n        return match ? num.substring(0, num.length - match[0].length) : '';\r\n    };\r\n\r\n\r\n//Frac =========================================================================\r\n    function Frac(n) {\r\n        if(n instanceof Frac)\r\n            return n;\r\n        if(n === undefined)\r\n            return this;\r\n        try {\r\n            if(isInt(n)) {\r\n                try {\r\n                    this.num = bigInt(n);\r\n                    this.den = bigInt(1);\r\n                }\r\n                catch(e) {\r\n                    return Frac.simple(n);\r\n                }\r\n            }\r\n            else {\r\n                var frac = n instanceof bigDec ? Fraction.quickConversion(n) : Fraction.convert(n);\r\n                this.num = new bigInt(frac[0]);\r\n                this.den = new bigInt(frac[1]);\r\n            }\r\n        }\r\n        catch(e) {\r\n            return Frac.simple(n);\r\n        }\r\n\r\n    }\r\n    //safe to use with negative numbers or other types\r\n    Frac.create = function (n) {\r\n        if(n instanceof Frac)\r\n            return n;\r\n        n = n.toString();\r\n        var is_neg = n.charAt(0) === '-'; //check if it's negative\r\n        if(is_neg)\r\n            n = n.substr(1, n.length - 1); //remove the sign\r\n        var frac = new Frac(n);\r\n        //put the sign back\r\n        if(is_neg)\r\n            frac.negate();\r\n        return frac;\r\n    };\r\n    Frac.isFrac = function (o) {\r\n        return (o instanceof Frac);\r\n    };\r\n    Frac.quick = function (n, d) {\r\n        var frac = new Frac();\r\n        frac.num = new bigInt(n);\r\n        frac.den = new bigInt(d);\r\n        return frac;\r\n    };\r\n    Frac.simple = function (n) {\r\n        var nstr = String(scientificToDecimal(n)),\r\n                m_dc = nstr.split('.'),\r\n                num = m_dc.join(''),\r\n                den = 1,\r\n                l = (m_dc[1] || '').length;\r\n        for(var i = 0; i < l; i++)\r\n            den += '0';\r\n        var frac = Frac.quick(num, den);\r\n        return frac.simplify();\r\n    };\r\n    Frac.prototype = {\r\n        multiply: function (m) {\r\n            if(this.isOne()) {\r\n                return m.clone();\r\n            }\r\n            if(m.isOne()) {\r\n                return this.clone();\r\n            }\r\n\r\n            var c = this.clone();\r\n            c.num = c.num.multiply(m.num);\r\n            c.den = c.den.multiply(m.den);\r\n\r\n            return c.simplify();\r\n        },\r\n        divide: function (m) {\r\n            if(m.equals(0))\r\n                throw new DivisionByZero('Division by zero not allowed!');\r\n            return this.clone().multiply(m.clone().invert()).simplify();\r\n        },\r\n        subtract: function (m) {\r\n            return this.clone().add(m.clone().neg());\r\n        },\r\n        neg: function () {\r\n            this.num = this.num.multiply(-1);\r\n            return this;\r\n        },\r\n        add: function (m) {\r\n            var n1 = this.den, n2 = m.den, c = this.clone();\r\n            var a = c.num, b = m.num;\r\n            if(n1.equals(n2)) {\r\n                c.num = a.add(b);\r\n            }\r\n            else {\r\n                c.num = a.multiply(n2).add(b.multiply(n1));\r\n                c.den = n1.multiply(n2);\r\n            }\r\n\r\n            return c.simplify();\r\n        },\r\n        mod: function (m) {\r\n            var a = this.clone(),\r\n                    b = m.clone();\r\n            //make their denominators even and return the mod of their numerators\r\n            a.num = a.num.multiply(b.den);\r\n            a.den = a.den.multiply(b.den);\r\n            b.num = b.num.multiply(this.den);\r\n            b.den = b.den.multiply(this.den);\r\n            a.num = a.num.mod(b.num);\r\n            return a.simplify();\r\n        },\r\n        simplify: function () {\r\n            var gcd = bigInt.gcd(this.num, this.den);\r\n\r\n            this.num = this.num.divide(gcd);\r\n            this.den = this.den.divide(gcd);\r\n            return this;\r\n        },\r\n        clone: function () {\r\n            var m = new Frac();\r\n            m.num = new bigInt(this.num);\r\n            m.den = new bigInt(this.den);\r\n            return m;\r\n        },\r\n        decimal: function (prec) {\r\n            var sign = this.num.isNegative() ? '-' : '';\r\n            if(this.num.equals(this.den)) {\r\n                return '1';\r\n            }\r\n            //go plus one for rounding\r\n            prec = prec || Settings.PRECISION;\r\n            prec++;\r\n            var narr = [],\r\n                    n = this.num.abs(),\r\n                    d = this.den;\r\n            for(var i = 0; i < prec; i++) {\r\n                var w = n.divide(d), //divide out whole\r\n                        r = n.subtract(w.multiply(d)); //get remainder\r\n\r\n                narr.push(w);\r\n                if(r.equals(0))\r\n                    break;\r\n                n = r.times(10); //shift one dec place\r\n            }\r\n            var whole = narr.shift();\r\n            if(narr.length === 0) {\r\n                return sign + whole.toString();\r\n            }\r\n\r\n            if(i === prec) {\r\n                var lt = [];\r\n                //get the last two so we can round it\r\n                for(var i = 0; i < 2; i++)\r\n                    lt.unshift(narr.pop());\r\n                //put the last digit back by rounding the last two\r\n                narr.push(Math.round(lt.join('.')));\r\n            }\r\n\r\n            var dec = whole.toString() + '.' + narr.join('');\r\n            return sign + dec;\r\n        },\r\n        toDecimal: function (prec) {\r\n            prec = prec || Settings.PRECISION;\r\n            if(prec) {\r\n                return this.decimal(prec);\r\n            }\r\n            else\r\n                return this.num / this.den;\r\n        },\r\n        qcompare: function (n) {\r\n            return [this.num.multiply(n.den), n.num.multiply(this.den)];\r\n        },\r\n        equals: function (n) {\r\n            if(!isNaN(n))\r\n                n = new Frac(n);\r\n            var q = this.qcompare(n);\r\n\r\n            return q[0].equals(q[1]);\r\n        },\r\n        absEquals: function (n) {\r\n            if(!isNaN(n))\r\n                n = new Frac(n);\r\n            var q = this.qcompare(n);\r\n\r\n            return q[0].abs().equals(q[1]);\r\n        },\r\n        //lazy check to be fixed. Sufficient for now but will cause future problems\r\n        greaterThan: function (n) {\r\n            if(!isNaN(n))\r\n                n = new Frac(n);\r\n            var q = this.qcompare(n);\r\n\r\n            return q[0].gt(q[1]);\r\n        },\r\n        gte: function (n) {\r\n            return this.greaterThan(n) || this.equals(n);\r\n        },\r\n        lte: function (n) {\r\n            return this.lessThan(n) || this.equals(n);\r\n        },\r\n        lessThan: function (n) {\r\n            if(!isNaN(n))\r\n                n = new Frac(n);\r\n            var q = this.qcompare(n);\r\n\r\n            return q[0].lt(q[1]);\r\n        },\r\n        isInteger: function () {\r\n            return this.den.equals(1);\r\n        },\r\n        negate: function () {\r\n            this.num = this.num.multiply(-1);\r\n            return this;\r\n        },\r\n        invert: function () {\r\n            var t = this.den;\r\n            //why invert 0/1? It'll become 1/0 and that's a lie.\r\n            if(!this.num.equals(0)) {\r\n                var isnegative = this.num.isNegative();\r\n                this.den = this.num.abs();\r\n                this.num = t;\r\n                if(isnegative)\r\n                    this.num = this.num.multiply(-1);\r\n            }\r\n\r\n            return this;\r\n        },\r\n        isOne: function () {\r\n            return this.num.equals(1) && this.den.equals(1);\r\n        },\r\n        sign: function () {\r\n            return this.num.isNegative() ? -1 : 1;\r\n        },\r\n        abs: function () {\r\n            this.num = this.num.abs();\r\n            return this;\r\n        },\r\n        gcd: function (f) {\r\n            return Frac.quick(bigInt.gcd(f.num, this.num), bigInt.lcm(f.den, this.den));\r\n        },\r\n        toString: function () {\r\n            return !this.den.equals(1) ? this.num.toString() + '/' + this.den.toString() : this.num.toString();\r\n        },\r\n        valueOf: function () {\r\n//            if(this.num == 24) throw new Error(999)\r\n            if(Settings.USE_BIG)\r\n                return new bigDec(this.num.toString()).div(new bigDec(this.den.toString()));\r\n            return this.num / this.den;\r\n        },\r\n        isNegative: function () {\r\n            return this.toDecimal() < 0;\r\n        }\r\n    };\r\n\r\n//Symbol =======================================================================\r\n    /**\r\n     * All symbols e.g. x, y, z, etc or functions are wrapped in this class. All symbols have a multiplier and a group.\r\n     * All symbols except for \"numbers (group N)\" have a power.\r\n     * @class Primary data type for the Parser.\r\n     * @param {String} obj\r\n     * @returns {Symbol}\r\n     */\r\n    function Symbol(obj) {\r\n        var isInfinity = obj === 'Infinity';\r\n        // This enables the class to be instantiated without the new operator\r\n        if(!(this instanceof Symbol)) {\r\n            return new Symbol(obj);\r\n        }\r\n        // Convert big numbers to a string\r\n        if(obj instanceof bigDec) {\r\n            obj = obj.toString();\r\n        }\r\n        //define numeric symbols\r\n        if(/^(\\-?\\+?\\d+)\\.?\\d*e?\\-?\\+?\\d*/i.test(obj) || obj instanceof bigDec) {\r\n            this.group = N;\r\n            this.value = CONST_HASH;\r\n            this.multiplier = new Frac(obj);\r\n        }\r\n        //define symbolic symbols\r\n        else {\r\n            this.group = S;\r\n            validateName(obj);\r\n            this.value = obj;\r\n            this.multiplier = new Frac(1);\r\n            this.imaginary = obj === Settings.IMAGINARY;\r\n            this.isInfinity = isInfinity;\r\n        }\r\n\r\n        //As of 6.0.0 we switched to infinite precision so all objects have a power\r\n        //Although this is still redundant in constants, it simplifies the logic in\r\n        //other parts so we'll keep it\r\n        this.power = new Frac(1);\r\n\r\n        // Added to silence the strict warning.\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns vanilla imaginary symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Symbol.imaginary = function () {\r\n        var s = new Symbol(Settings.IMAGINARY);\r\n        s.imaginary = true;\r\n        return s;\r\n    };\r\n    /**\r\n     * Return nerdamer's representation of Infinity\r\n     * @param {int} negative -1 to return negative infinity\r\n     * @returns {Symbol}\r\n     */\r\n    Symbol.infinity = function (negative) {\r\n        var v = new Symbol('Infinity');\r\n        if(negative === -1)\r\n            v.negate();\r\n        return v;\r\n    };\r\n    Symbol.shell = function (group, value) {\r\n        var symbol = new Symbol(value);\r\n        symbol.group = group;\r\n        symbol.symbols = {};\r\n        symbol.length = 0;\r\n        return symbol;\r\n    };\r\n    //sqrt(x) -> x^(1/2)\r\n    Symbol.unwrapSQRT = function (symbol, all) {\r\n        var p = symbol.power;\r\n        if(symbol.fname === SQRT && (symbol.isLinear() || all)) {\r\n            var t = symbol.args[0].clone();\r\n            t.power = t.power.multiply(new Frac(1 / 2));\r\n            t.multiplier = t.multiplier.multiply(symbol.multiplier);\r\n            symbol = t;\r\n            if(all)\r\n                symbol.power = p.multiply(new Frac(1 / 2));\r\n        }\r\n\r\n        return symbol;\r\n    };\r\n    Symbol.hyp = function (a, b) {\r\n        a = a || new Symbol(0);\r\n        b = b || new Symbol(0);\r\n        return _.sqrt(_.add(_.pow(a.clone(), new Symbol(2)), _.pow(b.clone(), new Symbol(2))));\r\n    };\r\n    //converts to polar form array\r\n    Symbol.toPolarFormArray = function (symbol) {\r\n        var re, im, r, theta;\r\n        re = symbol.realpart();\r\n        im = symbol.imagpart();\r\n        r = Symbol.hyp(re, im);\r\n        theta = re.equals(0) ? _.parse('pi/2') : _.trig.atan(_.divide(im, re));\r\n        return [r, theta];\r\n    };\r\n    //removes parentheses\r\n    Symbol.unwrapPARENS = function (symbol) {\r\n        if(symbol.fname === '') {\r\n            var r = symbol.args[0];\r\n            r.power = r.power.multiply(symbol.power);\r\n            r.multiplier = r.multiplier.multiply(symbol.multiplier);\r\n            if(symbol.fname === '')\r\n                return Symbol.unwrapPARENS(r);\r\n            return r;\r\n        }\r\n        return symbol;\r\n    };\r\n    //quickly creates a Symbol\r\n    Symbol.create = function (value, power) {\r\n        power = power === undefined ? 1 : power;\r\n        return _.parse('(' + value + ')^(' + power + ')');\r\n    };\r\n    Symbol.prototype = {\r\n        /**\r\n         * Gets nth root accounting for rounding errors\r\n         * @param {Number} n\r\n         * @return {Number}\r\n         */\r\n        getNth: function (n) {\r\n            // First calculate the root\r\n            var root = evaluate(_.pow(_.parse(this.multiplier), _.parse(n).invert()));\r\n            // Round of any errors\r\n            var rounded = _.parse(nround(root));\r\n            // Reverse the root\r\n            var e = evaluate(_.pow(rounded, _.parse(n)));\r\n            // If the rounded root equals the original number then we're good \r\n            if(e.equals(_.parse(this.multiplier))) {\r\n                return rounded;\r\n            }\r\n            // Otherwise return the unrounded version\r\n            return root;\r\n        },\r\n        /**\r\n         * Checks if symbol is to the nth power\r\n         * @returns {Boolean}\r\n         */\r\n        isToNth: function (n) {\r\n            // Start by check in the multiplier for squareness\r\n            // First get the root but round it because currently we still depend \r\n            var root = this.getNth(n);\r\n            var nthMultiplier = isInt(root);\r\n            var nthPower;\r\n\r\n            if(this.group === CB) {\r\n                // Start by assuming that all will be square.\r\n                nthPower = true;\r\n                // All it takes is for one of the symbols to not have an even power\r\n                // e.g. x^n1*y^n2 requires that both n1 and n2 are even\r\n                this.each(function (x) {\r\n                    var isNth = x.isToNth(n);\r\n\r\n                    if(!isNth) {\r\n                        nthPower = false;\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                // Check if the power is divisible by n if it's not a number.\r\n                nthPower = this.group === N ? true : isInt(_.divide(_.parse(this.power), _.parse(n)));\r\n            }\r\n\r\n            return nthMultiplier && nthPower;\r\n        },\r\n        /**\r\n         * Checks if a symbol is square\r\n         * @return {Boolean}\r\n         */\r\n        isSquare: function () {\r\n            return this.isToNth(2);\r\n        },\r\n        /**\r\n         * Checks if a symbol is cube\r\n         * @return {Boolean}\r\n         */\r\n        isCube: function () {\r\n            return this.isToNth(3);\r\n        },\r\n        /**\r\n         * Checks if a symbol is a bare variable\r\n         * @return {Boolean}\r\n         */\r\n        isSimple: function () {\r\n            return this.power.equals(1) && this.multiplier.equals(1);\r\n        },\r\n        /**\r\n         * Simplifies the power of the symbol\r\n         * @returns {Symbol} a clone of the symbol\r\n         */\r\n        powSimp: function () {\r\n            if(this.group === CB) {\r\n                var powers = [],\r\n                        sign = this.multiplier.sign();\r\n                this.each(function (x) {\r\n                    var p = x.power;\r\n                    //why waste time if I can't do anything anyway\r\n                    if(isSymbol(p) || p.equals(1))\r\n                        return this.clone();\r\n                    powers.push(p);\r\n                });\r\n                var min = new Frac(arrayMin(powers));\r\n\r\n                //handle the coefficient\r\n                //handle the multiplier\r\n                var sign = this.multiplier.sign(),\r\n                        m = this.multiplier.clone().abs(),\r\n                        mfactors = Math2.ifactor(m);\r\n                //if we have a multiplier of 6750 and a min of 2 then the factors are 5^3*5^3*2\r\n                //we can then reduce it to 2*3*5*(15)^2\r\n                var out_ = new Frac(1);\r\n                var in_ = new Frac(1);\r\n\r\n                for(var x in mfactors) {\r\n                    var n = new Frac(mfactors[x]);\r\n                    if(!n.lessThan(min)) {\r\n                        n = n.divide(min).subtract(new Frac(1));\r\n                        in_ = in_.multiply(new Frac(x)); //move the factor inside the bracket\r\n                    }\r\n\r\n                    out_ = out_.multiply(_.parse(inBrackets(x) + '^' + inBrackets(n)).multiplier);\r\n                }\r\n                var t = new Symbol(in_);\r\n                this.each(function (x) {\r\n                    x = x.clone();\r\n                    x.power = x.power.divide(min);\r\n                    t = _.multiply(t, x);\r\n                });\r\n\r\n                var xt = _.symfunction(PARENTHESIS, [t]);\r\n                xt.power = min;\r\n                xt.multiplier = sign < 0 ? out_.negate() : out_;\r\n\r\n                return xt;\r\n            }\r\n            return this.clone();\r\n        },\r\n        /**\r\n         * Checks to see if two functions are of equal value\r\n         * @param {Symbol} symbol\r\n         */\r\n        equals: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.value === symbol.value && this.power.equals(symbol.power)\r\n                    && this.multiplier.equals(symbol.multiplier)\r\n                    && this.group === symbol.group;\r\n        },\r\n        abs: function () {\r\n            var e = this.clone();\r\n            e.multiplier.abs();\r\n            return e;\r\n        },\r\n        // Greater than\r\n        gt: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.isConstant() && symbol.isConstant() && this.multiplier.greaterThan(symbol.multiplier);\r\n        },\r\n        // Greater than\r\n        gte: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.equals(symbol) ||\r\n                    this.isConstant() && symbol.isConstant() && this.multiplier.greaterThan(symbol.multiplier);\r\n        },\r\n        // Less than\r\n        lt: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.isConstant() && symbol.isConstant() && this.multiplier.lessThan(symbol.multiplier);\r\n        },\r\n        // Less than\r\n        lte: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.equals(symbol) ||\r\n                    this.isConstant() && symbol.isConstant() && this.multiplier.lessThan(symbol.multiplier);\r\n        },\r\n        /**\r\n         * Because nerdamer doesn't group symbols by polynomials but\r\n         * rather a custom grouping method, this has to be\r\n         * reinserted in order to make use of most algorithms. This function\r\n         * checks if the symbol meets the criteria of a polynomial.\r\n         * @param {bool} multivariate\r\n         * @returns {boolean}\r\n         */\r\n        isPoly: function (multivariate) {\r\n            var g = this.group,\r\n                    p = this.power;\r\n            //the power must be a integer so fail if it's not\r\n            if(!isInt(p) || p < 0)\r\n                return false;\r\n            //constants and first orders\r\n            if(g === N || g === S || this.isConstant(true))\r\n                return true;\r\n            var vars = variables(this);\r\n            if(g === CB && vars.length === 1) {\r\n                //the variable is assumed the only one that was found\r\n                var v = vars[0];\r\n                //if no variable then guess what!?!? We're done!!! We have a polynomial.\r\n                if(!v)\r\n                    return true;\r\n                for(var x in this.symbols) {\r\n                    var sym = this.symbols[x];\r\n                    //sqrt(x)\r\n                    if(sym.group === FN && !sym.args[0].isConstant())\r\n                        return false;\r\n                    if(!sym.contains(v) && !sym.isConstant(true))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n            //PL groups. These only fail if a power is not an int\r\n            //this should handle cases such as x^2*t\r\n            if(this.isComposite() || g === CB && multivariate) {\r\n                //fail if we're not checking for multivariate polynomials\r\n                if(!multivariate && vars.length > 1)\r\n                    return false;\r\n                //loop though the symbols and check if they qualify\r\n                for(var x in this.symbols) {\r\n                    //we've already the symbols if we're not checking for multivariates at this point\r\n                    //so we check the sub-symbols\r\n                    if(!this.symbols[x].isPoly(multivariate))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n            else\r\n                return false;\r\n\r\n            /*\r\n             //all tests must have passed so we must be dealing with a polynomial\r\n             return true;\r\n             */\r\n        },\r\n        //removes the requested variable from the symbol and returns the remainder\r\n        stripVar: function (x, exclude_x) {\r\n            var retval;\r\n            if((this.group === PL || this.group === S) && this.value === x)\r\n                retval = new Symbol(exclude_x ? 0 : this.multiplier);\r\n            else if(this.group === CB && this.isLinear()) {\r\n                retval = new Symbol(1);\r\n                this.each(function (s) {\r\n                    if(!s.contains(x, true))\r\n                        retval = _.multiply(retval, s.clone());\r\n                });\r\n                retval.multiplier = retval.multiplier.multiply(this.multiplier);\r\n            }\r\n            else if(this.group === CP && !this.isLinear()) {\r\n                retval = new Symbol(this.multiplier);\r\n            }\r\n            else if(this.group === CP && this.isLinear()) {\r\n                retval = new Symbol(0);\r\n                this.each(function (s) {\r\n                    if(!s.contains(x)) {\r\n                        var t = s.clone();\r\n                        t.multiplier = t.multiplier.multiply(this.multiplier);\r\n                        retval = _.add(retval, t);\r\n                    }\r\n                });\r\n                //BIG TODO!!! It doesn't make much sense\r\n                if(retval.equals(0))\r\n                    retval = new Symbol(this.multiplier);\r\n            }\r\n            else if(this.group === EX && this.power.contains(x, true)) {\r\n                retval = new Symbol(this.multiplier);\r\n            }\r\n            else if(this.group === FN && this.contains(x)) {\r\n                retval = new Symbol(this.multiplier);\r\n            }\r\n            else\r\n                //wth? This should technically be the multiplier.\r\n                //Unfortunately this method wasn't very well thought out :`(.\r\n                //should be: retval = new Symbol(this.multiplier);\r\n                //use: ((1+x^2)*sqrt(-1+x^2))^(-1) for correction.\r\n                //this will break a bunch of unit tests so be ready to for the long haul\r\n                retval = this.clone();\r\n\r\n\r\n            return retval;\r\n        },\r\n        //returns symbol in array form with x as base e.g. a*x^2+b*x+c = [c, b, a].\r\n        toArray: function (v, arr) {\r\n            arr = arr || {\r\n                arr: [],\r\n                add: function (x, idx) {\r\n                    var e = this.arr[idx];\r\n                    this.arr[idx] = e ? _.add(e, x) : x;\r\n                }\r\n            };\r\n            var g = this.group;\r\n\r\n            if(g === S && this.contains(v)) {\r\n                arr.add(new Symbol(this.multiplier), this.power);\r\n            }\r\n            else if(g === CB) {\r\n                var a = this.stripVar(v),\r\n                        x = _.divide(this.clone(), a.clone());\r\n                var p = x.isConstant() ? 0 : x.power;\r\n                arr.add(a, p);\r\n            }\r\n            else if(g === PL && this.value === v) {\r\n                this.each(function (x, p) {\r\n                    arr.add(x.stripVar(v), p);\r\n                });\r\n            }\r\n            else if(g === CP) {\r\n                //the logic: they'll be broken into symbols so e.g. (x^2+x)+1 or (a*x^2+b*x+c)\r\n                //each case is handled above\r\n                this.each(function (x) {\r\n                    x.toArray(v, arr);\r\n                });\r\n            }\r\n            else if(this.contains(v)) {\r\n                throw new NerdamerTypeError('Cannot convert to array! Exiting');\r\n            }\r\n            else {\r\n                arr.add(this.clone(), 0); //it's just a constant wrt to v\r\n            }\r\n            //fill the holes\r\n            arr = arr.arr; //keep only the array since we don't need the object anymore\r\n            for(var i = 0; i < arr.length; i++)\r\n                if(!arr[i])\r\n                    arr[i] = new Symbol(0);\r\n            return arr;\r\n        },\r\n        //checks to see if a symbol contans a function\r\n        hasFunc: function (v) {\r\n            var fn_group = this.group === FN || this.group === EX;\r\n            if(fn_group && !v || fn_group && this.contains(v))\r\n                return true;\r\n            if(this.symbols) {\r\n                for(var x in this.symbols) {\r\n                    if(this.symbols[x].hasFunc(v))\r\n                        return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n        sub: function (a, b) {\r\n            a = !isSymbol(a) ? _.parse(a) : a.clone();\r\n            b = !isSymbol(b) ? _.parse(b) : b.clone();\r\n            if(a.group === N || a.group === P)\r\n                err('Cannot substitute a number. Must be a variable');\r\n            var same_pow = false,\r\n                    a_is_unit_multiplier = a.multiplier.equals(1),\r\n                    m = this.multiplier.clone(),\r\n                    retval;\r\n            /*\r\n             * In order to make the substitution the bases have to first match take\r\n             * (x+1)^x -> (x+1)=y || x^2 -> x=y^6\r\n             * In both cases the first condition is that the bases match so we begin there\r\n             * Either both are PL or both are not PL but we cannot have PL and a non-PL group match\r\n             */\r\n            if(this.value === a.value && (this.group !== PL && a.group !== PL || this.group === PL && a.group === PL)) {\r\n                //we cleared the first hurdle but a subsitution may not be possible just yet\r\n                if(a_is_unit_multiplier || a.multiplier.equals(this.multiplier)) {\r\n                    if(a.isLinear()) {\r\n                        retval = b;\r\n                    }\r\n                    else if(a.power.equals(this.power)) {\r\n                        retval = b;\r\n                        same_pow = true;\r\n                    }\r\n                    if(a.multiplier.equals(this.multiplier))\r\n                        m = new Frac(1);\r\n                }\r\n            }\r\n            //the next thing is to handle CB\r\n            else if(this.group === CB || this.previousGroup === CB) {\r\n                retval = new Symbol(1);\r\n                this.each(function (x) {\r\n                    var subbed = _.parse(x.sub(a, b)); //parse it again for safety\r\n                    retval = _.multiply(retval, subbed);\r\n\r\n                });\r\n            }\r\n            else if(this.isComposite()) {\r\n                var symbol = this.clone();\r\n\r\n                if(a.isComposite() && symbol.isComposite() && symbol.isLinear() && a.isLinear()) {\r\n                    var find = function (stack, needle) {\r\n                        for(var x in stack.symbols) {\r\n                            var sym = stack.symbols[x];\r\n                            //if the symbol equals the needle or it's within the sub-symbols we're done\r\n                            if(sym.isComposite() && find(sym, needle) || sym.equals(needle))\r\n                                return true;\r\n                        }\r\n                        return false;\r\n                    };\r\n                    //go fish\r\n                    for(var x in a.symbols) {\r\n                        if(!find(symbol, a.symbols[x]))\r\n                            return symbol.clone();\r\n                    }\r\n                    retval = _.add(_.subtract(symbol.clone(), a), b);\r\n                }\r\n                else {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, x.sub(a, b));\r\n                    });\r\n                }\r\n            }\r\n            else if(this.group === EX) {\r\n                // the parsed value could be a function so parse and sub\r\n                retval = _.parse(this.value).sub(a, b);\r\n            }\r\n            else if(this.group === FN) {\r\n                var nargs = [];\r\n                for(var i = 0; i < this.args.length; i++) {\r\n                    var arg = this.args[i];\r\n                    if(!isSymbol(arg))\r\n                        arg = _.parse(arg);\r\n                    nargs.push(arg.sub(a, b));\r\n                }\r\n                retval = _.symfunction(this.fname, nargs);\r\n            }\r\n            //if we did manage a substitution\r\n            if(retval) {\r\n                if(!same_pow) {\r\n                    //substitute the power\r\n                    var p = this.group === EX ? this.power.sub(a, b) : _.parse(this.power);\r\n                    //now raise the symbol to that power\r\n                    retval = _.pow(retval, p);\r\n                }\r\n\r\n                //transfer the multiplier\r\n                retval.multiplier = retval.multiplier.multiply(m);\r\n\r\n                //done\r\n                return retval;\r\n            }\r\n            //if all else fails\r\n            return this.clone();\r\n        },\r\n        isMonomial: function () {\r\n            if(this.group === S)\r\n                return true;\r\n            if(this.group === CB) {\r\n                for(var x in this.symbols)\r\n                    if(this.symbols[x].group !== S)\r\n                        return false;\r\n            }\r\n            else\r\n                return false;\r\n            return true;\r\n        },\r\n        isPi: function () {\r\n            return this.group === S && this.value === 'pi';\r\n        },\r\n        sign: function () {\r\n            return this.multiplier.sign();\r\n        },\r\n        isE: function () {\r\n            return this.value === 'e';\r\n        },\r\n        isSQRT: function () {\r\n            return this.fname === SQRT;\r\n        },\r\n        isConstant: function (check_all, check_symbols) {\r\n            if(check_symbols && this.group === CB) {\r\n                for(var x in this.symbols) {\r\n                    if(this.symbols[x].isConstant(true))\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            if(check_all === 'functions' && this.isComposite()) {\r\n                var isConstant = true;\r\n\r\n                this.each(function (x) {\r\n                    if(!x.isConstant(check_all, check_symbols)) {\r\n                        isConstant = false;\r\n                    }\r\n                }, true);\r\n\r\n                return isConstant;\r\n            }\r\n\r\n            if(check_all === 'all' && (this.isPi() || this.isE())) {\r\n                return true;\r\n            }\r\n\r\n            if(check_all && this.group === FN) {\r\n                for(var i = 0; i < this.args.length; i++) {\r\n                    if(!this.args[i].isConstant(check_all))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n\r\n            if(check_all)\r\n                return isNumericSymbol(this);\r\n            return this.value === CONST_HASH;\r\n        },\r\n        //the symbols is imaginary if\r\n        //1. n*i\r\n        //2. a+b*i\r\n        //3. a*i\r\n        isImaginary: function () {\r\n            if(this.imaginary)\r\n                return true;\r\n            else if(this.symbols) {\r\n                for(var x in this.symbols)\r\n                    if(this.symbols[x].isImaginary())\r\n                        return true;\r\n            }\r\n            return false;\r\n        },\r\n        /**\r\n         * Returns the real part of a symbol\r\n         * @returns {Symbol}\r\n         */\r\n        realpart: function () {\r\n            if(this.isConstant()) {\r\n                return this.clone();\r\n            }\r\n            else if(this.imaginary)\r\n                return new Symbol(0);\r\n            else if(this.isComposite()) {\r\n                var retval = new Symbol(0);\r\n                this.each(function (x) {\r\n                    retval = _.add(retval, x.realpart());\r\n                });\r\n                return retval;\r\n            }\r\n            else if(this.isImaginary())\r\n                return new Symbol(0);\r\n            return this.clone();\r\n        },\r\n        /*\r\n         * Return imaginary part of a symbol\r\n         * @returns {Symbol}\r\n         */\r\n        imagpart: function () {\r\n            if(this.group === S && this.isImaginary())\r\n                return new Symbol(this.multiplier);\r\n            if(this.isComposite()) {\r\n                var retval = new Symbol(0);\r\n                this.each(function (x) {\r\n                    retval = _.add(retval, x.imagpart());\r\n                });\r\n                return retval;\r\n            }\r\n            if(this.group === CB)\r\n                return this.stripVar(Settings.IMAGINARY);\r\n            return new Symbol(0);\r\n        },\r\n        isInteger: function () {\r\n            return this.isConstant() && this.multiplier.isInteger();\r\n        },\r\n        isLinear: function (wrt) {\r\n            if(wrt) {\r\n                if(this.isConstant())\r\n                    return true;\r\n                if(this.group === S) {\r\n                    if(this.value === wrt)\r\n                        return this.power.equals(1);\r\n                    else\r\n                        return true;\r\n                }\r\n\r\n                if(this.isComposite() && this.power.equals(1)) {\r\n                    for(var x in this.symbols) {\r\n                        if(!this.symbols[x].isLinear(wrt))\r\n                            return false;\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                if(this.group === CB && this.symbols[wrt])\r\n                    return this.symbols[wrt].isLinear(wrt);\r\n                return false;\r\n            }\r\n            else\r\n                return this.power.equals(1);\r\n        },\r\n        /**\r\n         * Checks to see if a symbol has a function by a specified name or within a specified list\r\n         * @param {String|String[]} names\r\n         * @returns {Boolean}\r\n         */\r\n        containsFunction: function (names) {\r\n            if(typeof names === 'string')\r\n                names = [names];\r\n            if(this.group === FN && names.indexOf(this.fname) !== -1)\r\n                return true;\r\n            if(this.symbols) {\r\n                for(var x in this.symbols) {\r\n                    if(this.symbols[x].containsFunction(names))\r\n                        return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n        multiplyPower: function (p2) {\r\n            //leave out 1\r\n            if(this.group === N && this.multiplier.equals(1))\r\n                return this;\r\n\r\n            var p1 = this.power;\r\n\r\n            if(this.group !== EX && p2.group === N) {\r\n                var p = p2.multiplier;\r\n                if(this.group === N && !p.isInteger()) {\r\n                    this.convert(P);\r\n                }\r\n\r\n                this.power = p1.equals(1) ? p.clone() : p1.multiply(p);\r\n\r\n                if(this.group === P && isInt(this.power)) {\r\n                    //bring it back to an N\r\n                    this.value = Math.pow(this.value, this.power);\r\n                    this.toLinear();\r\n                    this.convert(N);\r\n                }\r\n            }\r\n            else {\r\n                if(this.group !== EX) {\r\n                    p1 = new Symbol(p1);\r\n                    this.convert(EX);\r\n                }\r\n                this.power = _.multiply(p1, p2);\r\n            }\r\n\r\n            return this;\r\n        },\r\n        setPower: function (p, retainSign) {\r\n            //leave out 1\r\n            if(this.group === N && this.multiplier.equals(1)) {\r\n                return this;\r\n            }\r\n            if(this.group === EX && !isSymbol(p)) {\r\n                this.group = this.previousGroup;\r\n                delete this.previousGroup;\r\n                if(this.group === N) {\r\n                    this.multiplier = new Frac(this.value);\r\n                    this.value = CONST_HASH;\r\n                }\r\n                else\r\n                    this.power = p;\r\n            }\r\n            else {\r\n                var isSymbolic = false;\r\n                if(isSymbol(p)) {\r\n                    if(p.group === N) {\r\n                        //p should be the multiplier instead\r\n                        p = p.multiplier;\r\n\r\n                    }\r\n                    else {\r\n                        isSymbolic = true;\r\n                    }\r\n                }\r\n                var group = isSymbolic ? EX : P;\r\n                this.power = p;\r\n                if(this.group === N && group)\r\n                    this.convert(group, retainSign);\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks to see if symbol is located in the denominator\r\n         * @returns {boolean}\r\n         */\r\n        isInverse: function () {\r\n            if(this.group === EX)\r\n                return (this.power.multiplier.lessThan(0));\r\n            return this.power < 0;\r\n        },\r\n        /**\r\n         * Make a duplicate of a symbol by copying a predefined list of items.\r\n         * The name 'copy' would probably be a more appropriate name.\r\n         * to a new symbol\r\n         * @param {Symbol} c\r\n         * @returns {Symbol}\r\n         */\r\n        clone: function (c) {\r\n            var clone = c || new Symbol(0),\r\n                    //list of properties excluding power as this may be a symbol and would also need to be a clone.\r\n                    properties = [\r\n                        'value', 'group', 'length', 'previousGroup', 'imaginary', 'fname', 'args', 'isInfinity', 'scientific'],\r\n                    l = properties.length, i;\r\n            if(this.symbols) {\r\n                clone.symbols = {};\r\n                for(var x in this.symbols) {\r\n                    clone.symbols[x] = this.symbols[x].clone();\r\n                }\r\n            }\r\n\r\n            for(i = 0; i < l; i++) {\r\n                if(this[properties[i]] !== undefined) {\r\n                    clone[properties[i]] = this[properties[i]];\r\n                }\r\n            }\r\n\r\n            clone.power = this.power.clone();\r\n            clone.multiplier = this.multiplier.clone();\r\n            //add back the flag to track if this symbol is a conversion symbol\r\n            if(this.isConversion)\r\n                clone.isConversion = this.isConversion;\r\n\r\n            if(this.isUnit)\r\n                clone.isUnit = this.isUnit;\r\n\r\n            return clone;\r\n        },\r\n        /**\r\n         * Converts a symbol multiplier to one.\r\n         * @param {Boolean} keepSign Keep the multiplier as negative if the multiplier is negative and keepSign is true\r\n         * @returns {Symbol}\r\n         */\r\n        toUnitMultiplier: function (keepSign) {\r\n            this.multiplier.num = new bigInt(this.multiplier.num.isNegative() && keepSign ? -1 : 1);\r\n            this.multiplier.den = new bigInt(1);\r\n            return this;\r\n        },\r\n        /**\r\n         * Converts a Symbol's power to one.\r\n         * @returns {Symbol}\r\n         */\r\n        toLinear: function () {\r\n            // Do nothing if it's already linear\r\n            if(this.power.equals(1)) {\r\n                return this;\r\n            }\r\n            this.setPower(new Frac(1));\r\n            return this;\r\n        },\r\n        /**\r\n         * Iterates over all the sub-symbols. If no sub-symbols exist then it's called on itself\r\n         * @param {Function} fn\r\n         * @@param {Boolean} deep If true it will itterate over the sub-symbols their symbols as well\r\n         */\r\n        each: function (fn, deep) {\r\n            if(!this.symbols) {\r\n                fn.call(this, this, this.value);\r\n            }\r\n            else {\r\n                for(var x in this.symbols) {\r\n                    var sym = this.symbols[x];\r\n                    if(sym.group === PL && deep) {\r\n                        for(var y in sym.symbols) {\r\n                            fn.call(x, sym.symbols[y], y);\r\n                        }\r\n                    }\r\n                    else\r\n                        fn.call(this, sym, x);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * A numeric value to be returned for Javascript. It will try to\r\n         * return a number as far a possible but in case of a pure symbolic\r\n         * symbol it will just return its text representation\r\n         * @returns {String|Number}\r\n         */\r\n        valueOf: function () {\r\n            if(this.group === N)\r\n                return this.multiplier.valueOf();\r\n            else if(this.power === 0) {\r\n                return 1;\r\n            }\r\n            else if(this.multiplier === 0) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return text(this, 'decimals');\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a symbols has a particular variable within it.\r\n         * Pass in true as second argument to include the power of exponentials\r\n         * which aren't check by default.\r\n         * @example var s = _.parse('x+y+z'); s.contains('y');\r\n         * //returns true\r\n         * @param {any} variable\r\n         * @param {boolean} all\r\n         * @returns {boolean}\r\n         */\r\n        contains: function (variable, all) {\r\n            //contains expects a string\r\n            variable = String(variable);\r\n            var g = this.group;\r\n            if(this.value === variable)\r\n                return true;\r\n            if(this.symbols) {\r\n                for(var x in this.symbols) {\r\n                    if(this.symbols[x].contains(variable, all))\r\n                        return true;\r\n                }\r\n            }\r\n            if(g === FN || this.previousGroup === FN) {\r\n                for(var i = 0; i < this.args.length; i++) {\r\n                    if(this.args[i].contains(variable, all))\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            if(g === EX) {\r\n                //exit only if it does\r\n                if(all && this.power.contains(variable, all)) {\r\n                    return true;\r\n                }\r\n                if(this.value === variable)\r\n                    return true;\r\n\r\n            }\r\n\r\n            return this.value === variable;\r\n        },\r\n        /**\r\n         * Negates a symbols\r\n         * @returns {boolean}\r\n         */\r\n        negate: function () {\r\n            this.multiplier.negate();\r\n            if(this.group === CP || this.group === PL)\r\n                this.distributeMultiplier();\r\n            return this;\r\n        },\r\n        /**\r\n         * Inverts a symbol\r\n         * @param {boolean} power_only\r\n         * @param {boolean} all\r\n         * @returns {boolean}\r\n         */\r\n        invert: function (power_only, all) {\r\n            //invert the multiplier\r\n            if(!power_only)\r\n                this.multiplier = this.multiplier.invert();\r\n            //invert the rest\r\n            if(isSymbol(this.power)) {\r\n                this.power.negate();\r\n            }\r\n            else if(this.group === CB && all) {\r\n                this.each(function (x) {\r\n                    return x.invert();\r\n                });\r\n            }\r\n            else {\r\n                if(this.power && this.group !== N)\r\n                    this.power.negate();\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Symbols of group CP or PL may have the multiplier being carried by\r\n         * the top level symbol at any given time e.g. 2*(x+y+z). This is\r\n         * convenient in many cases, however in some cases the multiplier needs\r\n         * to be carried individually e.g. 2*x+2*y+2*z.\r\n         * This method distributes the multiplier over the entire symbol\r\n         * @param {boolean} all\r\n         * @returns {Symbol}\r\n         */\r\n        distributeMultiplier: function (all) {\r\n            var is_one = all ? this.power.absEquals(1) : this.power.equals(1);\r\n            if(this.symbols && is_one && this.group !== CB && !this.multiplier.equals(1)) {\r\n                for(var x in this.symbols) {\r\n                    var s = this.symbols[x];\r\n                    s.multiplier = s.multiplier.multiply(this.multiplier);\r\n                    s.distributeMultiplier();\r\n                }\r\n                this.toUnitMultiplier();\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * This method expands the exponent over the entire symbol just like\r\n         * distributeMultiplier\r\n         * @returns {Symbol}\r\n         */\r\n        distributeExponent: function () {\r\n            if(!this.power.equals(1)) {\r\n                var p = this.power;\r\n                for(var x in this.symbols) {\r\n                    var s = this.symbols[x];\r\n                    if(s.group === EX) {\r\n                        s.power = _.multiply(s.power, new Symbol(p));\r\n                    }\r\n                    else {\r\n                        this.symbols[x].power = this.symbols[x].power.multiply(p);\r\n                    }\r\n                }\r\n                this.toLinear();\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * This method will attempt to up-convert or down-convert one symbol\r\n         * from one group to another. Not all symbols are convertible from one\r\n         * group to another however. In that case the symbol will remain\r\n         * unchanged.\r\n         * @param {int} group\r\n         * @param {string} imaginary\r\n         */\r\n        convert: function (group, imaginary) {\r\n            if(group > FN) {\r\n                //make a clone of this symbol;\r\n                var cp = this.clone();\r\n\r\n                //attach a symbols object and upgrade the group\r\n                this.symbols = {};\r\n\r\n                if(group === CB) {\r\n                    //symbol of group CB hold symbols bound together through multiplication\r\n                    //because of commutativity this multiplier can technically be anywhere within the group\r\n                    //to keep track of it however it's easier to always have the top level carry it\r\n                    cp.toUnitMultiplier();\r\n                }\r\n                else {\r\n                    //reset the symbol\r\n                    this.toUnitMultiplier();\r\n                }\r\n\r\n                if(this.group === FN) {\r\n                    cp.args = this.args;\r\n                    delete this.args;\r\n                    delete this.fname;\r\n                }\r\n\r\n                //the symbol may originate from the symbol i but this property no longer holds true\r\n                //after copying\r\n                if(this.isImgSymbol)\r\n                    delete this.isImgSymbol;\r\n\r\n                this.toLinear();\r\n                //attach a clone of this symbol to the symbols object using its proper key\r\n                this.symbols[cp.keyForGroup(group)] = cp;\r\n                this.group = group;\r\n                //objects by default don't have a length property. However, in order to keep track of the number\r\n                //of sub-symbols we have to impliment our own.\r\n                this.length = 1;\r\n            }\r\n            else if(group === EX) {\r\n                //1^x is just one so check and make sure\r\n                if(!(this.group === N && this.multiplier.equals(1))) {\r\n                    if(this.group !== EX)\r\n                        this.previousGroup = this.group;\r\n                    if(this.group === N) {\r\n                        this.value = this.multiplier.num.toString();\r\n                        this.toUnitMultiplier();\r\n                    }\r\n                    //update the hash to reflect the accurate hash\r\n                    else\r\n                        this.value = text(this, 'hash');\r\n\r\n                    this.group = EX;\r\n                }\r\n            }\r\n            else if(group === N) {\r\n                var m = this.multiplier.toDecimal();\r\n                if(this.symbols)\r\n                    this.symbols = undefined;\r\n                new Symbol(this.group === P ? m * Math.pow(this.value, this.power) : m).clone(this);\r\n            }\r\n            else if(group === P && this.group === N) {\r\n                this.value = imaginary ? this.multiplier.num.toString() : Math.abs(this.multiplier.num.toString());\r\n                this.toUnitMultiplier(!imaginary);\r\n                this.group = P;\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * This method is one of the principal methods to make it all possible.\r\n         * It performs cleanup and prep operations whenever a symbols is\r\n         * inserted. If the symbols results in a 1 in a CB (multiplication)\r\n         * group for instance it will remove the redundant symbol. Similarly\r\n         * in a symbol of group PL or CP (symbols glued by multiplication) it\r\n         * will remove any dangling zeroes from the symbol. It will also\r\n         * up-convert or down-convert a symbol if it detects that it's\r\n         * incorrectly grouped. It should be noted that this method is not\r\n         * called directly but rather by the 'attach' method for addition groups\r\n         * and the 'combine' method for multiplication groups.\r\n         * @param {Symbol} symbol\r\n         * @param {String} action\r\n         */\r\n        insert: function (symbol, action) {\r\n            //this check can be removed but saves a lot of aggravation when trying to hunt down\r\n            //a bug. If left, you will instantly know that the error can only be between 2 symbols.\r\n            if(!isSymbol(symbol))\r\n                err('Object ' + symbol + ' is not of type Symbol!');\r\n            if(this.symbols) {\r\n                var group = this.group;\r\n                if(group > FN) {\r\n                    var key = symbol.keyForGroup(group);\r\n                    var existing = key in this.symbols ? this.symbols[key] : false; //check if there's already a symbol there\r\n                    if(action === 'add') {\r\n                        var hash = key;\r\n                        if(existing) {\r\n                            //add them together using the parser\r\n                            this.symbols[hash] = _.add(existing, symbol);\r\n                            //if the addition resulted in a zero multiplier remove it\r\n                            if(this.symbols[hash].multiplier.equals(0)) {\r\n                                delete this.symbols[hash];\r\n                                this.length--;\r\n\r\n                                if(this.length === 0) {\r\n                                    this.convert(N);\r\n                                    this.multiplier = new Frac(0);\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            this.symbols[key] = symbol;\r\n                            this.length++;\r\n                        }\r\n                    }\r\n                    else {\r\n                        //check if this is of group P and unwrap before inserting\r\n                        if(symbol.group === P && isInt(symbol.power)) {\r\n                            symbol.convert(N);\r\n                        }\r\n\r\n                        //transfer the multiplier to the upper symbol but only if the symbol numeric\r\n                        if(symbol.group !== EX) {\r\n                            this.multiplier = this.multiplier.multiply(symbol.multiplier);\r\n                            symbol.toUnitMultiplier();\r\n                        }\r\n                        else {\r\n                            symbol.parens = symbol.multiplier.lessThan(0);\r\n                            this.multiplier = this.multiplier.multiply(symbol.multiplier.clone().abs());\r\n                            symbol.toUnitMultiplier(true);\r\n                        }\r\n\r\n                        if(existing) {\r\n                            //remove because the symbol may have changed\r\n                            symbol = _.multiply(remove(this.symbols, key), symbol);\r\n                            if(symbol.isConstant()) {\r\n                                this.multiplier = this.multiplier.multiply(symbol.multiplier);\r\n                                symbol = new Symbol(1); //the dirty work gets done down the line when it detects 1\r\n                            }\r\n\r\n                            this.length--;\r\n                            //clean up\r\n                        }\r\n\r\n                        //don't insert the symbol if it's 1\r\n                        if(!symbol.isOne(true)) {\r\n                            this.symbols[key] = symbol;\r\n                            this.length++;\r\n                        }\r\n                        else if(symbol.multiplier.lessThan(0)) {\r\n                            this.negate(); //put back the sign\r\n                        }\r\n                    }\r\n\r\n                    //clean up\r\n                    if(this.length === 0)\r\n                        this.convert(N);\r\n                    //update the hash\r\n                    if(this.group === CP || this.group === CB) {\r\n                        this.updateHash();\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        //the insert method for addition\r\n        attach: function (symbol) {\r\n            if(isArray(symbol)) {\r\n                for(var i = 0; i < symbol.length; i++)\r\n                    this.insert(symbol[i], 'add');\r\n                return this;\r\n            }\r\n            return this.insert(symbol, 'add');\r\n        },\r\n        //the insert method for multiplication\r\n        combine: function (symbol) {\r\n            if(isArray(symbol)) {\r\n                for(var i = 0; i < symbol.length; i++)\r\n                    this.insert(symbol[i], 'multiply');\r\n                return this;\r\n            }\r\n            return this.insert(symbol, 'multiply');\r\n        },\r\n        /**\r\n         * This method should be called after any major \"surgery\" on a symbol.\r\n         * It updates the hash of the symbol for example if the fname of a\r\n         * function has changed it will update the hash of the symbol.\r\n         */\r\n        updateHash: function () {\r\n            if(this.group === N)\r\n                return;\r\n\r\n            if(this.group === FN) {\r\n                var contents = '',\r\n                        args = this.args,\r\n                        is_parens = this.fname === PARENTHESIS;\r\n                for(var i = 0; i < args.length; i++)\r\n                    contents += (i === 0 ? '' : ',') + text(args[i]);\r\n                var fn_name = is_parens ? '' : this.fname;\r\n                this.value = fn_name + (is_parens ? contents : inBrackets(contents));\r\n            }\r\n            else if(!(this.group === S || this.group === PL)) {\r\n                this.value = text(this, 'hash');\r\n            }\r\n        },\r\n        /**\r\n         * this function defines how every group in stored within a group of\r\n         * higher order think of it as the switchboard for the library. It\r\n         * defines the hashes for symbols.\r\n         * @param {int} group\r\n         */\r\n        keyForGroup: function (group) {\r\n            var g = this.group;\r\n            var key;\r\n\r\n            if(g === N) {\r\n                key = this.value;\r\n            }\r\n            else if(g === S || g === P) {\r\n                if(group === PL)\r\n                    key = this.power.toDecimal();\r\n                else\r\n                    key = this.value;\r\n            }\r\n            else if(g === FN) {\r\n                if(group === PL)\r\n                    key = this.power.toDecimal();\r\n                else\r\n                    key = text(this, 'hash');\r\n            }\r\n            else if(g === PL) {\r\n                //if the order is reversed then we'll assume multiplication\r\n                //TODO: possible future dilemma\r\n                if(group === CB)\r\n                    key = text(this, 'hash');\r\n                else if(group === CP) {\r\n                    if(this.power.equals(1))\r\n                        key = this.value;\r\n                    else\r\n                        key = inBrackets(text(this, 'hash')) + Settings.POWER_OPERATOR + this.power.toDecimal();\r\n                }\r\n                else if(group === PL)\r\n                    key = this.power.toString();\r\n                else\r\n                    key = this.value;\r\n                return key;\r\n            }\r\n            else if(g === CP) {\r\n                if(group === CP) {\r\n                    key = text(this, 'hash');\r\n                }\r\n                if(group === PL)\r\n                    key = this.power.toDecimal();\r\n                else\r\n                    key = this.value;\r\n            }\r\n            else if(g === CB) {\r\n                if(group === PL)\r\n                    key = this.power.toDecimal();\r\n                else\r\n                    key = text(this, 'hash');\r\n            }\r\n            else if(g === EX) {\r\n                if(group === PL)\r\n                    key = text(this.power);\r\n                else\r\n                    key = text(this, 'hash');\r\n            }\r\n\r\n            return key;\r\n        },\r\n        /**\r\n         * Symbols are typically stored in an object which works fine for most\r\n         * cases but presents a problem when the order of the symbols makes\r\n         * a difference. This function simply collects all the symbols and\r\n         * returns them as an array. If a function is supplied then that\r\n         * function is called on every symbol contained within the object.\r\n         * @param {Function} fn\r\n         * @param {Object} opt\r\n         * @param {Function} sort_fn\r\n         * @@param {Boolean} expand_symbol\r\n         * @returns {Array}\r\n         */\r\n        collectSymbols: function (fn, opt, sort_fn, expand_symbol) {\r\n            var collected = [];\r\n            if(!this.symbols)\r\n                collected.push(this);\r\n            else {\r\n                for(var x in this.symbols) {\r\n                    var symbol = this.symbols[x];\r\n                    if(expand_symbol && (symbol.group === PL || symbol.group === CP)) {\r\n                        collected = collected.concat(symbol.collectSymbols());\r\n                    }\r\n                    else\r\n                        collected.push(fn ? fn(symbol, opt) : symbol);\r\n                }\r\n            }\r\n            if(sort_fn === null)\r\n                sort_fn = undefined; //WTF Firefox? Seriously?\r\n\r\n            return collected.sort(sort_fn);//sort hopefully gives us some sort of consistency\r\n        },\r\n        /**\r\n         * Returns the latex representation of the symbol\r\n         * @param {String} option\r\n         * @returns {String}\r\n         */\r\n        latex: function (option) {\r\n            return LaTeX.latex(this, option);\r\n        },\r\n        /**\r\n         * Returns the text representation of a symbol\r\n         * @param {String} option\r\n         * @returns {String}\r\n         */\r\n        text: function (option) {\r\n            return text(this, option);\r\n        },\r\n        /**\r\n         * Checks if the function evaluates to 1. e.g. x^0 or 1 :)\r\n         * @@param {bool} abs Compares the absolute value\r\n         */\r\n        isOne: function (abs) {\r\n            var f = abs ? 'absEquals' : 'equals';\r\n            if(this.group === N)\r\n                return this.multiplier[f](1);\r\n            else\r\n                return this.power.equals(0);\r\n        },\r\n        isComposite: function () {\r\n            var g = this.group,\r\n                    pg = this.previousGroup;\r\n            return g === CP || g === PL || pg === PL || pg === CP;\r\n        },\r\n        isCombination: function () {\r\n            var g = this.group,\r\n                    pg = this.previousGroup;\r\n            return g === CB || pg === CB;\r\n        },\r\n        lessThan: function (n) {\r\n            return this.multiplier.lessThan(n);\r\n        },\r\n        greaterThan: function (n) {\r\n            if(!isSymbol(n)) {\r\n                n = new Symbol(n);\r\n            }\r\n\r\n            // We can't tell for sure if a is greater than be if they're not both numbers\r\n            if(!this.isConstant(true) || !n.isConstant(true)) {\r\n                return false;\r\n            }\r\n\r\n            return this.multiplier.greaterThan(n.multiplier);\r\n        },\r\n        /**\r\n         * Get's the denominator of the symbol if the symbol is of class CB (multiplication)\r\n         * with other classes the symbol is either the denominator or not.\r\n         * Take x^-1+x^-2. If the symbol was to be mixed such as x+x^-2 then the symbol doesn't have have an exclusive\r\n         * denominator and has to be found by looking at the actual symbols themselves.\r\n         */\r\n        getDenom: function () {\r\n            var retval, symbol;\r\n            symbol = this.clone();\r\n            //e.g. 1/(x*(x+1))\r\n            if(this.group === CB && this.power.lessThan(0))\r\n                symbol = _.expand(symbol);\r\n\r\n            //if the symbol already is the denominator... DONE!!!\r\n            if(symbol.power.lessThan(0)) {\r\n                var d = _.parse(symbol.multiplier.den);\r\n                retval = symbol.toUnitMultiplier();\r\n                retval.power.negate();\r\n                retval = _.multiply(d, retval); //put back the coeff\r\n            }\r\n            else if(symbol.group === CB) {\r\n                retval = _.parse(symbol.multiplier.den);\r\n                for(var x in symbol.symbols)\r\n                    if(symbol.symbols[x].power < 0)\r\n                        retval = _.multiply(retval, symbol.symbols[x].clone().invert());\r\n            }\r\n            else\r\n                retval = _.parse(symbol.multiplier.den);\r\n            return retval;\r\n        },\r\n        getNum: function () {\r\n            var retval, symbol;\r\n            symbol = this.clone();\r\n            //e.g. 1/(x*(x+1))\r\n            if(symbol.group === CB && symbol.power.lessThan(0))\r\n                symbol = _.expand(symbol);\r\n            //if the symbol already is the denominator... DONE!!!\r\n            if(symbol.power.greaterThan(0) && symbol.group !== CB) {\r\n                retval = _.multiply(_.parse(symbol.multiplier.num), symbol.toUnitMultiplier());\r\n            }\r\n            else if(symbol.group === CB) {\r\n                retval = _.parse(symbol.multiplier.num);\r\n                symbol.each(function (x) {\r\n                    if(x.power > 0 || x.group === EX && x.power.multiplier > 0) {\r\n                        retval = _.multiply(retval, x.clone());\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                retval = _.parse(symbol.multiplier.num);\r\n            }\r\n            return retval;\r\n        },\r\n        toString: function () {\r\n            return this.text();\r\n        }\r\n    };\r\n\r\n//Parser =======================================================================\r\n    //Uses modified Shunting-yard algorithm. http://en.wikipedia.org/wiki/Shunting-yard_algorithm\r\n    function Parser() {\r\n        //Point to the local parser instead of the global one\r\n        var _ = this;\r\n        var bin = {};\r\n        var preprocessors = {names: [], actions: []};\r\n\r\n//Parser.classes ===============================================================\r\n        function Slice(upper, lower) {\r\n            this.start = upper;\r\n            this.end = lower;\r\n        }\r\n        ;\r\n        Slice.prototype.isConstant = function () {\r\n            return this.start.isConstant() && this.end.isConstant();\r\n        };\r\n        Slice.prototype.text = function () {\r\n            return text(this.start) + ':' + text(this.end);\r\n        };\r\n\r\n        /**\r\n         * Class used to collect arguments for functions\r\n         * @returns {Parser.Collection}\r\n         */\r\n        function Collection() {\r\n            this.elements = [];\r\n        }\r\n        Collection.prototype.append = function (e) {\r\n            this.elements.push(e);\r\n        };\r\n        Collection.prototype.getItems = function () {\r\n            return this.elements;\r\n        };\r\n        Collection.prototype.toString = function () {\r\n            return _.pretty_print(this.elements);\r\n        };\r\n        Collection.create = function (e) {\r\n            var collection = new Collection();\r\n            if(e)\r\n                collection.append(e);\r\n            return collection;\r\n        };\r\n\r\n        function Token(node, node_type, column) {\r\n            this.type = node_type;\r\n            this.value = node;\r\n            if(column !== undefined)\r\n                this.column = column + 1;\r\n            if(node_type === Token.OPERATOR) {\r\n                //copy everything over from the operator\r\n                var operator = operators[node];\r\n                for(var x in operator)\r\n                    this[x] = operator[x];\r\n\r\n            }\r\n            else if(node_type === Token.FUNCTION) {\r\n                this.precedence = Token.MAX_PRECEDENCE; //leave enough roon\r\n                this.leftAssoc = false;\r\n            }\r\n        }\r\n        Token.prototype.toString = function () {\r\n            return this.value;\r\n        };\r\n        Token.prototype.toString = function () {\r\n            if(this.is_prefix)\r\n                return '`' + this.value;\r\n            return this.value;\r\n        };\r\n        //some constants\r\n        Token.OPERATOR = 'OPERATOR';\r\n        Token.VARIABLE_OR_LITERAL = 'VARIABLE_OR_LITERAL';\r\n        Token.FUNCTION = 'FUNCTION';\r\n        Token.UNIT = 'UNIT';\r\n        Token.KEYWORD = 'KEYWORD';\r\n        Token.MAX_PRECEDENCE = 999;\r\n        //create link to classes\r\n        this.classes = {\r\n            Collection: Collection,\r\n            Slice: Slice,\r\n            Token: Token\r\n        };\r\n//Parser.modules ===============================================================\r\n        //object for functions which handle complex number\r\n        var complex = {\r\n            prec: undefined,\r\n            cos: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.cos(r) * Math.cosh(i));\r\n                im = _.parse(Math.sin(r) * Math.sinh(i));\r\n                return _.subtract(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            sin: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.sin(r) * Math.cosh(i));\r\n                im = _.parse(Math.cos(r) * Math.sinh(i));\r\n                return _.subtract(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            tan: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.sin(2 * r) / (Math.cos(2 * r) + Math.cosh(2 * i)));\r\n                im = _.parse(Math.sinh(2 * i) / (Math.cos(2 * r) + Math.cosh(2 * i)));\r\n                return _.add(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            sec: function (r, i) {\r\n                var t = this.removeDen(this.cos(r, i));\r\n                return _.subtract(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            csc: function (r, i) {\r\n                var t = this.removeDen(this.sin(r, i));\r\n                return _.add(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            cot: function (r, i) {\r\n                var t = this.removeDen(this.tan(r, i));\r\n                return _.subtract(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            acos: function (r, i) {\r\n                var symbol, sq, a, b, c, squared;\r\n                symbol = this.fromArray([r, i]);\r\n                squared = _.pow(symbol.clone(), new Symbol(2));\r\n                sq = _.expand(squared); //z*z\r\n                a = _.multiply(sqrt(_.subtract(new Symbol(1), sq)), Symbol.imaginary());\r\n                b = _.expand(_.add(symbol.clone(), a));\r\n                c = log(b);\r\n                return _.expand(_.multiply(Symbol.imaginary().negate(), c));\r\n            },\r\n            asin: function (r, i) {\r\n                return _.subtract(_.parse('pi/2'), this.acos(r, i));\r\n            },\r\n            atan: function (r, i) {\r\n                // Handle i and -i\r\n                if(r.equals(0) && (i.equals(1) || i.equals(-1))) {\r\n                    // Just copy Wolfram Alpha for now. The parenthesis \r\n                    return _.parse(`${Symbol.infinity()}*${Settings.IMAGINARY}*${i}`);\r\n                }\r\n                var a, b, c, symbol;\r\n                symbol = complex.fromArray([r, i]);\r\n                a = _.expand(_.multiply(Symbol.imaginary(), symbol.clone()));\r\n                b = log(_.expand(_.subtract(new Symbol(1), a.clone())));\r\n                c = log(_.expand(_.add(new Symbol(1), a.clone())));\r\n                return _.expand(_.multiply(_.divide(Symbol.imaginary(), new Symbol(2)), _.subtract(b, c)));\r\n            },\r\n            asec: function (r, i) {\r\n                var d = this.removeDen([r, i]);\r\n                d[1].negate();\r\n                return this.acos.apply(this, d);\r\n            },\r\n            acsc: function (r, i) {\r\n                var d = this.removeDen([r, i]);\r\n                d[1].negate();\r\n                return this.asin.apply(this, d);\r\n            },\r\n            acot: function (r, i) {\r\n                var d = this.removeDen([r, i]);\r\n                d[1].negate();\r\n                return this.atan.apply(this, d);\r\n            },\r\n            //Hyperbolic trig\r\n            cosh: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.cosh(r) * Math.cos(i));\r\n                im = _.parse(Math.sinh(r) * Math.sin(i));\r\n                return _.add(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            sinh: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.sinh(r) * Math.cos(i));\r\n                im = _.parse(Math.cosh(r) * Math.sin(i));\r\n                return _.add(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            tanh: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.sinh(2 * r) / (Math.cos(2 * i) + Math.cosh(2 * r)));\r\n                im = _.parse(Math.sin(2 * i) / (Math.cos(2 * i) + Math.cosh(2 * r)));\r\n                return _.subtract(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            sech: function (r, i) {\r\n                var t = this.removeDen(this.cosh(r, i));\r\n                return _.subtract(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            csch: function (r, i) {\r\n                var t = this.removeDen(this.sinh(r, i));\r\n                return _.subtract(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            coth: function (r, i) {\r\n                var t = this.removeDen(this.tanh(r, i));\r\n                return _.add(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            acosh: function (r, i) {\r\n                var a, b, z;\r\n                z = this.fromArray([r, i]);\r\n                a = sqrt(_.add(z.clone(), new Symbol(1)));\r\n                b = sqrt(_.subtract(z.clone(), new Symbol(1)));\r\n                return _.expand(log(_.add(z, _.expand(_.multiply(a, b)))));\r\n            },\r\n            asinh: function (r, i) {\r\n                var a, z;\r\n                z = this.fromArray([r, i]);\r\n                a = sqrt(_.add(new Symbol(1), _.expand(_.pow(z.clone(), new Symbol(2)))));\r\n                return _.expand(log(_.add(z, a)));\r\n            },\r\n            atanh: function (r, i) {\r\n                var a, b, z;\r\n                z = this.fromArray([r, i]);\r\n                a = log(_.add(z.clone(), new Symbol(1)));\r\n                b = log(_.subtract(new Symbol(1), z));\r\n                return _.expand(_.divide(_.subtract(a, b), new Symbol(2)));\r\n            },\r\n            asech: function (r, i) {\r\n                var t = this.removeDen([r, i]);\r\n                t[1].negate();\r\n                return this.acosh.apply(this, t);\r\n            },\r\n            acsch: function (r, i) {\r\n                var t = this.removeDen([r, i]);\r\n                t[1].negate();\r\n                return this.asinh.apply(this, t);\r\n            },\r\n            acoth: function (r, i) {\r\n                var t = this.removeDen([r, i]);\r\n                t[1].negate();\r\n                return this.atanh.apply(this, t);\r\n            },\r\n            sqrt: function (symbol) {\r\n                var re, im, h, a, d;\r\n                re = symbol.realpart();\r\n                im = symbol.imagpart();\r\n                h = Symbol.hyp(re, im);\r\n                a = _.add(re.clone(), h);\r\n                d = sqrt(_.multiply(new Symbol(2), a.clone()));\r\n                return _.add(_.divide(a.clone(), d.clone()), _.multiply(_.divide(im, d), Symbol.imaginary()));\r\n            },\r\n            log: function (r, i) {\r\n                var re, im, phi;\r\n                re = log(Symbol.hyp(r, i));\r\n                phi = Settings.USE_BIG ? Symbol(bigDec.atan2(i.multiplier.toDecimal(), r.multiplier.toDecimal())) : Math.atan2(i, r);\r\n                im = _.parse(phi);\r\n                return _.add(re, _.multiply(Symbol.imaginary(), im));\r\n            },\r\n            erf(symbol, n) {\r\n                //Do nothing for now. Revisit this in the future.\r\n                return _.symfunction('erf', [symbol]);\r\n\r\n                n = n || 30;\r\n\r\n                var f = function (R, I) {\r\n                    return block('PARSE2NUMBER', function () {\r\n                        var retval = new Symbol(0);\r\n                        for(var i = 0; i < n; i++) {\r\n                            var a, b;\r\n                            a = _.parse(bigDec.exp(bigDec(i).toPower(2).neg().dividedBy(bigDec(n).pow(2).plus(bigDec(R).toPower(2).times(4)))));\r\n                            b = _.parse(format('2*({1})-e^(-(2*{0}*{1}*{2}))*(2*{1}*cosh({2}*{3})-{0}*{3}*sinh({3}*{2}))', Settings.IMAGINARY, R, I, i));\r\n                            retval = _.add(retval, _.multiply(a, b));\r\n                        }\r\n                        return _.multiply(retval, new Symbol(2));\r\n                    }, true);\r\n                };\r\n                var re, im, a, b, c, k;\r\n                re = symbol.realpart();\r\n                im = symbol.imagpart();\r\n\r\n                k = _.parse(format('(e^(-{0}^2))/pi', re));\r\n                a = _.parse(format('(1-e^(-(2*{0}*{1}*{2})))/(2*{1})', Settings.IMAGINARY, re, im));\r\n                b = f(re.toString(), im.toString());\r\n\r\n                return _.add(_.parse(Math2.erf(re.toString())), _.multiply(k, _.add(a, b)));\r\n            },\r\n            removeDen: function (symbol) {\r\n                var den, r, i, re, im;\r\n                if(isArray(symbol)) {\r\n                    r = symbol[0];\r\n                    i = symbol[1];\r\n                }\r\n                else {\r\n                    r = symbol.realpart();\r\n                    i = symbol.imagpart();\r\n                }\r\n\r\n                den = Math.pow(r, 2) + Math.pow(i, 2);\r\n                re = _.parse(r / den);\r\n                im = _.parse(i / den);\r\n                return [re, im];\r\n            },\r\n            fromArray: function (arr) {\r\n                return _.add(arr[0], _.multiply(Symbol.imaginary(), arr[1]));\r\n            },\r\n            evaluate: function (symbol, f) {\r\n                var re, im, sign;\r\n\r\n                sign = symbol.power.sign();\r\n                //remove it from under the denominator\r\n                symbol.power = symbol.power.abs();\r\n                //expand\r\n                if(symbol.power.greaterThan(1))\r\n                    symbol = _.expand(symbol);\r\n                //remove the denominator\r\n                if(sign < 0) {\r\n                    var d = this.removeDen(symbol);\r\n                    re = d[0];\r\n                    im = d[1];\r\n                }\r\n                else {\r\n                    re = symbol.realpart();\r\n                    im = symbol.imagpart();\r\n                }\r\n\r\n                if(re.isConstant('all') && im.isConstant('all'))\r\n                    return this[f].call(this, re, im);\r\n\r\n                return _.symfunction(f, [symbol]);\r\n            }\r\n        };\r\n        //object for functions which handle trig\r\n        var trig = this.trig = {\r\n            //container for trigonometric function\r\n            cos: function (symbol) {\r\n                if(symbol.equals('pi') && symbol.multiplier.den.equals(2))\r\n                    return new Symbol(0);\r\n\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.equals(new Symbol(Settings.PI / 2)))\r\n                        return new Symbol(0);\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.cos(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.cos(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'cos');\r\n                    }\r\n                }\r\n                if(symbol.equals(0))\r\n                    return new Symbol(1);\r\n\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        m = symbol.multiplier.abs();\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return for 1 or -1 for multiples of pi\r\n                    if(isInt(m)) {\r\n                        retval = new Symbol(even(m) ? 1 : -1);\r\n                    }\r\n                    else {\r\n                        var n = Number(m.num), d = Number(m.den);\r\n                        if(d === 2)\r\n                            retval = new Symbol(0);\r\n                        else if(d === 3) {\r\n                            retval = _.parse('1/2');\r\n                            c = true;\r\n                        }\r\n                        else if(d === 4) {\r\n                            retval = _.parse('1/sqrt(2)');\r\n                            c = true;\r\n                        }\r\n                        else if(d === 6) {\r\n                            retval = _.parse('sqrt(3)/2');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.symfunction('cos', [symbol]);\r\n                    }\r\n                }\r\n\r\n                if(c && (q === 2 || q === 3))\r\n                    retval.negate();\r\n\r\n                if(!retval)\r\n                    retval = _.symfunction('cos', [symbol]);\r\n\r\n                return retval;\r\n            },\r\n            sin: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol % Math.PI === 0) {\r\n                            return new Symbol(0);\r\n                        }\r\n\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.sin(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.sin(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'sin');\r\n                }\r\n\r\n                if(symbol.equals(0))\r\n                    return new Symbol(0);\r\n\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        sign = symbol.multiplier.sign(),\r\n                        m = symbol.multiplier.abs();\r\n                symbol.multiplier = m;\r\n                if(symbol.equals('pi'))\r\n                    retval = new Symbol(0);\r\n                else if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return for 0 for multiples of pi\r\n                    if(isInt(m)) {\r\n                        retval = new Symbol(0);\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2) {\r\n                            retval = new Symbol(1);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 3) {\r\n                            retval = _.parse('sqrt(3)/2');\r\n                            c = true\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = _.parse('1/sqrt(2)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = _.parse('1/2');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.multiply(new Symbol(sign), _.symfunction('sin', [symbol]));\r\n                    }\r\n                }\r\n\r\n                if(!retval)\r\n                    retval = _.multiply(new Symbol(sign), _.symfunction('sin', [symbol]));\r\n\r\n                if(c && (q === 3 || q === 4))\r\n                    retval.negate();\r\n\r\n                return retval;\r\n            },\r\n            tan: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol % Math.PI === 0 && symbol.isLinear()) {\r\n                        return new Symbol(0);\r\n                    }\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.tan(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.tan(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'tan');\r\n                }\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        m = symbol.multiplier;\r\n\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return 0 for all multiples of pi\r\n                    if(isInt(m)) {\r\n                        retval = new Symbol(0);\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2)\r\n                            throw new UndefinedError('tan is undefined for ' + symbol.toString());\r\n                        else if(d == 3) {\r\n                            retval = _.parse('sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = new Symbol(1);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = _.parse('1/sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.symfunction('tan', [symbol]);\r\n                    }\r\n                }\r\n\r\n                if(!retval)\r\n                    retval = _.symfunction('tan', [symbol]);\r\n\r\n                if(c && (q === 2 || q === 4))\r\n                    retval.negate();\r\n\r\n                return retval;\r\n            },\r\n            sec: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(new bigDec(1).dividedBy(bigDec.cos(symbol.multiplier.toDecimal())));\r\n                        }\r\n\r\n                        return new Symbol(Math2.sec(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'sec');\r\n                    return _.parse(format('1/cos({0})', symbol));\r\n                }\r\n\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        m = symbol.multiplier.abs();\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return for 1 or -1 for multiples of pi\r\n                    if(isInt(m)) {\r\n                        retval = new Symbol(even(m) ? 1 : -1);\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2)\r\n                            throw new UndefinedError('sec is undefined for ' + symbol.toString());\r\n                        else if(d == 3) {\r\n                            retval = new Symbol(2);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = _.parse('sqrt(2)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = _.parse('2/sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.symfunction('sec', [symbol]);\r\n                    }\r\n                }\r\n\r\n                if(c && (q === 2 || q === 3))\r\n                    retval.negate();\r\n\r\n                if(!retval)\r\n                    retval = _.symfunction('sec', [symbol]);\r\n\r\n                return retval;\r\n            },\r\n            csc: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(new bigDec(1).dividedBy(bigDec.sin(symbol.multiplier.toDecimal())));\r\n                        }\r\n\r\n                        return new Symbol(Math2.csc(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'csc');\r\n                    return _.parse(format('1/sin({0})', symbol));\r\n                }\r\n\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        sign = symbol.multiplier.sign(),\r\n                        m = symbol.multiplier.abs();\r\n\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return for 0 for multiples of pi\r\n                    if(isInt(m)) {\r\n                        throw new UndefinedError('csc is undefined for ' + symbol.toString());\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2) {\r\n                            retval = new Symbol(1);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 3) {\r\n                            retval = _.parse('2/sqrt(3)');\r\n                            c = true\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = _.parse('sqrt(2)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = new Symbol(2);\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.multiply(new Symbol(sign), _.symfunction('csc', [symbol]));\r\n                    }\r\n                }\r\n\r\n                if(!retval)\r\n                    retval = _.multiply(new Symbol(sign), _.symfunction('csc', [symbol]));\r\n\r\n                if(c && (q === 3 || q === 4))\r\n                    retval.negate();\r\n\r\n                return retval;\r\n            },\r\n            cot: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol % (Math.PI/2) === 0) {\r\n                        return new Symbol(0);\r\n                    }\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(new bigDec(1).dividedBy(bigDec.tan(symbol.multiplier.toDecimal())));\r\n                        }\r\n\r\n                        return new Symbol(Math2.cot(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'cot');\r\n                    return _.parse(format('1/tan({0})', symbol));\r\n                }\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        m = symbol.multiplier;\r\n\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return 0 for all multiples of pi\r\n                    if(isInt(m)) {\r\n                        throw new UndefinedError('cot is undefined for ' + symbol.toString());\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2)\r\n                            retval = new Symbol(0);\r\n                        else if(d == 3) {\r\n                            retval = _.parse('1/sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = new Symbol(1);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = _.parse('sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.symfunction('cot', [symbol]);\r\n                    }\r\n                }\r\n\r\n                if(!retval)\r\n                    retval = _.symfunction('cot', [symbol]);\r\n\r\n                if(c && (q === 2 || q === 4))\r\n                    retval.negate();\r\n\r\n                return retval;\r\n            },\r\n            acos: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        // Handle values in the complex domain\r\n                        if(symbol.gt(1) || symbol.lt(-1)) {\r\n                            var x = symbol.toString();\r\n                            return expand(evaluate(`pi/2-asin(${x})`));\r\n                        }\r\n                        // Handle big numbers\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.acos(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.acos(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'acos');\r\n                }\r\n                return _.symfunction('acos', arguments);\r\n            },\r\n            asin: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        // Handle values in the complex domain\r\n                        if(symbol.gt(1) || symbol.lt(-1)) {\r\n                            var i = Settings.IMAGINARY;\r\n                            var x = symbol.multiplier.toDecimal();\r\n                            return expand(evaluate(`${i}*log(sqrt(1-${x}^2)-${i}*${x})`));\r\n                        }\r\n                        // Handle big numbers\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.asin(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.asin(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'asin');\r\n                }\r\n                return _.symfunction('asin', arguments);\r\n            },\r\n            atan: function (symbol) {\r\n                var retval;\r\n                if(symbol.equals(0))\r\n                    retval = new Symbol(0);\r\n                else if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        // Handle big numbers\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.atan(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.atan(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'atan');\r\n                    return _.symfunction('atan', arguments);\r\n                }\r\n                else if(symbol.equals(-1))\r\n                    retval = _.parse('-pi/4');\r\n                else\r\n                    retval = _.symfunction('atan', arguments);\r\n                return retval;\r\n            },\r\n            asec: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.equals(0)) {\r\n                        throw new OutOfFunctionDomainError('Input is out of the domain of sec!');\r\n                    }\r\n                    if(symbol.isConstant()) {\r\n                        return trig.acos(symbol.invert());\r\n                    }\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'asec');\r\n                    }\r\n                }\r\n                return _.symfunction('asec', arguments);\r\n            },\r\n            acsc: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        return trig.asin(symbol.invert());\r\n                    }\r\n\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'acsc');\r\n                }\r\n                return _.symfunction('acsc', arguments);\r\n            },\r\n            acot: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        return new _.add(_.parse('pi/2'), trig.atan(symbol).negate());\r\n                    }\r\n\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'acot');\r\n                }\r\n                return _.symfunction('acot', arguments);\r\n            },\r\n            atan2: function (a, b) {\r\n                if(a.equals(0) && b.equals(0))\r\n                    throw new UndefinedError('atan2 is undefined for 0, 0');\r\n\r\n                if(Settings.PARSE2NUMBER && a.isConstant() && b.isConstant()) {\r\n                    return new Symbol(Math.atan2(a, b));\r\n                }\r\n                return _.symfunction('atan2', arguments);\r\n            }\r\n        };\r\n        //object for functions which handle hyperbolic trig\r\n        var trigh = this.trigh = {\r\n            //container for hyperbolic trig function\r\n            cosh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.cosh(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'cosh');\r\n                    }\r\n                }\r\n\r\n                return retval = _.symfunction('cosh', arguments);\r\n            },\r\n            sinh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.sinh(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'sinh');\r\n                    }\r\n                }\r\n\r\n                return retval = _.symfunction('sinh', arguments);\r\n            },\r\n            tanh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.tanh(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'tanh');\r\n                    }\r\n                }\r\n\r\n                return retval = _.symfunction('tanh', arguments);\r\n            },\r\n            sech: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        return new Symbol(Math.sech(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'sech');\r\n                    }\r\n                    return _.parse(format('1/cosh({0})', symbol));\r\n                }\r\n\r\n                return retval = _.symfunction('sech', arguments);\r\n            },\r\n            csch: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.csch(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'csch');\r\n                    }\r\n                    return _.parse(format('1/sinh({0})', symbol));\r\n                }\r\n\r\n                return retval = _.symfunction('csch', arguments);\r\n            },\r\n            coth: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.coth(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'coth');\r\n                    }\r\n                    return _.parse(format('1/tanh({0})', symbol));\r\n                }\r\n\r\n                return retval = _.symfunction('coth', arguments);\r\n            },\r\n            acosh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'acosh');\r\n                else if(Settings.PARSE2NUMBER)\r\n                    retval = evaluate(_.parse(format(Settings.LOG + '(({0})+sqrt(({0})^2-1))', symbol.toString())));\r\n                else\r\n                    retval = _.symfunction('acosh', arguments);\r\n                return retval;\r\n            },\r\n            asinh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'asinh');\r\n                else if(Settings.PARSE2NUMBER)\r\n                    retval = evaluate(_.parse(format(Settings.LOG + '(({0})+sqrt(({0})^2+1))', symbol.toString())));\r\n                else\r\n                    retval = _.symfunction('asinh', arguments);\r\n                return retval;\r\n            },\r\n            atanh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'atanh');\r\n                else if(Settings.PARSE2NUMBER) {\r\n                    retval = evaluate(_.parse(format('(1/2)*' + Settings.LOG + '((1+({0}))/(1-({0})))', symbol.toString())));\r\n                }\r\n                else\r\n                    retval = _.symfunction('atanh', arguments);\r\n                return retval;\r\n            },\r\n            asech: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'asech');\r\n                else if(Settings.PARSE2NUMBER)\r\n                    retval = evaluate(log(_.add(symbol.clone().invert(), sqrt(_.subtract(_.pow(symbol, new Symbol(-2)), new Symbol(1))))));\r\n                else\r\n                    retval = _.symfunction('asech', arguments);\r\n                return retval;\r\n            },\r\n            acsch: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'acsch');\r\n                else if(Settings.PARSE2NUMBER)\r\n                    retval = evaluate(_.parse(format(Settings.LOG + '((1+sqrt(1+({0})^2))/({0}))', symbol.toString())));\r\n                else\r\n                    retval = _.symfunction('acsch', arguments);\r\n                return retval;\r\n            },\r\n            acoth: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'acoth');\r\n                else if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.equals(1))\r\n                        retval = Symbol.infinity();\r\n                    else\r\n                        retval = evaluate(\r\n                                _.divide(\r\n                                        log(_.divide(_.add(symbol.clone(), new Symbol(1)), _.subtract(symbol.clone(), new Symbol(1)))),\r\n                                        new Symbol(2)));\r\n                }\r\n                else\r\n                    retval = _.symfunction('acoth', arguments);\r\n                return retval;\r\n            }\r\n        };\r\n        //list of supported units\r\n        this.units = {};\r\n        //list all the supported operators\r\n        var operators = {\r\n            '\\\\': {\r\n                precedence: 8,\r\n                operator: '\\\\',\r\n                action: 'slash',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return e; //bypass the slash\r\n                }\r\n            },\r\n            '!!': {\r\n                precedence: 7,\r\n                operator: '!!',\r\n                action: 'dfactorial',\r\n                prefix: false,\r\n                postfix: true,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return _.symfunction(Settings.DOUBLEFACTORIAL, [e]); //wrap it in a factorial function\r\n                }\r\n            },\r\n            '!': {\r\n                precedence: 7,\r\n                operator: '!',\r\n                action: 'factorial',\r\n                prefix: false,\r\n                postfix: true,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return factorial(e); //wrap it in a factorial function\r\n                }\r\n            },\r\n            '^': {\r\n                precedence: 6,\r\n                operator: '^',\r\n                action: 'pow',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: true\r\n            },\r\n            '**': {\r\n                precedence: 6,\r\n                operator: '**',\r\n                action: 'pow',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: true\r\n            },\r\n            '%': {\r\n                precedence: 4,\r\n                operator: '%',\r\n                action: 'percent',\r\n                prefix: false,\r\n                postfix: true,\r\n                leftAssoc: true,\r\n                overloaded: true,\r\n                overloadAction: 'mod',\r\n                overloadLeftAssoc: false,\r\n                operation: function (x) {\r\n                    return _.divide(x, new Symbol(100));\r\n                }\r\n            },\r\n            '*': {\r\n                precedence: 4,\r\n                operator: '*',\r\n                action: 'multiply',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '/': {\r\n                precedence: 4,\r\n                operator: '/',\r\n                action: 'divide',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '+': {\r\n                precedence: 3,\r\n                operator: '+',\r\n                action: 'add',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: false,\r\n                operation: function (x) {\r\n                    return x;\r\n                }\r\n            },\r\n            'plus': {\r\n                precedence: 3,\r\n                operator: 'plus',\r\n                action: 'add',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: false,\r\n                operation: function (x) {\r\n                    return x;\r\n                }\r\n            },\r\n            '-': {\r\n                precedence: 3,\r\n                operator: '-',\r\n                action: 'subtract',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: false,\r\n                operation: function (x) {\r\n                    return x.negate();\r\n                }\r\n            },\r\n            '=': {\r\n                precedence: 2,\r\n                operator: '=',\r\n                action: 'equals',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '==': {\r\n                precedence: 1,\r\n                operator: '==',\r\n                action: 'eq',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '<': {\r\n                precedence: 1,\r\n                operator: '<',\r\n                action: 'lt',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '<=': {\r\n                precedence: 1,\r\n                operator: '<=',\r\n                action: 'lte',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '>': {\r\n                precedence: 1,\r\n                operator: '>',\r\n                action: 'gt',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '=>': {\r\n                precedence: 1,\r\n                operator: '=>',\r\n                action: 'gte',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            ',': {\r\n                precedence: 0,\r\n                operator: ',',\r\n                action: 'comma',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            ':': {\r\n                precedence: 0,\r\n                operator: ',',\r\n                action: 'assign',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false,\r\n                vectorFn: 'slice'\r\n            },\r\n            ':=': {\r\n                precedence: 0,\r\n                operator: ',',\r\n                action: 'function_assign',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: true\r\n            }\r\n        };\r\n        //brackets\r\n        var brackets = {\r\n            '(': {\r\n                type: 'round',\r\n                id: 1,\r\n                is_open: true,\r\n                is_close: false\r\n            },\r\n            ')': {\r\n                type: 'round',\r\n                id: 2,\r\n                is_open: false,\r\n                is_close: true\r\n            },\r\n            '[': {\r\n                type: 'square',\r\n                id: 3,\r\n                is_open: true,\r\n                is_close: false,\r\n                maps_to: 'vector'\r\n            },\r\n            ']': {\r\n                type: 'square',\r\n                id: 4,\r\n                is_open: false,\r\n                is_close: true\r\n            },\r\n            '{': {\r\n                type: 'curly',\r\n                id: 5,\r\n                is_open: true,\r\n                is_close: false,\r\n                maps_to: 'Set'\r\n            },\r\n            '}': {\r\n                type: 'curly',\r\n                id: 6,\r\n                is_open: false,\r\n                is_close: true\r\n            }\r\n        };\r\n        // Supported functions.\r\n        // Format: function_name: [mapped_function, number_of_parameters]\r\n        var functions = this.functions = {\r\n            'cos': [trig.cos, 1],\r\n            'sin': [trig.sin, 1],\r\n            'tan': [trig.tan, 1],\r\n            'sec': [trig.sec, 1],\r\n            'csc': [trig.csc, 1],\r\n            'cot': [trig.cot, 1],\r\n            'acos': [trig.acos, 1],\r\n            'asin': [trig.asin, 1],\r\n            'atan': [trig.atan, 1],\r\n            'arccos': [trig.acos, 1],\r\n            'arcsin': [trig.asin, 1],\r\n            'arctan': [trig.atan, 1],\r\n            'asec': [trig.asec, 1],\r\n            'acsc': [trig.acsc, 1],\r\n            'acot': [trig.acot, 1],\r\n            'atan2': [trig.atan2, 2],\r\n            'acoth': [trigh.acoth, 1],\r\n            'asech': [trigh.asech, 1],\r\n            'acsch': [trigh.acsch, 1],\r\n            'sinh': [trigh.sinh, 1],\r\n            'cosh': [trigh.cosh, 1],\r\n            'tanh': [trigh.tanh, 1],\r\n            'asinh': [trigh.asinh, 1],\r\n            'sech': [trigh.sech, 1],\r\n            'csch': [trigh.csch, 1],\r\n            'coth': [trigh.coth, 1],\r\n            'acosh': [trigh.acosh, 1],\r\n            'atanh': [trigh.atanh, 1],\r\n            'log10': [, 1],\r\n            'exp': [exp, 1],\r\n            'radians': [radians, 1],\r\n            'degrees': [degrees, 1],\r\n            'min': [min, -1],\r\n            'max': [max, -1],\r\n            'erf': [, 1],\r\n            'floor': [, 1],\r\n            'ceil': [, 1],\r\n            'trunc': [, 1],\r\n            'Si': [, 1],\r\n            'step': [, 1],\r\n            'rect': [, 1],\r\n            'sinc': [sinc, 1],\r\n            'tri': [, 1],\r\n            'sign': [sign, 1],\r\n            'Ci': [, 1],\r\n            'Ei': [, 1],\r\n            'Shi': [, 1],\r\n            'Chi': [, 1],\r\n            'Li': [, 1],\r\n            'fib': [, 1],\r\n            'fact': [factorial, 1],\r\n            'factorial': [factorial, 1],\r\n            'continued_fraction': [continued_fraction, [1, 2]],\r\n            'dfactorial': [, 1],\r\n            'gamma_incomplete': [, [1, 2]],\r\n            'round': [round, [1, 2]],\r\n            'scientific': [scientific, [1, 2]],\r\n            'mod': [mod, 2],\r\n            'pfactor': [pfactor, 1],\r\n            'vector': [vector, -1],\r\n            'matrix': [matrix, -1],\r\n            'Set': [set, -1],\r\n            'imatrix': [imatrix, -1],\r\n            'parens': [parens, -1],\r\n            'sqrt': [sqrt, 1],\r\n            'cbrt': [cbrt, 1],\r\n            'nthroot': [nthroot, 2],\r\n            'log': [log, [1, 2]],\r\n            'expand': [expandall, 1],\r\n            'abs': [abs, 1],\r\n            'invert': [invert, 1],\r\n            'determinant': [determinant, 1],\r\n            'size': [size, 1],\r\n            'transpose': [transpose, 1],\r\n            'dot': [dot, 2],\r\n            'cross': [cross, 2],\r\n            'vecget': [vecget, 2],\r\n            'vecset': [vecset, 3],\r\n            'vectrim': [vectrim, [1, 2]],\r\n            'matget': [matget, 3],\r\n            'matset': [matset, 4],\r\n            'matgetrow': [matgetrow, 2],\r\n            'matsetrow': [matsetrow, 3],\r\n            'matgetcol': [matgetcol, 2],\r\n            'matsetcol': [matsetcol, 3],\r\n            'rationalize': [rationalize, 1],\r\n            'IF': [IF, 3],\r\n            'is_in': [is_in, 2],\r\n            //imaginary support\r\n            'realpart': [realpart, 1],\r\n            'imagpart': [imagpart, 1],\r\n            'conjugate': [conjugate, 1],\r\n            'arg': [arg, 1],\r\n            'polarform': [polarform, 1],\r\n            'rectform': [rectform, 1],\r\n            'sort': [sort, [1, 2]],\r\n            'integer_part': [, 1],\r\n            'union': [union, 2],\r\n            'contains': [contains, 2],\r\n            'intersection': [intersection, 2],\r\n            'difference': [difference, 2],\r\n            'intersects': [intersects, 2],\r\n            'is_subset': [is_subset, 2],\r\n            //system support\r\n            'print': [print, -1]\r\n        };\r\n\r\n        //error handler\r\n        this.error = err;\r\n        //this function is used to comb through the function modules and find a function given its name\r\n        var findFunction = function (fname) {\r\n            var fmodules = Settings.FUNCTION_MODULES,\r\n                    l = fmodules.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var fmodule = fmodules[i];\r\n                if(fname in fmodule)\r\n                    return fmodule[fname];\r\n            }\r\n            err('The function ' + fname + ' is undefined!');\r\n        };\r\n\r\n        /**\r\n         * This method gives the ability to override operators with new methods.\r\n         * @param {String} which\r\n         * @param {Function} with_what\r\n         */\r\n        this.override = function (which, with_what) {\r\n            if(!bin[which])\r\n                bin[which] = [];\r\n            bin[which].push(this[which]);\r\n            this[which] = with_what;\r\n        };\r\n\r\n        /**\r\n         * Restores a previously overridden operator\r\n         * @param {String} what\r\n         */\r\n        this.restore = function (what) {\r\n            if(this[what])\r\n                this[what] = bin[what].pop();\r\n        };\r\n\r\n        /**\r\n         * This method is supposed to behave similarly to the override method but it does not override\r\n         * the existing function rather it only extends it\r\n         * @param {String} what\r\n         * @param {Function} with_what\r\n         * @param {boolean} force_call\r\n         */\r\n        this.extend = function (what, with_what, force_call) {\r\n            var _ = this,\r\n                    extended = this[what];\r\n            if(typeof extended === 'function' && typeof with_what === 'function') {\r\n                var f = this[what];\r\n                this[what] = function (a, b) {\r\n                    if(isSymbol(a) && isSymbol(b) && !force_call)\r\n                        return f.call(_, a, b);\r\n                    else\r\n                        return with_what.call(_, a, b, f);\r\n                };\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Generates library's representation of a function. It's a fancy way of saying a symbol with\r\n         * a few extras. The most important thing is that that it gives a fname and\r\n         * an args property to the symbols in addition to changing its group to FN\r\n         * @param {String} fn_name\r\n         * @param {Array} params\r\n         * @returns {Symbol}\r\n         */\r\n        this.symfunction = function (fn_name, params) {\r\n            //call the proper function and return the result;\r\n            var f = new Symbol(fn_name);\r\n            f.group = FN;\r\n            if(typeof params === 'object')\r\n                params = [].slice.call(params);//ensure an array\r\n            f.args = params;\r\n            f.fname = fn_name === PARENTHESIS ? '' : fn_name;\r\n            f.updateHash();\r\n            return f;\r\n        };\r\n\r\n        /**\r\n         * An internal function call for the Parser. This will either trigger a real\r\n         * function call if it can do so or just return a symbolic representation of the\r\n         * function using symfunction.\r\n         * @param {String} fn_name\r\n         * @param {Array} args\r\n         * @param {int} allowed_args\r\n         * @returns {Symbol}\r\n         */\r\n        this.callfunction = function (fn_name, args, allowed_args) {\r\n            var fn_settings = functions[fn_name];\r\n\r\n            if(!fn_settings)\r\n                err('Nerdamer currently does not support the function ' + fn_name);\r\n\r\n            var num_allowed_args = fn_settings[1] || allowed_args, //get the number of allowed arguments\r\n                    fn = fn_settings[0], //get the mapped function\r\n                    retval;\r\n            //We want to be able to call apply on the arguments or create a symfunction. Both require\r\n            //an array so make sure to wrap the argument in an array.\r\n            if(!(args instanceof Array))\r\n                args = args !== undefined ? [args] : [];\r\n\r\n            if(num_allowed_args !== -1) {\r\n                var is_array = isArray(num_allowed_args),\r\n                        min_args = is_array ? num_allowed_args[0] : num_allowed_args,\r\n                        max_args = is_array ? num_allowed_args[1] : num_allowed_args,\r\n                        num_args = args.length;\r\n\r\n                var error_msg = fn_name + ' requires a {0} of {1} arguments. {2} provided!';\r\n\r\n                if(num_args < min_args)\r\n                    err(format(error_msg, 'minimum', min_args, num_args));\r\n                if(num_args > max_args)\r\n                    err(format(error_msg, 'maximum', max_args, num_args));\r\n            }\r\n\r\n            /*\r\n             * The following are very important to the how nerdamer constructs functions!\r\n             * Assumption 1 - if fn is undefined then handling of the function is purely numeric. This\r\n             *     enables us to reuse Math, Math2, ..., any function from Settings.FUNCTIONS_MODULES entry\r\n             * Assumption 2 - if fn is defined then that function takes care of EVERYTHING including symbolics\r\n             * Assumption 3 - if the user calls symbolics on a function that returns a numeric value then\r\n             *     they are expecting a symbolic output.\r\n             */\r\n            //check if arguments are all numers\r\n            var numericArgs = allNumbers(args);\r\n            //Big number support. Check if Big number is requested and the arguments are all numeric and, not imaginary\r\n//            if (Settings.USE_BIG && numericArgs) {\r\n//                retval = Big[fn_name].apply(undefined, args);\r\n//            }\r\n//            else {\r\n            if(!fn) {\r\n                //Remember assumption 1. No function defined so it MUST be numeric in nature\r\n                fn = findFunction(fn_name);\r\n                if(Settings.PARSE2NUMBER && numericArgs)\r\n                    retval = bigConvert(fn.apply(fn, args));\r\n                else\r\n                    retval = _.symfunction(fn_name, args);\r\n            }\r\n            else {\r\n                //Remember assumption 2. The function is defined so it MUST handle all aspects including numeric values\r\n                retval = fn.apply(fn_settings[2], args);\r\n            }\r\n//            }\r\n\r\n            return retval;\r\n        };\r\n        /**\r\n         * Build a regex based on the operators currently loaded. These operators are to be ignored when\r\n         * substituting spaces for multiplication\r\n         */\r\n        this.operator_filter_regex = (function () {\r\n            //we only want the operators which are singular since those are the ones\r\n            //that nerdamer uses anyway\r\n            var ostr = '^\\\\' + Object.keys(operators).filter(function (x) {\r\n                if(x.length === 1)\r\n                    return x;\r\n            }).join('\\\\');\r\n            //create a regex which captures all spaces between characters except those\r\n            //have an operator on one end\r\n            return new RegExp('([' + ostr + '])\\\\s+([' + ostr + '])');\r\n        })();\r\n\r\n        /**\r\n         * Replaces nerdamer.setOperator\r\n         * @param {object} operator\r\n         * @param {boolean} shift\r\n         */\r\n        this.setOperator = function (operator, action, shift) {\r\n            var name = operator.operator; //take the name to be the symbol\r\n            operators[name] = operator;\r\n            if(action)\r\n                this[operator.action] = action;\r\n            //make the parser aware of the operator\r\n            _[name] = operator.operation;\r\n            //make the action available to the parser if infix\r\n            if(!operator.action && !(operator.prefix || operator.postif)) {\r\n                operator.action = name;\r\n            }\r\n            //if this operator is exclusive then all successive operators should be shifted\r\n            if(shift === 'over' || shift === 'under') {\r\n                var precedence = operator.precedence;\r\n\r\n                for(var x in operators) {\r\n                    var o = operators[x];\r\n                    var condition = shift === 'over' ? o.precedence >= precedence : o.precedence > precedence;\r\n                    if(condition)\r\n                        o.precedence++;\r\n                }\r\n                ;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Gets an opererator by its symbol\r\n         * @param {String} operator\r\n         * @returns {Object}\r\n         */\r\n        this.getOperator = function (operator) {\r\n            return operators[operator];\r\n        };\r\n\r\n        this.aliasOperator = function (o, n) {\r\n            var t = {};\r\n            var operator = operators[o];\r\n            //copy everything over to the new operator\r\n            for(var x in operator) {\r\n                t[x] = operator[x];\r\n            }\r\n            //update the symbol\r\n            t.operator = n;\r\n\r\n            this.setOperator(t);\r\n        };\r\n\r\n        /**\r\n         * Returns the list of operators. Caution! Can break parser!\r\n         * @returns {object}\r\n         */\r\n        this.getOperators = function () {\r\n            //will replace this with some cloning action in the future\r\n            return operators;\r\n        };\r\n\r\n        this.getBrackets = function () {\r\n            return brackets;\r\n        };\r\n        /*\r\n         * Preforms preprocessing on the string. Useful for making early modification before\r\n         * sending to the parser\r\n         * @param {String} e\r\n         */\r\n        var prepare_expression = function (e) {\r\n            /*\r\n             * Since variables cannot start with a number, the assumption is made that when this occurs the\r\n             * user intents for this to be a coefficient. The multiplication symbol in then added. The same goes for\r\n             * a side-by-side close and open parenthesis\r\n             */\r\n            e = String(e);\r\n            //apply preprocessors\r\n            for(var i = 0; i < preprocessors.actions.length; i++)\r\n                e = preprocessors.actions[i].call(this, e);\r\n\r\n            //e = e.split(' ').join('');//strip empty spaces\r\n            //replace multiple spaces with one space\r\n            e = e.replace(/\\s+/g, ' ');\r\n\r\n            //only even bother to check if the string contains e. This regex is painfully slow and might need a better solution. e.g. hangs on (0.06/3650))^(365)\r\n            if(/e/gi.test(e)) {\r\n                e = e.replace(/\\-*\\d+\\.*\\d*e\\+?\\-?\\d+/gi, function (x) {\r\n                    return scientificToDecimal(x);\r\n                });\r\n            }\r\n            //replace scientific numbers\r\n\r\n            //allow omission of multiplication after coefficients\r\n            e = e.replace(Settings.IMPLIED_MULTIPLICATION_REGEX, function () {\r\n                var str = arguments[4],\r\n                        group1 = arguments[1],\r\n                        group2 = arguments[2],\r\n                        start = arguments[3],\r\n                        first = str.charAt(start),\r\n                        before = '',\r\n                        d = '*';\r\n                if(!first.match(/[\\+\\-\\/\\*]/))\r\n                    before = str.charAt(start - 1);\r\n                if(before.match(/[a-z]/i))\r\n                    d = '';\r\n                return group1 + d + group2;\r\n            })\r\n                    .replace(/([a-z0-9_]+)/gi, function (match, a) {\r\n                        if(Settings.USE_MULTICHARACTER_VARS === false && !(a in functions)) {\r\n                            if(!isNaN(a))\r\n                                return a;\r\n                            return a.split('').join('*');\r\n                        }\r\n                        return a;\r\n                    })\r\n                    //allow omission of multiplication sign between brackets\r\n                    .replace(/\\)\\(/g, ')*(') || '0';\r\n            //replace x(x+a) with x*(x+a)\r\n            while(true) {\r\n                var e_org = e; //store the original\r\n                e = e.replace(/([a-z0-9_]+)(\\()|(\\))([a-z0-9]+)/gi, function (match, a, b, c, d) {\r\n                    var g1 = a || c,\r\n                            g2 = b || d;\r\n                    if(g1 in functions) //create a passthrough for functions\r\n                        return g1 + g2;\r\n                    return g1 + '*' + g2;\r\n                });\r\n                //if the original equals the replace we're done\r\n                if(e_org === e)\r\n                    break;\r\n            }\r\n            return e;\r\n        };\r\n        //delay setting of constants until Settings is ready\r\n        this.initConstants = function () {\r\n            this.CONSTANTS = {\r\n                E: new Symbol(Settings.E),\r\n                PI: new Symbol(Settings.PI)\r\n            };\r\n        };\r\n        /*\r\n         * Debugging method used to better visualize vector and arrays\r\n         * @param {object} o\r\n         * @returns {String}\r\n         */\r\n        this.pretty_print = function (o) {\r\n            if(Array.isArray(o)) {\r\n                var s = o.map(x => _.pretty_print(x)).join(', ');\r\n                if(o.type === 'vector')\r\n                    return 'vector<' + s + '>';\r\n                return '(' + s + ')';\r\n            }\r\n            return o.toString();\r\n        };\r\n        this.peekers = {\r\n            pre_operator: [],\r\n            post_operator: [],\r\n            pre_function: [],\r\n            post_function: []\r\n        };\r\n\r\n        this.callPeekers = function (name) {\r\n            if(Settings.callPeekers) {\r\n                var peekers = this.peekers[name];\r\n                //remove the first items and stringify\r\n                var args = arguments2Array(arguments).slice(1).map(stringify);\r\n                //call each one of the peekers\r\n                for(var i = 0; i < peekers.length; i++) {\r\n                    peekers[i].apply(null, args);\r\n                }\r\n            }\r\n        };\r\n        /*\r\n         * Tokenizes the string\r\n         * @param {String} e\r\n         * @returns {Token[]}\r\n         */\r\n        this.tokenize = function (e) {\r\n            //cast to String\r\n            e = String(e);\r\n            //remove multiple white spaces and spaces at beginning and end of string\r\n            e = e.trim().replace(/\\s+/g, ' ');\r\n            //remove spaces before and after brackets\r\n            for(var x in brackets) {\r\n                var regex = new RegExp(brackets[x].is_close ? '\\\\s+\\\\' + x : '\\\\' + x + '\\\\s+', 'g');\r\n                e = e.replace(regex, x);\r\n            }\r\n\r\n            var col = 0; //the column position\r\n            var L = e.length; //expression length\r\n            var lpos = 0; //marks beginning of next token\r\n            var tokens = []; //the tokens container\r\n            var scopes = [tokens]; //initiate with the tokens as the highest scope\r\n            var target = scopes[0]; //the target to which the tokens are added. This can swing up or down\r\n            var depth = 0;\r\n            var open_brackets = [];\r\n            var has_space = false; //marks if an open space character was found\r\n            var SPACE = ' ';\r\n            var EMPTY_STRING = '';\r\n            var COMMA = ',';\r\n            var MINUS = '-';\r\n            var MULT = '*';\r\n            //Possible source of bug. Review\r\n            /*\r\n             //gets the next space\r\n             var next_space = function(from) {\r\n             for(var i=from; i<L; i++) {\r\n             if(e.charAt(i) === ' ')\r\n             return i;\r\n             }\r\n             \r\n             return L; //assume the end of the string instead\r\n             };\r\n             */\r\n            /**\r\n             * Adds a scope to tokens\r\n             * @param {String} scope_type\r\n             * @param {int} column\r\n             * @returns {undefined}\r\n             */\r\n            var addScope = function (scope_type, column) {\r\n                var new_scope = []; //create a new scope\r\n                if(scope_type !== undefined) {\r\n                    new_scope.type = scope_type;\r\n                }\r\n                new_scope.column = column; //mark the column of the scope\r\n                scopes.push(new_scope); //add it to the list of scopes\r\n                target.push(new_scope); //add it to the tokens list since now it's a scope\r\n                target = new_scope; //point to it\r\n                depth++; //go down one in scope\r\n            };\r\n            /**\r\n             * Goes up in scope by one\r\n             * @returns {undefined}\r\n             */\r\n            var goUp = function () {\r\n                scopes.pop(); //remove the scope from the scopes stack\r\n                target = scopes[--depth]; //point the above scope\r\n            };\r\n            /**\r\n             * Extracts all the operators from the expression string starting at postion start_at\r\n             * @param {int} start_at\r\n             * @returns {String}\r\n             */\r\n            var get_operator_str = function (start_at) {\r\n                start_at = start_at !== undefined ? start_at : col;\r\n                //mark the end of the operator as the start since we're just going\r\n                //to be walking along the string\r\n                var end = start_at + 1;\r\n                //just keep moving along\r\n                while(e.charAt(end++) in operators) {\r\n                }\r\n                //remember that we started at one position ahead. The beginning operator is what triggered\r\n                //this function to be called in the first place. String.CharAt is zero based so we now\r\n                //have to correct two places. The initial increment + the extra++ at the end of end during\r\n                //the last iteration.\r\n                return e.substring(start_at, end - 1);\r\n            };\r\n            /**\r\n             * Breaks operator up in to several different operators as defined in operators\r\n             * @param {String} operator_str\r\n             * @returns {String[]}\r\n             */\r\n            var chunkify = function (operator_str) {\r\n                var start = col - operator_str.length; //start of operator\r\n                var _operators = [];\r\n                var operator = operator_str.charAt(0);\r\n                //grab the largest possible chunks but start at 2 since we already know\r\n                //that the first character is an operator\r\n\r\n                for(var i = 1, L = operator_str.length; i < L; i++) {\r\n                    var ch = operator_str.charAt(i);\r\n                    var o = operator + ch;\r\n                    //since the operator now is undefined then the last operator\r\n                    //was the largest possible combination.\r\n                    if(!(o in operators)) {\r\n                        _operators.push(new Token(operator, Token.OPERATOR, start + i));\r\n                        operator = ch;\r\n                    }\r\n                    else\r\n                        operator = o;//now the operator is the larger chunk\r\n                }\r\n                //add the last operator\r\n                _operators.push(new Token(operator, Token.OPERATOR, start + i));\r\n                return _operators;\r\n            };\r\n\r\n            /**\r\n             * Is used to add a token to the tokens array. Makes sure that no empty token is added\r\n             * @param {int} at\r\n             * @param {String} token\r\n             * @returns {undefined}\r\n             */\r\n            var add_token = function (at, token) {\r\n                //grab the token if we're not supplied one\r\n                if(token === undefined)\r\n                    token = e.substring(lpos, at);\r\n                //only add it if it's not an empty string\r\n                if(token in _.units)\r\n                    target.push(new Token(token, Token.UNIT, lpos));\r\n                else if(token !== '')\r\n                    target.push(new Token(token, Token.VARIABLE_OR_LITERAL, lpos));\r\n            };\r\n            /**\r\n             * Adds a function to the output\r\n             * @param {String} f\r\n             * @returns {undefined}\r\n             */\r\n            var add_function = function (f) {\r\n                target.push(new Token(f, Token.FUNCTION, lpos));\r\n            };\r\n            /**\r\n             * Tokens are found between operators so this marks the location of where the last token was found\r\n             * @param {int} position\r\n             * @returns {undefined}\r\n             */\r\n            var set_last_position = function (position) {\r\n                lpos = position + 1;\r\n            };\r\n            /**\r\n             * When a operator is found and added, especially a combo operator, then the column location\r\n             * has to be adjusted to the end of the operator\r\n             * @returns {undefined}\r\n             */\r\n            var adjust_column_position = function () {\r\n                lpos = lpos + operator_str.length - 2;\r\n                col = lpos - 1;\r\n            };\r\n            for(; col < L; col++) {\r\n                var ch = e.charAt(col);\r\n                if(ch in operators) {\r\n                    add_token(col);\r\n                    //is the last token numeric?\r\n                    var last_token_is_numeric = target[0] && isNumber(target[0]);\r\n                    //is this character multiplication?\r\n                    var is_multiplication = last_token_is_numeric && ch === MULT;\r\n                    //if we're in a new scope then go up by one but if the space\r\n                    //is right befor an operator then it makes no sense to go up in scope\r\n                    //consider sin -x. The last position = current position at the minus sign\r\n                    //this means that we're going for sin(x) -x which is wrong\r\n                    //Ignore comma since comma is still part of the existing scope.\r\n                    if(has_space && lpos < col && !(ch === COMMA || is_multiplication)) {\r\n                        has_space = false;\r\n                        goUp();\r\n                    }\r\n                    //mark the last position that a\r\n                    set_last_position(col + 1);\r\n                    var operator_str = get_operator_str(col);\r\n\r\n                    adjust_column_position();\r\n                    target.push.apply(target, chunkify(operator_str));\r\n                }\r\n                else if(ch in brackets) {\r\n                    var bracket = brackets[ch];\r\n\r\n                    if(bracket.is_open) {\r\n                        //mark the bracket\r\n                        open_brackets.push([bracket, lpos]);\r\n                        var f = e.substring(lpos, col);\r\n                        if(f in functions) {\r\n                            add_function(f);\r\n                        }\r\n                        else if(f !== '') {\r\n                            //assume multiplication\r\n                            //TODO: Add the multiplication to stack\r\n                            target.push(new Token(f, Token.VARIABLE_OR_LITERAL, lpos));\r\n                        }\r\n                        //go down one in scope\r\n                        addScope(bracket.maps_to, col);\r\n                    }\r\n                    else if(bracket.is_close) {\r\n                        //get the matching bracket\r\n                        var pair = open_brackets.pop();\r\n                        //throw errors accordingly\r\n                        //missing open bracket\r\n                        if(!pair)\r\n                            throw new ParityError('Missing open bracket for bracket at: ' + (col + 1));\r\n                        //incorrect pair\r\n                        else if(pair[0].id !== bracket.id - 1)\r\n                            throw new ParityError('Parity error');\r\n\r\n                        add_token(col);\r\n                        goUp();\r\n                    }\r\n                    set_last_position(col);\r\n                }\r\n                else if(ch === SPACE) {\r\n                    var prev = e.substring(lpos, col); //look back\r\n                    var nxt = e.charAt(col + 1); //look forward\r\n                    if(has_space) {\r\n\r\n                        if(prev in operators) {\r\n                            target.push(new Token(prev, Token.OPERATOR, col));\r\n                        }\r\n                        else {\r\n                            add_token(undefined, prev);\r\n                            //we're at the closing space\r\n                            goUp(); //go up in scope if we're at a space\r\n\r\n                            //assume multiplication if it's not an operator except for minus\r\n                            var is_operator = nxt in operators;\r\n\r\n                            if((is_operator && operators[nxt].value === MINUS) || !is_operator) {\r\n                                target.push(new Token(MULT, Token.OPERATOR, col));\r\n                            }\r\n                        }\r\n                        has_space = false; //remove the space\r\n                    }\r\n                    else {\r\n                        //we're at the closing space\r\n                        //check if it's a function\r\n                        var f = e.substring(lpos, col);\r\n\r\n                        if(f in functions) {\r\n                            //there's no need to go up in scope if the next character is an operator\r\n                            has_space = true; //mark that a space was found\r\n                            add_function(f);\r\n                            addScope();\r\n                        }\r\n                        else if(f in operators) {\r\n                            target.push(new Token(f, Token.OPERATOR, col));\r\n                        }\r\n                        else {\r\n                            add_token(undefined, f);\r\n                            //peek ahead to the next character\r\n                            var nxt = e.charAt(col + 1);\r\n\r\n                            //If it's a number then add the multiplication operator to the stack but make sure that the next character\r\n                            //is not an operator\r\n\r\n                            if(prev !== EMPTY_STRING && nxt !== EMPTY_STRING && !(prev in operators) && !(nxt in operators))\r\n                                target.push(new Token(MULT, Token.OPERATOR, col));\r\n                        }\r\n                        //Possible source of bug. Review\r\n                        /*\r\n                         //space can mean multiplication so add the symbol if the is encountered\r\n                         if(/\\d+|\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(f)) {\r\n                         var next = e.charAt(col+1);\r\n                         var next_is_operator = next in operators;\r\n                         var ns = next_space(col+1);\r\n                         var next_word = e.substring(col+1, ns);\r\n                         //the next can either be a prefix operator or no operator\r\n                         if((next_is_operator && operators[next].prefix) || !(next_is_operator || next_word in operators))\r\n                         target.push(new Token('*', Token.OPERATOR, col));\r\n                         }\r\n                         */\r\n                    }\r\n                    set_last_position(col); //mark this location\r\n                }\r\n            }\r\n            //check that all brackets were closed\r\n            if(open_brackets.length) {\r\n                var b = open_brackets.pop();\r\n                throw new ParityError('Missing closed bracket for bracket at ' + (b[1] + 1));\r\n            }\r\n            //add the last token\r\n            add_token(col);\r\n\r\n            return tokens;\r\n        };\r\n        /*\r\n         * Puts token array in Reverse Polish Notation\r\n         * @param {Token[]} tokens\r\n         * @returns {Token[]}\r\n         */\r\n        this.toRPN = function (tokens) {\r\n            var fn = tokens.type;\r\n            var l = tokens.length, i;\r\n            var output = [];\r\n            var stack = [];\r\n            var prefixes = [];\r\n            var collapse = function (target, destination) {\r\n                while(target.length)\r\n                    destination.push(target.pop());\r\n            };\r\n            //mark all the prefixes and add them to the stack\r\n            for(i = 0; i < l; i++) {\r\n                var token = tokens[i];\r\n                if(token.type !== Token.OPERATOR)\r\n                    break;\r\n                if(!token.prefix)\r\n                    throw new OperatorError('Not a prefix operator');\r\n                token.is_prefix = true;\r\n                stack.push(token);\r\n            }\r\n            //begin with remaining tokens\r\n            for(; i < l; i++) {\r\n                var e = tokens[i];\r\n                if(e.type === Token.OPERATOR) {\r\n                    var operator = e;\r\n\r\n                    //create the option for the operator being overloaded\r\n                    if(operator.overloaded) {\r\n                        var next = tokens[i + 1];\r\n                        //if it's followed by a number or variable then we assume it's not a postfix operator\r\n                        if(next && next.type === Token.VARIABLE_OR_LITERAL) {\r\n                            operator.postfix = false;\r\n                            //override the original function with the overload function\r\n                            operator.action = operator.overloadAction;\r\n                            operator.leftAssoc = operator.overloadLeftAssoc;\r\n                        }\r\n                    }\r\n\r\n                    //if the stack is not empty\r\n                    while(stack.length) {\r\n                        var last = stack[stack.length - 1];\r\n                        //if (there is an operator at the top of the operator stack with greater precedence)\r\n                        //or (the operator at the top of the operator stack has equal precedence and is left associative)) ~ wikipedia\r\n                        //the !prefixes.length makes sure that the operator on stack isn't prematurely taken fromt he stack.\r\n                        if(!(last.precedence > operator.precedence || !operator.leftAssoc && last.precedence === operator.precedence))\r\n                            break;\r\n                        output.push(stack.pop());\r\n                    }\r\n\r\n                    //change the behavior of the operator if it's a vector and we've been asked to do so\r\n                    if((fn === 'vector' || fn === 'set') && 'vectorFn' in operator)\r\n                        operator.action = operator.vectorFn;\r\n\r\n\r\n                    //if the operator is a postfix operator then we're ready to go since it belongs\r\n                    //to the preceding token. However the output cannot be empty. It must have either\r\n                    //an operator or a variable/literal\r\n                    if(operator.postfix) {\r\n                        var previous = tokens[i - 1];\r\n                        if(!previous)\r\n                            throw new OperatorError(\"Unexpected prefix operator '\" + e.value + \"'! at \" + e.column);\r\n                        else if(previous.type === Token.OPERATOR) {\r\n                            //a postfix can only be followed by a postfix\r\n                            if(!previous.postfix)\r\n                                throw new OperatorError(\"Unexpected prefix operator '\" + previous.value + \"'! at \" + previous.column);\r\n                        }\r\n                    }\r\n                    else {\r\n                        //we must be at an infix so point the operator this\r\n                        do {\r\n                            //the first one is an infix operator all others have to be prefix operators so jump to the end\r\n                            var next = tokens[i + 1]; //take a look ahead\r\n                            var next_is_operator = next ? next.type === Token.OPERATOR : false; //check if it's an operator\r\n                            if(next_is_operator) {\r\n                                //if it's not a prefix operator then it not in the right place\r\n                                if(!next.prefix) {\r\n                                    throw new OperatorError('A prefix operator was expected at ' + next.column);\r\n                                }\r\n                                //mark it as a confirmed prefix\r\n                                next.is_prefix = true;\r\n                                //add it to the prefixes\r\n                                prefixes.push(next);\r\n                                i++;\r\n                            }\r\n                        }\r\n                        while(next_is_operator)\r\n                    }\r\n\r\n                    //if it's a prefix it should be on a special stack called prefixes\r\n                    //we do this to hold on to prefixes because of left associative operators.\r\n                    //they belong to the variable/literal but if placed on either the stack\r\n                    //or output there's no way of knowing this. I might be wrong so I welcome\r\n                    //any discussion about this.\r\n\r\n                    if(operator.is_prefix) //ADD ALL EXCEPTIONS FOR ADDING TO PREFIX STACK HERE. !!!\r\n                        prefixes.push(operator);\r\n                    else\r\n                        stack.push(operator);\r\n                    //move the prefixes to the stack\r\n                    while(prefixes.length) {\r\n                        if(operator.leftAssoc || !operator.leftAssoc && prefixes[prefixes.length - 1].precedence >= operator.precedence) //revisit for commas\r\n                            stack.push(prefixes.pop());\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                else if(e.type === Token.VARIABLE_OR_LITERAL) {\r\n                    //move prefixes to stack at beginning of scope\r\n                    if(output.length === 0)\r\n                        collapse(prefixes, stack);\r\n                    //done with token\r\n                    output.push(e);\r\n                    var last_on_stack = stack[stack.length - 1];\r\n                    //then move all the prefixes to the output\r\n                    if(!last_on_stack || !last_on_stack.leftAssoc)\r\n                        collapse(prefixes, output);\r\n                }\r\n                else if(e.type === Token.FUNCTION) {\r\n                    stack.push(e);\r\n                }\r\n                else if(e.type === Token.UNIT) {\r\n                    //if it's a unit it belongs on the stack since it's tied to the previous token\r\n                    output.push(e);\r\n                }\r\n                //if it's an additonal scope then put that into RPN form\r\n                if(Array.isArray(e)) {\r\n                    output.push(this.toRPN(e));\r\n                    if(e.type)\r\n                        output.push(new Token(e.type, Token.FUNCTION, e.column)); //since it's hidden it needs no column\r\n\r\n                }\r\n            }\r\n            //collapse the remainder of the stack and prefixes to output\r\n            collapse(stack, output);\r\n            collapse(prefixes, output);\r\n\r\n            return output;\r\n        };\r\n        /*\r\n         * Parses the tokens\r\n         * @param {Tokens[]} rpn\r\n         * @param {object} substitutions\r\n         * @returns {Symbol}\r\n         */\r\n        this.parseRPN = function (rpn, substitutions) {\r\n            try {\r\n                //default substitutions\r\n                substitutions = substitutions || {};\r\n                //prepare the substitutions.\r\n                //we first parse them out as-is\r\n                for(var x in substitutions)\r\n                    substitutions[x] = _.parse(substitutions[x], {});\r\n\r\n                //Although technically constants,\r\n                //pi and e are only available when evaluating the expression so add to the subs.\r\n                //Doing this avoids rounding errors\r\n                //link e and pi\r\n                if(Settings.PARSE2NUMBER) {\r\n                    //use the value provided if the individual for some strange reason prefers this.\r\n                    //one reason could be to sub e but not pi or vice versa\r\n                    if(!('e' in substitutions))\r\n                        substitutions.e = new Symbol(Settings.E);\r\n                    if((!('pi' in substitutions)))\r\n                        substitutions.pi = new Symbol(Settings.PI);\r\n                }\r\n\r\n                var Q = [];\r\n                for(var i = 0, l = rpn.length; i < l; i++) {\r\n                    var e = rpn[i];\r\n\r\n                    //Arrays indicate a new scope so parse that out\r\n                    if(Array.isArray(e)) {\r\n                        e = this.parseRPN(e, substitutions);\r\n                    }\r\n\r\n                    if(e) {\r\n                        if(e.type === Token.OPERATOR) {\r\n                            if(e.is_prefix || e.postfix)\r\n                                //resolve the operation assocated with the prefix\r\n                                Q.push(e.operation(Q.pop()));\r\n                            else {\r\n                                var b = Q.pop();\r\n                                var a = Q.pop();\r\n                                //Throw an error if the RH value is empty. This cannot be a postfix since we already checked\r\n                                if(typeof a === 'undefined')\r\n                                    throw new OperatorError(e + ' is not a valid postfix operator at ' + e.column);\r\n\r\n                                var is_comma = e.action === 'comma';\r\n                                //convert Sets to Vectors on all operations at this point. Sets are only recognized functions or individually\r\n                                if(a instanceof Set && !is_comma)\r\n                                    a = Vector.fromSet(a);\r\n\r\n                                if(b instanceof Set && !is_comma)\r\n                                    b = Vector.fromSet(b);\r\n\r\n                                //call all the pre-operators\r\n                                this.callPeekers('pre_operator', a, b, e);\r\n\r\n                                var ans = _[e.action](a, b);\r\n\r\n                                //call all the pre-operators\r\n                                this.callPeekers('post_operator', ans, a, b, e);\r\n\r\n                                Q.push(ans);\r\n                            }\r\n                        }\r\n                        else if(e.type === Token.FUNCTION) {\r\n                            var args = Q.pop();\r\n                            var parent = args.parent; //make a note of the parent\r\n                            if(!(args instanceof Collection))\r\n                                args = Collection.create(args);\r\n                            //the return value may be a vector. If it is then we check\r\n                            //Q to see if there's another vector on the stack. If it is then\r\n                            //we check if has elements. If it does then we know that we're dealing\r\n                            //with an \"getter\" object and return the requested values\r\n\r\n                            //call the function. This is the _.callfunction method in nerdamer\r\n                            //call the function. This is the _.callfunction method in nerdamer\r\n                            var fn_name = e.value;\r\n                            var fn_args = args.getItems();\r\n\r\n                            //call the pre-function peekers\r\n                            this.callPeekers('pre_function', fn_name, fn_args);\r\n\r\n                            var ret = _.callfunction(fn_name, fn_args);\r\n\r\n                            //call the post-function peekers\r\n                            this.callPeekers('post_function', ret, fn_name, fn_args);\r\n\r\n                            var last = Q[Q.length - 1];\r\n                            var next = rpn[i + 1];\r\n                            var next_is_comma = next && next.type === Token.OPERATOR && next.value === ',';\r\n\r\n                            if(!next_is_comma && ret instanceof Vector && last && last.elements && !(last instanceof Collection)) {\r\n                                //remove the item from the queue\r\n                                var item = Q.pop();\r\n\r\n                                var getter = ret.elements[0];\r\n                                //check if it's symbolic. If so put it back and add the item to the stack\r\n                                if(!getter.isConstant()) {\r\n                                    item.getter = getter;\r\n                                    Q.push(item);\r\n                                    Q.push(ret);\r\n                                }\r\n                                else if(getter instanceof Slice) {\r\n                                    //if it's a Slice return the slice\r\n                                    Q.push(Vector.fromArray(item.elements.slice(getter.start, getter.end)));\r\n                                }\r\n                                else {\r\n                                    var index = Number(getter);\r\n                                    var il = item.elements.length;\r\n                                    //support for negative indices\r\n                                    if(index < 0)\r\n                                        index = il + index;\r\n                                    //it it's still out of bounds\r\n                                    if(index < 0 || index >= il) //index should no longer be negative since it's been reset above\r\n                                        //range error\r\n                                        throw new OutOfRangeError('Index out of range ' + (e.column + 1));\r\n\r\n                                    var element = item.elements[index];\r\n                                    //cyclic but we need to mark this for future reference\r\n                                    item.getter = index;\r\n                                    element.parent = item;\r\n\r\n                                    Q.push(element);\r\n                                }\r\n                            }\r\n                            else {\r\n                                //extend the parent reference\r\n                                if(parent)\r\n                                    ret.parent = parent;\r\n                                Q.push(ret);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            var subbed;\r\n                            var v = e.value;\r\n\r\n                            if(v in Settings.ALIASES)\r\n                                e = _.parse(Settings.ALIASES[e]);\r\n                            //wrap it in a symbol if need be\r\n                            else if(e.type === Token.VARIABLE_OR_LITERAL)\r\n                                e = new Symbol(v);\r\n                            else if(e.type === Token.UNIT) {\r\n                                e = new Symbol(v);\r\n                                e.isUnit = true;\r\n                            }\r\n\r\n                            //make substitutions\r\n                            //Always constants first. This avoids the being overridden\r\n                            if(v in _.CONSTANTS) {\r\n                                subbed = e;\r\n                                e = new Symbol(_.CONSTANTS[v]);\r\n                            }\r\n                            //next substitutions. This allows declared variable to be overridden\r\n                            //check if the values match to avoid erasing the multiplier.\r\n                            //Example:/e = 3*a. substutiting a for a will wipe out the multiplier.\r\n                            else if(v in substitutions && v !== substitutions[v].toString()) {\r\n                                subbed = e;\r\n                                e = substitutions[v].clone();\r\n                            }\r\n                            //next declare variables\r\n                            else if(v in VARS) {\r\n                                subbed = e;\r\n                                e = VARS[v].clone();\r\n                            }\r\n                            //make notation of what it was before\r\n                            if(subbed)\r\n                                e.subbed = subbed;\r\n\r\n                            Q.push(e);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var retval = Q[0];\r\n\r\n                if(['undefined', 'string', 'number'].indexOf(typeof retval) !== -1) {\r\n                    throw new UnexpectedTokenError('Unexpected token!');\r\n                }\r\n\r\n                return retval;\r\n            }\r\n            catch(error) {\r\n                var rethrowErrors = [OutOfFunctionDomainError];\r\n                // Rethrow certain errors in the same class to preserve them\r\n                rethrowErrors.forEach(function (E) {\r\n                    if(error instanceof E) {\r\n                        throw new E(error.message + ': ' + e.column);\r\n                    }\r\n                });\r\n\r\n                throw new ParseError(error.message + ': ' + e.column);\r\n            }\r\n        };\r\n        /**\r\n         * This is the method that triggers the parsing of the string. It generates a parse tree but processes\r\n         * it right away. The operator functions are called when their respective operators are reached. For instance\r\n         * + with cause this.add to be called with the left and right hand values. It works by walking along each\r\n         * character of the string and placing the operators on the stack and values on the output. When an operator\r\n         * having a lower order than the last is reached then the stack is processed from the last operator on the\r\n         * stack.\r\n         * @param {String} token\r\n         */\r\n\r\n        function Node(token) {\r\n            this.type = token.type;\r\n            this.value = token.value;\r\n            //the incoming token may already be a Node type\r\n            this.left = token.left;\r\n            this.right = token.right;\r\n        }\r\n\r\n        Node.prototype.toString = function () {\r\n            var left = this.left ? this.left.toString() + '---' : '';\r\n            var right = this.right ? '---' + this.right.toString() : '';\r\n            return left + '(' + this.value + ')' + right;\r\n        };\r\n\r\n        Node.prototype.toHTML = function (depth, indent) {\r\n            depth = depth || 0;\r\n            indent = typeof indent === 'undefined' ? 4 : indent;\r\n            var tab = function (n) {\r\n                return ' '.repeat(indent * n);\r\n            };\r\n            var html = '';\r\n            var left = this.left ? tab(depth + 1) + '<li>\\n' + this.left.toHTML(depth + 2, indent) + tab(depth + 1) + '</li> \\n' : '';\r\n            var right = this.right ? tab(depth + 1) + '<li>\\n' + this.right.toHTML(depth + 2, indent) + tab(depth + 1) + '</li>\\n' : '';\r\n            var html = tab(depth) + '<div class=\"' + this.type.toLowerCase() + '\"><span>' + this.value + '</span></div>' + tab(depth) + '\\n';\r\n            if(left || right) {\r\n                html += tab(depth) + '<ul>\\n' + left + right + tab(depth) + '</ul>\\n';\r\n            }\r\n            html += '';\r\n            return html;\r\n        };\r\n\r\n        this.tree = function (tokens) {\r\n            var Q = [];\r\n            for(var i = 0; i < tokens.length; i++) {\r\n                var e = tokens[i];\r\n                //Arrays indicate a new scope so parse that out\r\n                if(Array.isArray(e)) {\r\n                    e = this.tree(e);\r\n                    //if it's a comma then it's just arguments\r\n                    Q.push(e);\r\n                    continue;\r\n                }\r\n                if(e.type === Token.OPERATOR) {\r\n                    if(e.is_prefix || e.postfix) {\r\n                        //prefixes go to the left, postfix to the right\r\n                        var location = e.is_prefix ? 'left' : 'right';\r\n                        var last = Q.pop();\r\n                        e = new Node(e);\r\n                        e[location] = last;\r\n                        Q.push(e);\r\n                    }\r\n                    else {\r\n                        e = new Node(e);\r\n                        e.right = Q.pop();\r\n                        e.left = Q.pop();\r\n                        Q.push(e);\r\n                    }\r\n                }\r\n                else if(e.type === Token.FUNCTION) {\r\n                    e = new Node(e);\r\n                    var args = Q.pop();\r\n                    e.right = args;\r\n                    if(e.value === 'object') {\r\n                        //check if Q has a value\r\n                        var last = Q[Q.length - 1];\r\n                        if(last) {\r\n                            while(last.right) {\r\n                                last = last.right;\r\n                            }\r\n                            last.right = e;\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    Q.push(e);\r\n                }\r\n                else {\r\n                    Q.push(new Node(e));\r\n                }\r\n            }\r\n\r\n            return Q[0];\r\n        };\r\n        this.parse = function (e, substitutions) {\r\n            e = prepare_expression(e);\r\n            substitutions = substitutions || {};\r\n            //three passes but easier to debug\r\n            var tokens = this.tokenize(e);\r\n            var rpn = this.toRPN(tokens);\r\n            return this.parseRPN(rpn, substitutions);\r\n        };\r\n        /**\r\n         * TODO: Switch to Parser.tokenize for this method\r\n         * Reads a string into an array of Symbols and operators\r\n         * @param {String} expression_string\r\n         * @returns {Array}\r\n         */\r\n        this.toObject = function (expression_string) {\r\n            var objectify = function (tokens) {\r\n                var output = [];\r\n                for(var i = 0, l = tokens.length; i < l; i++) {\r\n                    var token = tokens[i];\r\n                    var v = token.value;\r\n                    if(token.type === Token.VARIABLE_OR_LITERAL) {\r\n                        output.push(new Symbol(v));\r\n                    }\r\n                    else if(token.type === Token.FUNCTION) {\r\n                        //jump ahead since the next object are the arguments\r\n                        i++;\r\n                        //create a symbolic function and stick it on output\r\n                        var f = _.symfunction(v, objectify(tokens[i]));\r\n                        f.isConversion = true;\r\n                        output.push(f);\r\n                    }\r\n                    else if(token.type === Token.OPERATOR) {\r\n                        output.push(v);\r\n                    }\r\n                    else {\r\n                        output.push(objectify(token));\r\n                    }\r\n                }\r\n\r\n                return output;\r\n            };\r\n            return objectify(_.tokenize(expression_string));\r\n        };\r\n\r\n        // A helper method for toTeX\r\n        var chunkAtCommas = function (arr) {\r\n            var j, k = 0, chunks = [[]];\r\n            for(var j = 0, l = arr.length; j < l; j++) {\r\n                if(arr[j] === ',') {\r\n                    k++;\r\n                    chunks[k] = [];\r\n                }\r\n                else {\r\n                    chunks[k].push(arr[j]);\r\n                }\r\n            }\r\n            return chunks;\r\n        };\r\n\r\n        // Helper method for toTeX\r\n        var rem_brackets = function (str) {\r\n            return str.replace(/^\\\\left\\((.+)\\\\right\\)$/g, function (str, a) {\r\n                if(a)\r\n                    return a;\r\n                return str;\r\n            });\r\n        };\r\n\r\n        var remove_redundant_powers = function (arr) {\r\n            // The filtered array\r\n            var narr = [];\r\n\r\n            while(arr.length) {\r\n                // Remove the element from the front\r\n                var e = arr.shift();\r\n                var next = arr[0];\r\n                var next_is_array = isArray(next);\r\n                var next_is_minus = next === '-';\r\n\r\n                // Remove redundant plusses \r\n                if(e === '^') {\r\n                    if(next === '+') {\r\n                        arr.shift();\r\n                    }\r\n                    else if(next_is_array && next[0] === '+') {\r\n                        next.shift();\r\n                    }\r\n\r\n                    // Remove redundant parentheses\r\n                    if(next_is_array && next.length === 1) {\r\n                        arr.unshift(arr.shift()[0]);\r\n                    }\r\n                }\r\n\r\n                // Check if it's a negative power\r\n                if(e === '^' && (next_is_array && next[0] === '-' || next_is_minus)) {\r\n                    // If so:\r\n                    // - Remove it from the new array, place a one and a division sign in that array and put it back\r\n                    var last = narr.pop();\r\n                    // Check if it's something multiplied by\r\n                    var before = narr[narr.length - 1];\r\n                    var before_last = '1';\r\n\r\n                    if(before === '*') {\r\n                        narr.pop();\r\n                        // For simplicity we just pop it. \r\n                        before_last = narr.pop();\r\n                    }\r\n                    // Implied multiplication\r\n                    else if(isArray(before)) {\r\n                        before_last = narr.pop();\r\n                    }\r\n\r\n                    narr.push(before_last, '/', last, e);\r\n\r\n                    // Remove the negative sign from the power \r\n                    if(next_is_array) {\r\n                        next.shift();\r\n                    }\r\n                    else {\r\n                        arr.shift();\r\n                    }\r\n\r\n                    // Remove it from the array so we don't end up with redundant parentheses if we can\r\n                    if(next_is_array && next.length === 1) {\r\n                        narr.push(arr.shift()[0]);\r\n                    }\r\n                }\r\n                else {\r\n                    narr.push(e);\r\n                }\r\n            }\r\n\r\n            return narr;\r\n        };\r\n        /*\r\n         * Convert expression or object to LaTeX\r\n         * @param {String} expression_or_obj\r\n         * @param {object} opt\r\n         * @returns {String}\r\n         */\r\n        this.toTeX = function (expression_or_obj, opt) {\r\n            opt = opt || {};\r\n            // Add decimal option as per issue #579. Consider passing an object to Latex.latex as option instead of string\r\n            var decimals = opt.decimals === true ? 'decimals' : undefined;\r\n\r\n            var obj = typeof expression_or_obj === 'string' ? this.toObject(expression_or_obj) : expression_or_obj,\r\n                    TeX = [],\r\n                    cdot = typeof opt.cdot === 'undefined' ? '\\\\cdot' : opt.cdot; //set omit cdot to true by default\r\n\r\n            // Remove negative powers as per issue #570\r\n            obj = remove_redundant_powers(obj);\r\n\r\n            if(isArray(obj)) {\r\n                var nobj = [], a, b;\r\n                //first handle ^\r\n                for(var i = 0; i < obj.length; i++) {\r\n                    a = obj[i];\r\n\r\n                    if(obj[i + 1] === '^') {\r\n                        b = obj[i + 2];\r\n                        nobj.push(LaTeX.braces(this.toTeX([a])) + '^' + LaTeX.braces(this.toTeX([b])));\r\n                        i += 2;\r\n                    }\r\n                    else {\r\n                        nobj.push(a);\r\n                    }\r\n                }\r\n                obj = nobj;\r\n            }\r\n\r\n            for(var i = 0, l = obj.length; i < l; i++) {\r\n                var e = obj[i];\r\n\r\n                // Convert * to cdot\r\n                if(e === '*') {\r\n                    e = cdot;\r\n                }\r\n\r\n                if(isSymbol(e)) {\r\n                    if(e.group === FN) {\r\n                        var fname = e.fname, f;\r\n\r\n                        if(fname === SQRT)\r\n                            f = '\\\\sqrt' + LaTeX.braces(this.toTeX(e.args));\r\n                        else if(fname === ABS)\r\n                            f = LaTeX.brackets(this.toTeX(e.args), 'abs');\r\n                        else if(fname === PARENTHESIS)\r\n                            f = LaTeX.brackets(this.toTeX(e.args), 'parens');\r\n                        else if(fname === Settings.LOG10) {\r\n                            f = '\\\\' + Settings.LOG10_LATEX + '\\\\left( ' + this.toTeX(e.args) + '\\\\right)';\r\n                        }\r\n                        else if(fname === 'integrate') {\r\n                            /* Retrive [Expression, x] */\r\n                            var chunks = chunkAtCommas(e.args);\r\n                            /* Build TeX */\r\n                            var expr = LaTeX.braces(this.toTeX(chunks[0])),\r\n                                    dx = this.toTeX(chunks[1]);\r\n                            f = '\\\\int ' + expr + '\\\\, d' + dx;\r\n                        }\r\n                        else if(fname === 'defint') {\r\n                            var chunks = chunkAtCommas(e.args),\r\n                                    expr = LaTeX.braces(this.toTeX(chunks[0])),\r\n                                    dx = this.toTeX(chunks[3]),\r\n                                    lb = this.toTeX(chunks[1]),\r\n                                    ub = this.toTeX(chunks[2]);\r\n                            f = '\\\\int\\\\limits_{' + lb + '}^{' + ub + '} ' + expr + '\\\\, d' + dx;\r\n\r\n                        }\r\n                        else if(fname === 'diff') {\r\n                            var chunks = chunkAtCommas(e.args);\r\n                            var dx = '', expr = LaTeX.braces(this.toTeX(chunks[0]));\r\n                            /* Handle cases: one argument provided, we need to guess the variable, and assume n = 1 */\r\n                            if(chunks.length === 1) {\r\n                                var vars = [];\r\n                                for(j = 0; j < chunks[0].length; j++) {\r\n                                    if(chunks[0][j].group === 3) {\r\n                                        vars.push(chunks[0][j].value);\r\n                                    }\r\n                                }\r\n                                vars.sort();\r\n                                dx = vars.length > 0 ? ('\\\\frac{d}{d ' + vars[0] + '}') : '\\\\frac{d}{d x}';\r\n                            }\r\n                            /* If two arguments, we have expression and variable, we assume n = 1 */\r\n                            else if(chunks.length === 2) {\r\n                                dx = '\\\\frac{d}{d ' + chunks[1] + '}';\r\n                            }\r\n                            /* If we have more than 2 arguments, we assume we've got everything */\r\n                            else {\r\n                                dx = '\\\\frac{d^{' + chunks[2] + '}}{d ' + this.toTeX(chunks[1]) + '^{' + chunks[2] + '}}';\r\n                            }\r\n\r\n                            f = dx + '\\\\left(' + expr + '\\\\right)';\r\n\r\n                        }\r\n                        else if(fname === 'sum' || fname === 'product') {\r\n                            // Split e.args into 4 parts based on locations of , symbols.\r\n                            var argSplit = [[], [], [], []], j = 0, i;\r\n                            for(i = 0; i < e.args.length; i++) {\r\n                                if(e.args[i] === ',') {\r\n                                    j++;\r\n                                    continue;\r\n                                }\r\n                                argSplit[j].push(e.args[i]);\r\n                            }\r\n                            // Then build TeX string.\r\n                            f = (fname === 'sum' ? '\\\\sum_' : '\\\\prod_') + LaTeX.braces(this.toTeX(argSplit[1]) + ' = ' + this.toTeX(argSplit[2]));\r\n                            f += '^' + LaTeX.braces(this.toTeX(argSplit[3])) + LaTeX.braces(this.toTeX(argSplit[0]));\r\n                        }\r\n                        else if(fname === 'limit') {\r\n                            var args = chunkAtCommas(e.args).map(function (x) {\r\n                                if(Array.isArray(x))\r\n                                    return _.toTeX(x.join(''));\r\n                                return _.toTeX(String(x));\r\n                            });\r\n                            f = '\\\\lim_' + LaTeX.braces(args[1] + '\\\\to ' + args[2]) + ' ' + LaTeX.braces(args[0]);\r\n                        }\r\n                        else if(fname === FACTORIAL || fname === DOUBLEFACTORIAL)\r\n                            f = this.toTeX(e.args) + (fname === FACTORIAL ? '!' : '!!');\r\n                        else {\r\n\r\n                            f = LaTeX.latex(e, decimals);\r\n                            //f = '\\\\mathrm'+LaTeX.braces(fname.replace(/_/g, '\\\\_')) + LaTeX.brackets(this.toTeX(e.args), 'parens');\r\n                        }\r\n\r\n                        TeX.push(f);\r\n                    }\r\n                    else {\r\n                        TeX.push(LaTeX.latex(e, decimals));\r\n                    }\r\n                }\r\n                else if(isArray(e)) {\r\n                    TeX.push(LaTeX.brackets(this.toTeX(e)));\r\n                }\r\n                else {\r\n                    if(e === '/')\r\n                        TeX.push(LaTeX.frac(rem_brackets(TeX.pop()), rem_brackets(this.toTeX([obj[++i]]))));\r\n                    else\r\n                        TeX.push(e);\r\n                }\r\n            }\r\n\r\n            return TeX.join(' ');\r\n        };\r\n\r\n//Parser.functions ==============================================================\r\n        /* Although parens is not a \"real\" function it is important in some cases when the\r\n         * symbol must carry parenthesis. Once set you don't have to worry about it anymore\r\n         * as the parser will get rid of it at the first opportunity\r\n         */\r\n        function parens(symbol) {\r\n            if(Settings.PARSE2NUMBER) {\r\n                return symbol;\r\n            }\r\n            return _.symfunction('parens', [symbol]);\r\n        }\r\n\r\n        function abs(symbol) {\r\n\r\n            //|-| = \r\n            if(symbol.isInfinity) {\r\n                return Symbol.infinity();\r\n            }\r\n            if(symbol.multiplier.lessThan(0))\r\n                symbol.multiplier.negate();\r\n\r\n            if(symbol.isImaginary()) {\r\n                var re = symbol.realpart();\r\n                var im = symbol.imagpart();\r\n                if(re.isConstant() && im.isConstant())\r\n                    return sqrt(_.add(_.pow(re, new Symbol(2)), _.pow(im, new Symbol(2))));\r\n            }\r\n            else if(isNumericSymbol(symbol) || even(symbol.power)) {\r\n                return symbol;\r\n            }\r\n\r\n            if(symbol.isComposite()) {\r\n                var ms = [];\r\n                symbol.each(function (x) {\r\n                    ms.push(x.multiplier);\r\n                });\r\n                var gcd = Math2.QGCD.apply(null, ms);\r\n                if(gcd.lessThan(0)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(new Frac(-1));\r\n                    symbol.distributeMultiplier();\r\n                }\r\n            }\r\n\r\n            //convert |n*x| to n*|x|\r\n            var m = _.parse(symbol.multiplier);\r\n            symbol.toUnitMultiplier();\r\n\r\n            return _.multiply(m, _.symfunction(ABS, [symbol]));\r\n        }\r\n        /**\r\n         * The factorial function\r\n         * @param {Symbol} symbol\r\n         * @return {Symbol}\r\n         */\r\n        function factorial(symbol) {\r\n            var retval;\r\n            if(isVector(symbol)) {\r\n                var V = new Vector();\r\n                symbol.each(function (x, i) {\r\n                    //i start at one.\r\n                    V.set(i - 1, factorial(x));\r\n                });\r\n                return V;\r\n            }\r\n            if(isMatrix(symbol)) {\r\n                var M = new Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    //i start at one.\r\n                    M.set(i, j, factorial(x));\r\n                });\r\n                return M;\r\n            }\r\n            if(Settings.PARSE2NUMBER && symbol.isConstant()) {\r\n                if(isInt(symbol)) {\r\n                    retval = Math2.bigfactorial(symbol);\r\n                }\r\n                else {\r\n                    retval = Math2.gamma(symbol.multiplier.add(new Frac(1)).toDecimal());\r\n                }\r\n\r\n                retval = bigConvert(retval);\r\n                return retval;\r\n            }\r\n            else if(symbol.isConstant()) {\r\n                var den = symbol.getDenom();\r\n                if(den.equals(2)) {\r\n                    var num = symbol.getNum();\r\n                    var a, b, c, n;\r\n\r\n                    if(!symbol.multiplier.isNegative()) {\r\n                        n = _.add(num, new Symbol(1)).multiplier.divide(new Frac(2));\r\n                        a = Math2.bigfactorial(new Frac(2).multiply(n));\r\n                        b = _.pow(new Symbol(4), new Symbol(n)).multiplier.multiply(Math2.bigfactorial(n));\r\n                    }\r\n                    else {\r\n                        n = _.subtract(num.negate(), new Symbol(1)).multiplier.divide(new Frac(2));\r\n                        a = _.pow(new Symbol(-4), new Symbol(n)).multiplier.multiply(Math2.bigfactorial(n));\r\n                        b = Math2.bigfactorial(new Frac(2).multiply(n));\r\n                    }\r\n                    c = a.divide(b);\r\n                    return _.multiply(_.parse('sqrt(pi)'), new Symbol(c));\r\n                }\r\n            }\r\n            return _.symfunction(FACTORIAL, [symbol]);\r\n        }\r\n        ;\r\n        /**\r\n         * Returns the continued fraction of a number\r\n         * @param {Symbol} symbol\r\n         * @param {Symbol} n\r\n         * @returns {Symbol}\r\n         */\r\n        function continued_fraction(symbol, n) {\r\n            var _symbol = evaluate(symbol);\r\n            if(_symbol.isConstant()) {\r\n                var cf = Math2.continuedFraction(_symbol, n);\r\n                //convert the fractions array to a new Vector\r\n                var fractions = Vector.fromArray(cf.fractions.map(function (x) {\r\n                    return new Symbol(x);\r\n                }));\r\n                return Vector.fromArray([new Symbol(cf.sign), new Symbol(cf.whole), fractions]);\r\n            }\r\n            return _.symfunction('continued_fraction', arguments);\r\n        }\r\n        /**\r\n         * Returns the error function\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function erf(symbol) {\r\n            var _symbol = evaluate(symbol);\r\n\r\n            if(_symbol.isConstant()) {\r\n                return Math2.erf(_symbol);\r\n            }\r\n            else if(_symbol.isImaginary()) {\r\n                return complex.erf(symbol);\r\n            }\r\n            return _.symfunction('erf', arguments);\r\n        }\r\n        ;\r\n        /**\r\n         * The mod function\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Symbol}\r\n         */\r\n        function mod(symbol1, symbol2) {\r\n            if(symbol1.isConstant() && symbol2.isConstant()) {\r\n                var retval = new Symbol(1);\r\n                retval.multiplier = retval.multiplier.multiply(symbol1.multiplier.mod(symbol2.multiplier));\r\n                return retval;\r\n            }\r\n            //try to see if division has remainder of zero\r\n            var r = _.divide(symbol1.clone(), symbol2.clone());\r\n            if(isInt(r))\r\n                return new Symbol(0);\r\n            return _.symfunction('mod', [symbol1, symbol2]);\r\n        }\r\n        /**\r\n         * A branghing function\r\n         * @param {Boolean} condition\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        function IF(condition, a, b) {\r\n            if(typeof condition !== 'boolean')\r\n                if(isNumericSymbol(condition))\r\n                    condition = !!Number(condition);\r\n            if(condition)\r\n                return a;\r\n            return b;\r\n        }\r\n        /**\r\n         *\r\n         * @param {Matrix|Vector|Set|Collection} obj\r\n         * @param {Symbol} item\r\n         * @returns {Boolean}\r\n         */\r\n        function is_in(obj, item) {\r\n            if(isMatrix(obj)) {\r\n                for(var i = 0, l = obj.rows(); i < l; i++) {\r\n                    for(var j = 0, l2 = obj.cols(); j < l2; j++) {\r\n                        var element = obj.elements[i][j];\r\n                        if(element.equals(item))\r\n                            return new Symbol(1);\r\n                    }\r\n                }\r\n            }\r\n            else if(obj.elements) {\r\n                for(var i = 0, l = obj.elements.length; i < l; i++) {\r\n                    if(obj.elements[i].equals(item))\r\n                        return new Symbol(1);\r\n                }\r\n            }\r\n\r\n            return new Symbol(0);\r\n        }\r\n\r\n        /**\r\n         * A symbolic extension for sinc\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function sinc(symbol) {\r\n            if(Settings.PARSE2NUMBER) {\r\n                if(symbol.isConstant()) {\r\n                    return new Symbol(Math2.sinc(symbol));\r\n                }\r\n                return _.parse(format('sin({0})/({0})', symbol));\r\n            }\r\n            return _.symfunction('sinc', [symbol]);\r\n        }\r\n\r\n        /**\r\n         * A symbolic extension for exp. This will auto-convert all instances of exp(x) to e^x.\r\n         * Thanks @ Happypig375\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function exp(symbol) {\r\n            if(symbol.fname === Settings.LOG && symbol.isLinear()) {\r\n                return _.pow(symbol.args[0], Symbol.create(symbol.multiplier));\r\n            }\r\n            return _.parse(format('e^({0})', symbol));\r\n        }\r\n\r\n        /**\r\n         * Converts value degrees to radians\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function radians(symbol) {\r\n            return _.parse(format('({0})*pi/180', symbol));\r\n        }\r\n\r\n        /**\r\n         * Converts value from radians to degrees\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function degrees(symbol) {\r\n            return _.parse(format('({0})*180/pi', symbol));\r\n        }\r\n\r\n        function nroots(symbol) {\r\n            var a, b;\r\n            if(symbol.group === FN && symbol.fname === '') {\r\n                a = Symbol.unwrapPARENS(_.parse(symbol).toLinear());\r\n                b = _.parse(symbol.power);\r\n            }\r\n            else if(symbol.group === P) {\r\n                a = _.parse(symbol.value);\r\n                b = _.parse(symbol.power);\r\n            }\r\n\r\n            if(a && b && a.group === N && b.group === N) {\r\n                var _roots = [];\r\n                var parts = Symbol.toPolarFormArray(symbol);\r\n                var r = _.parse(a).abs().toString();\r\n                //https://en.wikipedia.org/wiki/De_Moivre%27s_formula\r\n                var x = arg(a).toString();\r\n                var n = b.multiplier.den.toString();\r\n                var p = b.multiplier.num.toString();\r\n\r\n                var formula = \"(({0})^({1})*(cos({3})+({2})*sin({3})))^({4})\";\r\n                for(var i = 0; i < n; i++) {\r\n                    var t = evaluate(_.parse(format(\"(({0})+2*pi*({1}))/({2})\", x, i, n))).multiplier.toDecimal();\r\n                    _roots.push(evaluate(_.parse(format(formula, r, n, Settings.IMAGINARY, t, p))));\r\n                }\r\n                return Vector.fromArray(_roots);\r\n            }\r\n            else if(symbol.isConstant(true)) {\r\n                var sign = symbol.sign();\r\n                var x = evaluate(symbol.abs());\r\n                var root = _.sqrt(x);\r\n\r\n                var _roots = [root.clone(), root.negate()];\r\n\r\n                if(sign < 0)\r\n                    _roots = _roots.map(function (x) {\r\n                        return _.multiply(x, Symbol.imaginary());\r\n                    });\r\n            }\r\n            else {\r\n                _roots = [_.parse(symbol)];\r\n            }\r\n\r\n            return Vector.fromArray(_roots);\r\n        }\r\n\r\n        /**\r\n         * Rationalizes a symbol\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function rationalize(symbol) {\r\n            if(symbol.isComposite()) {\r\n                var retval = new Symbol(0);\r\n                var num, den, retnum, retden, a, b, n, d;\r\n                symbol.each(function (x) {\r\n                    num = x.getNum();\r\n                    den = x.getDenom();\r\n                    retnum = retval.getNum();\r\n                    retden = retval.getDenom();\r\n                    a = _.multiply(den, retnum);\r\n                    b = _.multiply(num, retden);\r\n                    n = _.expand(_.add(a, b));\r\n                    d = _.multiply(retden, den);\r\n                    retval = _.divide(n, d);\r\n                }, true);\r\n\r\n                return retval;\r\n            }\r\n            return symbol;\r\n        }\r\n\r\n        /**\r\n         * The square root function\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function sqrt(symbol) {\r\n            if(!isSymbol(symbol)) {\r\n                symbol = _.parse(symbol);\r\n            }\r\n            \r\n            // Exit early for EX\r\n            if(symbol.group === EX) {\r\n                return _.symfunction(SQRT, [symbol]);\r\n            }\r\n\r\n            if(symbol.fname === '' && symbol.power.equals(1))\r\n                symbol = symbol.args[0];\r\n\r\n            var is_negative = symbol.multiplier.sign() < 0;\r\n\r\n            if(Settings.PARSE2NUMBER) {\r\n                if(symbol.isConstant() && !is_negative) {\r\n                    return new Symbol(bigDec.sqrt(symbol.multiplier.toDecimal()));\r\n                }\r\n                else if(symbol.isImaginary()) {\r\n                    return complex.sqrt(symbol);\r\n                }\r\n                else if(symbol.group === S) {\r\n                    return _.symfunction('sqrt', [symbol]);\r\n                }\r\n            }\r\n\r\n            var img, retval,\r\n                    isConstant = symbol.isConstant();\r\n\r\n            if(symbol.group === CB && symbol.isLinear()) {\r\n                var m = sqrt(Symbol(symbol.multiplier));\r\n                for(var s in symbol.symbols) {\r\n                    var x = symbol.symbols[s];\r\n                    m = _.multiply(m, sqrt(x));\r\n                }\r\n\r\n                retval = m;\r\n            }\r\n            //if the symbol is already sqrt then it's that symbol^(1/4) and we can unwrap it\r\n            else if(symbol.fname === SQRT) {\r\n                var s = symbol.args[0];\r\n                var ms = symbol.multiplier;\r\n                s.setPower(symbol.power.multiply(new Frac(0.25)));\r\n                retval = s;\r\n                //grab the multiplier\r\n                if(!ms.equals(1))\r\n                    retval = _.multiply(sqrt(_.parse(ms)), retval);\r\n            }\r\n            //if the symbol is a fraction then we don't keep can unwrap it. For instance\r\n            //no need to keep sqrt(x^(1/3))\r\n            else if(!symbol.power.isInteger()) {\r\n                symbol.setPower(symbol.power.multiply(new Frac(0.5)));\r\n                retval = symbol;\r\n            }\r\n            else if(symbol.multiplier < 0 && symbol.group === S) {\r\n                var a = _.parse(symbol.multiplier).negate();\r\n                var b = _.parse(symbol).toUnitMultiplier().negate();\r\n                retval = _.multiply(_.symfunction(Settings.SQRT, [b]), sqrt(a));\r\n            }\r\n            else {\r\n\r\n                //Related to issue #401. Since sqrt(a)*sqrt(b^-1) relates in issues, we'll change the form\r\n                //to sqrt(a)*sqrt(b)^1 for better simplification\r\n                //the sign of the power\r\n                var sign = symbol.power.sign();\r\n                //remove the sign\r\n                symbol.power = symbol.power.abs();\r\n\r\n                //if the symbols is imagary then we place in the imaginary part. We'll return it\r\n                //as a product\r\n                if(isConstant && symbol.multiplier.lessThan(0)) {\r\n                    img = Symbol.imaginary();\r\n                    symbol.multiplier = symbol.multiplier.abs();\r\n                }\r\n\r\n                var q = symbol.multiplier.toDecimal(),\r\n                        qa = Math.abs(q),\r\n                        t = Math.sqrt(qa);\r\n\r\n                var m;\r\n                //it's a perfect square so take the square\r\n                if(isInt(t)) {\r\n                    m = new Symbol(t);\r\n                }\r\n                else if(isInt(q)) {\r\n                    var factors = Math2.ifactor(q);\r\n                    var tw = 1;\r\n                    for(var x in factors) {\r\n                        var n = factors[x],\r\n                                nn = (n - (n % 2)); //get out the whole numbers\r\n                        if(nn) { //if there is a whole number ...\r\n                            var w = Math.pow(x, nn);\r\n                            tw *= Math.pow(x, nn / 2); //add to total wholes\r\n                            q /= w; //reduce the number by the wholes\r\n                        }\r\n                    }\r\n                    m = _.multiply(_.symfunction(SQRT, [new Symbol(q)]), new Symbol(tw));\r\n                }\r\n                else {\r\n                    //reduce the numerator and denominator using prime factorization\r\n                    var c = [new Symbol(symbol.multiplier.num), new Symbol(symbol.multiplier.den)];\r\n                    var r = [new Symbol(1), new Symbol(1)];\r\n                    var sq = [new Symbol(1), new Symbol(1)];\r\n                    for(var i = 0; i < 2; i++) {\r\n                        var n = c[i];\r\n                        //get the prime factors and loop through each.\r\n                        pfactor(n).each(function (x) {\r\n                            x = Symbol.unwrapPARENS(x);\r\n                            var b = x.clone().toLinear();\r\n                            var p = Number(x.power);\r\n                            //We'll consider it safe to use the native Number since 2^1000 is already a pretty huge number\r\n                            var rem = p % 2; //get the remainder. This will be 1 if 3 since sqrt(n^2) = n where n is positive\r\n                            var w = (p - rem) / 2; //get the whole numbers of n/2\r\n                            r[i] = _.multiply(r[i], _.pow(b, new Symbol(w)));\r\n                            sq[i] = _.multiply(sq[i], sqrt(_.pow(b, new Symbol(rem))));\r\n                        });\r\n                    }\r\n                    m = _.divide(_.multiply(r[0], sq[0]), _.multiply(r[1], sq[1]));\r\n                }\r\n\r\n\r\n                //strip the multiplier since we already took the sqrt\r\n                symbol = symbol.toUnitMultiplier(true);\r\n                //if the symbol is one just return one and not the sqrt function\r\n                if(symbol.isOne()) {\r\n                    retval = symbol;\r\n                }\r\n                else if(even(symbol.power.toString())) {\r\n                    //just raise it to the 1/2\r\n                    retval = _.pow(symbol.clone(), new Symbol(0.5));\r\n                }\r\n                else {\r\n                    retval = _.symfunction(SQRT, [symbol]);\r\n                }\r\n\r\n                //put back the sign that was removed earlier\r\n                if(sign < 0)\r\n                    retval.power.negate();\r\n\r\n                if(m)\r\n                    retval = _.multiply(m, retval);\r\n\r\n                if(img)\r\n                    retval = _.multiply(img, retval);\r\n            }\r\n\r\n            if(is_negative && Settings.PARSE2NUMBER)\r\n                return _.parse(retval);\r\n\r\n            return retval;\r\n        }\r\n\r\n        /**\r\n         * The cube root function\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function cbrt(symbol) {\r\n            if(!symbol.isConstant(true)) {\r\n                var retval;\r\n\r\n                var n = symbol.power / 3;\r\n                //take the cube root of the multplier\r\n                var m = _.pow(_.parse(symbol.multiplier), new Symbol(1 / 3));\r\n                //strip the multiplier\r\n                var sym = symbol.toUnitMultiplier();\r\n\r\n                //simplify the power\r\n                if(isInt(n)) {\r\n                    retval = _.pow(sym.toLinear(), _.parse(n));\r\n                }\r\n                else {\r\n                    if(sym.group === CB) {\r\n                        retval = new Symbol(1);\r\n                        sym.each(function (x) {\r\n                            retval = _.multiply(retval, cbrt(x));\r\n                        });\r\n                    }\r\n                    else {\r\n                        retval = _.symfunction('cbrt', [sym]);\r\n                    }\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n            return nthroot(symbol, new Symbol(3));\r\n        }\r\n\r\n        function scientific(symbol, sigfigs) {\r\n            //Just set the flag and keep it moving. Symbol.toString will deal with how to\r\n            //display this\r\n            symbol.scientific = sigfigs || 10;\r\n            return symbol;\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Symbol} num - the number being raised\r\n         * @param {Symbol} p - the exponent\r\n         * @param {type} prec - the precision wanted\r\n         * @param {bool} asbig - true if a bigDecimal is wanted\r\n         * @returns {Symbol}\r\n         */\r\n        function nthroot(num, p, prec, asbig) {\r\n            //clone p and convert to a number if possible\r\n            p = evaluate(_.parse(p));\r\n\r\n            //cannot calculate if p = 0. nthroot(0, 0) => 0^(1/0) => undefined\r\n            if(p.equals(0)) {\r\n                throw new UndefinedError('Unable to calculate nthroots of zero');\r\n            }\r\n\r\n            //Stop computation if it negative and even since we have an imaginary result\r\n            if(num < 0 && even(p))\r\n                throw new Error('Cannot calculate nthroot of negative number for even powers');\r\n\r\n            //return non numeric values unevaluated\r\n            if(!num.isConstant(true)) {\r\n                return _.symfunction('nthroot', arguments);\r\n            }\r\n\r\n            //evaluate numeric values\r\n            if(num.group !== N) {\r\n                num = evaluate(num);\r\n            }\r\n\r\n            //default is to return a big value\r\n            if(typeof asbig === 'undefined')\r\n                asbig = true;\r\n\r\n            prec = prec || 25;\r\n\r\n            var sign = num.sign();\r\n            var retval;\r\n            var ans;\r\n\r\n            if(sign < 0) {\r\n                num = abs(num); //remove the sign\r\n            }\r\n\r\n            if(isInt(num) && p.isConstant()) {\r\n\r\n                if(num < 18446744073709551616) {\r\n                    //2^64\r\n                    ans = Frac.create(Math.pow(num, 1 / p));\r\n                }\r\n                else {\r\n                    ans = Math2.nthroot(num, p);\r\n                }\r\n\r\n                var retval;\r\n                if(asbig) {\r\n                    retval = new Symbol(ans);\r\n                }\r\n                retval = new Symbol(ans.toDecimal(prec));\r\n\r\n                return _.multiply(new Symbol(sign), retval);\r\n            }\r\n        }\r\n\r\n        function pfactor(symbol) {\r\n            //Fix issue #458 | nerdamer(\"sqrt(1-(3.3333333550520926e-7)^2)\").evaluate().text()\r\n            //More Big Number issues >:(\r\n            if(symbol.greaterThan(9.999999999998891e+41) || symbol.equals(-1))\r\n                return symbol;\r\n            //Fix issue #298\r\n            if(symbol.equals(Math.PI))\r\n                return new Symbol(Math.PI);\r\n            //evaluate the symbol to merge constants\r\n            symbol = evaluate(symbol.clone());\r\n\r\n            if(symbol.isConstant()) {\r\n                var retval = new Symbol(1);\r\n                var m = symbol.toString();\r\n                if(isInt(m)) {\r\n                    var factors = Math2.ifactor(m);\r\n                    for(var factor in factors) {\r\n                        var p = factors[factor];\r\n                        retval = _.multiply(retval, _.symfunction('parens', [new Symbol(factor).setPower(new Frac(p))]));\r\n                    }\r\n                }\r\n                else {\r\n                    var n = pfactor(new Symbol(symbol.multiplier.num));\r\n                    var d = pfactor(new Symbol(symbol.multiplier.den));\r\n                    retval = _.multiply(_.symfunction('parens', [n]), _.symfunction('parens', [d]).invert());\r\n                }\r\n            }\r\n            else\r\n                retval = _.symfunction('pfactor', arguments);\r\n            return retval;\r\n        }\r\n\r\n        /**\r\n         * Get's the real part of a complex number. Return number if real\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function realpart(symbol) {\r\n            return symbol.realpart();\r\n        }\r\n\r\n        /**\r\n         * Get's the imaginary part of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function imagpart(symbol) {\r\n            return symbol.imagpart();\r\n        }\r\n\r\n        /**\r\n         * Computes the conjugate of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function conjugate(symbol) {\r\n            var re = symbol.realpart();\r\n            var im = symbol.imagpart();\r\n            return _.add(re, _.multiply(im.negate(), Symbol.imaginary()));\r\n        }\r\n\r\n        /**\r\n         * Returns the arugment of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function arg(symbol) {\r\n            var re = symbol.realpart();\r\n            var im = symbol.imagpart();\r\n            if(re.isConstant() && im.isConstant())\r\n                return new Symbol(Math.atan2(im, re));\r\n            return _.symfunction('atan2', [im, re]);\r\n        }\r\n\r\n        /**\r\n         * Returns the arugment of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function arg(symbol) {\r\n            var re = symbol.realpart();\r\n            var im = symbol.imagpart();\r\n            if(re.isConstant() && im.isConstant()) {\r\n                if(im.equals(0) && re.equals(-1)) {\r\n                    return _.parse('pi');\r\n                }\r\n                else if(im.equals(1) && re.equals(0)) {\r\n                    return _.parse('pi/2');\r\n                }\r\n                else if(im.equals(1) && re.equals(1)) {\r\n                    return _.parse('pi/4');\r\n                }\r\n                return new Symbol(Math.atan2(im, re));\r\n            }\r\n            return _.symfunction('atan2', [im, re]);\r\n        }\r\n\r\n        /**\r\n         * Returns the polarform of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function polarform(symbol) {\r\n            var p, r, e, theta;\r\n            p = Symbol.toPolarFormArray(symbol);\r\n            theta = p[1];\r\n            r = p[0];\r\n            e = _.parse(format('e^({0}*({1}))', Settings.IMAGINARY, theta));\r\n            return _.multiply(r, e);\r\n        }\r\n\r\n        /**\r\n         * Returns the rectangular form of a complex number. Does not work for symbolic coefficients\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function rectform(symbol) {\r\n            //TODO: e^((i*pi)/4)\r\n            var original = symbol.clone();\r\n            try {\r\n                var f, p, q, s, h, d, n;\r\n                f = decompose_fn(symbol, 'e', true);\r\n                p = _.divide(f.x.power, Symbol.imaginary());\r\n                q = evaluate(trig.tan(p));\r\n                s = _.pow(f.a, new Symbol(2));\r\n                d = q.getDenom(true);\r\n                n = q.getNum();\r\n                h = Symbol.hyp(n, d);\r\n                //check\r\n                if(h.equals(f.a)) {\r\n                    return _.add(d, _.multiply(Symbol.imaginary(), n));\r\n                }\r\n                else {\r\n                    return original;\r\n                }\r\n            }\r\n            catch(e) {\r\n                return original;\r\n            }\r\n        }\r\n\r\n        function symMinMax(f, args) {\r\n            args.map(function (x) {\r\n                x.numVal = evaluate(x).multiplier;\r\n            });\r\n            var l, a, b, a_val, b_val;\r\n            while(true) {\r\n                l = args.length;\r\n                if(l < 2)\r\n                    return args[0];\r\n                a = args.pop();\r\n                b = args[l - 2];\r\n                if(f === 'min' ? a.numVal < b.numVal : a.numVal > b.numVal) {\r\n                    args.pop();\r\n                    args.push(a);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns maximum of a set of numbers\r\n         * @returns {Symbol}\r\n         */\r\n        function max() {\r\n            var args = [].slice.call(arguments);\r\n            if(allSame(args))\r\n                return args[0];\r\n            if(allNumbers(args))\r\n                return new Symbol(Math.max.apply(null, args));\r\n            if(Settings.SYMBOLIC_MIN_MAX && allConstants(args))\r\n                return symMinMax('max', args);\r\n            return _.symfunction('max', args);\r\n        }\r\n\r\n        /**\r\n         * Returns minimum of a set of numbers\r\n         * @returns {Symbol}\r\n         */\r\n        function min() {\r\n            var args = [].slice.call(arguments);\r\n            if(allSame(args))\r\n                return args[0];\r\n            if(allNumbers(args))\r\n                return new Symbol(Math.min.apply(null, args));\r\n            if(Settings.SYMBOLIC_MIN_MAX && allConstants(args))\r\n                return symMinMax('min', args);\r\n            return _.symfunction('min', args);\r\n        }\r\n\r\n        /**\r\n         * Returns the sign of a number\r\n         * @param {Symbol} x\r\n         * @returns {Symbol}\r\n         */\r\n        function sign(x) {\r\n            if(x.isConstant(true))\r\n                return new Symbol(Math.sign(evaluate(x)));\r\n            return _.symfunction('sign', arguments);\r\n        }\r\n\r\n        function sort(symbol, opt) {\r\n            opt = opt ? opt.toString() : 'asc';\r\n            var getval = function (e) {\r\n                if(e.group === N)\r\n                    return e.multiplier;\r\n                if(e.group === FN) {\r\n                    if(e.fname === '')\r\n                        return getval(e.args[0]);\r\n                    return e.fname;\r\n                }\r\n                if(e.group === S)\r\n                    return e.power;\r\n\r\n                return e.value;\r\n            };\r\n            var symbols = isVector(symbol) ? symbol.elements : symbol.collectSymbols();\r\n            return new Vector(symbols.sort(function (a, b) {\r\n                var aval = getval(a),\r\n                        bval = getval(b);\r\n                if(opt === 'desc')\r\n                    return bval - aval;\r\n                return aval - bval;\r\n            }));\r\n        }\r\n\r\n        /**\r\n         * The log function\r\n         * @param {Symbol} symbol\r\n         * @param {Symbol} base\r\n         * @returns {Symbol}\r\n         */\r\n        function log(symbol, base) {\r\n\r\n            if(symbol.equals(1)) {\r\n                return new Symbol(0);\r\n            }\r\n\r\n            var retval;\r\n\r\n            if(symbol.fname === SQRT && symbol.multiplier.equals(1)) {\r\n                retval = _.divide(log(symbol.args[0]), new Symbol(2));\r\n\r\n                if(symbol.power.sign() < 0) {\r\n                    retval.negate();\r\n                }\r\n\r\n                // Exit early\r\n                return retval;\r\n            }\r\n\r\n            //log(0) is undefined so complain\r\n            if(symbol.equals(0)) {\r\n                throw new UndefinedError(Settings.LOG + '(0) is undefined!');\r\n            }\r\n\r\n            //deal with imaginary values\r\n            if(symbol.isImaginary()) {\r\n                return complex.evaluate(symbol, Settings.LOG);\r\n            }\r\n\r\n            if(symbol.isConstant() && typeof base !== 'undefined' && base.isConstant()) {\r\n                var log_sym = Math.log(symbol);\r\n                var log_base = Math.log(base);\r\n                retval = new Symbol(log_sym / log_base);\r\n            }\r\n            else if(symbol.group === EX && symbol.power.multiplier.lessThan(0) || symbol.power.toString() === '-1') {\r\n                symbol.power.negate();\r\n                //move the negative outside but keep the positive inside :)\r\n                retval = log(symbol).negate();\r\n            }\r\n            else if(symbol.value === 'e' && symbol.multiplier.equals(1)) {\r\n                var p = symbol.power;\r\n                retval = isSymbol(p) ? p : new Symbol(p);\r\n            }\r\n            else if(symbol.group === FN && symbol.fname === 'exp') {\r\n                var s = symbol.args[0];\r\n                if(symbol.multiplier.equals(1))\r\n                    retval = _.multiply(s, new Symbol(symbol.power));\r\n                else\r\n                    retval = _.symfunction(Settings.LOG, [symbol]);\r\n            }\r\n            else if(Settings.PARSE2NUMBER && isNumericSymbol(symbol)) {\r\n                // Parse for safety.\r\n                symbol = _.parse(symbol);\r\n\r\n                var img_part;\r\n                if(symbol.multiplier.lessThan(0)) {\r\n                    symbol.negate();\r\n                    img_part = _.multiply(new Symbol(Math.PI), new Symbol('i'));\r\n                }\r\n\r\n                retval = new Symbol(Math.log(symbol.multiplier.toDecimal()));\r\n\r\n                if(img_part) {\r\n                    retval = _.add(retval, img_part);\r\n                }\r\n\r\n            }\r\n            else {\r\n                var s;\r\n                if(!symbol.power.equals(1) && !symbol.contains('e')) {\r\n                    s = symbol.group === EX ? symbol.power : new Symbol(symbol.power);\r\n                    symbol.toLinear();\r\n                }\r\n                //log(a,a) = 1 since the base is allowed to be changed.\r\n                //This was pointed out by Happypig375 in issue #280\r\n                if(arguments.length > 1 && allSame(arguments)) {\r\n                    retval = new Symbol(1);\r\n                }\r\n                else {\r\n                    retval = _.symfunction(Settings.LOG, arguments);\r\n                }\r\n\r\n                if(s)\r\n                    retval = _.multiply(s, retval);\r\n            }\r\n\r\n            return retval;\r\n        }\r\n\r\n        /**\r\n         * Round a number up to s decimal places\r\n         * @param {Number} x\r\n         * @param {int} s - the number of decimal places\r\n         * @returns {undefined}\r\n         */\r\n        function round(x, s) {\r\n            var sIsConstant = s && s.isConstant() || typeof s === 'undefined';\r\n            if(x.isConstant() && sIsConstant) {\r\n                var v, e, exp, retval;\r\n                v = x;\r\n                //round the coefficient of then number but not the actual decimal value\r\n                //we know this because a negative number was passed\r\n                if(s && s.lessThan(0)) {\r\n                    s = abs(s);\r\n                    //convert the number to exponential form\r\n                    e = Number(x).toExponential().toString().split('e');\r\n                    //point v to the coefficient of then number\r\n                    v = e[0];\r\n                    //set the expontent\r\n                    exp = e[1];\r\n                }\r\n                //round the number to the requested precision\r\n                retval = new Symbol(nround(v, Number(s || 0)));\r\n                //if there's a exponent then put it back\r\n                return _.multiply(retval, _.pow(new Symbol(10), new Symbol(exp || 0)))\r\n            }\r\n\r\n\r\n            return _.symfunction('round', arguments);\r\n        }\r\n\r\n        /**\r\n         * Gets the quadrant of the trig function\r\n         * @param {Frac} m\r\n         * @returns {Int}\r\n         */\r\n        function getQuadrant(m) {\r\n            var v = m % 2, quadrant;\r\n\r\n            if(v < 0)\r\n                v = 2 + v; //put it in terms of pi\r\n\r\n            if(v >= 0 && v <= 0.5)\r\n                quadrant = 1;\r\n            else if(v > 0.5 && v <= 1)\r\n                quadrant = 2;\r\n            else if(v > 1 && v <= 1.5)\r\n                quadrant = 3;\r\n            else\r\n                quadrant = 4;\r\n            return quadrant;\r\n        }\r\n\r\n        /*\r\n         * Serves as a bridge between numbers and bigNumbers\r\n         * @param {Frac|Number} n\r\n         * @returns {Symbol}\r\n         */\r\n        function bigConvert(n) {\r\n            if(!isFinite(n)) {\r\n                var sign = Math.sign(n);\r\n                var r = new Symbol(String(Math.abs(n)));\r\n                r.multiplier = r.multiplier.multiply(new Frac(sign));\r\n                return r;\r\n            }\r\n            if(isSymbol(n))\r\n                return n;\r\n            if(typeof n === 'number') {\r\n                try {\r\n                    n = Frac.simple(n);\r\n                }\r\n                catch(e) {\r\n                    n = new Frac(n);\r\n                }\r\n            }\r\n\r\n            var symbol = new Symbol(0);\r\n            symbol.multiplier = n;\r\n            return symbol;\r\n        }\r\n        ;\r\n\r\n        function clean(symbol) {\r\n            // handle functions with numeric values\r\n            // handle denominator within denominator\r\n            // handle trig simplifications\r\n            var g = symbol.group, retval;\r\n            //Now let's get to work\r\n            if(g === CP) {\r\n                var num = symbol.getNum(),\r\n                        den = symbol.getDenom() || new Symbol(1),\r\n                        p = Number(symbol.power),\r\n                        factor = new Symbol(1);\r\n                if(Math.abs(p) === 1) {\r\n                    den.each(function (x) {\r\n                        if(x.group === CB) {\r\n                            factor = _.multiply(factor, clean(x.getDenom()));\r\n                        }\r\n                        else if(x.power.lessThan(0)) {\r\n                            factor = _.multiply(factor, clean(x.clone().toUnitMultiplier()));\r\n                        }\r\n                    });\r\n\r\n                    var new_den = new Symbol(0);\r\n                    //now divide out the factor and add to new den\r\n                    den.each(function (x) {\r\n                        new_den = _.add(_.divide(x, factor.clone()), new_den);\r\n                    });\r\n\r\n                    factor.invert(); //invert so it can be added to the top\r\n                    var new_num;\r\n                    if(num.isComposite()) {\r\n                        new_num = new Symbol(0);\r\n                        num.each(function (x) {\r\n                            new_num = _.add(_.multiply(clean(x), factor.clone()), new_num);\r\n                        });\r\n                    }\r\n                    else\r\n                        new_num = _.multiply(factor, num);\r\n\r\n                    retval = _.divide(new_num, new_den);\r\n                }\r\n            }\r\n            else if(g === CB) {\r\n                retval = new Symbol(1);\r\n                symbol.each(function (x) {\r\n                    retval = _.multiply(retval, _.clean(x));\r\n                });\r\n            }\r\n            else if(g === FN) {\r\n                if(symbol.args.length === 1 && symbol.args[0].isConstant())\r\n                    retval = block('PARSE2NUMBER', function () {\r\n                        return _.parse(symbol);\r\n                    }, true);\r\n            }\r\n\r\n            if(!retval)\r\n                retval = symbol;\r\n\r\n            return retval;\r\n        }\r\n\r\n        /**\r\n         * A wrapper for the expand function\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function expandall(symbol, opt) {\r\n            opt = opt || {\r\n                expand_denominator: true,\r\n                expand_functions: true\r\n            };\r\n            return expand(symbol, opt);\r\n        }\r\n        /**\r\n         * Expands a symbol\r\n         * @param symbol\r\n         */\r\n        // Old expand\r\n        function expand(symbol, opt) {\r\n            if(Array.isArray(symbol)) {\r\n                return symbol.map(function (x) {\r\n                    return expand(x, opt);\r\n                });\r\n            }\r\n            opt = opt || {};\r\n            //deal with parenthesis\r\n            if(symbol.group === FN && symbol.fname === '') {\r\n                var f = expand(symbol.args[0], opt);\r\n                var x = expand(_.pow(f, _.parse(symbol.power)), opt);\r\n                return _.multiply(_.parse(symbol.multiplier), x).distributeMultiplier();\r\n            }\r\n            // We can expand these groups so no need to waste time. Just return and be done.\r\n            if([N, P, S].indexOf(symbol.group) !== -1) {\r\n                return symbol; //nothing to do\r\n            }\r\n\r\n            var original = symbol.clone();\r\n\r\n            // Set up a try-catch block. If anything goes wrong then we simply return the original symbol\r\n            try {\r\n                // Store the power and multiplier\r\n                var m = symbol.multiplier.toString();\r\n                var p = Number(symbol.power);\r\n                var retval = symbol;\r\n\r\n                // Handle (a+b)^2 | (x+x^2)^2\r\n                if(symbol.isComposite() && isInt(symbol.power) && symbol.power > 0) {\r\n                    var n = p - 1;\r\n                    // Strip the expression of it's multiplier and power. We'll call it f. The power will be p and the multiplier m.\r\n                    var f = new Symbol(0);\r\n\r\n                    symbol.each(function (x) {\r\n                        f = _.add(f, expand(_.parse(x), opt));\r\n                    });\r\n\r\n                    var expanded = _.parse(f);\r\n\r\n                    for(var i = 0; i < n; i++) {\r\n                        expanded = mix(expanded, f, opt);\r\n                    }\r\n\r\n                    retval = _.multiply(_.parse(m), expanded).distributeMultiplier();\r\n                }\r\n                else if(symbol.group === FN && opt.expand_functions === true) {\r\n                    var args = [];\r\n                    // Expand function the arguments\r\n                    symbol.args.forEach(function (x) {\r\n                        args.push(expand(x, opt));\r\n                    });\r\n                    // Put back the power and multiplier\r\n                    retval = _.pow(_.symfunction(symbol.fname, args), _.parse(symbol.power));\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.isComposite() && isInt(symbol.power) && symbol.power < 0 && opt.expand_denominator === true) {\r\n                    // Invert it. Expand it and then re-invert it.\r\n                    symbol = symbol.invert();\r\n                    retval = expand(symbol, opt);\r\n                    retval.invert();\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    var rank = function (s) {\r\n                        switch(s.group) {\r\n                            case CP:\r\n                                return 0;\r\n                            case PL:\r\n                                return 1;\r\n                            case CB:\r\n                                return 2;\r\n                            case FN:\r\n                                return 3;\r\n                            default:\r\n                                return 4;\r\n                        }\r\n                    };\r\n                    // Consider (a+b)(c+d). The result will be (a*c+a*d)+(b*c+b*d).\r\n                    // We start by moving collecting the symbols. We want others>FN>CB>PL>CP\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return rank(b) - rank(a);\r\n                    })\r\n                            // Distribute the power to each symbol and expand\r\n                            .map(function (s) {\r\n                                var x = _.pow(s, _.parse(p));\r\n                                var e = expand(x, opt);\r\n                                return e;\r\n                            });\r\n\r\n                    var f = symbols.pop();\r\n\r\n                    // If the first symbols isn't a composite then we're done\r\n                    if(f.isComposite() && f.isLinear()) {\r\n                        symbols.forEach(function (s) {\r\n                            f = mix(f, s, opt);\r\n                        });\r\n\r\n                        // If f is of group PL or CP then we can expand some more\r\n                        if(f.isComposite()) {\r\n                            if(f.power > 1) {\r\n                                f = expand(_.pow(f, _.parse(f.power)), opt);\r\n                            }\r\n                            // Put back the multiplier\r\n                            retval = _.multiply(_.parse(m), f).distributeMultiplier();\r\n                            ;\r\n                        }\r\n                        else {\r\n                            // Everything is expanded at this point so if it's still a CB\r\n                            // then just return the symbol\r\n                            retval = f;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Just multiply back in the expanded form of each\r\n                        retval = f;\r\n                        symbols.forEach(function (s) {\r\n                            retval = _.multiply(retval, s);\r\n                        });\r\n                        // Put back the multiplier\r\n                        retval = _.multiply(retval, _.parse(m)).distributeMultiplier();\r\n                    }\r\n\r\n                    // TODO: This exists solely as a quick fix for sqrt(11)*sqrt(33) not simplifying.\r\n                    if(retval.group === CB) {\r\n                        retval = _.parse(retval);\r\n                    }\r\n                }\r\n                else {\r\n                    // Otherwise just return the expression\r\n                    retval = symbol;\r\n                }\r\n                // Final cleanup and return\r\n                return retval;\r\n            }\r\n            catch(e) {\r\n                return original;\r\n            }\r\n\r\n            return original;\r\n        }\r\n\r\n        /**\r\n         * Returns an identity matrix of nxn\r\n         * @param {Number} n\r\n         * @returns {Matrix}\r\n         */\r\n        function imatrix(n) {\r\n            return Matrix.identity(n);\r\n        }\r\n\r\n        /**\r\n         * Retrieves and item from a vector\r\n         * @param {Vector} vector\r\n         * @param {Number} index\r\n         * @returns {Vector|Symbol}\r\n         */\r\n        function vecget(vector, index) {\r\n            if(index.isConstant() && isInt(index))\r\n                return vector.elements[index];\r\n            return _.symfunction('vecget', arguments);\r\n        }\r\n\r\n        /**\r\n         * Removes duplicates from a vector\r\n         * @param {Vector} vector\r\n         * @param {Number} tolerance\r\n         * @returns {Vector}\r\n         */\r\n        function vectrim(vector, tolerance) {\r\n            tolerance = typeof tolerance === 'undefined' ? 1e-14 : tolerance;\r\n\r\n            vector = vector.clone();\r\n\r\n            tolerance = Number(tolerance);\r\n            //place algebraic solutions first\r\n            vector.elements.sort(function (a, b) {\r\n                return b.group - a.group;\r\n            });\r\n            //depending on the start point we may have duplicates so we need to clean those up a bit.\r\n            //start by creating an object with the solution and the numeric value. This way we don't destroy algebraic values\r\n            vector.elements = removeDuplicates(vector.elements, function (a, b) {\r\n                var diff = Number(_.subtract(evaluate(a), evaluate(b)).abs());\r\n                return diff <= tolerance;\r\n            });\r\n\r\n            return vector;\r\n        }\r\n\r\n        /**\r\n         * Set a value for a vector at a given index\r\n         * @param {Vector} vector\r\n         * @param {Number} index\r\n         * @param {Symbol} value\r\n         * @returns {Vector}\r\n         */\r\n        function vecset(vector, index, value) {\r\n            if(!index.isConstant)\r\n                return _.symfunction('vecset', arguments);\r\n            vector.elements[index] = value;\r\n            return vector;\r\n        }\r\n\r\n        function matget(matrix, i, j) {\r\n            if(i.isConstant() && j.isConstant())\r\n                return matrix.elements[i][j];\r\n            return _.symfunction('matget', arguments);\r\n        }\r\n\r\n        function matgetrow(matrix, i) {\r\n            if(i.isConstant())\r\n                return new Matrix(matrix.elements[i]);\r\n            return _.symfunction('matgetrow', arguments);\r\n        }\r\n\r\n        function matsetrow(matrix, i, x) {\r\n            //handle symbolics\r\n            if(!i.isConstant())\r\n                return _.symfunction('matsetrow', arguments);\r\n            if(matrix.elements[i].length !== x.elements.length)\r\n                throw new DimensionError('Matrix row must match row dimensions!');\r\n            var M = matrix.clone();\r\n            M.elements[i] = x.clone().elements;\r\n            return M;\r\n        }\r\n\r\n        function matgetcol(matrix, col_index) {\r\n            //handle symbolics\r\n            if(!col_index.isConstant())\r\n                return _.symfunction('matgetcol', arguments);\r\n            col_index = Number(col_index);\r\n            var M = Matrix.fromArray([]);\r\n            matrix.each(function (x, i, j) {\r\n                if(j === col_index) {\r\n                    M.elements.push([x.clone()]);\r\n                }\r\n            });\r\n            return M;\r\n        }\r\n\r\n        function matsetcol(matrix, j, col) {\r\n            //handle symbolics\r\n            if(!j.isConstant())\r\n                return _.symfunction('matsetcol', arguments);\r\n            j = Number(j);\r\n            if(matrix.rows() !== col.elements.length)\r\n                throw new DimensionError('Matrix columns must match number of columns!');\r\n            col.each(function (x, i) {\r\n                matrix.set(i - 1, j, x.elements[0].clone());\r\n            });\r\n            return matrix;\r\n        }\r\n\r\n\r\n        function matset(matrix, i, j, value) {\r\n            matrix.elements[i][j] = value;\r\n            return matrix;\r\n        }\r\n\r\n        //the constructor for vectors\r\n        function vector() {\r\n            return new Vector([].slice.call(arguments));\r\n        }\r\n\r\n        //the constructor for matrices\r\n        function matrix() {\r\n            return Matrix.fromArray(arguments);\r\n        }\r\n\r\n        //the constructor for sets\r\n        function set() {\r\n            return Set.fromArray(arguments);\r\n        }\r\n\r\n        function determinant(symbol) {\r\n            if(isMatrix(symbol)) {\r\n                return symbol.determinant();\r\n            }\r\n            return symbol;\r\n        }\r\n\r\n        function size(symbol) {\r\n            var retval;\r\n            if(isMatrix(symbol))\r\n                retval = [new Symbol(symbol.cols()), new Symbol(symbol.rows())];\r\n            else if(isVector(symbol) || isSet(symbol))\r\n                retval = new Symbol(symbol.elements.length);\r\n            else\r\n                err('size expects a matrix or a vector');\r\n            return retval;\r\n        }\r\n\r\n        function dot(vec1, vec2) {\r\n            if(isVector(vec1) && isVector(vec2))\r\n                return vec1.dot(vec2);\r\n            err('function dot expects 2 vectors');\r\n        }\r\n\r\n        function cross(vec1, vec2) {\r\n            if(isVector(vec1) && isVector(vec2))\r\n                return vec1.cross(vec2);\r\n            err('function cross expects 2 vectors');\r\n        }\r\n\r\n        function transpose(mat) {\r\n            if(isMatrix(mat))\r\n                return mat.transpose();\r\n            err('function transpose expects a matrix');\r\n        }\r\n\r\n        function invert(mat) {\r\n            if(isMatrix(mat))\r\n                return mat.invert();\r\n            err('invert expects a matrix');\r\n        }\r\n\r\n        //basic set functions\r\n        function union(set1, set2) {\r\n            return set1.union(set2);\r\n        }\r\n\r\n        function intersection(set1, set2) {\r\n            return set1.intersection(set2);\r\n        }\r\n\r\n        function contains(set1, e) {\r\n            return set1.contains(e);\r\n        }\r\n\r\n        function difference(set1, set2) {\r\n            return set1.difference(set2);\r\n        }\r\n\r\n        function intersects(set1, set2) {\r\n            return new Symbol(Number(set1.intersects(set2)));\r\n        }\r\n\r\n        function is_subset(set1, set2) {\r\n            return new Symbol(Number(set1.is_subset(set2)));\r\n        }\r\n\r\n        function print() {\r\n            arguments2Array(arguments).map(function (x) {\r\n                console.log(x.toString());\r\n            });\r\n        }\r\n\r\n        function testSQRT(symbol) {\r\n            //wrap the symbol in sqrt. This eliminates one more check down the line.\r\n            if(!isSymbol(symbol.power) && symbol.power.absEquals(0.5)) {\r\n                var sign = symbol.power.sign();\r\n                //don't devide the power directly. Notice the use of toString. This makes it possible\r\n                //to use a bigNumber library in the future\r\n                var retval = sqrt(symbol.group === P ? new Symbol(symbol.value) : symbol.toLinear());\r\n                //place back the sign of the power\r\n                if(sign < 0)\r\n                    retval.invert();\r\n                return retval;\r\n            }\r\n            return symbol;\r\n        }\r\n\r\n        //try to reduce a symbol by pulling its power\r\n        function testPow(symbol) {\r\n            if(symbol.group === P) {\r\n                var v = symbol.value;\r\n\r\n                var fct = primeFactors(v)[0];\r\n\r\n                //safety\r\n                if(!fct) {\r\n                    warn('Unable to compute prime factors. This should not happen. Please review and report.');\r\n                    return symbol;\r\n                }\r\n\r\n                var n = new Frac(Math.log(v) / Math.log(fct)),\r\n                        p = n.multiply(symbol.power);\r\n\r\n                //we don't want a more complex number than before\r\n                if(p.den > symbol.power.den)\r\n                    return symbol;\r\n\r\n                if(isInt(p))\r\n                    symbol = Symbol(Math.pow(fct, p));\r\n                else\r\n                    symbol = new Symbol(fct).setPower(p);\r\n            }\r\n\r\n            return symbol;\r\n        }\r\n\r\n        //Link the functions to the parse so they're available outside of the library.\r\n        //This is strictly for convenience and may be deprecated.\r\n        this.expand = expand;\r\n        this.round = round;\r\n        this.clean = clean;\r\n        this.sqrt = sqrt;\r\n        this.cbrt = cbrt;\r\n        this.abs = abs;\r\n        this.log = log;\r\n        this.rationalize = rationalize;\r\n        this.nthroot = nthroot;\r\n        this.arg = arg;\r\n        this.conjugate = conjugate;\r\n        this.imagpart = imagpart;\r\n        this.realpart = realpart;\r\n\r\n        //TODO:\r\n        //Utilize the function below instead of the linked function\r\n        this.getFunction = function (name) {\r\n            return functions[name][0];\r\n        };\r\n\r\n//Parser.methods ===============================================================\r\n        this.addPreprocessor = function (name, action, order, shift_cells) {\r\n            var names = preprocessors.names;\r\n            var actions = preprocessors.actions;\r\n            if((typeof action !== 'function')) //the person probably forgot to specify a name\r\n                throw new PreprocessorError('Incorrect parameters. Function expected!');\r\n            if(!order) {\r\n                names.push(name);\r\n                actions.push(action);\r\n            }\r\n            else {\r\n                if(shift_cells) {\r\n                    names.splice(order, 0, name);\r\n                    actions.splice(order, 0, action);\r\n                }\r\n                else {\r\n                    names[order] = name;\r\n                    actions[order] = action;\r\n                }\r\n            }\r\n        };\r\n\r\n        this.getPreprocessors = function () {\r\n            var preprocessors = {};\r\n            for(var i = 0, l = preprocessors.names.length; i < l; i++) {\r\n                var name = preprocessors.names[i];\r\n                preprocessors[name] = {\r\n                    order: i,\r\n                    action: preprocessors.actions[i]\r\n                };\r\n            }\r\n            return preprocessors;\r\n        };\r\n\r\n        this.removePreprocessor = function (name, shift_cells) {\r\n            var i = preprocessors.names.indexOf(name);\r\n            if(shift_cells) {\r\n                remove(preprocessors.names, i);\r\n                remove(preprocessors.actions, i);\r\n            }\r\n            else {\r\n                preprocessors.names[i] = undefined;\r\n                preprocessors.actions[i] = undefined;\r\n            }\r\n        };\r\n\r\n        //The loader for functions which are not part of Math2\r\n        this.mapped_function = function () {\r\n            var subs = {},\r\n                    params = this.params;\r\n\r\n            for(var i = 0; i < params.length; i++) {\r\n                subs[params[i]] = String(arguments[i]);\r\n            }\r\n\r\n            return _.parse(this.body, subs);\r\n        };\r\n        /**\r\n         * Adds two symbols\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.add = function (a, b) {\r\n            var aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b);\r\n            //we're dealing with two symbols\r\n            if(aIsSymbol && bIsSymbol) {\r\n                //forward the adding of symbols with units to the Unit module\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.add(a, b);\r\n                }\r\n                //handle Infinity\r\n                //https://www.encyclopediaofmath.org/index.php/Infinity\r\n                if(a.isInfinity || b.isInfinity) {\r\n                    var aneg = a.multiplier.lessThan(0),\r\n                            bneg = b.multiplier.lessThan(0);\r\n\r\n                    if(a.isInfinity && b.isInfinity && aneg !== bneg) {\r\n                        throw new UndefinedError('(' + a + ')+(' + b + ') is not defined!');\r\n                    }\r\n\r\n                    var inf = Symbol.infinity();\r\n                    if(bneg)\r\n                        inf.negate();\r\n                    return inf;\r\n                }\r\n\r\n                if(a.isComposite() && a.isLinear() && b.isComposite() && b.isLinear()) {\r\n                    a.distributeMultiplier();\r\n                    b.distributeMultiplier();\r\n                    // Fix for issue #606\r\n                    if(b.length > a.length && a.group === b.group) {\r\n                        [a, b] = [b, a];\r\n                    }\r\n                }\r\n                \r\n                //no need to waste time on zeroes\r\n                if(a.multiplier.equals(0))\r\n                    return b;\r\n                if(b.multiplier.equals(0))\r\n                    return a;\r\n\r\n                if(a.isConstant() && b.isConstant() && Settings.PARSE2NUMBER) {\r\n                    var result = new Symbol(a.multiplier.add(b.multiplier).toDecimal(Settings.PRECISION));\r\n                    return result;\r\n                }\r\n\r\n                var g1 = a.group,\r\n                        g2 = b.group,\r\n                        ap = a.power.toString(),\r\n                        bp = b.power.toString();\r\n\r\n                //always keep the greater group on the left.\r\n                if(g1 < g2 || (g1 === g2 && ap > bp && bp > 0)) {\r\n                    return this.add(b, a);\r\n                }\r\n\r\n                /*note to self: Please don't forget about this dilemma ever again. In this model PL and CB goes crazy\r\n                 * because it doesn't know which one to prioritize. */\r\n                //correction to PL dilemma\r\n                if(g1 === CB && g2 === PL && a.value === b.value) {\r\n                    //swap\r\n                    var t = a;\r\n                    a = b;\r\n                    b = t;\r\n                    g1 = a.group;\r\n                    g2 = b.group;\r\n                    ap = a.power.toString();\r\n                    bp = b.power.toString();\r\n                }\r\n\r\n                var powEQ = ap === bp,\r\n                        v1 = a.value,\r\n                        v2 = b.value,\r\n                        aIsComposite = a.isComposite(),\r\n                        bIsComposite = b.isComposite(),\r\n                        h1, h2, result;\r\n\r\n                if(aIsComposite)\r\n                    h1 = text(a, 'hash');\r\n                if(bIsComposite)\r\n                    h2 = text(b, 'hash');\r\n\r\n                if(g1 === CP && g2 === CP && b.isLinear() && !a.isLinear() && h1 !== h2) {\r\n                    return this.add(b, a);\r\n                }\r\n\r\n                //PL & PL should compare hashes and not values e.g. compare x+x^2 with x+x^3 and not x with x\r\n                if(g1 === PL && g2 === PL) {\r\n                    v1 = h1;\r\n                    v2 = h2;\r\n                }\r\n\r\n                var PN = g1 === P && g2 === N,\r\n                        PNEQ = a.value === b.multiplier.toString(),\r\n                        valEQ = (v1 === v2 || h1 === h2 && h1 !== undefined || (PN && PNEQ));\r\n\r\n                //equal values, equal powers\r\n                if(valEQ && powEQ && g1 === g2) {\r\n                    //make sure to convert N to something P can work with\r\n                    if(PN)\r\n                        b = b.convert(P);//CL\r\n\r\n                    //handle PL\r\n                    if(g1 === PL && (g2 === S || g2 === P)) {\r\n                        a.distributeMultiplier();\r\n                        result = a.attach(b);\r\n                    }\r\n                    else {\r\n                        result = a;//CL\r\n                        if(a.multiplier.isOne() && b.multiplier.isOne() && g1 === CP && a.isLinear() && b.isLinear()) {\r\n                            for(var s in b.symbols) {\r\n                                var x = b.symbols[s];\r\n                                result.attach(x);\r\n                            }\r\n                        }\r\n                        else\r\n                            result.multiplier = result.multiplier.add(b.multiplier);\r\n                    }\r\n                }\r\n                //equal values uneven powers\r\n                else if(valEQ && g1 !== PL) {\r\n                    //break the tie for e.g. (x+1)+((x+1)^2+(x+1)^3)\r\n                    if(g1 === CP && g2 === PL) {\r\n                        b.insert(a, 'add');\r\n                        result = b;\r\n                    }\r\n                    else {\r\n                        result = Symbol.shell(PL).attach([a, b]);\r\n                        //update the hash\r\n                        result.value = g1 === PL ? h1 : v1;\r\n                    }\r\n                }\r\n                else if(aIsComposite && a.isLinear()) {\r\n                    var canIterate = g1 === g2,\r\n                            bothPL = g1 === PL && g2 === PL;\r\n\r\n                    //we can only iterate group PL if they values match\r\n                    if(bothPL)\r\n                        canIterate = a.value === b.value;\r\n                    //distribute the multiplier over the entire symbol\r\n                    a.distributeMultiplier();\r\n\r\n                    if(b.isComposite() && b.isLinear() && canIterate) {\r\n                        b.distributeMultiplier();\r\n                        //CL\r\n                        for(var s in b.symbols) {\r\n                            var x = b.symbols[s];\r\n                            a.attach(x);\r\n                        }\r\n                        result = a;\r\n                    }\r\n                    //handle cases like 2*(x+x^2)^2+2*(x+x^2)^3+4*(x+x^2)^2\r\n                    else if(bothPL && a.value !== h2 || g1 === PL && !valEQ) {\r\n                        result = Symbol.shell(CP).attach([a, b]);\r\n                        result.updateHash();\r\n\r\n                    }\r\n                    else {\r\n                        result = a.attach(b);\r\n                    }\r\n                }\r\n                else {\r\n                    if(g1 === FN && a.fname === SQRT && g2 !== EX && b.power.equals(0.5)) {\r\n                        var m = b.multiplier.clone();\r\n                        b = sqrt(b.toUnitMultiplier().toLinear());\r\n                        b.multiplier = m;\r\n                    }\r\n                    //fix for issue #3 and #159\r\n                    if(a.length === 2 && b.length === 2 && even(a.power) && even(b.power)) {\r\n                        result = _.add(expand(a), expand(b));\r\n                    }\r\n                    else {\r\n                        result = Symbol.shell(CP).attach([a, b]);\r\n                        result.updateHash();\r\n                    }\r\n                }\r\n\r\n                if(result.multiplier.equals(0))\r\n                    result = new Symbol(0);\r\n\r\n                //make sure to remove unnecessary wraps\r\n                if(result.length === 1) {\r\n                    var m = result.multiplier;\r\n                    result = firstObject(result.symbols);\r\n                    result.multiplier = result.multiplier.multiply(m);\r\n                }\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                //keep symbols to the right\r\n                if(bIsSymbol && !aIsSymbol) {\r\n                    var t = a;\r\n                    a = b;\r\n                    b = t; //swap\r\n                    t = bIsSymbol;\r\n                    bIsSymbol = aIsSymbol;\r\n                    aIsSymbol = t;\r\n                }\r\n\r\n                var bIsMatrix = isMatrix(b);\r\n\r\n                if(aIsSymbol && bIsMatrix) {\r\n                    var M = new Matrix();\r\n                    b.eachElement(function (e, i, j) {\r\n                        M.set(i, j, _.add(a.clone(), e));\r\n                    });\r\n\r\n                    b = M\r\n                }\r\n                else {\r\n                    if(isMatrix(a) && bIsMatrix) {\r\n                        b = a.add(b);\r\n                    }\r\n                    else if(aIsSymbol && isVector(b)) {\r\n                        b.each(function (x, i) {\r\n                            i--;\r\n                            b.elements[i] = _.add(a.clone(), b.elements[i]);\r\n                        });\r\n                    }\r\n                    else {\r\n                        if(isVector(a) && isVector(b)) {\r\n                            b.each(function (x, i) {\r\n                                i--;\r\n                                b.elements[i] = _.add(a.elements[i], b.elements[i]);\r\n                            });\r\n                        }\r\n                        else if(isVector(a) && isMatrix(b)) {\r\n                            //try to convert a to a matrix\r\n                            return _.add(b, a);\r\n                        }\r\n                        else if(isMatrix(a) && isVector(b)) {\r\n                            if(b.elements.length === a.rows()) {\r\n                                var M = new Matrix(), l = a.cols();\r\n                                b.each(function (e, i) {\r\n                                    var row = [];\r\n                                    for(var j = 0; j < l; j++) {\r\n                                        row.push(_.add(a.elements[i - 1][j].clone(), e.clone()));\r\n                                    }\r\n                                    M.elements.push(row);\r\n                                });\r\n                                return M;\r\n                            }\r\n                            else\r\n                                err('Dimensions must match!');\r\n                        }\r\n                    }\r\n                }\r\n                return b;\r\n            }\r\n\r\n        };\r\n        /**\r\n         * Gets called when the parser finds the - operator. Not the prefix operator. See this.add\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.subtract = function (a, b) {\r\n            var aIsSymbol = aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b), t;\r\n\r\n            if(aIsSymbol && bIsSymbol) {\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.subtract(a, b);\r\n                }\r\n                return this.add(a, b.negate());\r\n            }\r\n            else {\r\n                if(bIsSymbol && isVector(a)) {\r\n                    b = a.map(function (x) {\r\n                        return _.subtract(x, b.clone());\r\n                    });\r\n                }\r\n                else if(aIsSymbol && isVector(b)) {\r\n                    b = b.map(function (x) {\r\n                        return _.subtract(a.clone(), x);\r\n                    });\r\n                }\r\n                else if(isVector(a) && isVector(b)) {\r\n                    if(a.dimensions() === b.dimensions())\r\n                        b = a.subtract(b);\r\n                    else\r\n                        _.error('Unable to subtract vectors. Dimensions do not match.');\r\n                }\r\n                else if(isMatrix(a) && isVector(b)) {\r\n                    if(b.elements.length === a.rows()) {\r\n                        var M = new Matrix(), l = a.cols();\r\n                        b.each(function (e, i) {\r\n                            var row = [];\r\n                            for(var j = 0; j < l; j++) {\r\n                                row.push(_.subtract(a.elements[i - 1][j].clone(), e.clone()));\r\n                            }\r\n                            M.elements.push(row);\r\n                        });\r\n                        return M;\r\n                    }\r\n                    else\r\n                        err('Dimensions must match!');\r\n                }\r\n                else if(isVector(a) && isMatrix(b)) {\r\n                    var M = b.clone().negate();\r\n                    return _.add(M, a);\r\n                }\r\n                else if(isMatrix(a) && isMatrix(b)) {\r\n                    b = a.subtract(b);\r\n                }\r\n                else if(isMatrix(a) && bIsSymbol) {\r\n                    var M = new Matrix();\r\n                    a.each(function (x, i, j) {\r\n                        M.set(i, j, _.subtract(x, b.clone()));\r\n                    });\r\n                    b = M;\r\n                }\r\n                else if(aIsSymbol && isMatrix(b)) {\r\n                    var M = new Matrix();\r\n                    b.each(function (x, i, j) {\r\n                        M.set(i, j, _.subtract(a.clone(), x));\r\n                    });\r\n                    b = M;\r\n                }\r\n                return b;\r\n            }\r\n        };\r\n        /**\r\n         * Gets called when the parser finds the * operator. See this.add\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.multiply = function (a, b) {\r\n            var aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b);\r\n            //we're dealing with function assignment here\r\n            if(aIsSymbol && b instanceof Collection) {\r\n                b.elements.push(a);\r\n                return b;\r\n            }\r\n            if(aIsSymbol && bIsSymbol) {\r\n                //if it has a unit then add it and return it right away.\r\n                if(b.isUnit) {\r\n                    var result = a.clone();\r\n                    a.unit = b;\r\n                    return result;\r\n                }\r\n                \r\n                //if it has units then just forward that problem to the unit module\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.multiply(a, b);\r\n                }\r\n\r\n                //handle Infinty\r\n                if(a.isInfinity || b.isInfinity) {\r\n                    if(a.equals(0) || b.equals(0))\r\n                        throw new UndefinedError(a + '*' + b + ' is undefined!');\r\n                    //x/infinity\r\n                    if(b.power.lessThan(0)) {\r\n                        if(!a.isInfinity) {\r\n                            return new Symbol(0);\r\n                        }\r\n                        else {\r\n                            throw new UndefinedError('Infinity/Infinity is not defined!');\r\n                        }\r\n                    }\r\n\r\n                    var sign = a.multiplier.multiply(b.multiplier).sign(),\r\n                            inf = Symbol.infinity();\r\n                    if(a.isConstant() || b.isConstant() || (a.isInfinity && b.isInfinity)) {\r\n                        if(sign < 0)\r\n                            inf.negate();\r\n\r\n                        return inf;\r\n                    }\r\n                }\r\n                //the quickies\r\n                if(a.isConstant() && b.isConstant() && Settings.PARSE2NUMBER) {\r\n                    var t = new bigDec(a.multiplier.toDecimal()).times(new bigDec(b.multiplier.toDecimal())).toFixed();\r\n                    var retval = new Symbol(t);\r\n                    return retval;\r\n                }\r\n\r\n                //don't waste time\r\n                if(a.isOne()) {\r\n                    return b.clone();\r\n                }\r\n                if(b.isOne()) {\r\n                    return a.clone();\r\n                }\r\n\r\n                if(a.multiplier.equals(0) || b.multiplier.equals(0))\r\n                    return new Symbol(0);\r\n\r\n                if(b.group > a.group && !(b.group === CP))\r\n                    return this.multiply(b, a);\r\n                //correction for PL/CB dilemma\r\n                if(a.group === CB && b.group === PL && a.value === b.value) {\r\n                    var t = a;\r\n                    a = b;\r\n                    b = t;//swap\r\n                }\r\n\r\n                var g1 = a.group,\r\n                        g2 = b.group,\r\n                        bnum = b.multiplier.num,\r\n                        bden = b.multiplier.den;\r\n\r\n                if(g1 === FN && a.fname === SQRT && !b.isConstant() && a.args[0].value === b.value && !a.args[0].multiplier.lessThan(0)) {\r\n                    //unwrap sqrt\r\n                    var a_pow = a.power;\r\n                    var a_multiplier = _.parse(a.multiplier);\r\n                    a = _.multiply(a_multiplier, a.args[0].clone());\r\n                    a.setPower(new Frac(0.5).multiply(a_pow));\r\n                    g1 = a.group;\r\n                }\r\n                //simplify n/sqrt(n). Being very specific\r\n                else if(g1 === FN && a.fname === SQRT && a.multiplier.equals(1) && a.power.equals(-1) && b.isConstant() && a.args[0].equals(b)) {\r\n                    a = _.symfunction(SQRT, [b.clone()]);\r\n                    b = new Symbol(1);\r\n                }\r\n                ;\r\n\r\n                var v1 = a.value,\r\n                        v2 = b.value,\r\n                        sign = new Frac(a.sign()),\r\n                        //since P is just a morphed version of N we need to see if they relate\r\n                        ONN = (g1 === P && g2 === N && b.multiplier.equals(a.value)),\r\n                        //don't multiply the multiplier of b since that's equal to the value of a\r\n                        m = ONN ? new Frac(1).multiply(a.multiplier).abs() : a.multiplier.multiply(b.multiplier).abs(),\r\n                        result = a.clone().toUnitMultiplier();\r\n                b = b.clone().toUnitMultiplier(true);\r\n\r\n                //further simplification of sqrt\r\n                if(g1 === FN && g2 === FN) {\r\n                    var u = a.args[0].clone();\r\n                    var v = b.args[0].clone();\r\n                    if(a.fname === SQRT && b.fname === SQRT && a.isLinear() && b.isLinear()) {\r\n\r\n                        var q = _.divide(u, v).invert();\r\n                        if(q.gt(1) && isInt(q)) {\r\n                            //b contains a factor a which can be moved to a\r\n                            result = _.multiply(a.args[0].clone(), sqrt(q.clone()));\r\n                            b = new Symbol(1);\r\n                        }\r\n                    }\r\n                    //simplify factorial but only if\r\n                    //1 - It's division so b will have a negative power\r\n                    //2 - We're not dealing with factorials of numbers\r\n                    else if(a.fname === FACTORIAL && b.fname === FACTORIAL && !u.isConstant() && !v.isConstant() && b.power < 0) {\r\n                        //assume that n = positive\r\n                        var d = _.subtract(u.clone(), v.clone());\r\n\r\n                        //if it's not numeric then we don't know if we can simplify so just return\r\n                        if(d.isConstant()) {\r\n\r\n                            //there will never be a case where d == 0 since this will already have\r\n                            //been handled at the beginning of this function\r\n                            t = new Symbol(1);\r\n                            if(d < 0) {\r\n                                //If d is negative then the numerator is larger so expand that\r\n                                for(var i = 0, n = Math.abs(d); i <= n; i++) {\r\n                                    var s = _.add(u.clone(), new Symbol(i));\r\n                                    t = _.multiply(t, s);\r\n                                }\r\n\r\n                                result = _.multiply(_.pow(u, new Symbol(a.power)), _.pow(t, new Symbol(b.power)));\r\n\r\n                                b = new Symbol(1);\r\n                            }\r\n                            else {\r\n                                //Otherwise the denominator is larger so expand that\r\n                                for(var i = 0, n = Math.abs(d); i <= n; i++) {\r\n                                    var s = _.add(v.clone(), new Symbol(i));\r\n                                    t = _.multiply(t, s);\r\n                                }\r\n\r\n                                result = _.multiply(_.pow(t, new Symbol(a.power)), _.pow(v, new Symbol(b.power)));\r\n\r\n                                b = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //if both are PL then their hashes have to match\r\n                if(v1 === v2 && g1 === PL && g1 === g2) {\r\n                    v1 = a.text('hash');\r\n                    v2 = b.text('hash');\r\n                }\r\n\r\n                //same issue with (x^2+1)^x*(x^2+1)\r\n                //EX needs an exception when multiplying because it needs to recognize\r\n                //that (x+x^2)^x has the same hash as (x+x^2). The latter is kept as x\r\n                if(g2 === EX && b.previousGroup === PL && g1 === PL) {\r\n                    v1 = text(a, 'hash', EX);\r\n                }\r\n\r\n                if((v1 === v2 || ONN) && !(g1 === PL && (g2 === S || g2 === P || g2 === FN)) && !(g1 === PL && g2 === CB)) {\r\n                    var p1 = a.power,\r\n                            p2 = b.power,\r\n                            isSymbolP1 = isSymbol(p1),\r\n                            isSymbolP2 = isSymbol(p2),\r\n                            toEX = (isSymbolP1 || isSymbolP2);\r\n                    //TODO: this needs cleaning up\r\n                    if(g1 === PL && g2 !== PL && b.previousGroup !== PL && p1.equals(1)) {\r\n                        result = new Symbol(0);\r\n                        a.each(function (x) {\r\n                            result = _.add(result, _.multiply(x, b.clone()));\r\n                        }, true);\r\n                    }\r\n                    else {\r\n                        //add the powers\r\n                        result.power = toEX ? _.add(\r\n                                !(isSymbol(p1)) ? new Symbol(p1) : p1,\r\n                                !(isSymbol(p2)) ? new Symbol(p2) : p2\r\n                                ) : (g1 === N /*don't add powers for N*/ ? p1 : p1.add(p2));\r\n\r\n                        //eliminate zero power values and convert them to numbers\r\n                        if(result.power.equals(0))\r\n                            result = result.convert(N);\r\n\r\n                        //properly convert to EX\r\n                        if(toEX)\r\n                            result.convert(EX);\r\n\r\n                        //take care of imaginaries\r\n                        if(a.imaginary && b.imaginary) {\r\n                            var isEven = even(result.power % 2);\r\n                            if(isEven) {\r\n                                result = new Symbol(1);\r\n                                m.negate();\r\n                            }\r\n                        }\r\n\r\n                        //cleanup: this causes the LaTeX generator to get confused as to how to render the symbol\r\n                        if(result.group !== EX && result.previousGroup)\r\n                            result.previousGroup = undefined;\r\n                        //the sign for b is floating around. Remember we are assuming that the odd variable will carry\r\n                        //the sign but this isn't true if they're equals symbols\r\n                        result.multiplier = result.multiplier.multiply(b.multiplier);\r\n                    }\r\n                }\r\n                else if(g1 === CB && a.isLinear()) {\r\n                    if(g2 === CB)\r\n                        b.distributeExponent();\r\n                    if(g2 === CB && b.isLinear()) {\r\n                        for(var s in b.symbols) {\r\n                            var x = b.symbols[s];\r\n                            result = result.combine(x);\r\n                        }\r\n                        result.multiplier = result.multiplier.multiply(b.multiplier);\r\n                    }\r\n                    else {\r\n                        result.combine(b);\r\n                    }\r\n                }\r\n                else {\r\n                    //the multiplier was already handled so nothing left to do\r\n                    if(g1 !== N) {\r\n                        if(g1 === CB) {\r\n                            result.distributeExponent();\r\n                            result.combine(b);\r\n                        }\r\n                        else if(!b.isOne()) {\r\n                            var bm = b.multiplier.clone();\r\n                            b.toUnitMultiplier();\r\n                            result = Symbol.shell(CB).combine([result, b]);\r\n                            //transfer the multiplier to the outside\r\n                            result.multiplier = result.multiplier.multiply(bm);\r\n                        }\r\n                    }\r\n                    else {\r\n                        result = b.clone().toUnitMultiplier();\r\n                    }\r\n                }\r\n\r\n                if(result.group === P) {\r\n                    var logV = Math.log(result.value),\r\n                            n1 = Math.log(bnum) / logV,\r\n                            n2 = Math.log(bden) / logV,\r\n                            ndiv = m.num / bnum,\r\n                            ddiv = m.den / bden;\r\n                    //we don't want to divide by zero no do we? Strange things happen.\r\n                    if(n1 !== 0 && isInt(n1) && isInt(ndiv)) {\r\n                        result.power = result.power.add(new Frac(n1));\r\n                        m.num /= bnum; //BigInt? Keep that in mind for the future.\r\n                    }\r\n                    if(n2 !== 0 && isInt(n2) && isInt(ddiv)) {\r\n                        result.power = result.power.subtract(new Frac(n2));\r\n                        m.den /= bden; //BigInt? Keep that in mind for the future.\r\n                    }\r\n                }\r\n\r\n                //unpack CB if length is only one\r\n                if(result.length === 1) {\r\n                    var t = result.multiplier;\r\n                    //transfer the multiplier\r\n                    result = firstObject(result.symbols);\r\n                    result.multiplier = result.multiplier.multiply(t);\r\n                }\r\n\r\n                //reduce square root\r\n                var ps = result.power.toString();\r\n                if(even(ps) && result.fname === SQRT) {\r\n                    //grab the sign of the symbol\r\n                    sign = sign * result.sign();\r\n                    var p = result.power;\r\n                    result = result.args[0];\r\n                    result = _.multiply(new Symbol(m), _.pow(result, new Symbol(p.divide(new Frac(2)))));\r\n                    //flip it back to the correct sign\r\n                    if(sign < 0)\r\n                        result.negate()\r\n                }\r\n                else {\r\n                    result.multiplier = result.multiplier.multiply(m).multiply(sign);\r\n                    if(result.group === CP && result.isImaginary())\r\n                        result.distributeMultiplier();\r\n                }\r\n\r\n                //back convert group P to a simpler group N if possible\r\n                if(result.group === P && isInt(result.power.toDecimal()))\r\n                    result = result.convert(N);\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                //****** Matrices & Vector *****//\r\n                if(bIsSymbol && !aIsSymbol) { //keep symbols to the right\r\n                    t = a;\r\n                    a = b;\r\n                    b = t; //swap\r\n                    t = bIsSymbol;\r\n                    bIsSymbol = aIsSymbol;\r\n                    aIsSymbol = t;\r\n                }\r\n\r\n                var isMatrixB = isMatrix(b), isMatrixA = isMatrix(a);\r\n                if(aIsSymbol && isMatrixB) {\r\n                    var M = new Matrix();\r\n                    b.eachElement(function (e, i, j) {\r\n                        M.set(i, j, _.multiply(a.clone(), e));\r\n                    });\r\n\r\n                    b = M;\r\n                }\r\n                else {\r\n                    if(isMatrixA && isMatrixB) {\r\n                        b = a.multiply(b);\r\n                    }\r\n                    else if(aIsSymbol && isVector(b)) {\r\n                        b.each(function (x, i) {\r\n                            i--;\r\n                            b.elements[i] = _.multiply(a.clone(), b.elements[i]);\r\n                        });\r\n                    }\r\n                    else {\r\n                        if(isVector(a) && isVector(b)) {\r\n                            b.each(function (x, i) {\r\n                                i--;\r\n                                b.elements[i] = _.multiply(a.elements[i], b.elements[i]);\r\n                            });\r\n                        }\r\n                        else if(isVector(a) && isMatrix(b)) {\r\n                            //try to convert a to a matrix\r\n                            return this.multiply(b, a);\r\n                        }\r\n                        else if(isMatrix(a) && isVector(b)) {\r\n                            if(b.elements.length === a.rows()) {\r\n                                var M = new Matrix(), l = a.cols();\r\n                                b.each(function (e, i) {\r\n                                    var row = [];\r\n                                    for(var j = 0; j < l; j++) {\r\n                                        row.push(_.multiply(a.elements[i - 1][j].clone(), e.clone()));\r\n                                    }\r\n                                    M.elements.push(row);\r\n                                });\r\n                                return M;\r\n                            }\r\n                            else\r\n                                err('Dimensions must match!');\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return b;\r\n            }\r\n        };\r\n        /**\r\n         * Gets called when the parser finds the / operator. See this.add\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.divide = function (a, b) {\r\n            var aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b);\r\n\r\n            if(aIsSymbol && bIsSymbol) {\r\n                //forward to Unit division\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.divide(a, b);\r\n                }\r\n                var result;\r\n                if(b.equals(0))\r\n                    throw new DivisionByZero('Division by zero not allowed!');\r\n\r\n                if(a.isConstant() && b.isConstant()) {\r\n                    result = a.clone();\r\n                    result.multiplier = result.multiplier.divide(b.multiplier);\r\n                }\r\n                else {\r\n                    b.invert();\r\n                    result = _.multiply(a, b);\r\n                }\r\n                return result;\r\n            }\r\n            else {\r\n                //******* Vectors & Matrices *********//\r\n                var isVectorA = isVector(a), isVectorB = isVector(b);\r\n                if(aIsSymbol && isVectorB) {\r\n                    b = b.map(function (x) {\r\n                        return _.divide(a.clone(), x);\r\n                    });\r\n                }\r\n                else if(isVectorA && bIsSymbol) {\r\n                    b = a.map(function (x) {\r\n                        return _.divide(x, b.clone());\r\n                    });\r\n                }\r\n                else if(isVectorA && isVectorB) {\r\n                    if(a.dimensions() === b.dimensions()) {\r\n                        b = b.map(function (x, i) {\r\n                            return _.divide(a.elements[--i], x);\r\n                        });\r\n                    }\r\n                    else\r\n                        _.error('Cannot divide vectors. Dimensions do not match!');\r\n                }\r\n                else {\r\n                    var isMatrixA = isMatrix(a), isMatrixB = isMatrix(b);\r\n                    if(isMatrixA && bIsSymbol) {\r\n                        var M = new Matrix();\r\n                        a.eachElement(function (x, i, j) {\r\n                            M.set(i, j, _.divide(x, b.clone()));\r\n                        });\r\n                        b = M;\r\n                    }\r\n                    else if(aIsSymbol && isMatrixB) {\r\n                        var M = new Matrix();\r\n                        b.eachElement(function (x, i, j) {\r\n                            M.set(i, j, _.divide(a.clone(), x));\r\n                        });\r\n                        b = M;\r\n                    }\r\n                    else if(isMatrixA && isMatrixB) {\r\n                        var M = new Matrix();\r\n                        if(a.rows() === b.rows() && a.cols() === b.cols()) {\r\n                            a.eachElement(function (x, i, j) {\r\n                                M.set(i, j, _.divide(x, b.elements[i][j]));\r\n                            });\r\n                            b = M;\r\n                        }\r\n                        else {\r\n                            _.error('Dimensions do not match!');\r\n                        }\r\n                    }\r\n                    else if(isMatrixA && isVectorB) {\r\n                        if(a.cols() === b.dimensions()) {\r\n                            var M = new Matrix();\r\n                            a.eachElement(function (x, i, j) {\r\n                                M.set(i, j, _.divide(x, b.elements[i].clone()));\r\n                            });\r\n                            b = M;\r\n                        }\r\n                        else {\r\n                            _.error('Unable to divide matrix by vector.');\r\n                        }\r\n                    }\r\n                }\r\n                return b;\r\n            }\r\n        };\r\n        /**\r\n         * Gets called when the parser finds the ^ operator. See this.add\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.pow = function (a, b) {\r\n            var aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b);\r\n            if(aIsSymbol && bIsSymbol) {\r\n                //it has units then it's the Unit module's problem\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.pow(a, b);\r\n                }\r\n                \r\n                // Handle abs\r\n                if(a.group === FN && a.fname === ABS && even(b)) {\r\n                    var m = a.multiplier.clone();\r\n                    var raised = _.pow(a.args[0], b);\r\n                    raised.multiplier = m;\r\n                    return raised;\r\n                }\r\n                \r\n                // Handle infinity\r\n                if(a.isInfinity || b.isInfinity) {\r\n                    if(a.isInfinity && b.isInfinity)\r\n                        throw new UndefinedError('(' + a + ')^(' + b + ') is undefined!');\r\n\r\n                    if(a.isConstant() && b.isInfinity) {\r\n                        if(a.equals(0)) {\r\n                            if(b.lessThan(0))\r\n                                throw new UndefinedError('0^Infinity is undefined!');\r\n                            return new Symbol(0);\r\n                        }\r\n                        if(a.equals(1))\r\n                            throw new UndefinedError('1^' + b.toString() + ' is undefined!');\r\n                        //a^-oo\r\n                        if(b.lessThan(0))\r\n                            return new Symbol(0);\r\n                        //a^oo\r\n                        if(!a.lessThan(0))\r\n                            return Symbol.infinity();\r\n                    }\r\n\r\n                    if(a.isInfinity && b.isConstant()) {\r\n                        if(b.equals(0))\r\n                            throw new UndefinedError(a + '^0 is undefined!');\r\n                        if(b.lessThan(0))\r\n                            return new Symbol(0);\r\n                        return _.multiply(Symbol.infinity(), _.pow(new Symbol(a.sign()), b.clone()));\r\n                    }\r\n                }\r\n\r\n                var aIsZero = a.equals(0);\r\n                var bIsZero = b.equals(0);\r\n                if(aIsZero && bIsZero)\r\n                    throw new UndefinedError('0^0 is undefined!');\r\n\r\n                // Return 0 right away if possible\r\n                if(aIsZero && b.isConstant() && b.multiplier.greaterThan(0))\r\n                    return new Symbol(0);\r\n\r\n                if(bIsZero)\r\n                    return new Symbol(1);\r\n\r\n                var bIsConstant = b.isConstant(),\r\n                        aIsConstant = a.isConstant(),\r\n                        bIsInt = b.isInteger(),\r\n                        m = a.multiplier,\r\n                        result = a.clone();\r\n\r\n                // 0^0, 1/0, etc. Complain.\r\n                if(aIsConstant && bIsConstant && a.equals(0) && b.lessThan(0))\r\n                    throw new UndefinedError('Division by zero is not allowed!');\r\n\r\n                // Compute imaginary numbers right away\r\n                if(Settings.PARSE2NUMBER && aIsConstant && bIsConstant && a.sign() < 0 && evenFraction(b)) {\r\n                    var k, re, im;\r\n                    k = Math.PI * b;\r\n                    re = new Symbol(Math.cos(k));\r\n                    im = _.multiply(Symbol.imaginary(), new Symbol(Math.sin(k)));\r\n                    return _.add(re, im);\r\n                }\r\n\r\n                // Imaginary number under negative nthroot or to the n\r\n                if(Settings.PARSE2NUMBER && a.isImaginary() && bIsConstant && isInt(b) && !b.lessThan(0)) {\r\n                    var re, im, r, theta, nre, nim, phi;\r\n                    re = a.realpart();\r\n                    im = a.imagpart();\r\n                    if(re.isConstant('all') && im.isConstant('all')) {\r\n                        phi = Settings.USE_BIG ? Symbol(bigDec.atan2(i.multiplier.toDecimal(), r.multiplier.toDecimal()).times(b.toString())) : Math.atan2(im, re) * b;\r\n                        theta = new Symbol(phi);\r\n                        r = _.pow(Symbol.hyp(re, im), b);\r\n                        nre = _.multiply(r.clone(), _.trig.cos(theta.clone()));\r\n                        nim = _.multiply(r, _.trig.sin(theta));\r\n                        return _.add(nre, _.multiply(Symbol.imaginary(), nim));\r\n                    }\r\n                }\r\n\r\n                // Take care of the symbolic part\r\n                result.toUnitMultiplier();\r\n                //simpifly sqrt\r\n                if(result.group === FN && result.fname === SQRT && !bIsConstant) {\r\n                    var s = result.args[0];\r\n                    s.multiplyPower(new Symbol(0.5));\r\n                    s.multiplier.multiply(result.multiplier);\r\n                    s.multiplyPower(b);\r\n                    result = s;\r\n                }\r\n                else {\r\n                    var sign = m.sign();\r\n                    //handle cases such as (-a^3)^(1/4)\r\n                    if(evenFraction(b) && sign < 0) {\r\n                        // Swaperoo\r\n                        // First put the sign back on the symbol\r\n                        result.negate();\r\n                        // Wrap it in brackets\r\n                        result = _.symfunction(PARENTHESIS, [result]);\r\n                        // Move the sign back the exterior and let nerdamer handle the rest\r\n                        result.negate();\r\n                    }\r\n\r\n                    result.multiplyPower(b);\r\n                }\r\n\r\n                if(aIsConstant && bIsConstant && Settings.PARSE2NUMBER) {\r\n                    var c;\r\n                    //remove the sign\r\n                    if(sign < 0) {\r\n                        a.negate();\r\n                        if(b.multiplier.den.equals(2))\r\n                            //we know that the numerator has to be odd and therefore it's i\r\n                            c = new Symbol(Settings.IMAGINARY);\r\n                        else if(isInt(b.multiplier)) {\r\n                            if(even(b.multiplier))\r\n                                c = new Symbol(1);\r\n                            else\r\n                                c = new Symbol(-1);\r\n                        }\r\n                        else if(!even(b.multiplier.den)) {\r\n                            c = new Symbol(Math.pow(sign, b.multiplier.num));\r\n                        }\r\n                        else {\r\n                            c = _.pow(_.symfunction(PARENTHESIS, [new Symbol(sign)]), b.clone());\r\n                        }\r\n                    }\r\n\r\n                    result = new Symbol(Math.pow(a.multiplier.toDecimal(), b.multiplier.toDecimal()));\r\n\r\n                    //result = new Symbol(Math2.bigpow(a.multiplier, b.multiplier));\r\n                    //put the back sign\r\n                    if(c)\r\n                        result = _.multiply(result, c);\r\n                }\r\n                else if(bIsInt && !m.equals(1)) {\r\n                    var abs_b = b.abs();\r\n                    // Provide fall back to JS until big number implementation is improved\r\n                    if(abs_b.gt(Settings.MAX_EXP)) {\r\n                        if(b.sign() < 0)\r\n                            return new Symbol(0);\r\n                        return Symbol.infinity();\r\n                    }\r\n                    else {\r\n                        var p = b.multiplier.toDecimal();\r\n                        var sgn = Math.sign(p);\r\n                        p = Math.abs(p);\r\n                        var multiplier = new Frac(1);\r\n                        multiplier.num = m.num.pow(p);\r\n                        multiplier.den = m.den.pow(p);\r\n                        if(sgn < 0)\r\n                            multiplier.invert();\r\n                        //multiplying is justified since after mulltiplyPower if it was of group P it will now be of group N\r\n                        result.multiplier = result.multiplier.multiply(multiplier);\r\n                    }\r\n                }\r\n                else {\r\n                    var sign = a.sign();\r\n                    if(b.isConstant() && a.isConstant() && !b.multiplier.den.equals(1) && sign < 0) {\r\n                        //we know the sign is negative so if the denominator for b == 2 then it's i\r\n                        if(b.multiplier.den.equals(2)) {\r\n                            var i = new Symbol(Settings.IMAGINARY);\r\n                            a.negate();//remove the sign\r\n                            //if the power is negative then i is negative\r\n                            if(b.lessThan(0)) {\r\n                                i.negate();\r\n                                b.negate();//remove the sign from the power\r\n                            }\r\n                            //pull the power normally and put back the imaginary\r\n                            result = _.multiply(_.pow(a, b), i);\r\n                        }\r\n                        else {\r\n                            var aa = a.clone();\r\n                            aa.multiplier.negate();\r\n                            result = _.pow(_.symfunction(PARENTHESIS, [new Symbol(sign)]), b.clone());\r\n                            var _a = _.pow(new Symbol(aa.multiplier.num), b.clone());\r\n                            var _b = _.pow(new Symbol(aa.multiplier.den), b.clone());\r\n                            var r = _.divide(_a, _b);\r\n                            result = _.multiply(result, r);\r\n                        }\r\n                    }\r\n                    else if(Settings.PARSE2NUMBER && b.isImaginary()) {\r\n                        //4^(i + 2) = e^(- (2 - 4 i)  n + (2 + i) log(4))\r\n\r\n                        var re = b.realpart();\r\n                        var im = b.imagpart();\r\n                        /*\r\n                         if(b.group === CP && false) {\r\n                         var ex = _.pow(a.clone(), re);\r\n                         var xi = _.multiply(_.multiply(ex.clone(), trig.sin(im.clone())), Symbol.imaginary());\r\n                         var xa = _.multiply(trig.cos(im), ex);\r\n                         result = _.add(xi, xa);\r\n                         }\r\n                         else {\r\n                         */\r\n                        var aa = a.clone().toLinear();\r\n                        var a1 = _.pow(aa.clone(), re);\r\n                        var log_a = log(aa.clone());\r\n                        var b1 = trig.cos(_.multiply(im.clone(), log_a));\r\n                        var c1 = _.multiply(trig.sin(_.multiply(im, log(aa))), Symbol.imaginary());\r\n                        result = _.multiply(a1, _.add(b1, c1));\r\n                        result = _.expand(_.parse(result));\r\n                        /*\r\n                         }   \r\n                         */\r\n                    }\r\n                    else {\r\n                        //b is a symbol\r\n                        var neg_num = a.group === N && sign < 0,\r\n                            num = testSQRT(new Symbol(neg_num ? m.num : Math.abs(m.num)).setPower(b.clone())),\r\n                            den = testSQRT(new Symbol(m.den).setPower(b.clone()).invert());\r\n\r\n                        //eliminate imaginary if possible\r\n                        if(a.imaginary) {\r\n                            if(bIsInt) {\r\n                                var s, p, n;\r\n                                s = Math.sign(b);\r\n                                p = abs(b);\r\n                                n = p % 4;\r\n                                result = new Symbol(even(n) ? -1 : Settings.IMAGINARY);\r\n                                if(n === 0 || s < 0 && (n === 1) || s > 0 && (n === 3)) {\r\n                                    result.negate();\r\n                                }\r\n                            }\r\n                            else {\r\n                                //assume i = sqrt(-1) -> (-1)^(1/2)\r\n                                var nr = b.multiplier.multiply(Frac.quick(1, 2)),\r\n                                        //the denominator denotes the power so raise to it. It will turn positive it round\r\n                                        tn = Math.pow(-1, nr.num);\r\n                                result = even(nr.den) ? new Symbol(-1).setPower(nr, true) : new Symbol(tn);\r\n                            }\r\n                        }\r\n                        //ensure that the sign is carried by the symbol and not the multiplier\r\n                        //this enables us to check down the line if the multiplier can indeed be transferred\r\n                        if(sign < 0 && !neg_num)\r\n                            result.negate();\r\n\r\n                        //retain the absolute value\r\n                        if(bIsConstant && a.group !== EX) {\r\n                            var evenr = even(b.multiplier.den),\r\n                                    evenp = even(a.power),\r\n                                    n = result.power.toDecimal(),\r\n                                    evennp = even(n);\r\n                            if(evenr && evenp && !evennp) {\r\n                                if(n === 1)\r\n                                    result = _.symfunction(ABS, [result]);\r\n                                else if(!isInt(n)) {\r\n                                    var p = result.power;\r\n                                    result = _.symfunction(ABS, [result.toLinear()]).setPower(p);\r\n                                }\r\n                                else {\r\n                                    result = _.multiply(_.symfunction(ABS, [result.clone().toLinear()]),\r\n                                            result.clone().setPower(new Frac(n - 1)));\r\n                                }\r\n                                //quick workaround. Revisit\r\n                                if(Settings.POSITIVE_MULTIPLIERS && result.fname === ABS)\r\n                                    result = result.args[0];\r\n                            }\r\n                        }\r\n                        //multiply out sqrt\r\n                        if(b.equals(2) && result.group === CB) {\r\n                            var _result = new Symbol(1);\r\n                            result.each(function (sym) {\r\n                                _result = _.multiply(_result, _.pow(sym, b));\r\n                            });\r\n                            result = _result;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                result = testSQRT(result);\r\n\r\n                // Don't multiply until we've tested the remaining symbol\r\n                if(num && den) {\r\n                    result = _.multiply(result, testPow(_.multiply(num, den)));\r\n                }\r\n\r\n                // Reduce square root\r\n                if(result.fname === SQRT) {\r\n                    var isEX = result.group === EX;\r\n                    var t = isEX ? result.power.multiplier.toString() : result.power.toString();\r\n                    if(even(t)) {\r\n                        var pt = isEX ? _.divide(result.power, new Symbol(2)) : new Symbol(result.power.divide(new Frac(2))),\r\n                                m = result.multiplier;\r\n                        result = _.pow(result.args[0], pt);\r\n                        result.multiplier = result.multiplier.multiply(m);\r\n                    }\r\n                }\r\n                // Detect Euler's identity\r\n                else if(!Settings.IGNORE_E && result.isE() && result.group === EX && result.power.contains('pi')\r\n                        && result.power.contains(Settings.IMAGINARY) && b.group === CB) {\r\n                    var theta = b.stripVar(Settings.IMAGINARY);\r\n                    result = _.add(trig.cos(theta), _.multiply(Symbol.imaginary(), trig.sin(theta)));\r\n                }\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                if(isVector(a) && bIsSymbol) {\r\n                    a = a.map(function (x) {\r\n                        return _.pow(x, b.clone());\r\n                    });\r\n                }\r\n                else if(isMatrix(a) && bIsSymbol) {\r\n                    var M = new Matrix();\r\n                    a.eachElement(function (x, i, j) {\r\n                        M.set(i, j, _.pow(x, b.clone()));\r\n                    });\r\n                    a = M;\r\n                }\r\n                else if(aIsSymbol && isMatrix(b)) {\r\n                    var M = new Matrix();\r\n                    b.eachElement(function (x, i, j) {\r\n                        M.set(i, j, _.pow(a.clone(), x));\r\n                    });\r\n                    a = M;\r\n                }\r\n                return a;\r\n            }\r\n        };\r\n        // Gets called when the parser finds the , operator.\r\n        // Commas return a Collector object which is roughly an array\r\n        this.comma = function (a, b) {\r\n            if(!(a instanceof Collection))\r\n                a = Collection.create(a);\r\n            a.append(b);\r\n            return a;\r\n        };\r\n        // Link to modulus\r\n        this.mod = function (a, b) {\r\n            return mod(a, b);\r\n        };\r\n        // Used to slice elements from arrays\r\n        this.slice = function (a, b) {\r\n            return new Slice(a, b);\r\n        };\r\n        // The equality setter\r\n        this.equals = function (a, b) {\r\n            // Equality can only be set for group S so complain it's not\r\n            if(a.group !== S && !a.isLinear())\r\n                err('Cannot set equality for ' + a.toString());\r\n            VARS[a.value] = b.clone();\r\n            return b;\r\n        };\r\n        // Percent\r\n        this.percent = function (a) {\r\n            return _.divide(a, new Symbol(100));\r\n        };\r\n        // Set variable\r\n        this.assign = function (a, b) {\r\n            if(a instanceof Collection && b instanceof Collection) {\r\n                a.elements.map(function (x, i) {\r\n                    return _.assign(x, b.elements[i]);\r\n                });\r\n                return Vector.fromArray(b.elements);\r\n            }\r\n            if(a.parent) {\r\n                // It's referring to the parent instead. The current item can be discarded\r\n                var e = a.parent;\r\n                e.elements[e.getter] = b;\r\n                delete e.getter;\r\n                return e;\r\n            }\r\n\r\n            if(a.group !== S)\r\n                throw new NerdamerValueError('Cannot complete operation. Incorrect LH value for ' + a);\r\n            VARS[a.value] = b;\r\n            return b;\r\n        };\r\n        this.function_assign = function (a, b) {\r\n            var f = a.elements.pop();\r\n            return setFunction(f, a.elements, b);\r\n        };\r\n        // Function to quickly convert bools to Symbols\r\n        var bool2Symbol = function (x) {\r\n            return new Symbol(x === true ? 1 : 0);\r\n        };\r\n        //check for equality\r\n        this.eq = function (a, b) {\r\n            return bool2Symbol(a.equals(b));\r\n        };\r\n        //checks for greater than\r\n        this.gt = function (a, b) {\r\n            return bool2Symbol(a.gt(b));\r\n        };\r\n        //checks for greater than equal\r\n        this.gte = function (a, b) {\r\n            return bool2Symbol(a.gte(b));\r\n        };\r\n        //checks for less than\r\n        this.lt = function (a, b) {\r\n            return bool2Symbol(a.lt(b));\r\n        };\r\n        //checks for less than equal\r\n        this.lte = function (a, b) {\r\n            return bool2Symbol(a.lte(b));\r\n        };\r\n        // wraps the factorial\r\n        this.factorial = function (a) {\r\n            return this.symfunction(FACTORIAL, [a]);\r\n        };\r\n        // wraps the double factorial\r\n        this.dfactorial = function (a) {\r\n            return this.symfunction(DOUBLEFACTORIAL, [a]);\r\n        };\r\n    }\r\n    ;\r\n\r\n    /* \"STATIC\" */\r\n    // converts a number to a fraction.\r\n    var Fraction = {\r\n        /**\r\n         * Converts a decimal to a fraction\r\n         * @param {number} value\r\n         * @param {object} opts\r\n         * @returns {Array} - an array containing the denominator and the numerator\r\n         */\r\n        convert: function (value, opts) {\r\n            var frac;\r\n            if(value === 0) {\r\n                frac = [0, 1];\r\n            }\r\n            else {\r\n                if(value < 1e-6 || value > 1e20) {\r\n                    var qc = this.quickConversion(Number(value));\r\n                    if(qc[1] <= 1e20) {\r\n                        var abs = Math.abs(value);\r\n                        var sign = value / abs;\r\n                        frac = this.fullConversion(abs.toFixed((qc[1] + '').length - 1));\r\n                        frac[0] = frac[0] * sign;\r\n                    }\r\n                    else {\r\n                        frac = qc;\r\n                    }\r\n                }\r\n                else {\r\n                    frac = this.fullConversion(value);\r\n                }\r\n            }\r\n            return frac;\r\n        },\r\n        /**\r\n         * If the fraction is too small or too large this gets called instead of fullConversion method\r\n         * @param {number} dec\r\n         * @returns {Array} - an array containing the denominator and the numerator\r\n         */\r\n        quickConversion: function (value) {\r\n            var stripSign = function (s) {\r\n                // Explicitely convert to a string\r\n                if(typeof s !== 'string') {\r\n                    s = s.toString();\r\n                }\r\n\r\n                var sign = '';\r\n\r\n                // Remove and store the sign\r\n                var start = s.charAt(0);\r\n                if(start === '-') {\r\n                    s = s.substr(1, s.length);\r\n                    sign = '-';\r\n                }\r\n                else if(start === '+') {\r\n                    // Just remove the plus sign\r\n                    s = s.substr(1, s.length);\r\n                }\r\n\r\n                return {\r\n                    sign: sign,\r\n                    value: s\r\n                };\r\n            };\r\n\r\n\r\n            function convert(value) {\r\n                // Explicitely convert to a decimal\r\n                if(Scientific.isScientific(value)) {\r\n                    value = scientificToDecimal(value);\r\n                }\r\n\r\n                // Split the value into the sign and the value\r\n                var nparts = stripSign(value);\r\n\r\n                // Split it at the decimal. We'll refer to it as the coeffient parts\r\n                var cparts = nparts.value.split('.');\r\n\r\n                // Combine the entire number by removing leading zero and adding the decimal part\r\n                // This would be teh same as moving the decimal point to the end\r\n                var num;\r\n                // We're dealing with integers\r\n                if(cparts.length === 1) {\r\n                    num = cparts[0];\r\n                }\r\n                else {\r\n                    num = cparts[0] + cparts[1];\r\n                }\r\n                var n = cparts[1] ? cparts[1].length : 0;\r\n                // Generate the padding for the zeros\r\n                var den = `1${'0'.repeat(n)}`;\r\n\r\n                if(num !== '0') {\r\n                    num = num.replace(/^0+/, '');\r\n                }\r\n                return [nparts.sign + num, den];\r\n            }\r\n\r\n            return convert(value);\r\n        },\r\n        /**\r\n         * Returns a good approximation of a fraction. This method gets called by convert\r\n         * http://mathforum.org/library/drmath/view/61772.html\r\n         * Decimal To Fraction Conversion - A Simpler Version\r\n         * Dr Peterson\r\n         * @param {number} dec\r\n         * @returns {Array} - an array containing the denominator and the numerator\r\n         */\r\n        fullConversion: function (dec) {\r\n            var done = false;\r\n            // you can adjust the epsilon to a larger number if you don't need very high precision\r\n            var n1 = 0, d1 = 1, n2 = 1, d2 = 0, n = 0, q = dec, epsilon = 1e-16;\r\n            while(!done) {\r\n                n++;\r\n                if(n > 10000) {\r\n                    done = true;\r\n                }\r\n                var a = Math.floor(q);\r\n                var num = n1 + a * n2;\r\n                var den = d1 + a * d2;\r\n                var e = (q - a);\r\n                if(e < epsilon) {\r\n                    done = true;\r\n                }\r\n                q = 1 / e;\r\n                n1 = n2;\r\n                d1 = d2;\r\n                n2 = num;\r\n                d2 = den;\r\n                if(Math.abs(num / den - dec) < epsilon || n > 30) {\r\n                    done = true;\r\n                }\r\n            }\r\n            return [num, den];\r\n        }\r\n    };\r\n    //Depends on Fraction\r\n\r\n    //The latex generator\r\n    var LaTeX = {\r\n        parser: (function () {\r\n            // create a parser and strip it from everything except the items that you need\r\n            var keep = ['classes', 'setOperator', 'getOperators', 'getBrackets', 'tokenize', 'toRPN', 'tree', 'units'];\r\n            var parser = new Parser();\r\n            for(var x in parser) {\r\n                if(keep.indexOf(x) === -1)\r\n                    delete parser[x];\r\n            }\r\n            // declare the operators\r\n            parser.setOperator({\r\n                precedence: 8,\r\n                operator: '\\\\',\r\n                action: 'slash',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return e; // bypass the slash\r\n                }\r\n            });\r\n            parser.setOperator({\r\n                precedence: 8,\r\n                operator: '\\\\,',\r\n                action: 'slash_comma',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return e; // bypass the slash\r\n                }\r\n            });\r\n            // have braces not map to anything. We want them to be return as-is\r\n            var brackets = parser.getBrackets();\r\n            brackets['{'].maps_to = undefined;\r\n            return parser;\r\n        })(),\r\n        space: '~',\r\n        dot: ' \\\\cdot ',\r\n        // grab a list of supported functions but remove the excluded ones found in exclFN\r\n\r\n        latex: function (symbol, option) {\r\n            // it might be an array\r\n            if(symbol.clone) {\r\n                symbol = symbol.clone(); // leave original as-is\r\n            }\r\n            if(symbol instanceof _.classes.Collection)\r\n                symbol = symbol.elements;\r\n\r\n            if(isArray(symbol)) {\r\n                var LaTeXArray = [];\r\n                for(var i = 0; i < symbol.length; i++) {\r\n                    var sym = symbol[i];\r\n                    //This way I can generate LaTeX on an array of strings.\r\n                    if(!isSymbol(sym))\r\n                        sym = _.parse(sym);\r\n                    LaTeXArray.push(this.latex(sym, option));\r\n                }\r\n                return this.brackets(LaTeXArray.join(', '), 'square');\r\n            }\r\n\r\n            else if(isMatrix(symbol)) {\r\n                var TeX = '\\\\begin{pmatrix}\\n';\r\n                for(var i = 0; i < symbol.elements.length; i++) {\r\n                    var rowTeX = [],\r\n                            e = symbol.elements[i];\r\n                    for(var j = 0; j < e.length; j++) {\r\n                        rowTeX.push(this.latex(e[j], option));\r\n                    }\r\n                    TeX += rowTeX.join(' & ');\r\n                    if(i < symbol.elements.length - 1) {\r\n                        TeX += '\\\\\\\\\\n';\r\n                    }\r\n                }\r\n                TeX += '\\\\end{pmatrix}';\r\n                return TeX;\r\n            }\r\n\r\n            else if(isVector(symbol)) {\r\n                var TeX = '\\\\left[';\r\n                for(var i = 0; i < symbol.elements.length; i++) {\r\n                    TeX += this.latex(symbol.elements[i], option) + ' ' + (i !== symbol.elements.length - 1 ? ',\\\\,' : '');\r\n                }\r\n                TeX += '\\\\right]';\r\n                return TeX;\r\n            }\r\n\r\n            else if(isSet(symbol)) {\r\n                var TeX = '\\\\{';\r\n                for(var i = 0; i < symbol.elements.length; i++) {\r\n                    TeX += this.latex(symbol.elements[i], option) + ' ' + (i !== symbol.elements.length - 1 ? ',\\\\,' : '');\r\n                }\r\n                TeX += '\\\\}';\r\n                return TeX;\r\n            }\r\n\r\n            symbol = symbol.clone();\r\n\r\n            var decimal = (option === 'decimal' || option === 'decimals'),\r\n                    power = symbol.power,\r\n                    invert = isNegative(power),\r\n                    negative = symbol.multiplier.lessThan(0);\r\n\r\n            if(symbol.group === P && decimal) {\r\n                return String(symbol.multiplier.toDecimal() * Math.pow(symbol.value, symbol.power.toDecimal()));\r\n            }\r\n            else {\r\n                symbol.multiplier = symbol.multiplier.abs();\r\n\r\n                // if the user wants the result in decimal format then return it as such by placing it at the top part\r\n                var m_array;\r\n\r\n                if(decimal) {\r\n                    var m = String(symbol.multiplier.toDecimal());\r\n                    // if(String(m) === '1' && !decimal) m = '';\r\n                    m_array = [m, ''];\r\n                }\r\n                else {\r\n                    m_array = [symbol.multiplier.num, symbol.multiplier.den];\r\n                }\r\n                // get the value as a two part array\r\n                var v_array = this.value(symbol, invert, option, negative),\r\n                        p;\r\n                // make it all positive since we know whether to push the power to the numerator or denominator already.\r\n                if(invert)\r\n                    power.negate();\r\n                // the power is simple since it requires no additional formatting. We can get it to a\r\n                // string right away. pass in true to neglect unit powers\r\n                if(decimal) {\r\n                    p = isSymbol(power) ? LaTeX.latex(power, option) : String(power.toDecimal());\r\n                    if(String(p) === '1')\r\n                        p = '';\r\n                }\r\n                // get the latex representation\r\n                else if(isSymbol(power))\r\n                    p = this.latex(power, option);\r\n                // get it as a fraction\r\n                else\r\n                    p = this.formatFrac(power, true);\r\n                // use this array to specify if the power is getting attached to the top or the bottom\r\n                var p_array = ['', ''],\r\n                        // stick it to the top or the bottom. If it's negative then the power gets placed on the bottom\r\n                        index = invert ? 1 : 0;\r\n                p_array[index] = p;\r\n\r\n                // special case group P and decimal\r\n                var retval = (negative ? '-' : '') + this.set(m_array, v_array, p_array, symbol.group === CB);\r\n\r\n                return retval.replace(/\\+\\-/gi, '-');\r\n            }\r\n\r\n        },\r\n        // greek mapping\r\n        greek: {\r\n            alpha: '\\\\alpha',\r\n            beta: '\\\\beta',\r\n            gamma: '\\\\gamma',\r\n            delta: '\\\\delta',\r\n            epsilon: '\\\\epsilon',\r\n            zeta: '\\\\zeta',\r\n            eta: '\\\\eta',\r\n            theta: '\\\\theta',\r\n            iota: '\\\\iota',\r\n            kappa: '\\\\kappa',\r\n            lambda: '\\\\lambda',\r\n            mu: '\\\\mu',\r\n            nu: '\\\\nu',\r\n            xi: '\\\\xi',\r\n            omnikron: '\\\\omnikron',\r\n            pi: '\\\\pi',\r\n            rho: '\\\\rho',\r\n            sigma: '\\\\sigma',\r\n            tau: '\\\\tau',\r\n            upsilon: '\\\\upsilon',\r\n            phi: '\\\\phi',\r\n            chi: '\\\\chi',\r\n            psi: '\\\\psi',\r\n            omega: '\\\\omega',\r\n            Gamma: '\\\\Gamma',\r\n            Delta: '\\\\Delta',\r\n            Epsilon: '\\\\Epsilon',\r\n            Theta: '\\\\Theta',\r\n            Lambda: '\\\\Lambda',\r\n            Xi: '\\\\Xi',\r\n            Pi: '\\\\Pi',\r\n            Sigma: '\\\\Sigma',\r\n            Phi: '\\\\Phi',\r\n            Psi: '\\\\Psi',\r\n            Omega: '\\\\Omega'\r\n        },\r\n        symbols: {\r\n            arccos: '\\\\arccos',\r\n            cos: '\\\\cos',\r\n            csc: '\\\\csc',\r\n            exp: '\\\\exp',\r\n            ker: '\\\\ker',\r\n            limsup: '\\\\limsup',\r\n            min: '\\\\min',\r\n            sinh: '\\\\sinh',\r\n            arcsin: '\\\\arcsin',\r\n            cosh: '\\\\cosh',\r\n            deg: '\\\\deg',\r\n            gcd: '\\\\gcd',\r\n            lg: '\\\\lg',\r\n            ln: '\\\\ln',\r\n            Pr: '\\\\Pr',\r\n            sqrt: '\\\\sqrt',\r\n            sup: '\\\\sup',\r\n            arctan: '\\\\arctan',\r\n            cot: '\\\\cot',\r\n            det: '\\\\det',\r\n            hom: '\\\\hom',\r\n            lim: '\\\\lim',\r\n            log: '\\\\log',\r\n            LN: '\\\\LN',\r\n            sec: '\\\\sec',\r\n            tan: '\\\\tan',\r\n            arg: '\\\\arg',\r\n            coth: '\\\\coth',\r\n            dim: '\\\\dim',\r\n            inf: '\\\\inf',\r\n            liminf: '\\\\liminf',\r\n            max: '\\\\max',\r\n            sin: '\\\\sin',\r\n            tanh: '\\\\tanh'\r\n        },\r\n        // get the raw value of the symbol as an array\r\n        value: function (symbol, inverted, option, negative) {\r\n            var group = symbol.group,\r\n                    previousGroup = symbol.previousGroup,\r\n                    v = ['', ''],\r\n                    index = inverted ? 1 : 0;\r\n            /*if(group === N) // do nothing since we want to return top & bottom blank; */\r\n            if(symbol.isInfinity) {\r\n                v[index] = '\\\\infty';\r\n            }\r\n            else if(group === S || group === P || previousGroup === S || previousGroup === P || previousGroup === N) {\r\n                var value = this.formatSubscripts(symbol.value);\r\n                if(value.replace)\r\n                    value = value.replace(/(.+)_$/, '$1\\\\_');\r\n                // split it so we can check for instances of alpha as well as alpha_b\r\n                var t_varray = String(value).split('_');\r\n                var greek = this.greek[t_varray[0]];\r\n                if(greek) {\r\n                    t_varray[0] = greek;\r\n                    value = t_varray.join('_');\r\n                }\r\n                var symbol = this.symbols[t_varray[0]];\r\n                if(symbol) {\r\n                    t_varray[0] = symbol;\r\n                    value = t_varray.join('_');\r\n                }\r\n                v[index] = value;\r\n            }\r\n            else if(group === FN || previousGroup === FN) {\r\n                var name,\r\n                        input = [],\r\n                        fname = symbol.fname;\r\n                // collect the arguments\r\n                for(var i = 0; i < symbol.args.length; i++) {\r\n                    var arg = symbol.args[i], item;\r\n                    if(typeof arg === 'string')\r\n                        item = arg;\r\n                    else {\r\n                        item = this.latex(arg, option);\r\n                    }\r\n                    input.push(item);\r\n                }\r\n\r\n                if(fname === SQRT) {\r\n                    v[index] = '\\\\sqrt' + this.braces(input.join(','));\r\n                }\r\n                else if(fname === ABS) {\r\n                    v[index] = this.brackets(input.join(','), 'abs');\r\n                }\r\n                else if(fname === PARENTHESIS) {\r\n                    v[index] = this.brackets(input.join(','), 'parens');\r\n                }\r\n                else if(fname === 'limit') {\r\n                    v[index] = ' \\\\lim\\\\limits_{' + input[1] + ' \\\\to ' + input[2] + '} ' + input[0];\r\n                }\r\n                else if(fname === 'integrate') {\r\n                    v[index] = '\\\\int' + this.braces(input[0]) + this.braces('d' + input[1]);\r\n                }\r\n                else if(fname === 'defint') {\r\n                    v[index] = '\\\\int\\\\limits_' + this.braces(input[1]) + '^' + this.braces(input[2]) + ' ' + input[0] + ' d' + input[3];\r\n                }\r\n                else if(fname === FACTORIAL || fname === DOUBLEFACTORIAL) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.power.equals(1) && (arg.isComposite() || arg.isCombination())) {\r\n                        input[0] = this.brackets(input[0]);\r\n                    }\r\n                    v[index] = input[0] + (fname === FACTORIAL ? '!' : '!!');\r\n                }\r\n                else if(fname === 'floor') {\r\n                    v[index] = '\\\\left \\\\lfloor' + this.braces(input[0]) + '\\\\right \\\\rfloor';\r\n                }\r\n                else if(fname === 'ceil') {\r\n                    v[index] = '\\\\left \\\\lceil' + this.braces(input[0]) + '\\\\right \\\\rceil';\r\n                }\r\n                // capture log(a, b)\r\n                else if(fname === Settings.LOG && input.length > 1) {\r\n                    v[index] = '\\\\mathrm' + this.braces(Settings.LOG) + '_' + this.braces(input[1]) + this.brackets(input[0]);\r\n                }\r\n                // capture log(a, b)\r\n                else if(fname === Settings.LOG10) {\r\n                    v[index] = '\\\\mathrm' + this.braces(Settings.LOG) + '_' + this.braces(10) + this.brackets(input[0]);\r\n                }\r\n                else if(fname === 'sum') {\r\n                    var a = input[0],\r\n                            b = input[1],\r\n                            c = input[2],\r\n                            d = input[3];\r\n                    v[index] = '\\\\sum\\\\limits_{' + this.braces(b) + '=' + this.braces(c) + '}^' + this.braces(d) + ' ' + this.braces(a) + '';\r\n                }\r\n                else if(fname === 'product') {\r\n                    var a = input[0],\r\n                            b = input[1],\r\n                            c = input[2],\r\n                            d = input[3];\r\n                    v[index] = '\\\\prod\\\\limits_{' + this.braces(b) + '=' + this.braces(c) + '}^' + this.braces(d) + ' ' + this.braces(a) + '';\r\n                }\r\n                else if(fname === 'nthroot') {\r\n                    v[index] = '\\\\sqrt[' + input[1] + ']' + this.braces(input[0]);\r\n                }\r\n                else if(fname === 'mod') {\r\n                    v[index] = input[0] + ' \\\\bmod ' + input[1];\r\n                }\r\n                else if(fname === 'realpart') {\r\n                    v[index] = '\\\\operatorname{Re}' + this.brackets(input[0]);\r\n                }\r\n                else if(fname === 'imagpart') {\r\n                    v[index] = '\\\\operatorname{Im}' + this.brackets(input[0]);\r\n                }\r\n                else {\r\n                    var name = fname !== '' ? '\\\\mathrm' + this.braces(fname.replace(/_/g, '\\\\_')) : '';\r\n                    if(symbol.isConversion)\r\n                        v[index] = name + this.brackets(input.join(''), 'parens');\r\n                    else\r\n                        v[index] = name + this.brackets(input.join(','), 'parens');\r\n                }\r\n            }\r\n            else if(symbol.isComposite()) {\r\n                var collected = symbol.collectSymbols().sort(\r\n                        group === CP || previousGroup === CP ?\r\n                        function (a, b) {\r\n                            return b.group - a.group;\r\n                        } :\r\n                        function (a, b) {\r\n                            var x = isSymbol(a.power) ? -1 : a.power;\r\n                            var y = isSymbol(b.power) ? -1 : b.power;\r\n                            return y - x;\r\n                        }\r\n                ),\r\n                        symbols = [],\r\n                        l = collected.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    symbols.push(LaTeX.latex(collected[i], option));\r\n                }\r\n                var value = symbols.join('+');\r\n\r\n                v[index] = !(symbol.isLinear() && symbol.multiplier.equals(1)) || negative ? this.brackets(value, 'parens') : value;\r\n            }\r\n            else if(group === CB || previousGroup === EX || previousGroup === CB) {\r\n                if(group === CB)\r\n                    symbol.distributeExponent();\r\n                // This almost feels a little like cheating but I need to know if I should be wrapping the symbol\r\n                // in brackets or not. We'll do this by checking the value of the numerator and then comparing it\r\n                // to whether the symbol value is \"simple\" or not.\r\n                var denominator = [],\r\n                        numerator = [];\r\n                // Generate a profile\r\n                var den_map = [], num_map = [], num_c = 0, den_c = 0;\r\n                var setBrackets = function (container, map, counter) {\r\n                    if(counter > 1 && map.length > 0) {\r\n                        var l = map.length;\r\n                        for(var i = 0; i < l; i++) {\r\n                            var idx = map[i], item = container[idx];\r\n                            if(!(/^\\\\left\\(.+\\\\right\\)\\^\\{.+\\}$/g.test(item) || /^\\\\left\\(.+\\\\right\\)$/g.test(item))) {\r\n                                container[idx] = LaTeX.brackets(item, 'parens');\r\n                            }\r\n                        }\r\n                    }\r\n                    return container;\r\n                };\r\n\r\n                // Generate latex for each of them\r\n                symbol.each(function (x) {\r\n                    var isDenom = isNegative(x.power),\r\n                            laTex;\r\n\r\n                    if(isDenom) {\r\n                        laTex = LaTeX.latex(x.invert(), option);\r\n                        den_c++;\r\n                        if(x.isComposite()) {\r\n                            if(symbol.multiplier.den != 1 && Math.abs(x.power) == 1)\r\n                                laTex = LaTeX.brackets(laTex, 'parens');\r\n                            den_map.push(denominator.length); // make a note of where the composite was found\r\n                        }\r\n\r\n                        denominator.push(laTex);\r\n                    }\r\n                    else {\r\n                        laTex = LaTeX.latex(x, option);\r\n                        num_c++;\r\n                        if(x.isComposite()) {\r\n                            if(symbol.multiplier.num != 1 && Math.abs(x.power) == 1)\r\n                                laTex = LaTeX.brackets(laTex, 'parens');\r\n                            num_map.push(numerator.length);   // make a note of where the composite was found\r\n                        }\r\n                        numerator.push(laTex);\r\n                    }\r\n                });\r\n\r\n                // Apply brackets\r\n                setBrackets(numerator, num_map, num_c);\r\n                v[0] = numerator.join(this.dot); // collapse the numerator into one string\r\n\r\n                setBrackets(denominator, den_map, den_c);\r\n                v[1] = denominator.join(this.dot);\r\n            }\r\n\r\n            return v;\r\n        },\r\n        set: function (m, v, p, combine_power) {\r\n            var isBracketed = function (v) {\r\n                return /^\\\\left\\(.+\\\\right\\)$/.test(v);\r\n            };\r\n            // format the power if it exists\r\n            if(p)\r\n                p = this.formatP(p);\r\n            // group CB will have to be wrapped since the power applies to both it's numerator and denominator\r\n            if(combine_power) {\r\n                // POSSIBLE BUG: If powers for group CB format wrong, investigate this since I might have overlooked something\r\n                // the assumption is that in every case the denonimator should be empty when dealing with CB. I can't think\r\n                // of a case where this isn't true\r\n                var tp = p[0];\r\n                p[0] = ''; // temporarily make p blank\r\n            }\r\n\r\n            // merge v and p. Not that v MUST be first since the order matters\r\n            v = this.merge(v, p);\r\n            var mn = m[0], md = m[1], vn = v[0], vd = v[1];\r\n            // filters\r\n            // if the top has a variable but the numerator is one drop it\r\n            if(vn && Number(mn) === 1)\r\n                mn = '';\r\n            // if denominator is 1 drop it always\r\n            if(Number(md) === 1)\r\n                md = '';\r\n            // prepare the top portion but check that it's not already bracketed. If it is then leave out the cdot\r\n            var top = this.join(mn, vn, !isBracketed(vn) ? this.dot : '');\r\n\r\n            // prepare the bottom portion but check that it's not already bracketed. If it is then leave out the cdot\r\n            var bottom = this.join(md, vd, !isBracketed(vd) ? this.dot : '');\r\n            // format the power if it exists\r\n            // make it a fraction if both top and bottom exists\r\n            if(top && bottom) {\r\n                var frac = this.frac(top, bottom);\r\n                if(combine_power && tp)\r\n                    frac = this.brackets(frac) + tp;\r\n                return frac;\r\n            }\r\n            // otherwise only the top exists so return that\r\n            else\r\n                return top;\r\n        },\r\n        merge: function (a, b) {\r\n            var r = [];\r\n            for(var i = 0; i < 2; i++)\r\n                r[i] = a[i] + b[i];\r\n            return r;\r\n        },\r\n        // joins together two strings if both exist\r\n        join: function (n, d, glue) {\r\n            if(!n && !d)\r\n                return '';\r\n            if(n && !d)\r\n                return n;\r\n            if(d && !n)\r\n                return d;\r\n            return n + glue + d;\r\n        },\r\n        /**\r\n         * Places subscripts in braces for proper formatting\r\n         * @param {String} v\r\n         * @returns {String}\r\n         */\r\n        formatSubscripts: function (v) {\r\n            // Split it at the underscore\r\n            var arr = v.toString().split('_');\r\n\r\n            var name = '';\r\n\r\n            // Loop over all entries except the first one\r\n            while(arr.length > 1) {\r\n                // Wrap all in braces except for the last one\r\n                if(arr.length > 0) {\r\n                    name = '_' + this.braces(arr.pop() + name);\r\n                }\r\n            }\r\n\r\n            return arr[0] + name;\r\n        },\r\n        formatP: function (p_array) {\r\n            for(var i = 0; i < 2; i++) {\r\n                var p = p_array[i];\r\n                if(p)\r\n                    p_array[i] = '^' + this.braces(p);\r\n            }\r\n            return p_array;\r\n        },\r\n        /**\r\n         * formats the fractions accordingly.\r\n         * @param {Frac} f\r\n         * @param {bool} is_pow\r\n         */\r\n        formatFrac: function (f, is_pow) {\r\n            var n = f.num.toString(),\r\n                    d = f.den.toString();\r\n            // no need to have x^1\r\n            if(is_pow && n === '1' && d === '1')\r\n                return '';\r\n            // no need to have x/1\r\n            if(d === '1')\r\n                return n;\r\n            return this.frac(n, d);\r\n        },\r\n        frac: function (n, d) {\r\n            return '\\\\frac' + this.braces(n) + this.braces(d);\r\n        },\r\n        braces: function (e) {\r\n            return '{' + e + '}';\r\n        },\r\n        brackets: function (e, typ) {\r\n            typ = typ || 'parens';\r\n            var bracketTypes = {\r\n                parens: ['(', ')'],\r\n                square: ['[', ']'],\r\n                brace: ['{', '}'],\r\n                abs: ['|', '|'],\r\n                angle: ['\\\\langle', '\\\\rangle']\r\n            };\r\n            var bracket = bracketTypes[typ];\r\n            return '\\\\left' + bracket[0] + e + '\\\\right' + bracket[1];\r\n        },\r\n        /**\r\n         * Removes extreneous tokens\r\n         * @param {Tokens[]} tokens\r\n         * @returns {Tokens[]}\r\n         */\r\n        filterTokens: function (tokens) {\r\n            var filtered = [];\r\n\r\n            // Copy over the type of the scope\r\n            if(isArray(tokens)) {\r\n                filtered.type = tokens.type;\r\n            }\r\n\r\n            // the items that need to be disposed\r\n            var d = ['\\\\', 'left', 'right', 'big', 'Big', 'large', 'Large'];\r\n            for(var i = 0, l = tokens.length; i < l; i++) {\r\n                var token = tokens[i];\r\n                var next_token = tokens[i + 1];\r\n                if(token.value === '\\\\' && next_token.value === '\\\\') {\r\n                    filtered.push(token);\r\n                }\r\n                else if(isArray(token)) {\r\n                    filtered.push(LaTeX.filterTokens(token));\r\n                }\r\n                else if(d.indexOf(token.value) === -1) {\r\n                    filtered.push(token);\r\n                }\r\n            }\r\n            return filtered;\r\n        },\r\n        /*\r\n         * Parses tokens from LaTeX string. Does not do any error checking\r\n         * @param {Tokens[]} rpn\r\n         * @returns {String}\r\n         */\r\n        parse: function (raw_tokens) {\r\n            var i, l;\r\n            var retval = '';\r\n            var tokens = this.filterTokens(raw_tokens);\r\n            var replace = {\r\n                'cdot': '',\r\n                'times': '',\r\n                'infty': 'Infinity'\r\n            };\r\n            // get the next token\r\n            var next = function (n) {\r\n                return tokens[(typeof n === 'undefined' ? ++i : i += n)];\r\n            };\r\n            var parse_next = function () {\r\n                return LaTeX.parse(next());\r\n            };\r\n            var get = function (token) {\r\n                if(token in replace) {\r\n                    return replace[token];\r\n                }\r\n                // A quirk with implicit multiplication forces us to check for *\r\n                if(token === '*' && tokens[i + 1].value === '&') {\r\n                    next(2); // skip this and the &\r\n                    return ',';\r\n                }\r\n\r\n                if(token === '&') {\r\n                    next();\r\n                    return ','; // Skip the *\r\n                }\r\n                // If it's the end of a row, return the row separator\r\n                if(token === '\\\\') {\r\n                    return '],[';\r\n                }\r\n                return token;\r\n            };\r\n\r\n            // start parsing the tokens\r\n            for(i = 0, l = tokens.length; i < l; i++) {\r\n                var token = tokens[i];\r\n                // fractions\r\n                if(token.value === 'frac') {\r\n                    // parse and wrap it in brackets\r\n                    var n = parse_next();\r\n                    var d = parse_next();\r\n                    retval += n + '/' + d;\r\n                }\r\n                else if(token.value in LaTeX.symbols) {\r\n                    if(token.value === SQRT && tokens[i + 1].type === 'vector' && tokens[i + 2].type === 'Set') {\r\n                        var base = parse_next();\r\n                        var expr = parse_next();\r\n                        retval += (expr + '^' + inBrackets('1/' + base));\r\n                    }\r\n                    else {\r\n                        retval += token.value + parse_next();\r\n                    }\r\n                }\r\n                else if(token.value === 'int') {\r\n                    var f = parse_next();\r\n                    // skip the comma\r\n                    i++;\r\n                    // get the variable of integration\r\n                    var dx = next().value;\r\n                    dx = get(dx.substring(1, dx.length));\r\n                    retval += 'integrate' + inBrackets(f + ',' + dx);\r\n                }\r\n                else if(token.value === 'int_') {\r\n                    var l = parse_next(); // lower\r\n                    i++; // skip the ^\r\n                    var u = next().value; // upper\r\n                    // if it is in brackets\r\n                    if (u === undefined) {\r\n                        i--;\r\n                        var u = parse_next();\r\n                    }\r\n                    var f = parse_next(); // function\r\n                    \r\n                    // get the variable of integration\r\n                    var dx = next().value;\r\n                    // skip the comma\r\n                    if (dx === ',') {\r\n                        var dx = next().value;\r\n                    }\r\n                    // if 'd', skip\r\n                    if (dx === 'differentialD') {\r\n                        // skip the *\r\n                        i++;\r\n                        var dx = next().value;\r\n                    }\r\n                    if (dx === 'mathrm') {\r\n                        // skip the mathrm{d}\r\n                        i++;\r\n                        var dx = next().value;\r\n                    }\r\n                    retval += 'defint' + inBrackets(f + ',' + l + ',' + u + ',' + dx);\r\n                }\r\n                else if(token.value && token.value.startsWith('int_')) {\r\n                    // var l = parse_next(); // lower\r\n                    var l = token.value.replace('int_', '')\r\n                    console.log('uppernow')\r\n                    i++; // skip the ^\r\n                    var u = next().value; // upper\r\n                    // if it is in brackets\r\n                    if (u === undefined) {\r\n                        i--;\r\n                        var u = parse_next();\r\n                    }\r\n                    var f = parse_next(); // function\r\n                    \r\n                    // get the variable of integration\r\n                    var dx = next().value;\r\n                    // skip the comma\r\n                    if (dx === ',') {\r\n                        var dx = next().value;\r\n                    }\r\n                    // if 'd', skip\r\n                    if (dx === 'differentialD') {\r\n                        // skip the *\r\n                        i++;\r\n                        var dx = next().value;\r\n                    }\r\n                    if (dx === 'mathrm') {\r\n                        // skip the mathrm{d}\r\n                        i++;\r\n                        var dx = next().value;\r\n                    }\r\n                    retval += 'defint' + inBrackets(f + ',' + l + ',' + u + ',' + dx);\r\n                }\r\n                else if(token.value === 'mathrm') {\r\n                    var f = tokens[++i][0].value;\r\n                    retval += f + parse_next();\r\n                }\r\n                // sum and product\r\n                else if(token.value === 'sum_' || token.value === 'prod_') {\r\n                    var fn = token.value === 'sum_' ? 'sum' : 'product';\r\n                    var nxt = next();\r\n                    i++; // skip the caret\r\n                    var end = parse_next();\r\n                    var f = parse_next();\r\n                    retval += fn + inBrackets([f, get(nxt[0]), get(nxt[2]), get(end)].join(','));\r\n                }\r\n                else if(token.value === 'lim_') {\r\n                    var nxt = next();\r\n                    retval += 'limit' + inBrackets([parse_next(), get(nxt[0]), get(nxt[2])].join(','));\r\n                }\r\n                else if(token.value === 'begin') {\r\n                    var nxt = next();\r\n                    if(Array.isArray(nxt)) {\r\n                        var v = nxt[0].value;\r\n                        if(v === 'matrix') {\r\n                            // Start a matrix\r\n                            retval += 'matrix([';\r\n                        }\r\n                    }\r\n                }\r\n                else if(token.value === 'end') {\r\n                    var nxt = next();\r\n                    if(Array.isArray(nxt)) {\r\n                        var v = nxt[0].value;\r\n                        if(v === 'matrix') {\r\n                            // End a matrix\r\n                            retval += '])';\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if(Array.isArray(token)) {\r\n                        retval += get(LaTeX.parse(token));\r\n                    }\r\n                    else {\r\n                        retval += get(token.value.toString());\r\n                    }\r\n                }\r\n            }\r\n\r\n            return inBrackets(retval);\r\n        }\r\n    };\r\n//Vector =======================================================================\r\n    function Vector(v) {\r\n        if(isVector(v))\r\n            this.elements = v.items.slice(0);\r\n        else if(isArray(v))\r\n            this.elements = v.slice(0);\r\n        else\r\n            this.elements = [].slice.call(arguments);\r\n    }\r\n    /*\r\n     * Generates a pre-filled array\r\n     * @param {type} n\r\n     * @param {type} val\r\n     * @returns {unresolved}\r\n     */\r\n    Vector.arrayPrefill = function (n, val) {\r\n        var a = [];\r\n        val = val || 0;\r\n        for(var i = 0; i < n; i++)\r\n            a[i] = val;\r\n        return a;\r\n    };\r\n    /**\r\n     * Generate a vector from and array\r\n     * @param {type} a\r\n     * @returns {unresolved}\r\n     */\r\n    Vector.fromArray = function (a) {\r\n        var v = new Vector();\r\n        v.elements = a;\r\n        return v;\r\n    };\r\n\r\n    /**\r\n     * Convert a Set to a Vector\r\n     * @param {Set} set\r\n     * @returns {Vector}\r\n     */\r\n    Vector.fromSet = function (set) {\r\n        return Vector.fromArray(set.elements);\r\n    };\r\n\r\n    //Ported from Sylvester.js\r\n    Vector.prototype = {\r\n        custom: true,\r\n        // Returns element i of the vector\r\n        e: function (i) {\r\n            return (i < 1 || i > this.elements.length) ? null : this.elements[i - 1];\r\n        },\r\n\r\n        set: function (i, val) {\r\n            if(!isSymbol(val))\r\n                val = new Symbol(val);\r\n            this.elements[i] = val;\r\n        },\r\n\r\n        // Returns the number of elements the vector has\r\n        dimensions: function () {\r\n            return this.elements.length;\r\n        },\r\n\r\n        // Returns the modulus ('length') of the vector\r\n        modulus: function () {\r\n            return block('SAFE', function () {\r\n                return _.pow((this.dot(this.clone())), new Symbol(0.5));\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns true iff the vector is equal to the argument\r\n        eql: function (vector) {\r\n            var n = this.elements.length;\r\n            var V = vector.elements || vector;\r\n            if(n !== V.length) {\r\n                return false;\r\n            }\r\n            do {\r\n                if(Math.abs(_.subtract(this.elements[n - 1], V[n - 1]).valueOf()) > PRECISION) {\r\n                    return false;\r\n                }\r\n            }\r\n            while(--n);\r\n            return true;\r\n        },\r\n\r\n        // Returns a clone of the vector\r\n        clone: function () {\r\n            var V = new Vector(),\r\n                    l = this.elements.length;\r\n            for(var i = 0; i < l; i++) {\r\n                //Rule: all items within the vector must have a clone method.\r\n                V.elements.push(this.elements[i].clone());\r\n            }\r\n            if(this.getter) {\r\n                V.getter = this.getter.clone();\r\n            }\r\n            return V;\r\n        },\r\n\r\n        // Maps the vector to another vector according to the given function\r\n        map: function (fn) {\r\n            var elements = [];\r\n            this.each(function (x, i) {\r\n                elements.push(fn(x, i));\r\n            });\r\n\r\n            return new Vector(elements);\r\n        },\r\n\r\n        // Calls the iterator for each element of the vector in turn\r\n        each: function (fn) {\r\n            var n = this.elements.length, k = n, i;\r\n            do {\r\n                i = k - n;\r\n                fn(this.elements[i], i + 1);\r\n            }\r\n            while(--n);\r\n        },\r\n\r\n        // Returns a new vector created by normalizing the receiver\r\n        toUnitVector: function () {\r\n            return block('SAFE', function () {\r\n                var r = this.modulus();\r\n                if(r.valueOf() === 0) {\r\n                    return this.clone();\r\n                }\r\n                return this.map(function (x) {\r\n                    return _.divide(x, r);\r\n                });\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the angle between the vector and the argument (also a vector)\r\n        angleFrom: function (vector) {\r\n            return block('SAFE', function () {\r\n                var V = vector.elements || vector;\r\n                var n = this.elements.length;\r\n                if(n !== V.length) {\r\n                    return null;\r\n                }\r\n                var dot = new Symbol(0), mod1 = new Symbol(0), mod2 = new Symbol(0);\r\n                // Work things out in parallel to save time\r\n                this.each(function (x, i) {\r\n                    dot = _.add(dot, _.multiply(x, V[i - 1]));\r\n                    mod1 = _.add(mod1, _.multiply(x, x));// will not conflict in safe block\r\n                    mod2 = _.add(mod2, _.multiply(V[i - 1], V[i - 1]));// will not conflict in safe block\r\n                });\r\n                mod1 = _.pow(mod1, new Symbol(0.5));\r\n                mod2 = _.pow(mod2, new Symbol(0.5));\r\n                var product = _.multiply(mod1, mod2);\r\n                if(product.valueOf() === 0) {\r\n                    return null;\r\n                }\r\n                var theta = _.divide(dot, product);\r\n                var theta_val = theta.valueOf();\r\n                if(theta_val < -1) {\r\n                    theta = -1;\r\n                }\r\n                if(theta_val > 1) {\r\n                    theta = 1;\r\n                }\r\n                return new Symbol(Math.acos(theta));\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns true iff the vector is parallel to the argument\r\n        isParallelTo: function (vector) {\r\n            var angle = this.angleFrom(vector).valueOf();\r\n            return (angle === null) ? null : (angle <= PRECISION);\r\n        },\r\n\r\n        // Returns true iff the vector is antiparallel to the argument\r\n        isAntiparallelTo: function (vector) {\r\n            var angle = this.angleFrom(vector).valueOf();\r\n            return (angle === null) ? null : (Math.abs(angle - Math.PI) <= PRECISION);\r\n        },\r\n\r\n        // Returns true iff the vector is perpendicular to the argument\r\n        isPerpendicularTo: function (vector) {\r\n            var dot = this.dot(vector);\r\n            return (dot === null) ? null : (Math.abs(dot) <= PRECISION);\r\n        },\r\n\r\n        // Returns the result of adding the argument to the vector\r\n        add: function (vector) {\r\n            return block('SAFE', function () {\r\n                var V = vector.elements || vector;\r\n                if(this.elements.length !== V.length) {\r\n                    return null;\r\n                }\r\n                return this.map(function (x, i) {\r\n                    return _.add(x, V[i - 1]);\r\n                });\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the result of subtracting the argument from the vector\r\n        subtract: function (vector) {\r\n            return block('SAFE', function () {\r\n                var V = vector.elements || vector;\r\n                if(this.elements.length !== V.length) {\r\n                    return null;\r\n                }\r\n                return this.map(function (x, i) {\r\n                    return _.subtract(x, V[i - 1]);\r\n                });\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the result of multiplying the elements of the vector by the argument\r\n        multiply: function (k) {\r\n            return this.map(function (x) {\r\n                return x.clone() * k.clone();\r\n            });\r\n        },\r\n\r\n        x: function (k) {\r\n            return this.multiply(k);\r\n        },\r\n\r\n        // Returns the scalar product of the vector with the argument\r\n        // Both vectors must have equal dimensionality\r\n        dot: function (vector) {\r\n            return block('SAFE', function () {\r\n                var V = vector.elements || vector;\r\n                var product = new Symbol(0), n = this.elements.length;\r\n                if(n !== V.length) {\r\n                    return null;\r\n                }\r\n                do {\r\n                    product = _.add(product, _.multiply(this.elements[n - 1], V[n - 1]));\r\n                }\r\n                while(--n);\r\n                return product;\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the vector product of the vector with the argument\r\n        // Both vectors must have dimensionality 3\r\n        cross: function (vector) {\r\n            var B = vector.elements || vector;\r\n            if(this.elements.length !== 3 || B.length !== 3) {\r\n                return null;\r\n            }\r\n            var A = this.elements;\r\n            return block('SAFE', function () {\r\n                return new Vector([\r\n                    _.subtract(_.multiply(A[1], B[2]), _.multiply(A[2], B[1])),\r\n                    _.subtract(_.multiply(A[2], B[0]), _.multiply(A[0], B[2])),\r\n                    _.subtract(_.multiply(A[0], B[1]), _.multiply(A[1], B[0]))\r\n                ]);\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the (absolute) largest element of the vector\r\n        max: function () {\r\n            var m = 0, n = this.elements.length, k = n, i;\r\n            do {\r\n                i = k - n;\r\n                if(Math.abs(this.elements[i].valueOf()) > Math.abs(m.valueOf())) {\r\n                    m = this.elements[i];\r\n                }\r\n            }\r\n            while(--n);\r\n            return m;\r\n        },\r\n        magnitude: function () {\r\n            var magnitude = new Symbol(0);\r\n            this.each(function (e) {\r\n                magnitude = _.add(magnitude, _.pow(e, new Symbol(2)));\r\n            });\r\n            return _.sqrt(magnitude);\r\n        },\r\n        // Returns the index of the first match found\r\n        indexOf: function (x) {\r\n            var index = null, n = this.elements.length, k = n, i;\r\n            do {\r\n                i = k - n;\r\n                if(index === null && this.elements[i].valueOf() === x.valueOf()) {\r\n                    index = i + 1;\r\n                }\r\n            }\r\n            while(--n);\r\n            return index;\r\n        },\r\n        text: function (x) {\r\n            return text(this);\r\n        },\r\n        toString: function () {\r\n            return this.text();\r\n        },\r\n        latex: function (option) {\r\n            var tex = [];\r\n            for(var i = 0; i < this.elements.length; i++) {\r\n                tex.push(LaTeX.latex.call(LaTeX, this.elements[i], option));\r\n            }\r\n            return '[' + tex.join(', ') + ']';\r\n        }\r\n    };\r\n\r\n//Matrix =======================================================================\r\n    function Matrix() {\r\n        var m = arguments,\r\n                l = m.length, i, el = [];\r\n        if(isMatrix(m)) { // if it's a matrix then make a clone\r\n            for(i = 0; i < l; i++) {\r\n                el.push(m[i].slice(0));\r\n            }\r\n        }\r\n        else {\r\n            var row, lw, rl;\r\n            for(i = 0; i < l; i++) {\r\n                row = m[i];\r\n                if(isVector(row))\r\n                    row = row.elements;\r\n                if(!isArray(row))\r\n                    row = [row];\r\n                rl = row.length;\r\n                if(lw && lw !== rl)\r\n                    err('Unable to create Matrix. Row dimensions do not match!');\r\n                el.push(row);\r\n                lw = rl;\r\n            }\r\n        }\r\n        this.elements = el;\r\n    }\r\n    Matrix.identity = function (n) {\r\n        var m = new Matrix();\r\n        for(var i = 0; i < n; i++) {\r\n            m.elements.push([]);\r\n            for(var j = 0; j < n; j++) {\r\n                m.set(i, j, i === j ? new Symbol(1) : new Symbol(0));\r\n            }\r\n        }\r\n        return m;\r\n    };\r\n    Matrix.fromArray = function (arr) {\r\n        function F(args) {\r\n            return Matrix.apply(this, args);\r\n        }\r\n        F.prototype = Matrix.prototype;\r\n\r\n        return new F(arr);\r\n    };\r\n    Matrix.zeroMatrix = function (rows, cols) {\r\n        var m = new Matrix();\r\n        for(var i = 0; i < rows; i++) {\r\n            m.elements.push(Vector.arrayPrefill(cols, new Symbol(0)));\r\n        }\r\n        return m;\r\n    };\r\n    Matrix.prototype = {\r\n        // needs be true to let the parser know not to try to cast it to a symbol\r\n        custom: true,\r\n        get: function (row, column) {\r\n            if(!this.elements[row])\r\n                return undefined;\r\n            return this.elements[row][column];\r\n        },\r\n        map: function (f, raw_values) {\r\n            var M = new Matrix();\r\n            this.each(function (e, i, j) {\r\n                M.set(i, j, f.call(M, e), raw_values);\r\n            });\r\n            return M;\r\n        },\r\n        set: function (row, column, value, raw) {\r\n            if(!this.elements[row])\r\n                this.elements[row] = [];\r\n            this.elements[row][column] = raw ? value : (isSymbol(value) ? value : new Symbol(value));\r\n        },\r\n        cols: function () {\r\n            return this.elements[0].length;\r\n        },\r\n        rows: function () {\r\n            return this.elements.length;\r\n        },\r\n        row: function (n) {\r\n            if(!n || n > this.cols())\r\n                return [];\r\n            return this.elements[n - 1];\r\n        },\r\n        col: function (n) {\r\n            var nr = this.rows(),\r\n                    col = [];\r\n            if(n > this.cols() || !n)\r\n                return col;\r\n            for(var i = 0; i < nr; i++) {\r\n                col.push(this.elements[i][n - 1]);\r\n            }\r\n            return col;\r\n        },\r\n        eachElement: function (fn) {\r\n            var nr = this.rows(),\r\n                    nc = this.cols(), i, j;\r\n            for(i = 0; i < nr; i++) {\r\n                for(j = 0; j < nc; j++) {\r\n                    fn.call(this, this.elements[i][j], i, j);\r\n                }\r\n            }\r\n        },\r\n        // ported from Sylvester.js\r\n        determinant: function () {\r\n            if(!this.isSquare()) {\r\n                return null;\r\n            }\r\n            var M = this.toRightTriangular();\r\n            var det = M.elements[0][0], n = M.elements.length - 1, k = n, i;\r\n            do {\r\n                i = k - n + 1;\r\n                det = _.multiply(det, M.elements[i][i]);\r\n            }\r\n            while(--n);\r\n            return det;\r\n        },\r\n        isSquare: function () {\r\n            return this.elements.length === this.elements[0].length;\r\n        },\r\n        isSingular: function () {\r\n            return this.isSquare() && this.determinant() === 0;\r\n        },\r\n        augment: function (m) {\r\n            var r = this.rows(), rr = m.rows();\r\n            if(r !== rr)\r\n                err(\"Cannot augment matrix. Rows don't match.\");\r\n            for(var i = 0; i < r; i++) {\r\n                this.elements[i] = this.elements[i].concat(m.elements[i]);\r\n            }\r\n\r\n            return this;\r\n        },\r\n        clone: function () {\r\n            var r = this.rows(), c = this.cols(),\r\n                    m = new Matrix();\r\n            for(var i = 0; i < r; i++) {\r\n                m.elements[i] = [];\r\n                for(var j = 0; j < c; j++) {\r\n                    var symbol = this.elements[i][j];\r\n                    m.elements[i][j] = isSymbol(symbol) ? symbol.clone() : symbol;\r\n                }\r\n            }\r\n            return m;\r\n        },\r\n        // ported from Sylvester.js\r\n        invert: function () {\r\n            if(!this.isSquare())\r\n                err('Matrix is not square!');\r\n            return block('SAFE', function () {\r\n                var ni = this.elements.length, ki = ni, i, j;\r\n                var imatrix = Matrix.identity(ni);\r\n                var M = this.augment(imatrix).toRightTriangular();\r\n                var np, kp = M.elements[0].length, p, els, divisor;\r\n                var inverse_elements = [], new_element;\r\n                // Matrix is non-singular so there will be no zeros on the diagonal\r\n                // Cycle through rows from last to first\r\n                do {\r\n                    i = ni - 1;\r\n                    // First, normalise diagonal elements to 1\r\n                    els = [];\r\n                    np = kp;\r\n                    inverse_elements[i] = [];\r\n                    divisor = M.elements[i][i];\r\n                    do {\r\n                        p = kp - np;\r\n                        new_element = _.divide(M.elements[i][p], divisor.clone());\r\n                        els.push(new_element);\r\n                        // Shuffle of the current row of the right hand side into the results\r\n                        // array as it will not be modified by later runs through this loop\r\n                        if(p >= ki) {\r\n                            inverse_elements[i].push(new_element);\r\n                        }\r\n                    }\r\n                    while(--np);\r\n                    M.elements[i] = els;\r\n                    // Then, subtract this row from those above it to\r\n                    // give the identity matrix on the left hand side\r\n                    for(j = 0; j < i; j++) {\r\n                        els = [];\r\n                        np = kp;\r\n                        do {\r\n                            p = kp - np;\r\n                            els.push(_.subtract(M.elements[j][p].clone(), _.multiply(M.elements[i][p].clone(), M.elements[j][i].clone())));\r\n                        }\r\n                        while(--np);\r\n                        M.elements[j] = els;\r\n                    }\r\n                }\r\n                while(--ni);\r\n                return Matrix.fromArray(inverse_elements);\r\n            }, undefined, this);\r\n        },\r\n        // ported from Sylvester.js\r\n        toRightTriangular: function () {\r\n            return block('SAFE', function () {\r\n                var M = this.clone(), els, fel, nel,\r\n                        n = this.elements.length, k = n, i, np, kp = this.elements[0].length, p;\r\n                do {\r\n                    i = k - n;\r\n                    fel = M.elements[i][i];\r\n                    if(fel.valueOf() === 0) {\r\n                        for(var j = i + 1; j < k; j++) {\r\n                            nel = M.elements[j][i];\r\n                            if(nel && nel.valueOf() !== 0) {\r\n                                els = [];\r\n                                np = kp;\r\n                                do {\r\n                                    p = kp - np;\r\n                                    els.push(_.add(M.elements[i][p].clone(), M.elements[j][p].clone()));\r\n                                }\r\n                                while(--np);\r\n                                M.elements[i] = els;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    var fel = M.elements[i][i];\r\n                    if(fel.valueOf() !== 0) {\r\n                        for(j = i + 1; j < k; j++) {\r\n                            var multiplier = _.divide(M.elements[j][i].clone(), M.elements[i][i].clone());\r\n                            els = [];\r\n                            np = kp;\r\n                            do {\r\n                                p = kp - np;\r\n                                // Elements with column numbers up to an including the number\r\n                                // of the row that we're subtracting can safely be set straight to\r\n                                // zero, since that's the point of this routine and it avoids having\r\n                                // to loop over and correct rounding errors later\r\n                                els.push(p <= i ? new Symbol(0) :\r\n                                        _.subtract(M.elements[j][p].clone(), _.multiply(M.elements[i][p].clone(), multiplier.clone())));\r\n                            }\r\n                            while(--np);\r\n                            M.elements[j] = els;\r\n                        }\r\n                    }\r\n                }\r\n                while(--n);\r\n\r\n                return M;\r\n            }, undefined, this);\r\n        },\r\n        transpose: function () {\r\n            var rows = this.elements.length, cols = this.elements[0].length;\r\n            var M = new Matrix(), ni = cols, i, nj, j;\r\n\r\n            do {\r\n                i = cols - ni;\r\n                M.elements[i] = [];\r\n                nj = rows;\r\n                do {\r\n                    j = rows - nj;\r\n                    M.elements[i][j] = this.elements[j][i].clone();\r\n                }\r\n                while(--nj);\r\n            }\r\n            while(--ni);\r\n            return M;\r\n        },\r\n        // Returns true if the matrix can multiply the argument from the left\r\n        canMultiplyFromLeft: function (matrix) {\r\n            var l = isMatrix(matrix) ? matrix.elements.length : matrix.length;\r\n            // this.columns should equal matrix.rows\r\n            return (this.elements[0].length === l);\r\n        },\r\n        sameSize: function (matrix) {\r\n            return this.rows() === matrix.rows() && this.cols() === matrix.cols();\r\n        },\r\n        multiply: function (matrix) {\r\n            return block('SAFE', function () {\r\n                var M = matrix.elements || matrix;\r\n                if(!this.canMultiplyFromLeft(M)) {\r\n                    if(this.sameSize(matrix)) {\r\n                        var MM = new Matrix();\r\n                        var rows = this.rows();\r\n                        for(var i = 0; i < rows; i++) {\r\n                            var e = _.multiply(new Vector(this.elements[i]), new Vector(matrix.elements[i]));\r\n                            MM.elements[i] = e.elements;\r\n                        }\r\n                        return MM;\r\n                    }\r\n                    return null;\r\n                }\r\n                var ni = this.elements.length, ki = ni, i, nj, kj = M[0].length, j;\r\n                var cols = this.elements[0].length, elements = [], sum, nc, c;\r\n                do {\r\n                    i = ki - ni;\r\n                    elements[i] = [];\r\n                    nj = kj;\r\n                    do {\r\n                        j = kj - nj;\r\n                        sum = new Symbol(0);\r\n                        nc = cols;\r\n                        do {\r\n                            c = cols - nc;\r\n                            sum = _.add(sum, _.multiply(this.elements[i][c], M[c][j]));\r\n                        }\r\n                        while(--nc);\r\n                        elements[i][j] = sum;\r\n                    }\r\n                    while(--nj);\r\n                }\r\n                while(--ni);\r\n                return Matrix.fromArray(elements);\r\n            }, undefined, this);\r\n        },\r\n        add: function (matrix, callback) {\r\n            var M = new Matrix();\r\n            if(this.sameSize(matrix)) {\r\n                this.eachElement(function (e, i, j) {\r\n                    var result = _.add(e.clone(), matrix.elements[i][j].clone());\r\n                    if(callback) {\r\n                        result = callback.call(M, result, e, matrix.elements[i][j]);\r\n                    }\r\n                    M.set(i, j, result);\r\n                });\r\n            }\r\n            return M;\r\n        },\r\n        subtract: function (matrix, callback) {\r\n            var M = new Matrix();\r\n            if(this.sameSize(matrix)) {\r\n                this.eachElement(function (e, i, j) {\r\n                    var result = _.subtract(e.clone(), matrix.elements[i][j].clone());\r\n                    if(callback) {\r\n                        result = callback.call(M, result, e, matrix.elements[i][j]);\r\n                    }\r\n                    M.set(i, j, result);\r\n                });\r\n            }\r\n            return M;\r\n        },\r\n        negate: function () {\r\n            this.each(function (e) {\r\n                return e.negate();\r\n            });\r\n            return this;\r\n        },\r\n        toVector: function () {\r\n            if(this.rows() === 1 || this.cols() === 1) {\r\n                var v = new Vector();\r\n                v.elements = this.elements;\r\n                return v;\r\n            }\r\n            return this;\r\n        },\r\n        toString: function (newline, to_decimal) {\r\n            var l = this.rows(),\r\n                    s = [];\r\n            newline = newline === undefined ? '\\n' : newline;\r\n            for(var i = 0; i < l; i++) {\r\n                s.push('[' + this.elements[i].map(function (x) {\r\n                    var v = to_decimal ? x.multiplier.toDecimal() : x.toString();\r\n                    return x !== undefined ? v : '';\r\n                }).join(',') + ']');\r\n            }\r\n            return 'matrix' + inBrackets(s.join(','));\r\n        },\r\n        text: function () {\r\n            return 'matrix(' + this.elements.toString('') + ')';\r\n        },\r\n        latex: function (option) {\r\n            var cols = this.cols(), elements = this.elements;\r\n            return format('\\\\begin{vmatrix}{0}\\\\end{vmatrix}', function () {\r\n                var tex = [];\r\n                for(var row in elements) {\r\n                    var row_tex = [];\r\n                    for(var i = 0; i < cols; i++) {\r\n                        row_tex.push(LaTeX.latex.call(LaTeX, elements[row][i], option));\r\n                    }\r\n                    tex.push(row_tex.join(' & '));\r\n                }\r\n                return tex.join(' \\\\cr ');\r\n            });\r\n        }\r\n    };\r\n    // aliases\r\n    Matrix.prototype.each = Matrix.prototype.eachElement;\r\n\r\n\r\n    function Set(set) {\r\n        this.elements = [];\r\n        // if the first object isn't an array, convert it to one.\r\n        if(!isVector(set))\r\n            set = Vector.fromArray(arguments);\r\n\r\n        if(set) {\r\n            var elements = set.elements;\r\n            for(var i = 0, l = elements.length; i < l; i++) {\r\n                this.add(elements[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    Set.fromArray = function (arr) {\r\n        function F(args) {\r\n            return Set.apply(this, args);\r\n        }\r\n        F.prototype = Set.prototype;\r\n\r\n        return new F(arr);\r\n    };\r\n\r\n    Set.prototype = {\r\n        add: function (x) {\r\n            if(!this.contains(x))\r\n                this.elements.push(x.clone());\r\n        },\r\n        contains: function (x) {\r\n            for(var i = 0; i < this.elements.length; i++) {\r\n                var e = this.elements[i];\r\n                if(x.equals(e))\r\n                    return true;\r\n            }\r\n            return false;\r\n        },\r\n        each: function (f) {\r\n            var elements = this.elements;\r\n            var set = new Set();\r\n            for(var i = 0, l = elements.length; i < l; i++) {\r\n                var e = elements[i];\r\n                f.call(this, e, set, i);\r\n            }\r\n            return set;\r\n        },\r\n        clone: function () {\r\n            var set = new Set();\r\n            this.each(function (e) {\r\n                set.add(e.clone());\r\n            });\r\n            return set;\r\n        },\r\n        union: function (set) {\r\n            var _union = this.clone();\r\n            set.each(function (e) {\r\n                _union.add(e);\r\n            });\r\n\r\n            return _union;\r\n        },\r\n        difference: function (set) {\r\n            var diff = this.clone();\r\n            set.each(function (e) {\r\n                diff.remove(e);\r\n            });\r\n            return diff;\r\n        },\r\n        remove: function (element) {\r\n            for(var i = 0, l = this.elements.length; i < l; i++) {\r\n                var e = this.elements[i];\r\n                if(e.equals(element)) {\r\n                    remove(this.elements, i);\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n        intersection: function (set) {\r\n            var _intersection = new Set();\r\n            var A = this;\r\n            set.each(function (e) {\r\n                if(A.contains(e)) {\r\n                    _intersection.add(e);\r\n                }\r\n                ;\r\n            });\r\n\r\n            return _intersection;\r\n        },\r\n        intersects: function (set) {\r\n            return this.intersection(set).elements.length > 0;\r\n        },\r\n        is_subset: function (set) {\r\n            var elements = set.elements;\r\n            for(var i = 0, l = elements.length; i < l; i++) {\r\n                if(!this.contains(elements[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        toString: function () {\r\n            return '{' + this.elements.join(',') + '}';\r\n        }\r\n    };\r\n\r\n//build ========================================================================\r\n    var Build = {\r\n        dependencies: {\r\n            _rename: {\r\n                'Math2.factorial': 'factorial'\r\n            },\r\n            factorial: {\r\n                'Math2.gamma': Math2.gamma\r\n            },\r\n            gamma_incomplete: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Li: {\r\n                'Math2.Ei': Math2.Ei,\r\n                'Math2.bigLog': Math2.bigLog,\r\n                'Frac': Frac\r\n            },\r\n            Ci: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Ei: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Si: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Shi: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Chi: {\r\n                'isInt': isInt,\r\n                'nround': nround,\r\n                'Math2.num_integrate': Math2.num_integrate\r\n            },\r\n            factor: {\r\n                'Math2.ifactor': Math2.ifactor,\r\n                'Symbol': Symbol\r\n            },\r\n            num_integrate: {\r\n                'Math2.simpson': Math2.simpson,\r\n                'nround': nround\r\n            },\r\n            fib: {\r\n                'even': even\r\n            }\r\n        },\r\n        /* Some functions need to be made numeric safe. Build checks if there's a\r\n         * reformat option and calls that instead when compiling the function string.\r\n         */\r\n        reformat: {\r\n            // this simply extends the build function\r\n            diff: function (symbol, deps) {\r\n                var v = symbol.args[1].toString();\r\n                var f = 'var f = ' + Build.build(symbol.args[0].toString(), [v]) + ';';\r\n                deps[1] += 'var diff = ' + Math2.diff.toString() + ';';\r\n                deps[1] += f;\r\n\r\n                return ['diff(f)(' + v + ')', deps];\r\n            }\r\n        },\r\n        getProperName: function (f) {\r\n            var map = {\r\n                continued_fraction: 'continuedFraction'\r\n            };\r\n            return map[f] || f;\r\n        },\r\n        // assumes that dependences are at max 2 levels\r\n        compileDependencies: function (f, deps) {\r\n            // grab the predefined dependiences\r\n            var dependencies = Build.dependencies[f];\r\n\r\n            // the dependency string\r\n            var dep_string = deps && deps[1] ? deps[1] : '';\r\n\r\n            // the functions to be replaced\r\n            var replacements = deps && deps[0] ? deps[0] : {};\r\n\r\n            // loop through them and add them to the list\r\n            for(var x in dependencies) {\r\n                if(typeof dependencies[x] === 'object')\r\n                    continue; // skip object\r\n                var components = x.split('.'); //Math.f becomes f\r\n                // if the function isn't part of an object then reference the function itself\r\n                dep_string += 'var ' + (components.length > 1 ? components[1] : components[0]) + '=' + dependencies[x] + ';';\r\n                replacements[x] = components.pop();\r\n            }\r\n\r\n            return [replacements, dep_string];\r\n        },\r\n        getArgsDeps: function (symbol, dependencies) {\r\n            var args = symbol.args;\r\n            for(var i = 0; i < args.length; i++) {\r\n                symbol.args[i].each(function (x) {\r\n                    if(x.group === FN)\r\n                        dependencies = Build.compileDependencies(x.fname, dependencies);\r\n                });\r\n            }\r\n            return dependencies;\r\n        },\r\n        build: function (symbol, arg_array) {\r\n            symbol = block('PARSE2NUMBER', function () {\r\n                return _.parse(symbol);\r\n            }, true);\r\n            var args = variables(symbol);\r\n            var supplements = [];\r\n            var dependencies = [];\r\n            var ftext = function (symbol, xports) {\r\n                //Fix for #545 - Parentheses confuse build.\r\n                if(symbol.fname === '') {\r\n                    symbol = Symbol.unwrapPARENS(symbol);\r\n                }\r\n                xports = xports || [];\r\n                var c = [],\r\n                        group = symbol.group,\r\n                        prefix = '';\r\n\r\n                var ftext_complex = function (group) {\r\n                    var d = group === CB ? '*' : '+',\r\n                            cc = [];\r\n\r\n                    for(var x in symbol.symbols) {\r\n                        var sym = symbol.symbols[x],\r\n                                ft = ftext(sym, xports)[0];\r\n                        // wrap it in brackets if it's group PL or CP\r\n                        if(sym.isComposite())\r\n                            ft = inBrackets(ft);\r\n                        cc.push(ft);\r\n                    }\r\n                    var retval = cc.join(d);\r\n                    retval = retval && !symbol.multiplier.equals(1) ? inBrackets(retval) : retval;\r\n                    return retval;\r\n                },\r\n                        ftext_function = function (bn) {\r\n                            var retval;\r\n                            if(bn in Math)\r\n                                retval = 'Math.' + bn;\r\n                            else {\r\n                                bn = Build.getProperName(bn);\r\n                                if(supplements.indexOf(bn) === -1) { // make sure you're not adding the function twice\r\n                                    //Math2 functions aren't part of the standard javascript\r\n                                    //Math library and must be exported.\r\n                                    xports.push('var ' + bn + ' = ' + Math2[bn].toString() + '; ');\r\n                                    supplements.push(bn);\r\n                                }\r\n                                retval = bn;\r\n                            }\r\n                            retval = retval + inBrackets(symbol.args.map(function (x) {\r\n                                return ftext(x, xports)[0];\r\n                            }).join(','));\r\n\r\n                            return retval;\r\n                        };\r\n\r\n                // the multiplier\r\n                if(group === N)\r\n                    c.push(symbol.multiplier.toDecimal());\r\n                else if(symbol.multiplier.equals(-1))\r\n                    prefix = '-';\r\n                else if(!symbol.multiplier.equals(1))\r\n                    c.push(symbol.multiplier.toDecimal());\r\n                // the value\r\n                var value;\r\n\r\n                if(group === S || group === P)\r\n                    value = symbol.value;\r\n                else if(group === FN) {\r\n                    dependencies = Build.compileDependencies(symbol.fname, dependencies);\r\n                    dependencies = Build.getArgsDeps(symbol, dependencies);\r\n                    if(Build.reformat[symbol.fname]) {\r\n                        var components = Build.reformat[symbol.fname](symbol, dependencies);\r\n                        dependencies = components[1];\r\n                        value = components[0];\r\n                    }\r\n                    else {\r\n                        value = ftext_function(symbol.fname);\r\n                    }\r\n\r\n                }\r\n                else if(group === EX) {\r\n                    var pg = symbol.previousGroup;\r\n                    if(pg === N || pg === S)\r\n                        value = symbol.value;\r\n                    else if(pg === FN) {\r\n                        value = ftext_function(symbol.fname);\r\n                        dependencies = Build.compileDependencies(symbol.fname, dependencies);\r\n                        dependencies = Build.getArgsDeps(symbol, dependencies);\r\n                    }\r\n                    else\r\n                        value = ftext_complex(symbol.previousGroup);\r\n                }\r\n                else {\r\n                    value = ftext_complex(symbol.group);\r\n                }\r\n\r\n                if(symbol.group !== N && !symbol.power.equals(1)) {\r\n                    var pow = ftext(_.parse(symbol.power));\r\n                    xports.push(pow[1]);\r\n                    value = 'Math.pow' + inBrackets(value + ',' + pow[0]);\r\n                }\r\n\r\n                if(value)\r\n                    c.push(prefix + value);\r\n\r\n                return [c.join('*'), xports.join('').replace(/\\n+\\s+/g, ' ')];\r\n            };\r\n            if(arg_array) {\r\n                // Fix for issue #546\r\n                // Disable argument checking since it's a bit presumptuous.\r\n                // Consider f(x) = 5; If I explicitely pass in an argument array contain x \r\n                // this check will fail and complain since the function doesn't contain x.\r\n                /*\r\n                 for (var i = 0; i < args.length; i++) {\r\n                 var arg = args[i];\r\n                 if (arg_array.indexOf(arg) === -1)\r\n                 err(arg + ' not found in argument array');\r\n                 }\r\n                 */\r\n                args = arg_array;\r\n            }\r\n\r\n            var f_array = ftext(symbol);\r\n\r\n            // make all the substitutions;\r\n            for(var x in dependencies[0]) {\r\n                var alias = dependencies[0][x];\r\n                f_array[1] = f_array[1].replace(x, alias);\r\n                dependencies[1] = dependencies[1].replace(x, alias);\r\n            }\r\n\r\n            var f = new Function(args, (dependencies[1] || '') + f_array[1] + ' return ' + f_array[0] + ';');\r\n\r\n            return f;\r\n        }\r\n    };\r\n\r\n\r\n//finalize =====================================================================\r\n    /* FINALIZE */\r\n    (function () {\r\n        reserveNames(_.CONSTANTS);\r\n        reserveNames(_.functions);\r\n        _.initConstants();\r\n        //bug fix for error but needs to be revisited\r\n        if(!_.error)\r\n            _.error = err;\r\n\r\n        //Store the log and log10 functions\r\n        Settings.LOG_FNS = {\r\n            log: _.functions['log'],\r\n            log10: _.functions['log10']\r\n        };\r\n\r\n    })();\r\n\r\n    /* END FINALIZE */\r\n\r\n//Core =========================================================================\r\n    var Utils = {\r\n        allSame: allSame,\r\n        allNumeric: allNumeric,\r\n        arguments2Array: arguments2Array,\r\n        arrayAddSlices: arrayAddSlices,\r\n        arrayClone: arrayClone,\r\n        arrayMax: arrayMax,\r\n        arrayMin: arrayMin,\r\n        arrayEqual: arrayEqual,\r\n        arrayUnique: arrayUnique,\r\n        arrayGetVariables: arrayGetVariables,\r\n        arraySum: arraySum,\r\n        block: block,\r\n        build: Build.build,\r\n        clearU: clearU,\r\n        comboSort: comboSort,\r\n        compare: compare,\r\n        convertToVector: convertToVector,\r\n        customError: customError,\r\n        customType: customType,\r\n        decompose_fn: decompose_fn,\r\n        each: each,\r\n        evaluate: evaluate,\r\n        even: even,\r\n        evenFraction: evenFraction,\r\n        fillHoles: fillHoles,\r\n        firstObject: firstObject,\r\n        format: format,\r\n        generatePrimes: generatePrimes,\r\n        getCoeffs: getCoeffs,\r\n        getU: getU,\r\n        importFunctions: importFunctions,\r\n        inBrackets: inBrackets,\r\n        isArray: isArray,\r\n        isExpression: isExpression,\r\n        isFraction: isFraction,\r\n        isInt: isInt,\r\n        isMatrix: isMatrix,\r\n        isNegative: isNegative,\r\n        isNumericSymbol: isNumericSymbol,\r\n        isPrime: isPrime,\r\n        isReserved: isReserved,\r\n        isSymbol: isSymbol,\r\n        isVariableSymbol: isVariableSymbol,\r\n        isVector: isVector,\r\n        keys: keys,\r\n        knownVariable: knownVariable,\r\n        nroots: nroots,\r\n        remove: remove,\r\n        reserveNames: reserveNames,\r\n        range: range,\r\n        round: nround,\r\n        sameSign: sameSign,\r\n        scientificToDecimal: scientificToDecimal,\r\n        separate: separate,\r\n        stringReplace: stringReplace,\r\n        text: text,\r\n        validateName: validateName,\r\n        variables: variables,\r\n        warn: warn\r\n    };\r\n\r\n    //This contains all the parts of nerdamer and enables nerdamer's internal functions\r\n    //to be used.\r\n    var C = {\r\n        groups: Groups,\r\n        Symbol: Symbol,\r\n        Expression: Expression,\r\n        Frac: Frac,\r\n        Vector: Vector,\r\n        Matrix: Matrix,\r\n        Parser: Parser,\r\n        Scientific: Scientific,\r\n        Fraction: Fraction,\r\n        Math2: Math2,\r\n        LaTeX: LaTeX,\r\n        Utils: Utils,\r\n        PARSER: _,\r\n        PARENTHESIS: PARENTHESIS,\r\n        Settings: Settings,\r\n        err: err,\r\n        bigInt: bigInt,\r\n        bigDec: bigDec,\r\n        exceptions: exceptions\r\n    };\r\n\r\n//libExports ===================================================================\r\n    /**\r\n     *\r\n     * @param {String} expression the expression to be evaluated\r\n     * @param {Object} subs the object containing the variable values\r\n     * @param {Integer} location a specific location in the equation list to\r\n     * insert the evaluated expression\r\n     * @param {String} option additional options\r\n     * @returns {Expression}\r\n     */\r\n    var libExports = function (expression, subs, option, location) {\r\n        // Initiate the numer flag\r\n        var numer = false;\r\n\r\n        // Is the user declaring a function?\r\n        var fndec = /^([a-z_][a-z\\d\\_]*)\\(([a-z_,\\s]*)\\):=(.+)$/gi.exec(expression);\r\n        if(fndec)\r\n            return nerdamer.setFunction(fndec[1], fndec[2].split(','), fndec[3]);\r\n\r\n        // var variable, fn, args;\r\n        // Convert any expression passed in to a string\r\n        if(expression instanceof Expression)\r\n            expression = expression.toString();\r\n\r\n        // Convert it to an array for simplicity\r\n        if(!isArray(option)) {\r\n            option = typeof option === 'undefined' ? [] : [option];\r\n        }\r\n\r\n        option.forEach(function (o) {\r\n            // Turn on the numer flag if requested\r\n            if(o === 'numer') {\r\n                numer = true;\r\n                return;\r\n            }\r\n            // Wrap it in a function if requested. This only holds true for\r\n            // functions that take a single argument which is the expression\r\n            var f = _.functions[option];\r\n            // If there's a function and it takes a single argument, then wrap\r\n            // the expression in it\r\n            if(f && f[1] === 1) {\r\n                expression = `${o}(${expression})`;\r\n            }\r\n        });\r\n\r\n        var e = block('PARSE2NUMBER', function () {\r\n            return _.parse(expression, subs);\r\n        }, numer || Settings.PARSE2NUMBER);\r\n\r\n        if(location) {\r\n            EXPRESSIONS[location - 1] = e;\r\n        }\r\n        else {\r\n            EXPRESSIONS.push(e);\r\n        }\r\n\r\n        return new Expression(e);\r\n    };\r\n    /**\r\n     * Converts expression into rpn form\r\n     * @param {String} expression\r\n     * @returns {Token[]}\r\n     */\r\n    libExports.rpn = function (expression) {\r\n        return _.tokenize(_.toRPN(expression));\r\n    };\r\n\r\n    /**\r\n     * Generates LaTeX from expression string\r\n     * @param {String} e\r\n     * @param {object} opt\r\n     * @returns {String}\r\n     */\r\n    libExports.convertToLaTeX = function (e, opt) {\r\n        return _.toTeX(e, opt);\r\n    };\r\n\r\n    /**\r\n     * Converts latex to text - Very very very basic at the moment\r\n     * @param {String} e\r\n     * @returns {String}\r\n     */\r\n    libExports.convertFromLaTeX = function (e) {\r\n        var txt = LaTeX.parse(_.tokenize(e));\r\n        return new Expression(_.parse(txt));\r\n    };\r\n\r\n    /**\r\n     * Get the version of nerdamer or a loaded add-on\r\n     * @param {String} add_on - The add-on being checked\r\n     * @returns {String} returns the version of nerdamer\r\n     */\r\n    libExports.version = function (add_on) {\r\n        if(add_on) {\r\n            try {\r\n                return C[add_on].version;\r\n            }\r\n            catch(e) {\r\n                return \"No module named \" + add_on + \" found!\";\r\n            }\r\n        }\r\n        return version;\r\n    };\r\n\r\n    /**\r\n     * Get nerdamer generated warnings\r\n     * @returns {String[]}\r\n     */\r\n    libExports.getWarnings = function () {\r\n        return WARNINGS;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {String} constant The name of the constant to be set\r\n     * @param {mixed} value The value of the constant\r\n     * @returns {Object} Returns the nerdamer object\r\n     */\r\n    libExports.setConstant = function (constant, value) {\r\n        validateName(constant);\r\n        if(!isReserved(constant)) {\r\n            //fix for issue #127\r\n            if(value === 'delete' || value === '') {\r\n                delete _.CONSTANTS[constant];\r\n            }\r\n            else {\r\n                if(isNaN(value))\r\n                    throw new NerdamerTypeError('Constant must be a number!');\r\n                _.CONSTANTS[constant] = value;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Returns the value of a previously set constant\r\n     * @param {type} constant\r\n     * @returns {String}\r\n     */\r\n    libExports.getConstant = function (constant) {\r\n        return String(_.constant[constant]);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {String} name The name of the function\r\n     * @param {Array} params_array A list containing the parameter name of the functions\r\n     * @param {String} body The body of the function\r\n     * @returns {Boolean} returns true if succeeded and falls on fail\r\n     * @example nerdamer.setFunction('f',['x'], 'x^2+2');\r\n     */\r\n    libExports.setFunction = setFunction;\r\n\r\n    /**\r\n     *\r\n     * @returns {C} Exports the nerdamer core functions and objects\r\n     */\r\n    libExports.getCore = function () {\r\n        return C;\r\n    };\r\n\r\n    libExports.getExpression = libExports.getEquation = Expression.getExpression;\r\n\r\n    /**\r\n     *\r\n     * @param {Boolean} asArray The returned names are returned as an array if this is set to true;\r\n     * @returns {String|Array}\r\n     */\r\n    libExports.reserved = function (asArray) {\r\n        if(asArray) {\r\n            return RESERVED;\r\n        }\r\n        return RESERVED.join(', ');\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {Integer} equation_number the number of the equation to clear.\r\n     * If 'all' is supplied then all equations are cleared\r\n     * @param {Boolean} keep_EXPRESSIONS_fixed use true if you don't want to keep EXPRESSIONS length fixed\r\n     * @returns {Object} Returns the nerdamer object\r\n     */\r\n    libExports.clear = function (equation_number, keep_EXPRESSIONS_fixed) {\r\n        if(equation_number === 'all') {\r\n            EXPRESSIONS = [];\r\n        }\r\n        else if(equation_number === 'last') {\r\n            EXPRESSIONS.pop();\r\n        }\r\n        else if(equation_number === 'first') {\r\n            EXPRESSIONS.shift();\r\n        }\r\n        else {\r\n            var index = !equation_number ? EXPRESSIONS.length : equation_number - 1;\r\n            keep_EXPRESSIONS_fixed === true ? EXPRESSIONS[index] = undefined : remove(EXPRESSIONS, index);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Alias for nerdamer.clear('all')\r\n     */\r\n    libExports.flush = function () {\r\n        this.clear('all');\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {Boolean} asObject\r\n     * @param {Boolean} asLaTeX\r\n     * @param {String|String[]} option\r\n     * @returns {Array}\r\n     */\r\n    libExports.expressions = function (asObject, asLaTeX, option) {\r\n        var result = asObject ? {} : [];\r\n        for(var i = 0; i < EXPRESSIONS.length; i++) {\r\n            var eq = asLaTeX ? LaTeX.latex(EXPRESSIONS[i], option) : text(EXPRESSIONS[i], option);\r\n            asObject ? result[i + 1] = eq : result.push(eq);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    //the method for registering modules\r\n    libExports.register = function (obj) {\r\n        var core = this.getCore();\r\n\r\n        if(isArray(obj)) {\r\n            for(var i = 0; i < obj.length; i++) {\r\n                if(obj)\r\n                    this.register(obj[i]);\r\n            }\r\n        }\r\n        else if(obj && Settings.exclude.indexOf(obj.name) === -1) {\r\n            //make sure all the dependencies are available\r\n            if(obj.dependencies) {\r\n                for(var i = 0; i < obj.dependencies.length; i++)\r\n                    if(!core[obj.dependencies[i]])\r\n                        throw new Error(format('{0} requires {1} to be loaded!', obj.name, obj.dependencies[i]));\r\n            }\r\n            //if no parent object is provided then the function does not have an address and cannot be called directly\r\n            var parent_obj = obj.parent,\r\n                    fn = obj.build.call(core); //call constructor to get function\r\n            if(parent_obj) {\r\n                if(!core[parent_obj])\r\n                    core[obj.parent] = {};\r\n\r\n                var ref_obj = parent_obj === 'nerdamer' ? this : core[parent_obj];\r\n                //attach the function to the core\r\n                ref_obj[obj.name] = fn;\r\n            }\r\n            if(obj.visible)\r\n                _.functions[obj.name] = [fn, obj.numargs]; //make the function available\r\n\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {String} name variable name\r\n     * @returns {boolean} validates if the profided string is a valid variable name\r\n     */\r\n    libExports.validateName = validateName;\r\n\r\n    /**\r\n     * @param {String} varname variable name\r\n     * @returns {boolean} validates if the profided string is a valid variable name\r\n     */\r\n    libExports.validVarName = function (varname) {\r\n        try {\r\n            validateName(varname);\r\n            return RESERVED.indexOf(varname) === -1;\r\n        }\r\n        catch(e) {\r\n            return false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @returns {Array} Array of functions currently supported by nerdamer\r\n     */\r\n    libExports.supported = function () {\r\n        return keys(_.functions);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @returns {Number} The number equations/expressions currently loaded\r\n     */\r\n    libExports.numEquations = libExports.numExpressions = function () {\r\n        return EXPRESSIONS.length;\r\n    };\r\n    /* END EXPORTS */\r\n\r\n    /**\r\n     *\r\n     * @param {String} v variable to be set\r\n     * @param {String} val value of variable. This can be a variable expression or number\r\n     * @returns {Object} Returns the nerdamer object\r\n     */\r\n    libExports.setVar = function (v, val) {\r\n        validateName(v);\r\n        //check if it's not already a constant\r\n        if(v in _.CONSTANTS)\r\n            err('Cannot set value for constant ' + v);\r\n        if(val === 'delete' || val === '')\r\n            delete VARS[v];\r\n        else {\r\n            VARS[v] = isSymbol(val) ? val : _.parse(val);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Returns the value of a set variable\r\n     * @param {type} v\r\n     * @returns {varies}\r\n     */\r\n    libExports.getVar = function (v) {\r\n        return VARS[v];\r\n    };\r\n    /**\r\n     * Clear the variables from the VARS object\r\n     * @returns {Object} Returns the nerdamer object\r\n     */\r\n    libExports.clearVars = function () {\r\n        VARS = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {Function} loader\r\n     * @returns {nerdamer}\r\n     */\r\n    libExports.load = function (loader) {\r\n        loader.call(this);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param {String} output - output format. Can be 'object' (just returns the VARS object), 'text' or 'latex'. Default: 'text'\r\n     * @param {String|String[]} option\r\n     * @returns {Object} Returns an object with the variables\r\n     */\r\n    libExports.getVars = function (output, option) {\r\n        output = output || 'text';\r\n        var variables = {};\r\n        if(output === 'object')\r\n            variables = VARS;\r\n        else {\r\n            for(var v in VARS) {\r\n                if(output === 'latex') {\r\n                    variables[v] = VARS[v].latex(option);\r\n                }\r\n                else if(output === 'text') {\r\n                    variables[v] = VARS[v].text(option);\r\n                }\r\n            }\r\n        }\r\n        return variables;\r\n    };\r\n\r\n    /**\r\n     * Set the value of a setting\r\n     * @param {String} setting The setting to be changed\r\n     * @param {boolean} value\r\n     */\r\n    libExports.set = function (setting, value) {\r\n        //current options:\r\n        //PARSE2NUMBER, suppress_errors\r\n        if(typeof setting === 'object')\r\n            for(var x in setting) {\r\n                libExports.set(x, setting[x]);\r\n            }\r\n\r\n        var disallowed = ['SAFE'];\r\n        if(disallowed.indexOf(setting) !== -1)\r\n            err('Cannot modify setting: ' + setting);\r\n\r\n        if(setting === 'PRECISION') {\r\n            bigDec.set({precision: value});\r\n            Settings.PRECISION = value;\r\n\r\n            // Avoid that nerdamer puts out garbage after 21 decimal place\r\n            if(value > 21) {\r\n                this.set('USE_BIG', true);\r\n            }\r\n        }\r\n        else if(setting === 'USE_LN' && value === true) {\r\n            //set log as LN\r\n            Settings.LOG = 'LN';\r\n            //set log10 as log\r\n            Settings.LOG10 = 'log';\r\n            //point the functions in the right direction\r\n            _.functions['log'] = Settings.LOG_FNS.log10; //log is now log10\r\n            //the log10 function must be explicitly set\r\n            _.functions['log'][0] = function (x) {\r\n                if(x.isConstant())\r\n                    return new Symbol(Math.log10(x));\r\n                return _.symfunction(Settings.LOG10, [x]);\r\n            };\r\n            _.functions['LN'] = Settings.LOG_FNS.log; //LN is now log\r\n\r\n            //remove log10\r\n            delete _.functions['log10'];\r\n        }\r\n        else\r\n            Settings[setting] = value;\r\n    };\r\n\r\n    /**\r\n     * Get the value of a setting\r\n     * @param {type} setting\r\n     * @returns {undefined}\r\n     */\r\n    libExports.get = function (setting) {\r\n        return Settings[setting];\r\n    };\r\n\r\n    /**\r\n     * This functions makes internal functions available externally\r\n     * @param {bool} override Override the functions when calling api if it exists\r\n     */\r\n    libExports.api = function (override) {\r\n        //Map internal functions to external ones\r\n        var linker = function (fname) {\r\n            return function () {\r\n                var args = [].slice.call(arguments);\r\n                for(var i = 0; i < args.length; i++)\r\n                    args[i] = _.parse(args[i]);\r\n                return new Expression(block('PARSE2NUMBER', function () {\r\n                    return _.callfunction(fname, args);\r\n                }));\r\n            };\r\n        };\r\n        //perform the mapping\r\n        for(var x in _.functions)\r\n            if(!(x in libExports) || override)\r\n                libExports[x] = linker(x);\r\n    };\r\n\r\n    libExports.replaceFunction = function (name, fn, num_args) {\r\n        var existing = _.functions[name];\r\n        var new_num_args = typeof num_args === 'undefined' ? existing[1] : num_args;\r\n        _.functions[name] = [fn.call(undefined, existing[0], C), new_num_args];\r\n    };\r\n\r\n    libExports.setOperator = function (operator, shift) {\r\n        _.setOperator(operator, shift);\r\n    };\r\n\r\n    libExports.getOperator = function (operator) {\r\n        return _.getOperator(operator);\r\n    };\r\n\r\n    libExports.aliasOperator = function (operator, withOperator) {\r\n        _.aliasOperator(operator, withOperator);\r\n    };\r\n\r\n    libExports.tree = function (expression) {\r\n        return _.tree(_.toRPN(_.tokenize(expression)));\r\n    };\r\n\r\n    libExports.htmlTree = function (expression, indent) {\r\n        var tree = this.tree(expression);\r\n\r\n        return '<div class=\"tree\">\\n' +\r\n                '    <ul>\\n' +\r\n                '        <li>\\n' +\r\n                tree.toHTML(3, indent) + '\\n' +\r\n                '        </li>\\n' +\r\n                '    </ul>\\n' +\r\n                '</div>';\r\n    };\r\n\r\n    libExports.addPeeker = function (name, f) {\r\n        if(_.peekers[name])\r\n            _.peekers[name].push(f);\r\n    };\r\n\r\n    libExports.removePeeker = function (name, f) {\r\n        remove(_.peekers[name], f);\r\n    };\r\n\r\n    libExports.parse = function (e) {\r\n        return String(e).split(';').map(function (x) {\r\n            return _.parse(x);\r\n        });\r\n    };\r\n\r\n    libExports.api();\r\n\r\n    return libExports; //Done\r\n//imports ======================================================================\r\n})({\r\n    //https://github.com/peterolson/BigInteger.js\r\n    bigInt: (function(){\r\n        var bigInt=function(undefined){\"use strict\";var BASE=1e7,LOG_BASE=7,MAX_INT=9007199254740992,MAX_INT_ARR=smallToArray(MAX_INT),LOG_MAX_INT=Math.log(MAX_INT);function Integer(v,radix){if(typeof v===\"undefined\")return Integer[0];if(typeof radix!==\"undefined\")return+radix===10?parseValue(v):parseBase(v,radix);return parseValue(v)}function BigInteger(value,sign){this.value=value;this.sign=sign;this.isSmall=false}BigInteger.prototype=Object.create(Integer.prototype);function SmallInteger(value){this.value=value;this.sign=value<0;this.isSmall=true}SmallInteger.prototype=Object.create(Integer.prototype);function isPrecise(n){return-MAX_INT<n&&n<MAX_INT}function smallToArray(n){if(n<1e7)return[n];if(n<1e14)return[n%1e7,Math.floor(n/1e7)];return[n%1e7,Math.floor(n/1e7)%1e7,Math.floor(n/1e14)]}function arrayToSmall(arr){trim(arr);var length=arr.length;if(length<4&&compareAbs(arr,MAX_INT_ARR)<0){switch(length){case 0:return 0;case 1:return arr[0];case 2:return arr[0]+arr[1]*BASE;default:return arr[0]+(arr[1]+arr[2]*BASE)*BASE}}return arr}function trim(v){var i=v.length;while(v[--i]===0);v.length=i+1}function createArray(length){var x=new Array(length);var i=-1;while(++i<length){x[i]=0}return x}function truncate(n){if(n>0)return Math.floor(n);return Math.ceil(n)}function add(a,b){var l_a=a.length,l_b=b.length,r=new Array(l_a),carry=0,base=BASE,sum,i;for(i=0;i<l_b;i++){sum=a[i]+b[i]+carry;carry=sum>=base?1:0;r[i]=sum-carry*base}while(i<l_a){sum=a[i]+carry;carry=sum===base?1:0;r[i++]=sum-carry*base}if(carry>0)r.push(carry);return r}function addAny(a,b){if(a.length>=b.length)return add(a,b);return add(b,a)}function addSmall(a,carry){var l=a.length,r=new Array(l),base=BASE,sum,i;for(i=0;i<l;i++){sum=a[i]-base+carry;carry=Math.floor(sum/base);r[i]=sum-carry*base;carry+=1}while(carry>0){r[i++]=carry%base;carry=Math.floor(carry/base)}return r}BigInteger.prototype.add=function(v){var n=parseValue(v);if(this.sign!==n.sign){return this.subtract(n.negate())}var a=this.value,b=n.value;if(n.isSmall){return new BigInteger(addSmall(a,Math.abs(b)),this.sign)}return new BigInteger(addAny(a,b),this.sign)};BigInteger.prototype.plus=BigInteger.prototype.add;SmallInteger.prototype.add=function(v){var n=parseValue(v);var a=this.value;if(a<0!==n.sign){return this.subtract(n.negate())}var b=n.value;if(n.isSmall){if(isPrecise(a+b))return new SmallInteger(a+b);b=smallToArray(Math.abs(b))}return new BigInteger(addSmall(b,Math.abs(a)),a<0)};SmallInteger.prototype.plus=SmallInteger.prototype.add;function subtract(a,b){var a_l=a.length,b_l=b.length,r=new Array(a_l),borrow=0,base=BASE,i,difference;for(i=0;i<b_l;i++){difference=a[i]-borrow-b[i];if(difference<0){difference+=base;borrow=1}else borrow=0;r[i]=difference}for(i=b_l;i<a_l;i++){difference=a[i]-borrow;if(difference<0)difference+=base;else{r[i++]=difference;break}r[i]=difference}for(;i<a_l;i++){r[i]=a[i]}trim(r);return r}function subtractAny(a,b,sign){var value;if(compareAbs(a,b)>=0){value=subtract(a,b)}else{value=subtract(b,a);sign=!sign}value=arrayToSmall(value);if(typeof value===\"number\"){if(sign)value=-value;return new SmallInteger(value)}return new BigInteger(value,sign)}function subtractSmall(a,b,sign){var l=a.length,r=new Array(l),carry=-b,base=BASE,i,difference;for(i=0;i<l;i++){difference=a[i]+carry;carry=Math.floor(difference/base);difference%=base;r[i]=difference<0?difference+base:difference}r=arrayToSmall(r);if(typeof r===\"number\"){if(sign)r=-r;return new SmallInteger(r)}return new BigInteger(r,sign)}BigInteger.prototype.subtract=function(v){var n=parseValue(v);if(this.sign!==n.sign){return this.add(n.negate())}var a=this.value,b=n.value;if(n.isSmall)return subtractSmall(a,Math.abs(b),this.sign);return subtractAny(a,b,this.sign)};BigInteger.prototype.minus=BigInteger.prototype.subtract;SmallInteger.prototype.subtract=function(v){var n=parseValue(v);var a=this.value;if(a<0!==n.sign){return this.add(n.negate())}var b=n.value;if(n.isSmall){return new SmallInteger(a-b)}return subtractSmall(b,Math.abs(a),a>=0)};SmallInteger.prototype.minus=SmallInteger.prototype.subtract;BigInteger.prototype.negate=function(){return new BigInteger(this.value,!this.sign)};SmallInteger.prototype.negate=function(){var sign=this.sign;var small=new SmallInteger(-this.value);small.sign=!sign;return small};BigInteger.prototype.abs=function(){return new BigInteger(this.value,false)};SmallInteger.prototype.abs=function(){return new SmallInteger(Math.abs(this.value))};function multiplyLong(a,b){var a_l=a.length,b_l=b.length,l=a_l+b_l,r=createArray(l),base=BASE,product,carry,i,a_i,b_j;for(i=0;i<a_l;++i){a_i=a[i];for(var j=0;j<b_l;++j){b_j=b[j];product=a_i*b_j+r[i+j];carry=Math.floor(product/base);r[i+j]=product-carry*base;r[i+j+1]+=carry}}trim(r);return r}function multiplySmall(a,b){var l=a.length,r=new Array(l),base=BASE,carry=0,product,i;for(i=0;i<l;i++){product=a[i]*b+carry;carry=Math.floor(product/base);r[i]=product-carry*base}while(carry>0){r[i++]=carry%base;carry=Math.floor(carry/base)}return r}function shiftLeft(x,n){var r=[];while(n-- >0)r.push(0);return r.concat(x)}function multiplyKaratsuba(x,y){var n=Math.max(x.length,y.length);if(n<=30)return multiplyLong(x,y);n=Math.ceil(n/2);var b=x.slice(n),a=x.slice(0,n),d=y.slice(n),c=y.slice(0,n);var ac=multiplyKaratsuba(a,c),bd=multiplyKaratsuba(b,d),abcd=multiplyKaratsuba(addAny(a,b),addAny(c,d));var product=addAny(addAny(ac,shiftLeft(subtract(subtract(abcd,ac),bd),n)),shiftLeft(bd,2*n));trim(product);return product}function useKaratsuba(l1,l2){return-.012*l1-.012*l2+15e-6*l1*l2>0}BigInteger.prototype.multiply=function(v){var n=parseValue(v),a=this.value,b=n.value,sign=this.sign!==n.sign,abs;if(n.isSmall){if(b===0)return Integer[0];if(b===1)return this;if(b===-1)return this.negate();abs=Math.abs(b);if(abs<BASE){return new BigInteger(multiplySmall(a,abs),sign)}b=smallToArray(abs)}if(useKaratsuba(a.length,b.length))return new BigInteger(multiplyKaratsuba(a,b),sign);return new BigInteger(multiplyLong(a,b),sign)};BigInteger.prototype.times=BigInteger.prototype.multiply;function multiplySmallAndArray(a,b,sign){if(a<BASE){return new BigInteger(multiplySmall(b,a),sign)}return new BigInteger(multiplyLong(b,smallToArray(a)),sign)}SmallInteger.prototype._multiplyBySmall=function(a){if(isPrecise(a.value*this.value)){return new SmallInteger(a.value*this.value)}return multiplySmallAndArray(Math.abs(a.value),smallToArray(Math.abs(this.value)),this.sign!==a.sign)};BigInteger.prototype._multiplyBySmall=function(a){if(a.value===0)return Integer[0];if(a.value===1)return this;if(a.value===-1)return this.negate();return multiplySmallAndArray(Math.abs(a.value),this.value,this.sign!==a.sign)};SmallInteger.prototype.multiply=function(v){return parseValue(v)._multiplyBySmall(this)};SmallInteger.prototype.times=SmallInteger.prototype.multiply;function square(a){var l=a.length,r=createArray(l+l),base=BASE,product,carry,i,a_i,a_j;for(i=0;i<l;i++){a_i=a[i];carry=0-a_i*a_i;for(var j=i;j<l;j++){a_j=a[j];product=2*(a_i*a_j)+r[i+j]+carry;carry=Math.floor(product/base);r[i+j]=product-carry*base}r[i+l]=carry}trim(r);return r}BigInteger.prototype.square=function(){return new BigInteger(square(this.value),false)};SmallInteger.prototype.square=function(){var value=this.value*this.value;if(isPrecise(value))return new SmallInteger(value);return new BigInteger(square(smallToArray(Math.abs(this.value))),false)};function divMod1(a,b){var a_l=a.length,b_l=b.length,base=BASE,result=createArray(b.length),divisorMostSignificantDigit=b[b_l-1],lambda=Math.ceil(base/(2*divisorMostSignificantDigit)),remainder=multiplySmall(a,lambda),divisor=multiplySmall(b,lambda),quotientDigit,shift,carry,borrow,i,l,q;if(remainder.length<=a_l)remainder.push(0);divisor.push(0);divisorMostSignificantDigit=divisor[b_l-1];for(shift=a_l-b_l;shift>=0;shift--){quotientDigit=base-1;if(remainder[shift+b_l]!==divisorMostSignificantDigit){quotientDigit=Math.floor((remainder[shift+b_l]*base+remainder[shift+b_l-1])/divisorMostSignificantDigit)}carry=0;borrow=0;l=divisor.length;for(i=0;i<l;i++){carry+=quotientDigit*divisor[i];q=Math.floor(carry/base);borrow+=remainder[shift+i]-(carry-q*base);carry=q;if(borrow<0){remainder[shift+i]=borrow+base;borrow=-1}else{remainder[shift+i]=borrow;borrow=0}}while(borrow!==0){quotientDigit-=1;carry=0;for(i=0;i<l;i++){carry+=remainder[shift+i]-base+divisor[i];if(carry<0){remainder[shift+i]=carry+base;carry=0}else{remainder[shift+i]=carry;carry=1}}borrow+=carry}result[shift]=quotientDigit}remainder=divModSmall(remainder,lambda)[0];return[arrayToSmall(result),arrayToSmall(remainder)]}function divMod2(a,b){var a_l=a.length,b_l=b.length,result=[],part=[],base=BASE,guess,xlen,highx,highy,check;while(a_l){part.unshift(a[--a_l]);trim(part);if(compareAbs(part,b)<0){result.push(0);continue}xlen=part.length;highx=part[xlen-1]*base+part[xlen-2];highy=b[b_l-1]*base+b[b_l-2];if(xlen>b_l){highx=(highx+1)*base}guess=Math.ceil(highx/highy);do{check=multiplySmall(b,guess);if(compareAbs(check,part)<=0)break;guess--}while(guess);result.push(guess);part=subtract(part,check)}result.reverse();return[arrayToSmall(result),arrayToSmall(part)]}function divModSmall(value,lambda){var length=value.length,quotient=createArray(length),base=BASE,i,q,remainder,divisor;remainder=0;for(i=length-1;i>=0;--i){divisor=remainder*base+value[i];q=truncate(divisor/lambda);remainder=divisor-q*lambda;quotient[i]=q|0}return[quotient,remainder|0]}function divModAny(self,v){var value,n=parseValue(v);var a=self.value,b=n.value;var quotient;if(b===0)throw new Error(\"Cannot divide by zero\");if(self.isSmall){if(n.isSmall){return[new SmallInteger(truncate(a/b)),new SmallInteger(a%b)]}return[Integer[0],self]}if(n.isSmall){if(b===1)return[self,Integer[0]];if(b==-1)return[self.negate(),Integer[0]];var abs=Math.abs(b);if(abs<BASE){value=divModSmall(a,abs);quotient=arrayToSmall(value[0]);var remainder=value[1];if(self.sign)remainder=-remainder;if(typeof quotient===\"number\"){if(self.sign!==n.sign)quotient=-quotient;return[new SmallInteger(quotient),new SmallInteger(remainder)]}return[new BigInteger(quotient,self.sign!==n.sign),new SmallInteger(remainder)]}b=smallToArray(abs)}var comparison=compareAbs(a,b);if(comparison===-1)return[Integer[0],self];if(comparison===0)return[Integer[self.sign===n.sign?1:-1],Integer[0]];if(a.length+b.length<=200)value=divMod1(a,b);else value=divMod2(a,b);quotient=value[0];var qSign=self.sign!==n.sign,mod=value[1],mSign=self.sign;if(typeof quotient===\"number\"){if(qSign)quotient=-quotient;quotient=new SmallInteger(quotient)}else quotient=new BigInteger(quotient,qSign);if(typeof mod===\"number\"){if(mSign)mod=-mod;mod=new SmallInteger(mod)}else mod=new BigInteger(mod,mSign);return[quotient,mod]}BigInteger.prototype.divmod=function(v){var result=divModAny(this,v);return{quotient:result[0],remainder:result[1]}};SmallInteger.prototype.divmod=BigInteger.prototype.divmod;BigInteger.prototype.divide=function(v){return divModAny(this,v)[0]};SmallInteger.prototype.over=SmallInteger.prototype.divide=BigInteger.prototype.over=BigInteger.prototype.divide;BigInteger.prototype.mod=function(v){return divModAny(this,v)[1]};SmallInteger.prototype.remainder=SmallInteger.prototype.mod=BigInteger.prototype.remainder=BigInteger.prototype.mod;BigInteger.prototype.pow=function(v){var n=parseValue(v),a=this.value,b=n.value,value,x,y;if(b===0)return Integer[1];if(a===0)return Integer[0];if(a===1)return Integer[1];if(a===-1)return n.isEven()?Integer[1]:Integer[-1];if(n.sign){return Integer[0]}if(!n.isSmall)throw new Error(\"The exponent \"+n.toString()+\" is too large.\");if(this.isSmall){if(isPrecise(value=Math.pow(a,b)))return new SmallInteger(truncate(value))}x=this;y=Integer[1];while(true){if(b&1===1){y=y.times(x);--b}if(b===0)break;b/=2;x=x.square()}return y};SmallInteger.prototype.pow=BigInteger.prototype.pow;BigInteger.prototype.modPow=function(exp,mod){exp=parseValue(exp);mod=parseValue(mod);if(mod.isZero())throw new Error(\"Cannot take modPow with modulus 0\");var r=Integer[1],base=this.mod(mod);while(exp.isPositive()){if(base.isZero())return Integer[0];if(exp.isOdd())r=r.multiply(base).mod(mod);exp=exp.divide(2);base=base.square().mod(mod)}return r};SmallInteger.prototype.modPow=BigInteger.prototype.modPow;function compareAbs(a,b){if(a.length!==b.length){return a.length>b.length?1:-1}for(var i=a.length-1;i>=0;i--){if(a[i]!==b[i])return a[i]>b[i]?1:-1}return 0}BigInteger.prototype.compareAbs=function(v){var n=parseValue(v),a=this.value,b=n.value;if(n.isSmall)return 1;return compareAbs(a,b)};SmallInteger.prototype.compareAbs=function(v){var n=parseValue(v),a=Math.abs(this.value),b=n.value;if(n.isSmall){b=Math.abs(b);return a===b?0:a>b?1:-1}return-1};BigInteger.prototype.compare=function(v){if(v===Infinity){return-1}if(v===-Infinity){return 1}var n=parseValue(v),a=this.value,b=n.value;if(this.sign!==n.sign){return n.sign?1:-1}if(n.isSmall){return this.sign?-1:1}return compareAbs(a,b)*(this.sign?-1:1)};BigInteger.prototype.compareTo=BigInteger.prototype.compare;SmallInteger.prototype.compare=function(v){if(v===Infinity){return-1}if(v===-Infinity){return 1}var n=parseValue(v),a=this.value,b=n.value;if(n.isSmall){return a==b?0:a>b?1:-1}if(a<0!==n.sign){return a<0?-1:1}return a<0?1:-1};SmallInteger.prototype.compareTo=SmallInteger.prototype.compare;BigInteger.prototype.equals=function(v){return this.compare(v)===0};SmallInteger.prototype.eq=SmallInteger.prototype.equals=BigInteger.prototype.eq=BigInteger.prototype.equals;BigInteger.prototype.notEquals=function(v){return this.compare(v)!==0};SmallInteger.prototype.neq=SmallInteger.prototype.notEquals=BigInteger.prototype.neq=BigInteger.prototype.notEquals;BigInteger.prototype.greater=function(v){return this.compare(v)>0};SmallInteger.prototype.gt=SmallInteger.prototype.greater=BigInteger.prototype.gt=BigInteger.prototype.greater;BigInteger.prototype.lesser=function(v){return this.compare(v)<0};SmallInteger.prototype.lt=SmallInteger.prototype.lesser=BigInteger.prototype.lt=BigInteger.prototype.lesser;BigInteger.prototype.greaterOrEquals=function(v){return this.compare(v)>=0};SmallInteger.prototype.geq=SmallInteger.prototype.greaterOrEquals=BigInteger.prototype.geq=BigInteger.prototype.greaterOrEquals;BigInteger.prototype.lesserOrEquals=function(v){return this.compare(v)<=0};SmallInteger.prototype.leq=SmallInteger.prototype.lesserOrEquals=BigInteger.prototype.leq=BigInteger.prototype.lesserOrEquals;BigInteger.prototype.isEven=function(){return(this.value[0]&1)===0};SmallInteger.prototype.isEven=function(){return(this.value&1)===0};BigInteger.prototype.isOdd=function(){return(this.value[0]&1)===1};SmallInteger.prototype.isOdd=function(){return(this.value&1)===1};BigInteger.prototype.isPositive=function(){return!this.sign};SmallInteger.prototype.isPositive=function(){return this.value>0};BigInteger.prototype.isNegative=function(){return this.sign};SmallInteger.prototype.isNegative=function(){return this.value<0};BigInteger.prototype.isUnit=function(){return false};SmallInteger.prototype.isUnit=function(){return Math.abs(this.value)===1};BigInteger.prototype.isZero=function(){return false};SmallInteger.prototype.isZero=function(){return this.value===0};BigInteger.prototype.isDivisibleBy=function(v){var n=parseValue(v);var value=n.value;if(value===0)return false;if(value===1)return true;if(value===2)return this.isEven();return this.mod(n).equals(Integer[0])};SmallInteger.prototype.isDivisibleBy=BigInteger.prototype.isDivisibleBy;function isBasicPrime(v){var n=v.abs();if(n.isUnit())return false;if(n.equals(2)||n.equals(3)||n.equals(5))return true;if(n.isEven()||n.isDivisibleBy(3)||n.isDivisibleBy(5))return false;if(n.lesser(49))return true}function millerRabinTest(n,a){var nPrev=n.prev(),b=nPrev,r=0,d,t,i,x;while(b.isEven())b=b.divide(2),r++;next:for(i=0;i<a.length;i++){if(n.lesser(a[i]))continue;x=bigInt(a[i]).modPow(b,n);if(x.equals(Integer[1])||x.equals(nPrev))continue;for(d=r-1;d!=0;d--){x=x.square().mod(n);if(x.isUnit())return false;if(x.equals(nPrev))continue next}return false}return true}BigInteger.prototype.isPrime=function(strict){var isPrime=isBasicPrime(this);if(isPrime!==undefined)return isPrime;var n=this.abs();var bits=n.bitLength();if(bits<=64)return millerRabinTest(n,[2,325,9375,28178,450775,9780504,1795265022]);var logN=Math.log(2)*bits;var t=Math.ceil(strict===true?2*Math.pow(logN,2):logN);for(var a=[],i=0;i<t;i++){a.push(bigInt(i+2))}return millerRabinTest(n,a)};SmallInteger.prototype.isPrime=BigInteger.prototype.isPrime;BigInteger.prototype.isProbablePrime=function(iterations){var isPrime=isBasicPrime(this);if(isPrime!==undefined)return isPrime;var n=this.abs();var t=iterations===undefined?5:iterations;for(var a=[],i=0;i<t;i++){a.push(bigInt.randBetween(2,n.minus(2)))}return millerRabinTest(n,a)};SmallInteger.prototype.isProbablePrime=BigInteger.prototype.isProbablePrime;BigInteger.prototype.modInv=function(n){var t=bigInt.zero,newT=bigInt.one,r=parseValue(n),newR=this.abs(),q,lastT,lastR;while(!newR.equals(bigInt.zero)){q=r.divide(newR);lastT=t;lastR=r;t=newT;r=newR;newT=lastT.subtract(q.multiply(newT));newR=lastR.subtract(q.multiply(newR))}if(!r.equals(1))throw new Error(this.toString()+\" and \"+n.toString()+\" are not co-prime\");if(t.compare(0)===-1){t=t.add(n)}if(this.isNegative()){return t.negate()}return t};SmallInteger.prototype.modInv=BigInteger.prototype.modInv;BigInteger.prototype.next=function(){var value=this.value;if(this.sign){return subtractSmall(value,1,this.sign)}return new BigInteger(addSmall(value,1),this.sign)};SmallInteger.prototype.next=function(){var value=this.value;if(value+1<MAX_INT)return new SmallInteger(value+1);return new BigInteger(MAX_INT_ARR,false)};BigInteger.prototype.prev=function(){var value=this.value;if(this.sign){return new BigInteger(addSmall(value,1),true)}return subtractSmall(value,1,this.sign)};SmallInteger.prototype.prev=function(){var value=this.value;if(value-1>-MAX_INT)return new SmallInteger(value-1);return new BigInteger(MAX_INT_ARR,true)};var powersOfTwo=[1];while(2*powersOfTwo[powersOfTwo.length-1]<=BASE)powersOfTwo.push(2*powersOfTwo[powersOfTwo.length-1]);var powers2Length=powersOfTwo.length,highestPower2=powersOfTwo[powers2Length-1];function shift_isSmall(n){return(typeof n===\"number\"||typeof n===\"string\")&&+Math.abs(n)<=BASE||n instanceof BigInteger&&n.value.length<=1}BigInteger.prototype.shiftLeft=function(n){if(!shift_isSmall(n)){throw new Error(String(n)+\" is too large for shifting.\")}n=+n;if(n<0)return this.shiftRight(-n);var result=this;if(result.isZero())return result;while(n>=powers2Length){result=result.multiply(highestPower2);n-=powers2Length-1}return result.multiply(powersOfTwo[n])};SmallInteger.prototype.shiftLeft=BigInteger.prototype.shiftLeft;BigInteger.prototype.shiftRight=function(n){var remQuo;if(!shift_isSmall(n)){throw new Error(String(n)+\" is too large for shifting.\")}n=+n;if(n<0)return this.shiftLeft(-n);var result=this;while(n>=powers2Length){if(result.isZero()||result.isNegative()&&result.isUnit())return result;remQuo=divModAny(result,highestPower2);result=remQuo[1].isNegative()?remQuo[0].prev():remQuo[0];n-=powers2Length-1}remQuo=divModAny(result,powersOfTwo[n]);return remQuo[1].isNegative()?remQuo[0].prev():remQuo[0]};SmallInteger.prototype.shiftRight=BigInteger.prototype.shiftRight;function bitwise(x,y,fn){y=parseValue(y);var xSign=x.isNegative(),ySign=y.isNegative();var xRem=xSign?x.not():x,yRem=ySign?y.not():y;var xDigit=0,yDigit=0;var xDivMod=null,yDivMod=null;var result=[];while(!xRem.isZero()||!yRem.isZero()){xDivMod=divModAny(xRem,highestPower2);xDigit=xDivMod[1].toJSNumber();if(xSign){xDigit=highestPower2-1-xDigit}yDivMod=divModAny(yRem,highestPower2);yDigit=yDivMod[1].toJSNumber();if(ySign){yDigit=highestPower2-1-yDigit}xRem=xDivMod[0];yRem=yDivMod[0];result.push(fn(xDigit,yDigit))}var sum=fn(xSign?1:0,ySign?1:0)!==0?bigInt(-1):bigInt(0);for(var i=result.length-1;i>=0;i-=1){sum=sum.multiply(highestPower2).add(bigInt(result[i]))}return sum}BigInteger.prototype.not=function(){return this.negate().prev()};SmallInteger.prototype.not=BigInteger.prototype.not;BigInteger.prototype.and=function(n){return bitwise(this,n,function(a,b){return a&b})};SmallInteger.prototype.and=BigInteger.prototype.and;BigInteger.prototype.or=function(n){return bitwise(this,n,function(a,b){return a|b})};SmallInteger.prototype.or=BigInteger.prototype.or;BigInteger.prototype.xor=function(n){return bitwise(this,n,function(a,b){return a^b})};SmallInteger.prototype.xor=BigInteger.prototype.xor;var LOBMASK_I=1<<30,LOBMASK_BI=(BASE&-BASE)*(BASE&-BASE)|LOBMASK_I;function roughLOB(n){var v=n.value,x=typeof v===\"number\"?v|LOBMASK_I:v[0]+v[1]*BASE|LOBMASK_BI;return x&-x}function integerLogarithm(value,base){if(base.compareTo(value)<=0){var tmp=integerLogarithm(value,base.square(base));var p=tmp.p;var e=tmp.e;var t=p.multiply(base);return t.compareTo(value)<=0?{p:t,e:e*2+1}:{p:p,e:e*2}}return{p:bigInt(1),e:0}}BigInteger.prototype.bitLength=function(){var n=this;if(n.compareTo(bigInt(0))<0){n=n.negate().subtract(bigInt(1))}if(n.compareTo(bigInt(0))===0){return bigInt(0)}return bigInt(integerLogarithm(n,bigInt(2)).e).add(bigInt(1))};SmallInteger.prototype.bitLength=BigInteger.prototype.bitLength;function max(a,b){a=parseValue(a);b=parseValue(b);return a.greater(b)?a:b}function min(a,b){a=parseValue(a);b=parseValue(b);return a.lesser(b)?a:b}function gcd(a,b){a=parseValue(a).abs();b=parseValue(b).abs();if(a.equals(b))return a;if(a.isZero())return b;if(b.isZero())return a;var c=Integer[1],d,t;while(a.isEven()&&b.isEven()){d=Math.min(roughLOB(a),roughLOB(b));a=a.divide(d);b=b.divide(d);c=c.multiply(d)}while(a.isEven()){a=a.divide(roughLOB(a))}do{while(b.isEven()){b=b.divide(roughLOB(b))}if(a.greater(b)){t=b;b=a;a=t}b=b.subtract(a)}while(!b.isZero());return c.isUnit()?a:a.multiply(c)}function lcm(a,b){a=parseValue(a).abs();b=parseValue(b).abs();return a.divide(gcd(a,b)).multiply(b)}function randBetween(a,b){a=parseValue(a);b=parseValue(b);var low=min(a,b),high=max(a,b);var range=high.subtract(low).add(1);if(range.isSmall)return low.add(Math.floor(Math.random()*range));var length=range.value.length-1;var result=[],restricted=true;for(var i=length;i>=0;i--){var top=restricted?range.value[i]:BASE;var digit=truncate(Math.random()*top);result.unshift(digit);if(digit<top)restricted=false}result=arrayToSmall(result);return low.add(typeof result===\"number\"?new SmallInteger(result):new BigInteger(result,false))}var parseBase=function(text,base){var length=text.length;var i;var absBase=Math.abs(base);for(var i=0;i<length;i++){var c=text[i].toLowerCase();if(c===\"-\")continue;if(/[a-z0-9]/.test(c)){if(/[0-9]/.test(c)&&+c>=absBase){if(c===\"1\"&&absBase===1)continue;throw new Error(c+\" is not a valid digit in base \"+base+\".\")}else if(c.charCodeAt(0)-87>=absBase){throw new Error(c+\" is not a valid digit in base \"+base+\".\")}}}if(2<=base&&base<=36){if(length<=LOG_MAX_INT/Math.log(base)){var result=parseInt(text,base);if(isNaN(result)){throw new Error(c+\" is not a valid digit in base \"+base+\".\")}return new SmallInteger(parseInt(text,base))}}base=parseValue(base);var digits=[];var isNegative=text[0]===\"-\";for(i=isNegative?1:0;i<text.length;i++){var c=text[i].toLowerCase(),charCode=c.charCodeAt(0);if(48<=charCode&&charCode<=57)digits.push(parseValue(c));else if(97<=charCode&&charCode<=122)digits.push(parseValue(c.charCodeAt(0)-87));else if(c===\"<\"){var start=i;do{i++}while(text[i]!==\">\");digits.push(parseValue(text.slice(start+1,i)))}else throw new Error(c+\" is not a valid character\")}return parseBaseFromArray(digits,base,isNegative)};function parseBaseFromArray(digits,base,isNegative){var val=Integer[0],pow=Integer[1],i;for(i=digits.length-1;i>=0;i--){val=val.add(digits[i].times(pow));pow=pow.times(base)}return isNegative?val.negate():val}function stringify(digit){if(digit<=35){return\"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(digit)}return\"<\"+digit+\">\"}function toBase(n,base){base=bigInt(base);if(base.isZero()){if(n.isZero())return{value:[0],isNegative:false};throw new Error(\"Cannot convert nonzero numbers to base 0.\")}if(base.equals(-1)){if(n.isZero())return{value:[0],isNegative:false};if(n.isNegative())return{value:[].concat.apply([],Array.apply(null,Array(-n)).map(Array.prototype.valueOf,[1,0])),isNegative:false};var arr=Array.apply(null,Array(+n-1)).map(Array.prototype.valueOf,[0,1]);arr.unshift([1]);return{value:[].concat.apply([],arr),isNegative:false}}var neg=false;if(n.isNegative()&&base.isPositive()){neg=true;n=n.abs()}if(base.equals(1)){if(n.isZero())return{value:[0],isNegative:false};return{value:Array.apply(null,Array(+n)).map(Number.prototype.valueOf,1),isNegative:neg}}var out=[];var left=n,divmod;while(left.isNegative()||left.compareAbs(base)>=0){divmod=left.divmod(base);left=divmod.quotient;var digit=divmod.remainder;if(digit.isNegative()){digit=base.minus(digit).abs();left=left.next()}out.push(digit.toJSNumber())}out.push(left.toJSNumber());return{value:out.reverse(),isNegative:neg}}function toBaseString(n,base){var arr=toBase(n,base);return(arr.isNegative?\"-\":\"\")+arr.value.map(stringify).join(\"\")}BigInteger.prototype.toArray=function(radix){return toBase(this,radix)};SmallInteger.prototype.toArray=function(radix){return toBase(this,radix)};BigInteger.prototype.toString=function(radix){if(radix===undefined)radix=10;if(radix!==10)return toBaseString(this,radix);var v=this.value,l=v.length,str=String(v[--l]),zeros=\"0000000\",digit;while(--l>=0){digit=String(v[l]);str+=zeros.slice(digit.length)+digit}var sign=this.sign?\"-\":\"\";return sign+str};SmallInteger.prototype.toString=function(radix){if(radix===undefined)radix=10;if(radix!=10)return toBaseString(this,radix);return String(this.value)};BigInteger.prototype.toJSON=SmallInteger.prototype.toJSON=function(){return this.toString()};BigInteger.prototype.valueOf=function(){return parseInt(this.toString(),10)};BigInteger.prototype.toJSNumber=BigInteger.prototype.valueOf;SmallInteger.prototype.valueOf=function(){return this.value};SmallInteger.prototype.toJSNumber=SmallInteger.prototype.valueOf;function parseStringValue(v){if(isPrecise(+v)){var x=+v;if(x===truncate(x))return new SmallInteger(x);throw new Error(\"Invalid integer: \"+v)}var sign=v[0]===\"-\";if(sign)v=v.slice(1);var split=v.split(/e/i);if(split.length>2)throw new Error(\"Invalid integer: \"+split.join(\"e\"));if(split.length===2){var exp=split[1];if(exp[0]===\"+\")exp=exp.slice(1);exp=+exp;if(exp!==truncate(exp)||!isPrecise(exp))throw new Error(\"Invalid integer: \"+exp+\" is not a valid exponent.\");var text=split[0];var decimalPlace=text.indexOf(\".\");if(decimalPlace>=0){exp-=text.length-decimalPlace-1;text=text.slice(0,decimalPlace)+text.slice(decimalPlace+1)}if(exp<0)throw new Error(\"Cannot include negative exponent part for integers\");text+=new Array(exp+1).join(\"0\");v=text}var isValid=/^([0-9][0-9]*)$/.test(v);if(!isValid)throw new Error(\"Invalid integer: \"+v);var r=[],max=v.length,l=LOG_BASE,min=max-l;while(max>0){r.push(+v.slice(min,max));min-=l;if(min<0)min=0;max-=l}trim(r);return new BigInteger(r,sign)}function parseNumberValue(v){if(isPrecise(v)){if(v!==truncate(v))throw new Error(v+\" is not an integer.\");return new SmallInteger(v)}return parseStringValue(v.toString())}function parseValue(v){if(typeof v===\"number\"){return parseNumberValue(v)}if(typeof v===\"string\"){return parseStringValue(v)}return v}for(var i=0;i<1e3;i++){Integer[i]=new SmallInteger(i);if(i>0)Integer[-i]=new SmallInteger(-i)}Integer.one=Integer[1];Integer.zero=Integer[0];Integer.minusOne=Integer[-1];Integer.max=max;Integer.min=min;Integer.gcd=gcd;Integer.lcm=lcm;Integer.isInstance=function(x){return x instanceof BigInteger||x instanceof SmallInteger};Integer.randBetween=randBetween;Integer.fromArray=function(digits,base,isNegative){return parseBaseFromArray(digits.map(parseValue),parseValue(base||10),isNegative)};return Integer}();if( true&&module.hasOwnProperty(\"exports\")){module.exports=bigInt}if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return bigInt}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}\r\n        return bigInt;\r\n    })(),\r\n    /*\r\n     *  decimal.js v10.2.1\r\n     *  An arbitrary-precision Decimal type for JavaScript.\r\n     *  https://github.com/MikeMcl/decimal.js\r\n     *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>\r\n     *  MIT Licence\r\n     */\r\n    bigDec: function(n){\"use strict\";var e,i,t,r,s=9e15,o=1e9,u=\"0123456789abcdef\",c=\"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\",f=\"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\",a={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-s,maxE:s,crypto:!1},h=!0,d=\"[DecimalError] \",l=d+\"Invalid argument: \",p=d+\"Precision limit exceeded\",g=d+\"crypto unavailable\",m=Math.floor,w=Math.pow,v=/^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,N=/^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,b=/^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,E=/^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,x=1e7,y=7,M=c.length-1,q=f.length-1,O={name:\"[object Decimal]\"};function D(n){var e,i,t,r=n.length-1,s=\"\",o=n[0];if(r>0){for(s+=o,e=1;e<r;e++)t=n[e]+\"\",(i=y-t.length)&&(s+=k(i)),s+=t;o=n[e],(i=y-(t=o+\"\").length)&&(s+=k(i))}else if(0===o)return\"0\";for(;o%10==0;)o/=10;return s+o}function F(n,e,i){if(n!==~~n||n<e||n>i)throw Error(l+n)}function A(n,e,i,t){var r,s,o,u;for(s=n[0];s>=10;s/=10)--e;return--e<0?(e+=y,r=0):(r=Math.ceil((e+1)/y),e%=y),s=w(10,y-e),u=n[r]%s|0,null==t?e<3?(0==e?u=u/100|0:1==e&&(u=u/10|0),o=i<4&&99999==u||i>3&&49999==u||5e4==u||0==u):o=(i<4&&u+1==s||i>3&&u+1==s/2)&&(n[r+1]/s/100|0)==w(10,e-2)-1||(u==s/2||0==u)&&0==(n[r+1]/s/100|0):e<4?(0==e?u=u/1e3|0:1==e?u=u/100|0:2==e&&(u=u/10|0),o=(t||i<4)&&9999==u||!t&&i>3&&4999==u):o=((t||i<4)&&u+1==s||!t&&i>3&&u+1==s/2)&&(n[r+1]/s/1e3|0)==w(10,e-3)-1,o}function S(n,e,i){for(var t,r,s=[0],o=0,c=n.length;o<c;){for(r=s.length;r--;)s[r]*=e;for(s[0]+=u.indexOf(n.charAt(o++)),t=0;t<s.length;t++)s[t]>i-1&&(void 0===s[t+1]&&(s[t+1]=0),s[t+1]+=s[t]/i|0,s[t]%=i)}return s.reverse()}O.absoluteValue=O.abs=function(){var n=new this.constructor(this);return n.s<0&&(n.s=1),P(n)},O.ceil=function(){return P(new this.constructor(this),this.e+1,2)},O.comparedTo=O.cmp=function(n){var e,i,t,r,s=this,o=s.d,u=(n=new s.constructor(n)).d,c=s.s,f=n.s;if(!o||!u)return c&&f?c!==f?c:o===u?0:!o^c<0?1:-1:NaN;if(!o[0]||!u[0])return o[0]?c:u[0]?-f:0;if(c!==f)return c;if(s.e!==n.e)return s.e>n.e^c<0?1:-1;for(e=0,i=(t=o.length)<(r=u.length)?t:r;e<i;++e)if(o[e]!==u[e])return o[e]>u[e]^c<0?1:-1;return t===r?0:t>r^c<0?1:-1},O.cosine=O.cos=function(){var n,e,i=this,t=i.constructor;return i.d?i.d[0]?(n=t.precision,e=t.rounding,t.precision=n+Math.max(i.e,i.sd())+y,t.rounding=1,i=function(n,e){var i,t,r=e.d.length;r<32?(i=Math.ceil(r/3),t=(1/z(4,i)).toString()):(i=16,t=\"2.3283064365386962890625e-10\");n.precision+=i,e=J(n,1,e.times(t),new n(1));for(var s=i;s--;){var o=e.times(e);e=o.times(o).minus(o).times(8).plus(1)}return n.precision-=i,e}(t,G(t,i)),t.precision=n,t.rounding=e,P(2==r||3==r?i.neg():i,n,e,!0)):new t(1):new t(NaN)},O.cubeRoot=O.cbrt=function(){var n,e,i,t,r,s,o,u,c,f,a=this,d=a.constructor;if(!a.isFinite()||a.isZero())return new d(a);for(h=!1,(s=a.s*w(a.s*a,1/3))&&Math.abs(s)!=1/0?t=new d(s.toString()):(i=D(a.d),(s=((n=a.e)-i.length+1)%3)&&(i+=1==s||-2==s?\"0\":\"00\"),s=w(i,1/3),n=m((n+1)/3)-(n%3==(n<0?-1:2)),(t=new d(i=s==1/0?\"5e\"+n:(i=s.toExponential()).slice(0,i.indexOf(\"e\")+1)+n)).s=a.s),o=(n=d.precision)+3;;)if(f=(c=(u=t).times(u).times(u)).plus(a),t=Z(f.plus(a).times(u),f.plus(c),o+2,1),D(u.d).slice(0,o)===(i=D(t.d)).slice(0,o)){if(\"9999\"!=(i=i.slice(o-3,o+1))&&(r||\"4999\"!=i)){+i&&(+i.slice(1)||\"5\"!=i.charAt(0))||(P(t,n+1,1),e=!t.times(t).times(t).eq(a));break}if(!r&&(P(u,n+1,0),u.times(u).times(u).eq(a))){t=u;break}o+=4,r=1}return h=!0,P(t,n,d.rounding,e)},O.decimalPlaces=O.dp=function(){var n,e=this.d,i=NaN;if(e){if(i=((n=e.length-1)-m(this.e/y))*y,n=e[n])for(;n%10==0;n/=10)i--;i<0&&(i=0)}return i},O.dividedBy=O.div=function(n){return Z(this,new this.constructor(n))},O.dividedToIntegerBy=O.divToInt=function(n){var e=this.constructor;return P(Z(this,new e(n),0,1,1),e.precision,e.rounding)},O.equals=O.eq=function(n){return 0===this.cmp(n)},O.floor=function(){return P(new this.constructor(this),this.e+1,3)},O.greaterThan=O.gt=function(n){return this.cmp(n)>0},O.greaterThanOrEqualTo=O.gte=function(n){var e=this.cmp(n);return 1==e||0===e},O.hyperbolicCosine=O.cosh=function(){var n,e,i,t,r,s=this,o=s.constructor,u=new o(1);if(!s.isFinite())return new o(s.s?1/0:NaN);if(s.isZero())return u;i=o.precision,t=o.rounding,o.precision=i+Math.max(s.e,s.sd())+4,o.rounding=1,(r=s.d.length)<32?e=(1/z(4,n=Math.ceil(r/3))).toString():(n=16,e=\"2.3283064365386962890625e-10\"),s=J(o,1,s.times(e),new o(1),!0);for(var c,f=n,a=new o(8);f--;)c=s.times(s),s=u.minus(c.times(a.minus(c.times(a))));return P(s,o.precision=i,o.rounding=t,!0)},O.hyperbolicSine=O.sinh=function(){var n,e,i,t,r=this,s=r.constructor;if(!r.isFinite()||r.isZero())return new s(r);if(e=s.precision,i=s.rounding,s.precision=e+Math.max(r.e,r.sd())+4,s.rounding=1,(t=r.d.length)<3)r=J(s,2,r,r,!0);else{n=(n=1.4*Math.sqrt(t))>16?16:0|n,r=J(s,2,r=r.times(1/z(5,n)),r,!0);for(var o,u=new s(5),c=new s(16),f=new s(20);n--;)o=r.times(r),r=r.times(u.plus(o.times(c.times(o).plus(f))))}return s.precision=e,s.rounding=i,P(r,e,i,!0)},O.hyperbolicTangent=O.tanh=function(){var n,e,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(n=t.precision,e=t.rounding,t.precision=n+7,t.rounding=1,Z(i.sinh(),i.cosh(),t.precision=n,t.rounding=e)):new t(i.s)},O.inverseCosine=O.acos=function(){var n,e=this,i=e.constructor,t=e.abs().cmp(1),r=i.precision,s=i.rounding;return-1!==t?0===t?e.isNeg()?U(i,r,s):new i(0):new i(NaN):e.isZero()?U(i,r+4,s).times(.5):(i.precision=r+6,i.rounding=1,e=e.asin(),n=U(i,r+4,s).times(.5),i.precision=r,i.rounding=s,n.minus(e))},O.inverseHyperbolicCosine=O.acosh=function(){var n,e,i=this,t=i.constructor;return i.lte(1)?new t(i.eq(1)?0:NaN):i.isFinite()?(n=t.precision,e=t.rounding,t.precision=n+Math.max(Math.abs(i.e),i.sd())+4,t.rounding=1,h=!1,i=i.times(i).minus(1).sqrt().plus(i),h=!0,t.precision=n,t.rounding=e,i.ln()):new t(i)},O.inverseHyperbolicSine=O.asinh=function(){var n,e,i=this,t=i.constructor;return!i.isFinite()||i.isZero()?new t(i):(n=t.precision,e=t.rounding,t.precision=n+2*Math.max(Math.abs(i.e),i.sd())+6,t.rounding=1,h=!1,i=i.times(i).plus(1).sqrt().plus(i),h=!0,t.precision=n,t.rounding=e,i.ln())},O.inverseHyperbolicTangent=O.atanh=function(){var n,e,i,t,r=this,s=r.constructor;return r.isFinite()?r.e>=0?new s(r.abs().eq(1)?r.s/0:r.isZero()?r:NaN):(n=s.precision,e=s.rounding,t=r.sd(),Math.max(t,n)<2*-r.e-1?P(new s(r),n,e,!0):(s.precision=i=t-r.e,r=Z(r.plus(1),new s(1).minus(r),i+n,1),s.precision=n+4,s.rounding=1,r=r.ln(),s.precision=n,s.rounding=e,r.times(.5))):new s(NaN)},O.inverseSine=O.asin=function(){var n,e,i,t,r=this,s=r.constructor;return r.isZero()?new s(r):(e=r.abs().cmp(1),i=s.precision,t=s.rounding,-1!==e?0===e?((n=U(s,i+4,t).times(.5)).s=r.s,n):new s(NaN):(s.precision=i+6,s.rounding=1,r=r.div(new s(1).minus(r.times(r)).sqrt().plus(1)).atan(),s.precision=i,s.rounding=t,r.times(2)))},O.inverseTangent=O.atan=function(){var n,e,i,t,r,s,o,u,c,f=this,a=f.constructor,d=a.precision,l=a.rounding;if(f.isFinite()){if(f.isZero())return new a(f);if(f.abs().eq(1)&&d+4<=q)return(o=U(a,d+4,l).times(.25)).s=f.s,o}else{if(!f.s)return new a(NaN);if(d+4<=q)return(o=U(a,d+4,l).times(.5)).s=f.s,o}for(a.precision=u=d+10,a.rounding=1,n=i=Math.min(28,u/y+2|0);n;--n)f=f.div(f.times(f).plus(1).sqrt().plus(1));for(h=!1,e=Math.ceil(u/y),t=1,c=f.times(f),o=new a(f),r=f;-1!==n;)if(r=r.times(c),s=o.minus(r.div(t+=2)),r=r.times(c),void 0!==(o=s.plus(r.div(t+=2))).d[e])for(n=e;o.d[n]===s.d[n]&&n--;);return i&&(o=o.times(2<<i-1)),h=!0,P(o,a.precision=d,a.rounding=l,!0)},O.isFinite=function(){return!!this.d},O.isInteger=O.isInt=function(){return!!this.d&&m(this.e/y)>this.d.length-2},O.isNaN=function(){return!this.s},O.isNegative=O.isNeg=function(){return this.s<0},O.isPositive=O.isPos=function(){return this.s>0},O.isZero=function(){return!!this.d&&0===this.d[0]},O.lessThan=O.lt=function(n){return this.cmp(n)<0},O.lessThanOrEqualTo=O.lte=function(n){return this.cmp(n)<1},O.logarithm=O.log=function(n){var e,i,t,r,s,o,u,c,f=this.constructor,a=f.precision,d=f.rounding;if(null==n)n=new f(10),e=!0;else{if(i=(n=new f(n)).d,n.s<0||!i||!i[0]||n.eq(1))return new f(NaN);e=n.eq(10)}if(i=this.d,this.s<0||!i||!i[0]||this.eq(1))return new f(i&&!i[0]?-1/0:1!=this.s?NaN:i?0:1/0);if(e)if(i.length>1)s=!0;else{for(r=i[0];r%10==0;)r/=10;s=1!==r}if(h=!1,o=V(this,u=a+5),t=e?T(f,u+10):V(n,u),A((c=Z(o,t,u,1)).d,r=a,d))do{if(o=V(this,u+=10),t=e?T(f,u+10):V(n,u),c=Z(o,t,u,1),!s){+D(c.d).slice(r+1,r+15)+1==1e14&&(c=P(c,a+1,0));break}}while(A(c.d,r+=10,d));return h=!0,P(c,a,d)},O.minus=O.sub=function(n){var e,i,t,r,s,o,u,c,f,a,d,l,p=this,g=p.constructor;if(n=new g(n),!p.d||!n.d)return p.s&&n.s?p.d?n.s=-n.s:n=new g(n.d||p.s!==n.s?p:NaN):n=new g(NaN),n;if(p.s!=n.s)return n.s=-n.s,p.plus(n);if(f=p.d,l=n.d,u=g.precision,c=g.rounding,!f[0]||!l[0]){if(l[0])n.s=-n.s;else{if(!f[0])return new g(3===c?-0:0);n=new g(p)}return h?P(n,u,c):n}if(i=m(n.e/y),a=m(p.e/y),f=f.slice(),s=a-i){for((d=s<0)?(e=f,s=-s,o=l.length):(e=l,i=a,o=f.length),s>(t=Math.max(Math.ceil(u/y),o)+2)&&(s=t,e.length=1),e.reverse(),t=s;t--;)e.push(0);e.reverse()}else{for((d=(t=f.length)<(o=l.length))&&(o=t),t=0;t<o;t++)if(f[t]!=l[t]){d=f[t]<l[t];break}s=0}for(d&&(e=f,f=l,l=e,n.s=-n.s),o=f.length,t=l.length-o;t>0;--t)f[o++]=0;for(t=l.length;t>s;){if(f[--t]<l[t]){for(r=t;r&&0===f[--r];)f[r]=x-1;--f[r],f[t]+=x}f[t]-=l[t]}for(;0===f[--o];)f.pop();for(;0===f[0];f.shift())--i;return f[0]?(n.d=f,n.e=L(f,i),h?P(n,u,c):n):new g(3===c?-0:0)},O.modulo=O.mod=function(n){var e,i=this,t=i.constructor;return n=new t(n),!i.d||!n.s||n.d&&!n.d[0]?new t(NaN):!n.d||i.d&&!i.d[0]?P(new t(i),t.precision,t.rounding):(h=!1,9==t.modulo?(e=Z(i,n.abs(),0,3,1)).s*=n.s:e=Z(i,n,0,t.modulo,1),e=e.times(n),h=!0,i.minus(e))},O.naturalExponential=O.exp=function(){return B(this)},O.naturalLogarithm=O.ln=function(){return V(this)},O.negated=O.neg=function(){var n=new this.constructor(this);return n.s=-n.s,P(n)},O.plus=O.add=function(n){var e,i,t,r,s,o,u,c,f,a,d=this,l=d.constructor;if(n=new l(n),!d.d||!n.d)return d.s&&n.s?d.d||(n=new l(n.d||d.s===n.s?d:NaN)):n=new l(NaN),n;if(d.s!=n.s)return n.s=-n.s,d.minus(n);if(f=d.d,a=n.d,u=l.precision,c=l.rounding,!f[0]||!a[0])return a[0]||(n=new l(d)),h?P(n,u,c):n;if(s=m(d.e/y),t=m(n.e/y),f=f.slice(),r=s-t){for(r<0?(i=f,r=-r,o=a.length):(i=a,t=s,o=f.length),r>(o=(s=Math.ceil(u/y))>o?s+1:o+1)&&(r=o,i.length=1),i.reverse();r--;)i.push(0);i.reverse()}for((o=f.length)-(r=a.length)<0&&(r=o,i=a,a=f,f=i),e=0;r;)e=(f[--r]=f[r]+a[r]+e)/x|0,f[r]%=x;for(e&&(f.unshift(e),++t),o=f.length;0==f[--o];)f.pop();return n.d=f,n.e=L(f,t),h?P(n,u,c):n},O.precision=O.sd=function(n){var e,i=this;if(void 0!==n&&n!==!!n&&1!==n&&0!==n)throw Error(l+n);return i.d?(e=_(i.d),n&&i.e+1>e&&(e=i.e+1)):e=NaN,e},O.round=function(){var n=this,e=n.constructor;return P(new e(n),n.e+1,e.rounding)},O.sine=O.sin=function(){var n,e,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(n=t.precision,e=t.rounding,t.precision=n+Math.max(i.e,i.sd())+y,t.rounding=1,i=function(n,e){var i,t=e.d.length;if(t<3)return J(n,2,e,e);i=(i=1.4*Math.sqrt(t))>16?16:0|i,e=e.times(1/z(5,i)),e=J(n,2,e,e);for(var r,s=new n(5),o=new n(16),u=new n(20);i--;)r=e.times(e),e=e.times(s.plus(r.times(o.times(r).minus(u))));return e}(t,G(t,i)),t.precision=n,t.rounding=e,P(r>2?i.neg():i,n,e,!0)):new t(NaN)},O.squareRoot=O.sqrt=function(){var n,e,i,t,r,s,o=this,u=o.d,c=o.e,f=o.s,a=o.constructor;if(1!==f||!u||!u[0])return new a(!f||f<0&&(!u||u[0])?NaN:u?o:1/0);for(h=!1,0==(f=Math.sqrt(+o))||f==1/0?(((e=D(u)).length+c)%2==0&&(e+=\"0\"),f=Math.sqrt(e),c=m((c+1)/2)-(c<0||c%2),t=new a(e=f==1/0?\"5e\"+c:(e=f.toExponential()).slice(0,e.indexOf(\"e\")+1)+c)):t=new a(f.toString()),i=(c=a.precision)+3;;)if(t=(s=t).plus(Z(o,s,i+2,1)).times(.5),D(s.d).slice(0,i)===(e=D(t.d)).slice(0,i)){if(\"9999\"!=(e=e.slice(i-3,i+1))&&(r||\"4999\"!=e)){+e&&(+e.slice(1)||\"5\"!=e.charAt(0))||(P(t,c+1,1),n=!t.times(t).eq(o));break}if(!r&&(P(s,c+1,0),s.times(s).eq(o))){t=s;break}i+=4,r=1}return h=!0,P(t,c,a.rounding,n)},O.tangent=O.tan=function(){var n,e,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(n=t.precision,e=t.rounding,t.precision=n+10,t.rounding=1,(i=i.sin()).s=1,i=Z(i,new t(1).minus(i.times(i)).sqrt(),n+10,0),t.precision=n,t.rounding=e,P(2==r||4==r?i.neg():i,n,e,!0)):new t(NaN)},O.times=O.mul=function(n){var e,i,t,r,s,o,u,c,f,a=this,d=a.constructor,l=a.d,p=(n=new d(n)).d;if(n.s*=a.s,!(l&&l[0]&&p&&p[0]))return new d(!n.s||l&&!l[0]&&!p||p&&!p[0]&&!l?NaN:l&&p?0*n.s:n.s/0);for(i=m(a.e/y)+m(n.e/y),(c=l.length)<(f=p.length)&&(s=l,l=p,p=s,o=c,c=f,f=o),s=[],t=o=c+f;t--;)s.push(0);for(t=f;--t>=0;){for(e=0,r=c+t;r>t;)u=s[r]+p[t]*l[r-t-1]+e,s[r--]=u%x|0,e=u/x|0;s[r]=(s[r]+e)%x|0}for(;!s[--o];)s.pop();return e?++i:s.shift(),n.d=s,n.e=L(s,i),h?P(n,d.precision,d.rounding):n},O.toBinary=function(n,e){return K(this,2,n,e)},O.toDecimalPlaces=O.toDP=function(n,e){var i=this,t=i.constructor;return i=new t(i),void 0===n?i:(F(n,0,o),void 0===e?e=t.rounding:F(e,0,8),P(i,n+i.e+1,e))},O.toExponential=function(n,e){var i,t=this,r=t.constructor;return void 0===n?i=R(t,!0):(F(n,0,o),void 0===e?e=r.rounding:F(e,0,8),i=R(t=P(new r(t),n+1,e),!0,n+1)),t.isNeg()&&!t.isZero()?\"-\"+i:i},O.toFixed=function(n,e){var i,t,r=this,s=r.constructor;return void 0===n?i=R(r):(F(n,0,o),void 0===e?e=s.rounding:F(e,0,8),i=R(t=P(new s(r),n+r.e+1,e),!1,n+t.e+1)),r.isNeg()&&!r.isZero()?\"-\"+i:i},O.toFraction=function(n){var e,i,t,r,s,o,u,c,f,a,d,p,g=this,m=g.d,v=g.constructor;if(!m)return new v(g);if(f=i=new v(1),t=c=new v(0),o=(s=(e=new v(t)).e=_(m)-g.e-1)%y,e.d[0]=w(10,o<0?y+o:o),null==n)n=s>0?e:f;else{if(!(u=new v(n)).isInt()||u.lt(f))throw Error(l+u);n=u.gt(e)?s>0?e:f:u}for(h=!1,u=new v(D(m)),a=v.precision,v.precision=s=m.length*y*2;d=Z(u,e,0,1,1),1!=(r=i.plus(d.times(t))).cmp(n);)i=t,t=r,r=f,f=c.plus(d.times(r)),c=r,r=e,e=u.minus(d.times(r)),u=r;return r=Z(n.minus(i),t,0,1,1),c=c.plus(r.times(f)),i=i.plus(r.times(t)),c.s=f.s=g.s,p=Z(f,t,s,1).minus(g).abs().cmp(Z(c,i,s,1).minus(g).abs())<1?[f,t]:[c,i],v.precision=a,h=!0,p},O.toHexadecimal=O.toHex=function(n,e){return K(this,16,n,e)},O.toNearest=function(n,e){var i=this,t=i.constructor;if(i=new t(i),null==n){if(!i.d)return i;n=new t(1),e=t.rounding}else{if(n=new t(n),void 0===e?e=t.rounding:F(e,0,8),!i.d)return n.s?i:n;if(!n.d)return n.s&&(n.s=i.s),n}return n.d[0]?(h=!1,i=Z(i,n,0,e,1).times(n),h=!0,P(i)):(n.s=i.s,i=n),i},O.toNumber=function(){return+this},O.toOctal=function(n,e){return K(this,8,n,e)},O.toPower=O.pow=function(n){var e,i,t,r,s,o,u=this,c=u.constructor,f=+(n=new c(n));if(!(u.d&&n.d&&u.d[0]&&n.d[0]))return new c(w(+u,f));if((u=new c(u)).eq(1))return u;if(t=c.precision,s=c.rounding,n.eq(1))return P(u,t,s);if((e=m(n.e/y))>=n.d.length-1&&(i=f<0?-f:f)<=9007199254740991)return r=C(c,u,i,t),n.s<0?new c(1).div(r):P(r,t,s);if((o=u.s)<0){if(e<n.d.length-1)return new c(NaN);if(0==(1&n.d[e])&&(o=1),0==u.e&&1==u.d[0]&&1==u.d.length)return u.s=o,u}return(e=0!=(i=w(+u,f))&&isFinite(i)?new c(i+\"\").e:m(f*(Math.log(\"0.\"+D(u.d))/Math.LN10+u.e+1)))>c.maxE+1||e<c.minE-1?new c(e>0?o/0:0):(h=!1,c.rounding=u.s=1,i=Math.min(12,(e+\"\").length),(r=B(n.times(V(u,t+i)),t)).d&&A((r=P(r,t+5,1)).d,t,s)&&(e=t+10,+D((r=P(B(n.times(V(u,e+i)),e),e+5,1)).d).slice(t+1,t+15)+1==1e14&&(r=P(r,t+1,0))),r.s=o,h=!0,c.rounding=s,P(r,t,s))},O.toPrecision=function(n,e){var i,t=this,r=t.constructor;return void 0===n?i=R(t,t.e<=r.toExpNeg||t.e>=r.toExpPos):(F(n,1,o),void 0===e?e=r.rounding:F(e,0,8),i=R(t=P(new r(t),n,e),n<=t.e||t.e<=r.toExpNeg,n)),t.isNeg()&&!t.isZero()?\"-\"+i:i},O.toSignificantDigits=O.toSD=function(n,e){var i=this.constructor;return void 0===n?(n=i.precision,e=i.rounding):(F(n,1,o),void 0===e?e=i.rounding:F(e,0,8)),P(new i(this),n,e)},O.toString=function(){var n=this,e=n.constructor,i=R(n,n.e<=e.toExpNeg||n.e>=e.toExpPos);return n.isNeg()&&!n.isZero()?\"-\"+i:i},O.truncated=O.trunc=function(){return P(new this.constructor(this),this.e+1,1)},O.valueOf=O.toJSON=function(){var n=this,e=n.constructor,i=R(n,n.e<=e.toExpNeg||n.e>=e.toExpPos);return n.isNeg()?\"-\"+i:i};var Z=function(){function n(n,e,i){var t,r=0,s=n.length;for(n=n.slice();s--;)t=n[s]*e+r,n[s]=t%i|0,r=t/i|0;return r&&n.unshift(r),n}function e(n,e,i,t){var r,s;if(i!=t)s=i>t?1:-1;else for(r=s=0;r<i;r++)if(n[r]!=e[r]){s=n[r]>e[r]?1:-1;break}return s}function t(n,e,i,t){for(var r=0;i--;)n[i]-=r,r=n[i]<e[i]?1:0,n[i]=r*t+n[i]-e[i];for(;!n[0]&&n.length>1;)n.shift()}return function(r,s,o,u,c,f){var a,h,d,l,p,g,w,v,N,b,E,M,q,O,D,F,A,S,Z,R,L=r.constructor,T=r.s==s.s?1:-1,U=r.d,_=s.d;if(!(U&&U[0]&&_&&_[0]))return new L(r.s&&s.s&&(U?!_||U[0]!=_[0]:_)?U&&0==U[0]||!_?0*T:T/0:NaN);for(f?(p=1,h=r.e-s.e):(f=x,p=y,h=m(r.e/p)-m(s.e/p)),Z=_.length,A=U.length,b=(N=new L(T)).d=[],d=0;_[d]==(U[d]||0);d++);if(_[d]>(U[d]||0)&&h--,null==o?(O=o=L.precision,u=L.rounding):O=c?o+(r.e-s.e)+1:o,O<0)b.push(1),g=!0;else{if(O=O/p+2|0,d=0,1==Z){for(l=0,_=_[0],O++;(d<A||l)&&O--;d++)D=l*f+(U[d]||0),b[d]=D/_|0,l=D%_|0;g=l||d<A}else{for((l=f/(_[0]+1)|0)>1&&(_=n(_,l,f),U=n(U,l,f),Z=_.length,A=U.length),F=Z,M=(E=U.slice(0,Z)).length;M<Z;)E[M++]=0;(R=_.slice()).unshift(0),S=_[0],_[1]>=f/2&&++S;do{l=0,(a=e(_,E,Z,M))<0?(q=E[0],Z!=M&&(q=q*f+(E[1]||0)),(l=q/S|0)>1?(l>=f&&(l=f-1),1==(a=e(w=n(_,l,f),E,v=w.length,M=E.length))&&(l--,t(w,Z<v?R:_,v,f))):(0==l&&(a=l=1),w=_.slice()),(v=w.length)<M&&w.unshift(0),t(E,w,M,f),-1==a&&(a=e(_,E,Z,M=E.length))<1&&(l++,t(E,Z<M?R:_,M,f)),M=E.length):0===a&&(l++,E=[0]),b[d++]=l,a&&E[0]?E[M++]=U[F]||0:(E=[U[F]],M=1)}while((F++<A||void 0!==E[0])&&O--);g=void 0!==E[0]}b[0]||b.shift()}if(1==p)N.e=h,i=g;else{for(d=1,l=b[0];l>=10;l/=10)d++;N.e=d+h*p-1,P(N,c?o+N.e+1:o,u,g)}return N}}();function P(n,e,i,t){var r,s,o,u,c,f,a,d,l,p=n.constructor;n:if(null!=e){if(!(d=n.d))return n;for(r=1,u=d[0];u>=10;u/=10)r++;if((s=e-r)<0)s+=y,o=e,c=(a=d[l=0])/w(10,r-o-1)%10|0;else if((l=Math.ceil((s+1)/y))>=(u=d.length)){if(!t)break n;for(;u++<=l;)d.push(0);a=c=0,r=1,o=(s%=y)-y+1}else{for(a=u=d[l],r=1;u>=10;u/=10)r++;c=(o=(s%=y)-y+r)<0?0:a/w(10,r-o-1)%10|0}if(t=t||e<0||void 0!==d[l+1]||(o<0?a:a%w(10,r-o-1)),f=i<4?(c||t)&&(0==i||i==(n.s<0?3:2)):c>5||5==c&&(4==i||t||6==i&&(s>0?o>0?a/w(10,r-o):0:d[l-1])%10&1||i==(n.s<0?8:7)),e<1||!d[0])return d.length=0,f?(e-=n.e+1,d[0]=w(10,(y-e%y)%y),n.e=-e||0):d[0]=n.e=0,n;if(0==s?(d.length=l,u=1,l--):(d.length=l+1,u=w(10,y-s),d[l]=o>0?(a/w(10,r-o)%w(10,o)|0)*u:0),f)for(;;){if(0==l){for(s=1,o=d[0];o>=10;o/=10)s++;for(o=d[0]+=u,u=1;o>=10;o/=10)u++;s!=u&&(n.e++,d[0]==x&&(d[0]=1));break}if(d[l]+=u,d[l]!=x)break;d[l--]=0,u=1}for(s=d.length;0===d[--s];)d.pop()}return h&&(n.e>p.maxE?(n.d=null,n.e=NaN):n.e<p.minE&&(n.e=0,n.d=[0])),n}function R(n,e,i){if(!n.isFinite())return j(n);var t,r=n.e,s=D(n.d),o=s.length;return e?(i&&(t=i-o)>0?s=s.charAt(0)+\".\"+s.slice(1)+k(t):o>1&&(s=s.charAt(0)+\".\"+s.slice(1)),s=s+(n.e<0?\"e\":\"e+\")+n.e):r<0?(s=\"0.\"+k(-r-1)+s,i&&(t=i-o)>0&&(s+=k(t))):r>=o?(s+=k(r+1-o),i&&(t=i-r-1)>0&&(s=s+\".\"+k(t))):((t=r+1)<o&&(s=s.slice(0,t)+\".\"+s.slice(t)),i&&(t=i-o)>0&&(r+1===o&&(s+=\".\"),s+=k(t))),s}function L(n,e){var i=n[0];for(e*=y;i>=10;i/=10)e++;return e}function T(n,e,i){if(e>M)throw h=!0,i&&(n.precision=i),Error(p);return P(new n(c),e,1,!0)}function U(n,e,i){if(e>q)throw Error(p);return P(new n(f),e,i,!0)}function _(n){var e=n.length-1,i=e*y+1;if(e=n[e]){for(;e%10==0;e/=10)i--;for(e=n[0];e>=10;e/=10)i++}return i}function k(n){for(var e=\"\";n--;)e+=\"0\";return e}function C(n,e,i,t){var r,s=new n(1),o=Math.ceil(t/y+4);for(h=!1;;){if(i%2&&Q((s=s.times(e)).d,o)&&(r=!0),0===(i=m(i/2))){i=s.d.length-1,r&&0===s.d[i]&&++s.d[i];break}Q((e=e.times(e)).d,o)}return h=!0,s}function I(n){return 1&n.d[n.d.length-1]}function H(n,e,i){for(var t,r=new n(e[0]),s=0;++s<e.length;){if(!(t=new n(e[s])).s){r=t;break}r[i](t)&&(r=t)}return r}function B(n,e){var i,t,r,s,o,u,c,f=0,a=0,d=0,l=n.constructor,p=l.rounding,g=l.precision;if(!n.d||!n.d[0]||n.e>17)return new l(n.d?n.d[0]?n.s<0?0:1/0:1:n.s?n.s<0?0:n:NaN);for(null==e?(h=!1,c=g):c=e,u=new l(.03125);n.e>-2;)n=n.times(u),d+=5;for(c+=t=Math.log(w(2,d))/Math.LN10*2+5|0,i=s=o=new l(1),l.precision=c;;){if(s=P(s.times(n),c,1),i=i.times(++a),D((u=o.plus(Z(s,i,c,1))).d).slice(0,c)===D(o.d).slice(0,c)){for(r=d;r--;)o=P(o.times(o),c,1);if(null!=e)return l.precision=g,o;if(!(f<3&&A(o.d,c-t,p,f)))return P(o,l.precision=g,p,h=!0);l.precision=c+=10,i=s=u=new l(1),a=0,f++}o=u}}function V(n,e){var i,t,r,s,o,u,c,f,a,d,l,p=1,g=n,m=g.d,w=g.constructor,v=w.rounding,N=w.precision;if(g.s<0||!m||!m[0]||!g.e&&1==m[0]&&1==m.length)return new w(m&&!m[0]?-1/0:1!=g.s?NaN:m?0:g);if(null==e?(h=!1,a=N):a=e,w.precision=a+=10,t=(i=D(m)).charAt(0),!(Math.abs(s=g.e)<15e14))return f=T(w,a+2,N).times(s+\"\"),g=V(new w(t+\".\"+i.slice(1)),a-10).plus(f),w.precision=N,null==e?P(g,N,v,h=!0):g;for(;t<7&&1!=t||1==t&&i.charAt(1)>3;)t=(i=D((g=g.times(n)).d)).charAt(0),p++;for(s=g.e,t>1?(g=new w(\"0.\"+i),s++):g=new w(t+\".\"+i.slice(1)),d=g,c=o=g=Z(g.minus(1),g.plus(1),a,1),l=P(g.times(g),a,1),r=3;;){if(o=P(o.times(l),a,1),D((f=c.plus(Z(o,new w(r),a,1))).d).slice(0,a)===D(c.d).slice(0,a)){if(c=c.times(2),0!==s&&(c=c.plus(T(w,a+2,N).times(s+\"\"))),c=Z(c,new w(p),a,1),null!=e)return w.precision=N,c;if(!A(c.d,a-10,v,u))return P(c,w.precision=N,v,h=!0);w.precision=a+=10,f=o=g=Z(d.minus(1),d.plus(1),a,1),l=P(g.times(g),a,1),r=u=1}c=f,r+=2}}function j(n){return String(n.s*n.s/0)}function $(n,e){var i,t,r;for((i=e.indexOf(\".\"))>-1&&(e=e.replace(\".\",\"\")),(t=e.search(/e/i))>0?(i<0&&(i=t),i+=+e.slice(t+1),e=e.substring(0,t)):i<0&&(i=e.length),t=0;48===e.charCodeAt(t);t++);for(r=e.length;48===e.charCodeAt(r-1);--r);if(e=e.slice(t,r)){if(r-=t,n.e=i=i-t-1,n.d=[],t=(i+1)%y,i<0&&(t+=y),t<r){for(t&&n.d.push(+e.slice(0,t)),r-=y;t<r;)n.d.push(+e.slice(t,t+=y));e=e.slice(t),t=y-e.length}else t-=r;for(;t--;)e+=\"0\";n.d.push(+e),h&&(n.e>n.constructor.maxE?(n.d=null,n.e=NaN):n.e<n.constructor.minE&&(n.e=0,n.d=[0]))}else n.e=0,n.d=[0];return n}function W(n,i){var t,r,s,o,u,c,f,a,d;if(\"Infinity\"===i||\"NaN\"===i)return+i||(n.s=NaN),n.e=NaN,n.d=null,n;if(N.test(i))t=16,i=i.toLowerCase();else if(v.test(i))t=2;else{if(!b.test(i))throw Error(l+i);t=8}for((o=i.search(/p/i))>0?(f=+i.slice(o+1),i=i.substring(2,o)):i=i.slice(2),u=(o=i.indexOf(\".\"))>=0,r=n.constructor,u&&(o=(c=(i=i.replace(\".\",\"\")).length)-o,s=C(r,new r(t),o,2*o)),o=d=(a=S(i,t,x)).length-1;0===a[o];--o)a.pop();return o<0?new r(0*n.s):(n.e=L(a,d),n.d=a,h=!1,u&&(n=Z(n,s,4*c)),f&&(n=n.times(Math.abs(f)<54?w(2,f):e.pow(2,f))),h=!0,n)}function J(n,e,i,t,r){var s,o,u,c,f=n.precision,a=Math.ceil(f/y);for(h=!1,c=i.times(i),u=new n(t);;){if(o=Z(u.times(c),new n(e++*e++),f,1),u=r?t.plus(o):t.minus(o),t=Z(o.times(c),new n(e++*e++),f,1),void 0!==(o=u.plus(t)).d[a]){for(s=a;o.d[s]===u.d[s]&&s--;);if(-1==s)break}s=u,u=t,t=o,o=s,0}return h=!0,o.d.length=a+1,o}function z(n,e){for(var i=n;--e;)i*=n;return i}function G(n,e){var i,t=e.s<0,s=U(n,n.precision,1),o=s.times(.5);if((e=e.abs()).lte(o))return r=t?4:1,e;if((i=e.divToInt(s)).isZero())r=t?3:2;else{if((e=e.minus(i.times(s))).lte(o))return r=I(i)?t?2:3:t?4:1,e;r=I(i)?t?1:4:t?3:2}return e.minus(s).abs()}function K(n,e,t,r){var s,c,f,a,h,d,l,p,g,m=n.constructor,w=void 0!==t;if(w?(F(t,1,o),void 0===r?r=m.rounding:F(r,0,8)):(t=m.precision,r=m.rounding),n.isFinite()){for(w?(s=2,16==e?t=4*t-3:8==e&&(t=3*t-2)):s=e,(f=(l=R(n)).indexOf(\".\"))>=0&&(l=l.replace(\".\",\"\"),(g=new m(1)).e=l.length-f,g.d=S(R(g),10,s),g.e=g.d.length),c=h=(p=S(l,10,s)).length;0==p[--h];)p.pop();if(p[0]){if(f<0?c--:((n=new m(n)).d=p,n.e=c,p=(n=Z(n,g,t,r,0,s)).d,c=n.e,d=i),f=p[t],a=s/2,d=d||void 0!==p[t+1],d=r<4?(void 0!==f||d)&&(0===r||r===(n.s<0?3:2)):f>a||f===a&&(4===r||d||6===r&&1&p[t-1]||r===(n.s<0?8:7)),p.length=t,d)for(;++p[--t]>s-1;)p[t]=0,t||(++c,p.unshift(1));for(h=p.length;!p[h-1];--h);for(f=0,l=\"\";f<h;f++)l+=u.charAt(p[f]);if(w){if(h>1)if(16==e||8==e){for(f=16==e?4:3,--h;h%f;h++)l+=\"0\";for(h=(p=S(l,s,e)).length;!p[h-1];--h);for(f=1,l=\"1.\";f<h;f++)l+=u.charAt(p[f])}else l=l.charAt(0)+\".\"+l.slice(1);l=l+(c<0?\"p\":\"p+\")+c}else if(c<0){for(;++c;)l=\"0\"+l;l=\"0.\"+l}else if(++c>h)for(c-=h;c--;)l+=\"0\";else c<h&&(l=l.slice(0,c)+\".\"+l.slice(c))}else l=w?\"0p+0\":\"0\";l=(16==e?\"0x\":2==e?\"0b\":8==e?\"0o\":\"\")+l}else l=j(n);return n.s<0?\"-\"+l:l}function Q(n,e){if(n.length>e)return n.length=e,!0}function X(n){return new this(n).abs()}function Y(n){return new this(n).acos()}function nn(n){return new this(n).acosh()}function en(n,e){return new this(n).plus(e)}function tn(n){return new this(n).asin()}function rn(n){return new this(n).asinh()}function sn(n){return new this(n).atan()}function on(n){return new this(n).atanh()}function un(n,e){n=new this(n),e=new this(e);var i,t=this.precision,r=this.rounding,s=t+4;return n.s&&e.s?n.d||e.d?!e.d||n.isZero()?(i=e.s<0?U(this,t,r):new this(0)).s=n.s:!n.d||e.isZero()?(i=U(this,s,1).times(.5)).s=n.s:e.s<0?(this.precision=s,this.rounding=1,i=this.atan(Z(n,e,s,1)),e=U(this,s,1),this.precision=t,this.rounding=r,i=n.s<0?i.minus(e):i.plus(e)):i=this.atan(Z(n,e,s,1)):(i=U(this,s,1).times(e.s>0?.25:.75)).s=n.s:i=new this(NaN),i}function cn(n){return new this(n).cbrt()}function fn(n){return P(n=new this(n),n.e+1,2)}function an(n){if(!n||\"object\"!=typeof n)throw Error(d+\"Object expected\");var e,i,t,r=!0===n.defaults,u=[\"precision\",1,o,\"rounding\",0,8,\"toExpNeg\",-s,0,\"toExpPos\",0,s,\"maxE\",0,s,\"minE\",-s,0,\"modulo\",0,9];for(e=0;e<u.length;e+=3)if(i=u[e],r&&(this[i]=a[i]),void 0!==(t=n[i])){if(!(m(t)===t&&t>=u[e+1]&&t<=u[e+2]))throw Error(l+i+\": \"+t);this[i]=t}if(i=\"crypto\",r&&(this[i]=a[i]),void 0!==(t=n[i])){if(!0!==t&&!1!==t&&0!==t&&1!==t)throw Error(l+i+\": \"+t);if(t){if(\"undefined\"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw Error(g);this[i]=!0}else this[i]=!1}return this}function hn(n){return new this(n).cos()}function dn(n){return new this(n).cosh()}function ln(n,e){return new this(n).div(e)}function pn(n){return new this(n).exp()}function gn(n){return P(n=new this(n),n.e+1,3)}function mn(){var n,e,i=new this(0);for(h=!1,n=0;n<arguments.length;)if((e=new this(arguments[n++])).d)i.d&&(i=i.plus(e.times(e)));else{if(e.s)return h=!0,new this(1/0);i=e}return h=!0,i.sqrt()}function wn(n){return n instanceof e||n&&\"[object Decimal]\"===n.name||!1}function vn(n){return new this(n).ln()}function Nn(n,e){return new this(n).log(e)}function bn(n){return new this(n).log(2)}function En(n){return new this(n).log(10)}function xn(){return H(this,arguments,\"lt\")}function yn(){return H(this,arguments,\"gt\")}function Mn(n,e){return new this(n).mod(e)}function qn(n,e){return new this(n).mul(e)}function On(n,e){return new this(n).pow(e)}function Dn(n){var e,i,t,r,s=0,u=new this(1),c=[];if(void 0===n?n=this.precision:F(n,1,o),t=Math.ceil(n/y),this.crypto)if(crypto.getRandomValues)for(e=crypto.getRandomValues(new Uint32Array(t));s<t;)(r=e[s])>=429e7?e[s]=crypto.getRandomValues(new Uint32Array(1))[0]:c[s++]=r%1e7;else{if(!crypto.randomBytes)throw Error(g);for(e=crypto.randomBytes(t*=4);s<t;)(r=e[s]+(e[s+1]<<8)+(e[s+2]<<16)+((127&e[s+3])<<24))>=214e7?crypto.randomBytes(4).copy(e,s):(c.push(r%1e7),s+=4);s=t/4}else for(;s<t;)c[s++]=1e7*Math.random()|0;for(t=c[--s],n%=y,t&&n&&(r=w(10,y-n),c[s]=(t/r|0)*r);0===c[s];s--)c.pop();if(s<0)i=0,c=[0];else{for(i=-1;0===c[0];i-=y)c.shift();for(t=1,r=c[0];r>=10;r/=10)t++;t<y&&(i-=y-t)}return u.e=i,u.d=c,u}function Fn(n){return P(n=new this(n),n.e+1,this.rounding)}function An(n){return(n=new this(n)).d?n.d[0]?n.s:0*n.s:n.s||NaN}function Sn(n){return new this(n).sin()}function Zn(n){return new this(n).sinh()}function Pn(n){return new this(n).sqrt()}function Rn(n,e){return new this(n).sub(e)}function Ln(n){return new this(n).tan()}function Tn(n){return new this(n).tanh()}function Un(n){return P(n=new this(n),n.e+1,1)}return(e=function n(e){var i,t,r;function s(n){var e,i,t,r=this;if(!(r instanceof s))return new s(n);if(r.constructor=s,n instanceof s)return r.s=n.s,void(h?!n.d||n.e>s.maxE?(r.e=NaN,r.d=null):n.e<s.minE?(r.e=0,r.d=[0]):(r.e=n.e,r.d=n.d.slice()):(r.e=n.e,r.d=n.d?n.d.slice():n.d));if(\"number\"==(t=typeof n)){if(0===n)return r.s=1/n<0?-1:1,r.e=0,void(r.d=[0]);if(n<0?(n=-n,r.s=-1):r.s=1,n===~~n&&n<1e7){for(e=0,i=n;i>=10;i/=10)e++;return void(h?e>s.maxE?(r.e=NaN,r.d=null):e<s.minE?(r.e=0,r.d=[0]):(r.e=e,r.d=[n]):(r.e=e,r.d=[n]))}return 0*n!=0?(n||(r.s=NaN),r.e=NaN,void(r.d=null)):$(r,n.toString())}if(\"string\"!==t)throw Error(l+n);return 45===(i=n.charCodeAt(0))?(n=n.slice(1),r.s=-1):(43===i&&(n=n.slice(1)),r.s=1),E.test(n)?$(r,n):W(r,n)}if(s.prototype=O,s.ROUND_UP=0,s.ROUND_DOWN=1,s.ROUND_CEIL=2,s.ROUND_FLOOR=3,s.ROUND_HALF_UP=4,s.ROUND_HALF_DOWN=5,s.ROUND_HALF_EVEN=6,s.ROUND_HALF_CEIL=7,s.ROUND_HALF_FLOOR=8,s.EUCLID=9,s.config=s.set=an,s.clone=n,s.isDecimal=wn,s.abs=X,s.acos=Y,s.acosh=nn,s.add=en,s.asin=tn,s.asinh=rn,s.atan=sn,s.atanh=on,s.atan2=un,s.cbrt=cn,s.ceil=fn,s.cos=hn,s.cosh=dn,s.div=ln,s.exp=pn,s.floor=gn,s.hypot=mn,s.ln=vn,s.log=Nn,s.log10=En,s.log2=bn,s.max=xn,s.min=yn,s.mod=Mn,s.mul=qn,s.pow=On,s.random=Dn,s.round=Fn,s.sign=An,s.sin=Sn,s.sinh=Zn,s.sqrt=Pn,s.sub=Rn,s.tan=Ln,s.tanh=Tn,s.trunc=Un,void 0===e&&(e={}),e&&!0!==e.defaults)for(r=[\"precision\",\"rounding\",\"toExpNeg\",\"toExpPos\",\"maxE\",\"minE\",\"modulo\",\"crypto\"],i=0;i<r.length;)e.hasOwnProperty(t=r[i++])||(e[t]=this[t]);return s.config(e),s}(a)).default=e.Decimal=e,c=new e(c),f=new e(f), true?!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return e}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0,e}(this)\r\n//    bigDec: require('decimal.js')\r\n});\r\n\r\nif(true) {\r\n    module.exports = nerdamer;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92YW5pbGxhLWludGVncmF0aW9uLTJkLy4vbm9kZV9tb2R1bGVzL25lcmRhbWVyL25lcmRhbWVyLmNvcmUuanM/MTVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBBdXRob3IgOiBNYXJ0aW4gRG9ua1xyXG4gKiBXZWJzaXRlIDogaHR0cDovL3d3dy5uZXJkYW1lci5jb21cclxuICogRW1haWwgOiBtYXJ0aW4uci5kb25rQGdtYWlsLmNvbVxyXG4gKiBTb3VyY2UgOiBodHRwczovL2dpdGh1Yi5jb20vamlnZ3pzb24vbmVyZGFtZXJcclxuICovXHJcblxyXG4vKiBnbG9iYWwgdHJpZywgdHJpZ2gsIEluZmluaXR5LCBkZWZpbmUsIGFyZ3VtZW50czJBcnJheSwgTmFOICovXHJcbi8vZXh0ZXJuYWxzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8qIEJpZ0ludGVyZ2VyLmpzIHYxLjYuNDAgaHR0cHM6Ly9naXRodWIuY29tL3BldGVyb2xzb24vQmlnSW50ZWdlci5qcy9ibG9iL21hc3Rlci9MSUNFTlNFICovXHJcbi8vdmFyIG5lcmRhbWVyQmlnSW50ID0gdHlwZW9mIG5lcmRhbWVyQmlnSW50ICE9PSAndW5kZWZpbmVkJyA/IG5lcmRhbWVyQmlnSW50IDogcmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpO1xyXG4vKiBiaWcuanMgdjUuMi4yIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9MSUNFTkNFICovXHJcbi8vdmFyIG5lcmRhbWVyQmlnRGVjaW1hbCA9IHR5cGVvZiBuZXJkYW1lckJpZ0RlY2ltYWwgIT09ICd1bmRlZmluZWQnID8gbmVyZGFtZXJCaWdEZWNpbWFsIDogcmVxdWlyZSgnYmlnLmpzJyk7XHJcblxyXG52YXIgbmVyZGFtZXIgPSAoZnVuY3Rpb24gKGltcG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuLy92ZXJzaW9uID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIHZhciB2ZXJzaW9uID0gJzEuMS4xMic7XHJcblxyXG4vL2luaXRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgdmFyIF8gPSBuZXcgUGFyc2VyKCk7IC8vbmVyZGFtZXIncyBwYXJzZXJcclxuXHJcbiAgICAvL2ltcG9ydCBiaWdJbnRcclxuICAgIHZhciBiaWdJbnQgPSBpbXBvcnRzLmJpZ0ludDtcclxuICAgIHZhciBiaWdEZWMgPSBpbXBvcnRzLmJpZ0RlYztcclxuXHJcbiAgICAvL3NldCB0aGUgcHJlY2lzaW9uIHRvIGpzIHByZWNpc2lvblxyXG4gICAgYmlnRGVjLnNldCh7XHJcbiAgICAgICAgcHJlY2lzaW9uOiAyNTBcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBHcm91cHMgPSB7fTtcclxuXHJcbiAgICAvL2NvbnRhaW5lciBvZiBwcmVnZW5lcmF0ZWQgcHJpbWVzXHJcbiAgICB2YXIgUFJJTUVTID0gWzIsIDMsIDUsIDcsIDExLCAxMywgMTcsIDE5LCAyMywgMjksIDMxLCAzNywgNDEsIDQzLCA0NywgNTMsIDU5LCA2MSwgNjcsIDcxLCA3MywgNzksIDgzLCA4OSwgOTcsIDEwMSwgMTAzLCAxMDcsIDEwOSwgMTEzXHJcbiAgICAgICAgICAgICAgICAsIDEyNywgMTMxLCAxMzcsIDEzOSwgMTQ5LCAxNTEsIDE1NywgMTYzLCAxNjcsIDE3MywgMTc5LCAxODEsIDE5MSwgMTkzLCAxOTcsIDE5OSwgMjExLCAyMjMsIDIyNywgMjI5LCAyMzMsIDIzOSwgMjQxLCAyNTEsXHJcbiAgICAgICAgMjU3LCAyNjMsIDI2OSwgMjcxLCAyNzcsIDI4MSwgMjgzLCAyOTMsIDMwNywgMzExLCAzMTMsIDMxNywgMzMxLCAzMzcsIDM0NywgMzQ5LCAzNTMsIDM1OSwgMzY3LCAzNzMsIDM3OSwgMzgzLCAzODksIDM5NyxcclxuICAgICAgICA0MDEsIDQwOSwgNDE5LCA0MjEsIDQzMSwgNDMzLCA0MzksIDQ0MywgNDQ5LCA0NTcsIDQ2MSwgNDYzLCA0NjcsIDQ3OSwgNDg3LCA0OTEsIDQ5OSwgNTAzLCA1MDksIDUyMSwgNTIzLCA1NDEsIDU0NywgNTU3LFxyXG4gICAgICAgIDU2MywgNTY5LCA1NzEsIDU3NywgNTg3LCA1OTMsIDU5OSwgNjAxLCA2MDcsIDYxMywgNjE3LCA2MTksIDYzMSwgNjQxLCA2NDMsIDY0NywgNjUzLCA2NTksIDY2MSwgNjczLCA2NzcsIDY4MywgNjkxLCA3MDEsXHJcbiAgICAgICAgNzA5LCA3MTksIDcyNywgNzMzLCA3MzksIDc0MywgNzUxLCA3NTcsIDc2MSwgNzY5LCA3NzMsIDc4NywgNzk3LCA4MDksIDgxMSwgODIxLCA4MjMsIDgyNywgODI5LCA4MzksIDg1MywgODU3LCA4NTksIDg2MyxcclxuICAgICAgICA4NzcsIDg4MSwgODgzLCA4ODcsIDkwNywgOTExLCA5MTksIDkyOSwgOTM3LCA5NDEsIDk0NywgOTUzLCA5NjcsIDk3MSwgOTc3LCA5ODMsIDk5MSwgOTk3LCAxMDA5LCAxMDEzLCAxMDE5LCAxMDIxLCAxMDMxLFxyXG4gICAgICAgIDEwMzMsIDEwMzksIDEwNDksIDEwNTEsIDEwNjEsIDEwNjMsIDEwNjksIDEwODcsIDEwOTEsIDEwOTMsIDEwOTcsIDExMDMsIDExMDksIDExMTcsIDExMjMsIDExMjksIDExNTEsIDExNTMsIDExNjMsIDExNzEsXHJcbiAgICAgICAgMTE4MSwgMTE4NywgMTE5MywgMTIwMSwgMTIxMywgMTIxNywgMTIyMywgMTIyOSwgMTIzMSwgMTIzNywgMTI0OSwgMTI1OSwgMTI3NywgMTI3OSwgMTI4MywgMTI4OSwgMTI5MSwgMTI5NywgMTMwMSwgMTMwMyxcclxuICAgICAgICAxMzA3LCAxMzE5LCAxMzIxLCAxMzI3LCAxMzYxLCAxMzY3LCAxMzczLCAxMzgxLCAxMzk5LCAxNDA5LCAxNDIzLCAxNDI3LCAxNDI5LCAxNDMzLCAxNDM5LCAxNDQ3LCAxNDUxLCAxNDUzLCAxNDU5LCAxNDcxLFxyXG4gICAgICAgIDE0ODEsIDE0ODMsIDE0ODcsIDE0ODksIDE0OTMsIDE0OTksIDE1MTEsIDE1MjMsIDE1MzEsIDE1NDMsIDE1NDksIDE1NTMsIDE1NTksIDE1NjcsIDE1NzEsIDE1NzksIDE1ODMsIDE1OTcsIDE2MDEsIDE2MDcsXHJcbiAgICAgICAgMTYwOSwgMTYxMywgMTYxOSwgMTYyMSwgMTYyNywgMTYzNywgMTY1NywgMTY2MywgMTY2NywgMTY2OSwgMTY5MywgMTY5NywgMTY5OSwgMTcwOSwgMTcyMSwgMTcyMywgMTczMywgMTc0MSwgMTc0NywgMTc1MyxcclxuICAgICAgICAxNzU5LCAxNzc3LCAxNzgzLCAxNzg3LCAxNzg5LCAxODAxLCAxODExLCAxODIzLCAxODMxLCAxODQ3LCAxODYxLCAxODY3LCAxODcxLCAxODczLCAxODc3LCAxODc5LCAxODg5LCAxOTAxLCAxOTA3LCAxOTEzLCAxOTMxLFxyXG4gICAgICAgIDE5MzMsIDE5NDksIDE5NTEsIDE5NzMsIDE5NzksIDE5ODcsIDE5OTMsIDE5OTcsIDE5OTksIDIwMDMsIDIwMTEsIDIwMTcsIDIwMjcsIDIwMjksIDIwMzksIDIwNTMsIDIwNjMsIDIwNjksIDIwODEsIDIwODNdO1xyXG5cclxuLy9TZXR0aW5ncyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIHZhciBDVVNUT01fT1BFUkFUT1JTID0ge307XHJcblxyXG4gICAgdmFyIFNldHRpbmdzID0ge1xyXG4gICAgICAgIC8vRW5hYmxlcy9EaXNhYmxlcyBjYWxsIHBlZWtlcnMuIEZhbHNlIG1lYW5zIGNhbGxQZWVrZXJzIGFyZSBkaXNhYmxlZCBhbmQgdHJ1ZSBtZWFucyBjYWxsUGVla2VycyBhcmUgZW5hYmxlZC5cclxuICAgICAgICBjYWxsUGVla2VyczogZmFsc2UsXHJcblxyXG4gICAgICAgIC8vdGhlIG1heCBudW1iZXIgdXAgdG8gd2hpY2ggdG8gY2FjaGUgcHJpbWVzLiBNYWtpbmcgdGhpcyB0b28gaGlnaCBjYXVzZXMgcGVyZm9ybWFuY2UgaXNzdWVzXHJcbiAgICAgICAgaW5pdF9wcmltZXM6IDEwMDAsXHJcblxyXG4gICAgICAgIGV4Y2x1ZGU6IFtdLFxyXG4gICAgICAgIC8vSWYgeW91IGRvbid0IGNhcmUgYWJvdXQgZGl2aXNpb24gYnkgemVybyBmb3IgZXhhbXBsZSB0aGVuIHRoaXMgY2FuIGJlIHNldCB0byB0cnVlLlxyXG4gICAgICAgIC8vSGFzIHNvbWUgbmFzdHkgc2lkZSBlZmZlY3RzIHNvIGNob29zZSBjYXJlZnVsbHkuXHJcbiAgICAgICAgc3VwcHJlc3NfZXJyb3JzOiBmYWxzZSxcclxuICAgICAgICAvL3RoZSBnbG9iYWwgdXNlZCB0byBpbnZva2UgdGhlIGxpYmFyeSB0byBwYXJzZSB0byBhIG51bWJlci4gTm9ybWFsbHkgY29zKDkpIGZvciBleGFtcGxlIHJldHVybnNcclxuICAgICAgICAvL2Nvcyg5KSBmb3IgY29udmVuaWVuY2UgYnV0IHBhcnNlIHRvIG51bWJlciB3aWxsIGFsd2F5cyB0cnkgdG8gcmV0dXJuIGEgbnVtYmVyIGlmIHNldCB0byB0cnVlLlxyXG4gICAgICAgIFBBUlNFMk5VTUJFUjogZmFsc2UsXHJcbiAgICAgICAgLy90aGlzIGZsYWcgZm9yY2VzIHRoZSBhIGNsb25lIHRvIGJlIHJldHVybmVkIHdoZW4gYWRkLCBzdWJ0cmFjdCwgZXRjLi4uIGlzIGNhbGxlZFxyXG4gICAgICAgIFNBRkU6IGZhbHNlLFxyXG4gICAgICAgIC8vdGhlIHN5bWJvbCB0byB1c2UgZm9yIGltYWdpbmFyeSBzeW1ib2xzXHJcbiAgICAgICAgSU1BR0lOQVJZOiAnaScsXHJcbiAgICAgICAgLy90aGUgbW9kdWxlcyB1c2VkIHRvIGxpbmsgbnVtZXJpYyBmdW5jdGlvbiBob2xkZXJzXHJcbiAgICAgICAgRlVOQ1RJT05fTU9EVUxFUzogW01hdGhdLFxyXG4gICAgICAgIC8vQWxsb3cgY2VydGFpbiBjaGFyYWN0ZXJzXHJcbiAgICAgICAgQUxMT1dfQ0hBUlM6IFsnz4AnXSxcclxuICAgICAgICAvL0FsbG93IG5lcmRhbWVyIHRvIGNvbnZlcnQgbXVsdGktY2hhcmFjdGVyIHZhcmlhYmxlc1xyXG4gICAgICAgIFVTRV9NVUxUSUNIQVJBQ1RFUl9WQVJTOiB0cnVlLFxyXG4gICAgICAgIC8vQWxsb3cgY2hhbmdpbmcgb2YgcG93ZXIgb3BlcmF0b3JcclxuICAgICAgICBQT1dFUl9PUEVSQVRPUjogJ14nLFxyXG4gICAgICAgIC8vVGhlIHZhcmlhYmxlIHZhbGlkYXRpb24gcmVnZXhcclxuICAgICAgICAvL1ZBTElEQVRJT05fUkVHRVg6IC9eW2Etel9dW2EtelxcZFxcX10qJC9pXHJcbiAgICAgICAgVkFMSURBVElPTl9SRUdFWDogL15bYS16X86xQc6yQs6zzpPOtM6Uz7VFzrZazrdIzrjOmM65Sc66S867zpvOvE3OvU7Ovs6eb0/PgM6gz4FQz4POo8+EVM+Fz5LPlc6mz4dYz4jOqM+JzqniiJ5dWzAtOWEtel/OsUHOskLOs86TzrTOlM+1Rc62Ws63SM64zpjOuUnOukvOu86bzrxNzr1Ozr7Onm9Pz4DOoM+BUM+DzqPPhFTPhc+Sz5XOps+HWM+IzqjPic6pXSokL2ksXHJcbiAgICAgICAgLy8gVGhlIHJlZ2V4IHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGNoYXJhY3RlcnMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIGltcGxpZWQgbXVsdGlwbGljYXRpb25cclxuICAgICAgICBJTVBMSUVEX01VTFRJUExJQ0FUSU9OX1JFR0VYOiAvKFtcXCtcXC1cXC9cXCpdKlswLTldKykoW2Etel/OsUHOskLOs86TzrTOlM+1Rc62Ws63SM64zpjOuUnOukvOu86bzrxNzr1Ozr7Onm9Pz4DOoM+BUM+DzqPPhFTPhc+Sz5XOps+HWM+IzqjPic6pXStbXFwrXFwtXFwvXFwqXSopL2dpLFxyXG4gICAgICAgIC8vQWxpYXNlc1xyXG4gICAgICAgIEFMSUFTRVM6IHtcclxuICAgICAgICAgICAgJ8+AJzogJ3BpJyxcclxuICAgICAgICAgICAgJ+KInic6ICdJbmZpbml0eSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIFBPU0lUSVZFX01VTFRJUExJRVJTOiBmYWxzZSxcclxuICAgICAgICAvL0NhY2hlZCBpdGVtc1xyXG4gICAgICAgIENBQ0hFOiB7fSxcclxuICAgICAgICAvL1ByaW50IG91dCB3YXJuaW5ncyBvciBub3RcclxuICAgICAgICBTSUxFTkNFX1dBUk5JTkdTOiBmYWxzZSxcclxuICAgICAgICAvL1ByZWNpc2lvblxyXG4gICAgICAgIFBSRUNJU0lPTjogMjEsXHJcbiAgICAgICAgLy9mdW5jdGlvbiBtYXBwaW5nc1xyXG4gICAgICAgIFZFQ1RPUjogJ3ZlY3RvcicsXHJcbiAgICAgICAgUEFSRU5USEVTSVM6ICdwYXJlbnMnLFxyXG4gICAgICAgIFNRUlQ6ICdzcXJ0JyxcclxuICAgICAgICBBQlM6ICdhYnMnLFxyXG4gICAgICAgIEZBQ1RPUklBTDogJ2ZhY3RvcmlhbCcsXHJcbiAgICAgICAgRE9VQkxFRkFDVE9SSUFMOiAnZGZhY3RvcmlhbCcsXHJcbiAgICAgICAgLy9yZWZlcmVuY2UgcGkgYW5kIGVcclxuICAgICAgICBMT05HX1BJOiAnMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNCcgK1xyXG4gICAgICAgICAgICAgICAgJzgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NicsXHJcbiAgICAgICAgTE9OR19FOiAnMi43MTgyODE4Mjg0NTkwNDUyMzUzNjAyODc0NzEzNTI2NjI0OTc3NTcyNDcwOTM2OTk5NTk1NzQ5NjY5Njc2Mjc3MjQwNzY2MzAzNTM1NDc1OTQ1NzEzODIxNzg1MjUxNjY0Mjc0Mjc0NjYnICtcclxuICAgICAgICAgICAgICAgICczOTE5MzIwMDMwNTk5MjE4MTc0MTM1OTY2MjkwNDM1NzI5MDAzMzQyOTUyNjA1OTU2MzA3MzgxMzIzMjg2Mjc5NDM0OTA3NjMyMzM4Mjk4ODA3NTMxOTUyNTEwMTkwMScsXHJcbiAgICAgICAgUEk6IE1hdGguUEksXHJcbiAgICAgICAgRTogTWF0aC5FLFxyXG4gICAgICAgIExPRzogJ2xvZycsXHJcbiAgICAgICAgTE9HMTA6ICdsb2cxMCcsXHJcbiAgICAgICAgTE9HMTBfTEFURVg6ICdsb2dfezEwfScsXHJcbiAgICAgICAgTUFYX0VYUDogMjAwMDAwLFxyXG4gICAgICAgIC8vVGhlIG51bWJlciBvZiBzY2llbnRpZmljIHBsYWNlIHRvIHJvdW5kIHRvXHJcbiAgICAgICAgU0NJRU5USUZJQ19NQVhfREVDSU1BTF9QTEFDRVM6IDE0LFxyXG4gICAgICAgIC8vVHJ1ZSBpZiBpbnRzIHNob3VsZCBub3QgYmUgY29udmVydGVkIHRvXHJcbiAgICAgICAgU0NJRU5USUZJQ19JR05PUkVfWkVST19FWFBPTkVOVFM6IHRydWVcclxuICAgIH07XHJcblxyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBTZXR0aW5ncy5DQUNIRS5yb290cyA9IHt9O1xyXG4gICAgICAgIHZhciB4ID0gNDAsXHJcbiAgICAgICAgICAgICAgICB5ID0gNDA7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMjsgaSA8PSB4OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yKHZhciBqID0gMjsgaiA8PSB5OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBudGhwb3cgPSBiaWdJbnQoaSkucG93KGopO1xyXG4gICAgICAgICAgICAgICAgU2V0dGluZ3MuQ0FDSEUucm9vdHNbbnRocG93ICsgJy0nICsgal0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvL0FkZCB0aGUgZ3JvdXBzLiBUaGVzZSBoYXZlIGJlZW4gcmVvcmdhbml6ZWQgYXMgb2YgdjAuNS4xIHRvIG1ha2UgQ1AgdGhlIGhpZ2hlc3QgZ3JvdXBcclxuICAgIC8vVGhlIGdyb3VwcyB0aGF0IGhlbHAgd2l0aCBvcmdhbml6aW5nIGR1cmluZyBwYXJzaW5nLiBOb3RlIHRoYXQgZm9yIEZOIGlzIHN0aWxsIGEgZnVuY3Rpb24gZXZlblxyXG4gICAgLy93aGVuIGl0J3MgcmFpc2VkIHRvIGEgc3ltYm9sLCB3aGljaCB0eXBpY2FsbHkgcmVzdWx0cyBpbiBhbiBFWFxyXG4gICAgdmFyIE4gPSBHcm91cHMuTiA9IDEsIC8vIEEgbnVtYmVyXHJcbiAgICAgICAgICAgIFAgPSBHcm91cHMuUCA9IDIsIC8vIEEgbnVtYmVyIHdpdGggYSByYXRpb25hbCBwb3dlciBlLmcuIDJeKDMvNSkuXHJcbiAgICAgICAgICAgIFMgPSBHcm91cHMuUyA9IDMsIC8vIEEgc2luZ2xlIHZhcmlhYmxlIGUuZy4geC5cclxuICAgICAgICAgICAgRVggPSBHcm91cHMuRVggPSA0LCAvLyBBbiBleHBvbmVudGlhbFxyXG4gICAgICAgICAgICBGTiA9IEdyb3Vwcy5GTiA9IDUsIC8vIEEgZnVuY3Rpb25cclxuICAgICAgICAgICAgUEwgPSBHcm91cHMuUEwgPSA2LCAvLyBBIHN5bWJvbC9leHByZXNzaW9uIGhhdmluZyBzYW1lIG5hbWUgd2l0aCBkaWZmZXJlbnQgcG93ZXJzIGUuZy4gMS94ICsgeF4yXHJcbiAgICAgICAgICAgIENCID0gR3JvdXBzLkNCID0gNywgLy8gQSBzeW1ib2wvZXhwcmVzc2lvbiBjb21wb3NlZCBvZiBvbmUgb3IgbW9yZSB2YXJpYWJsZXMgdGhyb3VnaCBtdWx0aXBsaWNhdGlvbiBlLmcuIHgqeVxyXG4gICAgICAgICAgICBDUCA9IEdyb3Vwcy5DUCA9IDg7IC8vIEEgc3ltYm9sL2V4cHJlc3Npb24gY29tcG9zZWQgb2Ygb25lIHZhcmlhYmxlIGFuZCBhbnkgb3RoZXIgc3ltYm9sIG9yIG51bWJlciB4KzEgb3IgeCt5XHJcblxyXG4gICAgdmFyIENPTlNUX0hBU0ggPSBTZXR0aW5ncy5DT05TVF9IQVNIID0gJyMnO1xyXG5cclxuICAgIHZhciBQQVJFTlRIRVNJUyA9IFNldHRpbmdzLlBBUkVOVEhFU0lTO1xyXG5cclxuICAgIHZhciBTUVJUID0gU2V0dGluZ3MuU1FSVDtcclxuXHJcbiAgICB2YXIgQUJTID0gU2V0dGluZ3MuQUJTO1xyXG5cclxuICAgIHZhciBGQUNUT1JJQUwgPSBTZXR0aW5ncy5GQUNUT1JJQUw7XHJcblxyXG4gICAgdmFyIERPVUJMRUZBQ1RPUklBTCA9IFNldHRpbmdzLkRPVUJMRUZBQ1RPUklBTDtcclxuXHJcbiAgICAvL3RoZSBzdG9yYWdlIGNvbnRhaW5lciBcIm1lbW9yeVwiIGZvciBwYXJzZWQgZXhwcmVzc2lvbnNcclxuICAgIHZhciBFWFBSRVNTSU9OUyA9IFtdO1xyXG5cclxuICAgIC8vdmFyaWFibGVzXHJcbiAgICB2YXIgVkFSUyA9IHt9O1xyXG5cclxuICAgIC8vdGhlIGNvbnRhaW5lciB1c2VkIHRvIHN0b3JlIGFsbCB0aGUgcmVzZXJ2ZWQgZnVuY3Rpb25zXHJcbiAgICB2YXIgUkVTRVJWRUQgPSBbXTtcclxuXHJcbiAgICB2YXIgV0FSTklOR1MgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIHdoZW4gZXJyb3JzIGFyZSBzdXBwcmVzc2libGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtc2dcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBFcnJvck9ialxyXG4gICAgICovXHJcbiAgICB2YXIgZXJyID0gZnVuY3Rpb24gKG1zZywgRXJyb3JPYmopIHtcclxuICAgICAgICBpZighU2V0dGluZ3Muc3VwcHJlc3NfZXJyb3JzKSB7XHJcbiAgICAgICAgICAgIGlmKEVycm9yT2JqKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yT2JqKG1zZyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4vL1V0aWxzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgdmFyIGN1c3RvbUVycm9yID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgRSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UgOiAnJztcclxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKHRoaXMubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSB0aGlzLm5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcclxuICAgICAgICB9OyAvL2NyZWF0ZSBhbiBlbXB0eSBlcnJvclxyXG4gICAgICAgIEUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIHJldHVybiBFO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdmFsdWUgaXMgb25lIG9mIG5lcmRhbWVyJ3MgcmVzZXJ2ZWQgbmFtZXNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxyXG4gICAgICogQHJldHVybiBib29sZWFuXHJcbiAgICAgKi9cclxuICAgIHZhciBpc1Jlc2VydmVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFJFU0VSVkVELmluZGV4T2YodmFsdWUpICE9PSAtMTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIHRoYXQgYWxsIHN5bWJvbHMgaW4gYXJyYXkgYXJlIHRoZSBzYW1lXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbFtdfSBhcnJcclxuICAgICAqIEByZXR1cm5zIHtib29sfVxyXG4gICAgICovXHJcbiAgICB2YXIgYWxsU2FtZSA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICB2YXIgbGFzdCA9IGFyclswXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAxLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgaWYoIWFycltpXS5lcXVhbHMobGFzdCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBwYXNzIHdhcm5pbmdzIG9yIGxvdyBzZXZlcml0eSBlcnJvcnMgYWJvdXQgdGhlIGxpYnJhcnlcclxuICAgICAqIEBwYXJhbSBtc2dcclxuICAgICAqL1xyXG4gICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgV0FSTklOR1MucHVzaChtc2cpO1xyXG4gICAgICAgIGlmKFNldHRpbmdzLlNIT1dfV0FSTklOR1MgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuZm9yY2VzIHJ1bGU6IFwibXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyIG9yIHVuZGVyc2NvcmUgYW5kXHJcbiAgICAgKiBjYW4gaGF2ZSBhbnkgbnVtYmVyIG9mIHVuZGVyc2NvcmVzLCBsZXR0ZXJzLCBhbmQgbnVtYmVycyB0aGVyZWFmdGVyLlwiXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sIGJlaW5nIGNoZWNrZWRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXAgLSBUaGUgdHlwZSBvZiBzeW1ib2xzIHRoYXQncyBiZWluZyB2YWxpZGF0ZWRcclxuICAgICAqIEB0aHJvd3Mge0V4Y2VwdGlvbn0gIC0gVGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiBmYWlsXHJcbiAgICAgKi9cclxuICAgIHZhciB2YWxpZGF0ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgdHlwKSB7XHJcbiAgICAgICAgdHlwID0gdHlwIHx8ICd2YXJpYWJsZSc7XHJcbiAgICAgICAgaWYoU2V0dGluZ3MuQUxMT1dfQ0hBUlMuaW5kZXhPZihuYW1lKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgcmVnZXggPSBTZXR0aW5ncy5WQUxJREFUSU9OX1JFR0VYO1xyXG4gICAgICAgIGlmKCEocmVnZXgudGVzdChuYW1lKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRWYXJpYWJsZU5hbWVFcnJvcihuYW1lICsgJyBpcyBub3QgYSB2YWxpZCAnICsgdHlwICsgJyBuYW1lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgbnVtYmVyIGZyb20gc2NpZW50aWZpYyBmb3JtYXQgdG8gZGVjaW1hbCBmb3JtYXRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW1cclxuICAgICAqL1xyXG4gICAgdmFyIHNjaWVudGlmaWNUb0RlY2ltYWwgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgdmFyIG5zaWduID0gTWF0aC5zaWduKG51bSk7XHJcbiAgICAgICAgLy9yZW1vdmUgdGhlIHNpZ25cclxuICAgICAgICBudW0gPSBNYXRoLmFicyhudW0pO1xyXG4gICAgICAgIC8vaWYgdGhlIG51bWJlciBpcyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIHJlbW92ZSBpdFxyXG4gICAgICAgIGlmKC9cXGQrXFwuP1xcZCplW1xcK1xcLV0qXFxkKy9pLnRlc3QobnVtKSkge1xyXG4gICAgICAgICAgICB2YXIgemVybyA9ICcwJyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IFN0cmluZyhudW0pLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ2UnKSwgLy9zcGxpdCBpbnRvIGNvZWZmIGFuZCBleHBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBwYXJ0cy5wb3AoKSwgLy9zdG9yZSB0aGUgZXhwb25lbnRpYWwgcGFydFxyXG4gICAgICAgICAgICAgICAgICAgIGwgPSBNYXRoLmFicyhlKSwgLy9nZXQgdGhlIG51bWJlciBvZiB6ZXJvc1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSBlIC8gbCxcclxuICAgICAgICAgICAgICAgICAgICBjb2VmZl9hcnJheSA9IHBhcnRzWzBdLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIGlmKHNpZ24gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBsID0gbCAtIGNvZWZmX2FycmF5WzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmKGwgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gY29lZmZfYXJyYXlbMF0uc2xpY2UoMCwgbCkgKyAnLicgKyBjb2VmZl9hcnJheVswXS5zbGljZShsKSArIChjb2VmZl9hcnJheS5sZW5ndGggPT09IDIgPyBjb2VmZl9hcnJheVsxXSA6ICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IHplcm8gKyAnLicgKyBuZXcgQXJyYXkobCArIDEpLmpvaW4oemVybykgKyBjb2VmZl9hcnJheS5qb2luKCcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWMgPSBjb2VmZl9hcnJheVsxXTtcclxuICAgICAgICAgICAgICAgIGlmKGRlYylcclxuICAgICAgICAgICAgICAgICAgICBsID0gbCAtIGRlYy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZihsIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IGNvZWZmX2FycmF5WzBdICsgZGVjLnNsaWNlKDAsIGwpICsgJy4nICsgZGVjLnNsaWNlKGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gY29lZmZfYXJyYXkuam9pbignJykgKyBuZXcgQXJyYXkobCArIDEpLmpvaW4oemVybyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuc2lnbiA8IDAgPyAnLScgKyBudW0gOiBudW07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgbnVtYmVyIGlzIGEgcHJpbWUgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiAtIHRoZSBudW1iZXIgdG8gYmUgY2hlY2tlZFxyXG4gICAgICovXHJcbiAgICB2YXIgaXNQcmltZSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdmFyIHEgPSBNYXRoLmZsb29yKE1hdGguc3FydChuKSk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMjsgaSA8PSBxOyBpKyspIHtcclxuICAgICAgICAgICAgaWYobiAlIGkgPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhbiBvYmplY3Qgd2l0aCBrbm93biB2YXJpYWJsZSB2YWx1ZSBmb3IgZXZhbHVhdGlvblxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhcmlhYmxlXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgQW55IHN0cmluZ2lmeWFibGUgb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBcclxuICAgICAqL1xyXG4gICAgdmFyIGtub3duVmFyaWFibGUgPSBmdW5jdGlvbiAodmFyaWFibGUsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG8gPSB7fTtcclxuICAgICAgICBvW3ZhcmlhYmxlXSA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBuIGlzIGEgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gblxyXG4gICAgICovXHJcbiAgICB2YXIgaXNOdW1iZXIgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiAvXlxcZCtcXC4/XFxkKiQvLnRlc3Qobik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhbiBhcnJheSBjb250YWlucyBvbmx5IG51bWVyaWMgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICAgICAqL1xyXG4gICAgdmFyIGFsbE51bWVyaWMgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgaWYoIWlzTnVtYmVyKGFycltpXSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgbnVtYmVyIG9yIFN5bWJvbCBpcyBhIGZyYWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcnxTeW1ib2x9IG51bVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHZhciBpc0ZyYWN0aW9uID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIGlmKGlzU3ltYm9sKG51bSkpXHJcbiAgICAgICAgICAgIHJldHVybiBpc0ZyYWN0aW9uKG51bS5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKTtcclxuICAgICAgICByZXR1cm4gKG51bSAlIDEgIT09IDApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG9iamVjdCBwcm92aWRlZCBpcyBhIFN5bWJvbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAgICovXHJcbiAgICB2YXIgaXNTeW1ib2wgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBTeW1ib2wpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG9iamVjdCBwcm92aWRlZCBpcyBhbiBFeHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICAgKi9cclxuICAgIHZhciBpc0V4cHJlc3Npb24gPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBFeHByZXNzaW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB0cmF2ZXJzZXMgdGhlIHN5bWJvbCBzdHJ1Y3R1cmUgYW5kIGdyYWJzIGFsbCB0aGUgdmFyaWFibGVzIGluIGEgc3ltYm9sLiBUaGUgdmFyaWFibGVcclxuICAgICAqIG5hbWVzIGFyZSB0aGVuIHJldHVybmVkIGluIGFscGhhYmV0aWNhbCBvcmRlci5cclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBvYmpcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcG9seVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhcnMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdmFyaWFibGVzLiBEbyBub3QgcGFzcyB0aGlzIGluIGFzIGl0IGdlbmVyYXRlZFxyXG4gICAgICogYXV0b21hdGljYWxseS4gSW4gdGhlIGZ1dHVyZSB0aGlzIHdpbGwgYmUgYSBDb2xsZWN0b3Igb2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfSAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdmFyaWFibGUgbmFtZXNcclxuICAgICAqL1xyXG4gICAgdmFyIHZhcmlhYmxlcyA9IGZ1bmN0aW9uIChvYmosIHBvbHksIHZhcnMpIHtcclxuICAgICAgICB2YXJzID0gdmFycyB8fCB7XHJcbiAgICAgICAgICAgIGM6IFtdLFxyXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jLmluZGV4T2YodmFsdWUpID09PSAtMSAmJiBpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYoaXNTeW1ib2wob2JqKSkge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBvYmouZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmdyb3VwID0gb2JqLnByZXZpb3VzR3JvdXA7XHJcbiAgICAgICAgICAgIGlmKGdyb3VwID09PSBFWClcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyhvYmoucG93ZXIsIHBvbHksIHZhcnMpO1xyXG5cclxuICAgICAgICAgICAgaWYoZ3JvdXAgPT09IENQIHx8IGdyb3VwID09PSBDQiB8fCBwcmV2Z3JvdXAgPT09IENQIHx8IHByZXZncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBvYmouc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyhvYmouc3ltYm9sc1t4XSwgcG9seSwgdmFycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihncm91cCA9PT0gUyB8fCBwcmV2Z3JvdXAgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgIC8vdmVyeSBjcnVkZSBuZWVkcyBmaXhpbmcuIFRPRE9cclxuICAgICAgICAgICAgICAgIGlmKCEob2JqLnZhbHVlID09PSAnZScgfHwgb2JqLnZhbHVlID09PSAncGknIHx8IG9iai52YWx1ZSA9PT0gU2V0dGluZ3MuSU1BR0lOQVJZKSlcclxuICAgICAgICAgICAgICAgICAgICB2YXJzLmFkZChvYmoudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IFBMIHx8IHByZXZncm91cCA9PT0gUEwpIHtcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyhmaXJzdE9iamVjdChvYmouc3ltYm9scyksIHBvbHksIHZhcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICBpZighaXNOYU4ob2JqLnZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICB2YXJzLmFkZChvYmoudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzKG9iai5wb3dlciwgcG9seSwgdmFycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihncm91cCA9PT0gRk4gJiYgIXBvbHkpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmouYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyhvYmouYXJnc1tpXSwgcG9seSwgdmFycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2YXJzLmMuc29ydCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHN1bSBvZiBhbiBhcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRvTnVtYmVyXHJcbiAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICovXHJcbiAgICB2YXIgYXJyYXlTdW0gPSBmdW5jdGlvbiAoYXJyLCB0b051bWJlcikge1xyXG4gICAgICAgIHZhciBzdW0gPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHggPSBhcnJbaV07XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gc3ltYm9sIGlmIG5vdFxyXG4gICAgICAgICAgICBzdW0gPSBfLmFkZChzdW0sICFpc1N5bWJvbCh4KSA/IF8ucGFyc2UoeCkgOiB4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0b051bWJlciA/IE51bWJlcihzdW0pIDogc3VtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcGFyYXRlcyBvdXQgdGhlIHZhcmlhYmxlcyBpbnRvIHRlcm1zIG9mIHZhcmlhYmxzLlxyXG4gICAgICogZS5nLiB4K3kreCp5K3NxcnQoMikrcGkgcmV0dXJuc1xyXG4gICAgICoge3g6IHgsIHk6IHksIHggeTogeCp5LCBjb25zdGFudHM6IHNxcnQoMikrcGlcclxuICAgICAqIEBwYXJhbSB7dHlwZX0gc3ltYm9sXHJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IG9cclxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gZm9yIGV4cG9udGVudGlhbHNcclxuICAgICAqL1xyXG4gICAgdmFyIHNlcGFyYXRlID0gZnVuY3Rpb24gKHN5bWJvbCwgbykge1xyXG4gICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbCk7XHJcbiAgICAgICAgbyA9IG8gfHwge307XHJcbiAgICAgICAgdmFyIGluc2VydCA9IGZ1bmN0aW9uIChrZXksIHN5bSkge1xyXG4gICAgICAgICAgICBpZighb1trZXldKVxyXG4gICAgICAgICAgICAgICAgb1trZXldID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgb1trZXldID0gXy5hZGQob1trZXldLCBzeW0uY2xvbmUoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZih4LmlzQ29uc3RhbnQoJ2FsbCcpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQoJ2NvbnN0YW50cycsIHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoeC5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0KHgudmFsdWUsIHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoeC5ncm91cCA9PT0gRk4gJiYgKHguZm5hbWUgPT09IEFCUyB8fCB4LmZuYW1lID09PSAnJykpIHtcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRlKHguYXJnc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih4Lmdyb3VwID09PSBFWCB8fCB4Lmdyb3VwID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2VwYXJhdGUuIFRlcm0gY2Fubm90IGJlIGEgZnVuY3Rpb24hJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQodmFyaWFibGVzKHgpLmpvaW4oJyAnKSwgeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbHMgaG9sZXMgaW4gYW4gYXJyYXkgd2l0aCB6ZXJvIHN5bWJvbCBvciBnZW5lcmF0ZXMgb25lIHdpdGggbiB6ZXJvZXNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cclxuICAgICAqL1xyXG4gICAgdmFyIGZpbGxIb2xlcyA9IGZ1bmN0aW9uIChhcnIsIG4pIHtcclxuICAgICAgICBuID0gbiB8fCBhcnIubGVuZ3RoO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHN5bSA9IGFycltpXTtcclxuICAgICAgICAgICAgaWYoIXN5bSlcclxuICAgICAgICAgICAgICAgIGFycltpXSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG9iamVjdCBwcm92aWRlZCBpcyBhIFZlY3RvclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAgICovXHJcbiAgICB2YXIgaXNWZWN0b3IgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBWZWN0b3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG9iamVjdCBwcm92aWRlZCBpcyBhIE1hdHJpeFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAgICovXHJcbiAgICB2YXIgaXNNYXRyaXggPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBNYXRyaXgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgaXNTZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBTZXQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgYSBzeW1ib2wgaXMgaW4gZ3JvdXAgTlxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICovXHJcbiAgICB2YXIgaXNOdW1lcmljU3ltYm9sID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgIHJldHVybiBzeW1ib2wuZ3JvdXAgPT09IE4gfHwgc3ltYm9sLmdyb3VwID09PSBQO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgYSBzeW1ib2wgaXMgYSB2YXJpYWJsZSB3aXRoIG5vIG11bHRpcGxpZXIgbm9yIHBvd2VyXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgKi9cclxuICAgIHZhciBpc1ZhcmlhYmxlU3ltYm9sID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgIHJldHVybiBzeW1ib2wuZ3JvdXAgPT09IFMgJiYgc3ltYm9sLm11bHRpcGxpZXIuZXF1YWxzKDEpICYmIHN5bWJvbC5wb3dlci5lcXVhbHMoMSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgb2JqZWN0IHByb3ZpZGVkIGlzIGFuIEFycmF5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJyXHJcbiAgICAgKi9cclxuICAgIHZhciBpc0FycmF5ID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhIG51bWJlciBpcyBhbiBpbnRlZ2VyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXHJcbiAgICAgKi9cclxuICAgIHZhciBpc0ludCA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICByZXR1cm4gL15bLStdP1xcZCtlP1xcKz9cXGQqJC9naW0udGVzdChudW0udG9TdHJpbmcoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3ltYm9sfSBvYmpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBpZihpc1N5bWJvbChvYmopKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IG9iai5tdWx0aXBsaWVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqLmxlc3NUaGFuKDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2FmZWx5IHN0cmluZ2lmeSBvYmplY3RcclxuICAgICAqIEBwYXJhbSBvXHJcbiAgICAgKi9cclxuICAgIHZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmKCFvKVxyXG4gICAgICAgICAgICByZXR1cm4gbztcclxuICAgICAgICByZXR1cm4gU3RyaW5nKG8pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gcmV0dXJucyBhIGZvcm1hdHRlZCBzdHJpbmcgc3Vycm91bmRlZCBieSBicmFja2V0c1xyXG4gICAgICovXHJcbiAgICB2YXIgaW5CcmFja2V0cyA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICByZXR1cm4gJygnICsgc3RyICsgJyknO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlcGxhY2UgcGFydHMgb2Ygc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gVGhlIG9yaWdpbmFsIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBmcm9tIC0gVGhlIHN0YXJ0aW5nIGluZGV4XHJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHRvIC0gVGhlIGVuZGluZyBpbmRleFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHdpdGhfc3RyIC0gVGhlIHJlcGxhY2VtZW50IHN0cmluZ1xyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gLSBBIGZvcm1hdHRlZCBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgdmFyIHN0cmluZ1JlcGxhY2UgPSBmdW5jdGlvbiAoc3RyLCBmcm9tLCB0bywgd2l0aF9zdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBmcm9tKSArIHdpdGhfc3RyICsgc3RyLnN1YnN0cih0bywgc3RyLmxlbmd0aCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogdGhlIFBhcnNlciB1c2VzIHRoaXMgdG8gY2hlY2sgaWYgaXQncyBhbGxvd2VkIHRvIGNvbnZlcnQgdGhlIG9iaiB0byB0eXBlIFN5bWJvbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHZhciBjdXN0b21UeXBlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmouY3VzdG9tO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgbnVtYmVycyBhcmUgYm90aCBuZWdhdGl2ZSBvciBhcmUgYm90aCBwb3NpdGl2ZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdmFyIHNhbWVTaWduID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gKGEgPCAwKSA9PT0gKGIgPCAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZXBsYWNlIG11bHRpcGxlIG9jY3VyZW5jZXMgaW4gYSBzdHJpbmcuIFRha2VzIG11bHRpcGxlIGFyZ3VtZW50c1xyXG4gICAgICogQGV4YW1wbGUgZm9ybWF0KCd7MH0gbmljZSwgezB9IHN3ZWV0JywgJ3NvbWV0aGluZycpXHJcbiAgICAgKiAvL3JldHVybnMgJ3NvbWV0aGluZyBuaWNlLCBzb21ldGhpbmcgc3dlZXQnXHJcbiAgICAgKi9cclxuICAgIHZhciBmb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXHJcbiAgICAgICAgICAgICAgICBzdHIgPSBhcmdzLnNoaWZ0KCk7XHJcbiAgICAgICAgdmFyIG5ld19zdHIgPSBzdHIucmVwbGFjZSgveyhcXGQrKX0vZywgZnVuY3Rpb24gKG1hdGNoLCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXdfc3RyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhbiBhcnJheSB3aXRoIHZhbHVlcyB3aXRoaW4gYSByYW5nZS4gTXVsdGlwbGllcyBieSBhIHN0ZXAgaWYgcHJvdmlkZWRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcclxuICAgICAqL1xyXG4gICAgdmFyIHJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHN0ZXApIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgc3RlcCA9IHN0ZXAgfHwgMTtcclxuICAgICAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKylcclxuICAgICAgICAgICAgYXJyLnB1c2goaSAqIHN0ZXApO1xyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdGhlIGtleXMgaW4gYW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVuY291bnRlcmVkIGl0ZW0gaW4gYW4gb2JqZWN0LiBJdGVtcyBkbyBub3QgaGF2ZSBhIGZpeGVkIG9yZGVyIGluIG9iamVjdHNcclxuICAgICAqIHNvIG9ubHkgdXNlIGlmIHlvdSBuZWVkIGFueSBmaXJzdCByYW5kb20gb3IgaWYgdGhlcmUncyBvbmx5IG9uZSBpdGVtIGluIHRoZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgUmV0dXJuIHRoaXMga2V5IGFzIGZpcnN0IG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBib3RoXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgdmFyIGZpcnN0T2JqZWN0ID0gZnVuY3Rpb24gKG9iaiwga2V5LCBib3RoKSB7XHJcbiAgICAgICAgZm9yKHZhciB4IGluIG9iailcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYoa2V5KVxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICBpZihib3RoKVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAga2V5OiB4LFxyXG4gICAgICAgICAgICAgICAgb2JqOiBvYmpbeF1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gb2JqW3hdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YnN0aXR1dGVzIG91dCB2YXJpYWJsZXMgZm9yIHR3byBzeW1ib2xzLCBwYXJzZXMgdGhlbSB0byBhIG51bWJlciBhbmQgdGhlbSBjb21wYXJlcyB0aGVtIG51bWVyaWNhbGx5XHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltMVxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bTJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHZhcnMgLSBhbiBvcHRpb25hbCBhcnJheSBvZiB2YXJpYWJsZXMgdG8gdXNlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbH1cclxuICAgICAqL1xyXG4gICAgdmFyIGNvbXBhcmUgPSBmdW5jdGlvbiAoc3ltMSwgc3ltMiwgdmFycykge1xyXG4gICAgICAgIHZhciBuID0gNTsgLy9hIHJhbmRvbSBudW1iZXIgYmV0d2VlbiAxIGFuZCA1IGlzIGdvb2QgZW5vdWdoXHJcbiAgICAgICAgdmFyIHNjb3BlID0ge307IC8vIHNjb3BlIG9iamVjdCB3aXRoIHJhbmRvbSBudW1iZXJzIGdlbmVyYXRlZCB1c2luZyB2YXJzXHJcbiAgICAgICAgdmFyIGNvbXBhcmlzb247XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHNjb3BlW3ZhcnNbaV1dID0gbmV3IFN5bWJvbChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBuKSArIDEpO1xyXG4gICAgICAgIGJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbXBhcmlzb24gPSBfLnBhcnNlKHN5bTEsIHNjb3BlKS5lcXVhbHMoXy5wYXJzZShzeW0yLCBzY29wZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wYXJpc29uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElzIHVzZWQgdG8gc2V0IGEgdXNlciBkZWZpbmVkIGZ1bmN0aW9uIHVzaW5nIHRoZSBmdW5jdGlvbiBhc3NpZ24gb3BlcmF0b3JcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJhbXNfYXJyYXlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdmFyIHNldEZ1bmN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIHBhcmFtc19hcnJheSwgYm9keSkge1xyXG4gICAgICAgIHZhbGlkYXRlTmFtZShuYW1lKTtcclxuICAgICAgICBpZighaXNSZXNlcnZlZChuYW1lKSkge1xyXG4gICAgICAgICAgICBwYXJhbXNfYXJyYXkgPSBwYXJhbXNfYXJyYXkgfHwgdmFyaWFibGVzKF8ucGFyc2UoYm9keSkpO1xyXG4gICAgICAgICAgICAvLyBUaGUgZnVuY3Rpb24gZ2V0cyBzZXQgdG8gUEFSU0VSLm1hcHBlZCBmdW5jdGlvbiB3aGljaCBpcyBqdXN0XHJcbiAgICAgICAgICAgIC8vIGEgZ2VuZXJpYyBmdW5jdGlvbiBjYWxsLlxyXG4gICAgICAgICAgICBfLmZ1bmN0aW9uc1tuYW1lXSA9IFtfLm1hcHBlZF9mdW5jdGlvbiwgcGFyYW1zX2FycmF5Lmxlbmd0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNfYXJyYXksXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxyXG4gICAgICAgICAgICAgICAgfV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWluaW11bSBudW1iZXIgaW4gYW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5TWF4ID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseSh1bmRlZmluZWQsIGFycik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgaW4gYW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5TWluID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbi5hcHBseSh1bmRlZmluZWQsIGFycik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0d28gYXJyYXlzIGFyZSBlcXVhbFxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyMSBcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycjIgXHJcbiAgICAgKi9cclxuICAgIHZhciBhcnJheUVxdWFsID0gZnVuY3Rpb24gKGFycjEsIGFycjIpIHtcclxuICAgICAgICBhcnIxLnNvcnQoKTtcclxuICAgICAgICBhcnIyLnNvcnQoKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIG11c3QgYmUgb2YgdGhlIHNhbWUgbGVuZ3RoXHJcbiAgICAgICAgaWYoYXJyMS5sZW5ndGggPT09IGFycjIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgdHdvIGl0ZW1zIGRvbid0IG1hdGNoIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgIGlmKGFycjFbaV0gIT09IGFycjJbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZXkncmUgZXF1YWxcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xvbmVzIGFycmF5IHdpdGggY2xvbmFibGUgaXRlbXNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICovXHJcbiAgICB2YXIgYXJyYXlDbG9uZSA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICB2YXIgbmV3X2FycmF5ID0gW10sIGwgPSBhcnIubGVuZ3RoO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgIG5ld19hcnJheVtpXSA9IGFycltpXS5jbG9uZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXdfYXJyYXk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlsbHMgbnVtYmVycyBiZXR3ZWVuIGFycmF5IHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJzW119IGFyclxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBzbGljZXNcclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5QWRkU2xpY2VzID0gZnVuY3Rpb24gKGFyciwgc2xpY2VzKSB7XHJcbiAgICAgICAgc2xpY2VzID0gc2xpY2VzIHx8IDIwO1xyXG4gICAgICAgIHZhciByZXR2YWwgPSBbXTtcclxuICAgICAgICB2YXIgYywgZGVsdGEsIGU7XHJcbiAgICAgICAgcmV0dmFsLnB1c2goYXJyWzBdKTsgLy9wdXNoIHRoZSBiZWdpbm5pbmdcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBjID0gYXJyW2ldO1xyXG4gICAgICAgICAgICBkZWx0YSA9IGFycltpICsgMV0gLSBjOyAvL2dldCB0aGUgZGlmZmVyZW5jZVxyXG4gICAgICAgICAgICBlID0gZGVsdGEgLyBzbGljZXM7IC8vY2hvcCBpdCB1cCBpbiB0aGUgZGVzaXJlZCBudW1iZXIgb2Ygc2xpY2VzXHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBzbGljZXM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYyArPSBlOyAvL2FkZCB0aGUgbWVzaCB0byB0aGUgbGFzdCBzbGljZVxyXG4gICAgICAgICAgICAgICAgcmV0dmFsLnB1c2goYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBudGggcm9vdHMgb2YgYSBudW1iZXJcclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAqIEByZXR1cm5zIHtWZWN0b3J9XHJcbiAgICAgKi9cclxuICAgIHZhciBucm9vdHMgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgdmFyIGEsIGI7XHJcblxyXG4gICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gRk4gJiYgc3ltYm9sLmZuYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICBhID0gU3ltYm9sLnVud3JhcFBBUkVOUyhfLnBhcnNlKHN5bWJvbCkudG9MaW5lYXIoKSk7XHJcbiAgICAgICAgICAgIGIgPSBfLnBhcnNlKHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBQKSB7XHJcbiAgICAgICAgICAgIGEgPSBfLnBhcnNlKHN5bWJvbC52YWx1ZSk7XHJcbiAgICAgICAgICAgIGIgPSBfLnBhcnNlKHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihhICYmIGIgJiYgKGEuZ3JvdXAgPT09IE4pICYmIGIuZ3JvdXAgPT09IE4gJiYgYS5tdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICB2YXIgX3Jvb3RzID0gW107XHJcblxyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBTeW1ib2wudG9Qb2xhckZvcm1BcnJheShldmFsdWF0ZShzeW1ib2wpKTtcclxuICAgICAgICAgICAgdmFyIHIgPSBwYXJ0c1swXTtcclxuXHJcbiAgICAgICAgICAgIC8vdmFyIHIgPSBfLnBhcnNlKGEpLmFicygpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlX01vaXZyZSUyN3NfZm9ybXVsYVxyXG4gICAgICAgICAgICB2YXIgeCA9IF8uYXJnKGEpO1xyXG4gICAgICAgICAgICB2YXIgbiA9IGIubXVsdGlwbGllci5kZW4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIHAgPSBiLm11bHRpcGxpZXIubnVtLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZm9ybXVsYSA9ICcoKHswfSleKHsxfSkqKGNvcyh7M30pKyh7Mn0pKnNpbih7M30pKSleKHs0fSknO1xyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBldmFsdWF0ZShfLnBhcnNlKGZvcm1hdChcIigoezB9KSsyKnBpKih7MX0pKS8oezJ9KVwiLCB4LCBpLCBuKSkpLm11bHRpcGxpZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICBfcm9vdHMucHVzaChldmFsdWF0ZShfLnBhcnNlKGZvcm1hdChmb3JtdWxhLCByLCBuLCBTZXR0aW5ncy5JTUFHSU5BUlksIHQsIHApKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuZnJvbUFycmF5KF9yb290cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzQ29uc3RhbnQodHJ1ZSwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSBzeW1ib2wuc2lnbigpO1xyXG4gICAgICAgICAgICB2YXIgeCA9IGV2YWx1YXRlKHN5bWJvbC5hYnMoKSk7XHJcbiAgICAgICAgICAgIHZhciByb290ID0gXy5zcXJ0KHgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIF9yb290cyA9IFtyb290LmNsb25lKCksIHJvb3QubmVnYXRlKCldO1xyXG5cclxuICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICBfcm9vdHMgPSBfcm9vdHMubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoeCwgU3ltYm9sLmltYWdpbmFyeSgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9yb290cyA9IFtfLnBhcnNlKHN5bWJvbCldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFZlY3Rvci5mcm9tQXJyYXkoX3Jvb3RzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTb3J0cyBhbmQgYXJyYXkgZ2l2ZW4gMiBwYXJhbWV0ZXJzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJcclxuICAgICAqL1xyXG4gICAgdmFyIGNvbWJvU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGNvbWJpbmVkID0gW107IC8vdGhlIGxpbmtlclxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbWJpbmVkLnB1c2goW2FbaV0sIGJbaV1dKTsgLy9jcmVhdGUgdGhlIG1hcFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29tYmluZWQuc29ydChmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICByZXR1cm4geFswXSAtIHlbMF07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBuYSA9IFtdLCBuYiA9IFtdO1xyXG5cclxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgbmEucHVzaChjb21iaW5lZFtpXVswXSk7XHJcbiAgICAgICAgICAgIG5iLnB1c2goY29tYmluZWRbaV1bMV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFtuYSwgbmJdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVE9ETzogUGljayBhIG1vcmUgZGVzY3JpcHRpdmUgbmFtZSBhbmQgYmV0dGVyIGRlc2NyaXB0aW9uXHJcbiAgICAgKiBCcmVha3MgYSBmdW5jdGlvbiBkb3duIGludG8gaXQncyBwYXJ0cyB3cnQgdG8gYSB2YXJpYWJsZSwgbWFpbmx5IGNvZWZmaWNpZW50c1xyXG4gICAgICogRXhhbXBsZSBhKnheMitiIHdydCB4XHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gZm5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3cnRcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gYXNfb2JqXHJcbiAgICAgKi9cclxuICAgIHZhciBkZWNvbXBvc2VfZm4gPSBmdW5jdGlvbiAoZm4sIHdydCwgYXNfb2JqKSB7XHJcbiAgICAgICAgd3J0ID0gU3RyaW5nKHdydCk7IC8vY29udmVydCB0byBzdHJpbmdcclxuICAgICAgICB2YXIgYXgsIGEsIHgsIGI7XHJcbiAgICAgICAgaWYoZm4uZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gXy5leHBhbmQoZm4uY2xvbmUoKSkuc3RyaXBWYXIod3J0KTtcclxuICAgICAgICAgICAgYXggPSBfLnN1YnRyYWN0KGZuLmNsb25lKCksIHQuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIGIgPSB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGF4ID0gZm4uY2xvbmUoKTtcclxuICAgICAgICBhID0gYXguc3RyaXBWYXIod3J0KTtcclxuICAgICAgICB4ID0gXy5kaXZpZGUoYXguY2xvbmUoKSwgYS5jbG9uZSgpKTtcclxuICAgICAgICBiID0gYiB8fCBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgIGlmKGFzX29iailcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGE6IGEsXHJcbiAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgYXg6IGF4LFxyXG4gICAgICAgICAgICAgICAgYjogYlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBbYSwgeCwgYXgsIGJdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUm91bmRzIGEgbnVtYmVyIHVwIHRvIHggZGVjaW1hbCBwbGFjZXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc1xyXG4gICAgICovXHJcbiAgICB2YXIgbnJvdW5kID0gZnVuY3Rpb24gKHgsIHMpIHtcclxuICAgICAgICBpZihpc0ludCh4KSkge1xyXG4gICAgICAgICAgICBpZih4ID49IE51bWJlci5NQVhfVkFMVUUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcyA9IHR5cGVvZiBzID09PSAndW5kZWZpbmVkJyA/IDE0IDogcztcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogTWF0aC5wb3coMTAsIHMpKSAvIE1hdGgucG93KDEwLCBzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB1c2VkIGZvciB1LXN1YnN0aXR1dGlvbi4gR2V0cyBhIHN1aXRhYmxlIHUgZm9yIHN1YnN0aXR1dGlvbi4gSWYgZm9yXHJcbiAgICAgKiBpbnN0YW5jZSBhIGlzIHVzZWQgaW4gdGhlIHN5bWJvbCB0aGVuIGl0IGtlZXBzIGdvaW5nIGRvd24gdGhlIGxpbmUgdW50aWxcclxuICAgICAqIG9uZSBpcyBmb3VuZCB0aGF0J3Mgbm90IGluIHVzZS4gSWYgYWxsIGxldHRlcnMgYXJlIHRha2VuIHRoZW4gaXRcclxuICAgICAqIHN0YXJ0cyBhcHBlbmRpbmcgbnVtYmVycy5cclxuICAgICAqIElNUE9SVEFOVCEgSXQgYXNzdW1lcyB0aGF0IHRoZSBzdWJzdGl0dXRpb24gd2lsbCBiZSB1bmRvbmVcclxuICAgICAqIGJlb3JlIHRoZSB1c2VyIGdldHMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgb2JqZWN0IGFnYWluLlxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0VSA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAvL3N0YXJ0IHdpdGggdVxyXG4gICAgICAgIHZhciB1ID0gJ3UnLCAvL3N0YXJ0IHdpdGggdVxyXG4gICAgICAgICAgICAgICAgdiA9IHUsIC8vaW5pdCB3aXRoIHVcclxuICAgICAgICAgICAgICAgIGMgPSAwLCAvL3Bvc3RmaXggbnVtYmVyXHJcbiAgICAgICAgICAgICAgICB2YXJzID0gdmFyaWFibGVzKHN5bWJvbCk7XHJcbiAgICAgICAgLy9tYWtlIHN1cmUgdGhpcyB2YXJpYWJsZSBpc24ndCByZXNlcnZlZCBhbmQgaXNuJ3QgaW4gdGhlIHZhcmlhYmxlIGxpc3RcclxuICAgICAgICB3aGlsZSghKFJFU0VSVkVELmluZGV4T2YodikgPT09IC0gMSAmJiB2YXJzLmluZGV4T2YodikgPT09IC0gMSkpXHJcbiAgICAgICAgICAgIHYgPSB1ICsgYysrO1xyXG4gICAgICAgIC8vZ2V0IGFuIGVtcHR5IHNsb3QuIEl0IHNlZW1zIGVhc2llciB0byBqdXN0IHB1c2ggYnV0IHRoZVxyXG4gICAgICAgIC8vcHJvYmxlbSBpcyB0aGF0IHdlIG1heSBoYXZlIHNvbWUgd2hpY2ggYXJlIGNyZWF0ZWQgYnkgY2xlYXJVXHJcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IFJFU0VSVkVELmxlbmd0aDsgaSA8PSBsOyBpKyspXHJcbiAgICAgICAgICAgIC8vcmVzZXJ2ZWQgY2Fubm90IGVxdWFscyBmYWxzZSBvciAwIHNvIHdlIGNhbiBzYWZlbHkgY2hlY2sgZm9yIGEgZmFsc3kgdHlwZVxyXG4gICAgICAgICAgICBpZighUkVTRVJWRURbaV0pIHtcclxuICAgICAgICAgICAgICAgIFJFU0VSVkVEW2ldID0gdjsgLy9yZXNlcnZlIHRoZSB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIHUgdmFyaWFibGUgc28gaXQncyBubyBsb25nZXIgcmVzZXJ2ZWRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1XHJcbiAgICAgKi9cclxuICAgIHZhciBjbGVhclUgPSBmdW5jdGlvbiAodSkge1xyXG4gICAgICAgIHZhciBpbmR4ID0gUkVTRVJWRUQuaW5kZXhPZih1KTtcclxuICAgICAgICBpZihpbmR4ICE9PSAtMSlcclxuICAgICAgICAgICAgUkVTRVJWRURbaW5keF0gPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9vcHMgdGhyb3VnaCBlYWNoIGl0ZW0gaW4gb2JqZWN0IGFuZCBjYWxscyBmdW5jdGlvbiB3aXRoIGl0ZW0gYXMgcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAgICAgKi9cclxuICAgIHZhciBlYWNoID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcclxuICAgICAgICBpZihpc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgZm4uY2FsbChvYmosIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIG9iailcclxuICAgICAgICAgICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eSh4KSlcclxuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKG9iaiwgeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgYSBudW1iZXIgaXMgYW4gZXZlbiBudW1iZXJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW1cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB2YXIgZXZlbiA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICByZXR1cm4gbnVtICUgMiA9PT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgZnJhY3Rpb24gaXMgZGl2aXNpYmxlIGJ5IDJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW1cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB2YXIgZXZlbkZyYWN0aW9uID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHJldHVybiAxIC8gKG51bSAlIDEpICUgMiA9PT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJpcHMgZHVwbGljYXRlcyBvdXQgb2YgYW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gICAgICovXHJcbiAgICB2YXIgYXJyYXlVbmlxdWUgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgdmFyIGwgPSBhcnIubGVuZ3RoLCBhID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFycltpXTtcclxuICAgICAgICAgICAgaWYoYS5pbmRleE9mKGl0ZW0pID09PSAtMSlcclxuICAgICAgICAgICAgICAgIGEucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgdGhlIHZhcmlhYmxlcyBpbiBhbiBhcnJheSBvZiBTeW1ib2xzXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbFtdfSBhcnIgXHJcbiAgICAgKi9cclxuICAgIHZhciBhcnJheUdldFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICB2YXIgdmFycyA9IHZhcmlhYmxlcyhhcnJbMF0sIG51bGwsIG51bGwsIHRydWUpO1xyXG5cclxuICAgICAgICAvL2dldCBhbGwgdmFyaWFibGVzXHJcbiAgICAgICAgZm9yKHZhciBpID0gMSwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgIHZhcnMgPSB2YXJzLmNvbmNhdCh2YXJpYWJsZXMoYXJyW2ldKSk7XHJcbiAgICAgICAgLy9yZW1vdmUgZHVwbGljYXRlc1xyXG4gICAgICAgIHZhcnMgPSBhcnJheVVuaXF1ZSh2YXJzKS5zb3J0KCk7XHJcblxyXG4gICAgICAgIC8vZG9uZVxyXG4gICAgICAgIHJldHVybiB2YXJzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIGFuIGFycmF5LiBSZXR1cm5zIGEgbmV3IGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmRpdGlvblxyXG4gICAgICovXHJcbiAgICB2YXIgcmVtb3ZlRHVwbGljYXRlcyA9IGZ1bmN0aW9uIChhcnIsIGNvbmRpdGlvbikge1xyXG4gICAgICAgIHZhciBjb25kaXRpb25UeXBlID0gdHlwZW9mIGNvbmRpdGlvbjtcclxuXHJcbiAgICAgICAgaWYoY29uZGl0aW9uVHlwZSAhPT0gJ2Z1bmN0aW9uJyB8fCBjb25kaXRpb25UeXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBjb25kaXRpb24gPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2VlbiA9IFtdO1xyXG5cclxuICAgICAgICB3aGlsZShhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJyWzBdO1xyXG4gICAgICAgICAgICAvL29ubHkgb25lIGVsZW1lbnQgbGVmdCBzbyB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgIGlmKGFyci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHNlZW4ucHVzaChhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gW107XHJcbiAgICAgICAgICAgIHNlZW4ucHVzaChhKTsgLy93ZSBhbHJlYWR5IHNjYW5uZWQgdGhlc2VcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBhcnJbaV07XHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBudW1iZXIgaXMgb3V0c2lkZSB0aGUgc3BlY2lmaWVkIHRvbGVyYW5jZVxyXG4gICAgICAgICAgICAgICAgaWYoIWNvbmRpdGlvbihhLCBiKSlcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2goYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9zdGFydCBvdmVyIHdpdGggdGhlIHJlbWFpbmRlclxyXG4gICAgICAgICAgICBhcnIgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNlZW47XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXJ2ZXMgdGhlIG5hbWVzIGluIGFuIG9iamVjdCBzbyB0aGV5IGNhbm5vdCBiZSB1c2VkIGFzIGZ1bmN0aW9uIG5hbWVzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICAgKi9cclxuICAgIHZhciByZXNlcnZlTmFtZXMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmKFJFU0VSVkVELmluZGV4T2YoaXRlbSkgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgUkVTRVJWRUQucHVzaChpdGVtKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZih0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgYWRkKG9iaik7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVhY2gob2JqLCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgYWRkKHgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gZWl0aGVyIGFuIGFycmF5IG9yIGFuIG9iamVjdC4gSWYgdGhlIG9iamVjdCBpcyBhbiBhcnJheSwgdGhlIGluZGV4IG11c3QgYmVcclxuICAgICAqIHNwZWNpZmllZCBhZnRlciB0aGUgYXJyYXkuIElmIGl0J3MgYW4gb2JqZWN0IHRoZW4gdGhlIGtleSBtdXN0IGJlIHNwZWNpZmllZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBpbmRleE9yS2V5XHJcbiAgICAgKi9cclxuICAgIHZhciByZW1vdmUgPSBmdW5jdGlvbiAob2JqLCBpbmRleE9yS2V5KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBpZihpc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gb2JqLnNwbGljZShpbmRleE9yS2V5LCAxKVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG9ialtpbmRleE9yS2V5XTtcclxuICAgICAgICAgICAgZGVsZXRlIG9ialtpbmRleE9yS2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IGJsb2NrIGluIHdoaWNoIG9uZSBvZiB0aGUgZ2xvYmFsIHNldHRpbmdzIGlzIHRlbXBvcmFyaWx5IG1vZGlmaWVkIHdoaWxlXHJcbiAgICAgKiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBGb3IgaW5zdGFuY2UgaWYgeW91IHdhbnQgdG8gcGFyc2UgZGlyZWN0bHkgdG8gYSBudW1iZXIgcmF0aGVyIHRoYW4gaGF2ZSBhIHN5bWJvbGljXHJcbiAgICAgKiBhbnN3ZXIgZm9yIGEgcGVyaW9kIHlvdSB3b3VsZCBzZXQgUEFSU0UyTlVNQkVSIHRvIHRydWUgaW4gdGhlIGJsb2NrLlxyXG4gICAgICogQGV4YW1wbGUgYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uKCl7Ly9zeW1ib2wgYmVpbmcgcGFyc2VkIHRvIG51bWJlcn0sIHRydWUpO1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmcgLSBUaGUgc2V0dGluZyBiZWluZyBhY2Nlc3NlZFxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHQgLSBUaGUgdmFsdWUgb2YgdGhlIHNldHRpbmcgaW4gdGhlIGJsb2NrXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gVGhlIG9iaiBvZiBpbnRlcmVzdC4gVXN1YWxseSBhIFN5bWJvbCBidXQgY291bGQgYmUgYW55IG9iamVjdFxyXG4gICAgICovXHJcbiAgICB2YXIgYmxvY2sgPSBmdW5jdGlvbiAoc2V0dGluZywgZiwgb3B0LCBvYmopIHtcclxuICAgICAgICB2YXIgY3VycmVudF9zZXR0aW5nID0gU2V0dGluZ3Nbc2V0dGluZ107XHJcbiAgICAgICAgU2V0dGluZ3Nbc2V0dGluZ10gPSBvcHQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIW9wdDtcclxuICAgICAgICB2YXIgcmV0dmFsID0gZi5jYWxsKG9iaik7XHJcbiAgICAgICAgU2V0dGluZ3Nbc2V0dGluZ10gPSBjdXJyZW50X3NldHRpbmc7XHJcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBwcm92aWRlIGEgbWVjaGFuaXNtIGZvciBhY2Nlc3NpbmcgZnVuY3Rpb25zIGRpcmVjdGx5LiBOb3QgeWV0IGNvbXBsZXRlISEhXHJcbiAgICAgKiBTb21lIGZ1bmN0aW9ucyB3aWxsIHJldHVybiB1bmRlZmluZWQuIFRoaXMgY2FuIG1heWJlIGp1c3QgcmVtb3ZlIHRoZVxyXG4gICAgICogZnVuY3Rpb24gb2JqZWN0IGF0IHNvbWUgcG9pbnQgd2hlbiBhbGwgZnVuY3Rpb25zIGFyZSBldmVudHVhbGx5XHJcbiAgICAgKiBob3VzZWQgaW4gdGhlIGdsb2JhbCBmdW5jdGlvbiBvYmplY3QuIFJldHVybnMgQUxMIHBhcnNlciBhdmFpbGFibGVcclxuICAgICAqIGZ1bmN0aW9ucy4gUGFyc2VyLmZ1bmN0aW9ucyBtYXkgbm90IGNvbnRhaW4gYWxsIGZ1bmN0aW9uc1xyXG4gICAgICovXHJcbiAgICB2YXIgaW1wb3J0RnVuY3Rpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvID0ge307XHJcbiAgICAgICAgZm9yKHZhciB4IGluIF8uZnVuY3Rpb25zKVxyXG4gICAgICAgICAgICBvW3hdID0gXy5mdW5jdGlvbnNbeF1bMF07XHJcbiAgICAgICAgcmV0dXJuIG87XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgZnVuY3Rpb24gYXJndW1lbnRzIHRvIGFuIGFycmF5LiBOb3cgdXNlZCBieSBnY2QgYW5kIGxjbSBpbiBBbGdlYnJhLmpzIDopXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fG9iamVjdH0gb2JqXHJcbiAgICAgKi9cclxuICAgIHZhciBhcmd1bWVudHMyQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwob2JqKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb2VmZmljaWVudHMgb2YgYSBzeW1ib2wgZ2l2ZW4gYSB2YXJpYWJsZS4gR2l2ZW4gYXheMitiXngrYywgaXQgZGl2aWRlc1xyXG4gICAgICogZWFjaCBudGggdGVybSBieSB4Xm4uXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gd3J0XHJcbiAgICAgKi9cclxuICAgIHZhciBnZXRDb2VmZnMgPSBmdW5jdGlvbiAoc3ltYm9sLCB3cnQsIGluZm8pIHtcclxuICAgICAgICB2YXIgY29lZmZzID0gW107XHJcbiAgICAgICAgLy93ZSBsb29wIHRocm91Z2ggdGhlIHN5bWJvbHMgYW5kIHN0aWNrIHRoZW0gaW4gdGhlaXIgcmVzcGVjdGl2ZVxyXG4gICAgICAgIC8vY29udGFpbmVycyBlLmcuIHkqeF4yIGdvZXMgdG8gaW5kZXggMlxyXG4gICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh0ZXJtKSB7XHJcbiAgICAgICAgICAgIGlmKHRlcm0uY29udGFpbnMod3J0KSkge1xyXG4gICAgICAgICAgICAgICAgLy93ZSB3YW50IG9ubHkgdGhlIGNvZWZmaWNpZW50IHdoaWNoIGluIHRoaXMgY2FzZSB3aWxsIGJlIGV2ZXJ5dGhpbmcgYnV0IHRoZSB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgLy9lLmcuIGEqYip4IC0+IGEqYiBpZiB0aGUgdmFyaWFibGUgdG8gc29sdmUgZm9yIGlzIHhcclxuICAgICAgICAgICAgICAgIHZhciBjb2VmZiA9IHRlcm0uc3RyaXBWYXIod3J0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IF8uZGl2aWRlKHRlcm0uY2xvbmUoKSwgY29lZmYuY2xvbmUoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSB4LnBvd2VyLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29lZmYgPSB0ZXJtO1xyXG4gICAgICAgICAgICAgICAgcCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGUgPSBjb2VmZnNbcF07XHJcbiAgICAgICAgICAgIC8vaWYgaXQgZXhpc3RzIGp1c3QgYWRkIGl0IHRvIGl0XHJcbiAgICAgICAgICAgIGNvZWZmc1twXSA9IGUgPyBfLmFkZChlLCBjb2VmZikgOiBjb2VmZjtcclxuXHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb2VmZnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmKCFjb2VmZnNbaV0pXHJcbiAgICAgICAgICAgICAgICBjb2VmZnNbaV0gPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgIC8vZmlsbCB0aGUgaG9sZXNcclxuICAgICAgICByZXR1cm4gY29lZmZzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFzIHRoZSBuYW1lIHN0YXRlcy4gSXQgZm9yY2VzIGV2YWx1YXRpb24gb2YgdGhlIGV4cHJlc3Npb25cclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBvXHJcbiAgICAgKi9cclxuICAgIHZhciBldmFsdWF0ZSA9IGZ1bmN0aW9uIChzeW1ib2wsIG8pIHtcclxuICAgICAgICByZXR1cm4gYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2Uoc3ltYm9sLCBvKTtcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhbiBhcnJheSB0byBhIHZlY3Rvci4gQ29uc2lkZXIgbW92aW5nIHRoaXMgdG8gVmVjdG9yLmZyb21BcnJheVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd8U3ltYm9sfE51bWJlcnxOdW1iZXJbXX0geFxyXG4gICAgICovXHJcbiAgICB2YXIgY29udmVydFRvVmVjdG9yID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZihpc0FycmF5KHgpKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB2ZWN0b3IuZWxlbWVudHMucHVzaChjb252ZXJ0VG9WZWN0b3IoeFtpXSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0Vuc3VyZSB0aGF0IGEgbmVyZGFtZXIgcmVhZHkgb2JqZWN0IGlzIHJldHVybmVkXHJcbiAgICAgICAgaWYoIWlzU3ltYm9sKHgpKVxyXG4gICAgICAgICAgICByZXR1cm4gXy5wYXJzZSh4KTtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgcHJpbWUgbnVtYmVycyB1cCB0byBhIHNwZWNpZmllZCBudW1iZXJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB1cHRvXHJcbiAgICAgKi9cclxuICAgIHZhciBnZW5lcmF0ZVByaW1lcyA9IGZ1bmN0aW9uICh1cHRvKSB7XHJcbiAgICAgICAgLy9nZXQgdGhlIGxhc3QgcHJpbWUgaW4gdGhlIGFycmF5XHJcbiAgICAgICAgdmFyIGxhc3RfcHJpbWUgPSBQUklNRVNbUFJJTUVTLmxlbmd0aCAtIDFdIHx8IDI7XHJcbiAgICAgICAgLy9ubyBuZWVkIHRvIGNoZWNrIGlmIHdlJ3ZlIGFscmVhZHkgZW5jb3VudGVyZWQgdGhlIG51bWJlci4gSnVzdCBjaGVjayB0aGUgY2FjaGUuXHJcbiAgICAgICAgZm9yKHZhciBpID0gbGFzdF9wcmltZTsgaSA8IHVwdG87IGkrKykge1xyXG4gICAgICAgICAgICBpZihpc1ByaW1lKGkpKVxyXG4gICAgICAgICAgICAgICAgUFJJTUVTLnB1c2goaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhbGwgYXJndW1lbnRzIGFyZSBudW1iZXJzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xyXG4gICAgICovXHJcbiAgICB2YXIgYWxsTnVtYmVycyA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmKGFyZ3NbaV0uZ3JvdXAgIT09IE4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICAqIENoZWNrcyBpZiBhbGwgYXJndW1lbnRzIGFyZW4ndCBqdXN0IGFsbCBudW1iZXIgYnV0IGlmIHRoZXlcclxuICAgICAqIGFyZSBjb25zdGFudHMgYXMgd2VsbCBlLmcuIHBpLCBlLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcclxuICAgICAqL1xyXG4gICAgdmFyIGFsbENvbnN0YW50cyA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYoYXJnc1tpXS5pc1BpKCkgfHwgYXJnc1tpXS5pc0UoKSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZighYXJnc1tpXS5pc0NvbnN0YW50KHRydWUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIG11bHRpcGx5IHR3byBleHByZXNzaW9uIGluIGV4cGFuZGVkIGZvcm1cclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBhXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYlxyXG4gICAgICovXHJcbiAgICB2YXIgbWl4ID0gZnVuY3Rpb24gKGEsIGIsIG9wdCkge1xyXG4gICAgICAgIC8vIEZsaXAgdGhlbSBpZiBiIGlzIGEgQ1Agb3IgUEwgYW5kIGEgaXMgbm90XHJcbiAgICAgICAgaWYoYi5pc0NvbXBvc2l0ZSgpICYmICFhLmlzQ29tcG9zaXRlKCkgfHwgYi5pc0xpbmVhcigpICYmICFhLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgW2EsIGJdID0gW2IsIGFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBob2xkIHRoZSBleHBhbmRlZCB0ZXJtc1xyXG4gICAgICAgIHZhciB0ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICBpZihhLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgYS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBiIGlzIG5vdCBhIFBMIG9yIGEgQ1AgdGhlbiBzaW1wbHkgbXVsdGlwbHkgaXRcclxuICAgICAgICAgICAgICAgIGlmKCFiLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybSA9IF8ubXVsdGlwbHkoXy5wYXJzZSh4KSwgXy5wYXJzZShiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IF8uYWRkKHQsIF8uZXhwYW5kKHRlcm0sIG9wdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIG11bHRpcGx5IG91dCBlYWNoIHRlcm0uXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGIuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuZWFjaChmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVybSA9IF8ubXVsdGlwbHkoXy5wYXJzZSh4KSwgXy5wYXJzZSh5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZCA9IF8uZXhwYW5kKF8ucGFyc2UodGVybSksIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLmFkZCh0LCBleHBhbmRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0ID0gXy5hZGQodCwgXy5tdWx0aXBseSh4LCBfLnBhcnNlKGIpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSnVzdCBtdWx0aXBseSB0aGVtIHRvZ2V0aGVyXHJcbiAgICAgICAgICAgIHQgPSBfLm11bHRpcGx5KGEsIGIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGV4cGFuZGVkIGZ1bmN0aW9uIGlzIG5vdyB0XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuLy9FeGNlcHRpb25zID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vSXMgdGhyb3duIGZvciBkaXZpc2lvbiBieSB6ZXJvXHJcbiAgICB2YXIgRGl2aXNpb25CeVplcm8gPSBjdXN0b21FcnJvcignRGl2aXNpb25CeVplcm8nKTtcclxuICAgIC8vIElzIHRocm93IGlmIGFuIGVycm9yIG9jY3VyZWQgZHVyaW5nIHBhcnNpbmdcclxuICAgIHZhciBQYXJzZUVycm9yID0gY3VzdG9tRXJyb3IoJ1BhcnNlRXJyb3InKTtcclxuICAgIC8vIElzIHRocm93biBpZiB0aGUgZXhwcmVzc2lvbiByZXN1bHRzIGluIHVuZGVmaW5lZFxyXG4gICAgdmFyIFVuZGVmaW5lZEVycm9yID0gY3VzdG9tRXJyb3IoJ1VuZGVmaW5lZEVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvdyBpbnB1dCBpcyBvdXQgb2YgdGhlIGZ1bmN0aW9uIGRvbWFpblxyXG4gICAgdmFyIE91dE9mRnVuY3Rpb25Eb21haW5FcnJvciA9IGN1c3RvbUVycm9yKCdPdXRPZkZ1bmN0aW9uRG9tYWluRXJyb3InKTtcclxuICAgIC8vIElzIHRocm93IGlmIGEgZnVuY3Rpb24gZXhjZWVkcyB4IGFtb3VudCBvZiBpdGVyYXRpb25zXHJcbiAgICB2YXIgTWF4aW11bUl0ZXJhdGlvbnNSZWFjaGVkID0gY3VzdG9tRXJyb3IoJ01heGltdW1JdGVyYXRpb25zUmVhY2hlZCcpO1xyXG4gICAgLy8gSXMgdGhyb3duIGlmIHRoZSBwYXJzZXIgcmVjZWl2ZXMgYW4gaW5jb3JyZWN0IHR5cGVcclxuICAgIHZhciBOZXJkYW1lclR5cGVFcnJvciA9IGN1c3RvbUVycm9yKCdOZXJkYW1lclR5cGVFcnJvcicpO1xyXG4gICAgLy8gSXMgdGhyb3duIGlmIGJyYWNrZXQgcGFyaXR5IGlzIG5vdCBjb3JyZWN0XHJcbiAgICB2YXIgUGFyaXR5RXJyb3IgPSBjdXN0b21FcnJvcignUGFyaXR5RXJyb3InKTtcclxuICAgIC8vIElzIHRocm93biBpZiBhbiB1bmV4cGVjdGQgb3IgaW5jb3JyZWN0IG9wZXJhdG9yIGlzIGVuY291bnRlcmVkXHJcbiAgICB2YXIgT3BlcmF0b3JFcnJvciA9IGN1c3RvbUVycm9yKCdPcGVyYXRvckVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvd24gaWYgYW4gaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxyXG4gICAgdmFyIE91dE9mUmFuZ2VFcnJvciA9IGN1c3RvbUVycm9yKCdPdXRPZlJhbmdlRXJyb3InKTtcclxuICAgIC8vIElzIHRocm93biBpZiBkaW1lbnNpb25zIGFyZSBpbmNvcnJlY3QuIE1vc3RseSBmb3IgbWF0cmljZXNcclxuICAgIHZhciBEaW1lbnNpb25FcnJvciA9IGN1c3RvbUVycm9yKCdEaW1lbnNpb25FcnJvcicpO1xyXG4gICAgLy8gSXMgdGhyb3duIGlmIHZhcmlhYmxlIG5hbWUgdmlvbGF0ZXMgbmFtaW5nIHJ1bGVcclxuICAgIHZhciBJbnZhbGlkVmFyaWFibGVOYW1lRXJyb3IgPSBjdXN0b21FcnJvcignSW52YWxpZFZhcmlhYmxlTmFtZUVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvd24gaWYgdGhlIGxpbWl0cyBvZiB0aGUgbGlicmFyeSBhcmUgZXhjZWVkZWQgZm9yIGEgZnVuY3Rpb25cclxuICAgIC8vIFRoaXMgY2FuIGJlIHRoYXQgdGhlIGZ1bmN0aW9uIGJlY29tZSB1bnN0YWJsZSBwYXNzZWQgYSB2YWx1ZVxyXG4gICAgdmFyIFZhbHVlTGltaXRFeGNlZWRlZEVycm9yID0gY3VzdG9tRXJyb3IoJ1ZhbHVlTGltaXRFeGNlZWRlZEVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvdyBpZiB0aGUgdmFsdWUgaXMgYW4gaW5jb3JyZWN0IExIIG9yIFJIIHZhbHVlXHJcbiAgICB2YXIgTmVyZGFtZXJWYWx1ZUVycm9yID0gY3VzdG9tRXJyb3IoJ05lcmRhbWVyVmFsdWVFcnJvcicpO1xyXG4gICAgLy8gSXMgdGhyb3duIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbmNvcnJlY3QgTEggb3IgUkggdmFsdWVcclxuICAgIHZhciBTb2x2ZUVycm9yID0gY3VzdG9tRXJyb3IoJ1NvbHZlRXJyb3InKTtcclxuICAgIC8vIElzIHRocm93biBmb3IgYW4gaW5maW5pdGUgbG9vcFxyXG4gICAgdmFyIEluZmluaXRlTG9vcEVycm9yID0gY3VzdG9tRXJyb3IoJ0luZmluaXRlTG9vcEVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvd24gaWYgYW4gb3BlcmF0b3IgaXMgZm91bmQgd2hlbiB0aGVyZSBzaG91bGRuJ3QgYmUgb25lXHJcbiAgICB2YXIgVW5leHBlY3RlZFRva2VuRXJyb3IgPSBjdXN0b21FcnJvcignVW5leHBlY3RlZFRva2VuRXJyb3InKTtcclxuXHJcbiAgICB2YXIgZXhjZXB0aW9ucyA9IHtcclxuICAgICAgICBEaXZpc2lvbkJ5WmVybzogRGl2aXNpb25CeVplcm8sXHJcbiAgICAgICAgUGFyc2VFcnJvcjogUGFyc2VFcnJvcixcclxuICAgICAgICBPdXRPZkZ1bmN0aW9uRG9tYWluRXJyb3I6IE91dE9mRnVuY3Rpb25Eb21haW5FcnJvcixcclxuICAgICAgICBVbmRlZmluZWRFcnJvcjogVW5kZWZpbmVkRXJyb3IsXHJcbiAgICAgICAgTWF4aW11bUl0ZXJhdGlvbnNSZWFjaGVkOiBNYXhpbXVtSXRlcmF0aW9uc1JlYWNoZWQsXHJcbiAgICAgICAgTmVyZGFtZXJUeXBlRXJyb3I6IE5lcmRhbWVyVHlwZUVycm9yLFxyXG4gICAgICAgIFBhcml0eUVycm9yOiBQYXJpdHlFcnJvcixcclxuICAgICAgICBPcGVyYXRvckVycm9yOiBPcGVyYXRvckVycm9yLFxyXG4gICAgICAgIE91dE9mUmFuZ2VFcnJvcjogT3V0T2ZSYW5nZUVycm9yLFxyXG4gICAgICAgIERpbWVuc2lvbkVycm9yOiBEaW1lbnNpb25FcnJvcixcclxuICAgICAgICBJbnZhbGlkVmFyaWFibGVOYW1lRXJyb3I6IEludmFsaWRWYXJpYWJsZU5hbWVFcnJvcixcclxuICAgICAgICBWYWx1ZUxpbWl0RXhjZWVkZWRFcnJvcjogVmFsdWVMaW1pdEV4Y2VlZGVkRXJyb3IsXHJcbiAgICAgICAgTmVyZGFtZXJWYWx1ZUVycm9yOiBOZXJkYW1lclZhbHVlRXJyb3IsXHJcbiAgICAgICAgU29sdmVFcnJvcjogU29sdmVFcnJvcixcclxuICAgICAgICBJbmZpbml0ZUxvb3BFcnJvcjogSW5maW5pdGVMb29wRXJyb3IsXHJcbiAgICAgICAgVW5leHBlY3RlZFRva2VuRXJyb3I6IFVuZXhwZWN0ZWRUb2tlbkVycm9yXHJcbiAgICB9O1xyXG4vL01hdGgyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy9UaGlzIG9iamVjdCBob2xkcyBhZGRpdGlvbmFsIGZ1bmN0aW9ucyBmb3IgbmVyZGFtZXIuIFRoaW5rIG9mIGl0IGFzIGFuIGV4dGVuc2lvbiBvZiB0aGUgTWF0aCBvYmplY3QuXHJcbiAgICAvL0kgcmVhbGx5IGRvbid0IGxpa2UgdG91Y2hpbmcgb2JqZWN0cyB3aGljaCBhcmVuJ3QgbWluZSBoZW5jZSB0aGUgcmVhc29uIGZvciBNYXRoMi4gVGhlIG5hbWVzIG9mIHRoZVxyXG4gICAgLy9mdW5jdGlvbnMgd2l0aGluIGFyZSBwcmV0dHkgc2VsZi1leHBsYW5hdG9yeS5cclxuICAgIC8vTk9URTogRE8gTk9UIFVTRSBJTkxJTkUgQ09NTUVOVFMgV0lUSCBUSEUgTUFUSDIgT0JKRUNUISBUSElTIEJSRUFLIERVUklORyBDT01QSUxBVElPTiBPRiBCVUlMREZVTkNUSU9OLlxyXG4gICAgdmFyIE1hdGgyID0ge1xyXG4gICAgICAgIGNzYzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyBNYXRoLnNpbih4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlYzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyBNYXRoLmNvcyh4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvdDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyBNYXRoLnRhbih4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFjc2M6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFzaW4oMSAvIHgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXNlYzogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWNvcygxIC8geCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY290OiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKE1hdGguUEkgLyAyKSAtIE1hdGguYXRhbih4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2ppZ2d6c29uL2RmMGU5YWU4YjNiMDZmZjNkOGRjMmFhMDYyODUzYmQ4XHJcbiAgICAgICAgZXJmOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IDEgLyAoMSArIDAuNSAqIE1hdGguYWJzKHgpKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDEgLSB0ICogTWF0aC5leHAoLXggKiB4IC0gMS4yNjU1MTIyMyArXHJcbiAgICAgICAgICAgICAgICAgICAgdCAqICgxLjAwMDAyMzY4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKiAoMC4zNzQwOTE5NiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKiAoMC4wOTY3ODQxOCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAqICgtMC4xODYyODgwNiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICogKDAuMjc4ODY4MDcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICogKC0xLjEzNTIwMzk4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICogKDEuNDg4NTE1ODcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAqICgtMC44MjIxNTIyMyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKiAoMC4xNzA4NzI3NykpKSkpKSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiB4ID49IDAgPyByZXN1bHQgOiAtcmVzdWx0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlmZjogZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgdmFyIGggPSAwLjAwMTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkZXJpdmF0aXZlID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZih4ICsgaCkgLSBmKHggLSBoKSkgLyAoMiAqIGgpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRlcml2YXRpdmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZWRpYW46IGZ1bmN0aW9uICguLi52YWx1ZXMpIHtcclxuICAgICAgICAgICAgdmFsdWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGFsZiA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xyXG5cclxuICAgICAgICAgICAgaWYodmFsdWVzLmxlbmd0aCAlIDIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzW2hhbGZdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXNbaGFsZiAtIDFdICsgdmFsdWVzW2hhbGZdKSAvIDIuMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV2ZXJzZXMgY29udGludWVkIGZyYWN0aW9uIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmp9IGNvbnRkXHJcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmcm9tQ29udGludWVkOiBmdW5jdGlvbiAoY29udGQpIHtcclxuICAgICAgICAgICAgdmFyIGFyciA9IGNvbnRkLmZyYWN0aW9ucy5zbGljZSgpO1xyXG4gICAgICAgICAgICB2YXIgZSA9IDEgLyBhcnIucG9wKCk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gMSAvIChhcnIucG9wKCkgKyBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udGQuc2lnbiAqIChjb250ZC53aG9sZSArIGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIGNvbnRpbnVlZCBmcmFjdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gblxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBudW1iZXIgb2YgcGxhY2VzXHJcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb250aW51ZWRGcmFjdGlvbjogZnVuY3Rpb24gKG4sIHgpIHtcclxuICAgICAgICAgICAgeCA9IHggfHwgMjA7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKG4pOyAvKnN0b3JlIHRoZSBzaWduKi9cclxuICAgICAgICAgICAgdmFyIGFic24gPSBNYXRoLmFicyhuKTsgLypnZXQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBudW1iZXIqL1xyXG4gICAgICAgICAgICB2YXIgd2hvbGUgPSBNYXRoLmZsb29yKGFic24pOyAvKmdldCB0aGUgd2hvbGUqL1xyXG4gICAgICAgICAgICB2YXIgbmkgPSBhYnNuIC0gd2hvbGU7IC8qc3VidHJhY3QgdGhlIHdob2xlKi9cclxuICAgICAgICAgICAgdmFyIGMgPSAwOyAvKnRoZSBjb3VudGVyIHRvIGtlZXAgdHJhY2sgb2YgaXRlcmF0aW9ucyovXHJcbiAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBlcHNpbG9uID0gMWUtMTQ7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSAxZTc7XHJcbiAgICAgICAgICAgIHZhciBlLCB3O1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0ge1xyXG4gICAgICAgICAgICAgICAgd2hvbGU6IHdob2xlLFxyXG4gICAgICAgICAgICAgICAgc2lnbjogc2lnbixcclxuICAgICAgICAgICAgICAgIGZyYWN0aW9uczogW11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLypzdGFydCBjYWxjdWxhdGluZyovXHJcbiAgICAgICAgICAgIHdoaWxlKCFkb25lICYmIG5pICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvKmludmVydCBhbmQgZ2V0IHRoZSB3aG9sZSovXHJcbiAgICAgICAgICAgICAgICBlID0gMSAvIG5pO1xyXG4gICAgICAgICAgICAgICAgdyA9IE1hdGguZmxvb3IoZSk7XHJcbiAgICAgICAgICAgICAgICBpZih3ID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyp0aGlzIHNpZ25hbHMgdGhhdCB3ZSBtYXkgaGF2ZSBhbHJlYWR5IGdvbmUgdG9vIGZhciovXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBNYXRoMi5mcm9tQ29udGludWVkKHJldHZhbCkgLSBuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGQgPD0gTnVtYmVyLkVQU0lMT04pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyphZGQgdG8gcmVzdWx0Ki9cclxuICAgICAgICAgICAgICAgIHJldHZhbC5mcmFjdGlvbnMucHVzaCh3KTtcclxuICAgICAgICAgICAgICAgIC8qbW92ZSB0aGUgbmkgdG8gdGhlIGRlY2ltYWwqL1xyXG4gICAgICAgICAgICAgICAgbmkgPSBlIC0gdztcclxuICAgICAgICAgICAgICAgIC8qbmkgc2hvdWxkIGFsd2F5cyBiZSBhIGRlY2ltYWwuIElmIHdlIGhhdmUgYSB3aG9sZSBudW1iZXIgdGhlbiB3ZSdyZSBpbiB0aGUgcm91bmRpbmcgZXJyb3JzKi9cclxuICAgICAgICAgICAgICAgIGlmKG5pIDw9IGVwc2lsb24gfHwgYyA+PSB4IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKmNsZWFudXAgMS8obisxLzEpID0gMS8obisxKSBzbyBqdXN0IG1vdmUgdGhlIGxhc3QgZGlnaXQgb25lIG92ZXIgaWYgaXQncyBvbmUqL1xyXG4gICAgICAgICAgICB2YXIgaWR4ID0gcmV0dmFsLmZyYWN0aW9ucy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBpZihyZXR2YWwuZnJhY3Rpb25zW2lkeF0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbC5mcmFjdGlvbnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAvKmluY3JlYXNlIHRoZSBsYXN0IG9uZSBieSBvbmUqL1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsLmZyYWN0aW9uc1stLWlkeF0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYmlncG93OiBmdW5jdGlvbiAobiwgcCkge1xyXG4gICAgICAgICAgICBpZighKG4gaW5zdGFuY2VvZiBGcmFjKSlcclxuICAgICAgICAgICAgICAgIG4gPSBGcmFjLmNyZWF0ZShuKTtcclxuICAgICAgICAgICAgaWYoIShwIGluc3RhbmNlb2YgRnJhYykpXHJcbiAgICAgICAgICAgICAgICBwID0gRnJhYy5jcmVhdGUocCk7XHJcbiAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgRnJhYygwKTtcclxuICAgICAgICAgICAgaWYocC5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsLm51bSA9IG4ubnVtLnBvdyhwLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsLmRlbiA9IG4uZGVuLnBvdyhwLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IEZyYWMuY3JlYXRlKE1hdGgucG93KG4ubnVtLCBwLm51bSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbiA9IEZyYWMuY3JlYXRlKE1hdGgucG93KG4uZGVuLCBwLm51bSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHZhbC5udW0gPSBNYXRoMi5udGhyb290KG51bSwgcC5kZW4udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwuZGVuID0gTWF0aDIubnRocm9vdChkZW4sIHAuZGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1NDU0MTgzL2hvdy10by1tYWtlLWEtZnVuY3Rpb24tdGhhdC1jb21wdXRlcy10aGUtZmFjdG9yaWFsLWZvci1udW1iZXJzLXdpdGgtZGVjaW1hbHNcclxuICAgICAgICBnYW1tYTogZnVuY3Rpb24gKHopIHtcclxuICAgICAgICAgICAgdmFyIGcgPSA3O1xyXG4gICAgICAgICAgICB2YXIgQyA9IFtcclxuICAgICAgICAgICAgICAgIDAuOTk5OTk5OTk5OTk5ODA5OTMsXHJcbiAgICAgICAgICAgICAgICA2NzYuNTIwMzY4MTIxODg1MSxcclxuICAgICAgICAgICAgICAgIC0xMjU5LjEzOTIxNjcyMjQwMjgsXHJcbiAgICAgICAgICAgICAgICA3NzEuMzIzNDI4Nzc3NjUzMTMsXHJcbiAgICAgICAgICAgICAgICAtMTc2LjYxNTAyOTE2MjE0MDU5LFxyXG4gICAgICAgICAgICAgICAgMTIuNTA3MzQzMjc4Njg2OTA1LFxyXG4gICAgICAgICAgICAgICAgLTAuMTM4NTcxMDk1MjY1NzIwMTIsXHJcbiAgICAgICAgICAgICAgICA5Ljk4NDM2OTU3ODAxOTU3MTZlLTYsXHJcbiAgICAgICAgICAgICAgICAxLjUwNTYzMjczNTE0OTMxMTZlLTddXHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgaWYoeiA8IDAuNSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLlBJIC8gKE1hdGguc2luKE1hdGguUEkgKiB6KSAqIE1hdGgyLmdhbW1hKDEgLSB6KSk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeiAtPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB4ID0gQ1swXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBnICsgMjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHggKz0gQ1tpXSAvICh6ICsgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB6ICsgZyArIDAuNTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkpICogTWF0aC5wb3codCwgKHogKyAwLjUpKSAqIE1hdGguZXhwKC10KSAqIHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vZmFjdG9yaWFsXHJcbiAgICAgICAgYmlnZmFjdG9yaWFsOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IGJpZ0ludCgxKTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMjsgaSA8PSB4OyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSByZXR2YWwudGltZXMoaSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnJhYyhyZXR2YWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Mb2dhcml0aG0jQ2FsY3VsYXRpb25cclxuICAgICAgICBiaWdMb2c6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciBDQUNIRSA9IFtcIi0yNTM2MzE5NTQzMzMxMTg3MTg3NjI2Mjk0MDkxMDkyNjIyNzk5MjYyODg5MDg3NzU5MTg3MTI0NjY2MDExOTYwMzIvMzk5NzAwOTM1NzYwNTM2MjU5NjM5NTc0NzgxMzkwNDk4MjQwMzA5MDYzNTI5MjIyNjI2NDI5NjgwNjA3MDYzNzVcIiwgXCIwXCIsIFwiMjQ1NTMwOTAxNDU4Njk2MDcxNzI0MTI5MTg0ODMxMjQxODQ4NjQyODkxNzA4MTQxMjI1Nzk5MjM0MDQ2OTQ5ODY0Njk2NTMyNjE2MDg1Mjg2ODE1ODk5NDk2Mjk3NTA2Nzc0MDczNTY0NjM2MDE5OTg1MzQ5NDUwNTc1MTE2NjQ5NTE3OTk2NzgzMzYvMzU0MjI2MjEzOTE5NDU3NTc0MzE2NzYxNzg0MzU2MzAyMjkyODMyNTUyNTA3NzkyMTY0MjEwNTQxODgyMjg2NTkwNjE5NTQzMTc1MDE2OTk3MDcyMzY4NjQxODkzODM1OTE0NzgwMjQyNDU0OTUxMTA1NjExMjQ1OTcxMjQ5OTU5ODY5NzgzMDIzNzVcIiwgXCIzNjkwMTczMzUzNDA5MTcxNDA3MDYwNDQyNDAwOTAyNDMzNjg3Mjg2MTYyNzkyMzkyMjc5NDM4NzEwNDg3NTkxNDAyNzQ4NjIxMzE2OTk1NTAwNDMxNTA3MTMwNTk4ODkxOTYyMjM5MTc1MjcxNzI1NDcvMzM1ODk0MDUzOTMyNjEyNzI4OTY5OTc1MzM4NTQ5OTkzNzY0NTU0NDgxMTczNjYxMjE4NTg1ODc2NDc1ODM3NDA5OTIyNTM3NjIyMzg1MjMyNzc2NjU3NzkxNjA0MzQ1MTI1MjI3MDA1NDc2ODY0MDAwXCIsIFwiMjQ2MDY4NTMwMjU2MjY3Mzc5MDMxMjEzMDM5MzAxMDA0NjIyNDU1MDYzMjI2MDc5ODU3Nzk2MDMyMjA4MjAzMjMyMTEzOTU2MDc5MzE2OTkxMjYzOTA5MTg0Nzc1MDEzMjU4MDU1MTM4NDk2MTE5MzAwMDg0MjcyNjgxNzY2MDI0NjA0NjI5ODg5NzI5NTc1OTM0NTg3MjY3MzQ4OTcxMjk5NTQ3MjgxMDIxNDQvMTc3NTAwOTI0MTU5Nzc2Mzk3ODcxMzk1NjEzMzAzMjYxNzA5MzYzMjE0NTIxMzc2MzUzMjIzMTMxMjI5MzgyMDc2MTE3ODc0NDQzMTE3MzUyNTEzODkwNjYxMDY5Mzc3OTYwODU2Njk0NjAxNTE5NjMyODUwODY1NDI3NDU4NTk0NjE5NDMzNjk2MDYwMTg0NTAyMTMwMTQxNDgxNzU3MTY0MDAxNDY0ODQzNzVcIiwgXCIzOTkwNzM1Njg3ODE5NzY4MDY3MTU3NTk0MDkwNTIyODY2NDE3Mzg5MjY2MzYzMjg5ODM5Mjk0Mzk0NTA4MjQ1NTU2MTM3MDQ2NzY2MzcxOTE1NjQ2OTkxNjQzMDMwMTIyNDczODYwOTU5NDIxNDQ4MjU2MDM1MjI0MDE3NDA2ODA4MDg0NjY4NTgwNDQvMjQ3OTU4MzQ5NzQzNjIwMzAyMDIxNzMzMjQ5MDQ5NDExNjA0OTgyNzg2NzU1NDU0NTE0OTQ3Mzc5MzE3NjAwNjEzNDMzNjgwMjIyNTExODk3OTUwNjU4MDQ5MzI1Njg1MTQwMzQ2MTY5NzE4NDY1NzczOTI3ODcyMTc5ODc0OTcxOTA4ODQ4MTE2NjI1XCIsIFwiMTQ2ODEwMjk4OTQ5NTg0Njk0NDA4NDc0MTE0Njk0NzI5NTM3ODA0MTgwODcwMTI1NjkwOTAxNjIyNDMwOTg2NjE0MzI5NDU1NjU1MTQwNzQ3MDg2MTM1NDMxMTU5MzM1MTI3NjYxMjQ2Mzg1ODgxNjc5NjcxNDU2OTQ5OTAyMTM3NTg5OTc5Mzg0OTEzNjg1NTA4NTg0OTEzMzcwMjAyOTMzNzkxMDUwMjQ0ODE4OTA1NTM1NzE4MjU5NTQyNDk1OTM2MC84MTkzNjM4NzkzMDkyODYzMDM0OTcyMTc1MjczNzU0NjMxMjA0MDQ3MzkwOTgyNjAyMDAyNzk1MjA3ODg5NTA3Nzc0NTg5MDA0MzgzMDczNTY3MzgwODI5MzA1ODYwMzI0NjI2MDEyMTU4MDI2MzYzMjA5OTM2NDgwMDc5MDc3MjQ4OTk2MTEyOTY2OTM5OTcyMTY5Mzg5ODk4NTQ4NjEwNDMyOTg0OTQ5OTAyMTQ4MjUxNjM1MjMzODc2MDA5ODI3NzdcIiwgXCI1ODk2NzA0ODU1Mjc0NjYxNzY3ODI0NTc0MDkzNjA1MzQ0ODcxNzIyNzkwMjc4MzU0NDMxNDIyNzI5NjQwOTUwODIxMjM5MDMwNzg1NjQyOTQzMDMzMTUzNzkzMjQ1OTA2ODYzMjAzODIyMzY5Mjc2MjcxMDUwMTY0NjM0MjA2OTY1MDU2MjMzMDk3NDc5MTE3OTgwNzgyNjQxODM5NjY5LzMwMzAzMDY4NTA1NjkzMDkzNDQwMTM3MjY3NDUxMDAwNzA2MDEyNzc5ODIxMzI1NDM5MDU1MzczNjY1NjI2Mzg1NTMxOTgxNjcwMDcxNTkwNjc1NDQ3ODk1OTIwODk5NjA5MTEwNjUxODE2MDYyODM0Nzg4NDMzNTk4NTYxMjM5OTI3MDc1OTg2ODUwNTgyOTcwNjcxNzkzNDM4NzIwMDBcIiwgXCI3NjYzMTc3Mjk0MzUzNDk4NTcxMzg3MzQyNzI2MjgzMDMxNDYxNzkxMjU1NjkyODQ3NjU3MzM1ODU0ODI1Njg3MjE0MTUxNjk4OTUzODM3NDc2MTkwOTYxMTg3OTkyMjM0OTQ3OTQyMDAxNDc3MTQ5OTAxODE1NTQ0NzE5ODExMjE1NTUxNTQ1MzY3MTEyODgxNDQ4ODEzOTYzMzgxMDQ5MzI2NDM1MjI5NDU2MDA0MzkxMjA2NjI1MzAyNjA1OTE0MDY1MzAyNzMyNjU2NjgwMTM5ODc4NC8zNjg1MjA5MjkzMzM4ODk4ODY0OTM5NjA0Mjg4MzIxODUwOTYwNzUwMzIwNDIxMTE0ODQ5MzU0NTg5Mjg0OTU5NTQ5ODgyMjgxNzYyMzg0MjU3OTAyNjk0MjYyMTA5ODg1MTYzMTg0Mjc1NDM5NTIzMTU2MTY3OTY3MTQwMDE5NzA1NjM3NzM4MDA2MzIzMzc0MDIwMjM3MDY4NjE0NDY3MzU4NTk1NTU4MTQwMzA0Njg4NjA4Mzk0ODQ1MDEzNjI0NzEzNDMwODM4MTk0MDE2NTgwNDg3NVwiLCBcIjMxNTkwNzYwODM4MTYzOTk1MDk3NTQ5NDg2MTA5Mjk0NjcyNzgyNTc0NzM4ODgyODI5NDczMTEyODA2NTM1NzQ2MzQ4MDI1ODA5MTIyODA5NDA2ODY5NTQ3NjMzMTM4ODI4MjMzMjcwNzcxNzE2MjQwMTU3Mzc3MTk2MTczNzM5MzIzMTgxNTE1OTQzMjU4MzQ1MjQwMDAyNzU4NDc0NzU4NjYyOTkzODc5MTMwNDgvMTQzNzc1NzQ4NTY5NDE4ODgyMjc1ODMwNDQ2Nzc1NjQxOTg0NTg0MjAzNzYyMzE0ODQ2MTEwNzM2Mjk1Nzk5NDgxNjU1NDc4Mjk4OTI1MDU1NTM2MjUxNDM1NDY2MTk2MTQ4MjkzOTIyNjI3MjMwOTAyNjA5MjAwOTk2MjQxNDYxNjQxNzQxMjkzODA4NzQ5NDQ2NzI1NDE0NjAwMjIzMzAyODQxMTg2NTIzNDM3NVwiLCBcIjIyMjY2MDY3MjU5OTA3MzY0OTg0NTMxNjExNjAxODcwMjkxMzY4MjcyNjc0NTczNjUzNDAzOTY1NjMwNjI4OTk2Njg3MzcwOTk0MTM5ODg0ODMzODk3NzczNDY4MTQ5MTQ5NjY0ODI5OTIyMzAyNDg0NzgyNDIzNTE0MTY3NDA1Mzk3NjY1MDk4Mzg4NDAwNDUwMTQ5MDc4OTgyNDYyMzE4NzgxNzUwNjYxMDA1ODMzMDM3MjM1MTgzMzk0MjIxNDk2MTg2NTM5Nzc5NzEyNDI4MjY1ODM3OTI2NDE3NTgxOTUyLzk2NzAwMzAxNDQ2NjQ0Mjg1NjUxMjg5NjIzMDk2NTcxMDAxMzgwOTYwNDcwMjg3OTQ2ODkyNDkzMjA4NTkyNzYxOTczNDAzOTg5MjA3MjU1Njk0Mjg1MzIyOTMzNzM2NzY0MTUzNTk5NjU3NzM0NjAzNjQ0OTQ5OTgzMzQyNTk4OTMwNzkwMDMxMjUzNzM4NzIxMDg3NzA1MzQ3ODgyODM4NDI5MDczMTgwNzExNzAyODUwMzg3NzcwOTE1ODgyOTI1MzkxMDIyNjk2MTczNzYxODAzOTA5ODI5MTU1NjczNzVcIiwgXCIxNDYwNDY1NDU2NDk4OTIzOTk1ODU2OTMzMTQ0MzM4NTM2OTUyMjg1MDk3NTE4NTM1ODY0NzEzMjc3MDAyMjcxNjQzMzI4MDA3MjI3MTAwNzc2NzExMTAzNjg3NzgwMzMyODc2ODkxMDI3NDQwMDUxNTU5MDE1MTkzNDY3NjgxOTI2MjA4NTIxMTgyODAyODYzODQxNzMyOTU1ODIyOTEyMzk4OTU1NjM3NjEwODQ1NDQ5NzgxMzA1NS82MDkwNjE0MDE5MTYyNTE2NjkzMDEzOTczNDA5NjUwNjEzMjA4MjI3ODg5MDc4ODc4NzgxMDM5MTA1MDQ3MDE1NzUyNDkzNTE5MTQ5MzE0MjI3NzIxOTg0NDM2OTczMzc0MDMyMjc5NDIxMzQ0ODE4MzI5Mjg1MjA3MTI0MjgwMjk3NjExMjUzODYxMTczODM1MjM4Mzc5ODMxMDA0MDEwNzQ4Mzc5ODc0MzkzMjkyMjMxNjcxODA4XCIsIFwiMTkwMTI0MTg4NTQwNzY5NjAzMTIxNzI5Mjg3Nzg2MjkyNTIyMDkxNzY2MDA0NzEyNzI2MTAyNjgyNzg2OTAyNzE1OTk5MzIzOTU2NzkzMzUzNDA1MjY2MzMzNTQ5ODI4MTQzOTIzOTc1MzAxODUwNzE4MjAxNjE1MzY1NzQwOTc3Nzc0OTc5MjIyODUzODM4MDM3OTcwMzQxMTI5ODQxMTYyMzQ2OTI5Mjg5MTQ3Njk2OTg5NDA4NDgzODg3NjAwMTU0NTgxODE0MTU0Mzg5MDI3MzI1Njk4NTc2ODY5MDg0NzU4NzcxMTI3MDkzMDY4OC83NjUxMTYwMTk3Nzg4Mzg4Mzk4MTI2NTU0MDIxMDM1MTI2ODU2OTU3NjkxNjEyMTIzNjA1NTMwOTk3MzI2ODk3OTU1Nzg5MDQ3NjIwOTEyMTY5OTg3OTA1ODk5MjYwNTc4MTk4Mzg1Mzc4MDU4NTY1NzkxMDk5MTAxOTg1NTMzMzAwNzU5MjQ4NTc0MTkzOTUxNjA3NTU2NDIzNzE1NTAxMTMzNDc0NjUzMDAyMDg0MjIxMjY5NDUyNjU4ODcwNjU0MzQxMTY3ODE2Nzg3MDI3NDE2NTcyNzUxODE2OTQ4NTE2NzAzMjU0Njk0MzQ2MjVcIiwgXCIxMzk0NTk4MDY3ODY2MDQ3NTE3OTM3Mzc5MjYxNDY4NDA2MjM2MDcwMTAyMDgyMTYyODk1NDMwMzYwMjYyMDYyMDg5NjIwNTk1OTM5MDA3NDU4ODYyMDIyMTQ3ODg3NDc0NTMyNzkxNzkyODMzNDQzNTA0Nzg3MzQyNzU5NzM4Nzg5MzI1Mzg0MzAxOTQzNjMzNTU3OTU4MjM1ODEzMTUzMjkzMTEyMjA3MDE2NDAyMzU2NTMyODg5NzU1Njk4MTIxNjE0MzYvNTQzNzEzNjg1MzQ0MTI1MTcwNTMwNTYxMDEzNTM2MTg2OTQ3MTgyMTU3MTE3NjcyNjYzNzY1NzMxMzg3NzI5NjgyNTczMDM1Nzg0Njc5MjY0NTAyMTIyOTMyMzMzMzI0MDEwNjc2NzMyNzA4NTM5NTMzOTkyNjk4NTIzNzY1OTI4NTU5OTI3MjQ5MzQ5NDExNzMzNDYyNjAxMjkyNTc3NTQ0MTY0MTI0NzYyMDI1MjY5Nzg0NDM2ODE1ODQ2MzMxMTYzNzVcIiwgXCIxMDQ1NjY5MDkxMTI0NDkzMDcwNzA5NjgzMjQxMTkwMDIyOTcwOTA4NjQwNTAxMTcxMzc4Nzc2NjA0MTI2NzcxMTQ0MDA4MzI0MzU4MjMzODE5NTYwNjQ5MDIxOTQwMTQ1MTY2MjU0NjU5MDI4NTI0MzE5NTE3MjQ0NzExNjQ1MTYyMTMyNTEzNDE2MjM4OTU4MTcwODE5MzQ3MzYxMTg1OTQ0OTQ1NjgwMjY5NDQyODQ1ODI5MzkwMTEyMDYyMTAxMjU1NTAwODM2MDcyMDgyODE3ODIwOTUwNDQ4NDYzMzE0MDM0Njc3MzUzNzIzMjU2OTY5MzQ0LzM5NjIyODI1OTAwNDQ0NjIzNDkyMTMxMDkzNjkxNTkzMTYxMTczNjgxNTU5ODUzNTk2MzUwNDY2MDA3NjMxNTIyODc5ODk4OTkzMjk1OTQ1OTQwNjcwMjA5MTE4MDA2MDQyOTA4MDM0NTE0NjczNTE3MzU5MTc0OTQ0ODUwOTgxMDI3MDc1OTUzMTk3NzI3ODY0MjEzNTU5MTY3MjE4OTAwMjAwNjI3MjMyNjEzMTg4NTMxNTc0MzE4MTI4OTk3MDg4NTMzNzU3NDc4MDg5NzUyOTM0NzM1NjU2NzA4NjUzNTUwNTk1MDQ1MDg5NzIxNjc5Njg3NVwiLCBcIjk5MTI5MTkyMzg5MTU0MzczMDIwMDYyNjQ0Nzc5MzEwMzE2MTE0NDc0NjcwNzAxMDM5NzMxMDY1Njc1Mzg1Mjg5NTE4Nzg3OTc5MzI1NTk5MzU4NjA3Mzg3NDUzNzQ0Mzc1MjI4MTkxMjQzNDc1MTA1OTA4MDAzNzA0NzE5MTA0OTIzMzg1ODQyODQwOTI1MzQyNjQ2MDg4MDEyMjEyMzUwMjkwNjI4ODE5NjQxMDE5OTY3NjIwMTEyOTY5OTY4NTE4OTM0NTU4Mjg5NDY1MjEvMzY2MDUzNzQ3MjY2ODI2NDE1MTIxODk2MTYzNDY4OTY2NTIxMDkzMzkzNjI0OTk4NjI4NTI5MDU1MzM1NzI1NDIyNDM2MDQxNzM4NjUxNTMxMTQ5MzMxMDE5OTMxOTUyMzY4NzE3MTc1NzY1MzIxNjk5NDc0MTE1MDM3NzUwODIzNDMxNzAyNTE1ODMwMjA1Nzc1ODE5NjQyOTYyMzcyMzA3MjA4NDE1NzkyODIyNDc5ODMyMjg2MTczMjg4MDAzNDg0NzI0Mzg5NDc4NDAwMFwiLCBcIjkyNjM3MTAxNzU0MzMxODE3NDY1NzUxODYzNjkzMTgyNDYwMDI5MTk4OTU2NDk2MjIxMjc0MTA4MjQwNDEzNzAwNzkyMjUyMDAyODI0MDMzNjgzMTkzNzA3NDMzNjMzMDMxNjQzMTMzOTU3MjM5MDQ1MTA1MzkwNTAxNTcwMzI2ODQ3MTA0NjgzNjQwNjcyMDQ4NzY0MzQ1NDY4NDg2MzQ4NDIzMzM0MzY5NTcyNDUyNzUyMTc1ODMyNDg4MDU5OTMxNDIyMjc2MzAyOTc5MjQxMTkzMzA1NTMzMDg0NjY2NjI0ODg2ODM2MjQ3ODMzMDcwMjMwMTQ5MDkzNjA2NDAvMzM0MTE3NzE4MjY5NzUxNzI0ODU1MjQyODgzNzY2MTkxOTI5OTcyNTAzMTAzNTg0OTg2NTYzMjUxMTg4MjY4ODc4NjIyNjg4ODEzNzYzNDE2ODAyNDk3NjAzMzY1Mjc1MzY4OTIxMDcwMDIxODE2MzYyMTczOTA3ODUzNDM1MzU3ODUxMDM2NDMwMTQ4MTA5MzczMDA1NDcyNTA3ODEzODY1ODgwNTAyNTAxNDYxNTY1MTA0MzMxMzk5MDY4NDM0NzYzMjE2NjAzMDM1OTA4Njg4NTU2MTEwNDAzNDUxMDk5MDgyNjY1NTI4OTI4ODMxOTg0MDU5NTc1MzAwMjc3MVwiLCBcIjUxMTYwODIyMzA3MTM2MjIxNzE4MzIzMjc1NDI0MzkwNTI3Mjc0NjUxMTQzMjI0Nzk1NzA2MDM5MDU0OTk0OTYyMjEyMjQ2NTM5ODM5NjA1OTg5NDYwMzMwODEyMTI5MDkwNjY5MTcxMzc1NDYwNjU1NDI5NTM4NjU2MTI3MTg4MzY5MTQzOTMyNzU2ODEzMTg2Njc2Njc1MjE3MjY3ODU2MzM2MzgxODkzNzM5OTgxOTEwOTA1MDEyMDE0Mjc5MDY2MTgwNzU4ODk3NDQ0ODkxOTAyMDk1ODQvMTgwNTc1MjU1MzczNjA2MDQ0MzgyMDQwNjEwMTI3NzcwNjk3MDc2NzY1NzAwNjM0NjI3NjE4Mzc0ODc0OTYzMDE3OTQ0MjMxODA2MzU2ODI4NjM3MjMyMDE4ODQzMzg0MzcyOTk2MDI5NDk2NTM2NjM0NjUyMjMwMzg5ODYwOTY1NTc2MjQ5MTYyMzA5ODQ1MzI2OTkxNjE2MzYyMTA4OTAwNTcxMTgyMzQ4ODc0OTI5NzQxODExMzQ3NDA1NjY3NjEwOTU4MTExMDcxNTA2ODEyNDQzODg3NVwiLCBcIjI0NjU2OTEyNTYxOTcxMzI4MjQzNDQ0ODU2Njk3MDM1MjIzMTg0NTQxNDMxNzAxODM3OTE2MDgyNDE3NjYzODM1MTU3NDkzODk5MzUzNTQ2NDc2Mzg5MDk2MjMzNjg4Mjc2MDg4MjM5ODQ3OTcwMjIzNzU2NDM4NDI5MTI5MDQ1OTk2MTAzNjA2ODkxNjg1NzI2NTQ5OTYzMzA2MTY2MDU2MjUzMjAxMTI0ODUwMTQ3NjExNDQwMTYyOTgzOTc0MjA1ODM4OTE5NTcyNTM5MzcwMjAwMDAxMTg2MDc5OTc5Mzc3ODI5NTYwNjk4ODA1NzMwMzIyNTQ5MzgxNDAwNTc4OTUzMzU3MDQzMi84NTMwNzA2MzAyMDgzNjMwNTc5NzE3ODI3MzAyOTM1MzYyMzA2MDg2MDAwOTE1MjExNDM2MTQ1MzQzNDAzMjQzNDY5OTYzNjA3ODExNTExNDQxMjU4ODcxOTQzMjI3NzQ0MTA1NTA0OTEzMjU1OTc4MjIwMzk4ODM4Nzc5NDcxMTU4NTM2ODI5NjgxNzIyMjU2NTQzNDk1MTI1Njc4ODg2NzI0NDY4NzA4MTIzMzYzMjY1MDk1Mzg1MDM4MzIyMDg2NDM5NDI2MTc2Mzg0NDE5NDk0ODM4OTg2MTE0NzYyMjk0NDY1MTU0NjkxMjM5NDU5MzE2NDQwNjkyNjQ4OTg2MjAzNjM0MzM3NVwiLCBcIjEzMzY3MjAyNjMwMzQ1MjkxMTA0NjE2Mzk5ODQ4MDg2MDkxNzExOTI5MDU3NjY1ODMzMDkwOTc4NTcwNzYwNDg4Njg4MTE1NTYwNjcyNTgyMjY4NTA4ODkyOTIzNjI2NjU4MzQxNjcwODY2ODUwMjc2MDkwNzY3NzAxOTU5ODAwMjE3NTEyMjQ1MzE3MDU3NDcyOTAyODQ1MjcyMTQ3NjQ2NDcyODU2NjE5MTQ2NDg5NzkyODY5NjYzMDk3OTg2MzE1NDY2MTcwNDM3NDIwNjE3MTQ2OTAxNDIyNTE0My80NTM5ODEzMDk3NTI3MDc4NTA0NTQ4MjU2Nzc2Mjg3MTQwNTA3MjE0MDU0ODk5ODEyNTQ3MTAyNTQ1MTY2NjUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCBcIjYwNDE2OTM5NTMzNjAwMDI4MDAyMjQwOTE2NzMzMzY1NjI1MDg5MTMxOTk5OTU5ODc0NzkyNjQ2MDUyMTYyNTIyMjA1Nzk3NDAxMzQ2MDE0MzU3NzAwODU5MjA4NjkzNzY2NDExODA3NjM0MTk5MDc0NDI3MjE3MDU4ODcxNjk4ODQyMzA2NDM3OTUxMjY1Njg4MTUxMjM2NDc2MDMwNDc3Mzk3OTkzMDI1NjIwOTU1NDI0NTkzNDQ4MTE0Mjk4ODIwNTMwODY1NTA5MDA4MDM3Njg5NjQ2MTIxOTM5NDE0MjQxMjg2NDk5NzY3MDQ3MjcxODM3OTc0OTU3NTkwODI3NDExNjY5MzgzNTE4NzIvMjAxNjc2Njk5MjEyMjM5NTY2NzgyODU1MzI3Nzk5NzQ3ODU3MDUwMzQ3NTYyNjEwNzI4NjM0MzQ5NzkxNzcwNTQ0NjEzMjAxNzEyNTA3OTYxMjc1NjAzNTI1NDc1MDgyMjg2MDgxNTUxNTg5OTU1Nzg1NTE2NjgyNDUyMzg1MTc3OTE1NjMzNjIzNTI5NDkxNDc3NzMwNzgwMjI1NjQzOTY0NTUyNTgzNTIyMzY5MTc1MTkzMTg2NjE4ODk1NzMyNDc5MjI3NjE0OTU0OTA3NjUwMDc4NDE5MTc5MTM4MDgwMzUwMDE1Njc3NjA4ODY4MzkwMDM0NjA2NTgzMDA2NjM3MDM3MDA4MzMwOTg3NVwiLCBcIjcwNTg2ODM5MTU5NzI0NDU4Mjc2NDc0OTIyOTM1NjMzMTQ0MTk3ODgyMDAyNDc5NjA2Njg3MDU1MTExMDQ4NjYyNTcyOTgyNjExMTE1ODIzNjY4NjY5NjMyNjA1ODc3ODg3NDIwMTYzOTAwNjIzNDQ0OTU1NzU5MjM1MzI0NzU0Mjk5NTg3MTQ5MTA3ODMwODE4NzI2MTMwNDkzMDA0MjAxOTY0MDgzMDYyOTUyNjAyMzk3MjY5MzEwNzE5Mzg5NzAwOTE2ODk1NTY3NDI0MDY1OTAyNjI0NzA5NDY1NzY3OTA2MC8yMzE4NDg2NDI3NDg0NzQzMzkyNzc1MzIwMDAzMzYzMzg2MzI5MTA5OTA4MjM1NjIzODE0Njk0NDE3MTY5MjIwMDYxMDc0MzM0MDQ1MjMzMTYyNTI2MTg0OTAyNjU5MjcyNjU3MzQ2NzA1MzkzODQ0ODU2OTkxMzIwODAwNjIyMTUxOTY0NjIxNzg5MzM5NjM5NTc2Nzk4ODIzNDIwODM4OTM0MTc1NDU4NTgwNzQzNzg3NTQwODk3MTk1NDc5MjA5MDE5MTc1MTYwMTYzNDYyMTEzMDEwNTQyMDYzODM2NDMzODNcIiwgXCIxMDE4MzIxNjA2MDQxNTc5NDMwOTM5NDQ2NzM1NDE2NTEwMTM5MDcyNzgxODg1NzE1MzMwNzUzMTE2NzMyNDk5MjM5NDg4NTYwMzQ2MzM0NDY2MTc2MzAwNTQ3NjE2ODEwMDYwNjI5MTA5ODAzNzE5MDA3ODI3ODEyMjY5NzkzOTE3NjU4MTgzMjUwNjUwMzE4ODkzMzQ1NjM5ODEyMzU4OTQzNjkwMzY0Mzk5Mjk2NTEyNjA1ODczMzU1NDQwNTY5NzU3MTUwNzY1OTg3Mzk5NzcwNjUzOTA2NzgyMjE5OTk5MTg4OTkwMDM4ODE3Nzg0NDkwOTIwMzg3NTA3MTI5Njk0Mzc1MTkyOTU4Nzg0OTEwMTgxMTIvMzI5NDQyNzc5MTA1NzE2NjYwMDI0NDkwODY0OTI1MTU0NjQ1NDE1NTAxMzgwMDQwMDIxNDE1NzE2NzA2NTc2NDM3NzA3MTM3ODMzMjkwNjM1NDg3OTAyMDIxMjA4MDUzNDE5ODk2MDg4Nzc3Mzk4MTE3ODc5Mzc3ODIyNDA4MDI5NjM5NjI1MjAyNjE4NDQxMTQzMjc0MzIxNjA3ODgxOTMzMTQ4NzQ5MTM2ODczODcyNjk0MDgzODc0MTc4MDYxNzYyMDI5NzkyNDQ2Mzc5MTU4MTI5MDU0MjY1NjUyNjMxOTY5NTQyMDM0ODc5MzQyMjU1ODk2MjI4NjQxNDU5NjAwNzk3MzY2MzM0MzQ4MzE5OTY2MjVcIiwgXCIxMDY1NTcwMzExOTI3MTQ2ODkxMzU5NzY0MDQ3OTQ5MDU5NDE4MDk2NDcwMDQ0ODM0MDc3ODE2ODcxNTk1NjcxMjEzMDYzNjk1ODM3MzI3MDIwMjQ4NDI3NjQwMjcxODU2NjMxNDg4MTExOTU1OTA5MDg0MjQ0OTYxMDk1Nzk3NDExMjIzMDMwNjM0MzQ4NjA5MTkxMDIxNzM0MDY2NTE0NjYwMjU5ODU2ODk5MTUyMDU2Mzk4NzQ5MDY4Njk5Njc0NjU1ODg1ODM2NjAwMjMwMTk4MjQ0MzAyOTQzMDI5MDY3OTM4NTU1MS8zMzk4NDEyNjg3MzY2NjM4NTQxMjMzMzY1MTM3MDg0NzIyMzY4MjAwMzExMTE3ODkxMTkyMzQ4NTMyMTU2NjQ1Mzc0Nzg2MTA0MTQyMDA5Njk1Nzk2NDA5MTA3MzgwMzQ1Nzk1OTk4NDAwODUwODM4NzA2NjYxODUxMTc2ODg1MTgzMTQ0OTI4NzAxNjA4NjU0NTE0ODEyMjYxNjk3NTk4MzgwMDcwNzQ2NTIwMTk3MTcxNTc2NjEwNTcyOTIxMDA3MDY5MTA0MzAwNjk1NTkyNzUxNTQzNTYzNDcyNDU2Mzg0NTEyMDAwXCIsIFwiMTkwMzAzOTMzMjg3Njc2MzgzNzQxOTkyMDI0MDU0MzczODc5OTUzMTEzMTc3NTAyODk3MTMyMzQzOTg3MDg2ODczMDMyMTIyMTYxNTUxNTAwODM5NDMyNzcyMzUwODY3MDk3NTYyMzQ5ODU4ODI5MTI5ODA2NDMyMDc4Njk3MDYyNjIzMjY2ODk1NjM3MjAwNDAwNDg5Nzg3MjgxMDIzMDE3ODUyNjEwMTE4NDYxMTI0MjUxMTE5MzQxNTc5NjYzODY5NDM3MDUwMzEwMDIxOTcxMDg2NDU0MzE2ODk1MjY4MjYxNzgwMTgzMzMxODQ5MzQzNjE3NDM4NzU2ODA2NzgxMTkzODQ5MDk1MzQ5NTgxOTQzODEwODY4NjMzNi81OTg4MDY1MzQzNjc1MDMzMzgzMDcyODcyNDYzMjA5NjMyODA1NTgxMzQ5MzczODIxNDk0MDUzMDU0NjY3MDk3ODcxNzk0MjkzMTc5MTQ4MDM2MTc1Mjc4Mjc4NjI0NDE2MTUzNTAzOTY4NjQzNTk5NzYyNzMyMTIyNzI1ODY4OTIwNzQ3OTk2NTEwODgzMTc1NDQxMDE3NTUzNjE0MzkyOTQ2ODczMjMyMzMwODY2OTYxODI2ODc2NjQ2Mzc0MjI3OTY5OTU3ODk5NjcwNzUyNzE0NDg1NjA4NzA2ODEyMTA1ODA2OTE1NzQ5MjQ1NDQ4OTY2NTYxNzU1NjMyNjUzNzg1MTQxODgzNDE3OTYzOTgxNjI4NDE3OTY4NzVcIiwgXCI1MjU1NzM5MTU1NjM4MjYxMzA5NjM1MjU4MjYxOTE0MTE5NDkyNjI4NDY5MTY3NTA0MzIwMTk1OTYwMjgzNDQ4MDgyOTg0NzEyOTMzNzg5MTc1MDg1NDkxNjQ5OTMzNjgzOTI4MzQwMjM3ODI0ODA3MDI4OTM2NDM0ODY2OTk3ODc4NzAwNTk5NDY0Mjk4MTAwNzAyMjIxMjYyNjAyMDAwMjYzMzI4NzQ0ODAyMzkwOTAzNzAwODgxMjM4MzM0OTE0OTk0MDA5OTExODE2NTk0NDU5MTQzNTI1MDAyNDc1OTY3NTcwMDUxNDI2MjMzNjgvMTYzMjc4NzI3MzI0OTM3Mzg5MDk1ODIyNDA1MDM0NDM1Njg3Nzc2MzQ1Nzk5ODM1NDQyMDIyNzk1NTMzNzgzODg5MzU2MzQ0NzU1MjI1ODE1MjY3ODE5NTA4NjA4NTU5MDc2MTkxMjkyOTAwMzY3OTgyNDkwODI3Mzk2ODY5NDA1NTM2NDg0ODQ2MTE1OTU1NTgxMDQzMDkxMjI5MjAyMDUyNDA3NDgzNzc2NTg3Njg3OTY3MTI1ODg1NjY1NDkzNjgxNzA3NDYxMzQ1ODk1OTk5NTQyMzgxNDc2MTY0MTU3MDU4MzkzOTcxNDMxMzc1XCIsIFwiOTI2MzgxNTY1NzE3Nzg1ODc4NzI3MzQ5NDcwNTMzODUxNjg2MTA0NTc3MTY3NDgzODA1NzMyOTE3MDIzOTYxMDk1MzAzOTk4NzAyMzQyOTczNjc1MjA3OTU0NDAxNDc4MDcwNzQwODY2NjYyODQ3NTk5NzI5MTEyNDgwNTU2Mjk5ODIyNzI5NjY3NzYxNjIwNDE0MDYwNTM1NjI1NzcxMjAyMjM4NDM2ODQ5MjU3NTM4MTM1NTU2Mzk3NjMzMDM0Nzc5MjUwNDYwNTY2NjYzMTUxMjM0MzQ0NzU2MDMwMTQxNzMyNTE1NDAwMzQ4MTA0MDI1MDE0ODU2MTgzOTg2MTgzNzc3ODU5NzM0NjYyMzYzMDA0NjYyMzc1MTA5NDQwMC8yODQzMzIxNzA5OTQ4NDk5OTU1MDk1NTkwODYyMjU2NzQ0NTMyMjI3Njk4MDAxNDA4OTI5MTQyNTQ4MDU3NzkyMjE3NzkwNTMyNjI0MDAzMTkwNDQ3MzYzNTc4MDQ4NTYyNDQ4MTY4NzIxNTM5MTc3NDU4MDY1NDgyMTcwMTQ4NDgyMzc1NTg1ODY3MjMwMTIzODczMTc4MTAwMTE3MDk0NTMzMTQzMDUyODg2NTI3NDUyNjY1NDgwNjE0NjIwMTIzNzY0MDM2OTc0MTgwOTE3MjA3NDIxNDgyNDMxOTgzNDA3NzQyMTU0NjM0MzkxMjY0NjE5NjE1Mjg5MjI1NzQ3NjY0NTMyMzMyNDY5NzgzMzAxNzA0NjQzMjU0MDc2NjAxXCIsIFwiNDA3OTU5MzM5NzI2MTE0NDU1NjIyMTgwMTg3NzU4NzUzMDA3MzQ5MjA5MDE2Mzk2MjQ4NzYzMDc1NzU5MjU3MzU3OTI1NjM2MDM5NzUyNDc0MjA3Njg1NjgyMjE4NDIyNzIxODI3ODU3OTk0NzY4MDIzMzk5NjI1MDYwMjA2NzA4Mzc4NDMzOTYwOTkzOTQ2MTU2ODAzOTQ4NjU1MDk4NjY3MTU2OTM3OTQ5MTc0NDAwODczNzQ4NTU3MjQ4ODAxODc0NzM1ODM0OTU3Nzk1MDQwMTM5NDAxNTYwNDk0MDg3NDc2OTY3NTQ4MDYwMjA4MjQzODY3LzEyMzc4MDIxODc1MTgxMjE1Njc0NDQwMTEyMTY5MDk5NjMwNTk3ODEzNDY5NDY3ODkzNDQ0NzIzNzQwMjUxMTExNjczMTQ1OTIxNDQ5ODc4NDQ5NzQzNjM1ODE2MDk2NDE5ODMzNjg3NDA0MzcwMjY1Mjc0NjgzNDc2MzEzMTQ0NDAzMDE4NTE1MTE0Mzk4NzMzMTQwNDYwNDA4Nzc3ODUxNDg2Mzk3MzYzMzk0MTQwMTgyNjMzNDc1MDI2ODQxNjAxNTIyNDkwNjA1NjU3NjY0MTAxODk2Mjg2MzY0NTA0Mzk3NjUzNzY2NDIyNzYzOTI5NjAwMFwiLCBcIjI1NDc2NzYzOTE1OTg5MTczNzk1MTY2OTg0Mzk5NzE5MTQ2OTUyMzA1NDg3ODI5MDQ0Nzk3Nzg2MDU2OTEzMzgzNjQ0NTM2MDY1Mzc2NDMwODg4NTcxMTYxNDE5MzkxNzA4OTkxMzUwMjY1NTIwMTY5NjkzMjAwNjE5MDA5MjY5NTQwMDg1MjI3ODExNjIxODY5OTU4NTY1ODA5NTUwOTA1NDg0NzE0NDgyNzY3MzY4NzgzMDA3MTc4Njk2MjU2NTE4OTM3NDEzMTY1MzAxMDk0Mzg4NzYwNjc0MTk4MjYyMTc5MDE2NTcwMTc1MDYxNTc5OTc1ODg5NDQyMzM2Nzc0NjczNTcyMjAzMTYwODQ1ODMzODM2MjM2MDI4NjUzNzkzMjUxODQvNzY0NTYyMDM0NzU3MzkyMjk4Nzg2NDIwMzc0NjcyMjY2NDk4ODE1MDIxMjI5NTE5ODUzNzI0ODUwODc0NTc2NDE5ODg1MzgwODMwNzUyOTMxNzAxODMxMjU2OTU5MTU5ODAwNzY0NjcyNjA1MDA0ODgwMzg5MzU4NjAxNjU4MzQzMjAzNTEzMTc3MDg0Mzg5NDkwMjg2NzIzMjQwMTg1MTQ2NTcwOTI1OTU3Mjg2MDgzMDI1Njc2ODc1MTk3MDI5NjYyMDM4MjEzMjE2NTQxMzUyODc1NTcwMTAxMzYzNjY4OTE3NzY2MjI1NzA5NTY5MzU2ODYxMjc1NDM0NDcwNTY4NzY3MDc3ODQ0Njc1NTkzMTc2MTc4NjExMDIxMTM1NTczNjI1XCIsIFwiMTg2NTQ1MzUyMjg2NDYzNzMwNTU5OTMzMzQ2NTY1MzExNTM1NTk4MjQzNjY2MDIyMjMyMDM3MDU0NzM1ODA3Mjg5NTAxMTczNDQ0MTAzNjkyMzA5NzM1NzY4NzAzODk4MzMwNDMwMTM1Mzk5MDMzNTI5MzU1MzYwMzkxNjU4NzI4OTg3Mzc5Mzg1NzMyMDk4OTYwNjA5NzQ0MzEzODc4NDc3OTY3OTcxNTU3MjA0MjA3MDQzODAyOTM1NzgyODc4NzQ1MjcxODU5NDY4MjQ4NzA0MDEyNjE4MjU0MjAzMTAxNzY3ODQxNTE3NTY5NDQzNTU1MTQzMjUyLzU1Mzk5MTc5NjQxNjIxNjU2MjMzNTg5ODIwOTk2MTQzODI1OTU5MzY1Nzg5MDkzMjYyOTc4OTg4Mjg5NDQ1NjI1MTUzMDk5NTkyNDYzMzcyNTc5NDk2MjQ1NDQyMzM4NjUzMDUzNjYyMTM0Njk5NjQ2NDEzODE3ODY2NzcwMjE4NTc0Nzk1Mzc4NjQ0NDE1MDE5OTQ0MzA0ODY4Mjg5MTE5NDQzNzc0OTMyNzgyMjM1NjM4NzM3ODg4NDY5NzQ2NzQ1NjIxMzgyMTM5MjYzODU2NjAzMjM5NTg4NTk0MDc4NjY4MzkzMTk0Njc1NDQ1NTU2NjQwNjI1XCIsIFwiNjY0ODg0NDQwMTY0Nzg2NDczMzQ0ODU0OTU1MzA5MDQ5MTEzMjY5MzU3MzE0OTU3OTg1MjY1NzI4MTA2OTI0MjM4NTg4NzA1NTMzNDM3MTY5Nzk2NTUxOTEyMjAyOTMxMTg1NzQ2MTkzMTU1ODAxOTA1ODQxNzEyNTAzNDA3MjU4MTY2MTM1MDc1OTY2MjgwNDM1NzgwODEyNzE0MjUyNjcwMzYyMjAyMDkxNjYzMjg3MDk1NDIzNzEyNTk2NDYyNjkwNzUzNDY4NjgyNjM0MjYxMDI5MzkyNzk0MTczNjM2OTQzOTc4NDA0MDAyODA0NDEzMDA5NTkwMDA1OTg0NzM2NjEyNDIxMTcyOTc5MTAxOTcyNTU2NzcyMDA1NTk0NDk5Nzc5ODYwNjA4LzE5NTQ4NTUxNzc3NjQwNzE0NTI4NjQyNDQ2MDQ0ODk5NTQ2MDc1NDY3NDAzOTU2MDY1MTc5MTE5MjY0NzU4NjU1MDYxNTg3ODk4ODM4MDE1MzczMDYwMjY2NTc5NTY0NzE4Nzg4NDU0MzM2MTIxODk2MjEyNTE3MjgwODc5MjE3NjM4Mjk1NjU5OTI1NjE4ODcwNjYzNjcyNzQxODU3MjU0MTI1NDQ4MDc5ODMwMzU2Njg0MDAxMDIxNzcyOTM4NjkwNTA0MTIxNzc5MzYxNDIxNDUxODM2Mzg1OTA1ODM0ODI0OTk2MTc5MDEwNDYxODkxMDg3NzgxMzA2NzUxMDc1ODIyNTMwMjg4NDgxNTQxMDM0NzIzODIwMDEzMzY5Mzc1NjQ5MzcwMzg3NVwiLCBcIjI2MTQ5NTcyODM5MzQzMTQ5MDQzMTU0NzEzMzg0ODU0NTExNjYwNTM2NjQ0OTQzODMyNDE5MjkzODU0MjQ1OTkzODkzMDkyMTUwNzMyNjcwNTI4NjA0NjQwMDk5ODEwNjM0ODM0NDAyMDExOTM3NzE2MDc1MjA1NzIwNzcyMzE4ODk2OTk4NTg0ODI1ODIzNjM4NDUyNzU0NTIyODA2MDYyNzY5NDk2NTM5NzA5OTI3MTkzMzI0NzIzNzAzNTExNzA3MzI4OTk2NzYzMTY5NjcyNDQ1MDQ1MzQxNTQ2MTYwMzYzNzE5NzkwMzEzOTk0MjU4NDYxMDA1Mjc2ODUvNzYxNDkzNjY0NDMyNzQ5MDg5MzEyNjY1NDgwNzczNDk2MjkwNjU4MDI5OTcxMDI3Njg2NTQzNDA0ODg1NDA3NjQ0MDYyNDg1NzQ2MDcyNzE5NTU5Mjg4MjMxMzYyMDYwMTQ5NjI2MjM3OTM5MDI5NjQxMDk4MzI4Mjc4NjUwOTM5NjY1NjY1OTY5MDExNTI5MjkzODY5NTYyNjM2NjU2NjUwOTk5NzU5NzI0NzA0MjcyNzQzMjM1MjEwODY3Njc2ODczNTI1MTQ3ODIwNzQ5NTYwMTU1Mjk0MDIyNDg4OTk0NDI2NzI5OTM5ODk0NzUzMjkzOTAwOTcyMDMyXCIsIFwiMTI0ODQzMzgwNTE4NDkzNzQ2NzYxMTQwMzY3MjgzMDA3NTA3ODU0MzY0NTAzOTYxMTU2NzA0MDk1MTk4MDEwMjU1NDY1OTQwMDg1NTM0MDk5NzQ3Mjk3NjAwMDg1OTAzODE0MDE0NDE1ODMwNzg1NjYzNzY0MzczMDU3ODk2MDE0Mzk5ODIyMTMxMTc1MjAyMzQyMzk5NTM2NDM5Mjg0MTIzOTE4ODU1ODkzODI1MjA3MjAyMjQ0ODMxMzE1NTc1NTk0ODg2Njc1ODEzMjU2NDQ4ODQ2ODYzNzIzMDkzMjQwOTU1OTAxOTE2MjI5MTM2MzkzNDU0NjA1NDU1NDQ0MTA1NDQ0OTg3MDI4MzkxNzQ4MTIxMDU0Mzk5NTM4MDY0Njg2MDc0NTIzNTA2MTc2LzM2MDIyMjI4MjEyMDUxNjU0Mzk1NDgwMjEwMzc4NjI2NjQ4NTE4NDMwMjgwMzM0NDU4MTQ0ODkyODg5MjcxMjcyMTIyNjYyNDY3NjM4MzMxMDkxODYzMjE1MTQ2NTQ4MDQ4MTQ0Njc1NjU3MjM5ODQ2MzM3MTY1ODEzOTM4NDI0Mzg3NDk5MzU4ODUyMzAxMDE2OTI2MzEyMDgzOTQwMjEyMTAwMDAxMjIwMTgwNzYyMTg5OTc4MDI0ODIxMTY2NzQ0OTY0OTA4ODcxNDQzNjgxMzMyNjY0Nzk4OTQwNjYwNDIxNDY5NTE5OTk3NzQ2Nzc1Mjc1ODczMDg1NzcwMDE4MjY5NzA2ODQ3NzQxMDY0MDM3ODc2MTM3MzE1MDAxMjI4MzE1ODA2NjU5ODc1XCIsIFwiODI3OTkyMzY5MDYzMDQzMTU1NTc4NzMwODcxODk2NzUwNTcwOTUxNzY2NjI4NDcyODEwNTA2OTI2MDk4NTA1MDI4MjY0NTUyMDQ2ODI5MDk3MDgyMDk1NjY1MTk0MDAwMDAyODAyNjYxNjAwMTk2ODQwNjM5MjA0MzAwODA0MjI1MzUyMzM3NjMyMjU5OTgwNzAzODMyNzEzMDMxNzkwOTIyNDg1NzMwNjE1MzA1NDQxMzA5OTE3Njk2MDQ0OTU0Mjg5MTg3ODM3NjUzOTMzMTU4OTUwNzc0MjQ2MDE3MjIzNTcxNDYxODU4OTM5NDA3Mzg2MDg3MDgxNTI1MTMwODMxMzkyLzIzNjgwNTkzMjgyMzY4NjUzNDk5MTE1MzM5Mzg2OTI4ODUzMDM2ODAxMTU3NDY2NTg1OTIyNjcwNDI3OTY4NTU2NzcyMzgzMDY5Njc1NDgyMTY1ODc3MDE3NjM4NTEzODkxNzcyMjgwODM3Nzk2MjM0NjY5MDc1NzE5MTEyMjMwOTg3NjkyMjA2OTg2NzQ3MjUxODExNzYyODYzOTkxMzA3NzQ0MjgwNjE0NzkxMDg4NDI2NzY5NDg3OTA4OTc1MzEzODQyOTc2NzQwMTcwMDI4MzAxNDE0MzI0ODQ0NTk2NjQ3NDgzOTE5MzYyODMwOTY2ODcwMjIyMzk5NDA3MTM5NDYyNVwiLCBcIjE3MzQ3Mjc2ODg2ODc4MzIzNzM2NTQwMDUxMzIxNTgyNTQ4NzI0Mzc4NDk3ODM5Nzg5OTQzNjM0MDcxMDI2MzMxMDAxNTg4NjQ1NTE5ODY1OTkyNzczMTU3NTY1NTk1ODg2MjUwMjMwMTQwNDUyMTU0MjY5MTk3NzcwNjE1MDk3Mzc3NDg2MDEzMDk3OTc5MDg3NjQ3Nzc0NTEzNTAwNzAxNzkzODg1OTc4MTkyMjE4NDU1Njg3MDc4ODgzNzY2MDg2MzA5NzI4Mjg3MTcyNTY3NDY2NDA2NDQ5MzcyNjU5NjgwMDQwMTgzMjczNjM0NzAxMDkyNTYxNzI3NTE0NzEzNDk0OTE0NzkzNDI1NDA3MTQ5MTg2MDQxNzk2OTM1MDU1MTg3MjgxNzQ0Mzg2NDMyLzQ5MTkzMjU2MjE4MDQ2ODM2MjMzMzk2MDY4NDk5NzA4MzIwOTQ3MTQzNzE5MDM3MDkxOTU1Mzk0NDA0MjQ3Mzg5NzM1NzU5MDIzMjk3OTc1NDY1OTI0OTczNzgwMDA4NTgxOTYxNzM3MTgxNDU4ODM3ODM3MDkyMjMxNTgyNjA3MDAzNjUyMjQ3NTYwODEyNzUyNzIwMjE4NTYzOTM3MzU2NjMzOTk1NTIxNjY3Mzc2OTAwMzg4MzI1NTA4NTMxNDU4MzExODU5NzkwOTQ5Nzk1NTY3MTUyOTQ5OTAyNTczMTUzNjkxMjQwNjU3ODc0NzM3MDcxMzY0NjQ3NzIyNDc5MTcxNTYyMzIzNjYzMjAyNjc2MDE2MjI2MTc4MDM1MTQwMDM3NTM2NjIxMDkzNzVcIiwgXCIxMzc5ODQyMzE4MzA1MjY4NjYyMzYxODYzNTc0NjE0NTg5MTcwMjA1MzgxMDgwNTg2MTU2MzI4MDEyOTgwOTEwMzE1NDA3MjkxMTE1Mjc3MzQ4NzIwNDQ3OTA0ODczOTYzMDI1NDU5MTAxMDgyODU5MjE0MjE0MTczNTgxMTMwNTU1MjI3MjUxOTc5OTg0ODMzODMzODAxOTIzOTEzMTIzMDQ2NDcwMDQyNDAwNjA5NzA5MjkwNzI0OTgyOTMyMTAwNTcxMjA2MTczMzIzMjM0NDUzNzk0MjQ4Njc5NjU3NjQ3NDk1MzQxMjUwODExMzEzMjc1NjU1MDc1MjQ1MDIxNjM0NjA3NjEvMzg4MTA0NDU3OTI2NDI4MTc1NjExNjg5NTA4OTAzMTUyMTA0NzA5NDAwMDY2MTM4MTk3OTA1NDM2NTM3NDUzMjc3Nzg1Nzk3ODc2OTQ4MDk3ODI2MDE3Nzc1MTQxMTY4NTg1MTQwNDk1ODUwNzQ2NjcwODUzOTk5MjUyNzg0NTkxMzg1MDg1MTQ4MzgyNjgzMjEzNDkwNjk0ODEzMzQ5NjcyMjE0NTU3MjI4MTE0MTQzOTk3Mzg3NTYxNTE0MTQ5MDYwOTIyMjUyNjUzNTU0NDkwMTExNTIyNjcwNjg3MjY0MTcwNDU2NDQyMjIzMjM0ODg0NDU2MjYyOTI1NzQ4Nzk3NDQwMDBcIiwgXCI3NDY1NjcxMjA1NDc4MjMzMzQ5MTQxMzYzMzk2MzM3NjYwOTg2MjY2MzY2NDM0NDkxNDQwMzI2MjYyNzAzNTg2MTkxMjU0MDI4MjYxMTMyNjk2OTk3MDk3MjEwNzExMzU0NzE2MjU1ODg5ODExMjY2Mzc2NzQ0MDIwNDg1MTk5OTAwMTA0OTkxODA4NDQ2NjUxNTE5NzEzNTYxNDkyOTI4MTgzNzU0NDg1MDQxMjI1NDU0MDAyMjc2OTY2MjE1NzIyNjM2MjE3Mjk1MTI0NjE1Mjg1NTA1ODgxMDgzODQ2MTkwNjQ5MTIyMjQ4ODQ0NjU3Mzc0MTc1OTYxOTA3MzU5NjY5MTUxNjc1MzAzMzI3NjIyMDMwNzQ0NDA2ODg2NzYxMjM3NTYxNjI1NzI4Mjk2OTIxNjAvMjA4MzM0MzM3MDU3OTIzOTI5NjM2ODg0MTcwNTA1NTcwMzYzMTcxNDQxMTQ3ODk5ODE2ODE1Nzg1MTUwOTU0NDE3NTk4NjQzNjE0MTUyODU2NzY3MTg2MTMyNDY3MDY5MzY1NjA1NDk2MjEwMDM2MTcxNDI5NzEyNDg1MTgyMTYyOTQwNDYwMTIwODM0MzQ5MDA2Nzg0OTU2NTIyNjAwNjc5MzU3MzA3ODQ5OTgxODYyMDA2NzEwMjM5MzExNzUwMjYxNTIyODMyOTk2ODc3NzEyMzUwMzMwMjkwODMxNjM4NjQwOTEzOTMyMjY1MDA0MTA3NjIzOTU0OTEzMTU1MTQ0OTc1MjUyNzQzMjU3ODQ2OTQ1NjA5NzM0MzY4NTE4NDI0MTcyODQ2MTE5MzA2NjQzNDMxXCIsIFwiNjQ2NDkzNzE3MjgzMzA2OTUwNzY5MjgwMTM2NjEwMDE4MTk5ODkzMzA5NTMzODE3MzEzNzI0NTAxNDA0ODM3Nzk1MzYxMjY5NDg5NTc5OTMyNjEyOTkyODc3NTM3OTE3NzA2MjI1MTIyNDg2MzAyMjQ3MjQ5OTAyMzQ5MDM5MjgwNTYyNzUwODA2ODI1Mzc2NDEzNzczOTMyMTA3Mjg1NDYzNjQxNzYyNjcwMzQzMzkyMjE1NTg2NDEwODQ3MzAwNTIzMDQ3NzA0OTg5Mjk5NTg4Mzg5OTcyMzk2MzU3OTA0Njk1MzY4NTc4NjM5NjM1ODkxMTg4ODgyMzgwNjk3Mzg2NDcyMzkwNzYvMTc5MDM5NTE0OTgyMDAyMTIzMjc4MDI4NDc0MjU5MTM3MjMzNTg0NTIxMDA2ODYyNDYyMjQwMDg3NDU0MTQyMTQ2OTAwNDcwNzgxMjI5MjUyNDcwODY1MjEzNjIzMjk4MzMzMDc4NDk4MTc5NDQ2NDU2NDc3NTA2NDkyOTAyNDgxMTA1MDkzOTU2MjgzMDU5NzA1MjMzODQ4MzE2NzE3Mzc1Njk4NzI1OTcyOTU5NDc1OTM0MTAwNjczNjQzNzk2ODc1ODg5MTkxMzU2MjE2MjExNjIwMDc3NDg2MzU5MjA4NjQ5MjY4Njc4NzA1MDI1Njg5MzU3Mzk3MjUzMTI2ODcwOTQwNDczNzVcIiwgXCIyNDU0OTE4OTQyMTU4MDAzMDk5Njg4OTIyMDI2MDE2MzkzNjg4MDkyMzk5Mjk1MTY2MzA0NjM0MzE3NjE2NzczMDgzMzg2MDg3NTMyODY5MTkzNDU4NTkwNDQ4OTE4OTU4MzM3NTMwNDA2NDEwODAzODQwODM3NjQ2NDY1NTIyNjU2NjcwMDUwMTEzNTQ4MjA4NjE4NjU1MDcwMjMxMjc0Nzc4NTkyNzY2MjQ0MjgyOTY0NDYzNzAyMzU0ODcyNzUzNjU3NzY2MTIxODI1MTk2ODk4OTE2NzI1NDk4NTUzODgyNjg5MjEwMjgwMDgwMjA2NjI3OTE2MDQ2NDg0OTQyODI3NDg3NzI2MzAwODIyMzE4NzY0MDU4MDg0MzIzMzE0MTA5NTk1MzI5MzA0NDA3NDY2MTg4MzgzNjE2LzY3NDg4MDE4NTkzMTMyNTkyNTk2NjU4NjU4MzgyMDAxMDU3ODk3OTY5OTE0MTgxNDQxNzMyNjU1MjYyOTIwNjE0MDI1MjM0ODgyMjkzOTg0NTAwNjg0NTY2OTU3MDg4NTI3MTU3NjY5ODc3MTQwNDE2MjUxMjAwMTU0OTkyMjkwOTA0ODkxNjAwMDAxNzgzNzg5ODY0OTEwMDgyNTk3NjIzMjc4NDQ0NjYzODc3NjAyMTQ4MzgwMjk4OTc5NzUwMTcwNTY4NTYyMDYxMjk4Njc3MTUyMTM5MDQzOTkzNjA2NjUyNzczODY4MjM5NjU2MDQ2Mjg5OTc1MzY1Nzk0MjcxNTMwNjc5Mjc4MzI4Mzc4MjIzODY2MjE1NTkyMjA4MjAwNTU5MTUxMjI5NjAwNzgyMDY4Mjk5NTEyNVwiLCBcIjc0MDE4NTU4MDQxMDY2MTYyOTE2NDU0MDEwNjgwNTk0MDQyNTE4NDYyNzU2MjM0MjU0Nzg4MTU4MTQxMTE1MjQ0MzQ5MDQ0OTU4NDQxNTIxNzQ5Mjc3Njg2ODUxOTI4NzA2NDMzNTU2Mjg1OTcxMDg4NDU1MjI2MjE3NjQ0MDA5NjI4Mzk5NDQxOTY3NTA4ODM4NTUzMzQ1MTUyMzEwNzMwNTYyMjI0OTEwNzk1NDQ2MzQxNjAxMDQ5NjQ3MzkyMDY5MzczOTcwMTAxNDkxNzQxODMwNjIzMDc4MTI2MzQ0OTI4ODA0MDI5NTI0MTgxNTc4OTQ1NTg2NjYzMTEwODQ4MTQyNTcxMTQ5ODYxLzIwMjA0MTUzNjIwMDA2NzgwNjg5OTIzMzI4NjM0NTg2MDkxMTAxMDIxNDIzOTc5NjIyMTcwNTc5MDM2MTQwNTk2MDg1NTY2MTcyNzc1MDUxNTk1NTg4NDM4NTkyNzQyNTYzOTIzNDI4OTAwODY0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsIFwiMjEyNzAzMjAzNjc1ODA0NTUxMzMzNTY5MDE4NTYwODU2MzAyMzk1NDAwOTA5NTIwNjA4ODIyNDQ4NzM2NTU0MTk5NTMyNjcxNDI4NTExOTM4NDc0MzkyODk4NzYzNTc1MjkzMTY2NDI0MDc1MjMyMzkzNzMyMTA5Nzk1NTQ1NjU0Mzg1NDk0MzIwNjA5MjkzMTI0NzQ5ODgzMzAwMTQ5OTk1NTQ1NjE5MDcwMTY5NTQzMDQ1OTU4Mzg4NTEyNTM4MjA4Njc3NzYwNzAyMTY3MDQ0Nzc5NTMyMTY2OTk0ODczMzMyODk3MzM1MDI3OTg0NjkyODYxMzk0OTEyMDkyOTI1MDMxMjY2NjM5MzM1OTQ0MjQyMzA2NjIxMjMxMTA2MDkzMTQ2OTAxNzczNzEwNjAyODMzOTg4MjgzMDg0OC81NzY2MTI0MTg1MTE5MDI5Mjg3NTczNDAwNjI4NDA5Njg1MjY4NjIzODEzMjY2OTgzMDk1Nzg3NzEyMzg3MTU0NjIxODAyODIyMTI0MjIzMDIyNjEwNDQ5ODAxMzE1OTQ1MjI0MDcwNjYzNjkyMjI5OTg5MDM4MDg5NjA2MTc0NjExNjQ5ODUzMTg2MzM1MTg2ODAzMDQ5OTU3ODQ2MTQzMDg5Nzk4ODE3MzU1Mzc2NzgxODIxMzQxMjgzMTk1OTY2MzY5MjA3MTkxMDY1MDY4Mjk1NzEwNzI0NDczNjIwNTIzMTk0MzgwOTEzNDc2OTk3MjAxNDcwMDMyMDk0MTc4MDYyMzAxNDk1OTgzNDUwNjgwNzg3MTc5NDgwMjUyMDc2MzU0NDgyMDUyNTMxODQ1NDA5MzY0Nzg0NDUxMjVcIiwgXCIzNTI4OTY1Mzk3NTU2MTA4MzU3NjY0MTk1NDkyODc2MjExNjg5NzA2MTI3NDg5OTUxNzMwOTEwMjc4NDc1MDM4NDAwMjMzNTE4NzExNzI2MzI3MzQ4ODc1MTA2NjU2OTIzNDM4NjEyMDc1OTg2NjIwNDM3MjM5ODYxMTE5NjM1Njg4ODQ3OTAzNjk0OTA1MzI4MjMwMTAyNzc4OTUzMDk5OTczNzMwNjUwMTAyOTcwMDEyODc0NDQwODAxNTY0MjIxMTM1OTQ0MjE4Mzk0MzkxNjEwNjc5MDY2NjExNDg3MDk3NDIxMjE1OTQxMDI4NDc1MTU3MTkwNTI3NTYxMDkyMTc4NDcxNjE4NDUwODQ0MC85NTAzMDA2MDY2ODgwNzI4Mzg2ODA4MTQzMDQ1OTI0MTE5MDI0MjEyMzc3MTUwMjE3NTMzMjUwNTYyMTg4MjI4MDYyMTc0MDY0NjkzMzc1MTM1MzA2NDM4MTIwMzg1ODc3MzIwMTYyNzEwOTE4NzE2NjEzNTQ2MDc3MTU2Mzg5NTgzMzg0NjU2MzQwNzA5NjM4NDMwNjc0MzY0MjMyMzQzNjA5NzE3NzM1NTc0MDM1NTM1MTAyOTUzNDgyMzY2OTE0NDIxMjA1MjE2Njc1MjQ4NDcxNjk1MTExNzIwOTg2MzQ2MDkyNzM4NzI4OTI5ODc4NTM4NDMwNjYyMTkxMjcyNzM3MTgzODMyNTU2MTMxXCIsIFwiMTAyNjMzNTUxMDIzOTY0Nzk0NDg1NTc1NDkxMDY1OTA5NDY3MTI1NDU4OTcyMjUwMjIyNTgxMTMzNjgxMDgwNTI0MzcxNTA3NTQ0MTUyOTc5NDY3MzI4MDQ4NzE4MTIyNDA5ODQxMDYwNTI3NTQ1OTI1MTM2MTk2MjY3NzUxODE5Njg5OTM1NTk5NTk5MzIxMDkwNTcxNjg3NjMyMTAzODUwODQ3NjA1NDkzMjIzNjAzNzUxMDM4OTk2NTQ4NTIwNTU3MzMwMDE2MDQ2MDMyNjcxOTYxODU3NjIzMDY2MjkyOTYyMjYwMTczODQwOTcyMzMyMTA4MTExNTA1OTcxMjMxMDIxNDQyODk2MDM2NzYwOTY3MTA3MDYwMzA5OTkxMzU1NTQ1NTU0NjMxMDAzNjgxNTQ0NjExNzMxMjQ1NDc1OTY4LzI3NDU5NjU4MTIxODgyMjY2MzI4NzUyODg2NjA1NTI5OTY0ODA0MDc4MzE2NzM3NjQ4MDEyMTY2ODc0NDk2MDE1ODA4NjIwMjY1NDcxMjAzNTEyNjA2NDYzMjE5Mjk3MDU5NTQ3NDI4ODU1MTk1NzgyMzg0MjM2MzM3OTk4NzM4MjMzNjY4Mzk5MTczNzQ2NjYzMjg5ODUyNDE2Njk3OTE3Mzk3NjQ0MjM0NDQxMzAwNTcwMjEyNTU1ODcwNDAxNDIwNTc5NzM3OTczNzIyMTQ1NjYzMjg3MTI0MTUxMDQ5NjkyMjkwNDMyNzU2MjMxMzkwODY0MTg0NDkxODkxNjk3NDY5ODc0NjAwMzQ1OTU4OTg5NDMzMTI1OTQyMzM2NzU3MDQ5NjM5Nzk3MjI1MzA5MzI3MDE5Mjc1Njg5MDc0NjI1XCIsIFwiMTAwMzQzOTM1NTgzODgzOTAwNjU3NjY3OTUwMDgyMTA0NTczNjg3MTMzNjU0OTE1NjYzODcyOTIxNjM4MTQ5MTU0MzU5MDY2NDkyNjgxMTkwNjA1NTA1MTExNDUwMjM0NTA3OTAzOTMzNTM5MzcxMjQ0OTU0ODg4NjA0NTExMjMzMDI0MTIyMDQ0ODM1NzA5MTM1NTc3NjI0NjAzODUyOTc3NzA0Mjc5NDYyMTkxMTk5MTE5MjA2NDAzMDY5MTQ0NTMyMDcwOTcxMDM4NTM3NjYwMjM5MzQ2MDI1MzQ1MDI0NzY5NjIxNTk2ODI3NTAyNjIxNDMzODA1Mjc1Mjk1MzY0OTgyMTUzODQ0Njc5NzUwMjMvMjY2NzkxOTkwMjYwMzMyMjc3MTU4NjM1ODA3Nzc2MDYyMTk1NTQ1NTQ3MDc4MTg2NTYyNDg0NDk4NDE2OTQ0MzczOTA3NTk3NjU3MjA2MTgyNzcwOTUyODcxMDEwODg3NzAxNTQ4OTA1MDM2OTU4OTExNzQ5MTYxMTA0NTUxODIyMTM1NDc5MzQxODg4NDQ0NzYzMjA2MzUzODk5NDA0NjcxNDQwMTIyOTUxMDQ5NzU5OTc4MzcyNjM3NjQ5MDI2MDE0MDcyMzAzMjEwMjg4MzYxNzM0MTk3MDk1MjY2Mzk0NzY0NjAxNzQ4OTQzOTE3OTk1MzQ1NDk2NDM3NDg4NzM4ODY1Mjc5MjQ0Njk3NjAwMFwiLCBcIjI0ODUyODE0NTI2Mzg0MzM3NTM5MDM4NjE3MjgwMDA0ODUwOTM4MDk2NjE4MzM4NDU2Nzk4MzI0MjIxMzk1OTExMzkyNzY2ODQyOTgwMjIzNzA2NzUwNTg5MDQzNjk1NzY5MzQ5NTYxNjEwNzA4OTM4NDc0MTU4NTI4MzYyMDA5Nzk4Mjg1OTM0NTA4MTczNjczMDg5OTkxMjUxOTI3MzI2MjkzNDc4NTk5MjIzNTg1Mjg2NjYzNzg3ODgzMTg3ODQ0ODM0ODQ0NDYxMTQxMjc2NDE2MTA3ODQ1ODA2ODU0OTcxOTgwMDczMzIzNzAyNDI4NTUyNTgxNjcyMzQ4MDg2ODcwNDc0MjgwNDA3NzI1NTI0MjY4MjA3NzI5MTcxMzA5Mjc5MDI1MDUxMTU2NzYyMTczNTAwNDIzNzQ1MDk0NjMwNC82NTY3Njg2NTY2OTE0ODYyNDgwOTM0MDg3MjE1MTkwNjA0NTc4MTQ0Njk4MTY2NDU2MTE5NjY4NjIxNzU1MTM1ODQ4NjgwMjI3NDY5ODIyODgyNTQwNDY5ODk1MDk3NDkzOTU0NTA5OTcyNzI0MjI1OTU0NzE0NTM5MjM1MjY1ODYzNzMzMzU2MjM0NTQ3NzkzMTk1MTg5MDk4NDI3NjcxODY3MzYxODczNjU2NTkyNjY2MzUyODYyNTc5NjQxMjQyMDc1Mzk2MTIzMTQwNDY4MDg3NjU1ODY1OTczNTI1MTQ2OTMyNjcwNzU2NzQ3OTA3MTg4MTk2Njg3NTMzNjk1MTEzMzQ3NTEzNTQyNzY0MDIxODk3MjcyMjkzOTQyNzgyMTg0MjE3MzIxNjI4MjM5MDA1ODA0MDYxODg5NjQ4NDM3NVwiLCBcIjc4MDU0NDg3MTg4MDU2MzU2OTY0OTU4MDk0MTQ1MDEyMDY5NjQ4NDMyNjIxMTQ0NzAxMDkxNDYzNDEzMDU2NTYzMTgwMTUwNTk3NDMxMjcxMTQzMjQyNDUwMzU0ODk1NzcxMzQ5Mzg1Nzk4NTYwMDM5NTY4NjE4ODExMjU4NTY1OTU5ODE1MDA1OTM0MjY4NDA5NjgwODc2MTgyNDE3ODU5MzExMjg5Nzg1MTYzNDA4MTIwNjY1MDI5NjQ1NjEyMzEyMzUwNzMwMTI2NzIzNTY1MzA1MDk2NjMzODQ3MzkxMzI2ODY1NDg5MzQyODg3MDMxNzk0NzkwMTEwMTY3MTkwNDU1MzA4NTUwMzMyMDUyNzE1NDgvMjA1MDUyNTE3ODAyNDAzOTc0NDEyNjU5MjUwNTM1MjIwMjIxNjkwNTQ5MTgzMzM2MDI3MjU1MzE2OTUyMDkxNTAyMDcxNTQ2NDIwNjE0MTk0MjE1MTA4NjE3NjUwOTQyMzQwNjQxMzMxMTUyMDgzODU2ODMyNDEzNDA3NzQwMjg0MTAzMDExMzQyNzMwOTcyNTg3MzM0NDgwNjAzMDgzNjMxNDUwMDI2NzEwNDA3MDEzMTQ1MTcyMDk0NzUzMTk5NDgxNDcxMDE4OTAwMDA3NjY1MTg5NTUyMDIyMjY0Njk3NDU5MDQ4MTQ5NzM4MjgzMDMyNTQ4NTE3NDg5OTE2OTA5MzA0OTI5OTc2NDgxMzI3NjM3NVwiLCBcIjMzNTUzMjUwNzEyOTMxOTc4Mzk0MzQxMTkxMDUwMzk2NzMzMjQyNjQ3NjU4MDk3NzExOTI4MTU5ODIyNDYwNDA0MTU1ODAzODc3MjkzODI0MDQ2MjQ2MTM4NzU2NTMwMDUyNjE1Nzg4NzcwNDc0MDUzNjUwMzIxNzg2MTk0NTA5NjM3MzE3MTk3NzcxNjcwMTU5NTk5MjA2NDUwNTU2MDA0Mzk5ODcxNjE4MDA1NDc5MDE1MzkyNjkzMjExMDA1NTkzOTMwNDg5NzMyNTUzODg4NjAxOTM5NDgyNzQyNTUzNDAzMzU4NzY4OTA0OTE3NDY5MDA5OTE2NjgxNjU1NjU3MjkyNjk2OTgxOTYyMzM4MDU5OTEyMDY2OTExOTYwNDUxODIyMTQ2NDE5MzU0ODMwODM2NjIzNTY2NjY5OTY5MjIyNDAvODc2NDAyNTc5MTE5MTE3NTc5NTgyNTY5ODM5NzU3NDYyNDYxMDUwODU1MTc0MzUzMTA4ODU4OTU0MjgyOTE1NjQ0NzkwNjU5NDI5MzQxODUzNDA0ODI5NjYxODk5ODUwODQxNjQ1NTI5NjQwNDU0NzY2MTczMjA5ODk3NTEwOTg4MDkwMzE4MzAzNDU0NTQyNTQ3NTE5ODUwNDczODA4Nzg5MjIyNTUyOTY5OTMzMjIyMjAzNDIwODQ3ODU5MTcxMjUwMzMyMzUwMDc2NTA5OTk2Mjk1ODQ0MjAzOTY1NTY0NDQ4MTU0NDg0NTY2NDkzMzk1NDAzOTY3NjI2NTk2MjEzNzkyOTIyNzg0NTA5ODkyMDg2MzYxNTcyOTU1MTc1NjU1OTg3MzM0ODgyMDMwNzY2MDAxNzk5ODY3NjU5ODE0MTE3XCIsIFwiMjE4ODcxMDYxOTkxMDQ1ODY4MzcyODY2MzgxNTQ1MjY3NTg5MzY1NDEwMzUwMjk0MDI4MTM4Nzc4NTcyNDY2MjM1NDg2Mzk3NDc4MDI4ODIzNzIwODQ2MTkxOTk4ODI1NjI4MTU2NzE2MTkwNDYzMjYzNDkyMzA0NjM5ODkwNjU5MjU0MjgyNDQ1NDY2ODA2MjI0OTQzNDEzNDQ2MDA4NjQ1MDg3MTg2MzA3OTg1MzQzNTc0ODA3MzYxOTcyMjM4MjMwNTIwOTc1NDM5NzM2MTk5MjkxMDE5NTQ0NTc2NDQzNzkxOTE2MzAyODI1MTkzNjQzNzc0MzYwMDU1NTQ1MTg2NzgzODE5MzY3Mzc4NDkyNjMxODA2Mjk3LzU2ODQ5NTYwNzI2NDE2ODk2NDMxNTU3OTQwMzE0NzYwNjgwOTYyNjUzNjU4MTI3NDU4MDAyMjMzNzgyMDI4MDQxNTM3MTIxMjE2NDg3NzkwMDA4MDg1ODc2OTk0MDIwODEyNDkyOTg3NzMzOTg3NDE0NzQzNjA0MjM5OTM1MjIzNzgzMzQ5ODcwNTE2Mjg0MDQ4MzY4NzYxNjE3NzM2MTI3ODkyMTYwODQ5MDY1ODk1MjIzMjg4MDIzNTMxOTMwNDExNzE4ODA3MDY1MjA5OTAzNTkzNjY4MTE3MDg1NTA1NDgyMDA3MDYxOTY5MzM5MjM3NDA0OTQ1MTgwMzc5NDYwMDUzMTgwNTcwNDA0ODQ2MDQzMTM2MDAwXCIsIFwiNTAwODY4NTEwODM2NTIyNjkzMTU4MjkzNzk2NDQ1MTcwMDc0Njg1Mzk4NjE3MDYzMzQzMzcyODQwOTE3MTkwNDgwMzc5NTAxODE0NjE1MjgwNDY5MDc1OTUzMDk5MDE0MDU1MjQ2MDU5NjA3NTU4ODQ2MzM5NDIwMDUxMDA0NDYxNzgxNjA4NTI3NTY2MDA3ODUwMjEyNjUwNzIwOTMwMjk1MTI4NjYwNjk1MzAzOTk1Mzg0MzY4NTgwMDk0MTU1ODIxMjQ0MDUxOTU0MjYwMjA5MjkxOTc3NjM2NjA2NzcyMDU4NjI5NTM5MDg4NjA3MDEyMDgyODE5OTU2MjY0MzIwODYzNzk3NDM0NzM5MDkzODc3MjA3MDA0OTM0NDk5MTI3MjYyMTEwMjYyMjkzMTU3NjMzOTk4ODEwMzY3NDA3MDg3NjUxODkxMi8xMjkzODg4NTM5NjgwMzU0MjgyNTQxMjc3NjQ2OTQ3MzgwNjI3MjQxOTc5OTY3NjExODgzMzQxODIzMzc4MzMxNjY3OTc2MDQ1Mjg3MzExOTg4MTAzMTYzMzgwNjUxMzM0ODI4MDEyODQwMzMwNzEwNzYwNzU3MjcxODYwMjE5NTg0MzcxMTA5NDcyMTMyMjExMjE1OTU3NDAyMjUxNTk0MDU1MDA5OTM3Mzk3MTg0NzY4MTg0NTE3NjIxOTc4OTQ3Mzg0MDI5Mzc2NzY2MjkwNDk4MTAxNzI4OTcxMTQ1NjMzMTM5NTQxODI3NTQ0NTM5OTg4MzQ0NzcyNTc4MTg0MzE2ODQzNzM0MjY3OTE1NjY1NzMwOTgxODU3Mzc2ODcyNjIyNzg3NjI3MzcwODU5NDExOTA5MzMwMjI3MDgwNjk3OTY2MzUzMzc1XCIsIFwiMTUzODgzNDAxMTM1MjU3MTE2NjAyMjc1NjY0NDYxMDE5MDk1ODU3OTY3NDY5NzkzOTYwOTM3NzY5NjA5ODk4Njg0NTcyMTE2ODQwMjgxNDk1MDI1NzgxMTY0NTY3ODUyMjE3MjA2ODIyMDI4MTYxNDA5MTE5NDQ2NjEwNTEwMDE2NzUxMjcyNjI3NzQ4MjQ1OTM0MjA4MjU1ODczMTk0MzY1MzczNDYzMTE4MzEwMDMyMTI0MjQ0OTc0ODg0ODUwOTg1NDM1MTIzMTQwNjIxMTI5NDg3Nzc1NzIwMzg3MzE4MjM5NDgyMjQ3MzQ1MDU5MzA3NDgzNzE1MjIzMDk0NTExNjgwODgwNTcxOTAxNjI4NzgyMjQ4MDEyMzIvMzk1NDIyMDU4Mjk2MDgzMTY5MTM3NzQzNTE2MDg5MDY1NjE3MzY1NDA2MzYxMTc2ODQyODQ1ODgwNzI3MzcwODA0MDUxODc2OTU0MTIxMTczNzkyNzk3NTg5NDU4NDAyNDQ0ODE5MzgzNTE2NTE2NzgwMTk3NjQyMzI3NTc2NzU5MDUwMjU1Mjk2NDQwNzQ5NDU0OTA0OTc3NzAwNjM0NjE4OTQzNjgxNzIxNTMyOTg5MTUzMDgxMTQ1MTgxMTg2NDU3OTY0NDg5NDk4Nzg2NDI2NzM4OTI5MDg0ODU5ODI4OTc5NDk3NzM4MjUwNDg5MDIxNjIxOTM2MjAzMTMyNDYzNTYwOTA1MzA3NTMxMzU2ODExNTIzNDM3NVwiLCBcIjUwOTkwMzkzMzM5ODc1NjEzNzQyMjIxOTM1NTExNTUzMjM0NzA2NzU2MTc5Nzk4MTY5NDE2NDYxOTY4OTU1ODk0MzkzOTE2ODU5MzgwNDY4NjUzOTExMTk0ODQ1MTAzMjk2MzQwMTUyNzU4OTM1MjA3MjUxMzUxNDE4Nzg3NTExNTMzNjAyNjQzNjgzNTM1OTUzNDg5MjE5NTEyODA1NjEwMjkwMjg5MTI5NTM1MDA5NDQ4MTQ3NzEwNjQ0MDk2MTE5MTc0NzU4MTg5NTY2NTk3NzUxMzE3NTExMjEzMTIzMTYwODQ0NjUzMjE5MTc3Njk2Nzk4ODEwNTIxNDQzNjQ4MzQ0ODU4NjY0NzczNzk0Mzc3MDU5MTM5MTEzNzE0ODE4MjgxNDA4MTc3NTk0MDExMTc3ODAxOTkyNDYzMDE3MDU2MDAwMjA2NzExMDQvMTMwMzUwMzYwMDI5NzY3OTM3MTEzNjk0MzQ1NDA2MDMxOTk1ODY4MDU1MzIyODg3OTAzMTMyNjY3OTQ0OTI2MzY4MjA0ODcwMzEwMzQ2NDg3MjkxNDk3MjkwMDEwNTU2OTgzNTAwNDg3ODk2MzcwMTU5OTc2NTAzMDU5MDA5NzczOTYzOTA0NTg5MDA2MDU0ODc2MDY5MjEyNTU0Njc1NDI5NDUxNDA2ODA1MjkwMjU0MzIyMDM4MjEwNDQ4MzgyMjQzODI4MzA0MDA5MDQ0NDgyNzk4MDkyNzU0NDQ0MDk4NDgyMzUzNTI2MDI3NzU5NTQ2NjMzOTQwMzc5NTQwMzIwMDcyMDYyMjg1MjA2OTI0NDc2ODkxMDYwMzgyMDAwNzYzMjM5NTE5MDIwNDU2OTkyNzYxMjM0ODE4OTA4OTE2MTU1MTk1MTEwNjYyNVwiLCBcIjQ5MDI4MzcxNDEzMzQwNzMwMjYxNDU4MjcwMjczNjE5Mzc5OTYyNjEzMjQzNDk3MjI3MjY4NjkxMTYxODUxNTg3Nzc0MzkzMzcwNDEyNjM0ODI4NTIzNzYxOTQ5ODgzNzE4NTM0MTM0Njc1NTk1NTc5MjM0MTA5NDk4OTgwNDgxMzk4MzAxODMzMzUxOTc5OTI3NTQ3NDgyOTQ4MTA4MzgxODcwNjgxMjY4Njc2MTE2MTU4MDAzODM4MzQ5NzU1NjMzMTMyMjA0OTc1NzM3Nzg0ODAxMDkyNjQxNzg2NzMzODkxNDk2NzExOTQxNDk3NDk3MzU4MzMzNzg1NTcxNDMxMzU0ODEzODc5MDQ5NjE1Mzc5NDI1Njk5MDQwNzUvMTI0NzA0NTMxMDU0NTk5MTI2NjI5MTI4NTczMDAxNjg1MzExODk4MTA5OTUxNjkzNTI1MTg2MTE0NjAzODM2OTk4NTEwOTI4ODA4NDQyMDUyODE3MTIxNzk0MjA2NTgzMjI5MjczOTEzMDE0NTc4MDgzMzQwNjAxNDY3MzY4OTExOTU2MzY5ODUyODIyNTA0ODgwMDc5NDcxODc4OTIxODI2NzYyODUwNzcxMzYyMTIzNTA1NjUzODIwMjA3MDE3MTU5NjE3Nzc3NTA5NTA3MTUxMzE5NDg4NTU2ODg0MzM3NTUyNjgwNDc5NjAxNjI2MTE3MzM4ODQ1MjE4NDUwNTUwMzM0MTEzMjIzNjcxOTQ4NDgwOTcxNDMzNTc0NFwiLCBcIjM4MTE0NzQzNTIyNzE2ODMyMTA3OTE3NDY2NDM4MjU3NjE2NzIwNDc2NDg4ODEyNTM4MzE2MTAxNjU4MTM5NjMyODY3Nzg4NDY0MzgxODYyMjkxMjQwNzI3MzA5NjExNDYwMTg3MTU5OTMwNjUyMTg2NDg2MDk2MzAwODYyMzg4NTkxNTIxNjI1MDkzMjM3MDE5NjYyMjczNzY0Mzg3NTkxNDk0MDc0NzkyNTc0OTI5NDkwMzgxOTEwNDQ2Mjg3OTQ3OTk0MTUwNjU1MDc3ODc3MjA0NDQ2ODY0MDA0MDY3OTU2MDg3OTc1MDEyNzczOTg4ODMzMzM5NTIxNzc1NDYzOTc3MjMzMDY4NDk4NDA0MTQ0MjIxMDQ1ODM3MTkwMzkyNjcwMzA4NDM3MzkxNjg2MDgxNDE4MzE4NjI0NzQ1MDM5NDAyMTQ1NDM5MjIzNTUyLzk2NDcwMDEwODMzODM5OTk0NTM2NjgxMTE4MDk3NzU0NTEwNzg5NzYwNDY0ODg3NDY5MTYwNzA5NzYyMTg2NDU0MzE5NDY2NDgwODcxNzE1ODYyNTIxNzI5MzY2MDAxMTUwMzIzMTYzODM0MjcyNjUyMTc5OTMxOTM0NDQxOTk4NjMxMzg0Mjk2MDIxMzg4NDE5NzY1ODYxOTA1MjU0NTEzMjQwOTM3NzIwOTcyNDEzNDk0MTc5Mzg1Nzg4Nzg5MzQ1NzcwOTE2NzEwNDYwNTAzMjYwODc4OTgyNTk2OTI5MTc5MzEyMzA5NzQxNzQ3OTk4MTUxOTg0OTMyNzk0MTM0MzgxOTIzMDE0MzcwNjg4MjAxODU3NTc4Njk2MDg1MjM3NjE0NTYxNjAzNDE3NTQ1MTIzMjkyNjQ0NDIxMTUzNTE5MjY5NjcxMjA0MDQxMjVcIiwgXCI1NzM2OTUwNTUyMjUyMjU3MjcwMDg4MDM3MzA3Njc1MTg5MDY0OTA3MDQ5OTU5MjkxNzc2MTc2NDYyNzU2NDY4ODQ1NTU3MDc5NjA5ODY2MjU0ODE5NDQxMDE2MjI3MDg0MTU0MTU5ODg4NDQ3NDAwMjg3MTgwMjc1NTQ0NTI2NjIzNTg5NTc5MzM1MjYxNzM4MjQzMjU5NTU5MDQwMDU0MDQxMTM2ODQwMDM4NDE5OTAxOTgxNTcwNzI1NDA2NTkxODQ5OTU3Mzg3MTkwNDAwMjQ2NDczNzA4NjkwMTA0NzMyNTQwNzE2ODE1MzM4ODA1NzY0NjIzNjg2MDA5MDE4MjQ2MjI0MzEwNDU1MjkwNjQ2NTE2NzU2NDAwNTU5MTcwOTIvMTQ0NTA5NDgyNTExMTE4ODE2Mzk5MDg5MDk2MDIxMjkwNTg3NDg5NTk0NTQxMjgwMzk4ODcxMjU1ODc2NTYzNjE1NDY0NjI4NzE4NTI3NjM0Njc5MzMwMjkxNzQxNDc5MTM1NDE1MTY4NTM5NzY1ODg3MjkxNzg5NjE1NzkwNTEzNTI3MzMwNjAwMzk0OTM3NjE0NDMzNTAyMzQxMTE2MDY4MzA1MzQ3NDY4MTMzOTUwMjA0MTUyMTc0MDk0NzA0MDkyNDAyOTc4MDgzMzcwNzkyMTM1NDMyNDg2MjQwOTE0OTUzOTI4MTg4ODM1ODE5NzY3NzU1MTcyNjY2NjkzMjE5MjEzODY4NTQ1ODU0MzcxMTAzMTIwNjA0OTQ2MjAwODc1XCIsIFwiMjM4NzY5NjAzMjk2NTM1ODk2NDc5MjUxMjYxODA5MDMzOTE2ODc2NjYzNzgyMzMyMDE3OTQ0MDMzMzk2MzA5OTU0MjAyMTUyNjc0MTU1NzUxNDIyNjY3MDczNTcyNTU3MjYzMzA1MzYwOTQ0NDgzMTQxOTk2MDI2MTYwMjY5MzUyNTExMjY0NjkyMjE5MjU5NDU5NjA5MDE3NDg2Nzk5MTk0MzU5MDg1NTY1NTAyNzE1MDQ3Njc3ODQ1NTM0ODQ0MzQzNjM2NDY0ODkxNzQ1ODc0NjM0NjYzMzM4NjQ1Nzc3MDU3NDU0NTI0OTIzOTU3ODU1NTc0MjU5MDQ3MzUwNDgxODAxNjQ2OTcwNDAzMTM1Mjg4MzExNzM0NDgwMjU0MDA2MzQ2MjkxNjM3OTUyMjM3MzkwNjE2NjE0NjE5ODY5MjM2NzU4MzM4ODAzNzg0OTYvNTk4NjMxMjQwODU5NDMwNjk1NDAxMzUyNjE5NzQ2NTYwODU1OTA2ODYyMTI0ODg5NjMyMDY1MjUxMjIyODIzODExNTU4OTg3NTUxNDYwNDYzMjIzMDA5ODk5NzYwOTQ4MjI0ODAwMDg4ODU2NzEzNTY4NTE2NzEzODc2MjE3MjQ3NTc4ODA2MDI4NDIzMjQ1OTgxMzk5ODIwMTcxOTU5MDIwODc0MjA5MTY5NzI5NDU2MjUzODI2NTgyOTk1NDE4NjE0OTE2Mjk3NDk3MjQ3MTUzMzIwMjg4MDM2ODMxNzIzNzUwODk4NzQ3NzA2OTg3MjQzMTA2NDA3NTAwNTMwNTgzODgwMTg2MjkwMDUwMTgxOTk2Mzc5MzA2MjA0MTA4MTYwMTg0NDc1OTQ1MjIwMjI4MjU0NTg0MDcxNjkyMDc5MzA1NjQ4ODAzNzEwOTM3NVwiLCBcIjU4MTY4Mjg5OTE3NTY3NzIzMTcxMjI2OTkyMzgzNTU5ODY2MjE0MDk0MTU3ODk0OTkyMzI3NTU1NDk1NDQxNjk4MDI4ODY3NzI3ODQ1NzY2NDg4MTIxOTAwNjI2OTEyODQ4Njk4OTUyODYzNDM4NjU0ODk1MjUyODExNTgzMTQ0NDc5MzAwMzgyNzYxMTI5NDMzOTExMjgwMDQ5MDA5MzYyNjY3MzgwMDAxNDA2NTc5MTc1NTYzNzQ1ODI0MzY4NjEzMzE5MTAzNjczODE3MDk0NDk4MTE3OTQ0ODU2MDA0NDE1ODEyODc3MjEzNzIyNDU1Mjk5NDkxMTQ1NjQ5ODc5Njc2Nzg3MDc5NzQ0NDEwNzY1MDUzODQ1NTUxOTU4NzU2NzAxLzE0NTE3MDY3Mjg5MzQ3OTAzNjU1NTAwMDIwMTYwNjcxMTEzNDUwMzQ5NzQzNjUwNjM2OTUzNzI2MjUxMTkxNjkyMDc0Mzg1NTIxOTc1MTMyMjY4MzEzMjYzNzIzODMxODA0MTUwODcyMjM4MTczNjAyODQ3MDY1NDIzNDYzMTMxOTE3MzczMzU2Nzk4NzUwMTAwMzEzMTQ1MjI4NjA4ODk0ODgxNDU3MTA3Njg5NDk5OTU2OTAzMDQ2OTg0NDQzNTQ1Nzg5MDUzNDM4OTQ2MDUwOTc0NTY3NjY1MDQ5MjM3NDE0NTg4NDM1Nzk2MzgxNjc0NTkwMDk4NjI5Nzc5Mzg0MzU1Mjc1ODIwNzgyNTMyNDc5NzA4ODA3NTEyOTgxNTA0MDAwXCIsIFwiNzI4NjIxODkwNTY4MjgxODU5Mjk1NDA5NDgxNDIyNDQ3MDEyNTI4MzAyNTk0MzY1NjkzNDEwNzYzODIxNzA3MDc0NDQ0Nzk5NzkzNjkwNzM4MTM3NTkyMTAxMjM5ODYyNzM2MzEzMzQ3MjczMTY3NDUwMDU2NjI1OTI5NTkxOTYwNjEwMjA4MzM1MjkwODgyMDQ3NDEzMDExNTcxNzgxMTYxMDA4Mjk2MDg0NjMwMDcyODI5MDc5NzgzMzI4OTM3NDE4NjQxNDE3NjQyODU3MTk2MzQ2MDI2MzY2MzcwMDU5NTIyOTkwODEzNTM3NzMxMzk0ODIzNjMwMjA3NDMzMjY3ODU0NjE2NzY4NjU4OTkwMjg5NDU0NjM1NzkzMzI2NzY2Njk3ODg0Nzk4NTM4NTc2MDU1OTQ5NDU3MTIyMDY3ODI4MTUzNjU1NDE2Njg4NjQwLzE4MTAzMDczMDc1OTUxNjk5MTg2MzcwODU5Mzc0Nzk2NDc4Nzg3NDA3MzM1NDA1MTY3NTU5NzA1MDM5OTA4NzYxMjE0MjUzOTUxNzMwODcyMDYwMzY4NzMyMjkyNDQyNjU5MTg4OTE3OTcyNjQ5MjQwMzkxMzM1NjQ2MTkwODc0ODczMzk3MjcwNzQ2MDA2MzAxNzA1NzgwOTA2MDE5MDQzNzkxNzg1MTc5MDc2Nzk2ODg3NzIxNTc5NTY3OTg0NDk4MzI4ODkzNTA3NTY4ODIxOTIzNDg4NTM2MDgzOTk4NDY4MTYxOTA4NDgzNDIyODIyNjc0NDE2NTYxMDA3MzY4NTcxOTAxNzU5NjYzMDMwMjQ2MjA3MDE4ODkzNzk5ODU1ODMxMjUwNzYzODQzNDMyOTI5OTAxNzU4NDMyOTQ3OTUxNjQxMDkwNzc4NjY4MTA5M1wiLCBcIjg2ODU1OTQ2OTIzNDM4MzIyMjE4NjIyNDcwMDY3MjI0NjkxODYwODA4MjczODg2MTg0OTk3MDY1NjYzNTU0ODQxNTczOTgyOTYzOTk1MzQwOTc3MDgzMDQ5MTMyNTE4ODEyOTIzMzI5NDIzNDgwMzkzMzA2OTE4ODU2NjUwNTc3MDcyNTI1NjMzOTIwNDU2NzIxMjY1OTUzNTc1NDI0MjMzNzAxOTI5ODkyMDE5NDEwMDk5MTY2MzIyNTExNDEzMTQ2ODkxMTIxMjQ4MzgxNjQ4MTQ1MzkxNjQyNTcxNjM4ODU3NTc2ODkwNTY4ODgyNTEyMTI5OTYwMjkxMTcxODY2NzcyNjY1ODYzMTU5NDc0NjAyNjA0NjQ3Mjg5MDUyMDc5OTkxNzY4LzIxNDg1NzUzNTA3MzY1OTAxOTQ3NTI4NTg4ODk2NDAyMjY0NjcwNzgxMzEwODc4NTQ3NzI2MTA0NDgyNzQwNjQ3NTU0NzM4MTUxMTAwOTU0ODM1Nzg0MTE1MTE5MDM1OTgwNTIzNTI5Njc3MDgzNTA0NDk1ODM5NzMwNDk5NjY0MDUyODgyNDAwOTE1MjA4MjUxNTk0Mzg0MDM4ODEwOTE3MjgyMjA3NDQ5ODYwODc2MjUxNTU4MzA3Mjg4NzAwMjAwOTEwNzQ3MzM4NzU4NzIzMzI0Njg2OTM5Mzc5MTM4MjA2MTE3NjM0NTQ2OTgxMTYzMzU1MDYwNzQwMjcwNzM0MTQ2NzgwOTQyNjk2MjkxNjY5NDYxMTgyNTk5NTEyMzIwMDk5NjI1XCIsIFwiMjE1ODk4OTE1MjMwMTAyMjkzODE0ODY4MDEwMjE0MjE4ODUzMTQ0ODgyMTM1OTUwNTE4ODA1NTI2NDY2NTE2NzMxMzQxODYxOTY2NTY5MzA5MjMzNzY2NTU3MzE1MDM3NDIzMTQ4NDg0MDk0ODQ0NzYzNzI5NzI0NzI3NzU3NjQxNTQ2MDg4OTI5NjcyNDgxMzk0MDEyODk1NTA3MDI0MDEzNzU5MDA3MzIzMzI2MzE2ODgzNTY3ODcxNDEzMTA2Mjc2NDI0NzQzNDE0NDk5NDczNzYxMDIyOTkwOTk2NDg0NzU2ODQ5MTQ0NjYwNjAxMjU4MTM3MDg0MDY5OTU4MjA1NTM0MTYyNjI2NjUzMzczMzc0NDI5MzkyOTY1ODk0OTY5NzgwNTg1NTM2MjExNDIyOTY2NjYyNjYyMDc2NjI0NTYzMDEyMjMzMzczMzcwMzYxODE3Ni81MzE3OTQ5MTU0MDUxNjQwMDU2MTM3MzM0NTQ1OTc5MzE0ODI4Nzg0Nzk4ODI3MDQ5NTYxMTA2ODUyMjM4OTIzMjUwNzQyMTE2OTQ4Mzc4MzYyMjE3NTk5OTU5NDg2MTAyMTI4MTg2NDI3ODkxMzI3NDkwODI0MzAwNTk1OTM2NTI4NTQ2NTkxMzAyMTcyMjU1MDY5NDI2NzU2MDg2OTI3MDE0NDc3Mzg3MzIwMzEzMDI5ODc4MDIxOTY1MDE4OTU4NDA1MTAyMzUxNjE4MjU1MDEyMzUxMzM3OTQ0NDk0MjE5MTk5MjczOTYxNDI0NzAxOTY5NjE4NzczNzY3MDE5NTc4Mjk5MjExNTI4NDgxNzgwNzY0MTAxNDE4MTM5MjY5MjQ3NDkwNTczMDQyMjIyODI2ODc2OTcyOTcyMTY2NjE2ODc1ODMyNTc5MDE0MTU0NjUxMjVcIiwgXCIxMzk0MzI1NDg1NzQzOTY4MjkwNzQ1ODY3MDQzODc2NTY2OTcwOTc3NjAwNTc4OTc2Mjg5OTQ1NDgzNTg2MTk4MTUwNTI5MzY0ODE2NTAzOTYxNTc0Mjg3NDc0MTExNzM1Njc4MDEwNDcyMjE5Mjg1OTMyNTM0NzkzMzA0ODA0NTQ0NjkzNTgyMjA2ODU4NTQzNTEyMzY5ODAzODM5MTQyMjM2OTM3MjI4NjgyMzM4MTk0ODMxMzc0MDEzMzk4MDAzMDQ5NDM4OTE5NjgwNTAzOTkzNDU0MzAyNDM3OTA4OTg5NTU0MTY5MDcyMjg5NDgyODczNjczNTY5OTAyNjM3NDAyMDcwNDY5MDIyMDk1NjM0MTcyNjc2ODY1OTE5OTQ3NDM1NDc2MjEvMzQyMDExNTE2ODg3NzUyMTQwNzE5NjMyMDY3NjU0MzYwODM0NDU5MDE2MjE0NDIwMDIwNjE3MDc0OTIwODI4NDMyMzIyMzE3NTQ4MjkyMjczMDM1MzkwNDEyODYzMDEzOTg2Njg0MzcyMDI1NDcwMDMzMDAzOTYxNjI3NDEzNzU0MzU3MDMxODg1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiwgXCIxMTAwODUxNzE3NDg3MjgzMzI4NjE1MDk4NTE4MDMyMjU4NDQ0ODE2Mjg4NDgzMjA5OTM0NDk2OTYwOTI5MTA3MDg0NDE5MzUyNDgxNjg1MjkyMDk0MjM4Mzg1MDU4MDIxNzQ0MzIwOTQwMjgzNjEwMDQ2Nzk0MDY1MTU4MTA5MjM1MDYwMDMyOTE0NTYyNzk2NzUxNTgxODY4NDQ0MjE3MTU3MTE1NjQ0NjMyMTIyODU5NjkxNDM1NTcwNDIwNTYyMzg1Nzg3MTQ5NzMxNTk1NTI2OTI2NjQ5ODIyOTgyMzI3ODgwMDcxNzkwOTMyMTI2OTE3OTgzOTA4NDQ1MjM4NDUwOTE0MjcxMjY3NzIzNTU1MjEwMzQ1OTczNzc5MDY3NDEwMzk5NDQ0NTE3MzA3NDY3MDM0NzA4MDUwNjY5ODE2ODQ4MjU2NDAwOTQ2NTI3NjE2NTgyNDc2OC8yNjg5MjIzMzk2OTM2MDgwODU2ODU1Mjk5MjE1NjU5MjA0MTYxOTQ2NzA0MjA1OTMxODg1MTI1MTQ4MjAxNjQzMDg3MTc2NTU2ODIyNTQyODk1MzI1MTkxNDc4MjgzNzA2NTg1NDAwMjM3OTAxMjE1NDg1MTUwOTI4MDM2ODk1NDI4NzIxOTEyMTE4NDY3NzYwNzY2NTA4MTYyNjMxOTAzNTg1MTI2Mzc3Njc2NDEyNTczMTg3OTEyNDQzODc4MjMyNTIxNDQ0Nzg2MDkwNTEwODkxNTk5MTcxNzQxNzczMjQyMDExMDE3OTI2NjU4MjMxNjM4MDIyOTQzMDE4NDYxMDg2NTE3NTAyNTg0ODU0MzkwODM2MzQ3NzgxNjc0NjI2NjE1NzA5NzUxMzg2NDU1MjkyMDI2Nzc1NjYzNTQ1NDcwNzk0MTY3NjI5MTQ0NDU2MjY4NzUwMTI1XCIsIFwiMTYxMDg2MzgwNzQyMTEyNjA1ODg4MDA1Mzc1NDA2ODA3MDc2NDE5ODYwNzM5MTQyNTE0MjQ4NzgxMjEyNTUyMzQ2Njg1NTgwNjc5ODgxNzE1Njg5NDYwNzk4NDg4NjAzMzU5NDg5OTE4MzQ1MjU1NTI1MTU2NjkwNDAxNjMwMjYxMzE5MTk4MDQ5ODczNDAxMTMyNDQ3NjA3Mzg4NDY4ODQ5MTEwMzgwOTc5MDc3NTYyMjA5NDU4ODM3NTA1MDI2NzM4OTkwODQ4ODA1NzgyMjk2MDE4NzA4ODI2MzExNjU1MTAzOTY3NzUxMjY4NTAzMDc4Mzg1MDUwNjM5MjIxMDE2ODIzMzM4MDYyODQ2Njg3NjI4MjU2MDk1NTYwNDk0MjY4Mjk1MzE3ODAvMzkxOTM2Mzk2MTM0NDI2MTc3NzEwMDY1ODMxODEzNzg4NDI5OTU3NTE5MzA4OTQ2Mjk0NDU1NDI4MjIxODI3ODQ5NjI5ODYxMDgyODc1NzY1MDEwNDkyMjU4MzM1OTY0MjM4NDI1MzA2Njg5NjUzODIwMzU5NjA1NzMwMjIwMzYzNTEzNDgzMzU0NTU4MDg2OTg3MTMzMzg5MjkzNTMzMDk1MDU4MzY2NDQwMDU1NTQ2MzU1NzczNTcyMzM2NDQ5Nzk0Nzk4Njg4NTE0NjA0MzAxNzAxMDE1OTM0NzA0NjM4OTYwNDE3MjE4Njc4ODkwMjYwODIxNjg5NDA5NDI4OTc2OTg1MDUxNzA5ODAyNzQ4NjQ2ODA4NDQwNzYxODc0ODg5NTYyNjg1M1wiLCBcIjM0NDIwNzU1ODQ5MTgwMjc5NTk3MzAyMTAzNzI2MTgwMTEwMDIyNjQwOTQ2NjkyNTkyNTQwNjM0MzUzNzM0MTU3NDc5NTA1NDIwMzIwMDAwMzI0MjYwNTMwNzY3MTg2MTMyMjYwOTcwNTcyNDUwNDg5NTMwMDM0NDQwMjE0MjU5NTU5MzI1MTE0NTExMjY1MDc1NDE2NTEyMzE2MjI5MTc3OTUyMTQwMjE3NzMyNjU1NDA1Mjg5ODA4MzI2MzQxNjk2OTg2NzU1MTQxOTY1MDQzNzE5MzQ0MTY5Njg1NjExMjE3OTU4NjE5MTAyNzc0NjE3MjI0ODQ3Mjg0MTIyOTAxMDIzNzc0OTU2ODg3Njg3MDI2OTA0NzY3NzE0OTU4MDkwMjU2MjgyODkzMDAzMDAwNzUyOTQ3NDI3ODU3NzAzMjU5NzA0NjgyNDU1Mzc1NDQyNzM1ODU3MDI0LzgzNDIwMzAzMTE3MTY2Nzk4MjY4ODk5MTc0OTQ5NTc1OTMxNjU0NjQ3NDg4ODQ1NzIyOTgxNzM1NTYyNTc2NTIzODk4NDUyOTQ1MzAzMjU3NjQ4MzcxMjQ5OTgyOTMzOTg0NDU4MDQ0NTg2MTM5NTY0ODkwOTYwMDc1NjQ4MTExMDEzNjEyNjYxOTY1NDIxMjk3NjQyODcwODQ4MjM2MDQ4OTcxODczMTE1NDA1NjE4NTc3NDEyODU3OTM0NDcxNzQxMTk2NjcyMTU4MDM4Mzc3MTk2NjA2NzUyOTgzMDg4NzM0OTYyMTkzODUyMjY5OTgwNzg2NDg0MjgzNjgwNjE4Njg5NDQzMjI0NzgzODQ2ODQ1MDk0NjY5NjUxMjk5NzIwMzA5MzI0MTg5MjA0MTUzMDgyNzY0MzAzNTU4ODIzMjk0NTczNDI5Mzc1NDkxNjIwMDAyNTI2MjVcIiwgXCIzNDU4ODgwNzUyNjEwMjAwMDQwNzEyMjA4NDM3MTQwNjAzNTM3NjMzODIyODA2NjQ5NjA5Mjk5MDM1NDQ5NjQxMTg4MzEyMzc4NzY2OTQzODQwNTM5MDQ1NzE0OTg4MzAwNjg4MzEwMjY2NDQzMDM3OTczNzc3NjIzNDU3MDk5NzY1OTUzNjA0MjE1MDI1OTQ2NTYzMDg5Mzc2NDkyMzk5Nzg1MjU3MTM0NzEzOTM1NzA1MzY2ODA0MTI4MTQ4MDUwNzYzMjM0MjYyNTY1ODQ1MDQyNTE3Mjg1MDc0MTYzNjg2MDk0MjA4ODI0NDIyOTM4MzE2ODQ2ODEwNzE1NTM3NjY2MDM0Nzg0NzkwMDY0OTU3NTcyMjI5MTI1MDAwMTI0NDQ3ODc4MDQ1Nzc4MTEvODM1MDU3MDM3MzE0Njk3MzQ2Mjg5NjEzOTUwNjM0ODE4OTM4MDE5MzgzNzE1MTY3NTI0MTc3NTkxMzE3NzQ1MzA3MjAwNzUyNjI0NTkxNTgzODQ0MzM3ODUwMDY2ODk1NDg0MzQ3MDE5MDQxMDYzMTIwMzg4MjI5Njk2NTg0NTUzNjQyMTk0MzUwMjI4NDE1OTcyNDMxNzg3NTc0MjM1OTgyNDg1NjU0NjM5ODU3ODYyMTMxNTY1NTY1MjM2ODU2NjY0MzA3OTkyODM4NzA1NDgyMzg0Njc4MTcyMjY5MTU2ODA3NDc0MTIxOTEyNDUwNDY2MzQyNzk3NjY0NTA2Mjk4ODY5MDQ3MTY3NzY3MTkyMTk2OTg5MjIwODgyMTExNTQxODc4NDU2MzIwMDBcIiwgXCIxMDYxNzE3ODMwNjE5MTc3NTI3MDgyMjk2NzIzMDk5ODkwMzkyMjczODk2Mzg2NjEzOTk3MDA0ODc0NjY5MDUzNDQ1OTQzMjUyMDQ2NzQ4MjUxODgzNTMyNjM0NTI5NzU5MTY5NTAwNzk1NDUyNTc2MzkyNzAwNDcyNzcxMzY1MjQwOTk2ODQyNjEwMjA3Mjc0MTI4MTAyMzI5MDk2NjE5MDI4NDg3MzY5NjIyMDAxNzM3MTI4NDYzNjMxMDE2NDk0MzcxNjM1Njg3ODQxNzMzNjQ0MzM5NjM2MTY0NTcwODE5NDMxNTczODI5MTczNTMzOTQxMDU2MjU4NzQ0NDQyOTMwNjQzNzM1NTg3NzgwOTA3MzEwNDMzMzcxNDUzOTkyMDYyNjQ3NzM3MjU5NTg3NTYzMzk4MTExNjg4NjU5NjU3NDA2MDg5MDAzMjkzNTc2OTYxNDc1ODQ4NzA0LzI1NTM1OTYzMTUzNzIxNTc0Nzk3OTg5NTk1NTgwNjk5NTM1Mjc5OTU3NDc5MDM0MDIxODM5OTM1MTE2ODE3ODU1NTQ3ODA3Mzk5Nzg3NjExMDg4OTQ4MzQ1Njk3MjY4NzQzODcwMjI2MjAxNzgwMDE2NzA0ODI0Mzc1NDE0MTcyMjQ5NjI3NjUzNzY4NTg1MzMxMTQzNDA2OTk5MTIyMjMyNDAzOTAwNTE2MDA1NzcyNDA3MzE1Njk1NzUzMDEwNjYyMzkwODY5NjI0MTI2ODI2ODA5Njg3OTU2OTc5NDQzMTkxOTcyOTYyMDE3ODM3NTIxMjkwNTIwMzQ4NDE2NTc0NTg2NjkxMzc3MzMwNDMxOTA2OTMyMTQyNjI0NTUyMTQ2NzEyMjQ3MjA0NjM3MDM1NjcyNTUzMDkxNDU4NzgwNzI3NDA3NDI5MzY3MzAzODQ4MjY2NjAxNTYyNVwiLCBcIjI3NDEyMjk0NDEwNjMwMDI5NjczODM5OTYzMjY4NDk1NTQwMDc2MTQ5NTgzMDM2MTY2Mzk2NjQ2NjIyNTY1MjkxODY4MzA5OTc3OTQ2NTQzODAyNDg0NjkwMzI4NjgxNjgxMzg1NjQ5MDg4ODc5NjM3MjEzNDU1NzI5NTY5OTk4MDUyODE4Nzc3OTYyNDg2NTA5ODQ0NTc1NjAxMzU2MzUzNTMzOTA1NjIzMzkxMjM5NDkwODU0NDE4NTg4NTU0Nzg0MjIzNTA5NzY3Nzc2NTMyNTM5NjI1NTY0OTIwNzMxNzAxODc1NDk2NzY2NjQ1MDcwODI0OTEyNTMxNjE5MjIwMDE1MTUwNTU2ODQxNjQ5NTI3NDY3MTY3OTUwMDU5NDY1NjY3MTc4NTIwMjQ5Ni82NTY4NzU5MjYyMTk3NjU0NjI1MDU4MTU2MDEwMjIwMTUzNTUzMzYwODE1ODI1Njk1MzA4Nzc0NTg1NjkwNjQzNzQwMDE0OTIwNTY5MzQyNzI4NTE2MjMzMzUwMjUyODc5MzY3NTU4NTAyMjAyNTYwMjE0NDI0MzU0MzA2NDE4NTY0Nzc5Mjk0ODQ5NTM3MjQ0MjYzMDMzMzgwMDEyNjI2OTEyMzUzMTYzNjgwMDIxMzQwNTI1NDA0NTI2MjEyNzU5Mzc1OTUzOTcwNjc1MDI0MjQzMDE1MzQ1Njg5MTc5MjUzMzI2Nzk0ODIzMTE4NTI5NjA5MTI5Nzk3OTkzMzU2MjcyNzExMjQ4NzA1NzIzNDQyMjAwOTQyNjg2ODUzMTY1MTYzNDcwNjI2MjEyNVwiLCBcIjc4NDI2ODA0ODA3MTY1MTY4MDMxNDg4MjExOTg2OTc5NjcyMzcxMzY3MjE4NjAwMTcxMzEyNDQyNjY5NzQ5OTYyNjcwNzQ3NDIyNDg1OTkwODUyNTM1Njk2MzcxODMwMDc3NDA1NjY5NDExMjU0NTIyMTU4MzQ2NDI2ODMwNTMzMzQ2MDc4OTY3MjM0NDcxNDA4NTEzNDQ1MDEwODQxMjI5NjUwMTQyNDIwOTEzMTI0MTE4ODQ5ODU1NjkzNDExNjY1NDUwNzQ2ODg3NTY0NDA3Mjg5MjI0MDg3NDM4NDE1OTI2NTg2Nzc3OTI3OTY4ODExODg2MDQ3NzM0NjkxMDg4MDc4Njk5NjAxNjEzOTU3NTk4Mzc0MDc5Nzg1OTY2Nzk5MTEwNjY1ODY2MjY4ODU4MzA5OTE1NTYwOTA5NzgzMjc1MDg0NTkyNzYwMjU5NDMyNzkwNjQ5NjU2ODg5NjAvMTg3MjUyODYxMjI0NTY0ODY3NTcyMDM4MjEzODA0NTA3MTEzMTMwNDY1MjA1MDY5Njg0Mjg3MjUyOTE2MzcyMDU1ODEyNjY1NTA3NTkzNzg0NTUzOTc5MjEwODA0ODMxMDIxOTM5NTc0NjI1OTU3MDUwNjE3NTkwMjIwNjIxNTEwMTUxODY5ODQ5MDE0NDcxNjUzMTY5NzY4OTUzNDU1OTgyNzQyMjczNTY0OTg4MTM4MTU5Nzc2MTY4NDE1NDQwOTc5NjMxNTQ1NTQ0NTQ1OTUzNzUxNTMwODE3NDkxOTQ4ODQ5NzE1NDQwOTY0Mzg3NjQ5MDQ3MjIxNTM1MjA1NjUwMjE5MzE1MDEyNTY0NDI4ODA4NjI5NDQxODI1MzMwOTk0NzIyOTE1MTA3NDQ2NDkyODg3NDg4MTgyNzIyNzcwNjk5Mjg1OTY0MDIzNjA4NjQxNzg4OTk5MDU0MTg4OVwiLCBcIjUzMDA4MjQ0MjIyNTEyNDIwNzAwNzQ1NjkxODY4MjU5MjkxMTk4NDgxMTE3MjMwMTI4NDE2MjcyNzU4MzAyMTYzMDExODgyMjg2NjA3NzkwMDgzNTMwNDk2MDM1Mjc1Njc3ODQxMTk4Nzc3MDY5ODQ3MjIxNzExNzgxMzcyNzI5ODYzNDU1NjA0ODU3ODQ5MDczNDU1MDA4OTM2NDg3MTUzNDEyNzM4NDExNDczMjAyODg4NTEwMzQwNzg4NjM4NDMzNzQ2NjU4NTA4NTI0ODE3NDcwMDAyMzc4MzQyMzg3MDMyNDg2MzQxNzQzOTc3OTI3NDU5MTQ4NDc3NzQyOTcyMjMxNzY2NzQ5MTc5MTI0MDY2NTk4MzEyMDY4Njk0NDI1MTA5NDg5NjU1NzE2NjEvMTI2MTE0MDQ3NjAxMzcwNzMzODQ3NzYwNDY3NzQyODU3MzgzMTc5MTM5NjM1MjgxNDgwMjE0OTk5NDY0MDYxNzcwMTc3MzA3ODE3NDg4MjQ1NTUxMjY2ODA4OTA3MjQ0MTE3Njg1Nzg5MjMzMTQ2ODY5MTE2MDk5MTMxMDQ3NDczNDE0Mzg0MjMzNjA5MjYzNjg0ODQ5MjA2NjU5MjM5Nzg5MjYzODA1MjIxMjI1MDIyOTEyOTM1NTAwOTkzOTExODQzMTY0MzQyNTgzNjk0NDI4MjQ1NjY0NzU3MTU1ODM4Mzc1NTMxNTIzODUwMDgzMjg2ODUzNTgxNjE0NDI4MDA4ODY0NDkzOTY5NjMzOTE2MDA5Mjk2MzYyOTAxMjAwMTk1ODIwNTA2MzE2ODAwMFwiLCBcIjIyMjAyMjM3MTg3NjIyMTU1ODQ2NTkzMDkwNTk4ODAxMDYzMzQ0MjU1MTU4NzU2MTUxMDczNjkzOTk3Njc4OTIwNTE1NTE2MzQwMDA2MTQzMjcyNzIyNjAwODEwNTY5NzM4NjM2NjkwMDQyMjQ5ODE1NjE4NzAyNDYwNzgxMjA4NjIyNTYzODM1ODEwMTIxODM4NTIyOTE0NDQ0NjI3MzAwMTg1NDY3NTMxODMxNTY5ODI4OTczODY1NjM1NjE0MTg0MjQwOTM4ODMxNjQwMjczMDUyNTQxNzY4NzQ2NTM3ODA0MjU0NTI5ODcwNjY1MTI1NjMxNDA1MzEzNjc3NjY5MDA2MTA0MTQyNzc4MjUyNjIyMzkxOTk1ODA5MjU4Nzk0NTM4MDY0MTQ4NjA0MDk0NDE4NDU2MzExNTg2ODA3MjEwOTE2MjE0NjA3NzUwNDM1NjIwNjU4MTUxNzk2MTc1MzYvNTI2MzgzMjA2NjA3ODQxMjUxMjUzODYxODQxMzc0Nzc5ODAzNzk4NDgwNjIzNzIyNzYwMzY3ODQzMDcwNDY2MDQzMDMwMjI4NjYyMzQwMTU0MzA0NDA1MTgwOTA3OTQxMDc5ODgzOTc2MTY4NjA5MDgyMjU0MzMxNDY1NTk1MjY3MjA5MTQ5OTYzNzg2Mzg4NjAwMDI4NzAxMDczNDMwNzczNTgxMjI4MjEyNDQxNDI0NDAwNzQ4MjIwODMzNTQyOTY0OTcxNDk1MDA1NzE0NDgzMjM1MzU5NDc5NDcwNDUyNTkzMjY0MjgwNjQ1MzYwMTMxNDgyNzEzMTQ3MTE2MzY2NTAwMzAwMDY2NzcxMjIzMzgzMDA3MjE2MTgyOTg4MjYzMzU1NDUxOTIzMzMzMzE5MTcwMTc0NzU1MzM0NTk4OTczMjAyNzQwMTA4MDMyMDk3MjQyNDc1NTU0MTI4ODc1XCIsIFwiNTIxODkxNzk3MTA5NjI2Mjk2Njg0ODkxNDU1OTU5MjYzNzEzMjU3MzUzNTAwODY3NjUyMjY4NTQxNTM1OTQwMTU5ODE1MTUyMTIwODcxMTQyMTk2NTM1MjMzMzI2ODkwMzUzOTE0NzYxMjQyMDI1OTMxMzczNDkxOTA2MTI3Mjc1NTYxMDAyOTEwMTU3OTA5MzA2OTc5MDkzMjQ2NTc0MjA3MTA0MDgxMTA4MTg4OTk1MDcyMTA1OTQ4MTM4Mjk5MDk3ODQ4MTc1MDE2MDgyOTQ3MTc0MTU2Mjc4NDM5OTg2NzA1MjQxNTcxNjE5NzkzMDU5NTAxNzI0MjY5NjQ0NDQ3NTcyMzIzNTAxMjYxNDI0NzcwNzQzMzI5ODU4MDM4MDQwNjg1MzEzNjIxNDQ2NTI0LzEyMzMxMDI1NjgyNjg3MzkyMzc2NTYwNDgyNTQxMzIwNzQ4MTczOTg4NjM0MDIyNTcxMzEwODY0OTc1ODU3NTEwNjU5ODUxMDAyMjMzODQ4MDE4OTY0OTc4NzIxNjg0NTA0MTM4Mjg2MDg5OTA5OTI1MDU0NzY1NzUzNDk3MjE1NjMyODA4MDczNjE0OTIzOTMzMjMzMDE0Mzc3MTEzODExNTY5NTU5ODQ5MzA1OTMyNTA2NDExOTE3NjAzODEzNzI5NDg2MzA1MzE0ODYxODY1NjM1NjQzNjMzMjk5MTA3OTE1MDcyMzIzNTIxNDI3ODg0ODYwMjY3MTMzMzA3NjIxOTUyOTUzNTEyMzg0MjIxMjEyOTgyOTkzMTY1NDk2NzM2NzY0OTA3ODM2OTE0MDYyNVwiLCBcIjY2MDg2MDQ0NTM4MzI5Njc3MzcyOTg2MTE4NzI3OTk5NjIyOTAwNDcxOTM3NjE5ODkxMzM3NzE0MzU3NzkyNzY4MjAwMzQxNTE5MTkzNTAwMzkzNzM5MzIyODk0MDMzMzAzMjQ1Mzc2MjI1NTg0ODY1MzY5NDg2Njk2Mjc2NjA3MDYwNDMyNDQ5NzkyODkzMDI4MDYxODE3MjAzOTMyMDY4MDg1ODYzODAwNDk0MDU0Mjc0NDIzNTEyOTU2MTM2Njk1MjExNzk2NzUxODQ1Mjk1OTIxMDE1OTUzNTM4MzI5Mzg1MjUzMjgwODY2NjY5NDAzMTY5OTE5NjE0OTgyMTU1MzUwODk5NjQ4NjI2NDgxNDA1NzgxNTE0NDM0NzYxNTQxMjgxMjI5MTU5Mzk2Nzg3Mjg3NTUzNDkzMDQ2OTI3NDQ4NTk1OTY0MTAzNTg5MTAwNDI5NzIyOTQ4OTEzNDAzMDA4LzE1NTYyMTM3MzM5NDc0MzUwNTY1NjcxMjQwNTE1MjczNjY2Nzk4MDYzOTAxNTA0MDUxOTc5OTgwNDUyNDkxNjUzOTc1MjUwNjMwNzIzNjc3Mjc5MDgxMDU4ODg0MTYzMzk2OTM4NTQ4NzgwODU2MjkzMDM0Nzc1NDU5MjIzODcxMjgxMDQ5MDI2MTQwOTk5MDU1OTIzNzQzNDcxNDY2NDcxODMwNTcyNjcyNzY2NjMzMDg2MzQ3MzEyMTc4NzExNjQzNzI0NDg1OTU1NTc2NTc5OTg4MTgyNTQ2MTA1MDQ4MDQxNjQ5OTQ3Mjc3NjcyODY5NjEzOTkyMzM0NTQxNDM4Nzg0NzM3OTkzNzA2NDgyNzMxNjk2ODA5OTQzMDI3NTI4ODgyOTI3OTQyOTY3NDE5NDQ3MjUwNTg2OTY0MjU4ODA3NDU0MDAzNzc1NjkzNTY3MzY2MTY1NTA3MTQ0ODY2Mzc1XCIsIFwiMzM1Mzc3NjE1Mzk0MTAwMTQ4NzUxNjQ3ODM3OTY3MDE3NDY3NzExNjEyMjk3MTcwMDc5OTQ5Mjk4MzI4MDYxMTU5NTU5OTM5OTY5MjI4MjI2NDc0NjE1NzExMDQ0ODkxMDg1NjI2NTE5ODc3NjM0ODQyNjk0OTgzNjY5NjExOTc0ODA3MTI5MzMzMDUyNDcxNzk5Njg3NDI2NjY1NTU2NzM4MzE2NjI2MTcxNDA4MjE5NzMwODUzODcyNDEwNzkyODMxODcxNTI2MTc0OTg3NDAyMTI5NjkxODk3NDMzODg4MDI3MDcyODA3MzAyNDExNDc0NjkwNjEzOTQ4OTUxNjczNTYyNDczNzU4ODE0NjY0MzQ2MjU5MTA5ODg2ODc2NTM4NTEwNDUzNDc1MjkwOTY3ODM1Lzc4NzE1NTkyNzUyMjcxNDYyMzA2NTg4MzU4ODgwMzM3MzQ3NjM4MDAwNjA1MDMxMDAwNTc1ODc2MjE0MTE2NjEwMzM5ODI3NDk1MjYxNTEyMjgxNjM1MzYxNTY4OTUxNjc1MDM3ODM0NTQ0ODExNTc1MDI2NzE4MTAxMTY2NTYyMDcyOTE3ODU1MDA0ODIyNjA2NzUyMjk2MjMzNDM1MDE3Mjg0MTI3NTk0ODQ3NjU2NTI5NjA2NjQ4MzQ1NTMzMTk1NDM3NjM1ODk0OTQ4ODI5ODU3OTEzNzk4MzM2MzU2NjQ3Mjg2MDMyMzcyNjk1MTMwNDYxNTczOTQwNTAwNzg1MTM3NDI0MzY1ODQwMDgxNTAzMTMzMTU3MzA4Nzk2NTA1NjIyNDM5NzkxNjk4MTE2NjA4XCIsIFwiMjAwOTA4Nzk3MDE2MTg3Mjk2MDI1NTQxNzA3MTY3ODA5NzA4NDg5MjUwMzk5MTc5ODc5NDU0NzEzMjI5OTQ4NjcxNzE2NjAzMDc5OTg2MDM1MTU3NDUwNjY0MTE2ODc5ODM0NTA0MDA0MTI3MzkyODU1NzcyNjk3NTE2MDM5MjExNjM4MzU2MTkyOTY4MjI4MDE4NDAzNDgzMTk3NDIyMDM5NzQwMjM1MDUxODYxODcwNjAyNTE1NDQyNDg2NDQzMzg0MTI2Njc2MzEyMzIyNDcxMDg2NzU1MDQ2Mjk1MzgzMTk0MjU3Njk0NjQyNzczMDk5MTU1MDIxNDQ0NDM5NzMzOTczNzExMzYyNTYxNTEzMzYyNTUxMzg1MDYwMDEyOTIzNTUzMzA4NzUxMTQyNDU5MDE4MjA0Mzg4MjE3MzI4NDM1NDA3MjUxMTY3Mjg4NjYzMDEyNzE0NjY2MTQ3NjI0OTcwMjQvNDcwMDIyMzUxOTQxMDUyODg1NzI5ODczMjA5NjcyOTQ4MzU0NDgyMDg0MTQ5NzgyMDYxMTc5NTYxNzkyMzA2MzQ0MDk0NjA5NzMyNjgxNzM0MDYzNzMwMzQzMTI4MzAwNTUwOTkwNDQ4MTMyMzIwNTQ4MDcyOTgwNjg3OTU3MDQzMDg2ODg5NzM0MjM5ODc4MzAyODY0OTYzMzk1MTM2MjM5ODE5NjEzNzQyOTA3Njg0NDUwNDUyOTA1MTA3MjM5MzcwOTE1NDQ4MzY3ODM0OTI3MjkzMDM2MTExMDU2ODYxNjExMjcyMzc0NzcyNjg1MzYxNDY2MTk1MzUzNzk1NzExNzIzMTkwMDAzMjA0NDIyMTUzNTUwMjc0NTY3NjMxMDMxMzU2OTk5NzY2NTM1MjI1MjQ5MjU2ODEwMDA3NTE5MTkwMDk2OTE3MDk3OTQ2MDI5ODE4OTE3MDQ4NjYwMTUwMjYyNVwiLCBcIjI5MDQ3Nzg5Nzk5ODU1MjQxNzEyMDY1NzMwMjg0NDUzNzk4NzIyNDA1NTgwODQyMzY0NjQyMDA4NTc1OTQ4MTQ2MzEwMzE1ODEzODc4MDQ2MjEzNzE4MjIwNzQwNjEyODkzNjMzNzI1MjMzNjQxNjcxODQ2OTc3ODU1NzAzMjQ4MzI4MTU5NzI5NzA2NTg2MzM1NTE4NzkxNDMxODc3MDk3MDcxNjQ3OTY2NjMwMTUxODA4Nzc0MTI3MTc5MTA4NzIyMzQ2NDc3MDQ1MzY4MTcxMDg2NzY3MzY2NjE4MDQ4NzgwNjgwNzg1NDMyNDEzOTA4MjgyMjk5MjM0MjQxOTEyMDQ1ODYzMTM2MjA2MTI1Mzk2Nzg5MzA5OTk3Njk1NDM3NTYyMTg3NjU4NzA1MTMwNDk5ODY3OTIvNjc3NDA4MDk5MDQ0ODIzNjQxNTgxNjU4ODY5MjIxMDQ0Mzc1MzEyMDc3OTI5OTc2NzE5MTgzNDI0ODY1ODM0ODExNTQzNzM3ODAwOTU2ODk2OTI2NjM3NjI1MTY2ODQ0MzcyNDI0MDQ0MDAzOTI5MzQxMzYxNzM0ODg2MjMyNzQyNzcwOTA5NjgzMDIxNTYzODIyOTg3NTA1MjM2Mjk1NzI3NDc4MTU5OTM4MTM1NDY3OTc1NTIyMzM2Nzc0NDcxOTE1MTY3NjA2NjczNDg5NzIyMTAyMDc3MDQxMzMwNjUyMTg1ODExMTk2NDIzNDAwNzAxNzk1NzkxNjY5NzgwNjk1MTU4NzMwNzU2MjQxMTc4MjYyOTYyNTE1OTE3Mzg5MzgyMzAyNzU3MzY2MzI1NzY4MDY5NjI1XCIsIFwiMzEyNzAxNTU4MDkzMjk3NTE4NjM4ODUyMjQ3MzI0NTQzOTcyOTIyMzA5NjkwMDIwMDQ5NTM4MzIzNTQwNjUzMTk3MzU1MzA2MjQ5OTYyNTQ2OTU0NTMwNjE4NTE0NDk2MDAzNDU5Nzc2NDY0NTUwNzI1MTI0MDA3NjA1Mzk3NDcwNTQwMDM4NTEyODk1NDAzMzk0MjU4NDg2ODE4MDQxOTAyODQ0NTEyNTM0NjI2NjM3MzExMzUzMzc3NzUwODgzNzk5NTQ0MDM3NDAwNTgwODQ5NDk2NzU0NjA0NDU5MDk4MjYzMjIyOTc4MTc1MzU0MDA2MDQxODAzMzgyMDEzMjI2NjcxMzkwNjI1MDAyNjkyODU0OTM0MTc1NjMwOTUzNjU4OTk2MzEzNjA5MDE3MzI2ODQxMjQ5MzAyOTY2NDMxMDg1NTE3MTA3MDQ3ODU5MDY0MzEzMjQ4NzYwNzI0NzAyMzE0MjQvNzI2OTU3ODAzODAwMDUwNDAxNzA3MzAwNzk3ODg0NDk5MjMxOTk4NzQxMTczMjg0ODU2NzExNjY1NTgyMTE5NjY0NDM4Mjc3NzA4ODcwMzIyODk2MDAyMDg5NDc1NjcyMjY3NTg4NzQ3Mzk3NzQ4MDUzNzU3NzUwOTA2MTI1NjEzODI2MTA2MzkyNjg0NTY0MzM2MDg0OTIxNzU1NjM3MDg2ODc1MjkwOTUzMTA4ODM2MTIyOTM3NDQ2NzIwNzE5NjkyODc0NTY3MzQwMjM4MDQ3MzcyMTAxODE1NzMyNzE5MzUwOTU4NjI5NTg3OTA1MTQxMTE4MzY1NzE4NTE3NjgxMjczODIzMTQ1NjI1MzMyMTE4NzQxOTIyNDcwNDMwMTIzNjIwNTQ3ODE4NDExNTk5NjEzNTk0MDg0ODUwMzQ4NzE5OTM5NDYxMjYxNjc0Mjk2MTEwODY4NDUzOTc5NDkyMTg3NVwiLCBcIjQzMjUzODgyMjA3OTcwNzc2MDM4MjA5NDEyMTAyMDQyMTczNTY3OTExODgzMDM2Mzc2NDU3MDY0MDc4OTM2ODIzNTQwNzg1MzE1MjM4MDMyODg5MTM1MDgxNjQwMDU0MTE4OTE0ODU1MDM1MzMzNzg3NDMwOTg4NTMzNDkyMDk5NTcxMzE1NDIyNTc5OTY2MDYwMTM4OTc4NDQxMDkxMTY1ODk2NzQ5OTEwMDYxMDM3NjA2NTY0MDc4NTU4NTM0MjAzNTA1ODM2NDY3NjMxNDA4NDU5NTI4Mzg1MDIxMzk0MjU3NjQzMTMxMDgyMzgzNjc5MjQ0MDIxODI3MTg3OTM1NDY2OTI5MTA1MjU4OTgwNDk1NjQzNTc0MzUwMDIwNDE4NTEwNzIxNTkyOTg0OTA1NDc4Mjg5MzExMy8xMDAyNDY1NzQ3MzkzMjYyOTEwMzU4MjQ5NTQ2Nzc1MDI1OTEyNzkzNDMzMTEwNTE3MTkxNTEzMjcwNjYzNDEzNzA5OTUzOTA0MjM3MTM0MDM3MzkwNDMzOTY1MDM3ODUyNjE5MTc3NzE4NTkyMjA1MzU1MDU2OTE3NjA0NzIzOTUzMDY1NDMyNzYzMTQ5MzgyODc4Njg3MzQwMDk1ODI5MDY4OTU3NjMwNzM1MTkzNzQwOTkyNzIzNDA1Nzc5MjE2NzEyOTg4Nzg4Mzc0MDA5MjEwNDUyNTIwMzU1MDc5MjUwMjE5MDQ5NTQ0NDUxNzIzNzI0Nzk3NDQ0NjU2NjY3NjA3NjI5MDk3MzEyMzc2MzQwODIwNTE4NTU1ODgwMjU3MzI0OTQ0NjE5Mzk5ODA4NTY5ODM1NTIwMDBcIiwgXCIxOTE0MzMzNjczNjg5MjA2Mzg5MTE2OTQyNzg5MTE2OTE3NTc5MDg4NjY0NTExMTE4NTgyNjEwMjkzMzgzNDI4NzEyOTAyMjExNjEyNTU0MjEyNzc5ODgwNjM4MDY1ODg4NTE4NDg4NDkyMjk4NTg2NjQxOTk3ODQ0MTQxNTEwODMyOTQwNDA5NTAxNjk0NzI2ODUxNjY2NDc4NjUwNDE0MTkxMjQ5NTM0NzMzMDg3OTMzODc5OTgxNzMzNTYxNTY1MjQ5ODE4NTcyMjA0OTMyNzE1MzQ3NzUyOTQ5MDg3ODAwNzc4NjQ2MDY1OTg2MjQ0NjU3MjYwODMyMjM0NDc5MjAyMjAxMTI5ODQ1MTE3OTU1OTU3MjQyNjE2OTQ3MzYxMDE2NjAzNzAyNjQwODIxMjU2MDk5ODk1NDY5MDg4MjI5MzM5MjQwNDAyNDc4NTc2Mjg1ODU0NzgzMDYzNjEyMzA3MjAwLzQ0MjMzMzgwMTA3NjI4MTc1NzI5ODExNzc4NDUyODk2MjgzNzExNTMyMzgzNTk2MjQ2MDY2MTYwMTkwNTEzMTYxODM0MTYwOTM3MTY0OTM0NzEzMTcyNDcwMDE5MjU1MTU3NDYyNTQwMDcwMTQ4NzEyNTk4NDM1OTQ5NDgwNDgyODkzNTU3NzEyNDYwMjYyMjU4MjU1MDYyNjMzNjk4Njg3MTc5MTQwNzM5ODYwOTkxNTIwODExNDMzOTAxMjM3NDQ1Njc4NTcwNTE2MTk5NDM0MzM0ODM1MTQ3MzM4NTg4Nzk0OTgwOTA1MTc5NjQwNzM0MDk4ODczNTg1MzgxMDE3NDU4OTI2MTMwMDY4MTAzMDgyNjM5MjY3MjI4MjYzMDYxMzM1NDQ2MTkyNzIwODU3OTk5MzA0Mjk2ODUyMDY1MDMxMzYyMTUyMjkzMzIxNDA2MzM2NjU1ODcwMzQyMjc1NzA3MVwiLCBcIjU3MDQ2OTE2MjY0MDIwNzIyMTMwMDYzNTQ1NDUyOTIzNjQ3NjEyNDY4OTM5MTk5OTc1MzEwMjQ4NjE0MDgyNDg3NDYyNDE2MTk4MTc5NTU4MjQ2ODI2Mzk1ODI4MzA0ODY3OTA2MTg2NjgyMjE1MzAzNjU0MjYyMDM0MjQ4ODg3Mzc2NTg3Nzg4ODE3MjEwNjM5NDE0OTUzNTAyMzc0MTk3MjM4NTUwMDA1MTU3NDc3MjU5MjY3MzUzMTk0NzE0ODAwMjcyOTMyMTA5OTE4NjkyNTU5NzEzNjU1MjIxNzA3NDk1Njg5OTY2NTE0MDYwMDIzMTEwMjA4ODM2MzU1Nzc1OTAwNDU2NTAwMzc1Njk5MDYwMDE5MjQ5NzEwNDE4MTA1NDc1NDMxNjMzNjM5NzY0NjQ3ODA3Mjk5MzIvMTMxNDI0MDM2MjA3Njc5MjU5MjY3MTc3Mzg3Mzc1NDc1NzQ0MzI3NjI1NjIyMzUzMzMzOTAwNDMzOTMzMDU1OTMyNTc1NDU3NDAyMzYxOTY5ODE3MTIyNTc3NzU4NTQwODE2MDQzODgzNDQ0OTU3NjUyNjk5NzA1NTY0OTg0OTg3NTUxNjMxMDEwNTI5Nzg5NDg1NTI2NDAzODQ1MDU4NTI5NTQyMjM0MzQ1NDQ1ODU2ODE1MjY2ODk4MDEzMTk3NzAwNTgwODg0MDE0MTA3OTUwMjQzNjM5MTkwOTM0OTE4MjE4NTU5NjM4MTUwOTA5MTQyNzc1MjE1MTg2MDIwNDIzNTA3MTEyMjc4ODQ5OTk5Njk5MTA3ODkzNTIxNjY4NjAxMDg4ODczNDQ3MTE3MzEyNDQ4NzkzNzg3NVwiLCBcIjQ1MTIxOTM2NDA4NDM4NjIwODcxODQ1NjE0MjMyOTQ0NDAyMzMzNzM0MzQwOTI2MTU0NTQ0NDY0MzAzMTAxNDc2OTQ4NDA4NTI3ODQ0MDYxMjY3NzgxMzY4Mjg5MjkyNjg1MjQ2OTU0MDExODYyNTczODIzODEzNzQ1ODMyMTExMjAwNTE4OTU5NTcwMzYxOTE3ODUzMzI2MzcwNjgxMTY4OTY4NzIxMzEyODg4NzA4MjE5NzMzMDEzNzUwMjA2NDI2MDEwNTM4NzUwMDU1Mjg1Njg1MTk3MjEyNDE3MjIwNjk5NjIwNTkxOTU1NjU1MzI0NjEzMzIxODQ0MTc2OTMyNTEzMzcyNTYzMTY2NTU5MzM3MjE4ODc1NTA5MDA5NDU0MTQ2MjQ3NDk3MDUyNTgyMDMzNDM4NTA1ODMzMzc1NjU5MTIyMjQ5MjgwMTY0NzExMDU5NDQyODkyMjA0NjY0MTk0NTI1OTM5Mi8xMDM2NDgyNTAxNzIyMDMzNDA4NjU0NTgxMTU4Mzk3NjQyOTc1NTg5MjU2OTMwNjE3OTgxNjk0MzQ1MTYwMDE3NzUwNjg3Njk5MTE3NjgyODEwODQxODg4ODMyNzg4NDI1NDY3OTE2MTIxOTkwMjU0MTM1NzMzOTQxNjc2Mzk5MjUyODcwNjg4MDk2MzE5NTgwMDY2MjI4NDI3MTY4NjkyMTEzNzQ1MTMxMzY3NjY4OTk4Nzc1MDQxMzY5MjkxNzcyNjczNjI4NjIzMTk3NDg1MDczNzIxNDcyNDM5MTE1MjI2Njc1OTEzNzUwMTU2MTEzMTIxNjU0NjQ1MTQzMDg0NTEyMjIxODAyNzI5MzUzOTg4MjgwOTI2NDYzOTM4MzA1NzI4Mzg3NzIwODUzNjY1NjcxNTQ2NDY0MjU1OTgzODg2MjAxMDU1Mzk2MTkxNzQ4Mzc0ODk1MzYzNzg2MDUxNDQ4OTE3Njk2MjVcIiwgXCIxNTkxMDc2NTY0NTc3NjM0NTc1NzAxNzkxMzkzODQyNTM1NDYwODc1NzMzOTc0NDY0ODA1MTk3MjgzNjMyNjcwMDEzNTE2MTgzMjgxNTQyOTAzMzc3NzUwMzA0NDE5OTk2NjgxMjIyNzU4NDAxNDk3MzIxMjc4NTU1Njg2NjYxOTgxNDM1NjM3NDYxMzUwMzIwNDcxMjU4Mzg2Mzg4ODQzMTk4NzA2Mjc3NjU3MjA4NTI2MzcyMTAwNjk4NzAwNjE1ODM1NzMzNzEyNTE5MzMyNTQ4NjA3MTE1ODc1Mjg4Nzg3NjAyMDg0MzM2MzQxNTk0NTc2NDI2NjMwNjcwOTExNDc4Mjc2MTAxNzAyMTE5OTcyMTk1NTU4MzE0MzU3OTc1MzY1ODYzODAzMjY1MTYzOTkxOTYxMTczLzM2NDQzMzEwODQxMDE5MzM5Mzg0NzIwMzM0ODcyODk4MTI5NjI4NTc0MjIwMjYxNzk4ODk3MDM4NDI3NzE2MjIyNTg0NzI1NjI5NTg2NTU1NDM0MTYxMTE3MTQ2MDQzNjM2Mjc4MDQ5NzE3OTA5MDMyOTgzMTg4NTg1MzMyNDM5MjkyMzQ0OTU3OTUzODI4NjgwNDcyOTg1NjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCBcIjUzMDc1MDcxNDg3MDk0MzU4MDcyNjEyMjkzNDUxMzI1MzUxMzQ4NDgwMzAzNDM5MDEzMDAzMjQ2MjM0MDk3MjE2OTgyMTcxMzQ5MzI4NjY0ODg5Mzc3NzI5ODYzODY1MDE1MzgwMjY2OTM5NTYxMjExMjE3NzEwODk3NDAwOTU3NjA0ODYzNjI2NTQ3NTQyMjk5MDQ2MzM0NzYyMzQwOTA3OTI4Mjc5MzA0MzM1OTg0NTMyMDA1MzY1NTE3Nzk3ODkwNDkzNTIxMzEwMDUyMjI2NTk5OTU4NDU0Mjc2ODA2ODY2NzczMjQ5NjMyMjM2NTM5NDkyNzcwMzc1MjA3MTE2MDkzNDMxNjY5MjY2Mjc3MTM3NTg5OTAzODQwMTEyNzQ3NzcwODc5Njg3OTk3OTM0MTA1MDYzOTE4ODQ4NzI0NTY0MjAwNDE0OTQ1OTgyNzM3MDM5MTQ2ODk1ODY2Mzc5OTUxMzk1ODA3OTQzNjgvMTIxMjI0NDI5MDM4MTUyNDExNTA4MjAwNTU3NTEwNTcwMzQ5NjU4MzMxNTE4ODU0MDE3NzcwMjc4MDIxNjU3MDI2NTE1OTkyMzY1NDE5Nzc0NjM4ODU2ODE1MTcwNjUwOTI0MzYzODMwMjcwNzUxMTIzODUzOTg0NTUzMTYwODMxMzMzNDI0ODc4ODk4MDE4ODA1NDY1MTYwMTUzNjA2Nzc0MDcwOTk3NzY3ODIyMjc5MDQ4MTM0ODAwMzA4NTAzNDg4ODI0NDQ0NzYyNjM0NzMxMjA5NDU4NjM4OTM0NzUzNTE2NzkwMzQwODUxOTAyNDEwNTc0ODUyMzM4NDkzMjk0MjQ0MTg0MzExODgxMzgxOTc4MTM0NzA4OTcwMjI4NjQ4MTkyNDQ5MzM2MTA1ODMzOTczMTk0OTg0NDYyMDc2MzI3Mjc3ODk2MDg2MDUwOTU3MDYyMjY3MzA0ODc4Njk2ODY2MDEyOTY1MDEyNVwiLCBcIjMwNDY1NzcwOTg4NDM1ODA1Nzg2MTk5NTU2MDMwMjkwNzMzMjgzNjEyOTg0MzYxMjk3OTE5MzEzMDQ2NjU3NzcwMzYxNTI5MTU4NTg1NzUyODIzNjI3NDIwMDgxMzY3MjEyODQ4MTc4OTk1NDI0NzU2NjYwNTQxMDE5NTc4OTk4NTgxMzg1OTA5NjM3ODkwNzI1MzA3MTA3NzU3OTA0MzM0NjY4NDcxMDA0MjI4NzU5MDY4NjY0OTYzMTg4MDQ5ODYyMDIwODk1MjgxOTg5MTIwOTgzNzc4Mjg1ODAwMzE4NTIxNTI5OTc5MDc0MzMzMzUxNzYyNjczMDAyODY0NjYwNzI5OTcwMTQwMjMxMjAwODc5ODg3NDgzOTY1OTgxNzY2MjI3NjU5MjMwNTkzODU4NzY4NTUzMDM5NDA3MjAvNjkzOTExODU5MDc3NzUyODk1OTc4ODMzMjQxMzM4OTAyNjk1NzU1NTI4NjEzNzI5NTA4NTU1OTM4NDE2NDE5ODY0NzcyMzg1MzM2Nzc3OTI0ODkyNDM0NzAxODA0MDc4ODkzODIyNDQ2NzI3NzYyMDc3NTM3OTU1MjQwNjA1OTI3NTUwNTQ4MDQ2MzA5ODIzMDUxODQxMzI2MzU1NjU1ODQ4NDA2NjQ2MjQ4NTk1NjI4NzE1MTg1NDEzODUyMDQwMjk1NjMxNDQ4MjUwNDU5MDc2MDQzODE2MzI4MDgyNTYxMjQ4NDIwOTI1OTMwNDMxNzc3NTAyNjIyMTQ4MDE5MzcxMzgzMjU0MzE2NjM2OTc5MDcwNzMxNDI3NzM3NzY0MTYwMTQ1MDk3MjkzMjYwOTM4OTc4NDEzNDg4ODE5XCIsIFwiMTU1MzEwOTI2NzQzODczMzQzNDI2MzEyNjA3MTgyMDYwMDcyOTM5MDMwNzY1Mjk3NjMwNTM0NTQ0ODk5MjMwMjEzMDU0NzE0NDgyNDU2ODI5MTk4NDg1OTk5NzgyMDg2OTQ0MjcxNDkwMjI5NDEyNzA3OTgwOTk3NDMyNTI4NjUzNTA5OTQ1MzAxNTc0Nzk0MjQyMTE4NDMzODY4NzQ3MTcyMjc5MjI0MTE4NTM0NDYwNTYzNDAwNDQwNjcwMDE1MzIzMzI0NjAyMTE3NTE3MzQyMjAxNjQwMDE2ODUzOTI3OTIzOTc2Nzk2NDUzNTc3MDQ4OTk1MjQzNjAwOTY3MjAyNDYyNDY2NjgxMTEyODA0NDc2NjcyMzQ4MjA2NDkxNDkwNTEzNDE5MzM2MzA4NTc1NDQyMDg2NTExMDE1MTAxOTk5ODQ3ODk2MTk3NTQ2OTAwNTEyNzY0MjMzNjc0NzQ3NDE1ODQ0MDQ1MTg0LzM1Mjc4MTYyOTg2NTg5NjU5MzAwNjc5MDg4NTM4MTc2MDcwNjQ5MjczOTkxODY1NjYzMDQxNjE2MDg4ODUxOTIzMTExMTc1NTE4NDA1MTE3MzkxMTM0ODYzNjQ0NTQwOTExMDA1NzgyMzcyODMxNDk2MTIxMzU1OTU0NDcwNzQ0MTY5OTY5Nzc0NTQwODkyMDk2MzIwOTc4Njg2NTQ4Mjg0NTAxMTM5ODYxNzgzMjkyMjI2MTQwNDEzNzY5NjY1NDYxNDk0NjY4NDc5NDMwODMzODkyODU3OTkyNDAxMzkxMjYyOTAzNTgyMTA5OTkzODM4NzI4MjgxOTE1ODA2Mzk0NzQ3ODMzNTg4NjI5NDY3NjEzMzA4ODM3MTk2MjY5NDI0NDIxMTMxOTM0ODU5MDc5MjYwMTg1MDUyMDgxNTM2NDg3NDYyMjU3ODA5OTg3MDAyMTk4NDM3MTgyNTM5NDQxMzQ5NDc0NDI2Mzc1XCIsIFwiNDY3Mjk1OTEwMjU2MjE4NzQ3ODI3NTg1MTkwNzQ0NTE3Mjg0NzYzODY2NTc1NzYwMzYzNjA3MzQzNTg3MTk5NzY0MDA5NDAzMDE0OTM5MzkxOTIwODMzMzkyOTM3NzkxNDkxMjcxMzI2NTE2MTY5NzI4MTcxNjUxNzIxMTYyNjkzMDcyNzY0ODcxNTgwNjkyOTMxMTQ4NjAzOTE1MDI0ODQxMjU1NTQ0MDY5NDUyNDk3Mjg4MDI0ODQxMjg3NTY5MjQwNDQ2MzM4MjU2OTI3Nzk3ODM0MjU2MjgyOTI5NTkxNzA1OTcwMDk5MzUzMDU0MjkyMzk3MDI5MjY4OTg5MzE5NzUwMjM1OTg0NTYyMDcxNjUwNjc1Njg5MTk3NTc5MDI3NjQ4MTUxMDg3NTE3MzU3NTM0MzExNTM1ODE4NDkvMTA1ODU4NjgwODQwNzkwMzA4Mzg2NTEzOTA3MzgzNzExNDExNDIyNDUwODY0NjUwMzM0NTk2NDA0NTgzNjYxNDY4NDkzMTQyNzQyODU4NzEzNzU0NTk4OTgwMTQ0MTQ4MzMyOTU4MDQxMzk5NzkwMTYzNjI3OTYzNTcwNDMzNzIzMTYzMjE4NzIzNTc4MTc3Mjc4MjE1NTkyMzIzNTM5OTM3MTQwNjI1MzU4ODMwNzQ2NjE3MzQ1MDk0NDA5OTQ2NjQ3MjY0MjUzOTk4ODA5OTUxMzM3MTEwMzg0ODM2MDc3NzM3ODI1MzI0MzA4NzkxOTY0MDU3OTM2OTQ2NTgxODUxNzU1ODM2OTExODA3NTc3ODM1OTc4OTU2MTY5MjA0MzI1MjcxMjU5OTMxMTgxNzEzNjExMTY2ODQyODgwMDBcIiwgXCIzNzM2MzcyMzQ4MTI0MTQ0NzIwODUyMTkwNzY5NzEwMTI5NDYxMTQ1ODg5MDExNTk4NjM2OTI1MjI4NjU3MzkzOTM0MTMyODI4NjMzMTMyMzU3MjMyODgzNDcwNDY2OTQwMzMwODQ4MTc3NDI1NTQyNzQ4MTAwMjExNDk4MTg0NDk0MjUyNzE0NjE2Mzc5NDUwMjcyNjExODUwMDY4ODY3ODE2MjUwMjA5ODY3NTMwOTIxMjc4NjQ1Mjg2NzY5NDE4MDgwMDE4NzA5OTQ3ODI2ODc2NDYxNDE5NjU0NzgyMzQxMzA5MTI3NzA5NzAzNjI2NDAxMjExOTk2MjU1NzQzODMxOTk4OTE4ODk0NjYxMDUzNjY5MTg5MzEyMzc1MTU5MDU4NzE4NzY3MDgyMTYzMTU2OTg4NzY2ODIxMTk0MDAyNTk2MzMxODI2MTUwMzIxODY0OTI3ODMyNjE4MTI2NTgwNTA5NzMyMzU5NDI0Lzg0NDE3Njg1MTAwNzUwNDAwMzYyNzAxNjk0NTIxMjAyMzIzOTMwODM0ODQyODA5NDAyMzQzNzI2OTUzMjc0MzIyMTkzNzA2OTM0NTY4MjkwMDg4NDYxODM3ODg0OTI4MzAwMjk5ODIyMDUxMzMwNzI3MzMzMzA5Njc3NTY2OTU1NjA5MzAwNTYzNzYxNTAxMjc1MDczMzIxNjQ2MDQ1ODY4OTI4Mjc5MTYzMjQzNzg1MTM2NDY3NDg3OTE1MjY5NTQzODU4OTY5MjIyNzE1OTAzODU1NTcyMjUzOTM0NTk3MjgzMzE2MTE0NjEwODM2NzMyOTM3MDU2NDgzODY3MTc5MTI0MTQzMTEyNTAwMzQwMTg2MTg4NzQ3Nzk2OTk1NDc0MDU0NDA5MjE3ODcyMTMyNzcyNDYyMDQ1MDk0NzY0NjIwOTkxNDYyMTAwNzE4NjQ5NzA4MTQyMDM4NDM0NzQzODgxMjI1NTg1OTM3NVwiLCBcIjEyNTg3NzQ3NTU4Mjg5OTEyODE1Nzg5NjgwMjMzODI2MjQ3MjM3NzI5Mjc2NDIwMDIwMTYyNzA0ODQwOTA0MDkwNDM0NTQzMzYwNDA4NTc5MjY1ODEzMTY5OTQ1OTQxMDkxNjkxMjMzNTQ1NTMzMjE0Njk1MDA4NDgxNDYwMTU3MTk4NTE2MDkyMjA0MjM3MzYxNTMzNjUxMzk4MDQwODY0MTMyODQ3ODc1OTgyNTM2MTgzNjE3NjkxMjU5OTY3NTUxNTk1NzE1MjM2MzI3NDcxMjk0ODAzODcyNTQxNjQwMDg5Njg5OTM3MzQ0NDIxNjQ4OTI0ODY0NDExNTIyMjc0MzMyODE2MjUzOTE3NTM3MDI1NzcxNDM5ODUwNDc4MzI1MTkwNjI1OTUxMjMyNTU1NjkxNzI5Njg2ODUwNjA4NDQvMjgzNjU5ODU5NjYxNjcxMTgxNTI2NTQ3ODMzNDE1NjUzNDUzNTA2NDc3OTUwNjc4NjUxNjc1MTkzMjEwOTY5MTczMTMwMTE2MTIxMDE3NzIzMzYwMjU4MjQ5NDMwODg0MjEzMDExOTg4Njc4MDExMzU3NDU4NzI3NjAzNDEzNTIxNjg4MTg0NTIxNTczMDk0NzgzMjkxNDk2MzY4MDA1Njk3NDgxMzMzNzM5NTA0NDkwNjQ3MTk0NDU0Njk1NTA0NzIyNTQyMDE0ODQ1NzA2MjE2MjI0NDMyMzczNDQyNDM4MjQyMzU1MTg4NDYxOTUxODgzNDU0NjY0NjkzMjYyNjg0ODczOTg4MDYxMDE4OTc2NzExMjAxMzUxMzgyMTYzNTI3MDkzNzg0NzUzMzk4MjU3MDk0NDI5NDAzNjkxNjI1XCIsIFwiODQ5MzIwNjMzNTUyOTI4Mjk5ODg5MDg5NjExOTI1NzQ3MTA0OTMwOTg4OTcxNDg3MDE0NzMxNzI3NTQ5NDk4NDY0NTU2MjYzODEzMjk0NTY2NjE4MDg1NjYzNjUzMjkyNjY4OTg5OTA4MjkyNDc0NDYzNTY5NzA0NTQ1MDIwMDcxMjcyNjk3MDg0ODc1NjMyNzk1MzY4MjUyNzczNzQxMzM2ODExNjcyMzU4MTEwODAyOTgxMzQ4OTk2Mjk1ODAzMTg4MTMzODI2NjgzOTk2NDQ1NTMxMTEwODA2MjU5MTgyMTMyNTAyMjMxOTc0NDA0MjYxNDc4MjEyMjU1OTMzMDQ5OTM2MjE0NTEwNTMxMzUzMzI0NTE5OTc2MzMxMzI3NzI2MDgyMzM0MzAxMzE0MDAxODY1NzE3OTM5MjkzNzcxMjkyMTEyMjg2ODk3MDMzNzYwNjc3NjM2MjU1Njg2MjM1MzU1ODg3MDk1NzYzMjAvMTkwODk5NzgxMzMzMjQ4NTI5MTA5NTA0Njk2NTg1NjY0NTgwMzcwOTYwMjc3MjIzMjY3MTY4MDAxMTMxMDc4NDgxMTUyMzE1NjM3ODc0NTU1ODQyNzgxOTM5NTQ1MTg0NDI2MDE4MTA3NzYzNDcwOTEyNTM1NjE5NTY4NzcxNTU2NzM1NTA0NTg5NTU1NjIxMDI5MzU1NTU1MTAzOTI5NTQ0MjUxOTYxNjU3ODU0MTAzMTkxMjYwOTgzOTMzNTM4NzgyODY0MDA4NzczMDUxNjQ4Njk1NDgzODA2NzAyMDQ1Nzc1NDQ2MzAzNTM4NTkwMDkxNzcwNTE2OTgwOTYxMzY0NzAwNzIxMzc1Nzk2OTg0NzMwMTcyNTczOTc5NDk5OTQ3MjIwMTUwODk3Njg3NDUwMTM3MTMzODM3Njk3NjU2MDk2MTM1MTQwMjEyMDA4ODg2NDc0NzI4MDQ3MjA0NTY0OTQ3NTc0MjMyOTk2MjdcIiwgXCI4MDI2Mzg4ODE1MzA4MzI0MzE4MjgyNDk2MDQwNDA1Nzk3NTA5MTYxMTg0MjM4MzM3OTE2MDg1ODk1NjA0MDI0NDkwMzY5MjAxNjU3MDQwMTIwNzAzNDk1MzcxMTQ5MjA4ODI5Mzg0NjY2MzU1OTg2MDIzODc3MTgzMDAwNzQ3MzM0NzYxNTA1NDg3MjQ3MjY0NjAyMDkwMTY4MzQ0MTYwOTQzMTc3MjQyNjE4NTc5Njk5NTU0MTQwMDAxNTU4MDczMTI4NTIwOTI3MjAzMTAxNTk1NzI1NDc2NDQ1Njk3OTc1MTIyMzM4OTk0OTUzMDAwMjgxNTk3MjEzNDg1OTk4MTYwODMxNjY3MTIzNjUyMTUwNzU3Mjg5NjgwMDU5NDE2MTAwNTYwMTgwMjM2MzMyMzUzNzI5MzY5MDMwMTU3NzE1ODMvMTc5OTUxMTk3Mzg2MTE5MDc5NzMyNDM4NjE3NDA3OTIxNTM1MDY1MTQwNTAzMDQzNDI5MTc0Mzk0NjA1NjUyOTEzODc5OTgyNDg2MDUxNjI3NzYwNjUyMTk3NDg0MTQyNTQ3NDQ3MDAwNTA4MTg5NDU1MTI2NDkzODY4MjI5NTY1NjQ3Mjg0MzMyNzM1NTUyNDYyNTI1NTk4NDY1MTkyMDczNTU4NzkzMzM1OTEzMDA1NDU5MjY2OTc3MDg2MTA0MzU5NjIxMDIyNjkxOTMxMDAyNDg4MDUyNzI3NTk3NTEzNDEzNDkyMzkzNTI1NjYwMjcyOTAwMTYxMzc1Njc3NDk5MjI4MjUyODYzNTI5OTM0NTc2ODgxNTk2Mzg0MDM2NDAxNzg0MDM1MjQ4NjQ5MDI2MDc2NTgxMzAyMzcwMzA0MDAwXCIsIFwiMjUyMDg3NDIzOTkzNzUzNjI4ODEwOTk4MTEwMzIxMzU1NzUzNjAxMDk3MTU5NjQwMjQ3NDcyMTIwMjYyNDU1MjkwODc1OTk2MzMyODAxNDIzMTQ5NjI1ODExOTMzMDM2ODM3NTk2MDUwODQ5OTU4MTgyNTMxMjQ0NDU3NzMxMTU1NzQ0NzA3MTcxOTkyMTg4Mjg3NTY0NDkxODcwNTU1Mzc4Nzc0NzgwMzMxMjk4NjI2MDA5ODIwNjg3ODIyNDk5NDMxNTAwMTk2MzcxODY0NjYyNjA3MDc1NTI0MTY0MzMwMTA1NDU0MzczMjE4MTQxMTUyMzM4NDE2ODc3MDAwNTE4MzAxNzAxOTExMDcxMjc3OTkzNTU0ODU5MjAwNDY1MDU1OTExOTM3NzAxNjQ3NTA4ODYwMzc4ODUzOTc0NzgxOTE1MzQ3OTc2NTU2MTY3NDU1MjgzNDMxNzIzMTgzMTg2Nzg0MDU1NzY0MzA1NDQ4OTYvNTYzNzcxMzM5ODk5NTU2OTYxNDE5NjM5Nzg1NzUyNTY0NjMyNTIzNDA1NjIxOTUxMzIwMjkyODU4NzU4MDUzNDE1OTU5Njg5Nzg4MDczMTA0MzMzNjc5MDI3MzA0MDgxMzA0NDA3NzE1MzA1MTI2MDk4OTczMDM3Mjg0NjcxMzYxODkwMDE0NTQ0NDgwMjIzNDYyOTkyMjcxNzQ2NDA0MTI2MTM3MDgwMzU5ODc5OTgyNjYwNDg0MTY1NDYwODcyNDcyNzMyMDc5ODMyNDAwNjEyOTUyNDYxMDY2NjIzNTk5ODExMzY1NTE5MzY0MjU5NDc0NDU0NDIyNjg4MDk0NDg4MjM0MjIwNDQwNzc1MDE5MzUxMjg2OTY3Mjg0OTkxMDAwMzI0NjUwNDA1MjI5ODAyMjQ2ODAxMjU5NDQ1OTk3NDIwOTk0MDYwNzQ1MDQ4MDYwOTE5MDg0MTg5MzI2NzIwMzM5Mjg4MDM2MDgyMzg3NVwiLCBcIjczMjMzMjYzNzE3ODU4NDU2MDIyMDY4ODkwMDI2ODU2NjEzMDI0NjgyMDIzNTk1Njc2ODcyNDg0NTc0NzgzMDk1OTU0NzUwMTk1MDc2NTA2Mzk4Mjk0MzA2MTE4MTUyNjIzNzA2MTgwOTA1MjQ0NDExMDQzNzkzMDEwMDIxMDEwNTI3NDgyNDYwNzM0NDkwMjc2NDE4NDE1MTAzMDgyNzI2NjE0MjIyNTg5NDY1NTUzMTQ5Nzg0OTE2MTY5Mjc2MDM4NTkzODc4NjczNjQzNjk3NzI2ODYxNjAyOTg2MjU3NzI5Mzk4NDM3NjE3MDkwNTAyNDcxMjk1MjgxMzIzNDk0OTUwODE4NjMwNjc3NDI1NzAzNTUzNTgwNTMzMDM2Njc0MjMyMjc3NzYxMTA2MzQwMjQ1NTI2MTM5MTAyMTA5NzEyOC8xNjMzNzc5ODgxNTIxNzk2MzY5MjI0MDk5MzgxNjMwMDU5NDg1OTY4MjI2NTY4NjgwNDA2NjI4MzEwMDM5OTEzOTU5MDUxODU4MjM4MzYwODk4ODc5OTAyMDE1MjI2NzMxOTY3MTk2MjgyNDcxMDY3Nzc4ODE3NDE4NDM3ODYzNjU3MDExMzU1NTU5MTcyNjMyODUyNjg3NTM2MDU1MTQ4MTI1NjgyNTgxNzkzOTEyNzIxMTM0MDU5MjAzNjk1ODc5MjI3MDIwMDI3MzI2Njc4NDI1MTExMDg3MzIwNjg2ODM0MDcxNjgwOTA3MjU3MTI0MDE5NTQzMTQyOTMxOTM1NzI2NTQzNDcyMzc3MTY2OTE3ODQzODY2OTA5NDg0OTQwMDMwOTQ5OTI4NzY4Njc3NjM2OTgxMDEwNDM3MDExNzE4NzVcIiwgXCIyMjM5MTM3NDg1NDI5OTQ2MjEwNzkyMzU4MzI2NzU3MDU5Mzg4NjAwMjY1ODc4Njc3NTIxMTU5Nzg5NjI1Mjg3OTcwODc1MzQ1MDc5NDMzMjMwMTE0MjkwOTcxNTg0NTE1MTc0Njc4NjAxNjUzNTE1Nzc5NzAyMzE1MzA0MTAwNzI2MzI1ODczMjk5MTQ2NTAzNzY0ODUzNjcwMjIxNzI3Mzg5Nzg3Njg2NDM1MTU1OTczNjQ0OTQ4MTI4NTUxODI0OTg0NjI2NDYwMDkzNTU0MzU4MjU2MjAxODg3NDU3NDY1NTc0MDY2MDgwMDYzNDg4MzQwMzU5NzE4MTg3NjM2NDcxMjUyMTI1MzY1MDc0NDE5NzMyMTA4MDY1NTAyODM3NDYwMjc3MjY5Njc3MDIyNzc0MTYxMDg3NDM5OTQ1NDM2MjU4Mzk4MDQ2NTIyNTIzNTY3NDgxNjc4NTk4ODE2NDE1NzM1MTI0MzE5MzI2NTQwMTcyOC80OTgzMjc1OTk3MTg4OTY3NzU4MzgyMTY3ODY3NjU2ODA2NjgxNTY1NTIxOTY0MTM1MTMxNzEwNjc4NDQ3MjQ1OTg0MjM5NzMzNTQ0OTQxODgxNDE4OTU3Njk0NjEyOTA5NTk5MjYxODQzNjkzNTU0MDQzNTA0ODU1MjA3MTcwNzgyNzQ0NTE4OTQzNzc4MDk2NzY4ODU5MzM3OTgwNDcwMjE5NzgzMjEwMTkxNzY1Njc4OTA4NTM3NjQ1MjcwMzkyNTAwNzc3NDExMTM0MTY0OTE4ODAzOTQ5MTU1MDM3NTgxMTA4Njc4OTY4NzAxOTYxNTQ0OTc5NDUxMDgxODM2ODcyNDI1NTc0MTIzNjgzNTc0NDc1NzkwOTk3NDE0NDg4NjQxNTM0MDc0ODczMjQ4ODAyNDUwMTA4NTM1MTgzNDEzOTcwMDU3MzE5MjQ3MDMzMzc5MDE2NjA2ODA5MjI2NTQ3ODA1MjY5NzUyMTIzNzQ2Mzc1XCIsIFwiMjEyNTIzNDQ5OTU1OTIyNjk3NzUxMDcyMzY3NzQ2ODkwMTI3NjA3NTA4NTA1OTg1Njc3OTk1NjAzNDM1MzU3MzEyNTE3NjY3ODAwMTY1MzA5Nzg2NjMwNzkzODY0NTM0MzAyNzI2OTgwMDY5Nzc2NjgwNjMyMDg1MDI0MDg2MDcyMjc1NDQzMjI5NDU0NDYwNzk3MDgwMDAzMDQxNzkwNzMxODQ3NDU2MjM3NDA0NjYzMzQxMjc4Njc0NjQ4ODM3NjI4NDMzNDY2MTk4NTMzMjU0MTU5NjMwNjIxODEwMTg3MzY0MTA1NzAxMTMxNzEzODc4OTE1MTgzOTg4NDY2MTcxOTcwOTc0MDc2MTI4NTIwMzc5MDU2ODc4OTk4MDA5MzIzNDMxNTY5Nzk1OTE3NDAzMTA5MjgyNTc3NjYwODE2OTc2NDUvNDcxODUxNTM3ODQ4NDUwOTE0MjM3NzU1ODQxMjE4NDE4Mzk5MTM1Nzc0NzIzNTg5MjE5NDIzNDM3NzkzMjIxMzYxMzc0NjAwODM3MzkxODkyMzYxMTIzNjM0NjMzMDE4OTI4NzMzNjQ5Mzc5NDQ5OTE4ODY0MDM4MDk3NTM2NDk5MTU0ODc5NDM0MTE3NzA2MDMyNTUwOTY5ODQwNDU3MTMxODAzNzI5ODExMjI5MzkyNjgzMzg3NzEwMzU1NDU0NjQ2NjA1NTYxMjQ5ODkyNzQ3NDIyNTYxOTY4MDE4NjExOTMxMzEyOTYwNDMxOTA5NjM3NDkyNDAzNzg3MDgwMzU1NDE1MzQ1ODEwNDIyNTc0MTI1NTc1MzMxNDk1NTExNTY0NTMwNDk0ODU2NDE1MTc2NTUxNjE4MzY2MzYzNDU0NjY4OFwiLCBcIjc2NzAzMDg1NjY2NTYwNjA5MzE5MzY1NjU5MjA5NDQ1MDQ0OTU3MDUyMzU5NTAwNzQ1MTk2NzE4MjY5NjY1MjM0NjQ2MTIxMTM0Nzg3ODA3OTM4NjgwNzg3MzQxMDIzMjAzNzg2OTA0MzA4MDQ3OTgxMDk5MjI4MzU3ODUwMDE2NjAyMjAzNTM5OTc5MjQ2NTc5NDU0MjI5MDc4NDk3NTM3MTQ4Nzk5MzQ5MzUzMjUwMTY3NjIxOTM1Mzg0MTkzNTAyMzgzMTg3NTEwOTI4NjA5ODE4MDExMTQyNjQyOTU0NTUwMzMwMDY5OTkxNTcwOTgzOTAyODQxMzE4MjAzNzk0MTEzODk4ODcxNTE1NzAyNDQ1NzIwMjA3MTQ0ODYzODc3MDI2NTI2MDI1NDQ3ODE5NTM3Mzk2MTQ2ODIyMjAxODE5NDM1NTM2NDM1ODM1Mjg1MDk4NDg1OTkwMjYwNjc3NzM3MTkyMjMwOTg1MDY5ODI0LzE2OTg5ODkyODIxMTA0MTIyOTE2MzEyOTkyNjE2NjY1NzY0OTQzNzIzMjIyMTk5Mjc3NDEyODU3MDUzODk2MzE5ODE0NDM4OTYxNDc1MTE3OTUxOTA0ODY3MDY2ODQ1NDEyNjM5MjM2NzkwNzYyNDMyOTk2MzA5NzE3OTI0MDM3NDY3ODYzMDI0MzYwMjExMTYzOTcxMTkwMDA2MjcyMTY4ODQ1MTk3MDAwMzA0MzI4NDgwOTIwNDgzNjUxNTU4NjcyODc5OTY3MzUwOTgyMTk5NzY4MjU1MjU2NzUzMTEwMzc1NDY3OTc2MjQ2MzM5MjYwMzI2NDIyODkxOTEzNTY0MTUxNDUzNzI5Mjg1MTkxMzUxMjczMzQyMjA2MTk4MzY2NjI0ODgyMTk1MTM1MDU2MTc2NTAyNzI0OTEyODQ5NTc1Mzg1NTc2NTU0MjA4ODQ0ODE0MDg1MjI4Njk2ODM4ODM0NjY1MzM5ODExMDI3NjI1XCIsIFwiNDAxNTM4MzExNjY1MjEzOTEyMjU0ODk4OTQ4NTc1NTE4Mzg0NjgxNTA1NzY4MjcxMjkxMzMxNjg5NzI4NTk0NDExMjI3Mjg3MTAxNjUyMzM4NjUzMDkwODQ4NzIxNTk1ODM3ODcwODMxMzA3MTM0NzM3MDIyOTYxMjI0NjUzMTkyNzY0NjE5OTE0NTcxNzMwODUzMTI0MDc2MTI3NTcyODA5MTU4NTM1ODQ2OTg0MjAwODM0MzY5NDY5NzY4NDQyNDAwNjM3MzEzMzM2MzgxNTA1OTkwMTc4ODY5Mzc3ODM0NzA5NDIwMDczNzY1MjM5NDc4NDAxMDQyNDY5Mjc1ODAyNTQ2MTI5OTExOTEwNDA5NTEwMDE1Mzk2NDE5NDcxNTM4NDc3NzYwNTAxMzg1MzIyMTk1OTU3NDYwNTYwNzY3NzY4MDk4MTIvODg3MzU3NjExMzU4MTA2NTQ5MzI3MzUxOTYyNzU0NDMwNzQxODEzOTkwODY0MDMyNTIyNzE5NjkxMjExNDUyMDkwMzUwNTQyNjcyMjA4NjI2NTcyMzkwMDMyNjczNTk4OTc3MTY2MDk4NzYwOTYwNDUwNzUwMzc1MDIxMjI5ODc1NDQxNDQ3MjgyMjQ3NzI0MzI5MzYzODQ4NjA0NzMxMzk5MDg3ODM0ODgyMDU3Mzg3NDgwOTYzNjA4NDU3NDEwODkwOTYxNTA0NDUyNDY2MzcxMjQ5NTQyMjU2NTE1MTM0MDAzNzU2NDE1NjIzNTc0NTYyODQ2NTE3MjIxOTI4NjY2NDY1MzM0MzE5MzE2MjY1NzM3NDQxMDkyNjE3MTE1MzUxNjg3MTc2NTY4MDU2MTUwNTc2ODIyMzY2MDA1NTYxNzkzNDYyNVwiLCBcIjIwMDczNjM3NDI3NzgzNTI3MjQ4NTE4NjUyMzQ4MDE3NzE1OTQ1MzAzMDA4Mjc3OTg3MjQyOTY0ODQ0OTQxMjMxMzI0NzY0MDMxMjQ3OTIxNDI2MTY4MTg5OTI4NjUxMzgxODkxMjk5MTk0NTA0NjI5NzMzNDQxODEwMjcxMTYyOTkzMzQzNzY1NDM3Nzc2MDAyODQ3Njc2NzQ4MjE2MjAzMTY0MTc4MTQ5OTExNDg1OTU1MzY3NzUwMjAwMjkwMTI0ODEyNDc1MDUzOTI3MDIzNTA5ODQ5MjM3NzgyNjI0MDMxOTc2NjY3Nzg1NjQ2NTA5Mzg3MTM2NzgxNzY4MzczNDA3OTYyMTM1OTE4NjQ3NzMwNjE3MzYyMDMzMTc0ODQ5NjM2OTEyMjE0MzAxOTMwMzc0MDI1MjQ2MTgyNDUyMzU5MDA5NjkyMzU2MTkyODM1NDAyMDk2MDE3NjYwNTAwODg4OTU3OTU3ODQ5NTA3MzI4MzcxMi80NDI1OTQ0MDA2NTEyNTQ0Mjk2NDAxNDQ1MzczOTM5MTU5NDE1MzI5MDkyMzkzNzczNzEzNjgyMzM1NTMxMjg5MjU1Nzk3NTM5OTAzNTM3MDYzMTUyMTAxNDU1NDk4MDEyOTI5MTU4MjQ4Njk2ODA4MzIyODg4ODA4MzA3OTExODExNjI4NjMxMjU4Mzk4OTQzMzAzNzA5NzM5NzI1MjUwNjE0MDIyNDQwNDEzMDM3MTE2MDYwODM2NTc3NzYyNTUzODE0ODMwMzkxNzMwNjM0MDYyMDAxOTg4MjkyODc0NDE1MTI5NDczODMwODA0NzgwMDcxMTAyODE1ODI3NzUwMDMxNzEzNDUzNzU0MDc3Mjc1OTQ4NjM2NTY1ODAyNDE5NDQyODc5Njg0NjM2NDQ4NjE4NzEwNTM0MzI2NjM5ODMzODA2MDA4MDYxMTY0MzExMDA3MTE4NDk5MjE5MzU5MzY0MzYwNTcwOTA3NTkyNzczNDM3NVwiLCBcIjQ4ODQ1OTA0OTMyNTQ5NDY5MzI1OTE1OTQ0NDUwNzQzNzk4MzM4MTY0NTc1NzI5MTg1ODA5Mjk4MzM3MTY3MjMzNDA0MzAyOTYxNTk2NTg4MjU3NDQwOTgwODkzMjUwOTI4NTA3OTQwMTIzOTQwMzI3MjQxNDI3MTY1MjYxNzQ3NDE4NDMyMTg1MjM4ODM5NzAyMTgzNjkwOTU4NTY1OTMyNzk3NDYxMTI3MzgyMDY3NjEyODY1MDgxMDkwNzU5ODEwNjU4ODQzMzkzOTU0MTY1NDIxNTc2Njg4ODIxMjI4NzMxMTk0MzM4NzIzMjY2NDQxNzM0Nzg4MzcxNzIwMzYxMTA5MjQ1MDk3MTc4NjA4MzgwNjMyMzQwNDQzMjI2NjE5NzI1MDkxOTg4MDIyNTg5MjA5OTE0NjcyMjQ3NDEyNDg3NDI1NjUyMy8xMDc0NTU4NTU0NjYyNjc0MTA5MjM0ODAxNDA4OTg1NTI1OTgzMDY2OTkzNDEzNjYwMzIwOTU5MDQ5Mzg0MzAwODQ3Njg2MjQxNDg4Mjk0NzM4NDg3NjM3NjE5MzY3MDMwNzIyNTM4NDE3NTE5NjY5MDYxNDIyODM2NDAzNzkzMzYxMzEwODM0NjE2NDY3NzczOTA4NzQ0MDUzMjMyOTg0MDY1MTcyNTAyMzEzODk0OTMwODQ5MTgwNjUyNDMwNzk4MTk4OTg2OTExNDY4NDE2OTUzNTA1ODk5OTIxNzExMDI5MzkwNDY3NDAxNjkxOTgzOTQ2NzE5NjUwNjk3NDcwNDI2MjEyNjU3NzU5NDgyMTcwNTQ1MTk4NTUzNDY2MTc5Njc4NjY2MTQzMDM0OTcyNTgwNDI0MzkwNTI2ODE4NDk4NjQxOTIwMDBcIiwgXCI4NDMwMzc0MDY4NTk2NDEzNzY4OTc1MzI2MzI5MzEzNjQ4NjgzMjIyNzQ0Nzg3MDk3MzczMTExNDc3Nzg4Nzk0NjkyNDE4OTMyMDU2OTAxMjM1MTc0MDE5MzMzMzkyODQ1NTI5ODIxNzIyNDg4OTgyNDQ3NjgzNzk0NzQ2NTE4NzEyMDcwNjM1MDYzMzk3NDY0OTA0NDg5NDUyODQwMTY5NDcyNTk2NDk0NDMzODc0NDEyNzI2NzIzMDY1NTYwMzU4NDA1MDI3NzY0MDE1MjczNzg5MDUzMDY0ODMwNTI4OTE5MDkxNDE0NTMxNDAwNTg5ODUwNzA0Mzk1ODg3MjUwNzU2NDU3NzgwODY4Njc3NTUzMDY4MTY0OTMzMjk5ODAyOTQ0Mzk2NTc2MzYwMzU2ODk2NzU4NzQ1MDMwOTU1OTA3MjU4MjMyMjU3MzU4MDU2OTMxNjgwNjE3NjI2NjA2NzE1MzkzODg1Mzc4ODg3NjU3Mzc3MjgwLzE4NTA0ODAzNTg1ODI3NDg0MTI3Njc4OTM2NTYyOTQ2Njk0ODYzOTA3NjkyNDYzNDkzNDk3MDYyMDA4Njk0NDY2NzkyMTI4MTIyNjQ0MDA4NzY2ODU3NjQ3NjIyMTE2NTk4NDM2NTg1NDE1NjcwNzE5Nzc4MTMxMTA0OTYzMjk4NTAwMTAyODgxNzk3MDI1ODk1MDEyNTUzNjczNDU5MzUzODkwNTAzNzMwMjE1OTE1NzI1MzkyNjA5NTExNDk2OTY4MDE2NjU5NTMxMjM1OTc1MjE5ODMyNTc4NTIyMDcyODA5NzA1NzcyODc0NzI5MzIxNjczNjI1MjE3NDAyMzA5NzM1NDcwNzAyNjQyNzM4NTAzODE4OTY3ODY4MjIxMjcyOTAzOTcwNzU3NTg3ODAxNzQwODM0MTU5MjM0ODI2NDAzMTMyNzczNDExMjA5Mzg2OTA1OTQ4NTkxMTg2MDMwMTc5MzA1MDAwMTQ2NDAxNjkyMTEyMzlcIiwgXCI1ODI3MzYxNTg4MjQ5MTkyNTU0MDg4MTc4NDMyODM3MDk1NzcyMDUzOTc5NzAxMDgxNjEzMDAwNzMyMjIxMTUxMjA3MDYzNDI5NTE1NDYyNjgxMzQ3NzQ5ODYwNzc2MTI2MDYxMzM1MzYzMzk5NjQ1MTc5NzY4NjE0MzEzMTg5Mzg4NDU1OTkwOTY2ODgwNTYyODI2OTk1OTkwMTA0NDk2MTY2NjUzNTUzMzg3NjM0MDExNjcyODk4MjA3MjYyNjg3NTAxMDM5MTE5NTM3Mjc1OTEzNTQ2OTQ0NjA0ODM5NDgzNTE0ODY1NDQwNzg0NjI0MjcyMTQ0Mzg0NTM1MTg1NTIzNDM0NzQyMjI1NjcwMDg2NDM3MDI3MzA5Mjk3MTgwNDIwNzUxNDczNjkyNDc4NzU3NzU2OTM1NTk0OTYwMTM4NTcwNTUxNzE1Mi8xMjc2MzE3MjEzODMyODQzMjk4NDU3MzgzNzUyOTc2NDkwMjczMDQ0ODY2NjU5NDA5NzQ2NjU0NDY1MjgzMDcwMzczNzE5NTgwNDc0NzY4MjQ1MDU0ODQ4ODE2MjIyNzM2NDUzODA1MjU4NTQ4NDQxODQ5MTkxNDMyMzY1ODIxNTQwNjMyNzM2MzgwNTM1MzU0MDI2NjA0ODk0MzE5NzgyMjgzODkyNTE4NDk0MjYwMDM2NzY0NzI3ODc2NDk1MjgyNjY2NDY4NDgzOTk1MzkwMjU2NzY5NDgzMjY5MDY4MzQ2NzYzNTcyNzQwOTk3NjM4ODI4MDA5MjI2MjgzOTEyNjc3OTczMDE2ODg4OTY4NjYyODYzMDMwMjUxOTA2MzIyNTAwNzQ5NzcwNzAyODYwMDg2NTYyNDEzMzk2ODM2MzkyMTkxNTAxNjYyNVwiLCBcIjI2ODUyNzg2OTQ5NDcxNTI5Njk0Njg0MDcwNTUxMDk5NTk5MDAxNjA4MDQ4MzUyMjg0NjYyMTQ0Nzk1MjU4OTExMDMxMjg0NTkwNjUxMzEyMjE3MzY3MTM1ODUwMzgxMzA3MzcwOTkwNjcwNDAxOTYzMjY4MTUyODMxNzE4NTc5Nzc3MDY5Nzk5OTA0Njc0NDQ2MjI1NTA0OTc1NjU1MjE4NjM0NDE2MTcwMDEwOTczNTQ2NDk5NzI2NjAxODMwMzg4NTAwMzM5NTA2NDc1OTQ3NTQ2NDQ5OTc0MzY2MjQ2MjMzMjUwMDM1MzczMDg0Mjg4Mjg3NTAwMDgzMDU0NjQxNzQ0NDMyMTAwNzkwNTkyNTM5MjAzODM0MTE5MTA5MTE1OTQ2MzYwNDU1MTc2NjI3OTY4MTEwMDEyODU5ODQ0NDc2NzEzNzE5NDMyNjc0MTkxNTEyMjA1MTg3MjY5NDA0NTU3NTY4MzMwNDA5MzQ1MDY0MTQxMzM4ODgvNTg2ODY0ODE2MDQ0OTY4OTk2ODI1OTA3NDg4NzIxNjc4MzA0MjExMjk2MjY3MzcxOTM2NDYzMjcyOTU1NDg4MDc3NjY2Nzk2MjgwMDI4MTI3MzMzMjI5NDUzMzQyMzU1NTU0NDUwNzA4Mjg0OTM0MjIxNDYxOTQ2OTkxNTU2MjE2MDk1MjEzNjI3MDU5MDQ3OTg0MTk5MDkxNjI1OTIxNDMyMTEwOTEzMDk2MjUzMzUyMDY1MjM4NzY1MjQwMDYzNTU1MzQ3MjkyMzkzNDI3NzI2NzU4MDEwODg4NTQ2NDI3NDE1Mjc2MDQ2MjM4Mjk3MzgyNDc0NzA4NjEyNTI2NzcwMDU1NDg4MzIzMDAzNjk4NjQxNDkzOTM5MTQ1NjI0MTg0OTQzMzg4MTU5NjE0MTExMzUwODM5NTU1MTQxMjAyMDI0OTkxODc2MjIxODc0MTEwNjQ0ODc5Njc2NjAyOTI0NzMwNTA2ODgyMzg0NjAzNDA5MTIxNjI1XCIsIFwiMjc3MDAzNDU3MTAyNjQzNDc5NTc3NTg2Mzg3NDE5NTIzOTQ1MzA1Mzg1OTgyMjU5MDQ3NzI2NjQzOTExNzMxMTk1OTQ2MTY2ODA5OTYwMzE4ODY2NjUyMTgyMjEzOTI0NTM2Mjg4MjQ1NzAyNTY0Mzg5NjAzNDkyMjAyNjM1NzU3NDE0OTUyODU3ODA4NDUzOTkxODcwMTM1ODIxNjk5MDc1MTg0NjI0Mzc5NjY5NjI5MjM1OTI2MDE3MjExMTkyNTg2NjM0OTA2NTUwMTM0MTk2NzU0Njk4NjQ4MDkwMDQ1NjIyNzI3OTkwMTIyMjcyOTM5NzQyNTQzMjk5Mjk0MDQwMzYwNzEwNTU1Mjg3NjYzOTcwNzk3NDMyMDAxNzk5MjQyNDM0NzkzNzA1OTQ5NzM2MjY3NjQzMzA4NTU0OTM3ODkxMTI0MTQxOTEvNjA0MDk5NzgzOTA1MTIxMzU0MTAwMTI3OTI3NjI4NzQ3ODM0Mzg3NDEwNzY2MDI4NzY1MTcxMTYwOTA2NzIwNTExMTU3NDcxODQ0MjIyOTIyNDIxMjI0NTE4NzY1NTMwMDM0ODQ4NDE0NDAwMTI5ODQyODk1ODAyNTA1MjE2MjI1Mzg1NDY3NjIxMDQ1MTY1NzQyNTQzNzU4ODI0NDY3NjU4OTk2NTgyMDMxMjUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCBcIjgwMTYwMjY5Nzg3NTc0MjcwOTUzMDIwNDg5MjEyNjE5NzkxODM5NjQzMjA3NzkzODg5MDA5NTAzMjM0ODc5NjgzNDk0OTI4Mzk2MjMxNzY5MTY3MDgyMzU1MTQzNTY0NzIzMjc0NTc2MTY2NjM4ODY5NDMwNTcyOTc3NDQyMDIwMjM2Mjk5MzE5NzE4NjQzODk0ODcxNzM2NTM5MTA5ODIyMTczNTM4MjY2Mjc4MTY1Mjc2NTkxOTYyMjE1OTI3ODE2NTQxMTY1NTQ4Njk5MzgwMTI5MDE0ODQwOTU2ODk1OTMxMjg1MjE1NDgwMzUwMzIxMjU5MDU0MzU5ODM1NDcyMzIwMzk0MDg5NjQ2NzY0MzYxODAyNDQ1MDY4Nzk4NDUxNzk2NTI1ODk3MzA0MjIxNTI5ODUwMTMzNDAxNzY4MDI3NDY5MTI2NDA4MDkwNTc3MTIxMTcyMjM4ODAyMjgxMDc5OTE2MjU4OTUxNzcwMTM1NDg1Njk2LzE3NDQ0OTU3MDg0OTM2NDU1NTU1MDc0ODc2NzIxODA4MjQxMzExNjUxNjY4ODAyMDkxODI4NTg5OTExMzEwMjUzNzA5NTE3MjI2NzE1ODgwNzIyOTQ4MjY3OTc3NTYwMzgxNDM2MzA3MTUyMzQyODIxMzA0NTI1MDczNjUxMzc5NzYzMTQ0MjgxNjc4OTExMDQ3Mjc2Mzg5MjMxNzEzODYwMzkyNzk0OTc1NDUzNTE4MTA3MDU1NTY4NzY1MDA5NDg2OTczMDE3MzQxNDc5NTYwMTU0NzkyMzQwODg4NzgwMzM3MDI5NDgxNjQ2MDQ2MjMzOTY3OTIzMjg5NDY4MTQxMjkzNjk5MjM2ODE1MTk2NTUzODE5MzczODI4MjgwMzk4NDg4OTY2NjY1OTk0MDkyODc3NjgwODYwNjQzMjY2OTE0ODYxODM3NjM5MzIyNjA3NzYxODA0NzQwMjU2OTIwNDI5NTE4NDM0MzUzODM5ODc4MjgwODc1XCIsIFwiMjM1MjgxNjg5NzA3MjYyMzQxNjIyMDAwMjEzNDQ3NjkyMTEwODQwNTczNTk1NTI2NjcwMzUxOTI1MjA5NTE1MDQxMjQxOTI2NDMxNzA5MTc4NTMxNzgwMzAyNDAyODU2NTg1MTQ4Nzg2MTk3ODQ3NzIwODc1NTIxMTU4OTg2NzgwMzAwOTcwMDk5NjgyODA4Mjg1MDc5NjEwMzc4OTAwOTE5NDc2NzgxMzYxMTc5ODc2OTI5NzYxNzY3NDYzMTI3Nzg0NzkxMDIzODA4ODA0MDI1NzAzNzY3ODEyNjMxNjg2NjUxNzYwMTM4ODI4OTgzNzU3NTc3ODE2NTMwMTgyODEzNzI1OTk0ODE3MzI5MjY1ODQ2Mjc2NTY0NTY0NTg2ODA5NDE5NzczNjM4MjY4Mzc3NTQxNTY0NTMwNzY0NzA0MzIwNTk4ODM5NDcwMC81MTA5NzM0MTEzMTY2OTAzMTM0ODU2ODE4MzM5OTE2NDU0MjM4MDI3NzY4NjU3MjA1ODAyODAwNTgzNDQxMTEzNjMzNjMwOTE2MTY1NTgyMzAxODI2NjkzNzY4NDEzODMzNzUzMjE5MTI1NTM3NzEwMjcxMDc4OTE5OTEzMTgzMTM5Mzg1MDU5ODg5MDM3MzUxMTQxOTEzMTMyMTQzMjc2ODM0NDk1MTQ2NzY3Mzc3OTY5NDIzODk3ODQ5NTc2NTgzOTU4MDY5NTE3MTU0NTQzNzI1Njg1MjM1OTc0MjA4NjYwNTA4MjU4MjIwMjg4MTc0MjI4MDUwNDYyODc3OTgwNTQ2ODI0ODQxNTgwMTExNDM5NDk0MTI5NTY2OTc0NDI5OTE4OTg5MTQ1NjAxOTE0MTE2MjQwNDA0OTAxMjI5NTEzMjgzNjQ4MzM3OTdcIiwgXCI2NDAzMjk1NTg0ODczMTY1Njg4MzcyOTA3NDk0MDQ2MjAyMTUwMDQ2NzY5NjY3ODM3NzkwODM0ODk2MzM0NDg2Njc5NTQxODg3NTY3NTE3MDUwNDQ2MTE5NTExNjk1MjQ4OTI2OTQxMzgzMjA3NDc4MTcwMTgyNjUwOTI3MzY4MTc3MDA5NjY5NzE3Mjg4MTg0OTAzMzA2Njg5MzMyNzQ2MTI3ODQ1OTUzMTkzNTg3NTE5NTc1MzA0OTc0MjAzMDk5ODczNzMyNTAyNjA1NzM5MjE5MDI4OTk1MjY2MTM5MzgzMTYzMDYyODM3MDA3OTgyOTk5MTg5MTE0ODEwNTM0ODU2MjI3ODQ4NTY4ODAwMzAyNTI3NzYwMTAwMTYzMzUwODE0MTIwNTQ1NTg3MDc0ODY1NTY4NDM2Nzg5MDIxMDgyNjE5Mzk4MTI2NzEzOTQzNjM3ODk4NjU3ODYxOTQ5MDkxNTQ1NTE2NDAzOTg3NTQ2MTQ1OTE1NDA5MDI0LzEzODc3OTQyNzIwMTAxMTE1MzU4OTMyMDU3MDM5OTk3MTI0Mzc3ODMwNDE1NTM5MDAzNDExMTI0ODg2NDE1Mjg5ODYzODU0NjI4MTA0NDg0OTM0NDQ5Njg5Njk4NDUzNTI0MDEwNTgzMzM5Mjk3MTEyMzc5NzgyMjMyMTQxODY2OTMxNzcyNTE1NjYwNjk0MTk4MDU3NTc0NDAxNzQ4NDAxNzAyMTMxNTk2NTE5NjI2ODY0Njc1MjM1MzM5MzgxNDU2Mjk0NDQ0NjgzNjYyMzU1NTQ1OTcyNDU3MTMxMjg4MTI1MzI3MTY2MTYwODc3NTM5NDcyNDY4MDA2MjYwMDY1MDQ4NzgyMDM2NjY5NzI2NTEzODQ3MzE0OTg3NzA0MzU3NTUyMjUyMjA3OTY4NzIxNTUyNDkyMDI5NjA4MDE3NjgwNDg4NTQ4NjkwMDEzMTA3MjI5MjcyMzAyMzcwODM0MTgwMTc0ODIxMzQ1ODg4NjUyNDQ2NDI2NTg4NzVcIiwgXCI4Mjk5MzI0NzY4MzUxNDQxOTU3MDQ2NjUyOTQ1NzA1OTY2MDYzNDQ4Mzg2MDY2NTU1Nzc3OTcwOTE1MzU0OTA0NTQyNzk4NzY3MjgyOTc3ODUyMDIwMTMxNTE0ODE0OTg3ODUyNTI3NDAwNTk3ODM2ODkzOTA5MjExNTE5MzYzNjExMzc0MTk3MjIzNjIxODUwMjY2NDg4MTQ1MDM2NzQ0MzYxNDk3MTEwOTY3NzM2MzY2ODg3NDQ4NDY5NjU0Mzk4MjIzOTQ5MjQwOTIzMTg3MDk0MjQxNDE5MzQxOTYzNDY3NTAyNDYyMTk0MjE5NjA4NzQ3MzU1NzkxNDE2NzgzMjA1ODExMTExMzQ3NjI5NTkyNjI1MDczOTA5OTI4NDI0MTgyNjU1MzczNzA3NDY3OTk1MzU1MTE5MTc2NzE0ODcxMjY4NDE1NzMxODY5Ny8xNzk1MDk0NjQyMzkyNzM1NzcyNTc4NzY4OTg1NTI2MzUzMjIyNDAwNTY0Mzg1OTA5NTE2ODg1MjcyOTUxMzAzNDQ1NjIwODg3MjQyMDUxMzYwMTg5NDUwODQzODY0MDUzMTE3MTA5NzA4MjUxNjU1OTk2Mjc1NTI0NDY5ODY5NTYyMjgyNDM4NjAwMTIxOTQzNTY1MTU1NTUxMzc5NTUwOTYxNjkwNjM1NTM2MzU3MzYzODkxNjg5NTA3NDM0OTQ5MTUxMzUzOTA5MzAyNDk4MDU3NTg1MjY5MzI5MzQ3NDI4ODYzODIwOTY4MDA4NTAzNzI4NjM1NDA1MDk1ODg1OTQyNTY0NzUzNjczNTM0MTg4NjY2MzA3NDU4MTkwOTE0ODMyMzEwNTAyMDMzNzg1Nzk1OTY1MTYyNDc2MDg3MzczNjU5MDA2NTY2NDAwMFwiLCBcIjU4NDg5MTYxMTM3Njc2Mzc4MTg1MjE0NDM5NzI2MDE0MDg0NDk3NzM0NjMwNTU0MTE5NzM2MjQzNDIyNzE5NDc3OTc2NjYxMjkzOTk3ODYyOTYzNjE5ODU4OTgxODEwNjEzNzMxOTI2NzI0MzQzMTgxMDQ4MTkyODYzOTQ0MjM0Mzk0NjM0NjAzNDQzMzgyODU5OTMyMzQxNjg3NzI0ODMyNjM1NjM0NTYzMTYxMTE0ODc0OTAwNTkzNzE0NDY4NDg2MjUwMjE5ODE0NzA4NzcwMjY2ODUyNDQ1MDcwOTExODU4ODc0MTYwNjk1NTk2NjU2OTQyNzYzNjYzMDE1OTc5MzQwOTU0NDY1Mzk0NDYwODk1ODgwODYwMjU1MTA2MTE4Njc5OTQwMTIxMjcxMjIxNjE1Njc5OTI3MzI1NDI1NzQ4Njk1NTM0ODIzNjkxNDIzNzY0NDE1MTk1NjIyNjMzNjc1MDIxMjk1NzA5MjIwNDgzMDM4NTQ0MTc5Mi8xMjYyNTY3MTA4NjE1NDk4MzgzOTU0OTkwNzgyNDk5MjI5ODY0MTc0ODg5ODU4NjY1MjI2NjA1MjEyOTQ2MTAyODA4MjAwMDc0OTkwOTkxNzYxOTA4MjAyOTEyMTQzNzA2OTkyODk5Nzc4ODg4MTMxMDk1MTQ4NTQxNzgxODAyNjUzODI0NzE5NzI1ODM5MjE0NzcwMjI0MTE2NTcyODU4NTA5MTEyNzAzODk3MjA1MDg3MTkzNzcwNzE5NDkwNTAyNTMyNDYwMjE5MjE5MTY2ODU3MTYzNTMzOTMwMTg0MTE2ODM3NTcwNjcwOTMyNTkxMDExNTE0ODExODk2MzU0MjMzOTk2MTE2MjUwMDk2MTc4ODQ5ODMzMTgxNDE0NjMxNDAxOTk4Mzk3MjQ3OTc0MTI1MTQ3ODU3NTE1NDkyNzcyMzEyNTkzNDU5MjM2NjI0OTk2MjM2NDA4ODY4ODEwNDg1NzI4MzE3ODcxNjg5Nzk2NDQ3NzUzOTA2MjVcIiwgXCI0NzQzMDU0ODY3NDYwODU2NDI1Mzk5NzQyMDcyOTI1NzMyNDY1NjYwNjI2MzQwMTgzNjkwNDY0NzQzMjE3MTQ3MTA5NDAzMTMwNzMwNDQ1ODQyNjczODY2NjI0OTQ3MzYwODYyNDM4OTI1MTk0Nzg2NjAwNTMxMjAwMDU2MTMxMzA5NjA4NjQyMzYzMzg5ODMzNDc0MDI2MDA3Nzk4NjQzMjM1MzQ2MTA0OTM3NzMzMzQ5NzkxNjY3Njk0ODYyNTE0MzgzNTIwNjg5NTk0NTk2NjYwMjc1MzA2MjQ3NjE1MzE0MjcyMjIzNjYwODYyMjEyNTI3MzQ2NTcyODExNDIyOTE1MjIzNDE3NzgzODg3NzE3NDI2NjQxMzE3OTIxOTcyNDU2OTEzNTM0MzM4NzA4NzQ1NTQ5MjUyMjU0ODY1NjE1NzI1ODU5ODgxNDU3OTA2Mzc2LzEwMjE4NDAwMzc4MzIyODk3ODgyODQ2OTE1MzU1NDMxMzgxNjQyODg0NjI3NzAzODQ5NjE4MDIyODcyNTAyMzY1MTk5ODM4ODcyNjI3NzE5NDQxNzQ1NTcwODcyMDc1NjYwMzA3MzA3NDMwNzUzMzQxNjk2Mjg5NzEzMzYzNTg3MDg1ODAxMjQ0Mjc4NTczMjE5NTM5ODE0NzU3MTk1MDM1NzQ4Njc0NzEwOTA2MDc3OTUyNDIxOTI0MTcxNjI3OTE3NjI1MTE5NDA4NDg0OTMxNzY4NDc5MjU4Mzg3MzgyNDIxNTMxNzczMTE2NDkxMzA3MTg4ODY3OTQyNDk2NzMyNTQxODM5MDc2MjE0NDk1MjA0MTUwNjA2NjA0OTYyMjU5Mzk5NjM0NzE3NTMxMjI3NjY0MjEzMzgyNDEyOTE3NTY4OTI1NzE4MjQ5ODQzNDQ2MjVcIiwgXCIzNzg0NjY0MDc0MTU1NzY5NDY3NzAyOTk5Nzg1MDE2NTE0NDY4MjgxOTEzMzc1MzQxMTM0ODk5ODc4ODkzMDYxMzI1NDY1NzkwNTg5MTAxMzM1MDE1NTY5ODQwMzI1Nzg2MDcwNzk1MjY3MDU1Mzg2NjgxMzU2MjQxMjA5NDEyOTQ3MTE2MzQwNTI0NTg4ODMxNTEwNzY4ODY0MjMxOTM3OTI5MjYwMjM2NzU0ODgxODI5MDA1MDY1MDU2MzEwMjI2NDA3MzU4MjA0Mjc4NjU4Njk5OTk5NjEyNTk2ODY2MTU2Mjk0MTk1MzE2ODY3OTM0MDM1ODc3MjgzOTUwODQxOTEwNzI2MjI0MzU1NDYxNTIyMDY1NzczODE2MTA5ODQ5MTA3NDg3MjE0Mjc1ODAxODI5ODQzNzYyNDgyMDgyODAzNTU5MTgzNjk0NjMxODU2NzcyNzc3MzEzNjczMDg2NzE1NjMxNTQ3MzI2NDAwMTcwOTYyNzIyODQyMjQwLzgxMzc4MzI4MTQ3MzIyMzU1OTk4MTI5MTY5NDE3NTA4NzUwODgxMjUyMDUwNTkzMTQ1NDg5NTg4NDQ0MjU4MDI4MDM0MjQ1NTUxNjE1NDY3NDY4MzIxNzM0ODAzOTMzNjcxMjkwMTg1MDczODc0NTI3NjQ0NTEwNzQ3NzkxOTUxODkwNTE1NTE1NjM4MDYyMDQ2NjEzNTk0NjY1NDk1MjgzNzU3Mzc5NzQ3OTA3NjAyNzY4ODg2NjMyNjM1OTQ0ODU0MzA2NTMwNTA3MTYwNTU5MTQ5Nzc3ODk0MTU2MTk4NjU3OTIzMDY5ODM4NDMwNTUzNjIyNDQzMDc5NDIzMzQ2Mjk0OTA1NjMyNjg2NDQ5OTgyNzQ0NDM2MzIwNjE2MjI1MTEwNDU1Mjc0MDE3NTUwMzk5NjY3MDk5NzcwNTQyMzg4ODM4MjMyODAxNDIxMDE3MTMyNDM3NjU5MzA5MDE4NzYwNDI2ODA4NjMzNDc5NjI0NTU1Mjc2MjMzM1wiLCBcIjE5NDY2NzEyNTg1MzY4NDI2NDIzODE2NTU3NDcyOTQ2MjE3NzYwNzAwNTE1MjUyMDk5NDAxMzAxMTU3NjkxNTM2NjYzNjg5MzIwNDIxNTIzMTE0Nzc3NDY3Mjg2NzgxODI5MjA4NDIyMzg4MDE3NjM1NjU3MjYwODY0NTk0ODUwNTAyMzc4NjA2OTMzOTQ0NzE2NDQwMjM5OTk0Njc2NzAwMTc0NzAzNzY3NDY2MDk4OTI0ODQxOTIwNzIyOTc5MzgyNTQ4OTg4ODAzNTQwMTQxNzYzNzMyNTM4NzU3MjI0MTAxODY2ODM4NTIyNTM4MjgyOTk2Njk1MzAwMjIxNjYzNjEzMDQzOTc2MzE2NjcxMzM2ODkxMjgzNTgzNjUyOTY3MDE3NTc3ODIzODI0NzU2OTI0NjU5Nzc3OTQ5NjAxMDk2OTAzNjI0NjIzMzA4NTcvNDE3Nzc0MDM5Njk4NDA4NTgxMDEzMDAzODgzOTI5MTI3NTEyMDYyMzIxNjIzODcxNDg2Mzc5MTAxNDk4OTY4MTQ1NjcwMjY5MTc0ODMzNTA1MDgwMjYwMzg5ODYwODYzNDE3NDA4ODQ4MjA5NTI1NDI3NzA1MjQ5NTI2NTE2NzY2NzMxNDI3NjAzNjQxODA2MjU2Mjg5MDk4MjA5NDI5MTEwNzk0MzExNjYwODQ0MTI1Mzc3NzAyMDE2MDU2OTg0NTczNjcxMDI0MDM1MjEzMDQ1NDc1MTMyMTM0ODk2ODM1ODE0NzQ2NDI1ODY0MzA0OTA3OTc0MDA1OTUwMTU1NjU3Nzg5MTU3NDk2Mzg5MjM0OTE5MTA3NzcyMjAxMzA1NjcyNDIxOTgyMTk4OTg0NjEzNjAxNTExMzg4NDEzMzgxMjE1MjIwOTI0NDE2MDAwXCIsIFwiMzI4NTc4NDg3NzIzMzc3MTUzNjAwODIxODEzNDEwNjMxNDY1MjI1MTU5NTg5NzI3MzIwODkzOTg4OTkxNzI5MzA2Njg4NjYzNzcwNjk3NTI4MTU2NjI1Mzk4MTc2OTI5Mjg4NjI4OTMwNDk2MzM4MDM2ODE1OTEwNjY5NTc5MDE5NzE5NjMzMTI0ODMyMTYyMDM1NTg4NTgzMjQyMzIwNTM3NDM1NTU0MTAxODQxNDA2NTY2MDA5MjE5MDU5MDQyODg4NDEyODkzMzUyNDE3NDQ2NDM3MjI3NDQwMDc2ODY5NDI3NTc3NzAxNzA2NzEzNTY0MjEyMTg1MTYzMDA1NjQ0MTE4ODY5NDk2ODY5OTgwOTI1MjE0NDI0NTkxMjY0ODcwMzg4MjM3MDc5Nzc2NTAzNTQ3MzE0NTg3MTM3NzIxNjMzOTE4ODI0NjY0OTQ2OTc0NTcxODM4NjM0ODYwMzg2ODkzNDA0MzY0NDk5OTc3OTY2ODk5MDY4Nzc3MDE2MDY0LzcwMzgyNjk1OTI3MDk2NjI4MzQ3NjM3NDU1MDMwOTcwNjQ0NjMwOTQyODcyODg4MzExODcwMTI0ODk2NTc1ODc3NTg1NjkyMjgxNjI0MTUxMTAzMjA0NTUxOTQ3Nzc2OTA2NTEwMzY2NTIxOTcyODM0MzU3MDMxNzc3Mjg3NTA2ODQ4ODg3NjA3NDU3NzUxNjY3ODE2NTE0MjE2OTA3MzM4MzA5MzcyOTAwMzI3OTE5NDEzMzcyMDQ0NjI1NjAyNTU1ODY2Mjk0MzM3NjcyMDIyMzYyODY1MTYxNTIzNjg0MDUyOTQwMTI2NTA5ODU0ODk1MzIwMTMyODI4MDA5NTUxMDEyNjM5MTU2MzQxODc4MDczNjgyNTAxMTg1Njg4NDYxNzIwNjY0ODAxODI5OTMzNjg5MjgwNzUyNjIzNzczNzg5MzczMTk5MjEwNDczOTk1ODIzMzY3MTk5NzkzNDA3MDQ4NzQxMTkxNzg2Mzc3OTkzMzkwOTY1Mjk3NjY0ODc1XCIsIFwiMjYxNzIwMTQ3NjkyMTM2ODUxNzg1Nzk0MjMyNjQzMjA5MDg3Njg3NDQxNDI2OTY4OTE0MDQzOTE1MTkwNzk4MjYzMTc2ODk0Njc5OTIwMDc0NDY3ODA1NTk4MDgyNzc4OTg1OTU3OTE5NjgzMjcxODg0OTM5MzA0NjE0NzY1NjQ0NzY3MjUzMTg2MTM1MzQ1NjM0MzgyMTE5NjgxMjg4MTg4MjAyMzE4ODg5ODgxNTE3OTk0NzY1MTI3NDEzMTE2NjgzNTEzMzk2NTYyOTExNTc0OTM2ODQ0MTYwNTY4MDM4MzYwNTMzMTMwMDAzMDg4NjY3NjA4MTQxODg2NzMwNTE3MDAxMjAzMjgyNDAxMTkxMjUzMTY3MzQ2ODIxNTU2MTUwNjQyMzgzMzkxMTYyMTI3MDY4MDEwNDA4MzUzMzkxNzU2MjYyMjYwMDQ3ODU0OC81NTk1NjcxMjEwODU1MzQ4NjUxODk5NzY4NzU2MDA4NDE3MTcxNjE2MTcxNTM3NzY5MDQ3NTIzNTEyMzEyMTA5NzAyNDAzMjM0NjA4MDA3ODU3Mjg3Mzk0MTI0NzQ5NjA0MjE3NzA4MDYxNjIzNjAxMjU3NzQwMDA2MjUwMzU1MjI0MjgxNjA4Mzc4NTU5NDQyMTU0MTc4MjEzMjQ3NTg4NzMxMjc1Njc2NTQyNDQ0NjUyODEzNTQ2NTQyOTkwNjg1NDY1NzA3ODk1NDc2OTEzNDI2MDk3OTMwNTAzMDEyNTg1MzI1ODYxMzEwMTM1ODU5NTkxNjQ3MTk1MzMxMjM4MjYyMDE5Mzc4MDE5ODY5NDI2MDY4NDQ4NTQxMjM3Njk1MzI0NDc1NzAxMDc1MjUwODEwODQ1MzE4NDgzMTg4NzQ4MzU5NjgwMTc1NzgxMjVcIiwgXCI2MzYyMjU3MzYwMzg5ODY1Mzc1NTk4ODAyNjU5ODg0MzE3MzE1Mjk4Mzc0NTEyODk3Mzc1NDIzOTU0OTQ2ODMzOTM0OTIwNDA4MDg1NjU5MDUzNzYyMzUwNzQ1MzQyMDcwMjY1MzcxNDU0MDg1NjI3ODUyNzk4MjM1NDc2NTcyOTk1NjU0NDAzMDk1MTA5MzEzMzYzOTQwMzE5MDQ5MjAwNTY0NjQ5NTk5NzQ3NDM1MjU2NjI0NTk0MzM4ODkzOTgwMDM2ODMwNzg5Njc2NDI2NTE4MTIwODE0NTAyMjc2NTQ0NzgwOTU0MjAzMDY4ODA3NjI3NTM0MDExMTEyNjA2MzA2NTQwNDkzODkxOTc2MDIzODk5NDk4OTI2MzY5NDM5NzE2OTAyMTI0ODQ5ODE2NzIwMTAzOTgxMDg0MjYwMDIxMzcxMTQ4MTk4MzgzOTkyMjIwOTY1Mzg5MjEyMjU0NTg5MTMyNjY5OTM4ODE5NjA3MzI2NjMzOTQ1NjYwMjQwNjQvMTM1Nzc2NTEwMTc2NzkzOTcxMDc0MTE1MTMxNjQ4NjM3NTA4NzU4OTUzMDUwMzkwNTkxNzczNTc0OTUxMzE3ODA3OTE5MDUxNjE5NjkwMzEzMzMxMTkyMDI3ODcxMTc2MTYwNDI0NjYzODExMTE2ODQ5ODU2NDg5MTg3NTYyNzI4NDk2MDk5NzU3OTEwNTQwMzYyNzAzODg4OTM3NzY4NTU1ODI0NTEzNzQwMTE4OTQxMzg3ODMxODIyOTAwMTk4MDI5MjY2MjA2MzM0MzUwNDQ4NjI2NzMzMTM5MTM2MDgzNDA0NDA0MTIwMjEwODkzOTg2NjU0NDIyODUwMTgzODM3OTc0NzcwNjc1NjAwOTUyMDc4OTU2MzI2MzE3Njk4OTk4MTAzNzcwODMzMDY5NzEyNjE2ODMyNjUwNDA2MjI1ODI4OTY5MDM2NzgxNTE0NjQ1NzMxMDIyNjE2MjM2MDgyMTc1NTgyOTM3OTAwNzMxNDE5NTc1MzM3NDczMzg0MTI1XCIsIFwiMjY2Njk1NzcxOTMzMTI0NjMzNjc3MzY3MTQ5Mzg5NjQzNDE3NjA4NDYxMzY2ODc0MzEwNTg4ODg0Mzc3MTUxNTM5MzI1ODU0NTQ3ODI2MzczNzExMDk5NTE3ODczNzIxNjE2NTQzNTcwNjA1OTM1OTU0MzM0OTQ0MDMwODE2MzgzODU4NDg1Mjk2NTQyMjYwMTUyODk0MDM1OTc5MTQxMjY2OTA5MDUwMjY3NDE0MDcyOTgyMDQyMDkwMzQxNzEyMDM1NTE4Njg1OTk3NDg0MjU3MzI2MjEyNDU0NzQyODE2OTc5ODA2NDYwMjg3OTcyNzU3NjI2MTA1NTI2OTA3NTEwMTk3MzIxMzUwODk1ODczNDczNjU2MjE1OTQxMDM0NjA1NzQ2NDk0MTcyMzE2MDg5NjM2MjE2OTE1ODI1MDIyMzM5ODU1MzA0OTI1NTE1Njg1LzU2ODExNzA2NjY1MjEwMzUyMjgzMzYyNjIzNzI4MTkxMjE4Njk4Mjk1MDU2MTc2NjI1MjE3OTM5NTI4MzMyMjQ3NTM3Mjc4NjA1MTEzNDk2MTQ3NjMwMTg1NTQ0MDA0NjU0NTgzNDQxNDQ4MzE5MjYwNTc4NjU5OTIyOTMxNzk4ODQ1NDkzNzU2MTg5NDAyODA1MTczMDM3NDkxNjQ1NDM0MDUyNzM3NDA1Mzc5Njc0NjA3NTE3NjU4MTE4NDI3NjE0MDkwMzM4OTM4NTE3OTYzMjE1ODEyNDQ0Nzc5MTg0MTkzOTMzNzQ5NTIwMzEzNjc2NTY0MTg3NTA3NTk0Mjc0NTUxNzkxMzg4MDM5MTM5NDA5MjM1MDU2MTE5Nzg4MjYxNjg5MDg3ODMxMjA5NDQxNzc5ODcwODczMzA1MjMyMDIxNzI4MDAyNjUxOTc5Nzc2XCIsIFwiMzUxMTgwNjY4MzE2MTY5NzcwODQ5NzU0NzYxNzk1NzcxOTM5MDE4OTk4Mjc2MTAwMjE1NDM4Njg4MTU4MDE2MDg1Njc5Mjc0Mjk1MjM2NTE1OTc2NDgzMDQzMzUxMTk0OTY3ODMwNDI4MTUzOTg3NTM2NjM3ODEzMTE5NTY3MDAwNDM0NTU2ODA0NzY5MDIxNjEyNjAwMTA2NzE5NDkwNDQ0NjI5NTMzNjczNDkzMTY5MTc0MzQ3NzUzMTgzMDg5MjAxNTY5MDgxNjIxMDc1Mjc5NTgwNjEyMDMwMzE5ODc0NTY4NTM5NDAxNTE2MTMyMzk4MjIyOTkwODEwNTM5Nzg1Nzc5MTE4MDM0MjMzMDA5ODI0MDcwMjMzMjA3MjM5NjAzMDc4MDM4NjM2MjczNTk2NzAyMTA1NTI1MDQ1MDY2NjUzNTQyMjUyODYzNzczNzY5NTA1MzMxNTEzNzIzODM2ODc4NzYwNzQxMjQ1OTg3NDA5NDE2NDAyNzIxNDk1Mzk4NC83NDY3NDE1Njk4Nzg2Mzk5ODM0OTEzOTA3NDE2Mzc4MTM5ODk5Nzg4MDQyMDI4OTg0Mzg3MDg3NDMyNTgwMDAxNTA5OTYwODAzODYzODEyODEzMDc2MDkwMzg4MzA2OTg1NzkzNTg4NzkzMzMwNzkyMTUzMjcyMDI5MTE5Nzc1Njg3MjYyNTg1Mjc2NDY1NjA0OTcwNzk2MjI3MDMwNTI3NjUxNjQwMzEwODk1OTA5NjUxOTk2Mjg1MzQ0NzczODE4NDMwNzk4OTIxMjM0NDAyMTQzNzg5NDk2MzI3MDc2Njg5MzUwMDEzNzE2MTY0NzUyODI4ODMwOTU5Mzk3NTA3MDQyOTI2MTY3NTg1Njg5NjQ3ODY3Mzc3NTIzMjU2NTI4MzkyMjYwMTMzMzUwOTIxNDg3Nzc3ODg3MzM0NTM3MDI0Mzg0MzIyNzkxNDkyOTg0ODIwMDQxMjI1OTMyNDM4NjA4MjkwNjA1NTczODY2OTkyMzE0NDg5NTcyMzI0MjAxMjVcIiwgXCI0OTk1NDM5NTEyNTI1MDQ2NTE3MTcyNzk0NjE0ODczMzcxNjg3MjEzNzYxODA0NDEzMjI3MzU4MDc3MTM0OTk1MjE4NzgwNzY3ODAyMDU0Mjc1OTgwODY3NTY2ODYwNjEwMDk3MTgwMTYxNzUyMTUxNDYzMDU0ODk4ODU4MzU4Mzk2NzM0MTk2OTg3NTE1MzAyMDc0MDQxMTUwMDIzODMxODAwNTQ3MDQ5Mjc2OTUyNjk5MjEwNzIyMzIzOTU4MjgyNTg4MjYyMTM1NTQ4MDY1NzA0MjM2MDI5NjY3NDMzMzc4MDE3NDE2MzM4NjkyNjc2MjA4NDM2MjY4MDQwMTY3NDI0MTIwNDY4NDQ3NzA2MDEzMjI1MTMxODQxMjM1MTU0MDU2OTI3OTUzNDY3OTA4MTM1MDI4MDUyMzg2MzUwMDMwOTk5NzY2OTM3ODYwMTI4MTYvMTA2MDMyOTg2MjAzNjgyNTUwNTE0NjAyOTY5NDYyODAzMjE0ODMxNTU5NDQyMzU4ODExNjU2NDg0MDM2OTUxNTU5OTkxMzIyMDg0OTM1NjkyOTUzMjExMTIwMjg5MzUyNjAwNDg0OTg3OTMxODEyNjMyNTA1NDk5NjEyMjIwNDk0MzExMzI0Njc5NTYyMTUyMDc4ODgzMTQxNDY0NDA2OTM4NTI0MDg3Mzc2OTY0OTM1NDk0MjQ1MDEwNjM2MTYzNzA1Njk4MjIwMzA4MjQzOTgwNzg5NTE0ODE1NTc5MzE5NTMzMzQxOTI5OTg5NDU1MjExNjEzODkwOTA1NDg1OTgxMzUzODM3MzIxMzQyNzMwMzA3ODE5MDYwODI1MTI1OTgwNTAwOTc1MDIzNDc5ODEzNzU3MDI0Mzk1NDIyMDQxNTAxMjA4ODA1MzM5MTc2Mzc1XCIsIFwiODU0MDg0OTcyMjI0MjEyMjgzNTg3MzMxMTYyOTk1Mjk4NTI4NTQ3Nzk4Njc2NTgxOTU4NDU1ODIzMzMyNDg2ODM2MzMxMDMwMjIwNjAwNjc3MzgyODg5NzgxNjU0NzI5OTI0NTcyNzA4Nzg3Njk4NDg1NzcyNjY1MjkzMjQ4MTg5OTc2NjUxMDYzNzQwMzU3NzE3NTYyMzAzMTQ2NzkzMzQ4NjgyMzk5NDA0MDU3NjQzMTc1NTE3MjIyMDkyMTkyMTg3NzE5MjAwNjY4NTA1MzU3MjIxNTkyMjM0NzQxODg0NjQyMzQxOTY4MzcyMzYwOTc5OTcyOTM1OTU1MTgyODUyMjk3ODE4NjIwODk4MzEzODM0NTQ3NjgwMTI0NzYzNDc3Mzk3NTMxMTQwNTkxMzI3NDU1MjYxNjAzNzAwNTg1NDgzNjA0MDE2MjIxMjc2MTA5OTM0NzUxODI0MjIwMDgwNzY5MjIyNDQ2MDUxNDA1NzUzMDY1NjY1ODYxNjg1MDgxNi8xODA5Njk0NTc1OTkyODE2NDQwOTI0MTY1NzQxMDk0OTk2NTExMzYxMjg4NDMwNzI3OTgxMTU5MzE0MTk0MDAwNTg1NTM2ODMyMTkyMDA0Mjc0NzI2NjUxODI4NzYwMjYzNTIyOTYyODY4OTQ0NjEyMjE1NjMzOTc2MjAzNTk2MTUwNjA2NTAzODQ5NTk1NjMzMzg4MzE5MzM4MjUxOTc3MTYwMjU3OTc5ODQ2MjM1OTk1NjU0MzU3MDgyMzIxNjExNzE5NjU0MTM2MDU4MjU3NDU4NzUzMTA1MTIyMDI0ODU5MDc4NDIwMTczNTE1MTg5NjQxNTE1NzM2MDI5NzI1ODQ3MzE1NjYyMjE1Nzc4MjUxMzcwMzk4MDA3NDY4NjY1OTg2NjA0NTI5MjYzMDcxOTgxMDQwMDE0MzIxNzE3NTk4NDY5MzE5MzcwNjUxODc3Mjk2MDg1MjUwMzIyNTk5MjQ3MTQxMzk3NDI3MTg1NDM4NTczMzYwNDQzMTE1MjM0Mzc1XCIsIFwiNTEzNzcwNTc2OTMxMTg3MjA0NTczODczMzA1MTkzMjE2ODQ4MTA0MTEyODk1ODI0NDU5ODIwNzg3NTY5ODkxNTg0NDc3MTEwODA0MTQwMzIwNTU4NDM4MDU3MzMzNDg1NTg2MjE5NDkzODA1NTQwMjkzNzUyOTQ0NTEzMDM0MzAyNjkxOTcxMTU4MTA0OTQ3NTgyMTM5ODA4MzMzNzkyMTQ0MDI0NTI5OTI2NTc1MDI3NzcwNjc4NTA2MzE4NjI0NTMyMzkzNDk4MzUyMTUyNjA3MDUxMzE4NjQ5MTExOTQ3NDA4MzI2OTQ0OTgwMTQwNDg3MTc4NzE0Mjk3OTczNDExMDQyMjc3NTk1NTcxOTk3MTY5NDQ1NTQzNDc4Nzk3Njc5MTY4MDExMDYyNzkwODE4NjQxMjcxOTI2MTE1NDY3NTc2MjcwMzgwMzc3ODAyNDQ2ODMvMTA4NjcyNDY3NDgyMDUxMzk3OTc4MjY1MTYxMDU0NTg0MDY4NzgzOTgyNjM0OTU4OTAwNDg2Mzc3NDE1ODQ5NjkxNDQ0MDYyMDY5MDIwMzc2MTU0OTY5MzY3MjQ2ODMyMzc3MDA5NzQzMzM4MTc1MjczNTAxMjExMDYzMjA5OTEwNTQwNTg0MDY1MDQ1NzEzNDc2ODAwNDk5NDU3NDU0MzI0MzIzODQ1NzA1MTU3MjMwMzMyNDU0MzAxNDgxNzcwOTcxNDQ4NTAxNTg3NTg0NjI5Njg5NDA1MjU1NjgwNDE5MjY4NjA4NTY3NjM4ODQ0NzQ2MDUwNTcwNTY1NTAxNDY0OTEwMDE0NTg2NDkyNDQwOTQyMTEzNTQxNTMxNzEzMzc0NjM0MDYxOTI2NTExNTAwMjg3NjcwNjQ2MDAyNzAxMTI4MzgxNTk2MjQ1Njg4MzIwMDBcIiwgXCIyNTE3MTk5ODIxNTQ4MTUzNjU3OTEwOTA0MjQyMjkwMDI5MDI2MjI5NjIxOTM1OTE4NzcxOTIyMTQ2NDI1MzczMDU3MjQ4MDkwNDY3Mzg4NDMwOTk5ODcwMDM2NjA4Mjc4NTQyNDQ5NjYxOTcxODMwMDc2ODQ1MTEzMzYzNDQzNDIxNzU3Mjc4NjEyMzk0MTY3MTk1NDMxNzU5ODA3OTA4NDEzMzUzNzQzMzc3NTg2ODkzODcyOTMwODI4NTQ4MjU2MjE2NTEwNzM0OTEyMDI3NDUwNjQyNjQ4Nzg5OTI1MTQyNDgyMDIzNzEzMzM2OTM3MjU4OTMyOTc4NTAzMzEwNTUxOTQ1NjMwMzU5NjQ2Nzc3MDgwMDczMzI5MDk5MjY4NTI5MDY0NDM3MTIwMDAyNTY3NzU4NjY0NDE5NDQzMzc0MTEwOTQxODI0MTA2NzI3MjE4MzQxNzk1MTAwNzQwMzE2OTY3Mzg2NDk3MDkxMDU4OTE1MDY2MTQ3NjA0NDgxMjgwLzUzMTUyNDI2MDMyNDAxNjk2OTM3MDcyODA1NzczODg1MTM0MDc5MjcwMjY0MDkxMTYzMTgwNzE3ODY1NDcyMzIyNDUxMTEwODA2NTYzMzQzMzAyNzc3MzM4ODc2ODg4OTAzNTA4MzczNDA0MTI4OTMwODEyNDk0MzEzMDA5OTU4MDc2NTk5NTE0OTg2NTI4ODMyODU1MDc1MTI4OTM0Njg2NjQ2Nzc1NTg4MTAxMzIxNzI4NzE3NTM5MjEwMTMzNDUzODM5MjU5Njk1NjI0ODk1MjQzMDQzODY3MzI5MjE4Njc3OTAwNjAxNTU0OTkyODgyOTk1Mzk3OTU5MTI1MDI3NDQ1NzY1ODA0MjkyNjUzOTU0MTQyMjY5Nzg1MjM5MDI5NDg4NjcxOTc3MDAzNDA1ODkxNjg4Njg5NDQwODAxNTYyNDI4ODExNTczMjE1NDQ5MjU1NDEwNTUxMjkzNjQ2ODUyMDI2NTMwNTE2MjM1ODY2NTQ5MTg4MDk2ODY1MjY4N1wiLCBcIjkzNzE1OTQ4NTAyNzU1MzA2OTAyMDgwNTg2NDU0NzM0OTU1NDU0NzY2MTY5MzgwMzEzNzY5NjEyNTE0MDUxMDIwMTI5NzQxNzA3NzIzMzA2MTQ2MjA2ODkzMDA2MTkxNTM4MTQ2ODE2MDY3NzUwMDQ0NTUzNTk3MTgxODYwOTYzMTY3NDM2MTA3NDU4NzczMjE4MzI5Nzc3NTcyODM4OTEyNDk2NjcxMzc0OTQ1MDk5NjY0MzE4Mzk2NTc5NTgyOTc4MDM0NTY3ODYzNDM1Njc0MTc1NjAzMzAzOTI5MzU5MDI2NDM1NTczMjEyOTc4OTExMDQxNjk0Mzc4OTMyNjQ4MjY2MzU3OTQxMzIyOTg5Mzg3ODQyMjY0MzExMDg1MjA2OTIyNTY3MTc4MzAxNzYxMDM4NzU3MDkzNTg2MzIyODI0ODQ2NDM5NjYxNTk4ODIyMjk2ODE4OC8xOTc1NTI2NDIxOTUxNjY2MTQ5MTI5OTEzOTY3NzE4NDUzNzQ2NTY4OTE4NTQzNTc5NDgwMDYyMjExMDA1ODU5MzE2NTYwMTY2NDA5ODIzNDUxNTkyMDc2MDEyNTM1OTkyMzUyNjUzNTMwNjA5NDIzMTM5OTUzNDU0ODM4NjIxNTI0ODk3NjY5OTM0NDI0MTk2Njg0OTI4NzczOTA3NzQwMTYyOTk4Nzg5NDM0NTQyNDkyMDk5MTcwMDIxNjk0ODAxMzQxMzE2MTI1MzA5Nzc0NTI1Nzk1MjA1NjQ0MDAxMjQ5MDgzOTIzMzkyNjM1NDU5MTE0NDM4MDM2MTk5NzI3NjUyMzEwOTQ1MDI3NDU5ODAwODMzNTA1Njc1MDkwMTQ5OTE3MzUyMjczOTA5Nzg4NTAwNDgwODgzNzg3MjEyMTAyMTkzMjE4NzcxNTA3NTY4NTUzNzIxMjVcIiwgXCI1MTE5MzQ2Njc1MTA5MDgyNDk5OTgwNzU2NjcyMDUyMDY2MjQ3Njc2NjQxNTEwNjYxMDI0NjgyNTc0Mjk2MDc1NjU5NjcxNzQzMzk3ODgwNTkxODgxNDE5NTE2MzA3MjkyNjEwNDQ5MTYxMjM5MjMzMTM5MDg4MzQ4NTEwMTY1NDQyNTk3Mjc4OTY1NzE4NDkwMDcwOTk3MTczMTgyMTg0NDE3NjQ4OTg3NjExNDIyNDQ2MzQ3MjM1NjU5MDg1MDkyNTMwOTI3MzEyNzYwMjI5NDk5MDgzMzQ4MjE3MzkyMTI1OTA2ODUxOTIxNTAwMzYwNTUzNzU4NjAwNzU2Njk4NjA1MDQ3MTk3NTI5NDQ2NTk0NjA2MzM2MzY5NDI1MDQwMjM2ODgzMTcxNTQyMzY3NzEzOTUxNTAwMDA3NjAwMzU1NDA2NDkyMTI4NzQxNjQ5MDkwNTAxOTg5MTA1Njk2NTc2Njk3Mzg3NjEzMDM1MzY2MDgzNTM2NjI5MzU4NDQ0MjI5MjQ4LzEwNzczNDkxOTA5MzAwMTg2NDExOTc5ODczMzkzNjUwNTY3NzE2Njc0NTUzNzM1MDA4NDYzNTQ3NzgwNzk4Nzg1NTgxNDYzMjAxOTMzODQxNjY5ODIyMzExNzEzMTc0MTkzNTYxMzYyMzczNDYzODk1NzA0MjIzMzIyNzg0NDcyMTcwMzM3NzMwMjM1NTYzODM0MjAzNzI2ODUwNDk2MjAzNjE0ODEzMDkwNjcwMTc2OTc1NjQ3NjA3NDcwNDc4Mzk5MzA0MjI1NTMzMjQ2ODEyMTgyNTMzNTk1ODYzMjA5NTI4OTYzNTIyNDUzNjY4ODUxNzE1ODMyMjE4NjQxMTIwNDAwMzg1MzExMTY5NDcxODc0ODI0MTMwMzE0ODMzMDk1MzQ1NTM0NjE2MTM3MTczOTg1MjMxMzIxNzY5NDgzMjE5NjQwNjY4MzM5MDEyMTU4NzgxMzM1OTQ3Mzk4MzM5MTA5NjA4NDMxODU0NjQyNDE4NDAwMzkzOTAyMDQyOTUwOTc4NzVcIiwgXCI1ODQ2OTk4MDg1MzMyNzAyODYyODg1NDM3ODA1MjU0ODQzNTIyNTI2NDM1Mzc0NzQxNDYyNDYyMDg0NzQ3NjAzNjk3OTI5MDYwNDYwNDk4ODYzNzQ2OTk3NzYyNDEwNTQ1MTk1OTc5NjE0MjExMjIwMDI4NTM2NjE5OTI0NzA3NTUwMzQyNDIwNDA0NDg4NDUxMjI2OTA3MTA2MTE3Njg3NzIyNTMxNTg4NDE4ODQwMjk1NDI0OTY4MzEwNzYzOTc3NzQ3OTY2MzI3NTQyODQ2NTI0MjkwNTMxNDQxODkzMDA1Mzg2OTQ2MTkwNDkzNDEzODc1MjAzMTEyNDY4NTU0MTg1MzU5OTQwNzcyNzQ0Njg5NjU1ODA2NDI1MjY5NjgxMzM3MDY5MjY2ODQ5NjQ1Mjc4MzAwMzMwNjM4NjY2OTk2MjExMDczNDI1Nzg1MTk1NTAwMTQ4MS8xMjI4NDQ1ODc4NDQxMjUzMzY2ODk2MDM4NzA0NjU4MzQ0MDE5OTY0NjA4MTM2MjQ4NDMyMTA3ODg3Mjg5MTQzODU1MTYzOTQ3MDgyNjU4MjkzMzg3OTkzNDcxMTg2MTU1MTAxNDI1ODQ5Mzg5ODg3MDg2NzU0MTM0OTk2MjUzMTQ0NzcyNDM5MzM4MTAxMTYzMzc4NTg4NDc0Mzg4OTQ0NTQwNzc0OTIzODE4MzA4MDk0MTg0NjUyODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCBcIjYzMjY5NDMzODAzNjI5MTA4Njg2ODI5MjU0MTczNjI3MjE1MTUxNzIxMjk3MTY0NzY4MDk4OTU1MzM4ODE5OTM3NDczOTg0MTQ5NDcwMDMxNTcxMTE4MDk2MTc2MDM4NDQ4NDA0MjE1OTUzMzk3OTg3MzYwNDM5NTYyMTAxNjI3Mjc3MjEwOTYxOTQwMTExMjQ1MjEwNTQ3NTkwNjgxMjMxMzU0ODU4Nzg4MDg5OTA1ODkwNTQxOTIyMDQ5NzQ1NjUwMjU0Mzk3MTEzMTIyNjQzMDc3NTY5Mjc0NDUwNjA0NzAzOTk1ODU1MTY0MTI3MDA3MDk5NjExMDY2MTAzNjM3MTM2MjUyNjQwMTUyNTIwNzQ5MzI3MDU5MDk5OTM4NzQ3NjI3NTYyOTQxMjY4NzQ3MzM2MjMxMDQxNDYzNDQ2OTc4ODk3OTIzNjg5NTMwMDEyOTIyNzA4MjQyMTAyMTk5OTIxMDg0MTM4NDU5NjYxNzQ1MjA5NzI3MzMyMDUwOTM0ODE1OTQ4OC8xMzI3MTA4NzQwODcwNzUyMjE2MjYxNTcxMzYxMTA5Nzg1MzY0ODgxNjgzMTMxMjcyMjg3MDMwMjU0MDg5NDMxNTM3ODI4MDIyNjU0NzI5Nzg5NDU3MDM3NDIxNTI5NTQ4ODE0MzgwNTgzNzM2ODY5NzI0NzcxOTU4NDYxNjI3MDg5ODY5ODI3NDI2NDcwMzgwMTQxNDc5MDM4MTc1Mzk0MTg0NDI4NjkwMTE5OTU5ODgwMjQ2MzgyNzg3NDY2NjQyMzAwNDY0NTI1NDU0OTk3MjI2MTQzMjAyODQ0Nzg5MjUwNTk1MjcwODY2NjM0NTU0NzgzNzQyMDAzNTIzNzUxMjE5MTAwMDA5NjcwNDQzNjY4MzEyNzU2ODEyNTQ1MzA5MTQzMDYwNjQ1MzUxMTA1Mjg3MjM0ODIyODI1MDEzNTg3NDkwMDE2NTc2MDgxMjIzMDc2ODY0ODI3MjA5MjYxODk1MzcyMjc0OTIwNDExMzUwNTUwOTA3ODQwNTk5OTQxMTgxOTI2MjVcIiwgXCIyMDIyNDIyNDY4MjQyMTUxMTkwMzQ3NTExODgzMTg1ODQxMzMzOTY4MzkwOTkxNDMwMzYzNjYwMjQ4Njg3Mjg0MDIxNTI0MjA2MDc5MTYyMjEyMDA3MjYzNjA2ODE5Mzg3ODIxMDU1MTgzMTkyODcxOTUxMDc2NjQ0NzA3MTExODAyOTcyMzU0MTI4MDExOTA0NzIwNTg2NzI5OTE5ODI2NzU4NjUxMTY3OTg0NTA3ODA0ODY3OTU0OTcwMDY0OTM4MDIyMTA2NDg0NjU2NTYwODY2NDQ3MjkwOTM0MTM2NjEwMjE0MTc1NTE2NDg3NTc5MTIyMzI4MDU1NDgyMzkyMTM3NjE5ODI5NzM5NTYwOTIzODA3ODgwNzc5ODY1NDQyMDE2NTMwNzEyOTg2NzUwNzExMTk5OTk4MTkwMTQ4ODg1NzI2MTQ0NTk2NjYzMTQzNjUxMjQwLzQyMzUyODAwOTEyNzA3MDQ1ODYwMzgzNzU4MDg0NDU1OTM0NzQ5Mzc3NTIzNjk3MDI1MzUxMzIwMzE4NjkxMjA5MTE0MDI1MTg1ODYwNTM1NDIxODcxNTUwODA5MTM5NDU2NDAwMDMwNDQwMDg1ODc2MTc1ODgzODE4MjY1NDIwMTY1MzkwMTQwODA0Njk3NDY2ODU5OTIxNjgwNDIyMzcyMTExNDMzMTA4NTUwNzc1MjYwMDgzMjM5MDIyNzA2ODk4NTY5MzAwNjAxNzU5MTMwNDkxNjUxOTU0MDI0NTkwMjY0NTcxMjUzMjk5Mzg4OTAwMDA0ODk5MjAyNjkzMTQ3NTc1NDUwODI0ODI2NTM1NjE4MTA5OTgxNzQ2NzYwODg2MzA2ODA2ODk1Mzc1NjA1NTMzNDIxMzU4NDY0OTEzNjU0MTQ5MDUzMDg0OTU3NzM2MzY0N1wiLCBcIjE1MDU0MjIwMTc3NjczNTIzMTYxODcwOTY1MzM4ODUwNjM5NDg4Nzc3NzgzNzY0NjY1MTQwNjAyMzE3NDY0MzI0MTc4MzAwNjc3NjAxOTM4ODMzNjMxODIxNjA1MzA0NTMwMDQxNzA4NjkyOTA2MTU2NTg2ODY2MzAzMTIzNzUwMjEzNzE1MDg4MDMxMzkyMjQ4ODEwNjc1MTI0MTAwNjcxNTQ0OTQ1ODczNjcyMzEyOTU0NTQwMDEzMzQ1MDM3NjMzOTE1NjA2MjM4Nzg1OTUzNjI4OTY5NDcyNzYzNTQ2ODMzODIzNTA4NDUzMzU1MjUwMTYxODY1OTI3MjA0Nzk2NjA0MDgzODUwOTI4Njk0MjgyNTQxNDQ2MzUxMTE3NTUzMTAwMTQxMDkyMzAxNDc1MTEyNDczMjc0ODA5OTM1NTQ3NjMzMjY0OTQ1ODQ3MTEzNTAyNzc3MzM3MTU0MTU3MjM3NDAxNjAzODUyNTMzNjcyODI3NjAyNDY3NjYwMTc3ODI5OTI2NC8zMTQ3NTYxODUyMjUyNzk3NTcyODg1MzM5MTE0NjcwMjE3MjM0NzI5MDgxOTI1MjI2ODU1MTIxOTc3MTIwMTg0NjcwMTY1ODg0ODc1NDMwMDgzODM4MzYzNzI0NzAxNDcwNTcwNjA2NjA1MDY3MzA5NjI3ODg5NzkzMzgzMTI3MjYwNzc3NDExMDE4MzQ4ODYxNTMzODAyMTY1NjkyMzQzMzMzNTY2MTg5MDQxNDc0MDY2NDQ4MDY3MTE2MjQ1OTI3MTg1MDg3Nzg1NTUyMTg2OTc0MTgzMzAzMDM4NDY4MjU0OTY0ODYyNjAzODMxNDY4NjYzMjE5NTE1ODUwNzY5MzMyMTUwNTUwMDg4ODk4ODE4MzI3MDI3NjEzNDY2NzA3MTAxNDA3NTAxNzMxNzY5MjEyMTk4NjE0NDc0MjQ3MzEzOTA3ODg1NzgxNjU3ODEzMzY5Mzc3NjM2ODg4MjU5Njc4MDEyMDQwNzk0OTA3NjEyOTY4NTcxOTMxNDcwMzQyNjI3ODg3NVwiLCBcIjE2MjY2NDM1MTQ5OTI4MzE4MjU0Njc4ODEyOTg2NjI1OTAxMTU0MjUyOTAxNzE1NTYzNzQwNTMyODAwNTA4NDM1NzA3ODA0ODA3NDA2NTU0ODM0OTYwMjYyNjcyNDI2NTMwNzczMzAwNTc0NTI0NDMzODk4MjY2MTA5MDUwNjM5NDcwODE3MDEwNTkxNjE3NzY3OTcxNDY2NDQzMjc1NDE1Mzc5NTc3MjgxMTM4OTYxMjcwMDA1MTAwMjMzNjcxOTg0Mjc4NDA5ODUwNzQ5ODI4NjI2MDQ1MDkzOTI4OTEwOTEyMzc1OTg1OTcxMDI0ODYyMTU0NDI5NjAwODM1NjA3MTQxNTcxMzkzMTcyMTEwMjgyNDQzNDk2NDMzNjY2Nzk4MDA2MjcyODY1MzU2MjM2OTY5NzI4OTc2MTkxMzkyNTIxNTYzOTQzMDQ5NjQ0MzgyMDQxMTgxMTY1MS8zMzk1NjQzMzI5ODUwOTIzMjYzMjMyNzY2NzIwNjkzNjM3OTI0ODE3MjA0OTYxOTY0MDA5MTE4NjY5ODY3Nzk1NDg3NDI5NzgzNzc2NDIzNTMwMDgwNjgzNjM1MDAxOTU2NTk3MDU1MDUzMzIwNjIxNjU5MDYzOTAwODYzNzkyNTI2NjQwNTUyNDcxNTA0MTM3MjQwNzcwMTk0Nzk1MzI4MzgwMzg1NDE1Mzg3Njg0NDMyMDI4MzczNTI4MTIwOTcyNTY1MTAzNjUxMzQ5MTI0NjIzODYyMjk2NzAzMTk3OTIzMzI2NTEzNjI4MDY4Nzk5NTE4MTM3NTU4Mjg0NDc4MDgzMDUxNzgyNTU5NTI0NTUwNjMyMTg3OTE3Nzk2NTg2ODc0NzU0NjEyNzY4NTI1Njg2NzQ1NjMxOTExMjI0NzU3MjM0ODQxNjY1NTM2NzY2NzE4NzcxMjAwMFwiLCBcIjI3MjI4NTgzNzEzNzM0MTgzNjI5NDUxODA4ODg5MTQ3NTU5MjQwMjU0NTcwNTU0MDQ0NjY3NjA3NTE5MjM4ODY1ODkxMDg0MTY1MzgyMDc1NjU4NzA3Njc1NDA1NjczMjc2NjE1MDM5NzAyOTE2NDQzMTUyOTU0MTU3NTM1MTk1NTA4MDMzMjg0MzU1NTgwNzQyNzYxNTY5MTAxOTM0ODIxMDg4MDM2MDg0NDgwMjk3NDQyMDE4MDA1OTcyNjUzMTI0MjQ4ODM4NDIwMDIxNDQwODk5MzY4ODY5NzQ0MTQxNjk4NTU2MzU5Mjk1NDg5NDcwNDk5MjQzNDAyNzk5NDgzMDgyNDA2MjM4MTI4ODc1Mzg2OTM5Mzg5MTIzMzM2MzAzNjMxOTkzNTU3ODQ0NTY1OTI3OTYwMDA5NzQ0NzgwODIzMTY2NDYyMzE0MTE2MDM5NDY5NjIyMjE2MjYzMjIxMjc4NDAyNjczMDI4MjI1MjE0NTM0ODU5MDc2ODU3NDEzNTU3NDY2MzY4LzU2NzUxMzQ3ODczNDAzNTkyNzYzODcwODU5MTA3MzI1MzA2NzgxNjM2MDQxODcwMDk1Njc1NzY4OTUzMzExMzQ1MjExMzIwNzEwOTIyOTMxMzkxNjc4MjQ5NTcyNTMwNTA2MzcwODU4ODU0MjYxMDAyMDYzNzA5NzQ0NzkyNzkyOTI4MDQ5NTkwNDk5OTk2NDc1Mzk2ODQ3NjY2MzIyNzg0NDkzNTc4OTM1NjA1NjE2MDg2MzMzMjk1NjEzODU3NjUwMzU3MzgwNzE3MjYyMTQ1MTA4MzIwNjY4ODUxNTY3NjcwNjAzMjQ0MjczMzA0MDE5NjcwMzQ4ODk5NjY3Mjc2MzgyNzYzNzEzMjA0MDEwNTMzMDI0MTMxMzY1NTExNDIxMDM2Nzg0MTI2OTIxMTE5NzMwMjg1ODc5MjIzOTk2NzA0NTY2NzAzODAxODk1NzA5Nzk1ODE2NzQ2OTkxMDI5MzQ3MzM1NjMzMzAzODI4MjE3MzIyMDA2ODIxNjMyMzg1MjUzOTA2MjVcIiwgXCIxMzQwOTM3NzI2ODE4Njg4Mzg3NjM2MDE4Njc3OTYwNTE4NjIyMTA2OTg5MzExNTc3NDQ1NjE0MzQ3MDYxNjE1NDE3ODMxMTYwMjk2MzY5NTAwNzA0NTI0MDIyODY5NjEyOTczMzMxNDQ0MjQyMDAwNzg4MTEwMTMzMTU3Njg5Nzg2OTc2ODM0OTEzMjk3NTQ0MDg3MjQ5NTkzNjAxNDIwOTcyMTExNzg5NTUyOTA1ODQ2MTY4OTMzMDE0NTcwMzk5NTYyNDYwNzg5MDc1ODcxMTEyMjI0NTMzNzIzMjU5NjYwOTY3NDgxMjg4NTI1MjIwNjg5NTc3MjkwMzg2NzgxMTY5MzE2MDA4OTg3MDEyNTY2MjE2MjM1ODc2ODQyNzU3MTgzMjMzMjA3OTQzMDcxNTIzNDQ3ODU1NjIzMDAxOTIwODU0NTcxNTk3ODg2NDkxMTYzMTY1MTUwNTU2LzI3OTA1NDM2ODgxNDUyMjQ4MzI0MTQ0NjU5NDkxMTk2ODUxOTc2MDg2OTE4MDQyOTA3OTc4MDgzNzk5NDgxMjQzNjM5NTc5MjU5NDQ0OTkyOTYxNzI5MzUwMzk3NTE2OTQ4OTk0NTEzNjI0NDYwMjM1MDk0MTY5NTQ3ODg2MTU4NDI2MTY2NTU4MjEyMzAzODM0MDgyNDcwMDIyNDU4MzE3MDI3MDQyNzE2MzQ2OTc2Mjc4OTYwMzY1NzAyNTk1ODY5NTU1MTQ0ODQ3NzA1MDk1ODU1NzY4MTI5OTQ5NTA0MTk5NDA1MDk1MTY5MjkxNjAzMjUwMTg4NDUyMzE1MDk3Mjg0MTc4MjY1ODM4OTgzNjA1OTIzNjA0MDA5MTYwNTgzODU4MzEyNjQwMDY2MDM0NDM0NDYwMTg3OTk2OTM1NDA1MzEzNzU2ODU4ODMzODA5NjU4OTA5NTg3NVwiLCBcIjg5MTA5NTE2NjAzMzkyNDk0Nzk1MTc3MzE1MzA3NzM1MDkwMzcwMzQ5NzczNTM0NTcxODU0NTM2MTc1NjkwNDY4ODUxMzI0MzQ1NTI3NzE3MjI3Mjc0NDI2NDkwOTUwMDc4Mjg0Njg4NzgzNzQxMzkwMDE4MDg4MjU3NDE4Mjk3MjgzNzUzNzAxNDA1MDUwODgxMzMyNDQ5NTIyODgyMzk2MTkxNDE1NDQ2NjE2OTUwNjUzMTg1NjgwNzQ4NjMzMTcwNTQ5ODk5ODI2MjA5NDQ2MDIyNDU5NjcxNTU0MDA3MTI3MDIyNTkxODA0NDMyMzg0NzM4ODU2OTAyOTcyODE1MjU5NjA2MTg5MDU2MjUwODQ2Mzk4NzA0MDcxMTMwMjk3MTI1MTAzNDUyNjIyNzk1MDcwNTUxOTcwMjQ2NzcyOTI1MjMyMTQ0NjczMDY4OTg1NzM5NTY2MDQ5Mjg3MzAzNzczMTgyMTA1ODg4MzcxMjY0NTA5NDIwODY1Mjc4OTM0Mzc5NTQ4NjQwMDAvMTg1MTU3MzI1NTI1NjQ3NjM2Mjk3NzYwNDc1OTY1NTI4NDI2MzM1ODU5NTI1NDM5Mjc5NzA3ODczMDQwMTExMzU1MDUyMjIxNDE4MjAzMDAxNjY2MDQ1ODc4MDE4MDYzNjkzMDU5MTE0OTAzNDQ5OTE0MjQ2NDM1NzUxMTE1ODg2ODYyNTMwOTQ0Mjg0Mzc5MjE4OTM5NDI5Mjc4NzY1Nzc3NDYyNzQyNTgxNjY5NDYyODgzOTk4NzQ1NjQ3Nzc5OTM0ODg3NDg1MzU1NTU4NjkzMTg1MDc4ODY0NTY3Nzk5ODAwNDE4NjQzNzMwMDE3MzA4MDA4ODgzOTkzMDM4NDQyNDc5NzcwNjM4MTI4MjQzMDIwODk2MTU2NTU1NTk1MzI1NDE0NTAwMjMxODg5MzE4ODE5NzU2MTMxNTg1NTI4NjE3MzI3NjU2NDAzNjQwMjU0Njc5ODMxODM1MTIyOTk3ODEwMzI3Njg0MzgyMjM0NTAwNDc1NzY2MTAwNTg3NjYzODAwNTI3NDAzN1wiLCBcIjg0OTk3NjYzMzUyOTg3NTM2NDE3MDM4NDk2MTI4MTExMTU5MjEwMzg2NDU1NDE5NDMxMTM3OTMxMzA4MzAxOTg5NDE0NDYyMzExMTM1NzA4MTE0MzIyMDQ2MjM0NzA4MDUzNDQ4MDk4NTM4NjI5MTY2NjcyNDU2NzAzNjUxNTI0NDgwNzM4MjE5ODIyODU4NDY5MTAwNDU0OTMzNTgzNzc0NDA0MDMyOTY4MzA0MzI4ODU5MzY1NDg0MjQ5ODk3OTEzNjc2MzgyOTA5MDUwNDUwODU1MjIyNTY3MTQ3NjYxODQyMTg0NTM4MzAyOTkxNTI2NjM1OTc0MTU4ODYyMDMzMjg3MTU0MzIxOTA4NDgzMDA3NTA2MzI2ODA3NDY5MjM5NzQ1ODUxMzc5NTU5MjU5MjYyNDI1Njc1MDM1NzkwNTc0ODQ2MjI5NDcwMDQxNTk2ODAxMzQzMDg3MDQxLzE3NjM0Njg3NTc1MTIyNzE1NTA3OTE1Mzg4MDk2ODU3MDY5MzY2MTQ2OTgxMTU2ODk3MjMwNjIwMzcxNzE0NTE4NzA3NTE4MTA1MTU3NDgzMjgzMjUzMzc0Nzk3MTI3MDc1Njg5MjM2Mjk4MTE0MzM1NzM0ODc0NTUzMTgzMjkxODA2MjY4MTQ5NzQ3ODI2MDUwODM4MDg5OTMxMzUxMTU4NDgzOTgwNzM1MzM2NzcyODc5MDQ1MDI3MjEzOTgyNjYxNjM0ODY1NTU2MTI5NTQ4MzU2NDg3NzIyNTM3MTkzOTE0OTg2OTk0MjgzNzI5NzQ2NTc4MDQ0NjIxMTE1NTg5MTk1MDY2MjEyMDQzMTg3MjI5NjA2OTIxMDYyMDA3MDQ3OTQwMjkzOTcyMzgxMTIxMjAwNzIzMjkyMjk3NzE2NjIxMjMxMzIwMjU0MzA5MDYwMzIxNDc2NjA4MDAwXCIsIFwiMTY0ODg0OTI1NzQ4NjMxMjkzNTQxNjI3NDAwOTQ3NDUyMDU4OTc5OTc1MDc1Nzg3NzI1MjM5MDU0MzMyOTg1MTAyOTQzNzQ1Mjk4ODQ5OTQ4NTE3OTAyNjg0NTI5MjA2ODM3Nzk1NzY5Nzg4NDczOTA1MjQ5MTQ1NTgwNzY4ODQyOTYzMDUyNDIxMDgyMzU2MDUyNDEyMjU5NjYxMDI3Njk1NzUzNzc1NjE0MjI3ODU4NTA5MTMxNTE0MTA5NjE0NjM0MTc3Mzk4MjMwMjg4ODAwNzc1MTYzMjQwMTA5MDY0MjQ3MjUwNjUzODgxNzk5ODA0MzMyNjQxNTY5Mzg0MDg2MjI2MTcwMTM2NDExNDkyMzMyNzI4NjQ2MjY1MDc5Nzk2Mzk2OTI4OTc0MzU3MTUxNDg5MDcyMzE0NTI1MTU4Mzg4MTc1Mjg3NjM0MDYyODA3MzM5NTcwODcxNjczNTE5MjY5MDgwODM1MjE4ODg2NzMzNDg0Mjc0Mzg5NTczODk1NTc2MjA2Nzk2OC8zNDE1ODA0MTE5MDI5NjIxNDA1Mjk1NDc2MjIyNjczODE4MzQ0MjUyNjQ4OTMyMjY0NDc2NTg3MjM2NTQxMjA5MjA1NDkxNjY0MTYxMTQ4NDk3MzE1ODg1NTI1Nzg2MjYwNDE1OTc4NDcwMDI5NDYxMDU0NTk4MTIyMzA5Nzk5MDA0ODAxMzU0MjM3ODc3MTc4MjU2OTc5NTUxNTIxOTM1MjY3MjQwMjk4OTA4Mjk2MTU4NDUzMTQ3NjU2MDU3NzAwNjA5NzU1Mzg1NDI5NzY1MjMxNzc5NzYxODI0MDE4MjA5MjY4NTQ0MDY5NDUzOTIxNjcxNDAzNDc0NDQ0MzM4ODU3ODYzNDA0MTU0MzcwMDY3NzUwNzUxOTYwMzE0MzMzNjU4Mjc4NzQyNTQ0NzczNTEzNzQyMzY5MzI2MjQ1MTQ0NjkyNDE2MzQ0MjIzMTI5OTA1NTU1MzQ3ODk2MDczNzcwMjMzMzkyMzY0MTc0MzQ1NzQ3NTU1NjY4NTY0ODkwMTM4MjgyMDY2MjVcIiwgXCI0ODk5NjI2NjU5MjMxNjMzNDA2NTY5MzYyMTk5MTg3MTkyMzUyOTMzNTY3MzQ0OTYwNDk4MTM5ODU0NDYwNTQ1NjQ0MjEwMTE5NzIyODU2ODcwNjM0NjUyNTYyNTMyMDgzNTQ2MzQ0OTY1MTY2MzQwMDYzMjk3NjQ3NTIwNjEzNDU1MDM3MjQwMTQ0NzM0MDE0NTc1MTk2NzY0MDIxMTAyNjE0NzQ4MjE4ODM0MDU0MTU3MTY1NzgxMDU3NDA1MTAwNTc4NjY4MDAwMjkwNDkzNDMxODY5Nzk3ODgzMTU1NzY0OTYzMjM4NzYwNjEyMzMzMDQ4MzM2OTUzNDM0NjYzODY3NTgwODYyNjkyMjY3NTc0NTc0NDY1MzcxNjE1MDIzOTk5NTMxMDMwNDQ2MjUwMzUxMzA1MDQ2NTcyMjY3Njg2NTY2OTk5MjA5MjI5MjAyNTg3MjU4MTQ0MzE4NTkyLzEwMTM1MjIzNzc1NzEyMDkzMDM3MzIyMDcwNDg1OTc5NjQ1NTUyNjE1MTIzNDI4NjAzMjY4MjcwMjQ3ODY1MDA2ODY2OTI0NzU2OTc1NzAyODQxMjAzNTk4NDA3MjQ1OTY0NDQyMDkyNzc5NDg2NDg4NjMwMTQ0Nzk0NjAxODg0OTY1ODc3MjE1NzgwNzUxNTE3OTMwODE4MjM3OTUxNjE0MDQxMTA4MTE0ODAyNjkxMDY4NDYzNTk5NjQ0MzY5OTMxOTAyOTM2MTUzODE1OTM3NTYwNzY1MTUwMTI1MTQxMDAyODk0MDY4NjI0ODc5NzEyMjAwMjA3NTI2Mjg2NTM4NDUzNDU3ODA3NjYyNDQ4NDIzODYxMzY3NDA3Njg0NzQ3MDMwMDkwOTE1NTIwNDM5NDU4NDM2MzIxOTk5OTkwMDcwNzA4MDA4NzE1ODgyODk3Mzc3MDE0MTYwMTU2MjVcIiwgXCIzNjI5MDM4NDczNTgwODg0MjMwMzIwOTg5Mzk1ODkwMTk1OTgwMzY1OTM1MjU3MjIwNDA4ODc4ODMxNjQxMTU5ODE3Njc3Nzc4NzM4NjA3OTk5NTU3MTU1ODc0MzY1NjYyMzMwMTA1NDM5Mzc0OTg5MjI0MzU5NjMzODUwOTE0MDA2NzAzMDM5NTY2MTI4ODE5NzQ0NTA1NDg5MDQ5MDY5NDkwMzIwMDU4NzgyNDE2Mzg1NDY3MzQ1OTczMDg3ODY1MTQwODY2Nzg1NjE5MDA3MTM3NDE3NDY5MDU3NDI4NjY2MzU3Nzk0MzIyMTY3NjE3OTkzNzE3OTMyNjAwMjU1NDk2OTg4NjUzMTk3NjA3ODY5MjE0NDQ1MDUzMjM3NTgyMzUxNjQ4MDc5NjYyNzcwMjQwMzE2MDU2NzM0ODE0ODA1OTAxOTM3MjQ5ODA2NTk0NDg2OTI0ODcxMDg4OTIxNTQ4MDk0OTAxOTk0MTQzNzAwMjM2OTY0MDQyNTk2OTEyOTk2MTQxNDc3MTIvNzQ5NTk2MDMxNzM3NTYwOTE5MjI0MzU3MDg1MDQ3NTE0NjE0NDgzMTg4MTk1NDg5NDM1ODY2NzYxNTk1NDUwMjgwNjM5Nzk2OTU4ODA5MzA5MjY4MDU1NzQ5NTEyNzU2MDI5NTEwNDc4NDU5MDQ3NzA4Mjg5MDA2NDU3MTc0NzcwOTg5ODgxMjQ1NTM0NzQ2MTY3NjQwNDA5MzgxMjExNzE3NzY1NTY5OTkwNjkzNTE3NzIyODYyNjI1Mjk3MjkwNTYyODg0NTEwMzc3MTcxOTgyNzM1MjE4MTA1ODU4NjgzMDc0MDI2OTMyNjE0NzkyOTg5MjMyMDk1ODcxNDM0NjgyMDY5MDcyNzgyMjA5MDk0NDc0ODM3Mzg3MzA2NTc0Mzg5NjE0MzU1ODc3NTI4NzM4NzkyNDQxMzY4MDExNjg4MzY3NjcyNzM5MzQ5OTc0MTcxNTY1NDM4NjY3MjIxNzE3NjY3OTQxNzE2MjMyMjQ4NTUzNTg2NDAxNTY4NTg2MDY4NDM1NzYxMjVcIiwgXCI4NTIxMzQ4MTU0OTU4NjEzNTUwNTc0MDk1NzQ1NTk2NjU3MjQ5OTI0MzI4MzM2MjYyMTI3MjQ0ODI3OTU1ODg2NDc0NzQyMzE5Mjc3NDI0MzgxMzYwNjc3NjU1MjM5MDE3NTgzNjA2ODUxNDgzMzE4OTUxNDQwNjkxNzU3ODc1MjcwMDAxMjgzMjI5NTg1MDc1MTM3MDkxNjE3MDczNTA5MDQxNjQ0MDk3NTI2MDQ3MTI3NjE4OTU0MjkzODgxMjY0MTEzNjk0MzYyNTk4MTU3NDU2ODc4Nzg0ODE0Njk2NTc3MDgzOTk3OTAyNTg4OTI2NDIxNjc1ODQzMjkxMTU3MDQ5MTUzNzAxMTAwMjE4Nzg0NDgxNDA2MDg2ODEwMjY0MjQzMTQzMzM3MDE2MDQyMzAxODA2Mzc2ODY0NDI0NjMyMjkwMjI2Mzc3ODgxMjA2NzY1MDUxODk2NzQ1LzE3NTc1ODQ2NzMyNTQxNDUxMDk2MTQ5MTQ4NjIxMzQyMTczNDU0NTYwNjU4NzM5MDgyNjI3NTMxNjk0MDQ4NDg2NTg5MTM3NzQzNjM2NTA4NjM5MDQ2MjcxODMxMDQ3NzczMzc0NjE0NDUwNjM3MDQ2NTUxNjQzMjU5MzA4OTEyNjk4NDM2Njk4NjA0MDk3NjM1NjkzNjI4NjM2MDA5MzIyNjczMTkzMzU4ODk1NDA0NTMzMDI3ODUwOTk1MzI2ODgyNjQ0MjU5ODg2NzcwODIwNDQ5MDU5NDgxNzkxNTMyODYyNzY2MDk5MTAxNTg4NTQzNDk3MTEwNTQxNDQ5NjgxMzE5MzQ3MTM0MTk3NzI4NTI2NjM4NjA4OTMyNDEzNjQ0MzM4NzI4NTMzMzg2MzAyMTYyMzIzMTM2MDc5Njk3OTAwODM0NDg0MzM2NjYzMzQ3NDIxMDgxNzYzODRcIiwgXCIxODAyNDYxNDIwNTYyNjQ2OTkzODU2NzMwMDgyOTk5ODIzNTA4MTQ1NjAyMjM4MTI1MDU0NzE3ODM2NTAxMjAxNTQ1OTIwNjA0MDIwMzg5MzYxMzcwOTMxMzQ1NDkxMTYwNTQ5Nzg3NDExNjY4Mjg4MzU5MDEzMDU5MTYwMzMxMzcwNzUxNDk2MzI5ODA2NDg4MjQ2MTM1MTAwNzc2MjYzNzc3ODYzMzk5MDk2NDg1ODk0MzA2MzA2NjIxODUyNTk2Njk0NzAwODQ1OTE4NjA4MTk5MzI5MDkxODUyOTU2MzE1ODcwNjY0NTMxNjE0MzU4Mzc5MTc2NjgwMzI2NTA4ODc3MzI5ODYyNzEzMzMzMzM2MTg4NTU2MTgxNDcwOTI4NjEzNDIzOTcyMzE0OTgzOTY0NTc4NjQ1Njg4ODc2NTU2MzUxNDMzNDI5NDk0MDA4NTEzODEyMTM2MTUyNTc2ODY2NjUwMTUyNjIzNTEwMjk2OTExNzA4MTExMDg1NTE4OTc0MTQyNzI4OTAzNDI0LzM3MTIzODQzOTI1MjA2NDAxNjIxNDQ0ODExNTIzMTEzOTM2MDgzNTQ4MTkyMDczMTYyNTMyMTA4NDYwMTU2Njk5MjQ5NzA1NzM3MTQxNjEyMTQwNzI5MzI4NjAyNzgzMjM1NzgxNjI1NzUwNzI4NzI5NTcxOTI2MTE0MTQyNjEzMDE1OTI2OTQzMzE5OTg2MjAwMjg0MTQzMzIzNTk1NTgzNTE3Mjc3NDQzMDY5MDM1MjQ4MTgwNjkzMzg2MDM5MDAxNTg5OTk3MzI5OTI2ODM2MTUxMzY0MzUyNDA4ODI0Mjk3Mzk2ODUzNzU5NTA4NTYwMDMzNTAyMTEyMDUyMzg1MjQyMDEzNTA4MTY0MzMxMDY2Mzg2OTMyNzM3MTgyMTA2NDg2MjQ0OTQyNjQwNDA0NDk1MTU3MTU4NTQwNjA5MjUyMzQ3ODg2MTg3OTE0ODU0NTY3ODYzOTY5NzY3OTIxNTI4OTUyMzIzNDM0MjMzNzM0NzUyOTIyNTU0Mzg1Mjc4NzU5OTAxNjI2NTEyNVwiLCBcIjg4Nzk1MjgwNjcwMTEyMjQwOTc3OTQ1MDgyMDY5MjE5NTQxOTAyNDgxNzY4NTA0NTM2MTY3ODA4ODE2NDUzMDIxOTYyNjE2NTk2NDEwMzk2ODEzMzE2MDY0Njg1NTc5NDEyNDI5OTQwMDE5MDcxMTE0OTE3ODI4OTI4MDgwMTgxNjM4MDU4NDQ0MzAyNDM5NjI2NDI1MTU1OTQ2NTYyMzYyNTUwMDcwMTg3NDMzMDgzNTQxNDE0NTY5NDQ3NjEyMTk1MzcwOTExNDk4MzIxMTQ5MzY3OTY5OTc0NzYyMjQ0MTQwNzg4NDk0OTU1MTQ2MjgwMjAxMDIwMzQ1ODQ5Mzg1ODY1MDg0MDk1MTg5OTgyMjkxMTkwMTM1MjkzMTE0NDg5NDA3ODAxNzQ5NTMzNDQ4NDQzMjIyNTg0MDkyNTc1ODYxMDk2OTQ2NjA1NDE4NDM4MTgxNDExNDg5Mjc2LzE4MjYyNTk2MjIzMDY5NTQ5MzEzOTY5Mjg4NjkzOTcwMjQ2NjYzNzI2MTQ3ODg2MzY0MzU0NTg0ODI1NjI0MzExNDg2NTU3ODgxMjM5MDAzMjE2OTcxNjMwNTk5Mzg5NjQyNzUyNjQ4ODE1Mzc3Nzk1MDE4MTMwNDQ5Mzg0NTEzODI0OTI3MTM4NTY2MjAzNzE0ODkxMDkwMDE3Nzg3MjU4OTIwNTI5OTkwNTIzNTE5NDc5MzgzMDMyNTY0MjA5NjI5OTgzODEwODY2MjMxMzY3NDM4MjcwODU5NDIxNTcyNjQxNDk0NDIwODMxNDM1NTYzNTgwMDUwOTU0ODY3MTAxMjkyNTY4Mzk5MTA3OTY1OTgyNzA0MjE2NDM0NDY3MjQzMjIzOTY0OTY0NTM1NDY0NjI0OTg4MzQ0MzQyMDg0MDg0MjM3NDg0MjYyNjEyMTAwOTgwNTE5NjAyNjI1XCIsIFwiNzUyOTExNDA5MzU4MTU4MDcwNjg4MTMzMzM2OTE4MDc4MjM2NDM4MDg2NTIxNzgxNzMxNzM1MTIzMjk0NzQxNzMxNjY5NTMwNzM0OTA5NTYzMTU1NzMyMDkyNDA2MDk5MDAzNTgyNzQ5MTgyOTY3MjQ2MjM2NjU3MDIxODc1NDg4MTMwMzA0MTA4MDgyNDA0MTM0MDA0MzgxMTk2OTI1MDQyNjE3OTA5MTA4NjU0MTA5MTM4NzAyOTkzOTAzNTYxMDM2OTg3NTExNDEwMzk2NTY3NjM2MzMxNDY1ODAzOTQ5MDQ5OTQ2OTQ3ODg4NDkwMjg3MjEwMDEzNzg4ODAyMjg3MjQ3NDIyOTkzMzg0ODc0NjcwMzY4NjQ5NjE2NzgyODM3MDk2MjMzMzg0Mjc5ODE3Mjk0Nzc4OTE2NDE5MDY3NDA0ODYzNDU4MzE4NDUxNzIyOTcxMTE3NjY5NjQyMTM0ODk0OTA2MjM1MDY2MzMyMjA1NzQwODcyOTM4NDA2NzY3NzY3MDE5MjY1NjY0LzE1NDYzNTMzMjg4MzA4NjM3NzY1NjgxMzQ1ODc1NDU3NzI4ODgzNDIxNjY0MTU3NzQzOTM1Njg5MTU4NTEyNTcwMTAyMDU3OTc2ODMxNTUyMDMyNDI5MzQzNTAwODU2MTYyNjkyNjA0Njk4ODA1NjMwMjc0NTYwNDI0ODIyMDQwODE1NDQ1NDI2NzY0MzIyMjMyODY5NjYwNjM2NzQwOTcxNTM2OTQ4MTU2NzIxMzY0MDEwMzA3NjExMjE0NjYxNTkzODE4MDA4OTMwMzI5NDcwOTAwOTgxMzc3MjUwOTYwMjk1NDUxNDM5MTY3NTE1MjU5NzQ1ODQyODMyNjY0NDk4ODIyNTU1NTk4Nzg4MzI1MDY0MjM4OTU1MDUzMTE2MzE1MzMzODU0MTg3MDAyOTQxNTA3Nzk4MjUzOTYxNDc4NDIwNjExOTA3NDcwMjAyMjExNzc5MDY3OTM1MTc3ODk5MzU0MTQyNjExMDQzNjI3NjUzMDg5MDYwOTEzNzcxMzkwOTE0OTE2OTkyMTg3NVwiLCBcIjE1Mjg2MDg5MDc3NDM5OTE4NTg0OTUzMTQ0NTU4Nzc1NzY1MDAyMDYxODMyOTUyMDkwODQ3MTE3Mjg2NDczODY4Njk0OTA5NzEzNzkxNjc4Mzk1MjIxNDM4MTEyMDA2NDc1MDQ3NjMzMDI4NTQzNTAxNjMyNjMxNjc5MzE2ODUwNTEyNzk3OTc4NTk0NDc2MjI5MjI4MzI1MjI4NDAzODQ5MDg5MDc5Njc1NjgxMDQyMjI0MDU3MjM0NDE1OTUxMjUzOTU0MDQ0MjM1MDk5MTM5OTgzMzg2MDU2NjEwMzg0NDg5MjAyNTg5NDg0NTcwODUyMDQ4MTU3MjcyNTUxMDk4OTA5NDU1MjUzMDM3NTYxOTk0OTQ0NjY1NTYzMjkxNTI2NTk3MzIzMTk5NTMwOTk3OTIzMjcyODk0MTE5MzUwNTEyNzI3ODAyNDE0NjgwNzcyNTEzNzYwMDgxMzYwMjkxLzMxMzUxNjE0MTgwMzc4MzYyNTk0NDI4MzEzMDI5NzcyMTk3NTA2MTQ3MjYxMzk2NTc3MTg3NzAyMDY5NjA3NzY1MTQ4MjIxMDcxNTU5Mjg4MDA2OTQzNzU1MjI1NzI1MjM3MTIyNzczODk2NzkwMzU2MzI1MzE3MjcxNTU5NTcxMjA1NjY2MTc3MzY4MTcyMjU1NDE2NzMxNDgzNTQ4MjkyMTI5Njk3Nzg2NjQxNDQ5MDc1MDM0MTE1ODkxMjYxMTE4ODg5MTc5Mjk0OTUxMDYwMjk4OTA1MzI4OTE5MTkwMDExMzg3NzAyMTA5NzcwMTI3MDgxMDc0OTYxODcyMjc3NTE0OTY5ODAwMDAxMzcyMjMwNDcwNzkxMjcwOTYwMjg5Mzk2MjQ4MzA2NTQyMjc3NTg3MzczMzk3MjUzNDU2ODE3NDU4NDc1OTgxNTc1Mzg0ODMzMDgwNjg4NjQwMDBcIiwgXCIxNzcyMzQ4MjM4MTczNzY5MzI2OTc4NzA3Njc5ODI0NjQyMzMxMDgwMjEyNjA5MjUwMDQzODY4MTg2NDY3MzM3NTcwNDQ2NDM5NDEwNTczNDA0OTA5OTA5NDgxODczODExNTM0NTcwNjEwMDE5MTU4MDk4MjcxMjE0Njg4MjAzNDYxODEwMzE2MTI2ODQ1MzgwODgxOTQ3MTYwMzgwNTM0NTk5MDE2Mjc2MjcyMjU0OTk2NDQwNjA0MjI5NTM1NTkxNjQ1ODYyNDgzNjg5NDI5MTI2NzU1MzEzODA0MTAzNTUyODMxNTgzOTEwODI1MjQyMjQ3ODYxMDg3OTMwMTY1NjIwNzc3MjQ5MTU0ODc0Mjk4MTk5MDQ2OTQ1NDUyOTUzNzA0OTEyMzk0ODYwNDkzMTY2MTgzNzUzOTk0MzUzNjg3ODI2MDY2NTYxNzUyNDgyNDYwNDI5MTU0NzM3Mzg3MjcxNjE5NDE1NDE5ODgyNDEwNzI2NjI3NTcxNjA4Mzg0ODI2MjYyNTA2ODk1ODcyMC8zNjMwMDkxNTY1NzI1ODg3MDg3NjA1NjAwNzcxMzU4MjE2OTI3MDk5NzQ4MDEzODMxOTEyMDgwMzgwOTgzNTQ1ODcyMDc3MTk3MzY2MTcyNjE5MjI1NzUxMjE3NjE5MDk3NjU3NDA1NjYwMTcyODAxODQ5OTI2MjIwOTQ4NDEzOTE5ODIzMDM4NDI1NTE5MDA2NDEzMDA1OTk4NTA5Njc3NDcyMjI2NzI5Mjk1Mjc4NjUyMjg0ODYxODM0MTc4NzkxMzMyNjMwNjc2NzcyMjg0OTcxNzYyNjgzNTc5MDQ3NTA4MDE2Njg3OTY5MDQwNjU4NTkyNDM2MjMwMDYyMDQ5MDUxMTQzMDAxNDg0Mzg0NzY3ODM2MzUzMjMzMzI0NTcwNjg2MjQ5ODI0OTgwNTA4NTIwMTg2NjQzNDc3MzEzOTQxMDU0OTAwMTk3MjY4NTg0NDk1MTI4NjEwODExMjczODM0MTkyMDk5MDk5NTkyNjg3NDg1MTc2NDAwNTM5NzQ4NjE2MzYwNzk5NTE4MzU3XCIsIFwiMzkxNjA1MTQwMzI0OTAyNTgzODkwMDMyMTQ1ODc5MDE3ODE3MjE1NDgwMTE2MzI4MjEwNTMyMzA4ODEyMzkwMDE0MzYzNDEwMTIzOTYxNjY4NTc1MTUxOTcyNTE0OTk0NjA4NDI5NTQ4NjMzNDI2NDEwMTUzMDYzMDQ4NTQyMjYxOTQ1NTExODkyMjQ3MjEyNTc2NjQ0MjA3Nzg0MTY3MzM4ODkwMzA2ODAyOTUyMDYxNzkxMDk2Nzk2Mjc1MjIxMTM1OTIzNzM5Mzg2MDI3Mzc0MTY4MjI5ODE2OTgzNjIzNjM1NTM0OTI2MTA4NDIyMDEwMDU0MjA3Mjc3NTA1MDU2ODEzNTg1OTUzNDAxMjcwOTk4NTU4MjM3NDY0MTA2NjM3NTAxMzMwMTk3NDMxNzA3MDA4ODgzNzU1NTQ5MTgyMTMxODI4NjI3ODkwMjg1MzEyODQzNjQ4Nzc0MzU4OTYvODAwOTkxOTMzNzQzNDc4NjI0NDM4MDgxODM5MDIxMzU0Njg2Njc5NDk1ODM4OTYwMzY2NjczNzU2MjA1MzQyMzc3NTM4NjE3MzE0OTM5NTk0MzMxMDI3NjQyOTg5NTk5MTkwMzc1MzQ0MTU4NDU1NzkxNzU2NTM0MzY3MzYwNTAxOTk4OTMzNjI2NDc0ODU4ODczNTM5MDE4MjEzMDMzNDI3ODg4NzY0MjU2OTUxNTIwMjEwMDg3MDA0MjIwOTI2MTU2MTAwMTYyNzM4NjUyNTE4MjA5NjA5MDE5NDA3NjgzOTM3MDU4OTc4MDQzMTMyNjA5Nzk2NTQyODMxMTc4NjYzNTM2NjgxOTA5NDYzMzY1MTI5NzE3OTk4NzM0MDQ5ODIxNTk0NzE0NDg3MDE2NDA2NjQwOTY1NDQ2NDU1MTAxNzc2MTY1ODc3NTIwNzM5MjgwMzgyNTk5NjM5NDg3NVwiLCBcIjE4MTg4Mzg4MTY3ODExNDc2NzYyNDc3NjU5MDA2ODQ5MTIxOTEyNjc5NzYzNTk3MTMyMjMzNTg4MTcwNDA2NjY2NzE4NzU4NTExNDc4MTU0NDE4OTQ4ODU1MTYwODM4MjEyMTUxMzcwNDUzMjEzOTQzNzg0MDY3Nzk2MTcyMTAyOTE2NjE4MTAyMDI0MTk5MjAwMDg2NDc4MDIxNTMzMTcxOTg0MjU0Nzk5MDA4NTQxOTQ4OTczNjUyMjE5NTMzODE5NTExODA3NjgxMTQ4MTc5ODA2MDUxODM1MzE4NjQ1NTkxMTAyMjk2MjU2MzQ3OTI3MDE4OTQyMzQ4NTc0Nzc0ODIxNDc4NDk5MDkyMDU0NDk3MzkwNzkwNzM0Nzk4MTQzOTgzOTQ1MDk2OTgyMjQwNTE3MDU4ODYxNDY3NDQwMjE3NTU4NTg2ODIyNjYzOTg1NTg0Nzc1OTIwNTE3NzU1OTA5NDQ0ODc2NDQzMjExNDA0MjIyNDAwMzM1NTAwNjA4NzMzMjg0NDYxNjg1ODg4LzM3MTUyNzgyNDE3OTUwODc2MTA5NDE1NDcxMzM0OTA4Mjc3MTExMzM5MDkxNDU0MTQ4NzgyMTc5NjUyNzMwNjE0OTM3NDA3MTk5ODMxOTE3NzUxMDU1NTA1NTk5MDUyODM3MzMxMzQxODkxOTUxOTAzMjE2NDM5NjU4NTg3NzE0NjE1NjAxMzA4NjQ3MTQ0Nzc0NDgwMTEyMjU4MTYyMTAyMTk0NTAwNDA1NTg1ODE1NzEyMDY3MTE3OTEyNzIyODQxOTc2MTQ4MTAwMjYyMjA3NDUxNjA2OTM4OTg0MjEwNjgxNjg2MzA4NzA4NTAzOTI3Mzk4MTczNDAzNzAxNDYxODY3MDM4NjcwOTc5ODI4NTg1NjAzNDc5NzEyODExNDI3NjYyMzU4NTA5NzE4MzczMzAyMjI5NzA5MDA2NjE2NTM4MDAwNDE3OTUwMjAzODI4NDc1ODgzNjI3NzQ2Nzc1NjgwNTkzNTUyMzgxNzQ0MDI0MTUzODQ3ODgyODA4NTIwNTk1MzI5NTgxMjE2MjVcIiwgXCI0NjM1MzQzMDYzNjg3NDI4NDQwMjM3NjAwODM2MTE3Njg4MDkzODc5ODc3NTUwNjIzNjcxNDA5ODEyMzkxNjY2ODU0NTMzMTcxODY3NzQwNzE0NTE5OTMxMTE5MTEwODE5OTE5NTQwNTEzOTU3NTE0NzkzMzI4MzUyMzMwNTM0MzAyNzI5NzgwODQ0MzY1MzQ2MDU3NTE0MTc5OTcyOTU1NDIwOTE4MTQ1NDY3Njg3NjI2MzU4Mjc1ODkxOTk2OTk0ODU0NjkxODQ3MTEyODI5OTUyMjcxNTY5MTY5NDg1NTkwNDUzNTQ0ODcwMzExODIyMTY4NTg4NzE5NTM4MzAyNTEzMzkyNDg1MjIyNDU2ODkyMjk5OTMxNzU4MzY2Nzk4NTQ1OTA0NzQwNzQ3MzQxOTE5NjM2NzgxMjk0OTU3OTg1ODA4MTE4MTY2MDYxMDE1NTMxNzkxMTMxODkzNzM0OS85NDU1ODkwMTc5ODk3ODI5MDUyNzA1NDA4OTMxMDY0MTIwODIwNTU5MjU0MjIwMzk0MTUyNDQ3NTAyMzk1Mjk4ODI3MzU3MTQ0MDgxMzc4NTEzMDgwMzk4ODIzMTg4MjQzNjYzOTQzMTc3NTM5ODE3OTgyNDgxNzEzNDU2Nzk4NzU3NTYzOTUyMTYyNTk4NDY0OTI5Nzg0MzcwMzA1Njk2NDIwMjQ1NjQ4MDM1MjIyMDgzMjA3NTk2Nzk3MzI3NDk4NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsIFwiMTM2MDc0MTQyMTExMjY0MTI2ODk0MzU5MjAxNzA4MzI3Nzk1MjMyMzUyNzkzMDgwMzk3MTIyOTQ2ODE1NzAxMjcyNDE0MDM0MDY0NTU3MjUwNjQ2MDUyMTA0NzM5MjM5NjU2ODU4NTgwMTIxMTQzMzIwMjE1NzIwODg1NTExMjc3NjI2Mjg4OTI2MTE0NTk3ODU2MjU0MDcxMDczMDAzNTUyODc2MjM3NjEwNDY0Mzg3MjQ3MDY5MTgzMDA5NzYxMDI1ODE5Mjg2NDM3NDA1OTYzMzY4NjU2OTg0ODU4Mzg0MzE5NzIwNTAyNjcxMTQ5NDAwNzkzNTM5OTYxMDA2MjAzMTEwOTc1NjE0MDUxOTIzNjU0OTYzODU1ODQxNjQ3MjUwMzU4NDIzMDcxNDYzNTEyMTExODM0NDMyNjc1ODM4NzIwNjczNTI4ODEzODcyOTQ3NjY4MDQyOTg2ODE4NDE0MDI4NjE2MjY0NDEyMDUwMzc2MzcyODIwMDc4MTA4MTE2MDIyODk1MDE0NzczNTAxNDQvMjc3MjIwNTk0NzI0MDA5NTY4NDc0MzM1ODI0NTk1MDQ5NDQwMDkzNDEzNjk3Mzg0NTU0MzA0OTkzODIxMjQwMzcwMzAwNTE1MDk1NDQyNTA4Nzg2Njc1ODg0MjYyNTA0MTQwOTA2MDIxNzU2Mjg3ODE1NzkwMDE5Nzk1MTM4MjczNzYxNTgyMjY1NTg2MzU0ODM1NjczNTU1MzY1MDc1NTM0MjEwODE4MzY0MTM1MzE0MjE1NzcyODM2NDQ2OTcwNjkxOTk5MzUxOTA3MTMyOTA2OTgwNTg3NTgzNDA1Nzc0Mzc5MzQzNDE2NDcyMDM3MDAyNjA3MzE0MzYyNjA1NTI5MzA1ODYwMTEyNDM2MjEzMDUzOTA0MDQwNDQ5MTc3MDM0NjA0Mzk3NzEwNjk4ODEwMDk2OTkwMTI5NzY2OTUyMzE3MDUwODMyMTcwMzQ5NjkwMzY3MjMzMzc4MTMwNjc0MzQ4ODU3MzA4NjkwMTU4MzAyMjU1MDM1NjM0NTE1NjQ1NzQ5NjM5Njc0OTc5Nzg3NVwiLCBcIjIzMjY0MzUwMDkzMzE1NjkwNTA3MTMxNTAwNzI2OTE0NDAxNzcxNjMzMjU5NjAyOTA0ODk0Mzg3MzEyNzQyMjc1NDYyNjAxNTc0Nzg4NDg1NTc0OTEzMTk1OTY3ODU0MDA5ODg2ODI0NDM2MjM3NzQwNzg5OTEwODUxODQzMDQ1MzA2NjczNTI0MzI0NjExMTMwNTM2NzE5ODAyNzE3OTEyNjE1NjA5MTA5Mjg1MjYxMTYzMjIwMDA3MjQxNDkyOTY0ODMzOTMzOTc1Nzg5MjU3NjgxNzU1MDAyMDU0ODkwNDUzNzQ3ODAzNDE4NDY1MTE5NTY3Mzg5MzE1NzU0ODAxNzkxOTUwNTUzMzA0MDM0NjY2Mzk5Njc3NjMwMDMwNjgzNzU5NDY2NjI3Nzk3MTIzOTcxNzQyMDYxODY2OTI4MjEzNzgwNDUyMzI1ODQ3ODQ4OTAxNjgyNzkyODg2ODQwOTgwLzQ3MzM0MzA1MDgzMTY4NTE0NDU1MjU3OTkzNTk5OTI2MjcxNDIwMDcwMjgzMjY4NjUxMTY1MjMwMzM5NTc4Njk2MDkxMjUyMTIyNTExMzY0NTIzOTY0MTAyMzY5MzAwMjU4NzY5ODIyNjU5MTU5NjMwODk1OTc4MjUzOTMzMTc5MDk2NDgwNTQ4MDgyNzQ0ODgzNTY4ODcxOTc5MzMzOTM3OTkyNDE5NDExMjA2OTE4MjY5MTY3NDE2NDcxNzM4NDM2MzQwNzYyOTk2MzA4ODQ2NTU5OTc0MDEzNzA0MDA3MzQ5NTQwOTgyNDk1MTkxMTExOTg1MDkwMTUzODc4Njk0NjIxOTg2NzQ2NTcxNzE4MDg4NDEwMDUyMTIwNTg4MjIyNTQ1MTM0Mjk4MzY0NTc1Mzk2MjkwMzU2NzU4MjI3MTk3MjAyOTUzNTI1MDg5MTY4OTg0NzYxMzcxMTE5ODEzOTdcIiwgXCI1Mzg5NjA5MzQ4MDc4MjYxNjE5Mjc1NjQyNTEwNjQ4OTY3MzA2NjM5MTg1Nzk4MTc3OTcxMzE4MDEzMjY4NDg4Mzk1MjQzNzM5MzY4ODg0MDI3NjIzMzEyNTQ4ODM1MDUxNTc4NDY2NTk4MzA1NTU3OTk5MDk4MjI4NjE4NTMxNDUzMDY1NDc2OTk4MTc5ODYwMTAzNTM3NzQ1MDA1NDUzMDU1OTY2MzA5MjQ4MTU2NTcwMTY1Njk0NDQ4MjQzODk4OTM5OTYzOTk1NTAzNDMwMjI0NDQ5Mzc2OTA3OTgxMjYxODkxNjI5NTQxODg2ODAyNTc3MzA4OTM0MjQ3NzUzMDM4MDE1NjIzMjc3NTc2NTUzNTAwMDIwMDEwODA4MTE4NjY0NTE0MjU2NjUzMDE2NzQ2ODg5Mjg1MTUwNDE0Mjk2NTQ2MjQ5NzA3MDc4MDMzMzY4MDAxMjU2NDg3NDIxNjgzODA2NzY4MTU3Njk0NTc0NjcwMzg4NDkyMTMyMjUyMDY4MjQ2NzEwMjU4MDMzOTIvMTA5NTE3NDQ4ODMzMjExMjA4OTA5MjEzNTIyNTc5NjY2Mzc2MDA3OTM3NjQ4ODc1MDQyNjA4MzU1ODEwNjg3MzI3NDI0NjIxNDY5MzIzNzg4Nzk5MTY5NzE4MjY3NzE1ODA4NTgwNzc1Mjk2NDYwOTQ0OTQzNjU4NDI4Mjk1NDgxMzQ3OTE1MTMxMDkxMjk3MzA1MjYwNjc0NzMxNjUxOTgwNTQ3NjY4NzYyMzE3MTM4NzUzMjUwNDU4NjM5MDQzNDc3NDUzOTUwNzc0NjI5ODYyNTQwMDE3MDM0NTY2NDA3Mjg2OTYzNTYyNTc0MTg4MTcyNzUzNzY0OTc4OTYzNjg1NTM1MjAxMDI4Mjg2MzU5ODE4NTI0NTE5OTgwODg1ODI3NDczOTA0NTc0ODQwMjg1NDExMjYwMDM3MjY0MDU3MTk3MTU1NTI3ODA5OTE2NjIzNDg3MTQ0NDkzMDE5OTgyNDE5NjA2MzA4MTQ0NTc2OTM5NTMyMDU1MDU3Njk3NTY3MjY5NTc2ODAwNTQyODc1XCIsIFwiMjQ0NTE0ODE1NTQzNTAyNTE2NTY1OTgzNTAxMjQxNjM5ODM0ODk1NDQ0NDU5OTE5OTI2NjEwNDk4MjkwMTQyNjgzNjYyNTA5NjgwNDY1ODkxMjc4MTA0NjY0ODMzNDkzNzg1NjA3MDE0OTE0NDU2NTg3MjUwODA0OTcwNzg1OTA5ODY3NDM1MTIzOTc5Mjc3NDc4ODUyODUwOTU4NDYzOTg4NTI1NzQyMTkzNjc1ODAwNjgwNDk3Mjk4OTQ2NjczNzQyMTQ4NjE5Mzk4OTc1NTc5MzA1Mjc2NDY5MzA3OTM0MzE1MTI2ODM3NTA3MzMwOTI0NDg4NjI1NTE1ODA0OTQyNDU0ODYzMDgxMTQxMjkyOTU0Njc5NzY4NzQ4NDM4NTIxMzgxNDQ1MzkyNTAyMzU2MzI5ODU2NzY5NTM2NjIyODg1MzY2NjkyODY5MTU5ODMyNjE4MjA5NDkzODY4NDU4MDY3ODEvNDk2MjI0MDY4Mzg1MTE4NjIyNTM0MDQ3OTMxNjk1OTYwNTIwNzI3ODk0ODM5NzgzMzg0OTg5OTIzNjM4MzI3MzE0NTg1MzA0NTQ4ODEzMTY3NDI5MDMzMjYwOTg3Njc1MTIyMjExMjkxNzA5NTA5NjE1MDUzMTgyNTI1NTYxMTkxMTM3NzA3MTg4NzE0NTAxOTcwMjQzMzg4MzM0Mzg0OTExOTAxNzY0MzExNzc0NjI3MzUyMzc3MDk2MTMwNDYwOTk4OTc3OTIzMTA0ODA5NTY2NTM4ODIwOTEyNTkzOTg3OTU5NTUwOTUxNjQ5MDIzMDk2MTU1ODM1MzA3NDc1MTMxMjg3NjI1MjA3MDg4OTk4Mzk0Njc2ODE3NTQ4ODM0MTM3MDQ1MzA1MzQ5NTMxOTgyMzM4MTk0Mzc5MzY3OTAwMzA5NjUwNDIwMDQ0MDk5NzkwODA3MTAyNzk2MjgwNjI3MjAwMFwiLCBcIjE2NjU5MTk2NDY4NTYwOTkyMDUyNTQyOTcxOTk2MTc1ODMzNTg4Nzk0MTQ2MTA1MjM1NzI5NzE1OTUyMzM1MDQ0ODI0MTQ4NDEwNjUxNTE1ODMxMDI5ODIxNjE1MDAzMDc2ODgxMjg3Mzc4MTM1NjMyNjkyMzIxNDYzNzg0NzQ0OTg5MzU3NTA3NDgxMzk5MTE0MTA5MjY4MTEwNzU4MzE4MzI3NTAwMzU3MDgwNDEzNDQ2MTE4NzIxMzE0MzgzMjEyMzYyODcwMTg3NjA0MTMxNTczNjA0ODQ1MTM3NDgyNDEwMTI1Njk4MDgzMjk5MTIxNDk0NTc2MjI2Njc0ODc1NTcyMzU1MTg5OTAwMTQ1ODI0NTE2NDMxNzU4MTYxNzczMTMzMjQ2NjAzOTc1Nzc4NjgzOTQ5Mjg2OTIxMTI0ODA2NDY2Mjg1Nzk4NzExMTI4NDUxODE1NTQ2MjE0ODA0NDgxMjYyNjA1NTg0MjA2MTI4MzkwNzA2Mzc4NDQ5MjMyNTY5Mzk5NDkxMTgxMTA3Mi8zMzc2NTk0MzQ2Njg1OTc1NjM0NzIzMTczNzI4NTc2ODUxNjI0MDc0OTcxNDI2NDU2NDQxMDgxNDgzOTk2NjAxMTQ5MDIzMzU5ODAwNjIyNzI0NjM5NjkyMzU5NDA2OTQ4ODQ5NjM2ODk5NDg1NzcxODczNDU0OTc4NzAwMDIxMzk0NDk5MDY5NTkyMDEzMDU5MTc1MDM3NzQ4MzkxMTExNjg0NTY5NzIzMTA3NDU0MzUyNjk4MjU4MDUyOTkzNzA4MTM3ODMwMzU1NTI2MjkzMzgwMDM3NTU3NjQ5NDA2Nzk1OTEyOTY4Mjc3MDA2NTQ0MzY2NzA5MTY2ODEwNDEzMjg4NDM3NTg0MDgxMjYzNTYyNDg2MjQ5NTU0ODg4ODQ2NzU3NTg0ODQyODQ2Mzg5NTc1NjM5NDA1MDI1MjQ1NzU5MjU0MDU3MDQ5MDA2MTU2MTYxNjkxNDQ0MzAwOTIyNDkxNzY1MjQ0MDIxMjExMjQ1MjQwMDEwNjEyMTc4NTkzODczOTc3NjYxMTMyODEyNVwiLCBcIjE0MjQ2NDcyOTUxOTIwNjY0Mjk0Mzk4NTcxNTQ2NTE5NjA2NTY4MDEwMTYzNDI2NDc4NzM3NTc0MDQ1OTc5MjYxOTc1NDg0MjM5NjQ1MzUzNTY0NjUwOTE3MDA2NjA5MTQ3ODA2OTc5OTA4MDE3MjI5OTM2OTk5NDQzODgzNjQ4NDkzODM3ODk5MTI4MzAyMDk3ODM0Mjg3OTA1NzI3MTA0NTAzMzkwMzUxODI1NTU0NjcwNTIxMTY0NzkwMDk0NTE0MzU0NjI5MzM2MDQ5NjY2MTQ2NjY1NzYwMDQ5NDc4NzIyODQ3NjAwOTIxNjUwODEyNDczNjI1NDk2Nzc2MTkwMTIyNDU0NzI2OTQ5NjY4MjA3ODQ3MDM3ODY3Njg2NTk4MTg1NTU2ODE5NzcwNTUwNzExMTk3MDkwMTM4OTEwNTcyMzU4OTY2NjcwOTU4MDg1MTYxMTY1NjgzODI4NTc3NzU2NjczNi8yODgzOTY0MzA3NTg4OTI5NDM0NjYzNTQzMDI3MjUyNTM0OTY1MTU1NTAzOTgwNzYxNTM1ODc5NTMzNDY2MzczNDk0MDEyNjA1Mzk2ODI0OTYwODYwMTcyNTk5MTk0NjM0MjQ0OTY2MDgyOTg0NzMyMjUxNzU2NDM3MDYwNjc0Njk2NDcxNDA5ODUwODI5ODcwNTc0MzY4OTcyOTMwNjUwNzU1NDM2Mzk1NDM0ODc4MDE0NDY3NTkzNzUxMDkwMDk4MzYyMjgzNjc3MDIyMzk0NTUzODg0NDMxNDQ2ODU1MDY0NDU0MzUwMjUwMTQ4NDUyMTU2MTU2Nzc4ODk5MjE1NjYzMjg5MjAyODU5MTY3ODc0MjAxNDEzNDEzMDg3ODEwMTU1MzYzMzE5NTU1MTYwNTc5NjE1ODEwMzAzMzc5NDY5NTk4NDk1ODk4NzM2Nzc5OTYwNzQwNzYyNjMxOTAyNDAzNDYyNVwiLCBcIjM4MDQ1NzE1NDg1NzQyMjA3Njc4NDQxNjYyNTQzNjE4MjczNDg0MDAxMjI3NzQ0MjQ5NjYwMDE3ODY2NDMyMzgyMTA2NDk3NzQ4NTI3MTI4ODUwMjgwNjEyNDc0MDIwNDI5NTgxMTc1OTkxNzQ2ODU5ODMxNTkzMjMzMTIxOTkwNjA0MDI1MzQ2Mzk2MDk2MTk5NTg0OTc2MTIzNTkxMTE0NTQzNjU1Mjk5MTY3NzA1MDU2NTAyMjE4MTUxNjU5NjQ2NDk2ODMxNjI5Mjc4OTA0ODgwOTU1OTEyOTUxNjkzMDU3NDM0MDcxMDk5ODYxMTA4ODk5NjUwODYxMzg1MDQwNzI5NDc0MzQ1NzE5NzUxOTA5MTE2MDE3MDYwNDQyNjAwMjkyNDAyMjkyMzM4ODMzODk5OTMyNDE4MjI2MTk1NDY4NTc5NDUyMjc3ODgzMzAyOTk1MDIxNDQ0MzI3MTUyNjQ2OTYwNzUzMjU4OTc3NTkxNjM4MTc4NjQ5MjA4OTQzMjQwNzU1MDIyNDEzNzM0NDY0MC83NjkyMjE0MjI5MTgzOTg1OTE5NjAzMzIxNTM5NTUyNjQ0ODQwODk4OTc5OTcyMjA5MDMzMDg2NjI1NjkzMDg5ODIyMzAxMjQyNzMzMjIwOTA1NDY5OTQ5NDAzMzUxMTQ3ODA1MDUzNjQ2MzA1MTQ1OTQ1MDg0NDUyMDAyMDQyNjk0MjU1MzEwNzk0NjI4MjgzMjA3MjgyNjA2OTM0MjEyMDgzNTM1MTQyMTYzNzk3MDQ2MjA1NDcwNzU2NjQ4MTA4NjIwMjI4NzY4NjQ1MzM3MTQ4MzEyNjg3MzE4ODAyMDUzODY2MTg3MTE0Nzc3ODMxMjk4NjEzMTkyMDAyMTkyOTQ1NTI3NjE4NzQyNTk0MDY2NjU4MDE1ODE3MzY3NjI4NDU0NTU4Njk0NDgzMzY3ODgxOTYyMjg5NTU1MDM0NTA4MzE3NTY4NTg0Njk0NDYzMzk4MjY4MDkwODUwNTkwMDA5OTM4ODAzNzA1MDEzNTIxMDkzNjg1MjIxMDI2MzcxNzE4NTYzNzE2NjcyNTYwNTU3N1wiLCBcIjc5OTk5ODAwNzA4MzY5NjY2NjcwNjkzMzQwODEzNjA5MjY1OTg4NjAwNDYxMjUxODQ0MjM5OTgyOTA0OTI4NjI5MDgzOTc1OTg2Mzg1MjM1ODE2NTg3NDk3NjU3Njc4Mjk3NjYzMTUxMjk4NzA5MDc2ODg0NTE2MTY4Nzk4Njk0MjkyODYyNTU5MDgzNzMwMjU5ODM5NTI0OTY4ODEzOTMyMTUxODEzMjMzMzY2MTc1MDkxMzE3MDQ2NzU4MjYwOTM0MzU3MDk2NzU3MzIyMzY5MTM4NzQ3NzMxMjI0NDE0MTc2NjA4MjQ3NjA1MzE0NjY4MDQ1ODM4NzY5NDMzODExNzgxNDkwMDMwNjM1Mzc0ODU2MDQyNzg2OTQ3MTA5MTAxNTg1MDk3MDM1Nzk0OTY5NTAyMTExMzU0MTI2NzczMTY1MzkxNTc3MjE3MDcxOTU2OTI4MTcxMzM2MDYwMjQ3NjMzNjA3LzE2MTU0ODUwMjY1NDEzNjEwMTE5MzEyNTk2Mjk5NjM1MzkxNDMzMzgwMzE5MzExNjgyMjA4NzU1MzkwMzQxNjU5MTUyMTYwNTc4MzY2MjQ0Nzc0MDI5MzAyMjgxMDY4ODMzOTYzODQ4ODExNTk2NTQ1NzkxMTA0OTE5NTU2MzQ2ODEwMTkzMzg1MDAxMTk2Mzk1NDg5NzQwNTcxMTg4ODg0ODczMjQ2MTMxODEzODY0NzgyNTgxMzU2ODg3MTEwNDk5NjM5NTQ0NjYyMzIyMDA4ODI0NzA0ODMwODE4MTM2NjYwNTQ0NjczMjkzODY1OTIxNzU0NTY5MzU2NTgzNjk4OTUxNjEyNzk3MjE5Nzc2MjkwODM1MTYxNzgwMzI2OTQ1NjI1NjIxNzU4MjA0OTMxMjk4OTQ4NjI1ODg1MDgxMzI1MjY4MTIzMzQ0NDA2MjYxNzQwODQzMTk3MjMyMzE2NDE2MDAwXCIsIFwiMjY1MTcwMTQwMDQyNDE0OTg3OTg4NDgwMDMyMDgxMzMxMTEzMDczMDA1OTI2MjA5NDc5MDg5MzMwNzI2NjE4MTI4MTY2ODMwODUyNjEzNTk2OTY4ODcwNjQ0MzY2MTE3NDcyOTI0Njg3MTc3Mzk2MDk3NzY4MjU2NjQzNDQwNjQwMjQ1MzUwMjgyNDI3Mzc2MTY3ODYyMzgyMDAyMDA0OTgyOTEyMjY5ODQ1NDE5NDI4MzY0NTkxODgzMjgzNDY2MDk1NDkyMzk3MjQ2NTM5NTAzMDIxNDUzODg4Nzc0NzIyNzQwNzQ2NjUxNjY2MzE1MDk0OTAyOTc2MzAzNDQzNTE1NzMyNDUyNjU0NDAxNjQwODIzMzQwOTI5OTczMDc3MjkwMDc0MjkyMTgzODU5MzM2MjI2MjM5MzU3MDQ0ODIzNzEzNjA5ODU4MzY2NTk4MjMyNjk1MTExMTU5Mzc0NDMxNjE1MzI5ODc2NjA4NTU0OTA5MDY1NDYxMzAxMzE3MTY4Mjk5MDkzODg2MjA1MzkxNTMxNTIvNTM0ODI1NzUyOTUzMDA3MzUyNDI4MDk4OTI1NzU3NzA1MDg3ODAzMzIzOTQ4Njg4NTY2NDc3NzM0MDk0NzEwMjQxNzA3Nzg3NTYyODIzODUwMTc5MTcxMTMzNjgwMzQxODUwMzYxNjA0MjkyMjg4MDIxODg2MDI2NjYxMTU5NTU5NDQwMDAyMDIwNjE5MjU5OTU1OTkyNTE2OTU4OTAyMzMzOTI5NTI1NjA4NDU3OTk2NjUzMzI2MDg2MTI0OTUyOTY3MDE0MTg1NDYzMjk2NTIzMTQ2ODUzMzQ0ODcwOTM2MzQ3NzEyMDQzNzI3NzQ3NzY2ODE3MzE0OTk1ODI2Nzk1NjY1NDQxMTgyMjM2MDA1MzMzNTY5NTk1NjI3MDcxOTY4MDA4NjUyNDMyMjUzMDUxNDI0OTg5MTE1NzQzOTg3ODQwNzQxNzk3MTgzOTc0NDM5MjA0NDA2NDcyMDQ3NjQxNzg0NDA1NjM0NjE3NDc5NTYwMTcxMDQ0NzU4Mzg2MTEyNzk1NjQ1NTQwNjkwMjEzOTYyNVwiLCBcIjcxMTk3MzQ4MjkwNzcxOTc4NDA1NjAyNzMyODM5NTM3MDEyMzEwNjI2MDA5MzE4MTMzNTcwODkwNDgyMzY0MzcxMDU2MTg2NTIzOTg5MzMwMTU3OTY2MDQ1Mjg5MTI3OTgwNjg3NzY0MjE4MzYzMDY0OTQxMzkxNDgzNzgxMDA4MjY1MjY2OTYzNTM3NjIzNzcwNjg1MzkwMTQ4ODEwNDU1MjQ0MzQ5ODU5MzU0ODU3NDIxNDc0Mjc3OTYzMDA5ODU3MDExNjUzODY1NDc2MDgxMzg5OTY4MTIyNDE4NjkxOTM0MzU0MTIyMjMwNzgwMzAwODMzMDA4NzUzNjg2MjM0NDMzNjQyMDcyOTE5OTIzNTgzMTc2MzMzNjY4Mjg5OTk4NjYxNDk5MTQ2NjE3Mjc3OTgxNjkxMzcyMDU3MDQyOTMwMTMxNzE3MzM2MjUwMzA5NjgwNzY0Mjg5MjU2MDgwODk1MDkyLzE0MzQyNjgwOTkzODkyODg2MzAzOTU0ODUzNTc5ODgzMzYzMjI1OTIxMTA5NjM1MDc5NjA1MzkyMzIwOTQ0NTIzMTA5MTg3NjQxMjgzMTE3MTgxNDYxNjYyODQ2NDExOTEyMzA2NDgwNjkxOTAxNTE1NjU1MjIwNDkwODUwNTg2NDM0OTQ3NTA0NTA0MzE3MDgwMTQ0Mzc4MTg1OTg5NTk2NTc4ODkwODc1NTYxMzM2NDk2NDc5NTc2NjUxNTE2OTAyMDQ4NjA2MzI4NjA0Njk2NjEwMzE0NDQxMjI5MzIxMjE5NjI3MDIxNjEwNzg4Mzk4NzMwMTczMTYxNDczNDU2OTU0ODYxOTE2MTE2MzkxNjg3NzQ4MTUxNDQzMzM1NTEzMjQ5ODEwODA4MzA5MjAxODMwMjE0MTUzNTY1OTY2MzM5NjA5NjE2Mzk3ODY1NDY1ODQyMTg3NDA0NjMyNTY4MzU5Mzc1XCIsIFwiMzQyNDAxMDE4NzU0MDIzODkxMDU5MzUyNjI5NTA5NzE1MzU3MDUzNDU0NTA2MDM3Mjg0Nzg4NzI1MTI3MDczMTY4NDQ1MTg5NDIyMTgxNTQwNDA4ODk2NDUyNjUxMjMyNzU5ODIxNzY2NjE2ODUwMjY0MTIyNTkxMjI1MzMxMTIwNTg4OTE4ODY1ODgyMDYxMzQ0MzIyOTk2Njg4ODgwNjY5NjY1NDUwMjMxOTgyMDAyNTk3Mzk4NzMyMjAxNzg5MDE3NDk1NDI3NTY2MjYwNjUxMTgwNDcwNjM1NDY3MDAyNDUzMjQ5NDc5NDgzOTAwMjY4MzIwNTcwMDA0MjkzNjc5MzYxNjk2MTk3OTA1ODIzNjkwMTQ1MzI2NTMxMTgwMzI0NDI5MzE4OTE2MDkyNDcxODYzMzQ3NTc1NTMzNzE0ODcxMzU1NjUxNTU4NjEwNTE1OTMxMzczMDgwOTk3NTM2NzkyMjQyMjc4NTI5NTc1NzAwODA4ODc4Nzg2NzMyMTI3NjMwMDI0MDY0NDE4NDY4OTE2NjA4LzY4ODk0NjQ3NjgyNDYxOTU2MDg5MzgyNDYxNDA2NDk5NzU5NjEzNjkxMTQ4NjUwNzM4OTU3MDE2MDE1ODQ0ODMwMzMzMTY4MzA3MDIwMjg0MjgxNTMyMDI2NDQyMjcyNjE4MzcyMjkwNjQ2MjgzNzk0MTIyNzcyMTIyNjY1NTMxMTA4NDg0NzA0MjIzMzExNjYzMjcwODM2NjQ1Mzk5NTU0OTQwNzQxOTI4MzU4MzE3ODg0NjIwNDIwODg2NjA5NzA1MjY3MjQ4NjU2NzY1MzU3MzQ4NDc3ODU3ODUyNjg0MTQwNTYxNzE0OTAwNjE0MzAzNzMxNzg2NjIxNjU2MDQxODgxOTc1MzI4MTY5NTQzODg0NjYxNzgwNTMxMDU3Mjc5NTgyNzg0MDM2Njg5NDAxMjA2NzA2MDY5MDI4MjI5Nzk4OTEzMDgyMzYyMzMxMzM0ODM5OTk3MTMzNzcxODgwNTE0NTE1OTcyMDI0ODk5NDA4NTU2NTE3MTU5NzU5OTA3ODgzNzkzNjc1NjcyMDY1MzYwMTI1XCIsIFwiMTkwMjg2NTcxODM4ODA1NDk1Njg2ODk1NDYzNzUyNDkyMTc0Nzk4MTYyODI3OTY3NDkwMzQzNjI1NTQwMzIwNjc5NzYwNzAwNTUxMjg2Mzk1OTU2MjQxMDU5OTY5Njg5MDIwODg1NzE0MTkwODgzMzIzMjY2Mzc1MDY3NjA3MjgyODkwMDYzNDQ0NjUyOTI2MTUxODYyNjUwNDI2MzIzMzM5MTg3NTk2Mjc4NzYwOTYyMzkwNDA0NjU2MzQyMzA5NzM3NDI4MjE0NDkzNDIyMDI4NTQ1OTEyNTA0NTAzOTc0NzYzMjE2MjMwOTI3MTk2MTg3NzQzNDM5MjI2MjQzODgwOTMzOTQ3NDE3NzYwMTQ3Nzg1NDA1NDQ0OTc2MTc3ODIyMTQzNzIyNTY5Njk2MTgyNTIwODI2MjE4MTIwNTk1Mjk4MDU5MDIwMzA1NTQ4NjgxODIzNDA4MjY4NTU2NDgyOTgxMzI1LzM4MjQyNjA4MjkxOTEyNDA4ODE1ODM4MDgxOTkzMDQ1MTIzODY0NjE3MDU4MzkwNTgzMzk0ODI4NzM3NjQwMDM2MTY3ODkzODU5NTA3NDk0MDkxODY0OTYzMzgzNTk2ODY3NzAxNDM2MjQ0MDA3OTA1NzcwMjg0OTM5OTkxOTEyODg0NDY1MTAxNTc1NDkwNTQ4ODEzODk0MTQ4ODMxOTY2MTMyOTcwNzMwMjYzNTYyMTEzOTYxNjg1MzY0MjE2OTg5OTk5ODQ0OTYxNjg4NDQxOTE0NDU1NDM1OTM0NzAzNzk3MzU5MzYwNzgwMzU2NDgyNjI5NDk1MjE0ODU5OTE3MjQ5NDY1NTY3ODQ2OTM0Mjg0MTIxMDMyMjQ3MjUwMzMyNjM0MjgzNjg5NDA5ODgzNDk5Mjk1NDY5MTE4NDg1OTEyNDg5MDU4OTgyNTk2NzI1MjEyOTc1MzExMTQwNjE4NzY0Mjg4XCIsIFwiMTUzNDUzNzk3MDExNTM3MTQ0MzY5MzgyODk1Njc2MzkxMDIzMDc4ODcyNzM4OTg4MzQwNTE0NTY2OTM5ODE1MTQ5NTYzMjk3MzE1NzI2MDAwMjY4NjYxNjIyODYwOTc2NjI5NTg3MTI5MjI4MzYzODM4ODE4NDAyMTEwNzIzODk4Njc0NjM5ODc4OTU4OTQwNjcyODg2OTk5NTU4NTgzMzc0ODg4MTIzNDM2NzQ4MTg1NjU0MzI3ODAyMjQ2NTQ0MjM4NzI2MTgzODA5Mjg0NjI5Mzk0ODIyNDc5MDAwNTU1NzIwNzk5MTQ3NTM2NTI5MTUxODQzMTM2ODUyNzA3MjI1ODM5MjYyNjE0OTk2ODc3Mjg4MTQ1NjA2ODAwOTIyMzE1MjY1MDE5NzA0MzEyODA3ODMxNzczNTc3MzUzOTg1ODA3MDAzMDA0MDIwMzY4NzM3ODAzODU5MjYyMjUwMDU1NjE3NjY4MjI0Nzk4NzgyODA4OTExMzAyMzIwMzYzODk3MDc0NTIwMDUxODMzNzAxNTI3NDkwNTYvMzA4MDQyNjYyMzA4NzgxOTY3ODYwMjA0OTE3MTc1Njk2MTgyNDE5NjQyNTU0ODUyOTYxOTU3Njk3Mjc5MzY1MzU4NTA4OTM4MDE2NTg2Mjg4OTA5MjgzMjM3NTkzNDUzNTQ2NDE2MDQyNTU4MDQ0OTE5MzA3MjEyNTk1NTY4NTA5OTE1MTUwMDc1NTI3ODc2MzMwNjU5OTMwNzIxODMwMjYzNTIzMzU5NTMyOTA4MjcwMjE0ODY3NzMwMDk0NTU1NjEzMDEwNjE5NzQ4MTIzNjEyMjQzNzk3ODM3NTk2MzI2MTE3MjUyNDUwMzYyNTU5MzA2NjEwMjYwMTA0MjA2MDU0MTYxNzc5MTAwODcyMjU2OTc5OTczNTIwMjc3OTAwNTQwNzM4MTI2NzAyMTY0MTU0NTY0NDI2NDMzNDEwOTA1MjI1ODA4MTIyNTE1OTc0ODA0Mzc5MjI4ODY5OTY3NDE1MzcyMjA0NjY1OTg4MDA4NTg1MDk4MDg0MzQ2MDcxNTA4MDk2NTYwNzQzNDExNDI3NTI1NjEyNVwiLCBcIjM2NDQzNjAxNjYyMTQ0Mjc5MzM3MDMzNDg0NDUyMjcyMTA1NTQ3MjU3MDY1NDYzMTY3NDI3NDE4NTI1ODgyODUxNTA3OTg5NDQ5Mzc1NDUyMDc2MjI3NjUyNjM0NDQwNDc2NTAyNzAyNTg0ODg5MDU3Mzc2ODI5MzIwNTQ4NDY0Njc3NjIzMDM4NjQ4ODQzMjUxNzE5MTY4ODEwNzAxNzQ0MzM4NzM1MjAyODUzNDEyNjUxMTYwNjgxMjU5NTMzMDE1MjkzOTk3NTAxNTI1NDMwMjIyODcwNjk2MjM1MTQxNDY4Mjc0Mjc0MDY0MzkwMjczMjE0NDg0OTIyMDgwMjE5NjQzMDk1OTc4NjQwMzAwODc0MDg2NTg1Mzg2OTkxMzM4NDQwNDE1MjAzODYzOTAxNzE0MjE3ODE4MjIyNjY2NzE1NjQyNDY3MjM3MTgzMjY3MzAzMjE0NDcxODU0NDcyMjg2NDc4MzQ0LzczMDcyMzc5OTAxNDgzMTI0NTExNTUwOTA1MDYyNjQ2NDI2NTc4NzIyMjQ2ODQ4Nzk4NjAwMDg0MzY3MzU0MzA4NzkzMTQzNDk1NTQwMjMwOTYzNjY4NDY4NTY0NzAzNzUwMjU1NTUxMzkyMTk5NjE2NjY3NTQ3ODA4NjQ4MzUwMzU5MDI4NTYzMTQ5ODE0ODIyNjgzMTk4ODYzOTU4ODE4MDk2NTkzNjgyNzU3MjAzNzU1NzYxNTIwMDgyODk5NDkwODU0NTMzMjY3MjIxNTY1NTM2MDMzNTg4Nzk0MjA4MjAwMTI5NjQwMDY5Nzg4MDgxMTMzMDczNDAzMjE4MjQ2NjA0ODQ0NDE2MTg0ODcyOTIxMzg2MzE1Nzk2MTYzNTE3NzcxOTExNDQwNzM4MjA2ODY1OTU1OTc5ODY1NDgzNzQ1ODg4Mzk3NjM3MTkwODIzMjMxMTQ2NjM4NDQwNDMwNDYwODczNzVcIiwgXCIxNTc1Mjk0OTMwODYwNjYzOTIyODQzMTQ5MTEzMDk3OTI3MTY4MDI0ODkzNzM5OTYyNDY0MzI3MDE2NzYzNzQxMzE0MDY4NDM4NDQ3MjcxMzI2MzAyMTI5NjgxOTMxNTY0MDY4Nzk2NjMxMzM3NTcxMTMzNDQ0MTYzMDI0MjI0MDcxMjcwMDYzMTc0ODI5NjY0ODQ4MjU5NDgyMDY2NzIzMTA0MjUxNzE4ODA4OTM2NzYyOTM4MjQ5MDI4NTgyOTkyNTU3ODIyNTUxOTUwMjEyMDk4Nzk3NzE4NjI3NDE4NzgyMzc2MDI3MTMzNTc2MjA5NzE4Mzc2Nzg0ODM0NDU2NTY4Njk0ODEzNTc3NzY0MzAwNzE2MTM5ODE3MDMxNTQ1NDA4NjA4MTEwODgwOTczMzgwMTYyNzM2NTM2MzEzMTczMzI5OTczMTcxODQ0NTI4MDgzNzU2NTI0ODA0NTc0MjY3ODI2NjkxMTU2MzY4Njk2NDM2MjczMDg3MTcxNDY3MjU0MTYxOTMwMjY1OTEwOTcyNTE3NTA0LzMxNTQ5ODU0NjY1NDUxMjA0NzYzNzQ2MTYwODc1MDAxODM0OTQyMTQ5Mjk4NjQ2NTM3Mzg0MDM0NzUxOTk0MjQ5NDkwNDIwMDczMzg0MDE4OTQ4MzkzNDI0NTUyOTU2MTIzMTYwNDA1MDYyOTY1Mzk5Mjk0NDE0MDM1MTEwNjg4Nzc0NzEwNTk0NTk4NDMyNTQ2NjQ1MjEzNjQxNTA2NzgwNzY2NjMxNjIwMjM0Njg5NTY1NzkxNDM5MzUxMjAwMTIxMjY1NjkzNjQ1MDQyNTI2ODUwNzIzNTg2MzE1MzI1ODc2OTM2MDI5NjUzNjA1MDAyODY5NTI2NjM2MzU1MzE0MTMyNzg5NjA2NDk0NDUwNjIxNjAxNzkzMzEzNTI1MTg3NTA4NzA2OTAzMTA5ODA5OTE5MjMyNTgxNzM5NTk1ODAxOTUyNDk1NjMyMDg0MDkyNTE3NjU4OTYxNjQzOTQ3NzEzNDQ4MDI2MjEwMDIzNzA1Nzk1MzkzMzExNzQ2MDExMDIyNDc4MzQyMDU2Mjc0NDE0MDYyNVwiLCBcIjc2OTIwNTc1OTk1NTMxMzM0MTcyMjU5OTc3ODY5ODAxMjgyOTkzNzI0Mzk1NDIzMTUxMjUwMzAwNzc0MDQ1MTk2Nzk0NTAzNzI4MDU5ODk3NTUxNTgwMDA4NjQzNzg5MjQ4NzcwMzYyMjUxODk3ODQwNDUxNzEwNDUxMzk2Njc2OTE1MjQ3NjM2MDk4NDA4MjI2Mjg3MDY0MjI5MTg5MjY0MTAzNzcxODU0OTQwNDgzNTUxMjgwNDY3ODMyOTQ5NTQzNzMxOTcwODI4NTE1MDE5Mjc0MTAzNTAzMTM1ODU2NDAyMzc1NTAxMDcwNzA5MzY0OTgxNjQ1OTcyMzE0MzEyNDI4NTg3NzE0NTc4OTgxNTI2ODQyOTgwNDc0NDY1MzAyMjA4NzM4ODQwMjIyMTMxMTQ4MTk1NTY4MjIwNTAxNzg1Nzk3MDcyMTAyNjQyNDMwODcyNTcwNTA0NjgwMDAwOTI4NDI3NjEvMTUzODgxNDQ4NzI0MTExMjc2MDczOTU2MTcwNDg0NjM4MTU4NTA2MzAwMjc4NDc5NTA1NzA2NjQzODMzMDMyNTU2Njg0MzEwODExNDc4NzA4Mzc0MTc4ODA3ODY4MDg2MTQ5NTM0MDAyNjExNzY4MjYwNjY4OTE1NjA2NTAwODY3MjM0NDcwNzYxNTQyMDUwMTk2NDEyMzEyMTYyMDQwMTA3MzY3NTQzMDY5MDU0MTYxNzkzMDUyMDk0NzE3MDMwNjc2MzU0MTI1MTE1Mjg1NDMwNDk3NTEzMTg3MTUzNzkzOTYxODY4NDE4Njc2NjE2ODM3NjUxNDY2NDQ5NDQ4ODY5MTMxMTM5NzMwNzQxODI5ODU1NjE4NTcyNDk5MzEwNDc2MDY5MjIxNjYxOTE3ODM1ODI2ODkzNDc0MDc0NjkzMjQyMDU2MjY2NDIzNDczODU3NjM5NDc0MjU1OTM0OTQwNzc0NDAwMFwiLCBcIjE1MTkwODM2NDcwNTUwNTU3OTI2MTQwMDEyMjYzMzEwMjMwMzc4NDU1MzQwNzk3MDk1MTAwNDc0NzIwNzc2MTEzNzY1MzAwMDgxNDYzOTYwMjM1NTA2OTUwNzk5ODY5MDczODk0MTI3ODg0MTg5ODU3NTA1OTUxMzE0NDI4ODEwNDIzNzM0OTc4MDI1NDA5MjA1NDEzNzg5MDI1NzIwNjQyNjA5MDM1MTE3MTIxMzg1NDUzODU2ODc3NzA2MjI5Nzc4MTY1NTMzMDM0NjgzMTMwMDY0ODY1MjU2NDQ4NDQ0NzY1OTAyNDgyMTQ2Njc2NjY4MTk3NTQ2MDk4ODA5MDU1MzQxMDUwODczNDk0NDQ2MjMxNzkzMzEyNDA3NTE2NDYzNTc2MzgwMTAyMDczMTcxMDkwODk4OTczMDQ2NjExNTcyMDIwNTY0NjU5MDQyMTQ2NDY1MzQ1MzM0MjczNTk1MDg2OTQxNTYyNDI1MDA2NzYzOTYwMTk3ODAxMDE4Nzk2OTA2MTE0OTI1MDA1ODEwMDY5Njg0NDgwLzMwMzU1NTY1OTg4Mjk1MjY5NjgxMjQ5NDI5MTYyOTcwMjU0MTY1MjI2MDYzNTcwMTA2Mzc2NTI2MzU3OTkwOTY0OTgyMDg2NDM5NzAyNzM4Mjg0OTY2NTUyMjc1NzIxMDAxNTk0MTQzNTIwMjA5MDk4NDYyOTg4MTc1MjEwODI1Mzg4OTg3MDIzOTM5MTY3MDg4MDQ3NzU3OTg1NTIyMDY0MDE3MTgzMjM5MjkxNTc4NjMxNzM1MDQ3OTUxMjcxODAxNzc2MjI2NjczNzY4NjcyMzU4MDYyMDgwMjEzMjk5ODExMzY2MzcxNzU1NzA0MDk3OTE0NDIzMjg0Njg0NzMxMTE3NjgxNDA3NDY4OTUwMDU1NjE0NzE1NzQzNTY4ODkwNDc5ODE0NTgwMDIyNTc4NzIwOTI0MDg3NzE5NTk0NzgyNzU1MzQwOTg3ODk5ODI4OTkwNTYxMTg0OTg0MTc2NDkxNjc0NDQ0ODA5MTM1NTI1NDgyNDkwMDUyNjgzODA4Mzg0NTc1MDU5NDQ0NjI0OTQ4NzQ1ODFcIiwgXCIyOTIzNzU0NTQ5MDkwOTQxNDI0NTQ2OTc0MjgxMDExNzcwNjg5NTM0OTYxNDQyMjY0MzUwOTg0MzkzMjM1OTgzMTg5MTY4MDI0MDc5NjE3ODQ4MTkwMjM2NjM5MzI4Njc2NDM2NDg1NDYwMzExMDkzMzkxOTgyODI1MDI3NTEyMjM0NDY3ODUzMDk4NzU3NDg2MDg2NDkyMzMzNDEwNzUzOTE5OTI3NTI4ODY3ODE3NDA2Mzg5Njc4NDYxMzU0MjU3ODQxMDA3NzIyNDcyMTA2NDY0Nzg1NTU3MTc5ODQ0NjAyMjc3MzUwNDExNTkzOTU5MTM2NTIwNzMyODYyOTM1NzQwNDMzMTYzMzgzODg1NTI2MjQ5ODk3MTgzODA1OTgxMjE5NDE2NDIwMzkwMTM3NTE2ODEyNzE1MjQ1NTY5MDM3NTYxOTY2OTI5NTcyNDQ4MjQ3MDc3NTc4NDE5NTM0NjUxOTkwODI3MDQ0LzU4MzU5OTY5MTYxNTM3ODU0NTEwMDk1MDc3NzYwMTEwNDAwNzgxMjc5MjQzNTEwMjk0NTI0ODQxMTQzOTEwMjExMjQyNDI1MTQ3ODUxMjk1MjA4NzUxNzQ2MzQwMDA1NDU2NzgzMjM1Mzk2NzczMTg4NzA2MjM0OTQ5NjYxNjQ0NTQxOTc4MjQ5OTgxNzU0ODkyODA3ODY2NTIxMjA3NzQ0OTQyMDIxNjg5MjU4Mzk5NzUwNTkwODg1ODM2MDAxMTQxMzI5MDAzODY0NTU3MzUwNDQ3MjQyMjYxMDc4MDA3Mzk3NTQ1MDM5MTcwNzA4NDAxNjkzMTY2MTA2ODY5NDAyNDAyMzA4MzQxNzEyNjI4NjQ2ODkwOTExNzI1NDUzMTMwNzA4NTU0NTc2ODQxMjUxMzQ0NzE5NzIwNTQ4MjI4NTAyMjQxNzYxMTAxODEyNjg4NjQ5MTQxNjEzMzY2NTYyNTg5MTA3NTEyNVwiLCBcIjQ0MTkyMjgxNTIxMzU2ODkwODQ4OTU4OTE5MzU1NjU2MDU4NjMxODg2NDMyNjQyNTM5NzcwMjA0Nzk2NTM3MjI4OTI5NTk2MjIyODI1NDY1ODMzMTIwMTI3NDI5MTY5NzYyNjY5NDg1OTQxNDc4NjI5MjI2NjAwODQ3NjEzNzY2Nzg0Mzg3NDc4MDUwNjg4NjkyOTE4MTgzNTQ2OTMwMjE0MjM2NTc3Mjc2MzEyOTgzODIxNzMxNjk1MzgzNTgzMTA1OTYxNjI2ODI4ODM5OTExOTY0MjMxNDc1ODI2MTY3NzYzOTk0NTAwNDU0NzgzMzgxMDA4MDcwMDEyNzg0NzIxNDY2Njc2Mzg2MzMzODA5MTUyMzc1Mzg5ODM2MjY5OTIyMjg4MDc3MjI5ODE4Mzc2MDIxNzczMTIyODYyODQ0Mjc4MjQzMTU3Mzk3NzQ5MDc2MTY2NTA5MTAwNTc1NjUzNDQyMDc4OTI1ODI3NjA3NTE3NDQzNjA5MTc5ODQ3NTgzODM3MDE1MjE5MjA3NzQ5NDU1MzI2MzIzMi84ODExMzUyNzM3MzU3MzA0OTMzMjc0OTI5NDY2MzQwMjQwNjQ1NDUyNDY0MDIyMTg2NjQwNzE2NTgzOTE2MjU3Njk3OTQ3NzEzODY5NDY1MzQwNDI4MTg4OTIyNzQxNjk3NzYxODkxMzI0OTI3NTcxMjkxNzU4Mjc0MzQyNjIzMTc0NDk4MDQ2MTkxODc3Mjc5MzY3MzIwMjA3NzcxNjIzNDAyNjA5MDMwODc5MTg5MzQwOTIwMDE1ODk2OTEwODkxMDU2NTQ2NzI3MzcyNTA2NDc2OTg5MDQ0MzQwODMyNDM4Njg5NzAxNzgyNTQ4OTYxNTYwMDc4NzYzNDk4NTM5Nzg4NTIzMDQ1NTE2ODU5MTI0MDMyODU4NTA0MTgzNjc3MTkyMTkyOTU2NzkxNDg5MTM3OTIzNTU3Mzk4MjQ0MjMxMTI2OTM5MjU0MTY5NDU2NDY3NTA1MzYzNjA3ODk5MDgzNjQ5MTEwNDExNjI4MDQ5MjI1NDc5NTYxNjA1NTgxODM3NTc3NDE0MTY2NzMxOTc3NDYzMDg3NVwiLCBcIjkxMTk3MTMzNzY3OTYyNDgzODUyMjc4NDU2Mjg1NTkxODEwNTc5OTc0NzgzMDc3ODc0MzA3NTg5NTU1NTU5NzE1NTc3NTk5NjA0NjI2ODE5MjQ1MDAwNjcyOTI5NTE4NjQ1MDA0NzcxMDg1MTA2NzcwNzg0NzYyOTk0NDc2OTczODQyNzEzMDM1NzkxNDg3MjA0MTIyNjUzMjQ1Nzk3MTI2OTA2MTg5MjcwMjA0MDI5NzM1ODcyNTA4NDYyMTA2NTI3MjQwMzIwOTMyNDU4MDM2MjMxNzA3MzExOTkyODY4MzQ3MjIxMTc2NDYwNDA3MDAzNDg3MzczNzU0MDE0MzY1ODgxMjA5NjQ5NjMyNTQ3Njg1NjU3NjY2NjkxNTg5NjA2NTcxODY1NzQwNTk1ODI5OTgzODQ5OTQxMDQ5NDUwNDcxMjEyMzg3ODA4NjE3MjQ3OTM4OTQxNDE3MDAwOTY1MTk4MTIzMDU5NDY3LzE4MTYzNjc5NjExMjE0Njc3ODEzNjQzNDU1MTk5OTc5MDk4MjYxODQ5NDA1MTg5ODA1MzY0OTg2MDM2OTExOTQ1MDEyMDE2MjQ4Mjk3NjQ1NTk2MjcwNjAyNTA4MDE1ODY0MzcxNzg4OTc0Njg0MzE3MjM5NzI4MjM5ODQ3ODg4OTYwMTU1MzY1MzQyNDYwODQzNTU5NjU4MjMzMDY5NjEzMjE4NDQyOTEwMjI2MTI4MTEzMTk2OTg0ODAxMTI2MjQ4ODYyMjczNTAzMjMyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsIFwiNzMzMzk2NzI0NDM0NTU0NDgxNDcwNjU2OTY0MTY3MjMzNjkwODUxMjc5OTIzMDg1MTk3MTQ0ODc5NjQ0NzUwNDM3NDAyNjI3OTM2NzIzNTMxNjM1ODk4NTQyNDE0MTM2OTQzMDAzMjM2NDc4NDMyODQ4OTY1NTE2OTI1ODkxOTU2NjE1MTExNjc4NDQ0NTg2Mzg0NDkzODgzMTEzMzg1MzM1NDYzNjM5Njc0Njk5NDQzODA4MDg0ODI3NzE1OTk0MTM3NDEwNzQzOTkyMTMwNzEyOTAzOTk3ODE1NDcxMzY5MjAxNDA2NjgzODYyOTg1Njc3Nzc0MTU1NzA0MjY3MDM5MjI0NTQ2MzUyNDE0NDE3NjMyNDc1NjI4MTM2NDYwOTE5OTAwMzQ3OTc3NzU0NjQ0MjE0NzI1OTMyNDc2ODU2MDE4MzM1MTk1OTI3NjA0NzcxNDA4OTQ5OTgwNjM0MTQyMjU1NDk3ODEyNTY2ODY2Nzk1Nzk5MjMwNTAxMDI2MDY2MTQ1NDM0NzU1ODM4MzM2OTkwMzY1MTg0LzE0NTkxMjQ5NTY0NDE1OTgxMDMxMzAyNjQyMDAyNTA1Mzk4OTYwOTk0MjI2NTY4NjM4ODYzMDI2NjIyNjg1NjY1MDc5NjA4ODc2ODE2NDM1ODk2MTY0NDExMzA3NjgwOTUxMTU2NjEyNTE0NTM5NTY5OTI3MTUzMDgwMjg5MTUyMzc0MTYzNjcwNzUzMjY3NjA2NTgzMzMyNzA4MjA5MjUyMTk4OTk1ODk3MTE1NDc5ODQ2NTc4NDg0NzA5Mjg3MDQ1Nzk0NDg1NzU5MDYyMzA5Nzc4MTk1Njg4NDI5NzEwMzk2MTcxMzM2MjI2ODI2NDE1OTAxNTkyODU1NDcwNzE1ODIzOTM5ODcyMTQxNjIxODk1MzAwMzIxNTEwOTIwMjc3MTY1MTk5MzYyMjI0NDc4ODUwNTY0OTA5ODQ0NTEwOTQzODEwNDQ2NjI1NjQwODA2MDk0NDI5ODQzNzAzMzA1ODM4MDgwNDEyNjU3NDg3ODM3Nzg3NDQ1OTM3MTI1MTA1NjgwMDg5NTM5NDkwNDQ1OTQ2OTgzMjg3NVwiLCBcIjE2NzYwNjQyMzg1MzY1ODcxMzYxNTc0OTEwMTEyMzMzNjMyNjkwODM4MTYxOTU4NjgzODYwNjkyMjU2NTM3ODUwNTIxMTM4NjE4NTEzMDQwNzQyMzU4NzI2NDc3NjUxOTU4OTI5NTQyMDc1ODAwOTc2NDY3ODc1OTIxMzU4NzkwNjIxNjU0MzE2MDgwMTA1OTAyOTEzMzQ1NzA2MjA2NzUyOTQ2ODQ2NDYzNjM3NjYzOTMwNzY5MDY1Nzk0NTU5Nzg0NzA4MDcwNjE0NDg5ODkyMDMwNTM3OTY1Mzc1NDkyMDU3MTc5Nzc3MTE3ODM0MTU1MDgwODA0MTY1MjM2MDYzNTU4NDQwMTc4OTkwMTUyNTcwOTE2NjE3MjI4MzM5MDE3NzY3MzAwOTQ4MzM0MTgyNjkxMTE3OTg2MTU4NDIxMzMxNDM5NTg5MzMyMzAzNTUyNzExNjI4Mzc1ODQ0NTAzODQxMzY0Njc1NzI4MC8zMzMxMDM2NDg0ODc0NDQ4ODcyNzQ3MDc2MTg4OTg2MTA2OTk5MzA3MTk2NTE4MDc1NjE4NzMxMTE3ODEyNDg4NzI4NjEzMzU1NDMyNDA0MjQyMjUwMzI2Mzk5NDcxNzk5MzEyOTUzOTQ0ODMxMDc0MzU5ODEzODM2NDE3Mjg4OTMwNTUzMjQwMTUwNTg5MDM4NDgwNjA3ODc5MDAzNDU1NzA0OTA3NDE2OTI0NTA3ODQxNjcwNDg2Njg2NzM4MDA4OTEwMzA2NDgyMTczMjY3Mzk2NzEyMDgwODYxMTYzNjYxODUyNjczNzEzODQzNTc5MjgxODgyODk5MDQwMzM3NDc2NjIyODAzNzAwMzkyNzU2OTY0Mzk3MjIwMzk5MzI2MzMyOTQwMzQ2OTc0NzM0MjIwNDgwODM2MDk0Nzg0MDEwMzg0MzMxNzUzMzIxMDUyMzg1MzYzMTcxMTYwMTQ1MDYxNzA5NTczNjQ3M1wiLCBcIjIyNDY2NzM1NDc4NjQzNzcxODAzNjI0OTA5MzUyMTgxODE3OTEyMzg3NzMyMTE3Mzc4NTM4Mjg0MTA3NDg1NjIxMDAxMjQ2MTc3MTUyNjQ0MTQxODUzNjA0NjMzNjc2OTM5Njk0MjA4MTMxMjQzMDgxMjI3NjY4MjM3NzE2MTk0MzE2NzMyMTI1NDQ1MDQxMjYwNTY4NDAzNzUyMzI1NDE2MjAzODU4MzI5NDY5NDc3Nzc0NzIwOTk4ODQ5MzM0OTYxNzUxNTQxMTkxNzYxNTIxMjI0NjQ0NTIwNzQyNjkxOTgxMzcyNzgyMDA5Mzk0ODI2NzM5MjQ5NjA0MjU3MDk4MjQ4NzUxNjI2OTU3NTI4NTQzNTU4NTQyNDQzMTIyNDcwNjU3MjMwODM1MTc2NDYyNjEyNTMwNDY0MDQ0NjUyMTQwNTgxMzY3NjY2MjcxNzcxODgyMTk4NzQ3MTgyMTE0Njg1MTE2MzM2NTEyNjA0MDM4ODMzMzI3NzA3MTYzMTA3MjA3NjY0NzA1MTIwNzI4MDY4OTg3OTk2NTYwNTEyLzQ0NjAzNDIyNjA1OTkxMTAwNzE4MTkxNDI1MzU5MDM5OTA4MTc4OTM0MjQxOTI5NzIzNDE4NzIzOTQwMTQ3NDgzMTUwOTA0MzA5OTkyMjQxMDcyNzQ3Nzc2OTUzMDYwMzI3ODMxMDU5NDQ3MjEzMzcwNTMxNTYwNzQ4NTEyNDAyMDExNzk5MDI4MzUzNTMwOTc2ODMyNjkyOTg1OTQxOTA0NTYyODY4ODgzMjYwNjc5MzI3Nzc3MjA1NjExODE3NjAzNjk3ODM0ODY4NzI2NjY5NzQ2MjM5MTA1MTU3OTUyMDgzNTM2MDU2OTcwNjU0NDc5NDI4MDQ0MTQxMjAwMzA2Nzg2MDM1Mzg3NjE1MzgzODU3OTM4Mjk3ODc3MzQ4MzAxMjk3NjQxNTIyNjM2OTEyOTY3MTk3MjY5MDk2MzM1ODAzMTg4OTc3ODc3MjkwMDQ5NzIzMjM1OTk3NzM1NDg2ODkyNzIwMDg3MTI0Mjc5MjY3MzQyNTg5MTMyNzExMDE4OTk3ODA1Mzg2MzUyMTM4MjYyMzk1NDI4ODQxMjVcIiwgXCIxOTcyODYyMDAyMDY2MjUyNzk4ODM3OTc3MTU1MjcyNTM1MzQyNzI3NDE1MzI5NjMyMjUyMjEzNTA4MjY3NzgxMzkwODcwNjQ2OTA5Njg2NzI0OTU1ODYxNjA4MDQ2MzI1NzY1NjUwNDA3MzQwMTAyNDcyODMzNDI4OTA1Mjc5NDczMTg1ODE4ODk4NjkzODU0MzQ0MTM4NDAzNzQ0NzU3ODU3OTI4ODgzNjAxNjM3OTA5NjA0MDgyNTg4MzM4ODY5NjEyMjIxNzc3MjYzNTgyMzY1NzQ1NDE5NzE5ODA1NTg3OTQ2NTU4MzI2MDQ4MDg3MTM4MTk3Njk0MDE2MjI0NjEzMTE4MzA0NjIzODY0NzA5MTgzNjgxMTcyMzYyNjkzMTA2NDYwNTM1MTE3NDU5MTkyOTkyODMyOTY5MTMwODk1ODI5OTE2MjEwOTMzNzEwODIwMDM1NDc5MTY5NTYyOTcwOTgyNzg0NTgwODYxLzM5MTI2Mjg1NDI0NTkzNjE5ODY0OTUwOTI3NTcxOTYyNDE1MjMwNTIwNjgwNzI2MTM4MjYyMTM5MDk0NjA2MDYzNjAzMjM3NjA1NzM4NTcyMzQyNzYwMTExMzIzMzA1MDI2MDM1OTY4NDE1Mzk2MzUyMDc4MjI4NTA5NzY2NDYyODI3OTU5NjYxODUyMTk2MzQ0NDU3NDU0MzQwOTA3NjQyODY2MDg3NDU2NDAyNjY1MTc0MjIzNDcyODk5NzMzOTg0NDE2MTUxNDI3MzY2OTczNTY4NjUxNjc2MTIzOTA3NjUyOTA4ODE0NTIwODk1ODkzODM4NDczMjgwMDU4NjI5ODk0MzI4MTcyODQzNTIwNzQ1MjI1MzE3MDkzNTcxNTIzOTM5MjUzNDgxNTY4MzM2NzExNDI5MDY3NjE4MDgzOTIxNzkxOTUzOTM4MTY1MTg0MTE1MTY3NDg1OTcxNTk5MjMwOTcyNzIzMjAwMFwiLCBcIjI1NDA4NjkxNDI2Mjg2NjUzMjc2MDA0NTU2NDI2NTEzNDAxNzY3NzE4MzI4NjQwMDQ4OTQ1OTE3NzQ1NzgzMjI1NDU5NzA5NDg3NDg3MzU2MDk1MTY0MTY0NjUyMjE4MTAwOTI1ODg4ODQ3Njg5MDk5MTUzMzIwNzc3Mzg5MzgxODUxNTk4MjM2MDQ2NDAyMTI0Njg0NTExOTY4Mzg1MzI1MTA3NDk3MDQ3MDI1NDg1MzAyMzMzNTAzMDc1MDg1NTYyNTMzNDcyNDgyNjQ1MDIzOTYzNzE3MzQ3ODY3Njk2ODYxODg1MzYzNDE3NTk1Mjk4NzUxNDkwMjEyNDk1OTMyNzY2ODcyNzQ4MTI1MTExMTE1MDM5MzExNTA3Mzc0MzYzMDAwMDYyNTEzOTc3NDM2OTIxNzcyMDk2NDQzOTQ4MTU5Mjg5NzA3OTk2NzQ5MDYxMDA3MTEyNDU4MTI2MzAxNjE4NzY5Mjk1MTYyNjQ5NjAwNjczMjQ3Nzk5OTYxMTE4NjYyNjAyNzU2ODg5NDQ4MTUyNTE3MzY0OTkyLzUwMzM4NzA3NzA4MTcxMDQ5MDkwMjU1MTIzMzEyMzg0MTk3NzY0MDczMzEyODE5NDQ1NjU2NDQ0NTczNDU1MDcyNjI4ODExMDA2MTg5MDg0MDU5MjQ5NTE1NTk4NTMzNTI4NDExNTQ3MzA4MDIwMDY3NTA2ODg1ODE2MDMyNzA4NDk4ODA3NTYwMjYyNjIyMTc2NTE2ODU4MTM1ODQ5MDAzMDAzNTc2ODU4NzQwNDQ0ODIzMjk2MDE4OTQxMzQ0NDM1NDI3NTM2OTAwNDg5NjIyNjA5MTQ2NDI2Nzg0NDUwNTg4OTEzODcwNDE5MTk1ODEzNzYxOTU1NDMxOTMxOTkzMDc1MjQ1NzI2NzEzNDQzMjMzNjEyODI2MzM4MjgxNDQ3MDg2ODM1MzY3MjExMTg5MTA1NDk5MzMzMzY4MDA0NjEyNDgzMzgwNTkyMDk4NTM3NjYzMDUwNTg5NDM4ODg5NjUyNzk4NjM4NTIxMDc1MDcwNzU5MTY5ODExNjUxNjQ1NDMxOTkzNTI5MjAwNTUzODk0MDQyOTY4NzVcIiwgXCI2MTY1NjU5NDA0ODE1Nzc3NjUwMTExNzQ2MTc2MTkxMjQ4NDE2MzE2MDM5NDQyNjcyNTYxNzgwOTM1NTUyMzU1OTEyMDgzODc1ODg4OTQwNjgwMDUxNjI3NjY1MTM3MjA1NDY2MjYzOTkzMDgxNjg5MjM5MDQ2MjUyMTA3NDgwNTE3ODg2NTIzMjgwNzIyNDE0OTQyNDMwNDAxODU2MTEzNzMwMzUwNTk2MTkxMzY3MTI1NTk1MDUwMjM3MDMxNTMxOTQ4MTU2MTEyNjg1MDMyOTEyOTUwNTk2NDgyNjk3NzI2NjM5MzkxMzc0NDYyNTM0MzcyNDg1NDE0OTY2MzE4NTI5ODY0OTk2ODgwNTI2Nzg5NjE0OTUxMTYyMTAxMzM0NTg1OTY4NjY2ODQ0MTM5MzExODgzNDg3OTgyNDQ5Njk3OTc5NzM4NDY1NjgxNjA5OTk1NjQ1NDA2NTIxMTE1OTkwODIxODE4NzE0MzYvMTIyMDI1NjgyMTQ5NjI3NDg0NTI4NjUxNTA3MzY4MDUxMzY3NjIwNTc4NDY5MzkyMjMzODc1NDkzNTU2ODI4NjIzNDM3ODY5NjUwMjg0MzU2NzAzMjk1ODM2OTk4MTc4MjU2ODc1NzY2MzE5NTA4Nzk3OTAzOTIzNjM4OTY3MDczNjg3OTkxMjI5NzA4MDUxMjg1NjA1MTg3MzU4NjE2NTMxOTI2MTEyNzM2NDAyNTExNTY3NzIxODg5ODQ1NjkzOTkxOTYzNjEwMTkyMTYxNDEzNjkyOTI4Mzc4NzA4MjIzNzEyNzkxOTMwMTEzMzg2ODQwMTA5NzI5MzY4NzcyOTk4MzQ3MDM2MDkwOTAyMzY0ODAxMDE0MDQ1MzI4MzQ4ODMwNzQ4MzA3MTc5NTkwNzU1NzIzMTYwMTQyNDY4NTYzOTc3MDExNzAwNzY0NTE3ODgwNDY3MTE2NzY2MTUwMzIyNzM2MDAzMTQ3MTI1XCIsIFwiOTc5ODgyMDU2ODM0NTgzMjQxNDc3MTg4Njg2NTUwNTYxNjI1Mjg5MzM3MDI1NzQ3Nzg3MTMyNzczODUzNjkwMTQzMzU5NjU3NTE5NDgxMzk3NTc1NTYxODEyNzI3Mzk0NDcwMTI1MTcyMjcyMjQ2Nzc0NTc4NDA0NTQzMjU3MjEwMTI0NDEyNzE4NzI1MDgxNTM2MzA5ODE4MzgzMzEwODk2MTAyOTU4MTY3MzM3MzMzNDMwNTU1MTY4NjcxMzI3OTkyMzk1OTE2NzM1MDIyNzExMjk3NDM1MjYzMTU3NjcwNTAxMTE3NzM0NDEyNTg3NjkxMjcxMDg0OTgxMTQwMTY3MDE3NDIxOTAwODUyNTUwODIyNTc5NDEwNjM2MTg0MzMzMTQyOTQ0NDExMDYwNzg4NzIzNjUzNTk2Mzc3MDE1MzU5MDM2MTAxMTcwMDU0ODI4NjIzNjY5MTY5MDQ3MTE4NTUxMDEwMTAyMjU4ODAyNDY1NTU0MDMzMTczOTY4NDY4MTgzNDkyMDU4MjcxMzY1ODAxNzU1OTg2NTYwLzE5MzczMjA2NjYyMDUwNDc3NTk4MTc1OTgxMjcwMzAyODc1NzYwODYwMDEyNTc0MjQ3NzE3ODc1MTE4OTYwNzYwMjk4MzE5ODU1OTc3ODAzOTE0MTE5MjQ5MjU4OTczNDI3NzczOTAxNzkwOTg4OTkyNDQ4ODY5OTM3Mjk0MDc4Nzk3Nzc5NDU1NTUxOTQ3NDgwNzkyMDE5ODk0NDEwOTU0OTAyMzU0NzI1OTkxMjMyNDI3OTc0MTAwNjk3NTEyOTUxODE5MTA4MTM3MzU1NDgxNzU4NDIxNDk0MTYyOTAyMTA4ODIwNjk3NzUzMjU5OTA1NTAxNDE1MDQzMzU4MTU0NDU5OTcyMTkwMzg4MTI4NDU4MTI1NzgxMjg1MDY5NzQyMzM1MDgwNTcxNTU4NjQzNjExNDg0MjE4MzI5NTczMDY4MDQ5MDExMDc5MzIyNTUxNDYwMjEzMzMwNDcyOTQ4NDU0NzE4MTc0MDI5MDUzNDA1NjQ0NTQ4MjE4NjQzMDcyOTM5ODcwMTMxMTU2MzI4NTQ5NDk2NDY0NTQxOVwiLCBcIjExMzgwNTk0NDE4OTA0Mjg5MDMzMzY3MTg3MTIxNTk5MDczNjQ5NzU5NTk0ODIxNjMwMDQyNzY5MDE2NzYwNjMxODY5MzkyOTYyMTc1Njk4NDk5OTA5NTE5MzA5NTUyNzA4NDk2OTI3NzUwNzc4MTMzNTk1NzMzOTQ0MzU5MjQ5MzQ1NDAyNjkzMTA2Mjk3MzE4MDEzNzYxMzQ1NDkxNjkzMjI5NDYzMTA3NTY3MzgxODc4MzQxMjg5NTY2NzExOTUzNTg0MTMwMjQwNjIyMzA3NzQxMTE5MzUxMDkyMDMyMDc3Njg4OTg1MjU4ODI0MTcwNzgxMTkzMTQwMDMxNjI1OTIwODc5MjA3NTU1NzIwNTA5OTMzNTU4NDM2ODE5MzExMzkyNTczMDM0ODQ1MjYyMjM0NjE4NDA5Mzk4ODA3NTk5MDg0NDkxODExMzUwMjkzMjc0NDIwMzk2NjY1MTMzMjU5MTY3MjkxMTI4NTMvMjI0Nzc3MzkzNzA0OTg1MzAzMjYwNDMzNDM5NDAxNTAzNTA3NzA1MTQ4NTc2NzI3MzY0Mzg4NzIwMzg3MTc0OTc3MTU0MjA0NjI5MzM2OTg1Mjk4MDgyODkzNDQzMjA1MjIzMDE3OTY2MTQ1MDk4MDY0ODYxNTY2NzU0MjQ0NjI0NzMyNjcxNDcwOTM1NzI1MzI2MDQzNDkxOTExMTQyNDY3MTc4MDI3MDEzMTEyNTI3NjY4MTgzNzgzNDUwOTMyOTkyNTM0NTE3ODI3ODYzMjkzODI1MDYxMjk2MjU3NDIwMTgzNjY5MzgzNzE5MDQzODczNjY2Mjg0Mzc4NjQ3OTUyMzg1NDAxMzAzNzMzMjc0NzcxMDQyMzg1NjY2NDM2MjE0NTE3MjA1Njc4Njc0MjEzMTE4Mzc0ODg5MTIxNTQyMzY5OTk2MDQyMzEzODc5MjU4NjIyMTQ0NDY0NTY1NDAzMTM4MzkyMDY0MDAwXCIsIFwiNjE0MjYyNjE3NjM0OTA0NTA5NDEwNTU1Njk1Mzk4MDkyMTkwMTY2MzIzMjg5Nzg3NzAzOTU0MzI5MTEzNDEyNjQ3MzQyMjMwODU1ODI2NTY4ODczOTQ2MjMzMTM2MzAzNTY2MTc4NjA0Mjc1Mjk2ODczMjM0OTI2NjUyMDgwNDYyMjU5NTUyNzc1MjU0NzU1MTA5OTMxMzEyNTE2NjE2ODM4MDkxODUyOTE1Mzk3ODQ2OTg0MzgxMTgzNzMyNzczNDExMjYzODI4NjAwMTA4NDQzMDcwNzc4ODYxOTg2ODQ5MjcyNzk0NDQyMTA1MTA3Mjg1MjM0NzI5MDc3ODE4NjE0MzMyMTU1ODkwOTQ2ODA0MjU3NzI0MTEyMTQzNjMxNjQyNjYzMDg0NjYwMDEyMzYyNjkxMTAwODcyNDY1MTQ4ODY0NDEzMzQzNTk4MDY3NTY3MTQyOTc3MTM0ODQ2MjY2NDI1MDc1MTk1NTQ2MjY1MTAxNzIwMzI2MjcyNTAyMDA5MjM0Njg5Mzg4MzU1MzY1Nzk0ODg5NDQ0MjU3NTU3NTA0LzEyMTIwMDg1NDY1NTMxMDM0NTg3ODA2OTE1NTE5MDczNDM4MTQ3NjkxNDQxNjg5MzAzMTk0MTc2MTc1NjM3OTE0ODYyMjU5MTMxMDE1Mjc5MzMyODkxMDMzNDM1NzcyNDc2MjA3OTEzOTUwOTgxMzM4MTk5NzI4Nzk1NDMxOTk4MzE2NTk3MTYyODQyOTI5NTgwMzE2MjU2Mzg1NjIxOTIxMTYyNzc5NjIwMDU5OTE5NjI2Mzg2ODc4MTkzNzIzNDAxNTgyMTM2NzU3NTUxMjU0ODUyMjc5MDE1ODEwMTg5MjUwNzk5Njc4MDY3NTg2MzIzNDE4MTcwMDI1MzU0NTkxMjY0MzU0ODQ2NjI1NjkzODkzNjgzNTQ2OTY0NjExNDY1OTU5ODcyNzU5MjM5MDYyODIwOTM2MjA5NjczODM0MzQxNzc3NTAwOTM2MTY3ODU5OTA3NTY3MTE1NDQwNTEzNzY2MzA3Nzc5ODQxOTg5NzkzMjQwNDEwNDU3OTExMzA1NjAzODI3MTc1Mzk4ODY2OTgxMzk4ODA3NjUxNTQ3NjEyNVwiLCBcIjEwNjg5MzQ0NTUzMTk5NTQzMDEzMTgzNzU2OTg5NTcwMzY5NzYwNDk3ODQ0NTg1OTQxMjczOTMzMTA0MjE1MTU0NjA4MzIzNDM3MzQ0MzYwMTkyMzk4MzcxNDI1MjgwMTEwMzU1MTg3NDk4NjAzMzg0MTYzNzA3OTQ3OTc5NDg5NTQ1MjA3NzgwMzE4MjY5ODI5MTgyMjYyOTcxMzUwMDAyMTk5NTI0MTk0MDEzMzAzNzIwMDI2ODM4MTc5MzI4MjMxODY5MTU2ODIzNDcyODMyOTM3ODgyOTMwMTI4MjEyMTU2MjY1MjQ1MjkzNjI5NzQyMjEzNjk2MTE0NzQzMjU1OTc2Njg5NjE0MzA4MTA1OTUxODIzODIzNDc3NzA1NTkzMTk5OTcxNDk3Mzk5OTU1MzQ1NjU0Nzc0NjgyNTYxNzE2ODAwNTY1MDIyMTU0MjQxNzIxNjI5MTQxMjMyNDE3NDc3Mjg5MzYzNTgzMi8yMTA3MDI4NzU0NjU4MzE1NDg5NTEwMjkyNzAyOTIwMzEyNTU3NzM4NTUyODM1MDE3MTQ1NzYzNDIwMzI2MTE5NzEzNzIzODkyMzkyMzI0NTM4MjQ5Mzg2ODEzNDg2OTAwOTg0NDA5NDQzNTA2ODI4NDMzNTkwOTI2NjE1MjA0MjkwMzE1NzcwMDUxMDUzNDkwNDg0NzI1NzQzNjY2Njk4MDY3MTA2NzMyOTA4NDQwOTM0NjE0OTcyOTM4NTYyNTEwODIzMzIzNDU0MjEzMzgzODkyNDI4MTExMzQ1NDUyNjQ3MTg1NTU3MzI3MTA2Njg2NTUzNDQ4MDk3NDQ4NDE5NjY0NDE3MzI3MDE0MTA1NjQ3MDg1NzY2NjYzMjkwMjgyNzYyNTQ3NTcxOTczODA3NjUyNDA0NzczNjEyMzE4MjI1NTMwNjQyOTY3NzY4ODEyOTIzMTY4Mjk3ODU3MDQ2MTI3MzE5MzM1OTM3NVwiLCBcIjExMTI3NDI3OTg3NzY3NDg1NTE5Mjg3NDQ5ODMzMDg1ODQ0OTM4MTcxMTI0MDA1MzYwODQ3NDQ4NTA5NjkwMjUwNjMzNjA2Nzk3ODUzNzg3ODk3NjQ4NzUwNzY1Mjk1NzU1ODM3OTI1NzExOTg1MTAzMDYxODY0MTc3NzMxMDEzNDY0MjU3MDQ5Njk2NzEyNTY1NjQ0OTQxMzU3NTA3ODM2NDI5MTAzOTQyMTM3MjcxODk2Mzk2NjExODQzNzkzNDE5NjE3MzcxMzU3NjQ1NzA5NDI5NjE2OTIxNTkxNzcxODk3NTMxMzkyMDk2Mzg5MjkzMDI5Mjg2OTk3MDUwNDI4MzI5MjI3NzQwMTI2MjIwMTcyNzAxNzIzMzE3MjIyOTU4ODE0MTIxMTE4MTI5MzM1OTMzNzA3NDMyMTAyMTQ1NDkwMzgyMTIzOTU5NDE2NzUyNTc1NTg0NDI4NzgwMTIxMzY0ODQwNTI4Mjc0MzkwMDc0ODM3Nzc4NTkzOTEyMTUyMjI2NDc0OTk3NDE1NzIzMjc3MjU2ODk4NDA4NTAwNDgvMjE5MTIxOTA1NTE0NjUyNTc1MTU1NTc5MTg1MzIyMzY3MTc1NDAwNjY5Mzg2MTMxODkxODQzMzgyNDQ3NDMyODUxMTIyNDYyNDIyOTkyMTQ3NzU2MzMzNzI5ODkzMDI4MzYyMDEzMzE4MjY0MTU1NDg5NTM3MTM4MTMzMzcyNzAzMjk1ODA0MDAyODQwOTIwNDAyNDgyMTEwMjYwNTkwMDU1NzQ5ODQzMTcwMDY0OTIxODQzNDYwNDk4ODI0MTI4Mjc0NDIwOTI1MzU3NTQ3MDIzODc2NDg4OTM5Nzg2ODYzNjYyODAxMjY4Nzk4OTg3Njg1NTAzMzkxMDU4MjUwOTAyNjM0OTk5MzUyNjUyMDYzNjY4NjYzMjQ1ODI5NDk2ODM2ODUzNTA5NjE2ODczMjQ2NTU0MjkyNzk2ODIzNzc5Mzk3MzE3ODE5MTM0ODkxODczNTgzODU3NjIxNjIzMTQzMjUzNzg4ODU0NTMwMTQ2MzAzNjQxNDAwOTg2MDI4NTAzNTM0NDA4ODcwMTk0OTg5NDc4NDIxMjUzMDU3NjI1XCIsIFwiOTgzOTk1MTcwMjU5NjM3NDk3OTQwMTIxNzA3ODU3NjczMjY4NjIwNjAzOTgyODQ0NDM5NjEwMDc2MzM0NzQ5NzkyMTE5NTAyNTU3MzgwMzYxNjI0MDk2OTYwMDcwMTQ4NjI3NjYzMzA1MTcxMzExNjQ2ODUxNTY2ODExNjgzMzUxMjMyMjY4MjQwMTY5ODQ4ODEwNjU4MDg5Njk4NjA2NDA5MTk1NzQ0NDcxMzQzNDE2MTk3NDM0OTI2NTEzNjg0ODgyNDM5NTk2MTQxMzY4Nzk0MTc1MTYyMzE1NjMzMTkyMDI4OTc3MjExOTA5Njk4NTk1Nzc4ODM5NDk3ODQ0ODQ3MjgxMjYyNTU5ODk5OTE0NTA0MDgwMDkyODQ0ODE2MzE5Mjk4Mjg2NTExNDM2NjkwNDI5MTc1NzU3ODA0NjA0NjczNzUyODM4Nzg2ODUyMjc3MjU1MDY0NDM0MzY1NDAxODcxOTAzMzA3NjQzNzA1LzE5MzU3OTQ5OTcwOTczOTc3NzU3Nzg5MzYzOTY2NTY0MzQxNzUyMTkyNDUxMDI0MjExOTU2MTc2NTkzMjA3ODgzNTEyMTk4MzE5MDQwMTc2MjU2MTQzNjIwODc1ODIxMDUxOTIzMTEwMzc2NzIzMjg5OTUyOTQ1NzQ0MDYwMjE2NjkxODcwMTU1MDM4NjE1MjA3MDgxMzUyNjc2MDgyMzUxMzg4NDM5MTA1NTA1NDA3NjQ4NTI5NTk0NTk3MjE4NTQwMjk3NzA5NTgxNTYwOTQ0ODY1MTMxNjgyNDQ1NTI1MDAwNTUwNTQxMDE5MjEwMTE0ODE0OTI4NDc1NjkyODI1MDI1ODYzMjAzMTk4MTQzOTM0NTE2NDAzNzMxODEyOTk4Nzk5OTU0NjY4MzExMzQ4MzcwMDY2MDg3OTQzMTgwMTcyODM5MTkxMTE2MTkwMDY4NjcwNzIzMTU0MzIxNjI4MzMwNDE4MjA2MzAzODQ2NFwiLCBcIjMwNjkxMDEzMDc2ODM2MzgwMzE5NjUyODg0ODQ4NTg1NDMxOTE3NDM5MzU4Mzc1MTE4NDM3MDM1OTQ0OTUwNDk4MTU2ODM2ODg1NDA5MTEwMDg3NjE2NjAyMDQzMjQyNzQ3NDEzNzI4ODY2NzQ3OTc1NjMxNzI3NTY2NjEzNTkzMjU3NjIzMDk5NTQ5NTgzMDAxMzYyMjQ2NjQ5OTI4MDc1ODU5OTQ0Njk1MDYwOTQ3NDM0ODg1NzA3MTAyNjg0NTY4NjMyNTU5MzM5MzgzNDA5Mzc4OTk3NTY4MTgyNDQ1MDE5MTgzOTI4MDU4OTAyNDQ1NzM4NzAyNjEwNDM2MTg3OTA3MTk5NDgyNjA0ODY3MTQ4NDQ1OTAzOTIxNDc0ODQ2MTAzNTg2MjUzMzIwOTUwNzI4OTg5MjI4ODk4MzI0ODI5MTQ0NzAxNzgyNzkyNzY3NzYzNzk0ODk1MTM3MzEzMDUwMzgxMTEyODcyOTcyODA2NzEyNTcwNTU5OTQyNTgzOTA2NjE5MzczMTU5MDUzNjU0NDgxMjUwODA5MTY4MTI4LzYwMzE5MzYxOTA1OTQzNzY1ODUyMzg0MDc5MDU0NjkwMzU1OTg2NjgyMTE2Nzk1MjE1NTMxNDQ5NTgwNTMwOTk0NjM5MzEyMTc4NTY3ODAxNzE4NzIyNTMyNTg3Mzg2MzU1MzEzODU3MTE3MDIxNzYzNDc1NzU1OTczODczODk2ODU1MjYwOTg4ODkyNzgyNzgwMjkzMTQ5ODI3MjEyODQ2OTExOTg5NjcyMDQ2NjQ3NzExNzg3NjE0MTY4OTEzMTc2NzI3MDU3MTkzMDMwODg3NDY5NTM2NDQ5Nzg0NzEyODkwMDE1Nzc2OTg1NTQwMjU0MTA4MjAwNDE0OTcxMDgzMTEyNzA0MzExMzA5MTEwMjE2NTM4NjA4NzQyMzgyMTIwNDA2NDA3MzcxNzExMDM4MjM2MzE3MTg0ODM1NzI0NjQzNjEyNzY3MDMzNzg1ODcxMDYzMTExNTM0NTU1NTc4OTY1MjczODQ0MjYzMjcwNTMxNjUyMTQ4MTQ5NTQxNTQzMjg0ODMyNTc2NTc0MjQ4NzM5Mjk1MDIxMTI5MDQ2MjVcIiwgXCIzMzYzMzAwMjY0MTIxODU3MTAyNzY4MjY5MDM3NzIzOTMwMDU2NzI3NzI5NzMwMTc5MTQzNDg5MDQzMTY0NTkwOTQ0NzA0MDgzMDQ1NzI1MzE4NjI2Mjk3MDc0NzQwNTUxNDg5NzM0MDMxNTQ5MDk3MDg0NjU1MzY2NjIwMTE5MDM4NjQ1NzIyMTg0NjY5NDEyNjYzNzk5ODQ2Mjg3Mzc4NjMzNDgzNzkwMTAwMTgzMzc3MTUxMDM1MzM2NTgyNTA4NzE4NzU4MjgwNzg0Mzk0MDQ3OTE5MjU0NDc3MjU1OTExODI5Mzg1MTEzMTIzNDkxMDYzODcwNTI1ODY2NDkwMTIyNTQ5NDEyOTAyMzI0NDkxNjEyNTU0NTI4MzYyMTYwNzkyMDk4MzI4Nzc5OTY0ODk5MjYzMjgxNDQ2MTgyODk5ODUxNzk0OTQ0OTg4NzUyMjg2NjI1OTcyNDY3NTMxODIzMzUyMjA2MDcyOTY1NDc5Ni82NjAzODAwNTc1MTkwODY0ODE1MTI1MzA3ODE3OTM0MzI3MDUzNTMwMzExOTE1NTcyMzIzNTQ0MjI1MTczOTM1ODMwNTU5NzU2MDc3NjM3MjUxNTM4MDk2MTY0NDk5MTEyNDExNjcyOTEzOTEwNzY3MDMyNDgyMTg4NTcwODc2NTI2NjA2MTE4MDY4OTI5OTEzNTE1NDk3NDAwMzk3NTYyNzIyNjY5NjAzODYxODEzNDUzNDE4NjIxMjQ2NTM4MTE0ODcyMzMwNTM2MDQ0NTE5MjQyNjYzNTM4NjYyMDc2NTgzNTExMDc4NTIzNTczMzIwMDM1MDg0NzQ0Mzk5NTM1NTgxMjE2ODE1MDM0ODM3NTUzMTY1ODUzNTc2NjE2NDIyNTkyNzkwMTAzNzI4MTQxNDQzNjk3MzYyNDA4NzI3MDU2ODEzOTc3MjM0MDc4MjE0Mzg2NzcxMTE1NTg2NDM2OTg1MTA1MDM4ODczOTk4ODc1XCIsIFwiOTA5MDU1MDc0MzM5NTQ1MzIzNzYwODM3Mzc2MTQyMjcwNTkyMjk4OTM1NjM0NjY5NjY3NzMxNDI3NzQ2MzkwMDEwMzI4MzI5Njg4OTQ4ODQ5MDIxNzY2MzQwMDM0OTM2MTk2MjY5NTI3OTg4ODQzMzY3Nzg1NjQ3MTc5Mjg1Njg1MzEwOTQ2OTQzMzM1NTQyMjgwMjY2Mzk0NzMwNTUwMzQ3OTU2MTQ5MzAzMzg1MTA4MTk5MzI0NzU1NjgyODU0NDMwODI1ODgyMTU1Nzk5NDUxMjEzMzcwODY1NjE3NDg2NDU0NDQ1NzE0Mzc5MzEwNjcwMzU3ODQ3NjkxNDkyNDMyODk2MDEwOTM5MDM1MDA0MDk1NDE1ODc5Nzg0NTI4ODc4NjMyMTIxNTAxMDMyNDU2NTAxMDQyMDczNDA0NDA1OTk2ODkzMTU1ODA5OTA3NzkzMjc3NjUyNTk3NDE4NzcxNzY1NTEwNTk1MTUwNjIyMzY0OTk0NzgwNjU2ODk4NDg0ODg4MzI1ODE0NDYxNjg5NzUyNjI1NzAzODU1MDY1Ni8xNzgzMjE5OTk0NDMyNDMwMTMzOTUwNDcyMDE0NTgyMTMwODgzODczNTE1MDYzMTgyMTQzNTIzNzEyMDYzODU5OTY0MTMzMDk5NzcwNzYzODc0NzQ0MTIxODk1ODg1NjQ1MzQ2ODg0MzcxMjczOTMwNzI3NDUwMDY5NDMwNzA0MTQ1OTE1MjYxMTI3MDYxNTM4Mjg4NzAyODU1MDExMjIwNTQ1NTMwMzI2NTg4Nzk5NDEyMDc2ODc5OTg1MDI2MDA2NTkzODkzNjQ4OTExNjM3OTg2MzM3Nzc2MTc0NTU1MTk4ODY1Mzc5NTc4NDI0ODM4MjEwNDY2NzAzNjgzNjQyMTA2OTM0MTU0NjAzNzEwNTg3NDA4NTEyMzU3MzUxNDU1ODkxNTU3NTk0OTc3MTkxNjQxNTI5NDUxNzQ5NDM3MjcwMjA4MjU4MDcyOTIwNTE0NjAyMjQzOTg1MTg0NzQ0OTU1NDc2NTU3MDEyOTEwNDQ2MDIzOTExMzU4MDM3NzYxMjMyMjUzNjE1MTYyMzM1MzM2MjA4MzQzNTA1ODU5Mzc1XCIsIFwiMzk2MjI2MDg3MTI5NTExNzg3NjE2NDcwNzE2MjQ0OTk2OTY1NTI5MzkxNTcxMDE5NjIwMzQyNjU3NDA5MTUwMjUyOTUyMzMwNTM3MzY2NTM3MzUyMTgyNzYzNDc3ODIwMTYwMzU1OTMxMDAzMTc0OTQ2MTA5NDgwMDM2OTE1NjI0OTc0NTAwMTg3MTc5MzY3NjE4NDU3MDA4ODAyNjY3MDg5MDA0Njc4OTI1NTk1Nzc1MjQ5NzI1NjI5NDk1ODQ4MTQ2NjY5NzczNTc0Mzk1Njk5MDMyNzg1MDI0NTIyODgyODkyNzUyOTg3ODI1MDYzOTMzNTczMzk5NjkxNzY0ODY2ODE2Mjg0MDk3MjMyODY5MTk4NDA1OTgxODMwMTA2NTY4ODI2OTIzNDA3OTk2MzY3MzIxMzUzMDAzNTY5MDUyNDE5OTk5ODgwMDg5MTgwNDE4NzU5MjY1Mjc0MzMxMjk5Nzg3NDY4MTM0OTc0ODExLzc3NjUxMTMyOTAyMzgyNTUwNTQwMjAxNjQxNjI4OTA2NzUyOTQ1MDc4OTY0MDAyODIyNTg1MDAwNjE5MzQwMjYxMTI4NTU1MDQ4NjI4ODYzOTk2Nzg0NzQwNDY5OTA4ODUzNjAyNTkwODc3NzI2ODQ1NDc1NjcwMTEwMTI3NTI3ODc0MDg4NjI1MjE0OTEyNTk4OTk1MDEyOTcxNjMwODUyNTkzNTk3MDI3NjQ5MTU0NDg3MjY0NTk1MTAwMzAwMTgwNTkxMDE2NTgxMjU0OTY1Mjk1MjgwMDg5OTAyNDk3NTQwMDQzOTE2MTI4MjMyODcxNjg1MTU5MTMxMjExMjEzNDk3MjM5NTY4NDgzMTQxMDMxMTM3OTA5MjA4MDMxMzkyNDY0ODE1MTg3NTA1NzE0MDY2MjM1ODY4NzQ4OTUwMTg0MDY1OTIzMjM2NjcwNDE4ODIyOTExNjE0NzgwMDYxNzUyOTA1MTcwOTQ0MDAwXCIsIFwiMTI4ODUyMzEzMDkwMDc2NzQxMjQ3Nzg1Njk1MjAzNTY5MDg2NzE1MzQ5NjU4NDc0NzUxMDI1Mzk4NDY4NjMzNjM4Mjk4MDIyMTYwMzkxNzUzODk5NjEzODI5NDMxMTI3NDM1NzcxMzg5Mzk1NjcyNTY3MjA2MjgzMjI2NDg3MTQxNTAyNTc1MDEzNjY5MDE0MzQxMTg4NDExMTU4MDMzNTQ1ODUzOTgyNDU3MzIzOTc3MTI2NzA0MzQxNDIyNTI3MTcyOTE0MTUwODIzNTgzOTk4MjAzMzE4MjYwNTQ0NTE3MzA1MDU5MDE1MTkxMjI5NzcyMDgwMDE2ODY4NzM2OTg1MjI4MDMyMzM1NjY5MTM0NTMxNzY0OTQ0NTg0MzA3ODI5MTM2OTM5NDMyNDg2MjAzOTE0MzI0NzA4NzQ0MjMwOTEzNTA3NDQ1MzI2NTY1ODczMDAyODE0NTUwMDg3MTU1OTQ1ODUxOTI4MjQzMzAxMjQ5NDA1NDcyNDY3ODMwMjk1NzI3NjM3MTQxODkzNjI4MjkwMjQzNDIwMzIyNTYwMC8yNTIyODQ0NTA1MTUwODAzNzA2MDM5NDkyMTMwODQ1Mjk5OTMzOTUwNTA1NzU5NTExODgwNDQwMzI5MDgyNzA0NzA1MTQ5OTk4ODA1NTQ4NjI0NDkyMjMzNDc3NjE1MDcwMjAzNTQzMjE0MjI3ODU3NjAyNzkxNTQ5MTMzMTA0ODgyOTY0ODU5ODk5Nzk3MDYyMDgyNTQyMDY5NzQwNzU0Mzg1NzA1MjE5Mzk4MjYxMjQ4NjA0ODM4NDI3NTgxMzcyMzEzNzMxODI0OTY0Mzg1NjgyMDIxMTAzMzc3NTEyOTExMDYxNjU2NTQ5NDUzNTIxODMxNjc1Nzg2NzU1MDg2MDI4MzI0Nzg3NTI0MDAwMTE1Njc0ODI0MzQzMDE2MTQyNjk1NzkzNjg4ODI4NTg5NzM4NTA5MTQ1MTM4NzAyOTcwNzE4NjY1NDQ4NzU2NTAxODkxMDY1NzY2NzIyODk3MzQzMjY0OTI0OTIwNTk4MTY2NjkyODg5MDcwMTgwOTU4MzI4NDIyNDk3MzgwODEwMjIyMjcyODE3MTU5MTkzNTdcIiwgXCI1NTk1MDY3ODIxNzUzNjg3NDgxODcxNDUwNjcyMzY5MDA4MDM5MjU4MjM3OTIwODgyOTM4NTE0NTMwMDU4ODI2MjExNzMxMjQ1OTAzNjgxMDEyMTM2NTIzNzE5NjU3NDAzNjUxMTkzNzUwNjkwNTM3NDc0MTU0MTU2ODQxOTMwOTI2MDc1MjMyMTE2MzY5MTIwNzQyMTkyMTUwNTM4MDk4ODE4MTQ4NTkxMjk1MTU1OTE0Nzk3ODA2Njk1MTE1MzM2MTkyNTg4MzUxOTk3MTUxNDY2NTU3NzQ5MTk0MTg0MzQwODA4MDc4Mzc1ODczOTYxMTU5NTUxMDUxMjY4MDY3NjI5NjEyOTI0Mjk5MDQzODAxMzIxMTY5ODY5ODQ0MzU1MjgzMDc2MTMwNTQ4Mjg5MjkyOTQ2MDIxODU5MjczMjIyMzg0NjE0OTEwNTk3NDAzNDIzODcyNjYwODQ0MzE5ODg3MjczMjE3MTExODQzMDgxNzYvMTA5NDQ2MTg4MjE2ODY0NDA1MTU0OTM2NjgyMzc0NjA5NDQ4MDgyNDM2MzQ3NjAwMzAxNzY1OTQ0MjMzMjc4MzAzNjQzNzQ0NzM2NTQ0MTA5MjYyNzk0MzgzMDY5MTk3MjcxNDA5Mzk4NjE1ODQ2MzgwNzAxNDU5ODgyNzg0NTQ3ODU3ODIxODMxODE2ODYzMjE2MDgwMDY5OTQ0ODE4NDUzOTA4NzYwNDc2NDc1ODc0MzE5NzkxNTEyNzgyNDQ1NDA4MTM2MTY5ODc4MjA3MzU4NjYzMjUwNDk5NjI4MDAyOTcxNjQ0NDMwMTY0MTg1NTc4OTY2Mzk5OTA4NjIyNjQwNzMyNDExODg1NTY4NjM4MDU0MjI5MTgwNjczNzU1NjkwODg5NDcxMzg4NTg1NTIxMTEzODYyNDkyNDMyOTQ2MTEwOTAyMDcwMTM5Njc5MTY0ODg0MjA4OTg4NDg5OTU1ODc0MTMxMjA2MzQzNTk3Mzc1XCIsIFwiMzY1ODQyMTA5Nzc2MDg1MjU2MjA3ODI5NDUyMzg1NzgxMTI5NDAyNjU2Njg0NTY5OTIyMzIwODEyNjI1NDM4Mjk2OTU4MTc0MTIwMDg0ODAwMDY0NjY5MDQ4MDE3MjI3MDMzMTg1OTY5NTk2NDU4Nzc4MjEzMzA2MTUyMzk3NzY2NjE5NjkyNjQ0Njk0NjQxNjc3MjIzMjEzMTg1OTc3NjI2OTQwMTkzMTA3NjA4MTM4ODI3NzcxMjU5MzM0Mzc5ODk1MDIwMzc3NzAwNzU5Nzg5Nzc0OTk0ODAwMDA4OTMzMTM3NTY5NTQzNTkyODI5MjIwNjExNTQzMDYwMTg5ODQ5NjAxODI4MzQyOTg5MDIzNjkyODc2MTgyMTQ4ODE4MzYzNjg5MjkzMDA5MTc0MzU4MTY4ODI2MzQwMDEwNDkxNzI4NzE1NTQ5OTA0OTg4MTk2MzQ3MzE2NzAzOTg1ODk0MzU1MjE3MjM1MzM5NTQ4MDc4MTg3MTY0MTc2MjU1NDA1NTk2MzEwNjAyOTIxNjQ3MjAzNDI4MjAwMjY5NjY2MTc2LzcxNDk3MjY2OTM3NzgzODI2MzA2Nzc0MzY3MjI1MTQ5ODMzNzg5Nzg4MzAwNjA5NTMwNjgwMzk5OTk0ODA0NzA0MTk2MjEyMjUyMTQ4MzI0NTUyMTkzMTQ5MzMyNzU1MDU3OTgyNjYyODQ0OTg4NTg4Njc4MTU5NjEwNTE2NjM0NjY3NTk3NzA3MjA0ODE4Mjk2NDU3NjE2MzE1NDg0OTczMjg4OTQ0NjM3MTM5OTM5OTEyMTY2MDM0NjkxMTU1MjcyMDc4NjA5ODc2ODg4OTE5MTcwODk0OTE1MjI0MDIyOTgyNzg1MTM4OTI4MDA4MTMzMDAzNDczMzIwMDE4MTUxMzcwNDg2ODk1NjM3OTM2MTAyNTIwMzUzOTUxNTExNTI1OTk2MTk3MjY3NTcyMzU1NzgyNjA4MzUyMDc1MjI5NTQ3NzY0NzMyNjAyNTU3MTMzNDk0NjQ4MjM3MjU4OTAwMjczMzU0MzY0MDUwNjYyOTIxODg5OTM3MzU1NjgyNDg2Mjg3Nzk5MjM5MzYzOTc2NTU2ODQ4MzIwMDQ2OTMzODc1XCIsIFwiNTkzNzg2ODQ4OTQ2MDU3NzMzOTcwNzA3ODM5MzYxMTMyNDQyNjEyOTc5NjY4NjM2Njg1NDYyODI4ODcyOTg5OTk4MTE5NTA1OTk3NzI3MzIzNzc5NzkzODI2MjA3NjYxODA2NjIxNTk0NjA2NjYyMjA4OTQ4OTY4OTY1NjQzNTc1MzM2MDQ5NjI5Nzc5Njg4NDM0NzQwNjIwOTIwODMyNzkxNjU4Mzc0MjQyMTA1OTEwNDI2NTUyNzE1Nzc5NzQyNzIzOTQyMDMyNTM4NzU5NjU1ODk2MTE0OTMzODQzODQyNTcxMTcwODg1MTg1MjE1OTgzNzkzMDExNjk5MTYwNjA5NTEzNTA2NTA2MjE3NTcyMzcyMDY4MDUwMzcyNjE4NzgyMTI0MjQyNjc3ODAzMTI2MTQ5NDIxNzM4NzA2NTE2ODQ1ODcxNjY2OTE1Mzk5MDkwNjg0NTI5MzI4OTE2NDk1NTQ1NzUwNzIyMDUwODA3NjMvMTE1OTM5MTY4Nzc5MjAxMzEyNjA0ODQxNDgzMjI4MTAzMTc2MjkzMjY4NTA3NjMwNTc5NTMwMjU2NzQxNTQ5Mjg5MjA5Nzc5NjUwOTUxNDE0ODU1MzY1NjYyMTc4NzM3OTYwMTkwMDY3MDkyNDc5MzgwMTk0MDQ4NDA0NDA1MTE0MzM0NjcwNDA5MTg3NzAxNjU0NTY5MjU2MDkxMjQxNjY5NzA4NjI0MzAxMDQzMjkzNTc0MTk2NjkxNzUzMjM3NjMxNDMzNzc5MTc5MTM3NjAwMjg1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiwgXCI0NDA3MDY2Mjk4NDI0MDIwNzUxMzc5MjY3OTc3MzI0MDUyNjgwMTU5MTUxOTkzMzQzNDE1NjUyMTg0NDM3NDg3OTg0Nzk1NjM1MDUxMjU2MDU0NzgwNjE2NjQzMjc2NTgxMzc1OTgyMDQxOTI1NTQzNTI2ODg4MzA2Nzk0NzU4NDAzODY4ODIzNTAwMzQxNTAwNzc1MDY4MDQ3OTk4NTk1ODY3NzI5MDQ5Mjk0MDI2ODMyNzY4OTgwOTg2MDE4MTQwOTE0MzA1OTgyNTkzNDc5ODA1NzMwODQ2ODY5MzI5NDk1MDI4MDkwNjg1NjU0MjA5MzczMDE2MzI0OTQzODc2OTEyODQ5MDIwMjYwODg5NTAwOTM4ODg0MjY4NzIyMjI4MTM4NTc5MjgwOTI4NzEyNjcxMzA1MDU3NDQwOTU2OTcxNzI0OTQxMTk2ODk3Nzk0NzQ4NDAwMzcyNjYyOTU1ODYzNTkyNDQ4OTk0Nzc3ODEzNDUyNDk2NTc0NTUxODY4NDc0NTIyNDkwNDA4OTUxNTEyODgxMTQwODUzNTI5NzQ5MzM3MDg1NDQvODU5NzE4NzYzMTgzMzQwMTA1NDIzMTMwNDgwNTY3NzM0MTk1NjcyODU3MDE4NTI4MTYzMDk3MTE3Mzg2NDQwNzQzMDI0Njc3NjMwNzU2NzE1MzEyNDg3OTMwODA0MjUzNDk1NzA1ODQxMDIwNzg3NjQ0NjQxOTY2NTM4NDM5NzM5MzYxMTkwMzczMjIwMDA2OTU5NDkyMDkyODMzMjc2MDYyODA0MjM0MDYzMDI1MTczMDI4NzQ4MDYwOTI4MzU2OTQxOTYzNTM3NzgxNjE2NjMzMzg2NjcwOTExOTUxOTkwMzI4MzE1ODc4OTc0MTAzMjk1MDk0ODcxNjUxODc3NTM0MTg2MTUzNTY4MzY2MzYzNTIzMTkzMTAxMDM2MzkwNzkxMjM2OTgxMTg5OTc1MDAwNjg2NDQ1MDA4OTMyODI0MzgxMzc2MTQ0MjAyODg4MzkyMzA4MjcwOTYxMDk4MzUyMDY2MDUzODU2NzMxOTcxMjM5OTQzNTczOTMyNTczMDQwNDkwOTM2ODM5MzQyMjQ4MjYwMDY3MDQxOTgxNzE1OTIzMDQxMjVcIiwgXCIxMzIyMDM3MTE3ODMxMjI4NDI0ODEwNzg2Mzg0OTI4NzU1ODY5NjIxMDc0MTUzNTI4MDE4NDAwMzMwMTU1NTE4ODA4Njc2MTc2NzE3NjU2MDgyMzE3NDE5NjkxNTA3MDM3ODc2MzA5MTg4OTMzMzIwMzYzNTc4NDAzNzI5NDc2OTc0NzY0MTk1OTg2MDgxMDAzOTgxNjUzMzYwOTE0MDY2MjA0MzQ5Mzk2MjcwNzQ0NTU2NDA1NzE5NzE1MDYwMzIyNjc5NzQ0NjkzMzUzMjEzMzk1NjA1NDY3MTEwMzk0MjUyMDE0MjU2ODY3NDMzOTQxMTI1MDAwMTU4NTk5MTc0MzYwODcyMzE1MDI4NDI3MDEwMTMyNjQxOTQ2NDA4ODI5MDE1MTQ4MzgyMzA2MTYxMzQwMzY3Mzk1NjkxODQ1ODQ1NjE2NTU1MjQ4MjkxMzA3OTI4MzUzNzUzNjIxNDk2NzI5NDIxMTI0NDM2MTM1MzA2MC8yNTc2NjgzMDEzNzk3MDU1MjI0Mzc3NzA3NzEzNzA0ODk5MzE1Mzc3Mzc5NTQ4NjMwNTExMDk1MTM2NTY4MjIwMTQ1ODA4NzgwMTYyNjcxNDczOTA3MjYwNjIzNTAzNTUyMzg1Mzg0NDgyNzIzMTczOTEzNTYyNDIzMzE2OTk3NTI4OTEzNjUxMDQ0Mjc3NDE4MjI3NjE2NDQ3ODE1NjA5ODczOTkxMDI4MDczMDExNzM4MTEzOTI3OTYxODI0NjMyODY4OTU2ODAyMjcxMjYwMjkyMDc1ODI1NTYxNjQ2MTU2NjgwNzQwMzIzNjg2MTI2ODExOTI4MzcyNjcyNjcwOTE3MzMyNjEzNDkwMjQxNjE1ODUwOTUzNjYwMjQ2MjcxNTQxNTkyMDU2MTQzNjExNTgxMjIzMjk1MDQ1MDYyMTU3NDA0OTk2OTU4MTAwMTM2MzU4NjQ5MTA5NjkzNjU5NjIzODQ3MDI0MDExMjY1MTQ3XCIsIFwiMTUzODM3MjU3ODA3MjI0NjcwNTI2NjA3ODI0Nzk1MDA4OTIxOTg4MTE5NzEzOTM5OTA4MTY0MzY1MDI3MTM0ODc3MDExMDE3ODIxNzk1OTg1NjgxOTE3MDMyNTQwMDQ3NjY1NTk0NDExNTU1MzIzODk0MDU0MTY5NTE1MjExMDk0OTA4MTY3NTk4NTI5OTE4OTkxMzUxNTk3NTI0Mjg0MDQ3MzYxNjE2OTc3NTg4MDI3MjQ4OTgwNTEyMzEyNDU0ODI1NjY2NjY1ODU4NDEyOTg3MzU5NzE5MjIxMzA4MDAzODkzNzQwOTA0NjExNDkwODcxOTI5ODE3MDA3ODQ3NjMyNTQyMzQ2NjczNDQyOTg3MDA0ODY5NzM4MzMwNDI2NTM0MjEyNTQyNTA4NzEwNTY5ODE1MjY0MzE0NTUzMTc2MDg1MzEyNzgwMTEyMzI3MjM4OTEzNDUxNDMzMzc1MjE3MzE3MzE2MTU2MjI3MzQ4Nzc1MjA2NDg1MDQ2MTgyMzcyNjk0ODU4ODIyMTkxMzU0MDc5OTgxNjQ4OTU2Njg4Mzc5ODkxMi8yOTk1NjYxMDI0NDY3NDU1NTI4MTM1NDQ4MDgxNjkzMjMyNzAzMTUzMjcxMjIyNDkzMjczOTQyNzk0Njc5OTkzMDg2NjkyODU0MTYxNzk0ODYwNzUyNTUwMjM1MjM3MjY0NDk0MjgxNTE4MDc2NzI1MjgzNjg2MDYwNzEwNDc4MTI5MDc5MzU0MjY0MDY4ODYyNTMyODQ1ODAyOTYzNDkzNDk1NTg3OTcxMjg1OTM0NDYzMTY3ODYyNDM2NjYyOTA2NDk0NDI5NTYxMzQ0NDg0ODA1OTgzMDM1Mjc3OTU5OTYyMjI3MDM4Mzc2NjM2MDU2MDA2MjQyNzE4MDc0NjE2MDUyOTU5NTY2NzQ5MjUyNzc2NTgzMzE3NjAwMDAxMTc3NjEwMTMzODExOTk4ODA5MDU3NDgxODgxNTE1NTYxODQ2MjA3Nzk2Njc2NzAyNzg1NTg4MzkxMTY5ODM2MzY5NzI2ODA3NDk4MzY0OTczNDY4NjM3NTI2NjI1MjExOTc3MDA3MTc3MDI3OTAzNTkxNjIzMDc2MTcwMjQ1NjY2ODkyNzE2MjVcIiwgXCIyODE2OTY5MzcyMjIzNjM2ODUzMzM2ODgwOTc5MTU1MzkxNDYyNzIxMTc0MTcwMjQwNzA3MjgwMzEwNjM4MjE3ODEzOTg5ODU3OTU4MTMzMzM2NTA1NDc5ODI5NjUzNDEyOTg4OTQ2MzQ3NjIyODk2NjkyNTYxMjk4MDU1NDU1NDkyODAzNTU2NDMxMjI1MDExODE4NTIxMzYzMzI1Mjk1MTU3NTYwNzQ1MDI5MDIyMDQ4Nzc2NjQzOTU0NTYyNzgyMDU3NzAyMDYwMTk2NjMwODI1MTEwOTg5NTY0Njg3MjQ4Mjk0NzUyMjA5OTY0MjcxMzAyOTUwMTA0MzA3NTE5NDIxMjYyNjM2MjAyMDY4ODY0MDQyNDQ0MzI0MDkxNjQ2NTE1MjQ0MDgxOTgyODY4MzEzMjk2ODI2MDU5NTk4ODE5OTM4NDUxODk1ODU2NDA4NzQyMjAwMzI1MTU0NjUwMTQwOTczNDU3NTk0OTA3NTAzMDcyMDcvNTQ4MDYyNzQ5Mjc5MzU0OTU1OTY4OTEzMTIwMjkxNzM4NjI0NzM2ODc2MTAwOTkzMjU5OTg1ODMwOTIwOTE5MTUxMDEyNjUzOTMxNTc2MzEyNDQ3NzUzODc4MzI2MjEwMzIyMzA0MzQwMDc0ODY2MDI4MTY5NzI3NjUyMTAyMDU1OTY0ODI5NDIwOTE1MTg0NTk4NDk3NzU0NTgwODk1NzU3NDM2OTk3OTcwOTY2OTc1NDIzMDYwNDk2Mjg5Mzk5MTk0NjYzNzgxODk2NTYwNjU0NjE3MDg2ODY0MjExMzA5NTY5OTY5NjUwMDQ3NzYxMDg0OTkyNzM4NzEwNTU2MTU0MTM1NjYwNDMwODM2MzQwOTAwODMwOTY5Njc1Njc5NjUzNzMyMDM2ODMyMzExNzE1OTQ5MjIzNDc4MTI5NjY5MDUxNDk4NzMyNjU2NTQ5NjI4OTY0NTY0NTE2ODEzMzIyMTY3MzUzOTYyNDkyMDY3ODQwMDBcIiwgXCIyMjg1MDYyMzg1MzM0MTA4MDUyMzgyNTMxMjI5NjE0NzE2Mzc1MDE0OTg0MDYxMDQ0MzAwNDY3Mjc3OTM0MjA0OTc4OTU4NTI0MTI1MTM1NjAyMDM0NzU0NDAxNTYyMTYwNjM1NzQ2NTQzNzI3MjYxOTQyMTUwMTM0MDczMjUyMDc3NjMzNjkwNzUyNTA4MTkzODY4OTcwODY3MDI3NTcxMjU0MTgzMjcwODQzMTI5MzMwNjE3MzgzOTI0MDYzMjEwMDMyMzE4NTMzNDk4NjUwMDMzMjI2OTczNjA2NTk3MTI3NzExNjcwNjY0NTM0MzAzMDk5OTc2Mzk1NDgzMjA2NzMyNzk5NjQyMTA3MzA3MDEzNzM3MDc3NjUwNTEyNDY1OTU4MDY2NzM4NjU2NDY2MDc4NDE4NzY0NjM2MDgwMzkxMTEyNTI2MDc0NTI4NDMzNzI5NzA3OTc0Nzk5NTkyMTM0NDcyMzc1NDA4MzA1NjM0NjkyOTcxNDQ0NDYwNjk2ODkxNDk1NDk1MTU0NTczMTg4OTk5ODE3NjM0ODk3OTIvNDQ0MTg3NTk4MTMxODg0NzAyNDY1OTY4MjI5NzQyODE5MzIyMTkwODg2OTcwMDUxMjMyODU1OTg5MDkzMjkzMjg0MTk4NzkyMTIxNjQ1NjQ1NjE1NTg2NTY1NDc2NzgyMTEyNjU1Mjk4MDMwODY3MDI4NDMzODAxMjg0NTc3NDQ0NDU3NjU4NTkzOTM0MjY2NzUzOTYzOTMwNTMwOTQ1ODgyNDA0NTc1NjkzODAxNTU1MjYxNzkwNDA4OTEwMDk3MTczMjMwNTk2NDEwMzUxODkwMTc5MTg0OTU0ODU2MzA2NTczNjA1MjU0MTA1MDY0NTM1NTQyNTU3MzQwMDU0NTk2MTQ4NTg5NzI5MDQzNzQ3Mzk2NzM4MzQxNDUwODM1MTIxNjA4ODM0MDIxNTE2MzY2NjQyMDgyNTMxMTYzNjIwODkyMTE2NTg2NDUzMTI3Nzg0MDQ4ODY0NjAyMDM2MDA3NjI1NDY4MTA4OTc4ODk2MjkzMzAwMjIzMDk3MDU1ODM0Mzg2OTkyNTAxMDk0OTM3MzI0NTIzOTI1NzgxMjVcIiwgXCIyMzk2MTEwMjk3MTg3NTcwNTA2MjU3ODM2NDI2MjUxOTMwNTIxMjQ1MTE3OTYwOTgwNjY3ODk3MTk0NjgwODk3NDc4OTk2MzIyNTkwOTI1MzgwMzEwOTE3NDAwNzYzNTgxNzg3OTgxOTkyMTMxNzY5MDc1OTYxMjU5MzkzNjg1MzMxNTIzNjAwMjg3Mzc3ODQxOTkwNjc4MTE3MTEzNTY2OTkxMTAwNzIwOTk2MDU5MTg3MTQ0OTM0NTY5NzAzMDQ1OTY2MjEwMzA2MjgyMzQ4NTI3NzI5NTMzODA2ODgyNDA4MzIzOTYxMzM2MTY2MTkwMTYyMDc1MTU0NTc5MzQ0MTg1MjQ0OTU3NjczMTM4MzcyMzQ3OTk3MTM0Mzg4ODAxMDg1Nzg4MzUzNDgyMjc2MjU3NDAxMDA1NzM0OTI5MDU5NzAwMzQ2Njg3NzgzNDAwNzcyMzMxMjgwNjQ0NjQ3MDg5NTIwNjQ2NTYyNjY5ODU3NjUyNjQ4LzQ2NTM3MDE1NDI2Mjg2MzAzMDgwMDcyOTE4MDc2MzA5MTk2NzU3MzUyMjc3OTI2MDQwNzYxNTU2NzU2MzI3NDA5NjAzNzI5NzU5Mzc2NDk1NTgyMDYyNjIxMzgyNzk2MjY5NzYwMTMzNDkzNTc3MzgwMjIwMTkxOTQ4MzY1NzMxMDI4MjIzNjEwMDI1MDU0Mzk5MjMzNDg2NTQ2MTgwMDk3NjgzODc5MTAzNTMzNTg2MTQyMDg5Mjk2NzY5OTg0MzYwODg1NTE4NTcxMDc1MzQzMzg1MjI3OTczNzcyNDQ0NjI5NDQ0MzMzNzM2MzQ3ODY3OTYwMTA0OTQzMjQwNDQzNTY3MjQ2OTA5ODg1MDY3NjMwMjcyODExNjM2OTk3OTQ2MDIyMjE0ODIwNjk0NDMyMzczMDU4NjEzODA4Nzg2MjcxOTM4NjMyNzM5NjMzNDQ2ODMwMjYwODQ5OTIzNTExMjUyMDMxODMyMjc2Mzg1NzY3NjM3NVwiLCBcIjExODgyNzI4ODgwNzUyNDc1MjA0NTM1Njg3OTA2NTE4MTkxODc0ODYzODk1NDY3NTU3NDU5NjE5NTIwMzMxNTA1NzYyNDM1NzU4NjIxMjA1NjkzOTk4MDg0NjcwNjc4MDA4MzA4OTA4NzQzOTE0ODc4MjI3MjM4Nzk3MTc1MjUyNjQ4NzU3MjI3MjA0MTYxNzMyNzY5NjMxNzA2NzI2MjIyMTQxMjEzMDgwMzg1MzA5NjgyOTE3NTg0NDU1MTA5ODIxODYwMTQyODk3NDUwMjY0Mzk0NzcxOTcxNDg0NDUwODc2MTQ4MTMyNjIxNzA5NzUwNTY4NjY4ODE5MDkwNTY0NTAwMjMzMjQ3NDM0MDkxMTQxMTUxNDExNDUzNDA0ODA4NDYwODg4Njk4MDc1NDA3OTgwNzM0MTcwMzUxNjgxMzk0NzYxNTM4OTcwNjYzMjUxMjc1NDA2MDk3NTYzMTAwNjg1NTg2MTAxMTI3MzE2MDc1MjIwOTYwOTY4MjE5MzgxNjMxMzQwODA0MjYzNTY4OTQ4OTkyNDU1NzU0MTA0OTQwODAvMjMwNTg2NzYyMzk1OTE0ODYzNjI1NzA5MDQ4Nzg5OTEzODQwNTExMTM0MDA0MzM3OTQ1NzAwMzY4MTE3Nzk1MTk1NzY5NTc2ODU2NDM0NTg4MTQ0MzYxNDU5NzQwODMzMDA3MTI1NTE2OTA1MDE3NDE1MTg0Nzg3MDc4NzEwMDAxOTY5ODE1NDE2MjgxMzgxNDI3Mzg3OTQ5MjYzNzkyMjAwNTc3NzkxNjQ0Mjc4MjM0NjYxOTUyODUyMTQ5MjE2NTQwNDkxODUyNzU3MTc0ODQyMTQ2Mzc2Nzg4MjgwNjc3OTU2MzUwOTAxMDgyODM4NDc0NzA1MjI3NjQyNDIwMjYxNjQxNzgzNzIyODkxOTQ4NzEwODMzODk4MjQ4NTY2ODkzMzIyMTQ0NDM1NDU3OTY3NDUyNDQ5OTY1NzcyNTQzMDc3NDIxNDA3ODE2MjI1NzA0OTUyMjcwNjk3MDE2MTUyNDUyMDMyNTA2ODk4MzExMjYwOTc5NTk0NTUwMTQzMzQ0OTcxNDE2Nzg2NTk1ODg4MDUzMTQ5Mzc1Mjg3MTIwNzMzXCIsIFwiMTA3MjE4NDI5OTI1ODQ2ODI0OTAwNDExNDUzNjAyMzkzNDg2OTUxODE1MjYxODM2OTg5NTYxMzI3MTYxODY5ODkwODQwNTUxNDYzMDE1NDgxOTQ1Mzk3OTQ3NzA3NzczODUyNjY3MzcxNjI2NDgzMDEwNjc0NTAzMTM4NTk1MTczNjEwODM3Njg2NjI1Mzk1NTMxOTcxMTAyNjA0MjM4OTI4MjAwOTM0ODU5NDg0NTQ5NzI1MjA1OTkwNjkwMTc0ODg2MDExMTk4NjgxMTM0NTc0Mjk5ODk2ODI4NDA3NzExOTE2NTA4MjQzNTU5ODM4MTgxMDMwNjY5MTA3ODAzNzAxODQzMjc2NjExNjg2NTc5MjY3Nzk1NTUyMDQ2NTMxOTE4NDMxMTUyOTY2NzY0Mjk5NTIxNzIxNDUwNzY1ODY5MzI1OTY5NDU4NjEwNzg0NzA5OTkxMTM0MTIxOTkxMzU3NjAzODYwNTg3MjIxODY4MDU2MjA0Ny8yMDc4ODIxMjk1MzU2MDcxMTg1MjA4MTg1NjU4MTExNjI2NDM4MTE4MTE1NjM1MTYwMDY4MzY5MjQzNDExMjM5NzY4NDgwMjI5NzAwMjQ3OTMwMDQ3MDA3MTA5OTI5Mzg5ODc0NzY3Mjg2NDA5NDM4MzQwMTI0NzM2ODc4OTI0ODEwNTk2MTg4MjM1MjA3MjE3Mzc0NzkzNjQzNTI4ODcxNzgwMTc4NjY0MjUwMjc5NTMyNTU4NTY0NDAwOTk0NDYxMTI1MDg2NjM2MDMzMTk3NDUwNjY3NTA1MjI5MzY0MDg3ODE1OTE1NzgzMjEwMzExNzM2MjA0NDU4NjUxMTMyOTU0MDc2MDMwOTAzMjIyODM1Mzk5NzQ1NjM2OTAxNTc0MTg5MzEwNjA1NjU2OTgzMTU0MDYwMjE1Njk0OTE3NTE2MTI3NjE4ODg2NDExNDE0NDY0MDY1MzE2NDUzNzkyNjQ3MjA2ODQyNDgzOTgyOTkxMzYwMDBcIiwgXCIxNTgwOTQwMjM5MDQzNzQ0NjQwNTc3MDIwMTAxMjY5OTMyMzExNTE0MzM0NzQzNjE4MjAyNjY1ODQwMjA0MDAxMDE1MzM2NTE1ODcwNzI0MzI3MjgwNTA3NzY1MDY2NzI1Mjc3MTg5NzUwNDI2MTY2NTExNzcwMzQ2MzUxODgxNzg5Njc0NjI5ODI5MjYyNjE1MTY3NDg4NDIwNzM1ODc5ODE5NTMwMzg0NDU5Nzc1MTQ0NDY4Mzg3MzM1NTc5MjY2OTY5Mzk1OTEwNjk3MTIzOTc5NDcwNTUyNjE3Nzc0MTY3MDQwMjg1MDY0NDExNzM1NDAzMzgzMjc1OTE1MTQ2NTAzOTgzNDkwNjkzNDgzODEzMDk2ODg2NzczMzUxMzIxMDA0NDE5MDU2MDM2NjQyODI3MzUzMTAyOTk2ODYyNjg3MjE2MzQzNjk1MDIyOTY4Njc0MDk1MTQ3NzczNTk5MzUwMjIzMDE0MjUxNjU3NTA3ODA5ODgyMzE2Mzk4Mjg2NzU0MjQyMzk5MzE1MzM4NDk4OTY3NDQxOTgwMTI3NDc2NzAyNzIvMzA2MjYzODQzNjY1MTM5MjM2NzEwNjM5NTU0Njk1Mzc3NzYyOTExODI1OTQwODAwODM0OTQ3MzczNDE2MDQ1Nzk1NzU0NDYzMTkxOTA5MTY5MjQ2ODI4MDk1NDYwMjQzNjkzMzA3MDYwMTI2NTM3OTk3ODMxMjIzMjg3NzU4NzUzOTkzNjM3NTkzMDgxOTM0MzIzMjczNTg4Mzc3NzI4MjU2MDkzNTY1NTM5NTUzNTA0MDE3MjU2ODk2ODI4Mzg3MDE5OTY0NDY0MDQ1NTkwMDU4OTY0Nzk2MTgzMTEzNTc1NzMyMDMwODExNTM4NTU5NjE0ODQzOTgzNjA2NzA4Mzc1OTk4NTMyOTQ2MjcxNTM3NDAyMjQ1NDMxNzU0OTc2NTU0MTQ1ODU5MTgyMzEyMTU2Mzk5MDY5MjQzMTM3Nzk5MzMyMTE3NzQyOTE1NjU0MjUzNjA0MTU2ODQ1NTY2NTUwMjEwMzExMzEzNDkzMTczOTAzODIzMjAyODYwOTI2Njc4NTIxNzM4MTUyNTk0MjI3Mzc5NTY3Njc5MjIxNTQ3OTgzNzVcIiwgXCIxMjIxNjI3ODkyNDI4NjQwMTg5NzQ3MDU0MDE2OTgyMjU0MjQxNzYxMTM1Njc5NzY3NjE2MDEyODE3NjcwNjcyMTM0MzUxMTU5ODk1MTg2NjEwNzg1ODcyOTQwNTYxNTYzMTI0NjAwMzQ1ODA2Mjk0OTcyMzI5MDE5MjI0MjU5NDYwOTk5NDYxMzcwNTE4MzQ2MDgxNDc5NzUyNzIxNDU0OTE0MjA0MzU3Mzg2Mzk0NzY1ODgzMjY5NDgwMDE4NDY5MTIyMjQyNjUyMTcwMzcyODM5NDIwMzcyMjQyMDMzNjc3MzMxMDkwODY4NzA3MTY3MDEwNzc5NDU0MzAyMjU2Nzk0MzQ3ODg0MzA2NTI0NjAxMTU0NDg4ODM5MDc1NzgxMDUzNDIxMTU1NDY2NjczNjIzOTUwNjUwMzYxMzc1MDc1NjI0NjM2NDYyMTUwOTM1OTgwNDkwMjI0MzQ4NzExMzY3MzAxNDU4ODMyNTgwNjI0OTk4ODMzMi8yMzY0NTg0MTI3NzM0NjgwNTgwNDgxNzA4MzY4OTI3OTIxMTI1OTM0MzMwMDAwMTYyOTM1MTE4MzcxMTc0MjY5NjQyODMxNDA5MDg0NjM0Mzc1NjU0MjM5NzM1MDU0MzYzOTI4NzQ4MTYyMjI5Mjk0ODI5NTI2MzM5OTI3OTA3Nzc4NTEwNTMwNDQ0NjQ2NzU0NjAzMzIyMzczNzEyNzg4MTQ3MTkzNjkxMDM3Njg4NTUyODU3MTgzMTE2MzMyMjkyMDQ4NzMxNzI2MzA1NDUxNTE2OTU0Njc5Mjc3MzIwNzc3OTU1MzQyMjk1NTY0MDAwNTg2OTIzMjI3Nzc1MjA4NTgwNzcyODY4NTkwNzQyMTM2MTUwNDMxMTUyNDk1NzE4MTMyMTQyNzQyMTUzNjQzMDgxMTg3NjkxODQ5ODI4MjE3NTkyOTU0NTE5NDg1ODY5MTM1OTMwNzU1NjQ2NzY4Mzc1Mjk5ODcwOTY3ODY0OTkwMjM0Mzc1XCIsIFwiNTc4OTM5MTk1MDE3NDQ3ODY0Mzg1ODM3MzQxOTc1NTU4Njc5MjkyOTAzNzE2NTgwMTE0NDIxMDMwNTM4NzI4Nzc4NDkxNjA2MjgyMTUzNTg4OTMwOTgzOTY2MTAwNTE0MTQ3OTc2MzIxMzA1NjE2MTk2NDYzMTc0MDcwMzQ1ODg0MjkyNjcyODQyNDk3NzE1OTY2OTMzNzIyMDg4NTM2NjE5MzMzOTEyNjg3MTA4NzM3NjU3MDY4NzAxMzUyOTE4NTgyNjU2MTA1NDE4NDkxNjcyMzc3MjcxMzA0OTcwNDA3NzMwNzg2OTMyOTEzNDkwODY5Nzk3NDcxMDgxMDgxNDMxMDcyODM2ODE0NTgxMDk5MjcxODMyNjk2OTkwMDY0ODI4NzE3Mjg3MjU4ODYwMTY2ODQyNzkxOTg0MTU4NjM0Njg0MDc4MzQ2NDUzMjAyOTI4MTM3OTg3OTMwMzI4ODI2MjEyMDExNzc0NjcwMzk2MzU2MTUxMjY1NzgxMDUzNTQ3NDEyNjMzMzEwMzI3NzM3OTAwNzg2NjM5ODQyNjc0Mjg4NzE2NDE2LzExMTk2NjI5MTY0OTY1MTYwMDcwMTg3NTE4NjgyNzM2MDgwNzU1ODk2MDgxNzU4OTcxOTA5NjQwNzg4Nzk5OTEwODAyNDU1NzI1NDIyMTAwODg0OTUxMDE1MjQ2OTExOTIxMTU2NzE1MjYxNjc0NTc2OTI1NjEyMzk2ODgzMjI1MDEwNDAwNjU2MDA2MTkwNzc0MTU2NzAzNDA4NzEwOTUxMjQ4MzM1Nzg1MTkxOTQwMjAxNzk1MDgxMjc5NTQyNjM5MzQxNTQwOTE5ODI2ODI0NjMzNzU0MjYzOTQ3MDgzNDE2ODA0MDI5NTEzNDEzMDY1NzA3MzIwMTAyMDM0MDQzMjIzNjcyMzgyNDY3MDgwMzQ5ODk0OTA3MTg3MDU5NzAzOTMwOTAwNDU2MjAyNDAzMzY1NjQ4ODE1MDQwNjEwNTE3NTQwMTM3MjcwOTAxMTA4MjcyNTM1OTM4MjY5MTI3MDY1OTI0NTMxMjEzMzkxOTUxODc2MDMyODQyMjgyNzA2NzU3ODMwNjAwNTY0NDgyNTkyNzA1MDk5NDg2MDcyMzQwNTQ3MzM3NVwiLCBcIjgwNDE1MTQ4MjE1NDU4MzM4NjUzNTA4NzMyMTI4NTM4NzMwNDIxMTIzNDMzMjc1NzMzNjQ1MjM5NDg3ODAwMzA4NDk1NDM3NTMwNzI2ODg1MjY3MTc4ODY1OTAwMTMwMjgyMjc3MTQ1ODU5NjUwOTUyMTYzODE4Mjk5MTQ5OTY1MzkxMzIzNTkyNDc0ODg2Mzk2OTI4Mjg2MzkxNzAwNzU3MjYzMDE0MTE3NzczMDcxNjg3Mzc2NjcwNzc3MzA3OTI4OTIzMjY5Nzk0NDY0MjYzNDk4MTM2NDI2ODA1Mzc2OTk5MDU2NTExMjUwNjgwOTEzNjIxMzUwNTU5MDIxNTI5OTQyMTYyMzM2MjI3MzM0MjQxMjg5ODIwMTEyNDg5MjMwNTE0MTAxNDEwMzMxNDY2MDQ2ODgwODM3MjE0MTM0MDIzOTUyOTA4NDI3MzgwMjEzNjU4NjE2NzA0MTU4MzMzNTY0MDMzNjQ2OTY3NTk1ODMwMDk2MzUvMTU1MzkzNzgzMzQ5OTU1OTEwNDkxMDU1MTgxMTU5MjEzODgzMzE4OTg5MjQ2NDQ0Njc2MTI0NzczMTMzMDY3MjI4NDE5MTMxMzU5MDcwODQzOTY4MDQ2MDU0MDMyOTgzNjM0NDc2NzU1NzU5OTc0NjIzNDIxMzAwNjQ5Mzg0Mjg0Mjg3OTM5ODY4NDc0NTg2NDkxOTk3MzA1MTYzNTEyNzA4MDczODYxMjI0ODE1MDEwODc5MzM5Nzg1NTExMzEyMjM2ODUwNzQ4MzQyOTIwOTEyNzAzNTI2MzUwNDE5NDg0Nzc5ODgwOTYxMjI3ODg2NDQzODI4NzgxNTQ3MDcxMTAzNjU0ODY5NTAzMjQyMTE0ODEyNTg0OTY2OTE3NTcyOTMzMTQ1OTE0OTgzMzk0NTE4MzIyODQxMzk2MTk4NTM4MTMzODE2MjE1NTU5NjAwODY4MDkwNjY3NjQ5ODQzNTk1NDE3ODIyNjk3MzI3MjM3MTYyNTk4NFwiLCBcIjEyMDU5NjU5Mzk5MzA5MTY5MTY3MzAxMzUzODQyMTIzMTkxNDA5MzA2OTk1Nzg4NjMzOTY1NjgwNDE0NjIwMzAyMjg1NjA2ODk2MTQ2NjY3NzUxNDcyODE4NTQxNTM3MTgzNzg3OTM1MzUyNzAwNzI1OTgyMDUzNTM2MDMyOTMwODY2NzA4NDEzMDEwOTcxODU2ODU2NzY4Mzg0OTc0ODQ5Njk1Nzc0NDM3MTc4NzkwODkwMDE1MjQyMzIzODczNzY5Njk3NDA3NDExNTU4NzA2NjI2MTA1MTQwNTk2MTYwMDQ5NzM1NjA1Mzg5MzAxNDE0NDYwODI1Njc0NjMxMTIyNDYyNzYwMDE0NDUxMjk4NDk0ODc1MjQ0NzU0MzU0MDU0NDQ3Njk3NTAyNTIxMzg4MzgxMjUzMjkzMTc1MzY3NTU4MDE0NDUzODY1OTA1MTA0NDY3MzgyMTg0OTk3NTI4ODc5MTcxMTM2NDkyMjc3MjIyMTI3Mzk5MDEyMzY4Njc3NjA0OTEwNDk3Nzg5MzYwMjEyNTcxMjM4MTQ2NjI3MDQ4MDgwNTY4NDAwMzg0LzIzMjg0OTQwNTQwMDI3MDMwNjcyMTkwMDQ0ODQ3ODI5MzE0NzE5MTk3NTE1ODU5Njk0ODcxNjA2MDIyNjk2MDU5MTY2NzYyMjMzMTUwNTU0NTA4NDU5NDI3NjM2OTA1ODE4Nzc3NzExNTk2MTU0Mjg4NTQ4MDI3MjE5NDMxMTQ0NjM4MzQ5OTIxMDYzMDAxODUzMjg4NzY5MTAyNzE2MTIzNzU1MDkxNjY5NzU2Mjg1NDA4Mzk4NTg3NzEwNzg0OTUyNjc1NjYwMDgwNzE1MzI4NzY4MTY4MjY3NTEwNjk0MDgxNTMzMjM4NDA1MTUwMzc0OTc2NjQ4NzE2ODkwODUzNzA2OTk5OTE4NjA3MzgzNjgzNzE1MTA1NzgwNzY2ODMzOTUxMDEwNjI0Mzk0OTM4MzE3NzMxOTQ0OTg1Nzk2MjA1MTMwNzM2OTMwMjIxOTE3MDIzOTg2MDE0NzEyMzcxNjYzODcwNDU3OTA0ODA4NjE5MzIwMDUwMTI4MDcyMzQwNzE0Mjk2Mjg3MjU5ODE5MzUxNDcwNjk3Mzg5ODg2ODI4NTg0MTcxODI2MjVcIiwgXCI2ODMwMDk0MjY3MDUwMDg4NTA2ODI1NDk3MDAzODI5MDE2MDM3NDI2OTE3MDUxMjMzNTY4NjYzMzg5NTEzOTczNDczNjgwNTkxMDUxNDA4MjY2NTU0ODY1MTg0MTY1Nzg2OTc5MzEyNDQzNDc1NTQzMjI2NTQ0MjgxNjI1NTQ5MDM4NjE3ODMyMjc2ODA5MzUzNDE2OTA3NDA1Nzk4Njc2NTE1NDUyMDU1NjI2OTAxNzI0MjUwMTY4MzY1NTk2Nzg5Mzc3OTQzMTIyODc2MzkxOTM3NDU1MTc4MTEyMzQyNTcwNjIzNTY4MjY2MjIyMDc0NzU5MTgyOTMwMTUxNDA0NzI5NDI1Nzk3MTMzODg2NzE3ODIyMDIyNjIzOTY2NDI3MzU2NDAzMTU5NDg2MTI1NzI5MDg0NDQ1MDExMDg1Nzk0NTc1MjA3MTQ2MzIzNzEwNTYyODg4NzQzNTEwMTU2NjY5OTU1NDkxMzkwMDM5NDYzMTQwODU2OTYvMTMxNzY5MjE0MjQ2NTIyODY5NzgwNDI5ODE3MjM2MTUwNDA2NTQ4NTQ5MDQ0NjU4NDc0NDE2OTA5ODA2MTc5NzM0ODczMzk5MTA5NjU2NDExNjMzNDg4MDk5MjQ5MTk4ODgyMTY1Mjc5NzQ1NjI3MDM4OTg0NDg3MzY1NTg5NjI1NTYyOTAxOTE0MDMwODUwMTc4MzMwMTMzMDgwNDA5NDIwMzQwMjI3MTc5NDQ3NTQ4MDQ0NTcyNTk0MTg0NjAxNDI1NjkxODIxNjE3OTI4MTMwNDIzNDEwOTk3ODUzMzg0NDI1MzczOTk5OTY3NzU5NDk5NTcxODkwMzI2NzQwNDMzMDgxMDYzNDI0OTAzMDk4MjUyNTAyNzkxNDc3ODU0MzAyMjA0MjAwOTQxMzc2OTgzMjk1NjIyNDMwMTc3NDQ1NTA3MzE2NzA2NjA5ODAyMjkyMTIxMjgyOTU3NTE5NTcxMTYyMTU4NjIwOTcxOTUyMDg0NDg2Mzc1XCIsIFwiMTQxODExNjI1OTc0OTA5MTQyMDMwOTI3MTkxMzkwOTMzNzE0Mzc1NjU4OTMxNDU5NzU1NzEyODU1MzExNzg3MDU3MzkyODA1NTEwOTMyMjg2NDc5NDE2OTU5MjM1NTA1ODM3MDg5MTI1MTQyNTEyNTE4Nzc3MDcyNDgyODEwODk4ODU4Nzg4ODA4NzAyMzk4MjQ1MTIwNTQ3NTk4MDM3MTQ0MDQyMzk5MjgzODQ4MTU0NzIzNjYzODQ1NjcxNzUyMDgzNTY2ODg1OTA5MzQxMzk1NjMzOTI2MTgwMjMwNTU5NzY5NDQwMzM4MTAyMTg2MzI1ODc1MzQ0MTg4OTUzNjM2MTA2MTQwNzU3OTMzMjU3MDQ5MzYzNDI1NDU0MjAxMzMzNzk5OTg0NDQwNzE4MTM0NjgxNTU0OTU5NDgzNjM3NDQ5NzUxMjQ0Nzk2OTc1MTUxNDQ2NjQ4MTQ2NjcxNzU5MDI1NTM2OTgxMDUwNjgxMzU0MzU3NzczNTA4MDIyODcxODY2MDc0Nzk0MDk1NjI0ODQyNzM1Njc4NTc4NDE5OTA3MzU2OTQwOC8yNzMzNjg4ODI5ODA1MTY1NTY5MjI1MzIzMzk2NTMzMDM4MjIxMDQ1MTAyMDM5MTYwMjQ3NjAzNzE4NDQ0OTE3MDU1OTkwOTM0MzUxMzM3Mzg3NzQ5NzU1MzgzNjQyNDE2MzAwNzk0Njg3MTI5ODEwNTYzMzY2NTU3NjYxMTczNzgxNjA4MjIzOTM4NzYzNDg3NTUzNzA3MTE5NDIyNzM4NzYyODQ5NDQ0MjI2MTA5NzQxNDk3MTIyMTI5NDQyMTE1MTM0NjI5MjE2NDk4NzIyMzI2NTY0NDk5NDA5ODc1NTIyMjc1MjU1MDQ1Mjk3MTAzNzMxNDQyMjg4MTg2MDYxMjc1NDE5Mzc4MzExMDM2NDI0MTU1MzQzMTgzMDMxODczOTM1OTMyMzYyMDkyOTgyNDI1NzQ2NzcyOTMzNTI3OTg0MTk0Mjg3MTI4NzM2ODU3OTg2MzY0NzQ2NjcyMDQwODM5Mzg4NzU2NzI5MzQyMzU4MTYzOTYzNzE0NzcxNDYwODkxNjgzNzUxOTgxNDE4MDI2ODQ0MDM5NTU5MzY0MzE4ODQ3NjU2MjVcIiwgXCI1NDY0MTEwNzc1ODE4NDU5OTkyNDgyMzgwNjk2ODQxOTQ4MzE2MjE2OTExOTMzNjY0NjY5NzI4OTg2MjgxNDE1MTE0MjIzMTc5NTQ0NzcyMTE4NjUxNjc0MDIyODQyMTE5NzEyOTYyODYzNDY0OTI2OTgzNTQyMTQwNDM4NDAwODAxODE3MDI2NTIxMzI4MzU2ODEyMzkzMDI3OTgzMzk2Njc4MzU0MzkxODkyNzU0NTcxMTYwNTEyNzkzNjYxOTQ1NTE2MzI3MTI4MTkwMjgxNzc0MDIyMjE4MTUxNDAwNDUyMTA2OTA5MDg2MzE3Njc3ODY3MTE2NzUwMjkxOTQzNTk5OTg4MjYyNTIzMzI0MzQ1NzMxMjE3NDA4MzA4Mjc0MTcyOTM1NTcyMzQ4OTE0MDYwMjExMDIwODM1NTU0NzIxNTU0NzkxNDgzMzI2OTc4Mzk5NzI3MDI2MzE2NDE5MTAyMTM4MjE4Mjc4MjAzNzQ1ODY0NTkzMTkvMTA1MjQ2OTQ1ODg5Nzk5MTQwMzM4MDcyNzU0MzY1OTAxNzA1NTQ0NTMwNjYxNzgxMjk1MzYyNTYzMjE0Mjg1OTUzODgxODkwMjMzOTg3NTE2MjMwNTY4NjYzMTQzMzQyOTUyNzk5MDM2MzQxNzAxOTUyMjY3MDExMjM2NjYzMTE4MTExMjI2NjIzODE1OTc1ODQ3NDk0MzcyMDc2NDIwMTk5NDE4NzEyOTQxMDE4Mjg4NzM4NTkwMjY0NDc1NTIwMjI5NjUxMzcwMDE1Mzc3NjA4NjM4MDc1ODY2NDU5Njg0NjkyNDg4MDc5MjIzNjg2Mjk2NTQxMDIwODk3OTA0NTg4MzQ3MDgzMDQ1NzIzMTY3NzYyNjgyOTU5NDIyODU4OTk2NjczODk0MTgwODA1NzAyMjk5OTA3NDc4Njg1Mzc0MDY1NTkzMTYxMjI2ODQ5NDQ3MTMxMTAwNDYyMDIyMDg5NzgzMjY1MzQ2NTk3NTUzMTc2NTc2MDAwXCIsIFwiMjM5ODMzMDY0MDk1ODg0MTQ3NDc3MjYwNjQzOTkxNjA3MDA1MDk3NzU0NDUzNTU4MDYwNTczNzM4Mzk5NTE2MDQ0NzEwNTczNjI3Njk1MDE5Njg4NTkwNjQwODMxNzYyODA4MzExMDkyMzMyMjE1NzExMzg5MjkyODk2MzIzNzg0NTkxNDAxNzg0NTQ0NDI5NTA0MDkyNDEwMTc4NDQyMzM4MjY4MTgwMTc1NDE5MTMwMTg2MDM4MzkyNzEyOTAwNjk1MzM1NDczOTI0MDkyNjY0MzU2Mjk4NzgzODgzNjk5NzQ1Mzk4NTg1NTU3NjQwMjYyODE2Njg3NTg2OTA0MTAzMjYzMTY1MTU5MTg3MTk2Mjg1Mjg4NDE4OTU0ODUzODI3MjI4NTM4NzA5Mjg0MzA0NDY2OTQ5OTY4ODAzNTEzNDE4MTg1OTM3NjY2NTQwOTc2Nzg4NjE4ODMwNDMxNDg4ODc1Mzg5NDkwNTMxNzkyOTg3NzIzODMyMjYxNTgzODUyNDM1NDE5MTI2MzUwMjM0Nzg4MTAzMzg1NTQ0MTE4MTQyMDM5OTM2MC80NjE1ODgwNzA4Njg1OTAxMjI4OTIyNjU2ODE4Nzk3MzQyOTUwMDcwMjkxMzA5NjU2MjYwNjA1NTI3ODM3NjAwNjg4OTcwMDAxOTUyMDc4NzgyMjc3MTQ4NDI2MTc0NzAzMjAyMzE1MjcyMjIwNzQ3MDE0NDQzNDk1MzA5NTI2OTk3MDg0MzU2NjgzMzk3MTI4NjA0NjQ1MzM0NTUzNDU2NjUwNjg4NDEzMzMyMzIzNTk2OTg0NDkwODg0OTcxMzcwNjg3MTMzMDk4MTE5NDI5Njg0MzM4Njg2MDkzMjkzMDEwODIwMDE3NTI2MTc0MjAwMDIzNzc4OTI3NTY4MjE1MzIyMjA2NzYwODUwMTQ4NzQxMTIwODM2MTUwNTQ1NTAyNzg5MDM5NjA2MjcxODU2NzU0NTkwMTUzNDM2MDYzOTEwOTQ1MjM1MTExMTc3MDU3NDc4NDI2NDU5MjczNDkxMzAzMDI1NDk1NTQ1MzQwNTYyNjkzMzE4MDkwMTY3NzA3MTU4MTk5MzQ5NzAyMDA0ODMxNjE1NDg1Mjc5MzI2MTcwMzYxODUyNTNcIiwgXCI2MDQxMDE1ODc5NDI0NzI1MzgzMDA2NDI0NTM2MTMwNDA5MjA5NjA3ODU0MDQ0NjQyMTEzNzQ3MjY2MDk4MTk4Nzc3MDExOTgxMzI4NzY1NTI4MzYxNjMwNTE2MTA4NjgwMzkyNTAwOTkwNTgwOTA4NTA5NDAzNDgzODkxNzYzMjE5NjU5NzI2MDkwNjc1MTQwNjcyOTg5NjU3NzQzODgyMTgzOTUxOTU0Mjk0NzQ1Mzk2NDE3ODI5OTQzNDY5MjAxMzA2NTk0MDE4NDU0OTk1ODYyMzIxODIxMDE2MDg3NDE2ODQwMjQ3NDIyMzUwOTA2NDEyMDA3MzM2MTAzMDg2NjIwMzk2NDY3NDU2MTgxNzcxNTgzMjAwMzY1NzQwMjUzMzg5MTA3OTY4MTIyODUwMDYzNjA3MDg1OTU3MTA5OTY1NDA2NjM0NzM4NzQwOTk2MzE4NDE1NTE0MzYwOTU2MDI4NTc1NTYwOTc5MjAzNDQ3NzM1MTIxNDM2LzExNjE3NTI3OTkxMDk0Mjg0MjIyODgwMjA5NDcwNjEyODE1NDA5ODk3MDg5Mzc0NTA1NjgxMDA3NjQ4MzAyNTE5MDg4NTA1OTY3MTc2MDY3MDEwNDc0MTM0MDc2MzY5MDc5MzQzMjA3ODk4NzAxNzU5MDc3OTIwMTc1MTM4OTY5OTkyMDg4OTIyODIxMzcyOTkwNzA3NjE0NjcwOTYyMTE4MTQ1ODY5MDk1OTg3MDU2MTUzMTI4MTk1OTY0OTU2MzYwMTc3MjgzMTM1MTM1MjAxOTM3ODYyNjY0NTI4MzY4MDUyOTE0NjQ4MjYyMjY4MzM1OTM4Nzg1MDQ4MDQzODk3Mjg0NzcxOTExNzAwMjc3Mjk5NjM3NzM3MTYyNjc4NjgyODQ0Nzk3NjgzOTc2MDM0NDQ5MTkwMDg5MTUyNzk1MjIzNzYwMDQzMjYzOTg0MDM4NTE2ODQ3NjE4MDg3ODUzODE2MDkzNzA3NjcxNjk1MjEwMzQzODM2MjVcIiwgXCIxMzI0MDA3NzQzNjQ0Mzk4ODc0OTE3OTUwODQ2MjI2NzI2NzE4NzE2OTQ0MTk0ODcyMjM1ODE2NTA5MDU1NDc2OTI1MDUwNTcxMzc0NzkzNDY0MzIwMDgwNDgxOTQxODY3MDE0NzIyNTY5NTMyNDQzMjY4NDI2NjkyNDY5NDUyNDMzNzkyMDgxNjQ1MjM0NjU5OTc3NDQ1MjY4MTgzMTMyMDAwNTI4NjMyNjk4NjY3NTkwNzg5OTYwODUzNzk3MjM4NDkyNDg4Mjk5Njc1NzUwMzI2NDYyMjk5MTM1NTk0OTAzOTg4MjUyNjM4OTM0MjE3NDMwNzE2ODgwNTE2NjIxNTgzODEzODI3NzU1NzA1MjMwMzQzMDQ5MjY2OTE5MzkzOTIxMjM2MjYzODI2MzU4Mjg5OTcxMzE5ODcxNjU0MTcyMzM4MzEzODAxNjU2NDAyNzc2NjU2MDIxNTk0NDQwOTM1MzQyNzE3NjEzNTg5NTk4MjU5NjMyNzY4NTY2NTg0NDgxNTYxODQwMjg4MTIwMjY0NTYxMDYyMDI4NDc5Mjc5MzQyMDc4MDUxNzI0OC8yNTQ0MjIzMDg0NDY4MTU4MjkxODgzNjk4ODEzMzA5NTQxODAxNDU1MzExNDY4OTgyMjMyNTQ2ODcyNDg1NDQ0MzA4MjExNDE1NTI5OTk4NDcyNzg3Mzc3ODAwNTU5ODg0MjEwODM3MjEzMDQyOTMyMTgwNDc5MDkwMjc3Mjg1NjMwMjM0MjM4NzExODUxNDgwMjMyNTIwMTM3ODU2ODQ4ODA5OTg2NjMxNzg0ODQzNTI4MzgxNzc4NTIwNzI3NDY1MTQ2NjYxNzkyNzk3OTI0NDU4NTQwOTU3MTMzNDIzNjY1NzQ2MjI5Nzk5Njc1NjUwMjkwMjk2MjE3NjU4NDQ0ODk5NjA1MjM2NTUwOTcyMDQzNTQ5Mjc4MTI4MDg3NjQ1MjExOTA5NDc5MDA5MDk5NzY2NjE5MzU1Njc3OTg0MjE4OTI5NjcyNDYxNTA2NjkxOTgwNDQyMDcxODYwNTkxNzY3MjY2OTEzMDQxMTQ3NTg3ODE1NDUyMDA3NzI2NTEzODUzODIwMTE2NjI5NDgyNzMyMDYwNTkzMTE2NjI0NTk2MzY4ODA2NTY2NjI1XCIsIFwiMTk1Mzk5OTE2NjI5Njk1NTgzMDkzNTQ5NTE1ODczNTM1OTIwMDM2MjkwNDE4MTc5Mjk0Nzc5NDUyOTMzOTQ4NzQ4OTczMDA0MjU2ODMwNTk5NzA5OTk1OTMwMjMyMjk1Njg5ODI5OTYxNjE5NDkzMjI4MzA2MDU1NDI2MTU2NjQxMDk4ODYxODA0NTEwNzM5ODA5MjM0NTQ3NjUzMjM3MTQwMjEzNDIwNjYzNTIzNTU3MDI4MTczODM3NzE4ODQzODQwNzcwMzA4OTMyNTMxNTQ0NjM3MTEyNzA0MjUzNzU3NjA5MzUzNjg5NjI4Mjk1NTUyNDg0MjYzMjcwODY0NTY1NTQ4MTAyODE2MTQ3MTMxMzYwODk3NDIzODExMDcxODI0MjI3MzkzNTk1Njk3NzU1NTYxMDE0NzcxNDMxNjE1ODQ4NjU1MzYzMzg3MTMxMjE4NzA4NDYxODE1NDAxNDkyMTE5MDU5NTIyMjc5OTI4Mzk1NzE0MDM1My8zNzUxOTExNjUwODQ4ODI1MjEwMzcwNDYwMTQ1NjkxODUxNjU4ODU0NTkwODI2MjkxMzYxMjQxNzcyODY1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIl07XHJcbiAgICAgICAgICAgIGlmKENBQ0hFW3hdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRnJhYy5xdWljay5hcHBseShudWxsLCBDQUNIRVt4XS5zcGxpdCgnLycpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4ID0gbmV3IEZyYWMoeCk7XHJcbiAgICAgICAgICAgIHZhciBuID0gODA7XHJcbiAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgRnJhYygwKTtcclxuICAgICAgICAgICAgdmFyIGEgPSB4LnN1YnRyYWN0KG5ldyBGcmFjKDEpKTtcclxuICAgICAgICAgICAgdmFyIGIgPSB4LmFkZChuZXcgRnJhYygxKSk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IEZyYWMoMiAqIGkgKyAxKTtcclxuICAgICAgICAgICAgICAgIHZhciBrID0gTWF0aDIuYmlncG93KGEuZGl2aWRlKGIpLCB0KTtcclxuICAgICAgICAgICAgICAgIHZhciByID0gdC5jbG9uZSgpLmludmVydCgpLm11bHRpcGx5KGspO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gcmV0dmFsLmFkZChyKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbC5tdWx0aXBseShuZXcgRnJhYygyKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL3RoZSBmYWN0b3JpYWwgZnVuY3Rpb24gYnV0IHVzaW5nIHRoZSBiaWcgbGlicmFyeSBpbnN0ZWFkXHJcbiAgICAgICAgZmFjdG9yaWFsOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgaXNfaW50ID0geCAlIDEgPT09IDA7XHJcblxyXG4gICAgICAgICAgICAvKmZhY3RvcmlhbCBmb3IgbmVnYXRpdmUgaW50ZWdlcnMgaXMgY29tcGxleCBpbmZpbml0eSBhY2NvcmRpbmcgdG8gV29sZnJhbSBBbHBoYSovXHJcbiAgICAgICAgICAgIGlmKGlzX2ludCAmJiB4IDwgMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XHJcblxyXG4gICAgICAgICAgICBpZighaXNfaW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgyLmdhbW1hKHggKyAxKTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXR2YWwgPSAxO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAyOyBpIDw9IHg7IGkrKylcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbCAqIGk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2RvdWJsZSBmYWN0b3JpYWxcclxuICAgICAgICAvL2h0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vRG91YmxlRmFjdG9yaWFsLmh0bWxcclxuICAgICAgICBkZmFjdG9yaWFsOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZihpc0ludCh4KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW4gPSB4ICUgMiA9PT0gMDtcclxuICAgICAgICAgICAgICAgIC8qIElmIHggPSBldmVuIHRoZW4gbiA9IHgvMiBlbHNlIG4gPSAoeC0xKS8yKi9cclxuICAgICAgICAgICAgICAgIHZhciBuID0gZXZlbiA/IHggLyAyIDogKHggKyAxKSAvIDI7XHJcbiAgICAgICAgICAgICAgICAvKnRoZSByZXR1cm4gdmFsdWUqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgRnJhYygxKTtcclxuICAgICAgICAgICAgICAgIC8qc3RhcnQgdGhlIGxvb3AqL1xyXG4gICAgICAgICAgICAgICAgaWYoZXZlbilcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDw9IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHIubXVsdGlwbHkobmV3IEZyYWMoMikubXVsdGlwbHkobmV3IEZyYWMoaSkpKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDw9IG47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IHIubXVsdGlwbHkobmV3IEZyYWMoMikubXVsdGlwbHkobmV3IEZyYWMoaSkpLnN1YnRyYWN0KG5ldyBGcmFjKDEpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvKk5vdCB5ZXQgZXh0ZW5kZWQgdG8gYmlnTnVtKi9cclxuICAgICAgICAgICAgICAgIHIgPSBNYXRoLnBvdygyLCAoMSArIDIgKiB4IC0gTWF0aC5jb3MoTWF0aC5QSSAqIHgpKSAvIDQpICogTWF0aC5wb3coTWF0aC5QSSwgKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gNCkgKiBNYXRoMi5nYW1tYSgxICsgeCAvIDIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKmRvbmUqL1xyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIEdDRDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFycmF5VW5pcXVlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKS5zb3J0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IE1hdGguYWJzKGFyZ3Muc2hpZnQoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IGFyZ3MubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUobi0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBNYXRoLmFicyhhcmdzLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgJT0gYjtcclxuICAgICAgICAgICAgICAgICAgICBpZihhID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYiAlPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGIgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFFHQ0Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHZhciBhID0gYXJnc1swXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYXJnc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gYS5pc05lZ2F0aXZlKCkgJiYgYi5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICBhID0gYi5nY2QoYSk7XHJcbiAgICAgICAgICAgICAgICBpZihzaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBhLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgTENNOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gKGEgKiBiKSAvIE1hdGgyLkdDRChhLCBiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vcG93IGJ1dCB3aXRoIHRoZSBoYW5kbGluZyBvZiBuZWdhdGl2ZSBudW1iZXJzXHJcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyODEwNzY1L2NhbGN1bGF0aW5nLWN1YmljLXJvb3QtZm9yLW5lZ2F0aXZlLW51bWJlclxyXG4gICAgICAgIHBvdzogZnVuY3Rpb24gKGIsIGUpIHtcclxuICAgICAgICAgICAgaWYoYiA8IDApIHtcclxuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGUpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qbnRoIHJvb3Qgb2YgYSBuZWdhdGl2ZSBudW1iZXIgaXMgaW1hZ2luYXJ5IHdoZW4gbiBpcyBldmVuKi9cclxuICAgICAgICAgICAgICAgICAgICBpZigxIC8gZSAlIDIgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1NYXRoLnBvdyhNYXRoLmFicyhiKSwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KGIsIGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmFjdG9yOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICBuID0gTnVtYmVyKG4pO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbihuKTsgLypzdG9yZSB0aGUgc2lnbiovXHJcbiAgICAgICAgICAgIC8qbW92ZSB0aGUgbnVtYmVyIHRvIGFic29sdXRlIHZhbHVlKi9cclxuICAgICAgICAgICAgbiA9IE1hdGguYWJzKG4pO1xyXG4gICAgICAgICAgICB2YXIgaWZhY3RvcnMgPSBNYXRoMi5pZmFjdG9yKG4pO1xyXG4gICAgICAgICAgICB2YXIgZmFjdG9ycyA9IG5ldyBTeW1ib2woKTtcclxuICAgICAgICAgICAgZmFjdG9ycy5zeW1ib2xzID0ge307XHJcbiAgICAgICAgICAgIGZhY3RvcnMuZ3JvdXAgPSBDQjtcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIGlmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIGZhY3Rvci5ncm91cCA9IFA7IC8qY2hlYXQgYSBsaXR0bGUqL1xyXG4gICAgICAgICAgICAgICAgZmFjdG9yLnZhbHVlID0geDtcclxuICAgICAgICAgICAgICAgIGZhY3Rvci5wb3dlciA9IG5ldyBTeW1ib2woaWZhY3RvcnNbeF0pO1xyXG4gICAgICAgICAgICAgICAgZmFjdG9ycy5zeW1ib2xzW3hdID0gZmFjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZhY3RvcnMudXBkYXRlSGFzaCgpO1xyXG5cclxuICAgICAgICAgICAgaWYobiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZmFjdG9ycyA9IG5ldyBTeW1ib2wobik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qcHV0IGJhY2sgdGhlIHNpZ24qL1xyXG4gICAgICAgICAgICBpZihzaWduIDwgMClcclxuICAgICAgICAgICAgICAgIGZhY3RvcnMubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9ycztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZXMgdHJpYWwgZGl2aXNpb25cclxuICAgICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG4gLSB0aGUgbnVtYmVyIGJlaW5nIGZhY3RvcmVkXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZhY3RvcnMgLSAgdGhlIGZhY3RvcnMgb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZmFjdG9yOiBmdW5jdGlvbiAobiwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICBmYWN0b3JzID0gZmFjdG9ycyB8fCB7fTtcclxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKE1hdGguc3FydChuKSk7XHJcbiAgICAgICAgICAgIHZhciBsY3ByaW1lID0gUFJJTUVTW1BSSU1FUy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgLyphIG9uZS10aW1lIGNvc3QuLi4gSG9wZWZ1bGx5IC4uLiBBbmQgZG9uJ3QgYm90aGVyIGZvciBtb3JlIHRoYW4gYSBtaWxsaW9uKi9cclxuICAgICAgICAgICAgLyp0YWtlcyB0b28gbG9uZyovXHJcbiAgICAgICAgICAgIGlmKHIgPiBsY3ByaW1lICYmIG4gPCAxZTYpXHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZVByaW1lcyhyKTtcclxuICAgICAgICAgICAgdmFyIGwgPSBQUklNRVMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJpbWUgPSBQUklNRVNbaV07XHJcbiAgICAgICAgICAgICAgICAvKnRyaWFsIGRpdmlzaW9uKi9cclxuICAgICAgICAgICAgICAgIHdoaWxlKG4gJSBwcmltZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuIC8gcHJpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yc1twcmltZV0gPSAoZmFjdG9yc1twcmltZV0gfHwgMCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG4gPiAxKVxyXG4gICAgICAgICAgICAgICAgZmFjdG9yc1tuXSA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3JzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUG9sbGFyZCdzIHJob1xyXG4gICAgICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWZhY3RvcjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0ID0gbmV3IGJpZ0ludChuKTtcclxuXHJcbiAgICAgICAgICAgIG4gPSBTdHJpbmcobik7XHJcblxyXG4gICAgICAgICAgICBpZihuID09PSAnMCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geycwJzogMX07XHJcbiAgICAgICAgICAgIG4gPSBuZXcgYmlnSW50KG4pOyAvKmNvbnZlcnQgdG8gYmlnSW50IGZvciBzYWZldHkqL1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IG4uc2lnbiA/IC0xIDogMTtcclxuICAgICAgICAgICAgbiA9IG4uYWJzKCk7XHJcbiAgICAgICAgICAgIHZhciBmYWN0b3JzID0ge307IC8qZmFjdG9yIG9iamVjdCBiZWluZyByZXR1cm5lZC4qL1xyXG4gICAgICAgICAgICBpZihuLmx0KCc2NTUzNicpKSB7IC8qbGVzcyB0aGFuIDJeMTYganVzdCB1c2UgdHJpYWwgZGl2aXNpb24qL1xyXG4gICAgICAgICAgICAgICAgZmFjdG9ycyA9IE1hdGgyLnNmYWN0b3IobiwgZmFjdG9ycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRkID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZighZS5pc1ByaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycyA9IE1hdGgyLnNmYWN0b3IoZSwgZmFjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yc1tlXSA9IChmYWN0b3JzW2VdIHx8IDApICsgMTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvL3NldCBhIHNhZmV0eVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAxZTM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmV0eSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKCFuLmFicygpLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuLmlzUHJpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByaG8oYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ZiA9IG5ldyBiaWdJbnQoYyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeiA9IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gbmV3IGJpZ0ludChjKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvciA9IG5ldyBiaWdJbnQoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGZhY3Rvci5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8PSBjeiAmJiBmYWN0b3IuZXF1YWxzKDEpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJpZ2dlciB0aGUgc2FmZXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzYWZldHkrKyA+IG1heClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3BwaW5nJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHgucG93KDIpLmFkZCgxKS5tb2Qobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IgPSBiaWdJbnQuZ2NkKHgubWludXMoeGYpLmFicygpLCBuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ogPSBjeiAqIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhmID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmFjdG9yLmVxdWFscyhuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmhvKGMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSByaG8oMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQoZmFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qZGl2aWRlIG91dCB0aGUgZmFjdG9yKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuLmRpdmlkZShmYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzZXQgZmFjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBhZGQoaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLypwdXQgdGhlIHNpZ24gYmFjayovXHJcbiAgICAgICAgICAgIGlmKHNpZ24gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc20gPSBhcnJheU1pbihrZXlzKGZhY3RvcnMpKTsgLyovZ2V0IHRoZSBzbWFsbGVzdCBudW1iZXIqL1xyXG4gICAgICAgICAgICAgICAgZmFjdG9yc1snLScgKyBzbV0gPSBmYWN0b3JzW3NtXTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmYWN0b3JzW3NtXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2ZhY3RvcnMgYSBudW1iZXIgaW50byByZWN0YW5ndWxhciBib3guIElmIHNpZGVzIGFyZSBwcmltZXMgdGhhdCB0aGlzIHdpbGwgYmVcclxuICAgICAgICAvL3RoZWlyIHByaW1lIGZhY3RvcnMuIGUuZy4gMjEgLT4gKDcpKDMpLCAxMzMgLT4gKDcpKDE5KVxyXG4gICAgICAgIGJveGZhY3RvcjogZnVuY3Rpb24gKG4sIG1heCkge1xyXG4gICAgICAgICAgICBtYXggPSBtYXggfHwgMjAwOyAvL3N0b3AgYWZ0ZXIgdGhpcyBudW1iZXIgb2YgaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICB2YXIgYywgcixcclxuICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5mbG9vcigoNSAvIDEyKSAqIG4pLCAvL3RoZSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsIC8vbnVtYmVyIG9mIGl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBzYWZldHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgYyA9IE1hdGguZmxvb3IobiAvIGQpO1xyXG4gICAgICAgICAgICAgICAgciA9IG4gJSBkO1xyXG4gICAgICAgICAgICAgICAgaWYociA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy93ZSdyZSBkb25lXHJcbiAgICAgICAgICAgICAgICBpZihzYWZldHkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuLCAxXTtcclxuICAgICAgICAgICAgICAgIGQgPSBNYXRoLm1heChyLCBkIC0gcik7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICBzYWZldHkgPSBpID4gbWF4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbYywgZCwgaV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaWI6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKG4pO1xyXG4gICAgICAgICAgICBuID0gTWF0aC5hYnMobik7XHJcbiAgICAgICAgICAgIHNpZ24gPSBldmVuKG4pID8gc2lnbiA6IE1hdGguYWJzKHNpZ24pO1xyXG4gICAgICAgICAgICB2YXIgYSA9IDAsIGIgPSAxLCBmID0gMTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMjsgaSA8PSBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGYgPSBhICsgYjtcclxuICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgYiA9IGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGYgKiBzaWduO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW9kOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgICAgICAgICByZXR1cm4geCAlIHk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2h0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vSW50ZWdlclBhcnQuaHRtbFxyXG4gICAgICAgIGludGVnZXJfcGFydDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24oeCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaWduICogTWF0aC5mbG9vcihNYXRoLmFicyh4KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW1wc29uOiBmdW5jdGlvbiAoZiwgYSwgYiwgc3RlcCkge1xyXG4gICAgICAgICAgICB2YXIgZ2V0X3ZhbHVlID0gZnVuY3Rpb24gKGYsIHgsIHNpZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2ID0gZih4KTtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gMC4wMDAwMDAwMDAwMDE7XHJcbiAgICAgICAgICAgICAgICBpZihpc05hTih2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBmKHNpZGUgPT09IDEgPyB4ICsgZCA6IHggLSBkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgfHwgMC4wMDAxO1xyXG4gICAgICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGludGVydmFsc1xyXG4gICAgICAgICAgICB2YXIgbiA9IE1hdGguYWJzKE1hdGguZmxvb3IoKGIgLSBhKSAvIHN0ZXApKTtcclxuICAgICAgICAgICAgLy9zaW1wc29uJ3MgcnVsZSByZXF1aXJlcyBhbiBldmVuIG51bWJlciBvZiBpbnRlcnZhbHMuIElmIGl0J3Mgbm90IHRoZW4gYWRkIDFcclxuICAgICAgICAgICAgaWYobiAlIDIgIT09IDApXHJcbiAgICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgIC8vZ2V0IHRoZSBpbnRlcnZhbCBzaXplXHJcbiAgICAgICAgICAgIHZhciBkeCA9IChiIC0gYSkgLyBuO1xyXG4gICAgICAgICAgICAvL2dldCB4MFxyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gZ2V0X3ZhbHVlKGYsIGEsIDEpO1xyXG5cclxuICAgICAgICAgICAgLy9nZXQgdGhlIG1pZGRsZSBwYXJ0IDR4MSsyeDIrNHgzIC4uLlxyXG4gICAgICAgICAgICAvL2J1dCBmaXJzdCBzZXQgYSBmbGFnIHRvIHNlZSBpZiBpdCdzIGV2ZW4gb3Igb2RkLlxyXG4gICAgICAgICAgICAvL1RoZSBmaXJzdCBvbmUgaXMgb2RkIHNvIHdlIHN0YXJ0IHRoZXJlXHJcbiAgICAgICAgICAgIHZhciBldmVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vZ2V0IHgxXHJcbiAgICAgICAgICAgIHZhciB4aSA9IGEgKyBkeDtcclxuICAgICAgICAgICAgLy90aGUgY29lZmZpY2llbnRcclxuICAgICAgICAgICAgdmFyIGMsIGs7XHJcbiAgICAgICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2ltcHNvbiUyN3NfcnVsZVxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gZXZlbiA/IDIgOiA0O1xyXG4gICAgICAgICAgICAgICAgayA9IGMgKiBnZXRfdmFsdWUoZiwgeGksIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsICs9IGs7XHJcbiAgICAgICAgICAgICAgICAvL2ZsaXAgdGhlIGV2ZW4gZmxhZ1xyXG4gICAgICAgICAgICAgICAgZXZlbiA9ICFldmVuO1xyXG4gICAgICAgICAgICAgICAgLy9pbmNyZW1lbnQgeGlcclxuICAgICAgICAgICAgICAgIHhpICs9IGR4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2FkZCB4blxyXG4gICAgICAgICAgICByZXR1cm4gKHJldHZhbCArIGdldF92YWx1ZShmLCB4aSwgMikpICogKGR4IC8gMyk7XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NjaWpzL2ludGVncmF0ZS1hZGFwdGl2ZS1zaW1wc29uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiAtIHRoZSBmdW5jdGlvbiBiZWluZyBpbnRlZ3JhdGVkXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBsb3dlciBib3VuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIC0gdXBwZXIgYm91bmRcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9sIC0gc3RlcCB3aWR0aFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhkZXB0aFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbnVtX2ludGVncmF0ZTogZnVuY3Rpb24gKGYsIGEsIGIsIHRvbCwgbWF4ZGVwdGgpIHtcclxuICAgICAgICAgICAgaWYobWF4ZGVwdGggPCAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXggZGVwdGggY2Fubm90IGJlIG5lZ2F0aXZlJyk7XHJcblxyXG4gICAgICAgICAgICAvKiBUaGlzIGFsZ29yaXRobSBhZGFwdGVkIGZyb20gcHNldWRvY29kZSBpbjoqL1xyXG4gICAgICAgICAgICAvKiBodHRwOi8vd3d3Lm1hdGgudXRrLmVkdS9+Y2NvbGxpbnMvcmVmcy9IYW5kb3V0cy9yaWNoLnBkZiovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkc2ltcChmLCBhLCBiLCBmYSwgZm0sIGZiLCBWMCwgdG9sLCBtYXhkZXB0aCwgZGVwdGgsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzdGF0ZS5uYW5FbmNvdW50ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaCwgZjEsIGYyLCBzbCwgc3IsIHMyLCBtLCBWMSwgVjIsIGVycjtcclxuICAgICAgICAgICAgICAgIGggPSBiIC0gYTtcclxuICAgICAgICAgICAgICAgIGYxID0gZihhICsgaCAqIDAuMjUpO1xyXG4gICAgICAgICAgICAgICAgZjIgPSBmKGIgLSBoICogMC4yNSk7XHJcbiAgICAgICAgICAgICAgICAvKiBTaW1wbGUgY2hlY2sgZm9yIE5hTjoqL1xyXG4gICAgICAgICAgICAgICAgaWYoaXNOYU4oZjEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubmFuRW5jb3VudGVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qIFNpbXBsZSBjaGVjayBmb3IgTmFOOiovXHJcbiAgICAgICAgICAgICAgICBpZihpc05hTihmMikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5uYW5FbmNvdW50ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNsID0gaCAqIChmYSArIDQgKiBmMSArIGZtKSAvIDEyO1xyXG4gICAgICAgICAgICAgICAgc3IgPSBoICogKGZtICsgNCAqIGYyICsgZmIpIC8gMTI7XHJcbiAgICAgICAgICAgICAgICBzMiA9IHNsICsgc3I7XHJcbiAgICAgICAgICAgICAgICBlcnIgPSAoczIgLSBWMCkgLyAxNTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzdGF0ZS5tYXhEZXB0aENvdW50ID4gMTAwMCAqIG1heGRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZihkZXB0aCA+IG1heGRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubWF4RGVwdGhDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzMiArIGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoTWF0aC5hYnMoZXJyKSA8IHRvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzMiArIGVycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBhICsgaCAqIDAuNTtcclxuICAgICAgICAgICAgICAgICAgICBWMSA9IGFkc2ltcChmLCBhLCBtLCBmYSwgZjEsIGZtLCBzbCwgdG9sICogMC41LCBtYXhkZXB0aCwgZGVwdGggKyAxLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNOYU4oVjEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm5hbkVuY291bnRlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgVjIgPSBhZHNpbXAoZiwgbSwgYiwgZm0sIGYyLCBmYiwgc3IsIHRvbCAqIDAuNSwgbWF4ZGVwdGgsIGRlcHRoICsgMSwgc3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihpc05hTihWMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubmFuRW5jb3VudGVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFYxICsgVjI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGludGVncmF0ZShmLCBhLCBiLCB0b2wsIG1heGRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4RGVwdGhDb3VudDogMCxcclxuICAgICAgICAgICAgICAgICAgICBuYW5FbmNvdW50ZXJlZDogZmFsc2VcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodG9sID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b2wgPSAxZS05O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYobWF4ZGVwdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qSXNzdWUgIzQ1OCAtIFRoaXMgd2FzIGxvd2VyZWQgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSBpc3N1ZXMuICovXHJcbiAgICAgICAgICAgICAgICAgICAgLypUaGlzIHdhcyBzdXNwZWN0ZWQgZnJvbSBiZWZvcmUgYnV0IGlzIG5vdyBjb25maXJtZWQgd2l0aCB0aGlzIGlzc3VlKi9cclxuICAgICAgICAgICAgICAgICAgICBtYXhkZXB0aCA9IDQ1O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmYSA9IGYoYSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm0gPSBmKDAuNSAqIChhICsgYikpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZiID0gZihiKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgVjAgPSAoZmEgKyA0ICogZm0gKyBmYikgKiAoYiAtIGEpIC8gNjtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYWRzaW1wKGYsIGEsIGIsIGZhLCBmbSwgZmIsIFYwLCB0b2wsIG1heGRlcHRoLCAxLCBzdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3RhdGUubWF4RGVwdGhDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuKCdpbnRlZ3JhdGUtYWRhcHRpdmUtc2ltcHNvbjogV2FybmluZzogbWF4aW11bSByZWN1cnNpb24gZGVwdGggKCcgKyBtYXhkZXB0aCArICcpIHJlYWNoZWQgJyArIHN0YXRlLm1heERlcHRoQ291bnQgKyAnIHRpbWVzJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3RhdGUubmFuRW5jb3VudGVyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGRvZXMgbm90IGNvbnZlcmdlIG92ZXIgaW50ZXJ2YWwhJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG5cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IGludGVncmF0ZShmLCBhLCBiLCB0b2wsIG1heGRlcHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAvKmZhbGxiYWNrIHRvIG5vbi1hZGFwdGl2ZSovXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aDIuc2ltcHNvbihmLCBhLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnJvdW5kKHJldHZhbCwgMTIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ucmlnb25vbWV0cmljX2ludGVncmFsXHJcbiAgICAgICAgLy9Db3NpbmVJbnRlZ3JhbFxyXG4gICAgICAgIENpOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IDIwLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qcm91Z2hseSBFdWxlcuKAk01hc2NoZXJvbmkqL1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSAwLjU3NzIxNTY2NDkwMTUzMjksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLypjYWNoZSAybiovXHJcbiAgICAgICAgICAgICAgICB2YXIgbjIgPSAyICogaTtcclxuICAgICAgICAgICAgICAgIHN1bSArPSAoTWF0aC5wb3coLTEsIGkpICogTWF0aC5wb3coeCwgbjIpKSAvIChuMiAqIE1hdGgyLmZhY3RvcmlhbChuMikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSArIGcgKyBzdW07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlNpbmVJbnRlZ3JhbCovXHJcbiAgICAgICAgU2k6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gMjAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG4yID0gMiAqIGk7XHJcbiAgICAgICAgICAgICAgICBzdW0gKz0gKE1hdGgucG93KC0xLCBpKSAqIE1hdGgucG93KHgsIG4yICsgMSkpIC8gKChuMiArIDEpICogTWF0aDIuZmFjdG9yaWFsKG4yICsgMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKkV4cG9uZW50aWFsSW50ZWdyYWwqL1xyXG4gICAgICAgIEVpOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZihOdW1iZXIoeCkgPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xyXG4gICAgICAgICAgICB2YXIgbiA9IDMwLFxyXG4gICAgICAgICAgICAgICAgICAgIGcgPSAwLjU3NzIxNTY2NDkwMTUzMjg2MDYsIC8qcm91Z2hseSBFdWxlcuKAk01hc2NoZXJvbmkqL1xyXG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyh4LCBpKSAvIChpICogTWF0aDIuZmFjdG9yaWFsKGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZyArIE1hdGguYWJzKE1hdGgubG9nKHgpKSArIHN1bTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qSHlwZXJib2xpYyBTaW5lIEludGVncmFsKi9cclxuICAgICAgICAvKmh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vU2hpLmh0bWwqL1xyXG4gICAgICAgIFNoaTogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSAzMCxcclxuICAgICAgICAgICAgICAgICAgICBzdW0gPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGssIHQ7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGsgPSAyICogaTtcclxuICAgICAgICAgICAgICAgIHQgPSBrICsgMTtcclxuICAgICAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyh4LCB0KSAvICh0ICogdCAqIE1hdGgyLmZhY3RvcmlhbChrKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qdGhlIGNvc2luZSBpbnRlZ3JhbCBmdW5jdGlvbiovXHJcbiAgICAgICAgQ2hpOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgZHgsIGcsIGY7XHJcbiAgICAgICAgICAgIGR4ID0gMC4wMDE7XHJcbiAgICAgICAgICAgIGcgPSAwLjU3NzIxNTY2NDkwMTUzMjg2MDY7XHJcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChNYXRoLmNvc2godCkgLSAxKSAvIHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSArIGcgKyBNYXRoMi5udW1faW50ZWdyYXRlKGYsIDAuMDAyLCB4LCBkeCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKnRoZSBsb2cgaW50ZWdyYWwqL1xyXG4gICAgICAgIExpOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aDIuRWkoTWF0aDIuYmlnTG9nKHgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qdGhlIGdhbW1hIGluY29tcGxldGUgZnVuY3Rpb24qL1xyXG4gICAgICAgIGdhbW1hX2luY29tcGxldGU6IGZ1bmN0aW9uIChuLCB4KSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gbiAtIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMCxcclxuICAgICAgICAgICAgICAgICAgICB4ID0geCB8fCAwO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gKz0gTWF0aC5wb3coeCwgaSkgLyBNYXRoMi5mYWN0b3JpYWwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgyLmZhY3RvcmlhbCh0KSAqIE1hdGguZXhwKC14KSAqIHN1bTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogSGVhdmlzaWRlIHN0ZXAgZnVuY3Rpb24gLSBNb3ZlZCBmcm9tIFNwZWNpYWwuanMgKG9yaWdpbmFsbHkgY29udHJpYnV0ZWQgYnkgQnJvc25hbiBZdWVuKVxyXG4gICAgICAgICAqIFNwZWNpZmljYXRpb24gOiBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0hlYXZpc2lkZVN0ZXBGdW5jdGlvbi5odG1sXHJcbiAgICAgICAgICogaWYgeCA+IDAgdGhlbiAxXHJcbiAgICAgICAgICogaWYgeCA9PSAwIHRoZW4gMS8yXHJcbiAgICAgICAgICogaWYgeCA8IDAgdGhlbiAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RlcDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYoeCA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgaWYoeCA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmVjdGFuZ2xlIGZ1bmN0aW9uIC0gTW92ZWQgZnJvbSBTcGVjaWFsLmpzIChvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5IEJyb3NuYW4gWXVlbilcclxuICAgICAgICAgKiBTcGVjaWZpY2F0aW9uIDogaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9SZWN0YW5nbGVGdW5jdGlvbi5odG1sXHJcbiAgICAgICAgICogaWYgfHh8ID4gMS8yIHRoZW4gMFxyXG4gICAgICAgICAqIGlmIHx4fCA9PSAxLzIgdGhlbiAxLzJcclxuICAgICAgICAgKiBpZiB8eHwgPCAxLzIgdGhlbiAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVjdDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBNYXRoLmFicyh4KTtcclxuICAgICAgICAgICAgaWYoeCA9PT0gMC41KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgIGlmKHggPiAwLjUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFNpbmMgZnVuY3Rpb24gLSBNb3ZlZCBmcm9tIFNwZWNpYWwuanMgKG9yaWdpbmFsbHkgY29udHJpYnV0ZWQgYnkgQnJvc25hbiBZdWVuKVxyXG4gICAgICAgICAqIFNwZWNpZmljYXRpb24gOiBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL1NpbmNGdW5jdGlvbi5odG1sXHJcbiAgICAgICAgICogaWYgeCA9PSAwIHRoZW4gMVxyXG4gICAgICAgICAqIG90aGVyd2lzZSBzaW4oeCkveFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNpbmM6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmKHguZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbih4KSAvIHg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFRyaWFuZ2xlIGZ1bmN0aW9uIC0gTW92ZWQgZnJvbSBTcGVjaWFsLmpzIChvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5IEJyb3NuYW4gWXVlbilcclxuICAgICAgICAgKiBTcGVjaWZpY2F0aW9uIDogaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9UcmlhbmdsZUZ1bmN0aW9uLmh0bWxcclxuICAgICAgICAgKiBpZiB8eHwgPj0gMSB0aGVuIDBcclxuICAgICAgICAgKiBpZiB8eHwgPCB0aGVuIDEtfHh8XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJpOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB4ID0gTWF0aC5hYnMoeCk7XHJcbiAgICAgICAgICAgIGlmKHggPj0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICByZXR1cm4gMSAtIHg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL050aF9yb290X2FsZ29yaXRobVxyXG4gICAgICAgIG50aHJvb3Q6IGZ1bmN0aW9uIChBLCBuKSB7XHJcbiAgICAgICAgICAgIC8qbWFrZSBzdXJlIHRoZSBpbnB1dCBpcyBvZiB0eXBlIEZyYWMqL1xyXG4gICAgICAgICAgICBpZighKEEgaW5zdGFuY2VvZiBGcmFjKSlcclxuICAgICAgICAgICAgICAgIEEgPSBuZXcgRnJhYyhBLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBpZighKG4gaW5zdGFuY2VvZiBGcmFjKSlcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgRnJhYyhuLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBpZihuLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBBO1xyXG4gICAgICAgICAgICAvKmJlZ2luIGFsZ29yaXRobSovXHJcbiAgICAgICAgICAgIHZhciB4ayA9IEEuZGl2aWRlKG5ldyBGcmFjKDIpKTsgLyp4MCovXHJcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEZyYWMoMWUtMTUpO1xyXG4gICAgICAgICAgICB2YXIgZGssIGRrMCwgZDA7XHJcbiAgICAgICAgICAgIHZhciBhID0gbi5jbG9uZSgpLmludmVydCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBuLnN1YnRyYWN0KG5ldyBGcmFjKDEpKTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvd2IgPSBNYXRoMi5iaWdwb3coeGssIGIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRrX2RlYyA9IGEubXVsdGlwbHkoQS5kaXZpZGUocG93Yikuc3VidHJhY3QoeGspKS50b0RlY2ltYWwoMjUpO1xyXG4gICAgICAgICAgICAgICAgZGsgPSBGcmFjLmNyZWF0ZShka19kZWMpO1xyXG4gICAgICAgICAgICAgICAgaWYoZDApXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgeGsgPSB4ay5hZGQoZGspO1xyXG4gICAgICAgICAgICAgICAgLypjaGVjayB0byBzZWUgaWYgdGhlcmUncyBubyBjaGFuZ2UgZnJvbSB0aGUgbGFzdCB4ayovXHJcbiAgICAgICAgICAgICAgICB2YXIgZGtfZGVjID0gZGsudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICBkMCA9IGRrMCA/IGRrMCA9PT0gZGtfZGVjIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBkazAgPSBka19kZWM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoZGsuYWJzKCkuZ3RlKGUpKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHhrO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qaWdnenNvbi8wYzViMzNjYmNkN2I1MmIzNjEzMmIxZTk2NTczMjg1ZiovXHJcbiAgICAgICAgLypKdXN0IHRoZSBzcXVhcmUgcm9vdCBmdW5jdGlvbiBidXQgYmlnIDopKi9cclxuICAgICAgICBzcXJ0OiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICBpZighKG4gaW5zdGFuY2VvZiBGcmFjKSlcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgRnJhYyhuKTtcclxuICAgICAgICAgICAgdmFyIHhuLCBkLCBsZCwgc2FtZV9kZWx0YTtcclxuICAgICAgICAgICAgdmFyIGMgPSAwOyAvKmNvdW50ZXIqL1xyXG4gICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBuZXcgRnJhYygxZS0yMCk7XHJcbiAgICAgICAgICAgIHhuID0gbi5kaXZpZGUobmV3IEZyYWMoMikpO1xyXG4gICAgICAgICAgICB2YXIgc2FmZXR5ID0gMTAwMDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgLypicmVhayBpZiB3ZSdyZSBub3QgY29udmVyZ2luZyovXHJcbiAgICAgICAgICAgICAgICBpZihjID4gc2FmZXR5KVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNhbGN1bGF0ZSBzcXVhcmUgcm9vdCBmb3IgJyArIG4pO1xyXG4gICAgICAgICAgICAgICAgeG4gPSB4bi5hZGQobi5kaXZpZGUoeG4pKS5kaXZpZGUobmV3IEZyYWMoMikpO1xyXG4gICAgICAgICAgICAgICAgeG4gPSBuZXcgRnJhYyh4bi5kZWNpbWFsKDMwKSk7XHJcbiAgICAgICAgICAgICAgICAvKmdldCB0aGUgZGlmZmVyZW5jZSBmcm9tIHRoZSB0cnVlIHNxdWFyZSovXHJcbiAgICAgICAgICAgICAgICBkID0gbi5zdWJ0cmFjdCh4bi5tdWx0aXBseSh4bikpO1xyXG4gICAgICAgICAgICAgICAgLyppZiB0aGUgc3F1YXJlIG9mIHRoZSBjYWxjdWxhdGVkIG51bWJlciBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIG51bWJlciovXHJcbiAgICAgICAgICAgICAgICAvKndlJ3JlIGdldHRpbmcgdGhlIHNxdWFyZSByb290IG9yIHRoZSBsYXN0IGRlbHRhIHdhcyB0aGUgc2FtZSBhcyB0aGUgbmV3IGRlbHRhKi9cclxuICAgICAgICAgICAgICAgIC8qdGhlbiB3ZSdyZSBkb25lKi9cclxuICAgICAgICAgICAgICAgIHNhbWVfZGVsdGEgPSBsZCA/IGxkLmVxdWFscyhkKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYoZC5jbG9uZSgpLmFicygpLmxlc3NUaGFuKGRlbHRhKSB8fCBzYW1lX2RlbHRhKVxyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgLypzdG9yZSB0aGUgY2FsY3VsYXRlZCBkZWx0YSovXHJcbiAgICAgICAgICAgICAgICBsZCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBjKys7IC8qaW5jcmVhc2UgdGhlIGNvdW50ZXIqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKCFkb25lKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHhuO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvL2xpbmsgdGhlIE1hdGgyIG9iamVjdCB0byBTZXR0aW5ncy5GVU5DVElPTl9NT0RVTEVTXHJcbiAgICBTZXR0aW5ncy5GVU5DVElPTl9NT0RVTEVTLnB1c2goTWF0aDIpO1xyXG4gICAgcmVzZXJ2ZU5hbWVzKE1hdGgyKTsgLy9yZXNlcnZlIHRoZSBuYW1lcyBpbiBNYXRoMlxyXG5cclxuXHJcbi8vUG9seWZpbGxzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvL2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvXHJcbiAgICBNYXRoLnNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB4ID0gK3g7IC8vIGNvbnZlcnQgdG8gYSBudW1iZXJcclxuICAgICAgICBpZih4ID09PSAwIHx8IGlzTmFOKHgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geCA+IDAgPyAxIDogLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGguY29zaCA9IE1hdGguY29zaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciB5ID0gTWF0aC5leHAoeCk7XHJcbiAgICAgICAgcmV0dXJuICh5ICsgMSAvIHkpIC8gMjtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aC5zZWNoID0gTWF0aC5zZWNoIHx8IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgcmV0dXJuIDEgLyBNYXRoLmNvc2goeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGguY3NjaCA9IE1hdGguY3NjaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiAxIC8gTWF0aC5zaW5oKHgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLmNvdGggPSBNYXRoLmNvdGggfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gMSAvIE1hdGgudGFuaCh4KTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aC5zaW5oID0gTWF0aC5zaW5oIHx8IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIHkgPSBNYXRoLmV4cCh4KTtcclxuICAgICAgICByZXR1cm4gKHkgLSAxIC8geSkgLyAyO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLnRhbmggPSBNYXRoLnRhbmggfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZih4ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih4ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHkgPSBNYXRoLmV4cCgyICogeCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoeSAtIDEpIC8gKHkgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGguYXNpbmggPSBNYXRoLmFzaW5oIHx8IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYoeCA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLmFjb3NoID0gTWF0aC5hY29zaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4IC0gMSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLmF0YW5oID0gTWF0aC5hdGFuaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLmxvZzEwID0gTWF0aC5sb2cxMCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLnRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmKGlzTmFOKHgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHgpO1xyXG4gICAgfTtcclxuXHJcbi8vR2xvYmFsIGZ1bmN0aW9ucyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGEgaGFzaCBvciBhIHRleHQgcmVwcmVzZW50YXRpb24gb2YgYSBTeW1ib2wsIE1hdHJpeCwgb3IgVmVjdG9yLlxyXG4gICAgICogSWYgYWxsIGVsc2UgZmFpbHMgaXQgKmFzc3VtZXMqIHRoZSBvYmplY3QgaGFzIGEgdG9TdHJpbmcgbWV0aG9kIGFuZCB3aWxsIGNhbGwgdGhhdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIGdldCBpcyBhcyBhIGhhc2hcclxuICAgICAqIEBwYXJhbSB7aW50fSB1c2VHcm91cFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGV4dChvYmosIG9wdGlvbiwgdXNlR3JvdXAsIGRlY3ApIHtcclxuICAgICAgICB2YXIgYXNIYXNoID0gb3B0aW9uID09PSAnaGFzaCcsXHJcbiAgICAgICAgICAgICAgICAvL3doZXRoZXIgdG8gd3JhcCBudW1iZXJzIGluIGJyYWNrZXRzXHJcbiAgICAgICAgICAgICAgICB3cmFwQ29uZGl0aW9uID0gdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgb3B0ID0gYXNIYXNoID8gdW5kZWZpbmVkIDogb3B0aW9uLFxyXG4gICAgICAgICAgICAgICAgYXNEZWNpbWFsID0gb3B0ID09PSAnZGVjaW1hbCcgfHwgb3B0ID09PSAnZGVjaW1hbHMnO1xyXG5cclxuICAgICAgICBpZihhc0RlY2ltYWwgJiYgdHlwZW9mIGRlY3AgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBkZWNwID0gMTY7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRvU3RyaW5nKG9iaikge1xyXG4gICAgICAgICAgICBzd2l0Y2gob3B0aW9uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkZWNpbWFscyc6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkZWNpbWFsJzpcclxuICAgICAgICAgICAgICAgICAgICB3cmFwQ29uZGl0aW9uID0gd3JhcENvbmRpdGlvbiB8fCBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmoudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmVjdXJyaW5nJzpcclxuICAgICAgICAgICAgICAgICAgICB3cmFwQ29uZGl0aW9uID0gd3JhcENvbmRpdGlvbiB8fCBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihcIidcIikgIT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBvYmoudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3ZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgaXMgYWN0dWFsbHkgYSBmcmFjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFjID0gL14tP1xcZCsoPzpcXC9cXGQrKT8kLy5leGVjKHN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZnJhYy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3BsaXQgdGhlIGZyYWN0aW9uIGludG8gdGhlIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3JcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBmcmFjWzBdLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5lZ2F0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBOdW1iZXIocGFydHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG0gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAtbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IE51bWJlcihwYXJ0c1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIW4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2h0dHBzOi8vc29mdHdhcmVlbmdpbmVlcmluZy5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTkyMDcwL3doYXQtaXMtYS1lZmZpY2llbnQtd2F5LXRvLWZpbmQtcmVwZWF0aW5nLWRlY2ltYWwjY29tbWVudDc0MzU3NF8xOTIwODFcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVvdGllbnQgPSBNYXRoLmZsb29yKG0gLyBuKSwgYyA9IDEwICogKG0gLSBxdW90aWVudCAqIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gcXVvdGllbnQudG9TdHJpbmcoKSArIFwiLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGMgJiYgYyA8IG4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyAqPSAxMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGllbnQgKz0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWdpdHMgPSBcIlwiLCBwYXNzZWQgPSBbXSwgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgcGFzc2VkW2NdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IGRpZ2l0cy5zbGljZSgwLCBwYXNzZWRbY10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeWNsZSA9IGRpZ2l0cy5zbGljZShwYXNzZWRbY10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBxdW90aWVudCArIHByZWZpeCArIFwiJ1wiICsgY3ljbGUgKyBcIidcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobmVnYXRpdmUgPyBcIi1cIiA6IFwiXCIpICsgcmVzdWx0LnJlcGxhY2UoXCInMCdcIiwgXCJcIikucmVwbGFjZSgvXFwuJC8sIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gTWF0aC5mbG9vcihjIC8gbiksIHIgPSBjIC0gcSAqIG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NlZFtjXSA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0cyArPSBxLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IDEwICogcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtaXhlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcENvbmRpdGlvbiA9IHdyYXBDb25kaXRpb24gfHwgZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YoJy8nKSAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IG9iai50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdmVyaWZ5IHRoYXQgdGhlIHN0cmluZyBpcyBhY3R1YWxseSBhIGZyYWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWMgPSAvXi0/XFxkKyg/OlxcL1xcZCspPyQvLmV4ZWMoc3RyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihmcmFjLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zcGxpdCB0aGUgZnJhY3Rpb24gaW50byB0aGUgbnVtZXJhdG9yIGFuZCBkZW5vbWluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGZyYWNbMF0uc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtZXIgPSBuZXcgYmlnSW50KHBhcnRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVub20gPSBuZXcgYmlnSW50KHBhcnRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihkZW5vbS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbm9tID0gbmV3IGJpZ0ludCgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gdGhlIHF1b3RpZW50IHBsdXMgdGhlIHJlbWFpbmRlclxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXZtb2QgPSBudW1lci5kaXZtb2QoZGVub20pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdW90aWVudCA9IGRpdm1vZC5xdW90aWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gZGl2bW9kLnJlbWFpbmRlcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBwYXJ0c1swXVswXSA9PT0gJy0nIHx8IHF1b3RpZW50LmVxdWFscygwKSB8fCByZW1haW5kZXIuZXF1YWxzKDApID8gJycgOiAnKyc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChxdW90aWVudC5lcXVhbHMoMCkgPyAnJyA6IHF1b3RpZW50LnRvU3RyaW5nKCkpICsgb3BlcmF0b3IgKyAocmVtYWluZGVyLmVxdWFscygwKSA/ICcnIDogKHJlbWFpbmRlci50b1N0cmluZygpICsgJy8nICsgcGFydHNbMV0pKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3NjaWVudGlmaWMnOlxyXG4gICAgICAgICAgICAgICAgICAgIHdyYXBDb25kaXRpb24gPSB3cmFwQ29uZGl0aW9uIHx8IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNjaWVudGlmaWMob2JqLnZhbHVlT2YoKSkudG9TdHJpbmcoU2V0dGluZ3MuU0NJRU5USUZJQ19NQVhfREVDSU1BTF9QTEFDRVMpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB3cmFwQ29uZGl0aW9uID0gd3JhcENvbmRpdGlvbiB8fCBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIuaW5kZXhPZignLycpICE9PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgdGhlIG9iamVjdCBpcyBhIHN5bWJvbFxyXG4gICAgICAgIGlmKGlzU3ltYm9sKG9iaikpIHtcclxuICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSAnJyxcclxuICAgICAgICAgICAgICAgICAgICBwb3dlciA9ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAnJyxcclxuICAgICAgICAgICAgICAgICAgICBncm91cCA9IG9iai5ncm91cCB8fCB1c2VHcm91cCxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iai52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIC8vaWYgdGhlIHZhbHVlIGlzIHRvIGJlIHVzZWQgYXMgYSBoYXNoIHRoZW4gdGhlIHBvd2VyIGFuZCBtdWx0aXBsaWVyIG5lZWQgdG8gYmUgc3VwcHJlc3NlZFxyXG4gICAgICAgICAgICBpZighYXNIYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAvL3VzZSBhc0RlY2ltYWwgdG8gZ2V0IHRoZSBvYmplY3QgYmFjayBhcyBhIGRlY2ltYWxcclxuICAgICAgICAgICAgICAgIHZhciBvbSA9IHRvU3RyaW5nKG9iai5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIGlmKG9tID09ICctMScgJiYgU3RyaW5nKG9iai5tdWx0aXBsaWVyKSA9PT0gJy0xJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XHJcbiAgICAgICAgICAgICAgICAgICAgb20gPSAnMSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL29ubHkgYWRkIHRoZSBtdWx0aXBsaWVyIGlmIGl0J3Mgbm90IDFcclxuICAgICAgICAgICAgICAgIGlmKG9tICE9ICcxJylcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gb207XHJcbiAgICAgICAgICAgICAgICAvL3VzZSBhc0RlY2ltYWwgdG8gZ2V0IHRoZSBvYmplY3QgYmFjayBhcyBhIGRlY2ltYWxcclxuICAgICAgICAgICAgICAgIHZhciBwID0gb2JqLnBvd2VyID8gdG9TdHJpbmcob2JqLnBvd2VyKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgLy9vbmx5IGFkZCB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgaWYocCAhPSAnMScpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2lzIGl0IGEgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNTeW1ib2wocCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXIgPSB0ZXh0KHAsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3dlciA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2goZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTjpcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yb3VuZCBpZiByZXF1ZXN0ZWRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGRlY3AgJiYgYXNEZWNpbWFsID8gb2JqLm11bHRpcGxpZXIudG9EZWNpbWFsKGRlY3ApIDogdG9TdHJpbmcob2JqLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaXQncyBudW1lcmljYWwgdGhlbiBhbGwgd2UgbmVlZCBpcyB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gU3RyaW5nKG9iai5tdWx0aXBsaWVyKSA9PSAnLTEnID8gJzEnIDogbTtcclxuICAgICAgICAgICAgICAgICAgICBwb3dlciA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQTDpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iai5jb2xsZWN0U3ltYm9scygpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHh0ID0gdGV4dCh4LCBvcHQsIHVzZUdyb3VwLCBkZWNwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHh0ID09ICcwJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4dCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLnNvcnQoKS5qb2luKCcrJykucmVwbGFjZSgvXFwrXFwtL2csICctJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENQOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqLmNvbGxlY3RTeW1ib2xzKCkubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eHQgPSB0ZXh0KHgsIG9wdCwgdXNlR3JvdXAsIGRlY3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0eHQgPT0gJzAnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHh0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuc29ydCgpLmpvaW4oJysnKS5yZXBsYWNlKC9cXCtcXC0vZywgJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ0I6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmouY29sbGVjdFN5bWJvbHMoZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHN5bWJvbC5ncm91cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ib3RoIGdyb3VwcyB3aWxsIGFscmVhZHkgYmUgaW4gYnJhY2tldHMgaWYgdGhlaXIgcG93ZXIgaXMgZ3JlYXRlciB0aGFuIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zbyBza2lwIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZigoZyA9PT0gUEwgfHwgZyA9PT0gQ1ApICYmIChzeW1ib2wucG93ZXIuZXF1YWxzKDEpICYmIHN5bWJvbC5tdWx0aXBsaWVyLmVxdWFscygxKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbkJyYWNrZXRzKHRleHQoc3ltYm9sLCBvcHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dChzeW1ib2wsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbignKicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBFWDpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGcgPSBvYmoucHJldmlvdXNHcm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB3ZyA9IG9iai5wb3dlci5ncm91cDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9QTCBhcmUgdGhlIGV4Y2VwdGlvbi4gSXQncyBzaW1wbGVyIHRvIGp1c3QgY29sbGVjdCBhbmQgc2V0IHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHBnID09PSBQTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmouY29sbGVjdFN5bWJvbHModGV4dCwgb3B0KS5qb2luKCcrJykucmVwbGFjZSgnKy0nLCAnLScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCEocGcgPT09IE4gfHwgcGcgPT09IFMgfHwgcGcgPT09IEZOKSAmJiAhYXNIYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaW5CcmFja2V0cyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZigocHdnID09PSBDUCB8fCBwd2cgPT09IENCIHx8IHB3ZyA9PT0gUEwgfHwgb2JqLnBvd2VyLm11bHRpcGxpZXIudG9TdHJpbmcoKSAhPSAnMScpICYmIHBvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvd2VyID0gaW5CcmFja2V0cyhwb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqLmZuYW1lICsgaW5CcmFja2V0cyhvYmouYXJncy5tYXAoZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KHN5bWJvbCwgb3B0KTtcclxuICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9UT0RPOiBOZWVkcyB0byBiZSBtb3JlIGVmZmljaWVudC4gTWF5YmUuXHJcbiAgICAgICAgICAgIGlmKGdyb3VwID09PSBGTiAmJiBvYmouZm5hbWUgaW4gQ1VTVE9NX09QRVJBVE9SUykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0ZXh0KG9iai5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gdGV4dChvYmouYXJnc1sxXSk7XHJcbiAgICAgICAgICAgICAgICBpZihvYmouYXJnc1swXS5pc0NvbXBvc2l0ZSgpKSAvL3ByZXNlcnZlIHRoZSBicmFja2V0c1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBpbkJyYWNrZXRzKGEpO1xyXG4gICAgICAgICAgICAgICAgaWYob2JqLmFyZ3NbMV0uaXNDb21wb3NpdGUoKSkgLy9wcmVzZXJ2ZSB0aGUgYnJhY2tldHNcclxuICAgICAgICAgICAgICAgICAgICBiID0gaW5CcmFja2V0cyhiKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gYSArIENVU1RPTV9PUEVSQVRPUlNbb2JqLmZuYW1lXSArIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy93cmFwIHRoZSBwb3dlciBzaW5jZSAvIGlzIGxlc3MgdGhhbiBeXHJcbiAgICAgICAgICAgIC8vVE9ETzogaW50cm9kdWNlIG1ldGhvZCBjYWxsIGlzU2ltcGxlXHJcbiAgICAgICAgICAgIGlmKHBvd2VyICYmIGdyb3VwICE9PSBFWCAmJiB3cmFwQ29uZGl0aW9uKHBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgcG93ZXIgPSBpbkJyYWNrZXRzKHBvd2VyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy90aGUgZm9sbG93aW5nIGdyb3VwcyBhcmUgaGVsZCB0b2dldGhlciBieSBwbHVzIG9yIG1pbnVzLiBUaGV5IGNhbiBiZSByYWlzZWQgdG8gYSBwb3dlciBvciBtdWx0aXBsaWVkXHJcbiAgICAgICAgICAgIC8vYnkgYSBtdWx0aXBsaWVyIGFuZCBoYXZlIHRvIGJlIGluIGJyYWNrZXRzIHRvIHByZXNlcnZlIHRoZSBvcmRlciBvZiBwcmVjZWRlbmNlXHJcbiAgICAgICAgICAgIGlmKCgoZ3JvdXAgPT09IENQIHx8IGdyb3VwID09PSBQTCkgJiYgKG11bHRpcGxpZXIgJiYgbXVsdGlwbGllciAhPSAnMScgfHwgc2lnbiA9PT0gJy0nKSlcclxuICAgICAgICAgICAgICAgICAgICB8fCAoKGdyb3VwID09PSBDQiB8fCBncm91cCA9PT0gQ1AgfHwgZ3JvdXAgPT09IFBMKSAmJiAocG93ZXIgJiYgcG93ZXIgIT0gJzEnKSlcclxuICAgICAgICAgICAgICAgICAgICB8fCAhYXNIYXNoICYmIGdyb3VwID09PSBQICYmIHZhbHVlID09IC0xXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgb2JqLmZuYW1lID09PSBQQVJFTlRIRVNJUykge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhbHVlID0gaW5CcmFja2V0cyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGRlY3AgJiYgKG9wdGlvbiA9PT0gJ2RlY2ltYWwnIHx8IG9wdGlvbiA9PT0gJ2RlY2ltYWxzJyAmJiBtdWx0aXBsaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IG5yb3VuZChtdWx0aXBsaWVyLCBkZWNwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vYWRkIHRoZSBzaWduIGJhY2tcclxuICAgICAgICAgICAgdmFyIGMgPSBzaWduICsgbXVsdGlwbGllcjtcclxuXHJcbiAgICAgICAgICAgIGlmKG11bHRpcGxpZXIgJiYgd3JhcENvbmRpdGlvbihtdWx0aXBsaWVyKSlcclxuICAgICAgICAgICAgICAgIGMgPSBpbkJyYWNrZXRzKGMpO1xyXG5cclxuICAgICAgICAgICAgaWYocG93ZXIgPCAwKVxyXG4gICAgICAgICAgICAgICAgcG93ZXIgPSBpbkJyYWNrZXRzKHBvd2VyKTtcclxuXHJcbiAgICAgICAgICAgIC8vYWRkIHRoZSBtdWx0aXBsaWNhdGlvbiBiYWNrXHJcbiAgICAgICAgICAgIGlmKG11bHRpcGxpZXIpXHJcbiAgICAgICAgICAgICAgICBjID0gYyArICcqJztcclxuXHJcbiAgICAgICAgICAgIGlmKHBvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICBpZih2YWx1ZSA9PT0gJ2UnICYmIFNldHRpbmdzLkVfVE9fRVhQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKyAnZXhwJyArIGluQnJhY2tldHMocG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG93ZXIgPSBTZXR0aW5ncy5QT1dFUl9PUEVSQVRPUiArIHBvd2VyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3RoaXMgbmVlZHMgc2VyaW91cyByZXRoaW5raW5nLiBNdXN0IGZpeFxyXG4gICAgICAgICAgICBpZihncm91cCA9PT0gRVggJiYgdmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gaW5CcmFja2V0cyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjdiA9IGMgKyB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmKG9iai5wYXJlbnMpIHtcclxuICAgICAgICAgICAgICAgIGN2ID0gaW5CcmFja2V0cyhjdik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjdiArIHBvd2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGlzVmVjdG9yKG9iaikpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSBvYmouZWxlbWVudHMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgIGMucHVzaChvYmouZWxlbWVudHNbaV0udGV4dChvcHRpb24pKTtcclxuICAgICAgICAgICAgcmV0dXJuICdbJyArIGMuam9pbignLCcpICsgJ10nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmoudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgcHJpbWUgZmFjdG9ycyBmb3IgYSBudW1iZXIuIEl0IGZpcnN0IGNoZWNrcyBpZiB0aGUgbnVtYmVyXHJcbiAgICAgKiBpcyBhIHByaW1lIG51bWJlci4gSWYgaXQncyBub3QgdGhlbiBpdCB3aWxsIGNhbGN1bGF0ZSBhbGwgdGhlIHByaW1lcyBcclxuICAgICAqIGZvciB0aGF0IG51bWJlci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBudW1cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIHByaW1lRmFjdG9ycyhudW0pIHtcclxuICAgICAgICBpZihpc1ByaW1lKG51bSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtudW1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGwgPSBudW0sIGkgPSAxLCBmYWN0b3JzID0gW10sXHJcbiAgICAgICAgICAgICAgICBlcHNpbG9uID0gMi4yMjA0NDYwNDkyNTAzMTMwODA4NDcyNjMzMzYxODE2RS0xNjtcclxuICAgICAgICB3aGlsZShpIDwgbCkge1xyXG4gICAgICAgICAgICB2YXIgcXVvdGllbnQgPSBudW0gLyBpO1xyXG4gICAgICAgICAgICB2YXIgd2hvbGUgPSBNYXRoLmZsb29yKHF1b3RpZW50KTtcclxuICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IHF1b3RpZW50IC0gd2hvbGU7XHJcblxyXG4gICAgICAgICAgICBpZihyZW1haW5kZXIgPD0gZXBzaWxvbiAmJiBpID4gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByaW1lIHdhc24ndCBmb3VuZCBidXQgY2FsY3VsYXRlZCB0aGVuIHNhdmUgaXQgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhZGQgaXQgYXMgYSBmYWN0b3IuXHJcbiAgICAgICAgICAgICAgICBpZihpc1ByaW1lKGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoUFJJTUVTLmluZGV4T2YoaSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFBSSU1FUy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbWFpbmRlciBpcyBhIHByaW1lXHJcbiAgICAgICAgICAgICAgICBpZihpc1ByaW1lKHdob2xlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnMucHVzaCh3aG9sZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbCA9IHdob2xlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWN0b3JzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcHJpbWVGYWN0b3JzKDMxNDE0NjE3OTM2NSlcclxuLy9FeHByZXNzaW9uID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyB3aGF0IG5lcmRhbWVyIHJldHVybnMuIEl0J3Mgc29ydCBvZiBhIHdyYXBwZXIgYXJvdW5kIHRoZSBzeW1ib2wgY2xhc3MgYW5kXHJcbiAgICAgKiBwcm92aWRlcyB0aGUgdXNlciB3aXRoIHNvbWUgdXNlZnVsIGZ1bmN0aW9ucy4gSWYgeW91IHdhbnQgdG8gcHJvdmlkZSB0aGUgdXNlciB3aXRoIGV4dHJhXHJcbiAgICAgKiBsaWJyYXJ5IGZ1bmN0aW9ucyB0aGVuIGFkZCB0aGVtIHRvIHRoaXMgY2xhc3MncyBwcm90b3R5cGUuXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn0gd3JhcHMgYXJvdW5kIHRoZSBTeW1ib2wgY2xhc3NcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvbihzeW1ib2wpIHtcclxuICAgICAgICAvL3dlIGRvbid0IHdhbnQgYXJyYXlzIHdyYXBwZWRcclxuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBzdG9yZWQgZXhwcmVzc2lvbiBhdCBpbmRleC4gRm9yIGZpcnN0IGluZGV4IHVzZSAxIG5vdCAwLlxyXG4gICAgICogQHBhcmFtIHtib29sfSBhc1R5cGVcclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZXhwcmVzc2lvbl9udW1iZXJcclxuICAgICAqL1xyXG4gICAgRXhwcmVzc2lvbi5nZXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb25fbnVtYmVyLCBhc1R5cGUpIHtcclxuICAgICAgICBpZihleHByZXNzaW9uX251bWJlciA9PT0gJ2xhc3QnIHx8ICFleHByZXNzaW9uX251bWJlcilcclxuICAgICAgICAgICAgZXhwcmVzc2lvbl9udW1iZXIgPSBFWFBSRVNTSU9OUy5sZW5ndGg7XHJcbiAgICAgICAgaWYoZXhwcmVzc2lvbl9udW1iZXIgPT09ICdmaXJzdCcpXHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25fbnVtYmVyID0gMTtcclxuICAgICAgICB2YXIgaW5kZXggPSBleHByZXNzaW9uX251bWJlciAtIDEsXHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gRVhQUkVTU0lPTlNbaW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gZXhwcmVzc2lvbiA/IG5ldyBFeHByZXNzaW9uKGV4cHJlc3Npb24pIDogZXhwcmVzc2lvbjtcclxuICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgfTtcclxuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgdGhlIGV4cHJlc3Npb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0IC0gb3B0aW9uIG9mIGZvcm1hdHRpbmcgbnVtYmVyc1xyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZmlndXJlc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKG9wdCwgbikge1xyXG4gICAgICAgICAgICBuID0gbiB8fCAxOTtcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8ICdkZWNpbWFscyc7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sLnRleHRfKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sLnRleHRfKG9wdCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGV4dCh0aGlzLnN5bWJvbCwgb3B0LCB1bmRlZmluZWQsIG4pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGF0ZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGV4cHJlc3Npb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIC0gb3B0aW9uIGZvciBmb3JtYXR0aW5nIG51bWJlcnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxhdGV4OiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sLmxhdGV4KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sLmxhdGV4KG9wdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBMYVRlWC5sYXRleCh0aGlzLnN5bWJvbCwgb3B0aW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sLnZhbHVlT2YoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFdmFsdWF0ZXMgdGhlIGV4cHJlc3Npb24gYW5kIHRyaWVzIHRvIHJlZHVjZSBpdCB0byBhIG51bWJlciBpZiBwb3NzaWJsZS5cclxuICAgICAgICAgKiBJZiBhbiBhcmd1bWVudCBpcyBnaXZlbiBpbiB0aGUgZm9ybSBvZiAle2ludGVnZXJ9IGl0IHdpbGwgZXZhbHVhdGUgdGhhdCBleHByZXNzaW9uLlxyXG4gICAgICAgICAqIE90aGVyIHRoYW4gdGhhdCBpdCB3aWxsIGp1c3QgdXNlIGl0J3Mgb3duIHRleHQgYW5kIHJlcGFyc2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgLy8gRG9uJ3QgZXZhbHVhdGUgYW4gZW1wdHkgdmVjdG9yXHJcbiAgICAgICAgICAgIGlmKGlzVmVjdG9yKHRoaXMuc3ltYm9sKSAmJiB0aGlzLnN5bWJvbC5kaW1lbnNpb25zKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZmlyc3RfYXJnID0gYXJndW1lbnRzWzBdLCBleHByZXNzaW9uLCBpZHggPSAxO1xyXG5cclxuICAgICAgICAgICAgLy9FbmFibGUgZ2V0dGluZyBvZiBleHByZXNzaW9ucyB1c2luZyB0aGUgJSBzbyBmb3IgZXhhbXBsZSAlMSBzaG91bGQgZ2V0IHRoZSBmaXJzdCBleHByZXNzaW9uXHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBmaXJzdF9hcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gKGZpcnN0X2FyZy5jaGFyQXQoMCkgPT09ICclJykgPyBFeHByZXNzaW9uLmdldEV4cHJlc3Npb24oZmlyc3RfYXJnLnN1YnN0cigxKSkudGV4dCgpIDogZmlyc3RfYXJnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZmlyc3RfYXJnIGluc3RhbmNlb2YgRXhwcmVzc2lvbiB8fCBpc1N5bWJvbChmaXJzdF9hcmcpKSB7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZmlyc3RfYXJnLnRleHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSB0aGlzLnN5bWJvbC50ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBpZHgtLTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN1YnMgPSBhcmd1bWVudHNbaWR4XSB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgRXhwcmVzc2lvbihibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZXhwcmVzc2lvbiwgc3Vicyk7XHJcbiAgICAgICAgICAgIH0sIHRydWUpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHN5bWJvbCB0byBhIEpTIGZ1bmN0aW9uLiBQYXNzIGluIGFuIGFycmF5IG9mIHZhcmlhYmxlcyB0byB1c2UgdGhhdCBvcmRlciBpbnN0ZWFkIG9mXHJcbiAgICAgICAgICogdGhlIGRlZmF1bHQgYWxwaGFiZXRpY2FsIG9yZGVyXHJcbiAgICAgICAgICogQHBhcmFtIHZhcnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJ1aWxkRnVuY3Rpb246IGZ1bmN0aW9uICh2YXJzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCdWlsZC5idWlsZCh0aGlzLnN5bWJvbCwgdmFycyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBleHByZXNzaW9uIGlzIGp1c3QgYSBwbGFpbiBvbGQgbnVtYmVyXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNOdW1iZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTnVtZXJpY1N5bWJvbCh0aGlzLnN5bWJvbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBleHByZXNzaW9uIGlzIGluZmluaXR5XHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNJbmZpbml0eTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zeW1ib2wubXVsdGlwbGllcikgPT09IEluZmluaXR5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBpbWFnaW5hcnkgbnVtYmVyc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzSW1hZ2luYXJ5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZShfLnBhcnNlKHRoaXMuc3ltYm9sKSkuaXNJbWFnaW5hcnkoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYWxsIHRoZSB2YXJpYWJsZXMgaW4gdGhlIGV4cHJlc3Npb25cclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyaWFibGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZXModGhpcy5zeW1ib2wpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZihpc0FycmF5KHRoaXMuc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1snICsgdGhpcy5zeW1ib2wudG9TdHJpbmcoKSArICddJztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9mb3JjZXMgdGhlIHN5bWJvbCB0byBiZSByZXR1cm5lZCBhcyBhIGRlY2ltYWxcclxuICAgICAgICB0b0RlY2ltYWw6IGZ1bmN0aW9uIChwcmVjKSB7XHJcbiAgICAgICAgICAgIFNldHRpbmdzLnByZWNpc2lvbiA9IHByZWM7XHJcbiAgICAgICAgICAgIHZhciBkZWMgPSB0ZXh0KHRoaXMuc3ltYm9sLCAnZGVjaW1hbHMnKTtcclxuICAgICAgICAgICAgU2V0dGluZ3MucHJlY2lzaW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gZGVjO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9jaGVja3MgdG8gc2VlIGlmIHRoZSBleHByZXNzaW9uIGlzIGEgZnJhY3Rpb25cclxuICAgICAgICBpc0ZyYWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0ZyYWN0aW9uKHRoaXMuc3ltYm9sKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vY2hlY2tzIHRvIHNlZSBpZiB0aGUgc3ltYm9sIGlzIGEgbXVsdGl2YXJpYXRlIHBvbHlub21pYWxcclxuICAgICAgICBpc1BvbHlub21pYWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sLmlzUG9seSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9wZXJmb3JtcyBhIHN1YnN0aXR1dGlvblxyXG4gICAgICAgIHN1YjogZnVuY3Rpb24gKHN5bWJvbCwgZm9yX3N5bWJvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24odGhpcy5zeW1ib2wuc3ViKF8ucGFyc2Uoc3ltYm9sKSwgXy5wYXJzZShmb3Jfc3ltYm9sKSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3BlcmF0aW9uOiBmdW5jdGlvbiAob3R5cGUsIHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZihpc0V4cHJlc3Npb24oc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5zeW1ib2w7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoIWlzU3ltYm9sKHN5bWJvbCkpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihfW290eXBlXSh0aGlzLnN5bWJvbC5jbG9uZSgpLCBzeW1ib2wuY2xvbmUoKSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbignYWRkJywgc3ltYm9sKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbignc3VidHJhY3QnLCBzeW1ib2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uKCdtdWx0aXBseScsIHN5bWJvbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaXZpZGU6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0aW9uKCdkaXZpZGUnLCBzeW1ib2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcG93OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbigncG93Jywgc3ltYm9sKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4cGFuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24oXy5leHBhbmQodGhpcy5zeW1ib2wpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaywgaSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLnN5bWJvbC5lYWNoKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zeW1ib2wuZWFjaChjYWxsYmFjaywgaSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYoaXNBcnJheSh0aGlzLnN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnN5bWJvbC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMuc3ltYm9sLCB0aGlzLnN5bWJvbFtpXSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLnN5bWJvbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF8ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfLnN1YnRyYWN0KHRoaXMuc3ltYm9sLmNsb25lKCksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmVxdWFscygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2wodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfLnBhcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gZXZhbHVhdGUoXy5zdWJ0cmFjdCh0aGlzLnN5bWJvbC5jbG9uZSgpLCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGVzc1RoYW4oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGd0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gXy5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGV2YWx1YXRlKF8uc3VidHJhY3QodGhpcy5zeW1ib2wuY2xvbmUoKSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3RlOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3QodmFsdWUpIHx8IHRoaXMuZXEodmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbHRlOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubHQodmFsdWUpIHx8IHRoaXMuZXEodmFsdWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG51bWVyYXRvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24odGhpcy5zeW1ib2wuZ2V0TnVtKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVub21pbmF0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHRoaXMuc3ltYm9sLmdldERlbm9tKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzRnVuY3Rpb246IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbC5jb250YWluc0Z1bmN0aW9uKGYpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2wuY29udGFpbnModmFyaWFibGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvL0FsaWFzZXNcclxuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnRvVGVYID0gRXhwcmVzc2lvbi5wcm90b3R5cGUubGF0ZXg7XHJcblxyXG4vL1NjaWVudGlmaWMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgZnVuY3Rpb24gU2NpZW50aWZpYyhudW0pIHtcclxuICAgICAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBTY2llbnRpZmljKSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2llbnRpZmljKG51bSk7XHJcblxyXG4gICAgICAgIG51bSA9IFN0cmluZyh0eXBlb2YgbnVtID09PSAndW5kZWZpbmVkJyA/IDAgOiBudW0pOyAvL2NvbnZlcnQgdG8gYSBzdHJpbmdcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgdGhlIHNpZ25cclxuICAgICAgICBpZihudW0uc3RhcnRzV2l0aCgnLScpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2lnbiA9IC0xO1xyXG4gICAgICAgICAgICAvL3JlbW92ZSB0aGUgc2lnblxyXG4gICAgICAgICAgICBudW0gPSBudW0uc3Vic3RyKDEsIG51bS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zaWduID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKFNjaWVudGlmaWMuaXNTY2llbnRpZmljKG51bSkpIHtcclxuICAgICAgICAgICAgdGhpcy5mcm9tU2NpZW50aWZpYyhudW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb252ZXJ0KG51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIFNjaWVudGlmaWMucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGZyb21TY2llbnRpZmljOiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IFN0cmluZyhudW0pLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ2UnKTtcclxuICAgICAgICAgICAgdGhpcy5jb2VmZiA9IHBhcnRzWzBdO1xyXG4gICAgICAgICAgICB0aGlzLmV4cG9uZW50ID0gcGFydHNbMV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgLy9nZXQgd2hvbGVzIGFuZCBkZWNpbWFsc1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBudW0uc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgLy9tYWtlIHplcm8gZ28gYXdheVxyXG4gICAgICAgICAgICB2YXIgdyA9IHBhcnRzWzBdIHx8ICcnO1xyXG4gICAgICAgICAgICB2YXIgZCA9IHBhcnRzWzFdIHx8ICcnO1xyXG4gICAgICAgICAgICAvL2NvbnZlcnQgemVybyB0byBibGFuayBzdHJpbmdzXHJcbiAgICAgICAgICAgIHcgPSBTY2llbnRpZmljLnJlbW92ZUxlYWRpbmdaZXJvZXModyk7XHJcbiAgICAgICAgICAgIGQgPSBTY2llbnRpZmljLnJlbW92ZVRyYWlsaW5nWmVyb2VzKGQpO1xyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkZWNpbWFsIHBsYWNlIHdoaWNoIGlzIHJpZ2h0IGFmdGVyIHRoZSB3aG9sZXNcclxuICAgICAgICAgICAgdmFyIGRvdF9sb2NhdGlvbiA9IHcubGVuZ3RoO1xyXG4gICAgICAgICAgICAvL2FkZCB0aGVtIHRvZ2V0aGVyIHNvIHdlIGNhbiBtb3ZlIHRoZSBkb3RcclxuICAgICAgICAgICAgdmFyIG4gPSB3ICsgZDtcclxuICAgICAgICAgICAgLy9maW5kIHRoZSBuZXh0IG51bWJlclxyXG4gICAgICAgICAgICB2YXIgemVyb2VzID0gU2NpZW50aWZpYy5sZWFkaW5nWmVyb2VzKG4pLmxlbmd0aDtcclxuICAgICAgICAgICAgLy9zZXQgdGhlIGV4cG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMuZXhwb25lbnQgPSBkb3RfbG9jYXRpb24gLSAoemVyb2VzICsgMSk7XHJcbiAgICAgICAgICAgIC8vc2V0IHRoZSBjb2VmZiBidXQgZmlyc3QgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXHJcbiAgICAgICAgICAgIHZhciBjb2VmZiA9IFNjaWVudGlmaWMucmVtb3ZlTGVhZGluZ1plcm9lcyhuKTtcclxuICAgICAgICAgICAgdGhpcy5jb2VmZiA9IGNvZWZmLmNoYXJBdCgwKSArICcuJyArIChjb2VmZi5zdWJzdHIoMSwgY29lZmYubGVuZ3RoKSB8fCAnMCcpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3VuZDogZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuY29weSgpO1xyXG5cclxuICAgICAgICAgICAgbnVtID0gTnVtYmVyKG51bSk7IC8vY2FzdCB0byBudW1iZXIgZm9yIHNhZmV0eVxyXG4gICAgICAgICAgICAvL3NpbmNlIHdlIGtub3cgaXQgZ3VhcmFudGVlZCB0byBiZSBpbiB0aGUgZm9ybWF0IHtkaWdpdH17b3B0aW9uYWwgZG90fXtvcHRpb25hbCBkaWdpdHN9XHJcbiAgICAgICAgICAgIC8vd2UgY2FuIHJvdW5kIGJhc2VkIG9uIHRoaXNcclxuICAgICAgICAgICAgaWYobnVtID09PSAwKVxyXG4gICAgICAgICAgICAgICAgbi5jb2VmZiA9IG4uY29lZmYuY2hhckF0KDApO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHVwIHRvIG4tMSBkaWdpdHNcclxuICAgICAgICAgICAgICAgIHZhciByb3VuZGVkID0gdGhpcy5jb2VmZi5zdWJzdHJpbmcoMCwgbnVtICsgMSk7XHJcbiAgICAgICAgICAgICAgICAvL2dldCB0aGUgbmV4dCB0d29cclxuICAgICAgICAgICAgICAgIHZhciBuZXh0X3R3byA9IHRoaXMuY29lZmYuc3Vic3RyaW5nKG51bSArIDEsIG51bSArIDMpO1xyXG4gICAgICAgICAgICAgICAgLy90aGUgZXh0cmEgZGlnaXRcclxuICAgICAgICAgICAgICAgIHZhciBlZCA9IG5leHRfdHdvLmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihuZXh0X3R3by5jaGFyQXQoMSkgPiA0KVxyXG4gICAgICAgICAgICAgICAgICAgIGVkKys7XHJcblxyXG4gICAgICAgICAgICAgICAgbi5jb2VmZiA9IHJvdW5kZWQgKyBlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb3B5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gbmV3IFNjaWVudGlmaWMoMCk7XHJcbiAgICAgICAgICAgIG4uY29lZmYgPSB0aGlzLmNvZWZmO1xyXG4gICAgICAgICAgICBuLmV4cG9uZW50ID0gdGhpcy5leHBvbmVudDtcclxuICAgICAgICAgICAgbi5zaWduID0gdGhpcy5zaWduO1xyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICB2YXIgY29lZmYgPSB0eXBlb2YgbiA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvZWZmIDogU2NpZW50aWZpYy5yb3VuZCh0aGlzLmNvZWZmLCBuKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjO1xyXG4gICAgICAgICAgICBpZih0aGlzLmV4cG9uZW50ID09PSAwICYmIFNldHRpbmdzLlNDSUVOVElGSUNfSUdOT1JFX0lOVFMpIHtcclxuICAgICAgICAgICAgICAgIGMgPSB0aGlzLmNvZWZmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYyA9IGNvZWZmICsgJ2UnICsgdGhpcy5leHBvbmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2lnbiA9PT0gLTEgPyAnLScgOiAnJykgKyBjO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgU2NpZW50aWZpYy5pc1NjaWVudGlmaWMgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIC9cXGQrXFwuP1xcZCplW1xcK1xcLV0qXFxkKy9pLnRlc3QobnVtKTtcclxuICAgIH07XHJcbiAgICBTY2llbnRpZmljLmxlYWRpbmdaZXJvZXMgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gbnVtLm1hdGNoKC9eKDAqKS4qJC8pO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbiAgICB9O1xyXG4gICAgU2NpZW50aWZpYy5yZW1vdmVMZWFkaW5nWmVyb2VzID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IG51bS5tYXRjaCgvXjAqKC4qKSQvKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xyXG4gICAgfTtcclxuXHJcbiAgICBTY2llbnRpZmljLnJlbW92ZVRyYWlsaW5nWmVyb2VzID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IG51bS5tYXRjaCgvMCokLyk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbnVtLnN1YnN0cmluZygwLCBudW0ubGVuZ3RoIC0gbWF0Y2hbMF0ubGVuZ3RoKSA6ICcnO1xyXG4gICAgfTtcclxuICAgIFNjaWVudGlmaWMucm91bmQgPSBmdW5jdGlvbiAoYywgbikge1xyXG4gICAgICAgIHZhciBjb2VmZiA9IG5yb3VuZChjLCBuKTtcclxuICAgICAgICB2YXIgbSA9IFN0cmluZyhjb2VmZikuc3BsaXQoJy4nKS5wb3AoKTtcclxuICAgICAgICB2YXIgZCA9IG4gLSBtLmxlbmd0aDtcclxuICAgICAgICAvL2lmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSBzaWduaWZpY2FudCBmaWd1cmVzXHJcbiAgICAgICAgaWYoZCA+IDApIHtcclxuICAgICAgICAgICAgY29lZmYgPSBjb2VmZiArIChuZXcgQXJyYXkoZCArIDEpLmpvaW4oMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29lZmY7XHJcbiAgICB9O1xyXG5cclxuLy9TY2llbnRpZmljID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8qXHJcbiAgICAgKiBKYXZhc2NyaXB0IGhhcyB0aGUgdG9FeHBvbmVudGlhbCBtZXRob2QgYnV0IHRoaXMgYWxsb3dzIHlvdSB0byB3b3JrIHdpdGggc3RyaW5nIGFuZCB0aGVyZWZvcmUgYW55IG51bWJlciBvZiBkaWdpdHMgb2YgeW91ciBjaG9vc2luZ1xyXG4gICAgICogRm9yIGV4YW1wbGUgU2NpZW50aWZpYygnNDY0NTg5NDk4NDQ5NDk2NDY3OTI0MTk3NTQ1NjI1MjQ3Njk1NDY0NTY5NTY4OTU5MTI0NTY4NDg5NTQ4NDU0Jyk7XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBTY2llbnRpZmljKG51bSkge1xyXG4gICAgICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIFNjaWVudGlmaWMpKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjaWVudGlmaWMobnVtKTtcclxuXHJcbiAgICAgICAgbnVtID0gU3RyaW5nKHR5cGVvZiBudW0gPT09ICd1bmRlZmluZWQnID8gMCA6IG51bSk7IC8vY29udmVydCB0byBhIHN0cmluZ1xyXG5cclxuICAgICAgICAvL3JlbW92ZSB0aGUgc2lnblxyXG4gICAgICAgIGlmKG51bS5zdGFydHNXaXRoKCctJykpIHtcclxuICAgICAgICAgICAgdGhpcy5zaWduID0gLTE7XHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBzaWduXHJcbiAgICAgICAgICAgIG51bSA9IG51bS5zdWJzdHIoMSwgbnVtLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNpZ24gPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoU2NpZW50aWZpYy5pc1NjaWVudGlmaWMobnVtKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZyb21TY2llbnRpZmljKG51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnZlcnQobnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgU2NpZW50aWZpYy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgZnJvbVNjaWVudGlmaWM6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gU3RyaW5nKG51bSkudG9Mb3dlckNhc2UoKS5zcGxpdCgnZScpO1xyXG4gICAgICAgICAgICB0aGlzLmNvZWZmID0gcGFydHNbMF07XHJcbiAgICAgICAgICAgIHRoaXMuZXhwb25lbnQgPSBwYXJ0c1sxXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udmVydDogZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgICAgICAvL2dldCB3aG9sZXMgYW5kIGRlY2ltYWxzXHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IG51bS5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICAvL21ha2UgemVybyBnbyBhd2F5XHJcbiAgICAgICAgICAgIHZhciB3ID0gcGFydHNbMF0gfHwgJyc7XHJcbiAgICAgICAgICAgIHZhciBkID0gcGFydHNbMV0gfHwgJyc7XHJcbiAgICAgICAgICAgIC8vY29udmVydCB6ZXJvIHRvIGJsYW5rIHN0cmluZ3NcclxuICAgICAgICAgICAgdyA9IFNjaWVudGlmaWMucmVtb3ZlTGVhZGluZ1plcm9lcyh3KTtcclxuICAgICAgICAgICAgZCA9IFNjaWVudGlmaWMucmVtb3ZlVHJhaWxpbmdaZXJvZXMoZCk7XHJcbiAgICAgICAgICAgIC8vZmluZCB0aGUgbG9jYXRpb24gb2YgdGhlIGRlY2ltYWwgcGxhY2Ugd2hpY2ggaXMgcmlnaHQgYWZ0ZXIgdGhlIHdob2xlc1xyXG4gICAgICAgICAgICB2YXIgZG90X2xvY2F0aW9uID0gdy5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vYWRkIHRoZW0gdG9nZXRoZXIgc28gd2UgY2FuIG1vdmUgdGhlIGRvdFxyXG4gICAgICAgICAgICB2YXIgbiA9IHcgKyBkO1xyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIG5leHQgbnVtYmVyXHJcbiAgICAgICAgICAgIHZhciB6ZXJvZXMgPSBTY2llbnRpZmljLmxlYWRpbmdaZXJvZXMobikubGVuZ3RoO1xyXG4gICAgICAgICAgICAvL3NldCB0aGUgZXhwb25lbnRcclxuICAgICAgICAgICAgdGhpcy5leHBvbmVudCA9IGRvdF9sb2NhdGlvbiAtICh6ZXJvZXMgKyAxKTtcclxuICAgICAgICAgICAgLy9zZXQgdGhlIGNvZWZmIGJ1dCBmaXJzdCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcclxuICAgICAgICAgICAgdmFyIGNvZWZmID0gU2NpZW50aWZpYy5yZW1vdmVMZWFkaW5nWmVyb2VzKG4pO1xyXG4gICAgICAgICAgICB0aGlzLmNvZWZmID0gY29lZmYuY2hhckF0KDApICsgJy4nICsgKGNvZWZmLnN1YnN0cigxLCBjb2VmZi5sZW5ndGgpIHx8ICcwJyk7XHJcblxyXG4gICAgICAgICAgICAvL3RoZSBjb2VmZiBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAgICB2YXIgZGVjID0gdGhpcy5jb2VmZi5zcGxpdCgnLicpWzFdIHx8ICcnOyAvL2lmIGl0J3MgdW5kZWZpbmVkIG9yIHplcm8gaXQncyBnb2luZyB0byBibGFua1xyXG5cclxuICAgICAgICAgICAgdGhpcy5kZWNwID0gZGVjID09PSAnMCcgPyAwIDogZGVjLmxlbmd0aDtcclxuICAgICAgICAgICAgLy9kZWNpbWFsc1xyXG4gICAgICAgICAgICB0aGlzLmRlYyA9IGQ7XHJcbiAgICAgICAgICAgIC8vd2hvbGVzXHJcbiAgICAgICAgICAgIHRoaXMud2hvbGVzID0gdztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm91bmQ6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmNvcHkoKTtcclxuXHJcbiAgICAgICAgICAgIG51bSA9IE51bWJlcihudW0pOyAvL2Nhc3QgdG8gbnVtYmVyIGZvciBzYWZldHlcclxuICAgICAgICAgICAgLy9zaW5jZSB3ZSBrbm93IGl0IGd1YXJhbnRlZWQgdG8gYmUgaW4gdGhlIGZvcm1hdCB7ZGlnaXR9e29wdGlvbmFsIGRvdH17b3B0aW9uYWwgZGlnaXRzfVxyXG4gICAgICAgICAgICAvL3dlIGNhbiByb3VuZCBiYXNlZCBvbiB0aGlzXHJcbiAgICAgICAgICAgIGlmKG51bSA9PT0gMClcclxuICAgICAgICAgICAgICAgIG4uY29lZmYgPSBuLmNvZWZmLmNoYXJBdCgwKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCB1cCB0byBuLTEgZGlnaXRzXHJcbiAgICAgICAgICAgICAgICB2YXIgcm91bmRlZCA9IHRoaXMuY29lZmYuc3Vic3RyaW5nKDAsIG51bSArIDEpO1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIG5leHQgdHdvXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF90d28gPSB0aGlzLmNvZWZmLnN1YnN0cmluZyhudW0gKyAxLCBudW0gKyAzKTtcclxuICAgICAgICAgICAgICAgIC8vdGhlIGV4dHJhIGRpZ2l0XHJcbiAgICAgICAgICAgICAgICB2YXIgZWQgPSBuZXh0X3R3by5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobmV4dF90d28uY2hhckF0KDEpID4gNClcclxuICAgICAgICAgICAgICAgICAgICBlZCsrO1xyXG5cclxuICAgICAgICAgICAgICAgIG4uY29lZmYgPSByb3VuZGVkICsgZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29weTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBTY2llbnRpZmljKDApO1xyXG4gICAgICAgICAgICBuLmNvZWZmID0gdGhpcy5jb2VmZjtcclxuICAgICAgICAgICAgbi5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XHJcbiAgICAgICAgICAgIG4uc2lnbiA9IHRoaXMuc2lnbjtcclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuXHJcbiAgICAgICAgICAgIGlmKFNldHRpbmdzLlNDSUVOVElGSUNfSUdOT1JFX1pFUk9fRVhQT05FTlRTICYmIHRoaXMuZXhwb25lbnQgPT09IDAgJiYgdGhpcy5kZWNwIDwgbikge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kZWNwID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHRoaXMud2hvbGVzO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHRoaXMuY29lZmY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29lZmYgPSB0eXBlb2YgbiA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvZWZmIDogU2NpZW50aWZpYy5yb3VuZCh0aGlzLmNvZWZmLCBNYXRoLm1pbihuLCB0aGlzLmRlY3AgfHwgMSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gdGhpcy5leHBvbmVudCA9PT0gMCA/IGNvZWZmIDogY29lZmYgKyAnZScgKyB0aGlzLmV4cG9uZW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2lnbiA9PT0gLTEgPyAnLScgOiAnJykgKyByZXR2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBTY2llbnRpZmljLmlzU2NpZW50aWZpYyA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICByZXR1cm4gL1xcZCtcXC4/XFxkKmVbXFwrXFwtXSpcXGQrL2kudGVzdChudW0pO1xyXG4gICAgfTtcclxuICAgIFNjaWVudGlmaWMubGVhZGluZ1plcm9lcyA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICB2YXIgbWF0Y2ggPSBudW0ubWF0Y2goL14oMCopLiokLyk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcclxuICAgIH07XHJcbiAgICBTY2llbnRpZmljLnJlbW92ZUxlYWRpbmdaZXJvZXMgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gbnVtLm1hdGNoKC9eMCooLiopJC8pO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbiAgICB9O1xyXG5cclxuICAgIFNjaWVudGlmaWMucmVtb3ZlVHJhaWxpbmdaZXJvZXMgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gbnVtLm1hdGNoKC8wKiQvKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBudW0uc3Vic3RyaW5nKDAsIG51bS5sZW5ndGggLSBtYXRjaFswXS5sZW5ndGgpIDogJyc7XHJcbiAgICB9O1xyXG5cclxuXHJcbi8vRnJhYyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBmdW5jdGlvbiBGcmFjKG4pIHtcclxuICAgICAgICBpZihuIGluc3RhbmNlb2YgRnJhYylcclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgaWYobiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZihpc0ludChuKSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm51bSA9IGJpZ0ludChuKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbiA9IGJpZ0ludCgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnJhYy5zaW1wbGUobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhYyA9IG4gaW5zdGFuY2VvZiBiaWdEZWMgPyBGcmFjdGlvbi5xdWlja0NvbnZlcnNpb24obikgOiBGcmFjdGlvbi5jb252ZXJ0KG4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5udW0gPSBuZXcgYmlnSW50KGZyYWNbMF0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZW4gPSBuZXcgYmlnSW50KGZyYWNbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZyYWMuc2ltcGxlKG4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcbiAgICAvL3NhZmUgdG8gdXNlIHdpdGggbmVnYXRpdmUgbnVtYmVycyBvciBvdGhlciB0eXBlc1xyXG4gICAgRnJhYy5jcmVhdGUgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIGlmKG4gaW5zdGFuY2VvZiBGcmFjKVxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICBuID0gbi50b1N0cmluZygpO1xyXG4gICAgICAgIHZhciBpc19uZWcgPSBuLmNoYXJBdCgwKSA9PT0gJy0nOyAvL2NoZWNrIGlmIGl0J3MgbmVnYXRpdmVcclxuICAgICAgICBpZihpc19uZWcpXHJcbiAgICAgICAgICAgIG4gPSBuLnN1YnN0cigxLCBuLmxlbmd0aCAtIDEpOyAvL3JlbW92ZSB0aGUgc2lnblxyXG4gICAgICAgIHZhciBmcmFjID0gbmV3IEZyYWMobik7XHJcbiAgICAgICAgLy9wdXQgdGhlIHNpZ24gYmFja1xyXG4gICAgICAgIGlmKGlzX25lZylcclxuICAgICAgICAgICAgZnJhYy5uZWdhdGUoKTtcclxuICAgICAgICByZXR1cm4gZnJhYztcclxuICAgIH07XHJcbiAgICBGcmFjLmlzRnJhYyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuIChvIGluc3RhbmNlb2YgRnJhYyk7XHJcbiAgICB9O1xyXG4gICAgRnJhYy5xdWljayA9IGZ1bmN0aW9uIChuLCBkKSB7XHJcbiAgICAgICAgdmFyIGZyYWMgPSBuZXcgRnJhYygpO1xyXG4gICAgICAgIGZyYWMubnVtID0gbmV3IGJpZ0ludChuKTtcclxuICAgICAgICBmcmFjLmRlbiA9IG5ldyBiaWdJbnQoZCk7XHJcbiAgICAgICAgcmV0dXJuIGZyYWM7XHJcbiAgICB9O1xyXG4gICAgRnJhYy5zaW1wbGUgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHZhciBuc3RyID0gU3RyaW5nKHNjaWVudGlmaWNUb0RlY2ltYWwobikpLFxyXG4gICAgICAgICAgICAgICAgbV9kYyA9IG5zdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgIG51bSA9IG1fZGMuam9pbignJyksXHJcbiAgICAgICAgICAgICAgICBkZW4gPSAxLFxyXG4gICAgICAgICAgICAgICAgbCA9IChtX2RjWzFdIHx8ICcnKS5sZW5ndGg7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgZGVuICs9ICcwJztcclxuICAgICAgICB2YXIgZnJhYyA9IEZyYWMucXVpY2sobnVtLCBkZW4pO1xyXG4gICAgICAgIHJldHVybiBmcmFjLnNpbXBsaWZ5KCk7XHJcbiAgICB9O1xyXG4gICAgRnJhYy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaXNPbmUoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG0uY2xvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihtLmlzT25lKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICBjLm51bSA9IGMubnVtLm11bHRpcGx5KG0ubnVtKTtcclxuICAgICAgICAgICAgYy5kZW4gPSBjLmRlbi5tdWx0aXBseShtLmRlbik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYy5zaW1wbGlmeSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBpZihtLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEaXZpc2lvbkJ5WmVybygnRGl2aXNpb24gYnkgemVybyBub3QgYWxsb3dlZCEnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWx0aXBseShtLmNsb25lKCkuaW52ZXJ0KCkpLnNpbXBsaWZ5KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5hZGQobS5jbG9uZSgpLm5lZygpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5lZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm51bSA9IHRoaXMubnVtLm11bHRpcGx5KC0xKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIHZhciBuMSA9IHRoaXMuZGVuLCBuMiA9IG0uZGVuLCBjID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IGMubnVtLCBiID0gbS5udW07XHJcbiAgICAgICAgICAgIGlmKG4xLmVxdWFscyhuMikpIHtcclxuICAgICAgICAgICAgICAgIGMubnVtID0gYS5hZGQoYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjLm51bSA9IGEubXVsdGlwbHkobjIpLmFkZChiLm11bHRpcGx5KG4xKSk7XHJcbiAgICAgICAgICAgICAgICBjLmRlbiA9IG4xLm11bHRpcGx5KG4yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGMuc2ltcGxpZnkoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vZDogZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IG0uY2xvbmUoKTtcclxuICAgICAgICAgICAgLy9tYWtlIHRoZWlyIGRlbm9taW5hdG9ycyBldmVuIGFuZCByZXR1cm4gdGhlIG1vZCBvZiB0aGVpciBudW1lcmF0b3JzXHJcbiAgICAgICAgICAgIGEubnVtID0gYS5udW0ubXVsdGlwbHkoYi5kZW4pO1xyXG4gICAgICAgICAgICBhLmRlbiA9IGEuZGVuLm11bHRpcGx5KGIuZGVuKTtcclxuICAgICAgICAgICAgYi5udW0gPSBiLm51bS5tdWx0aXBseSh0aGlzLmRlbik7XHJcbiAgICAgICAgICAgIGIuZGVuID0gYi5kZW4ubXVsdGlwbHkodGhpcy5kZW4pO1xyXG4gICAgICAgICAgICBhLm51bSA9IGEubnVtLm1vZChiLm51bSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhLnNpbXBsaWZ5KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW1wbGlmeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZ2NkID0gYmlnSW50LmdjZCh0aGlzLm51bSwgdGhpcy5kZW4pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5udW0gPSB0aGlzLm51bS5kaXZpZGUoZ2NkKTtcclxuICAgICAgICAgICAgdGhpcy5kZW4gPSB0aGlzLmRlbi5kaXZpZGUoZ2NkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbSA9IG5ldyBGcmFjKCk7XHJcbiAgICAgICAgICAgIG0ubnVtID0gbmV3IGJpZ0ludCh0aGlzLm51bSk7XHJcbiAgICAgICAgICAgIG0uZGVuID0gbmV3IGJpZ0ludCh0aGlzLmRlbik7XHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVjaW1hbDogZnVuY3Rpb24gKHByZWMpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB0aGlzLm51bS5pc05lZ2F0aXZlKCkgPyAnLScgOiAnJztcclxuICAgICAgICAgICAgaWYodGhpcy5udW0uZXF1YWxzKHRoaXMuZGVuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcxJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2dvIHBsdXMgb25lIGZvciByb3VuZGluZ1xyXG4gICAgICAgICAgICBwcmVjID0gcHJlYyB8fCBTZXR0aW5ncy5QUkVDSVNJT047XHJcbiAgICAgICAgICAgIHByZWMrKztcclxuICAgICAgICAgICAgdmFyIG5hcnIgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5udW0uYWJzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRoaXMuZGVuO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJlYzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdyA9IG4uZGl2aWRlKGQpLCAvL2RpdmlkZSBvdXQgd2hvbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IG4uc3VidHJhY3Qody5tdWx0aXBseShkKSk7IC8vZ2V0IHJlbWFpbmRlclxyXG5cclxuICAgICAgICAgICAgICAgIG5hcnIucHVzaCh3KTtcclxuICAgICAgICAgICAgICAgIGlmKHIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgbiA9IHIudGltZXMoMTApOyAvL3NoaWZ0IG9uZSBkZWMgcGxhY2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgd2hvbGUgPSBuYXJyLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGlmKG5hcnIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiArIHdob2xlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGkgPT09IHByZWMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIGxhc3QgdHdvIHNvIHdlIGNhbiByb3VuZCBpdFxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDI7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBsdC51bnNoaWZ0KG5hcnIucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgLy9wdXQgdGhlIGxhc3QgZGlnaXQgYmFjayBieSByb3VuZGluZyB0aGUgbGFzdCB0d29cclxuICAgICAgICAgICAgICAgIG5hcnIucHVzaChNYXRoLnJvdW5kKGx0LmpvaW4oJy4nKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVjID0gd2hvbGUudG9TdHJpbmcoKSArICcuJyArIG5hcnIuam9pbignJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzaWduICsgZGVjO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9EZWNpbWFsOiBmdW5jdGlvbiAocHJlYykge1xyXG4gICAgICAgICAgICBwcmVjID0gcHJlYyB8fCBTZXR0aW5ncy5QUkVDSVNJT047XHJcbiAgICAgICAgICAgIGlmKHByZWMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY2ltYWwocHJlYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtIC8gdGhpcy5kZW47XHJcbiAgICAgICAgfSxcclxuICAgICAgICBxY29tcGFyZTogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLm51bS5tdWx0aXBseShuLmRlbiksIG4ubnVtLm11bHRpcGx5KHRoaXMuZGVuKV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc05hTihuKSlcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgRnJhYyhuKTtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnFjb21wYXJlKG4pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHFbMF0uZXF1YWxzKHFbMV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWJzRXF1YWxzOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICBpZighaXNOYU4obikpXHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IEZyYWMobik7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5xY29tcGFyZShuKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBxWzBdLmFicygpLmVxdWFscyhxWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vbGF6eSBjaGVjayB0byBiZSBmaXhlZC4gU3VmZmljaWVudCBmb3Igbm93IGJ1dCB3aWxsIGNhdXNlIGZ1dHVyZSBwcm9ibGVtc1xyXG4gICAgICAgIGdyZWF0ZXJUaGFuOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICBpZighaXNOYU4obikpXHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IEZyYWMobik7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5xY29tcGFyZShuKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBxWzBdLmd0KHFbMV0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3RlOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbihuKSB8fCB0aGlzLmVxdWFscyhuKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGx0ZTogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVzc1RoYW4obikgfHwgdGhpcy5lcXVhbHMobik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsZXNzVGhhbjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgaWYoIWlzTmFOKG4pKVxyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBGcmFjKG4pO1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucWNvbXBhcmUobik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcVswXS5sdChxWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzSW50ZWdlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZW4uZXF1YWxzKDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubnVtID0gdGhpcy5udW0ubXVsdGlwbHkoLTEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGludmVydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuZGVuO1xyXG4gICAgICAgICAgICAvL3doeSBpbnZlcnQgMC8xPyBJdCdsbCBiZWNvbWUgMS8wIGFuZCB0aGF0J3MgYSBsaWUuXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLm51bS5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc25lZ2F0aXZlID0gdGhpcy5udW0uaXNOZWdhdGl2ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZW4gPSB0aGlzLm51bS5hYnMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubnVtID0gdDtcclxuICAgICAgICAgICAgICAgIGlmKGlzbmVnYXRpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5udW0gPSB0aGlzLm51bS5tdWx0aXBseSgtMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNPbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtLmVxdWFscygxKSAmJiB0aGlzLmRlbi5lcXVhbHMoMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaWduOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhYnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5udW0gPSB0aGlzLm51bS5hYnMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnY2Q6IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBGcmFjLnF1aWNrKGJpZ0ludC5nY2QoZi5udW0sIHRoaXMubnVtKSwgYmlnSW50LmxjbShmLmRlbiwgdGhpcy5kZW4pKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5kZW4uZXF1YWxzKDEpID8gdGhpcy5udW0udG9TdHJpbmcoKSArICcvJyArIHRoaXMuZGVuLnRvU3RyaW5nKCkgOiB0aGlzLm51bS50b1N0cmluZygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xyXG4vLyAgICAgICAgICAgIGlmKHRoaXMubnVtID09IDI0KSB0aHJvdyBuZXcgRXJyb3IoOTk5KVxyXG4gICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfQklHKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBiaWdEZWModGhpcy5udW0udG9TdHJpbmcoKSkuZGl2KG5ldyBiaWdEZWModGhpcy5kZW4udG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0gLyB0aGlzLmRlbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzTmVnYXRpdmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EZWNpbWFsKCkgPCAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4vL1N5bWJvbCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgc3ltYm9scyBlLmcuIHgsIHksIHosIGV0YyBvciBmdW5jdGlvbnMgYXJlIHdyYXBwZWQgaW4gdGhpcyBjbGFzcy4gQWxsIHN5bWJvbHMgaGF2ZSBhIG11bHRpcGxpZXIgYW5kIGEgZ3JvdXAuXHJcbiAgICAgKiBBbGwgc3ltYm9scyBleGNlcHQgZm9yIFwibnVtYmVycyAoZ3JvdXAgTilcIiBoYXZlIGEgcG93ZXIuXHJcbiAgICAgKiBAY2xhc3MgUHJpbWFyeSBkYXRhIHR5cGUgZm9yIHRoZSBQYXJzZXIuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqXHJcbiAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBTeW1ib2wob2JqKSB7XHJcbiAgICAgICAgdmFyIGlzSW5maW5pdHkgPSBvYmogPT09ICdJbmZpbml0eSc7XHJcbiAgICAgICAgLy8gVGhpcyBlbmFibGVzIHRoZSBjbGFzcyB0byBiZSBpbnN0YW50aWF0ZWQgd2l0aG91dCB0aGUgbmV3IG9wZXJhdG9yXHJcbiAgICAgICAgaWYoISh0aGlzIGluc3RhbmNlb2YgU3ltYm9sKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb252ZXJ0IGJpZyBudW1iZXJzIHRvIGEgc3RyaW5nXHJcbiAgICAgICAgaWYob2JqIGluc3RhbmNlb2YgYmlnRGVjKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IG9iai50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2RlZmluZSBudW1lcmljIHN5bWJvbHNcclxuICAgICAgICBpZigvXihcXC0/XFwrP1xcZCspXFwuP1xcZCplP1xcLT9cXCs/XFxkKi9pLnRlc3Qob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBiaWdEZWMpIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cCA9IE47XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBDT05TVF9IQVNIO1xyXG4gICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBuZXcgRnJhYyhvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2RlZmluZSBzeW1ib2xpYyBzeW1ib2xzXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBTO1xyXG4gICAgICAgICAgICB2YWxpZGF0ZU5hbWUob2JqKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9iajtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gbmV3IEZyYWMoMSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2luYXJ5ID0gb2JqID09PSBTZXR0aW5ncy5JTUFHSU5BUlk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNJbmZpbml0eSA9IGlzSW5maW5pdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0FzIG9mIDYuMC4wIHdlIHN3aXRjaGVkIHRvIGluZmluaXRlIHByZWNpc2lvbiBzbyBhbGwgb2JqZWN0cyBoYXZlIGEgcG93ZXJcclxuICAgICAgICAvL0FsdGhvdWdoIHRoaXMgaXMgc3RpbGwgcmVkdW5kYW50IGluIGNvbnN0YW50cywgaXQgc2ltcGxpZmllcyB0aGUgbG9naWMgaW5cclxuICAgICAgICAvL290aGVyIHBhcnRzIHNvIHdlJ2xsIGtlZXAgaXRcclxuICAgICAgICB0aGlzLnBvd2VyID0gbmV3IEZyYWMoMSk7XHJcblxyXG4gICAgICAgIC8vIEFkZGVkIHRvIHNpbGVuY2UgdGhlIHN0cmljdCB3YXJuaW5nLlxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHZhbmlsbGEgaW1hZ2luYXJ5IHN5bWJvbFxyXG4gICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAqL1xyXG4gICAgU3ltYm9sLmltYWdpbmFyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcyA9IG5ldyBTeW1ib2woU2V0dGluZ3MuSU1BR0lOQVJZKTtcclxuICAgICAgICBzLmltYWdpbmFyeSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gbmVyZGFtZXIncyByZXByZXNlbnRhdGlvbiBvZiBJbmZpbml0eVxyXG4gICAgICogQHBhcmFtIHtpbnR9IG5lZ2F0aXZlIC0xIHRvIHJldHVybiBuZWdhdGl2ZSBpbmZpbml0eVxyXG4gICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAqL1xyXG4gICAgU3ltYm9sLmluZmluaXR5ID0gZnVuY3Rpb24gKG5lZ2F0aXZlKSB7XHJcbiAgICAgICAgdmFyIHYgPSBuZXcgU3ltYm9sKCdJbmZpbml0eScpO1xyXG4gICAgICAgIGlmKG5lZ2F0aXZlID09PSAtMSlcclxuICAgICAgICAgICAgdi5uZWdhdGUoKTtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH07XHJcbiAgICBTeW1ib2wuc2hlbGwgPSBmdW5jdGlvbiAoZ3JvdXAsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbCA9IG5ldyBTeW1ib2wodmFsdWUpO1xyXG4gICAgICAgIHN5bWJvbC5ncm91cCA9IGdyb3VwO1xyXG4gICAgICAgIHN5bWJvbC5zeW1ib2xzID0ge307XHJcbiAgICAgICAgc3ltYm9sLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgIH07XHJcbiAgICAvL3NxcnQoeCkgLT4geF4oMS8yKVxyXG4gICAgU3ltYm9sLnVud3JhcFNRUlQgPSBmdW5jdGlvbiAoc3ltYm9sLCBhbGwpIHtcclxuICAgICAgICB2YXIgcCA9IHN5bWJvbC5wb3dlcjtcclxuICAgICAgICBpZihzeW1ib2wuZm5hbWUgPT09IFNRUlQgJiYgKHN5bWJvbC5pc0xpbmVhcigpIHx8IGFsbCkpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBzeW1ib2wuYXJnc1swXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0LnBvd2VyID0gdC5wb3dlci5tdWx0aXBseShuZXcgRnJhYygxIC8gMikpO1xyXG4gICAgICAgICAgICB0Lm11bHRpcGxpZXIgPSB0Lm11bHRpcGxpZXIubXVsdGlwbHkoc3ltYm9sLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICBzeW1ib2wgPSB0O1xyXG4gICAgICAgICAgICBpZihhbGwpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wucG93ZXIgPSBwLm11bHRpcGx5KG5ldyBGcmFjKDEgLyAyKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgfTtcclxuICAgIFN5bWJvbC5oeXAgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIGEgPSBhIHx8IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgYiA9IGIgfHwgbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICByZXR1cm4gXy5zcXJ0KF8uYWRkKF8ucG93KGEuY2xvbmUoKSwgbmV3IFN5bWJvbCgyKSksIF8ucG93KGIuY2xvbmUoKSwgbmV3IFN5bWJvbCgyKSkpKTtcclxuICAgIH07XHJcbiAgICAvL2NvbnZlcnRzIHRvIHBvbGFyIGZvcm0gYXJyYXlcclxuICAgIFN5bWJvbC50b1BvbGFyRm9ybUFycmF5ID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgIHZhciByZSwgaW0sIHIsIHRoZXRhO1xyXG4gICAgICAgIHJlID0gc3ltYm9sLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgaW0gPSBzeW1ib2wuaW1hZ3BhcnQoKTtcclxuICAgICAgICByID0gU3ltYm9sLmh5cChyZSwgaW0pO1xyXG4gICAgICAgIHRoZXRhID0gcmUuZXF1YWxzKDApID8gXy5wYXJzZSgncGkvMicpIDogXy50cmlnLmF0YW4oXy5kaXZpZGUoaW0sIHJlKSk7XHJcbiAgICAgICAgcmV0dXJuIFtyLCB0aGV0YV07XHJcbiAgICB9O1xyXG4gICAgLy9yZW1vdmVzIHBhcmVudGhlc2VzXHJcbiAgICBTeW1ib2wudW53cmFwUEFSRU5TID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgIGlmKHN5bWJvbC5mbmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSBzeW1ib2wuYXJnc1swXTtcclxuICAgICAgICAgICAgci5wb3dlciA9IHIucG93ZXIubXVsdGlwbHkoc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgci5tdWx0aXBsaWVyID0gci5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmZuYW1lID09PSAnJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2wudW53cmFwUEFSRU5TKHIpO1xyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgIH07XHJcbiAgICAvL3F1aWNrbHkgY3JlYXRlcyBhIFN5bWJvbFxyXG4gICAgU3ltYm9sLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcG93ZXIpIHtcclxuICAgICAgICBwb3dlciA9IHBvd2VyID09PSB1bmRlZmluZWQgPyAxIDogcG93ZXI7XHJcbiAgICAgICAgcmV0dXJuIF8ucGFyc2UoJygnICsgdmFsdWUgKyAnKV4oJyArIHBvd2VyICsgJyknKTtcclxuICAgIH07XHJcbiAgICBTeW1ib2wucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgbnRoIHJvb3QgYWNjb3VudGluZyBmb3Igcm91bmRpbmcgZXJyb3JzXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cclxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0TnRoOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCBjYWxjdWxhdGUgdGhlIHJvb3RcclxuICAgICAgICAgICAgdmFyIHJvb3QgPSBldmFsdWF0ZShfLnBvdyhfLnBhcnNlKHRoaXMubXVsdGlwbGllciksIF8ucGFyc2UobikuaW52ZXJ0KCkpKTtcclxuICAgICAgICAgICAgLy8gUm91bmQgb2YgYW55IGVycm9yc1xyXG4gICAgICAgICAgICB2YXIgcm91bmRlZCA9IF8ucGFyc2UobnJvdW5kKHJvb3QpKTtcclxuICAgICAgICAgICAgLy8gUmV2ZXJzZSB0aGUgcm9vdFxyXG4gICAgICAgICAgICB2YXIgZSA9IGV2YWx1YXRlKF8ucG93KHJvdW5kZWQsIF8ucGFyc2UobikpKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHJvdW5kZWQgcm9vdCBlcXVhbHMgdGhlIG9yaWdpbmFsIG51bWJlciB0aGVuIHdlJ3JlIGdvb2QgXHJcbiAgICAgICAgICAgIGlmKGUuZXF1YWxzKF8ucGFyc2UodGhpcy5tdWx0aXBsaWVyKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByb3VuZGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIHVucm91bmRlZCB2ZXJzaW9uXHJcbiAgICAgICAgICAgIHJldHVybiByb290O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHN5bWJvbCBpcyB0byB0aGUgbnRoIHBvd2VyXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNUb050aDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgLy8gU3RhcnQgYnkgY2hlY2sgaW4gdGhlIG11bHRpcGxpZXIgZm9yIHNxdWFyZW5lc3NcclxuICAgICAgICAgICAgLy8gRmlyc3QgZ2V0IHRoZSByb290IGJ1dCByb3VuZCBpdCBiZWNhdXNlIGN1cnJlbnRseSB3ZSBzdGlsbCBkZXBlbmQgXHJcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5nZXROdGgobik7XHJcbiAgICAgICAgICAgIHZhciBudGhNdWx0aXBsaWVyID0gaXNJbnQocm9vdCk7XHJcbiAgICAgICAgICAgIHZhciBudGhQb3dlcjtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBieSBhc3N1bWluZyB0aGF0IGFsbCB3aWxsIGJlIHNxdWFyZS5cclxuICAgICAgICAgICAgICAgIG50aFBvd2VyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIEFsbCBpdCB0YWtlcyBpcyBmb3Igb25lIG9mIHRoZSBzeW1ib2xzIHRvIG5vdCBoYXZlIGFuIGV2ZW4gcG93ZXJcclxuICAgICAgICAgICAgICAgIC8vIGUuZy4geF5uMSp5Xm4yIHJlcXVpcmVzIHRoYXQgYm90aCBuMSBhbmQgbjIgYXJlIGV2ZW5cclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc050aCA9IHguaXNUb050aChuKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWlzTnRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG50aFBvd2VyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcG93ZXIgaXMgZGl2aXNpYmxlIGJ5IG4gaWYgaXQncyBub3QgYSBudW1iZXIuXHJcbiAgICAgICAgICAgICAgICBudGhQb3dlciA9IHRoaXMuZ3JvdXAgPT09IE4gPyB0cnVlIDogaXNJbnQoXy5kaXZpZGUoXy5wYXJzZSh0aGlzLnBvd2VyKSwgXy5wYXJzZShuKSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnRoTXVsdGlwbGllciAmJiBudGhQb3dlcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiBhIHN5bWJvbCBpcyBzcXVhcmVcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzU3F1YXJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVG9OdGgoMik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgYSBzeW1ib2wgaXMgY3ViZVxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNDdWJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVG9OdGgoMyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgYSBzeW1ib2wgaXMgYSBiYXJlIHZhcmlhYmxlXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc1NpbXBsZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3dlci5lcXVhbHMoMSkgJiYgdGhpcy5tdWx0aXBsaWVyLmVxdWFscygxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNpbXBsaWZpZXMgdGhlIHBvd2VyIG9mIHRoZSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfSBhIGNsb25lIG9mIHRoZSBzeW1ib2xcclxuICAgICAgICAgKi9cclxuICAgICAgICBwb3dTaW1wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG93ZXJzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSB0aGlzLm11bHRpcGxpZXIuc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB4LnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vd2h5IHdhc3RlIHRpbWUgaWYgSSBjYW4ndCBkbyBhbnl0aGluZyBhbnl3YXlcclxuICAgICAgICAgICAgICAgICAgICBpZihpc1N5bWJvbChwKSB8fCBwLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBwb3dlcnMucHVzaChwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IG5ldyBGcmFjKGFycmF5TWluKHBvd2VycykpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaGFuZGxlIHRoZSBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gdGhpcy5tdWx0aXBsaWVyLnNpZ24oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHRoaXMubXVsdGlwbGllci5jbG9uZSgpLmFicygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZmFjdG9ycyA9IE1hdGgyLmlmYWN0b3IobSk7XHJcbiAgICAgICAgICAgICAgICAvL2lmIHdlIGhhdmUgYSBtdWx0aXBsaWVyIG9mIDY3NTAgYW5kIGEgbWluIG9mIDIgdGhlbiB0aGUgZmFjdG9ycyBhcmUgNV4zKjVeMyoyXHJcbiAgICAgICAgICAgICAgICAvL3dlIGNhbiB0aGVuIHJlZHVjZSBpdCB0byAyKjMqNSooMTUpXjJcclxuICAgICAgICAgICAgICAgIHZhciBvdXRfID0gbmV3IEZyYWMoMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5fID0gbmV3IEZyYWMoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIG1mYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgRnJhYyhtZmFjdG9yc1t4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIW4ubGVzc1RoYW4obWluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gbi5kaXZpZGUobWluKS5zdWJ0cmFjdChuZXcgRnJhYygxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluXyA9IGluXy5tdWx0aXBseShuZXcgRnJhYyh4KSk7IC8vbW92ZSB0aGUgZmFjdG9yIGluc2lkZSB0aGUgYnJhY2tldFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0XyA9IG91dF8ubXVsdGlwbHkoXy5wYXJzZShpbkJyYWNrZXRzKHgpICsgJ14nICsgaW5CcmFja2V0cyhuKSkubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBTeW1ib2woaW5fKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSB4LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5wb3dlciA9IHgucG93ZXIuZGl2aWRlKG1pbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkodCwgeCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeHQgPSBfLnN5bWZ1bmN0aW9uKFBBUkVOVEhFU0lTLCBbdF0pO1xyXG4gICAgICAgICAgICAgICAgeHQucG93ZXIgPSBtaW47XHJcbiAgICAgICAgICAgICAgICB4dC5tdWx0aXBsaWVyID0gc2lnbiA8IDAgPyBvdXRfLm5lZ2F0ZSgpIDogb3V0XztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0byBzZWUgaWYgdHdvIGZ1bmN0aW9ucyBhcmUgb2YgZXF1YWwgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbChzeW1ib2wpKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbChzeW1ib2wpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gc3ltYm9sLnZhbHVlICYmIHRoaXMucG93ZXIuZXF1YWxzKHN5bWJvbC5wb3dlcilcclxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLm11bHRpcGxpZXIuZXF1YWxzKHN5bWJvbC5tdWx0aXBsaWVyKVxyXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMuZ3JvdXAgPT09IHN5bWJvbC5ncm91cDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFiczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgZS5tdWx0aXBsaWVyLmFicygpO1xyXG4gICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIEdyZWF0ZXIgdGhhblxyXG4gICAgICAgIGd0OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbChzeW1ib2wpKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbChzeW1ib2wpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0NvbnN0YW50KCkgJiYgc3ltYm9sLmlzQ29uc3RhbnQoKSAmJiB0aGlzLm11bHRpcGxpZXIuZ3JlYXRlclRoYW4oc3ltYm9sLm11bHRpcGxpZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gR3JlYXRlciB0aGFuXHJcbiAgICAgICAgZ3RlOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbChzeW1ib2wpKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbChzeW1ib2wpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoc3ltYm9sKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDb25zdGFudCgpICYmIHN5bWJvbC5pc0NvbnN0YW50KCkgJiYgdGhpcy5tdWx0aXBsaWVyLmdyZWF0ZXJUaGFuKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIExlc3MgdGhhblxyXG4gICAgICAgIGx0OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbChzeW1ib2wpKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbChzeW1ib2wpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0NvbnN0YW50KCkgJiYgc3ltYm9sLmlzQ29uc3RhbnQoKSAmJiB0aGlzLm11bHRpcGxpZXIubGVzc1RoYW4oc3ltYm9sLm11bHRpcGxpZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gTGVzcyB0aGFuXHJcbiAgICAgICAgbHRlOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbChzeW1ib2wpKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbChzeW1ib2wpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoc3ltYm9sKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNDb25zdGFudCgpICYmIHN5bWJvbC5pc0NvbnN0YW50KCkgJiYgdGhpcy5tdWx0aXBsaWVyLmxlc3NUaGFuKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlY2F1c2UgbmVyZGFtZXIgZG9lc24ndCBncm91cCBzeW1ib2xzIGJ5IHBvbHlub21pYWxzIGJ1dFxyXG4gICAgICAgICAqIHJhdGhlciBhIGN1c3RvbSBncm91cGluZyBtZXRob2QsIHRoaXMgaGFzIHRvIGJlXHJcbiAgICAgICAgICogcmVpbnNlcnRlZCBpbiBvcmRlciB0byBtYWtlIHVzZSBvZiBtb3N0IGFsZ29yaXRobXMuIFRoaXMgZnVuY3Rpb25cclxuICAgICAgICAgKiBjaGVja3MgaWYgdGhlIHN5bWJvbCBtZWV0cyB0aGUgY3JpdGVyaWEgb2YgYSBwb2x5bm9taWFsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gbXVsdGl2YXJpYXRlXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNQb2x5OiBmdW5jdGlvbiAobXVsdGl2YXJpYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBnID0gdGhpcy5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5wb3dlcjtcclxuICAgICAgICAgICAgLy90aGUgcG93ZXIgbXVzdCBiZSBhIGludGVnZXIgc28gZmFpbCBpZiBpdCdzIG5vdFxyXG4gICAgICAgICAgICBpZighaXNJbnQocCkgfHwgcCA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vY29uc3RhbnRzIGFuZCBmaXJzdCBvcmRlcnNcclxuICAgICAgICAgICAgaWYoZyA9PT0gTiB8fCBnID09PSBTIHx8IHRoaXMuaXNDb25zdGFudCh0cnVlKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgdmFycyA9IHZhcmlhYmxlcyh0aGlzKTtcclxuICAgICAgICAgICAgaWYoZyA9PT0gQ0IgJiYgdmFycy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vdGhlIHZhcmlhYmxlIGlzIGFzc3VtZWQgdGhlIG9ubHkgb25lIHRoYXQgd2FzIGZvdW5kXHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHZhcnNbMF07XHJcbiAgICAgICAgICAgICAgICAvL2lmIG5vIHZhcmlhYmxlIHRoZW4gZ3Vlc3Mgd2hhdCE/IT8gV2UncmUgZG9uZSEhISBXZSBoYXZlIGEgcG9seW5vbWlhbC5cclxuICAgICAgICAgICAgICAgIGlmKCF2KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSB0aGlzLnN5bWJvbHNbeF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zcXJ0KHgpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltLmdyb3VwID09PSBGTiAmJiAhc3ltLmFyZ3NbMF0uaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXN5bS5jb250YWlucyh2KSAmJiAhc3ltLmlzQ29uc3RhbnQodHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vUEwgZ3JvdXBzLiBUaGVzZSBvbmx5IGZhaWwgaWYgYSBwb3dlciBpcyBub3QgYW4gaW50XHJcbiAgICAgICAgICAgIC8vdGhpcyBzaG91bGQgaGFuZGxlIGNhc2VzIHN1Y2ggYXMgeF4yKnRcclxuICAgICAgICAgICAgaWYodGhpcy5pc0NvbXBvc2l0ZSgpIHx8IGcgPT09IENCICYmIG11bHRpdmFyaWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy9mYWlsIGlmIHdlJ3JlIG5vdCBjaGVja2luZyBmb3IgbXVsdGl2YXJpYXRlIHBvbHlub21pYWxzXHJcbiAgICAgICAgICAgICAgICBpZighbXVsdGl2YXJpYXRlICYmIHZhcnMubGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvL2xvb3AgdGhvdWdoIHRoZSBzeW1ib2xzIGFuZCBjaGVjayBpZiB0aGV5IHF1YWxpZnlcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3dlJ3ZlIGFscmVhZHkgdGhlIHN5bWJvbHMgaWYgd2UncmUgbm90IGNoZWNraW5nIGZvciBtdWx0aXZhcmlhdGVzIGF0IHRoaXMgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAvL3NvIHdlIGNoZWNrIHRoZSBzdWItc3ltYm9sc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLnN5bWJvbHNbeF0uaXNQb2x5KG11bHRpdmFyaWF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAvL2FsbCB0ZXN0cyBtdXN0IGhhdmUgcGFzc2VkIHNvIHdlIG11c3QgYmUgZGVhbGluZyB3aXRoIGEgcG9seW5vbWlhbFxyXG4gICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9yZW1vdmVzIHRoZSByZXF1ZXN0ZWQgdmFyaWFibGUgZnJvbSB0aGUgc3ltYm9sIGFuZCByZXR1cm5zIHRoZSByZW1haW5kZXJcclxuICAgICAgICBzdHJpcFZhcjogZnVuY3Rpb24gKHgsIGV4Y2x1ZGVfeCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICBpZigodGhpcy5ncm91cCA9PT0gUEwgfHwgdGhpcy5ncm91cCA9PT0gUykgJiYgdGhpcy52YWx1ZSA9PT0geClcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woZXhjbHVkZV94ID8gMCA6IHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5ncm91cCA9PT0gQ0IgJiYgdGhpcy5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXMuY29udGFpbnMoeCwgdHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBzLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwubXVsdGlwbGllciA9IHJldHZhbC5tdWx0aXBsaWVyLm11bHRpcGx5KHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmdyb3VwID09PSBDUCAmJiAhdGhpcy5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmdyb3VwID09PSBDUCAmJiB0aGlzLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZighcy5jb250YWlucyh4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHMuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5tdWx0aXBsaWVyID0gdC5tdWx0aXBsaWVyLm11bHRpcGx5KHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvL0JJRyBUT0RPISEhIEl0IGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlXHJcbiAgICAgICAgICAgICAgICBpZihyZXR2YWwuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2wodGhpcy5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuZ3JvdXAgPT09IEVYICYmIHRoaXMucG93ZXIuY29udGFpbnMoeCwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2wodGhpcy5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuZ3JvdXAgPT09IEZOICYmIHRoaXMuY29udGFpbnMoeCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2wodGhpcy5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAvL3d0aD8gVGhpcyBzaG91bGQgdGVjaG5pY2FsbHkgYmUgdGhlIG11bHRpcGxpZXIuXHJcbiAgICAgICAgICAgICAgICAvL1VuZm9ydHVuYXRlbHkgdGhpcyBtZXRob2Qgd2Fzbid0IHZlcnkgd2VsbCB0aG91Z2h0IG91dCA6YCguXHJcbiAgICAgICAgICAgICAgICAvL3Nob3VsZCBiZTogcmV0dmFsID0gbmV3IFN5bWJvbCh0aGlzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgLy91c2U6ICgoMSt4XjIpKnNxcnQoLTEreF4yKSleKC0xKSBmb3IgY29ycmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vdGhpcyB3aWxsIGJyZWFrIGEgYnVuY2ggb2YgdW5pdCB0ZXN0cyBzbyBiZSByZWFkeSB0byBmb3IgdGhlIGxvbmcgaGF1bFxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gdGhpcy5jbG9uZSgpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL3JldHVybnMgc3ltYm9sIGluIGFycmF5IGZvcm0gd2l0aCB4IGFzIGJhc2UgZS5nLiBhKnheMitiKngrYyA9IFtjLCBiLCBhXS5cclxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbiAodiwgYXJyKSB7XHJcbiAgICAgICAgICAgIGFyciA9IGFyciB8fCB7XHJcbiAgICAgICAgICAgICAgICBhcnI6IFtdLFxyXG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAoeCwgaWR4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmFycltpZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJyW2lkeF0gPSBlID8gXy5hZGQoZSwgeCkgOiB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXA7XHJcblxyXG4gICAgICAgICAgICBpZihnID09PSBTICYmIHRoaXMuY29udGFpbnModikpIHtcclxuICAgICAgICAgICAgICAgIGFyci5hZGQobmV3IFN5bWJvbCh0aGlzLm11bHRpcGxpZXIpLCB0aGlzLnBvd2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuc3RyaXBWYXIodiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBfLmRpdmlkZSh0aGlzLmNsb25lKCksIGEuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHguaXNDb25zdGFudCgpID8gMCA6IHgucG93ZXI7XHJcbiAgICAgICAgICAgICAgICBhcnIuYWRkKGEsIHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gUEwgJiYgdGhpcy52YWx1ZSA9PT0gdikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4LCBwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyLmFkZCh4LnN0cmlwVmFyKHYpLCBwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgIC8vdGhlIGxvZ2ljOiB0aGV5J2xsIGJlIGJyb2tlbiBpbnRvIHN5bWJvbHMgc28gZS5nLiAoeF4yK3gpKzEgb3IgKGEqeF4yK2IqeCtjKVxyXG4gICAgICAgICAgICAgICAgLy9lYWNoIGNhc2UgaXMgaGFuZGxlZCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC50b0FycmF5KHYsIGFycik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuY29udGFpbnModikpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOZXJkYW1lclR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdG8gYXJyYXkhIEV4aXRpbmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFyci5hZGQodGhpcy5jbG9uZSgpLCAwKTsgLy9pdCdzIGp1c3QgYSBjb25zdGFudCB3cnQgdG8gdlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZmlsbCB0aGUgaG9sZXNcclxuICAgICAgICAgICAgYXJyID0gYXJyLmFycjsgLy9rZWVwIG9ubHkgdGhlIGFycmF5IHNpbmNlIHdlIGRvbid0IG5lZWQgdGhlIG9iamVjdCBhbnltb3JlXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBpZighYXJyW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIGFycltpXSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2NoZWNrcyB0byBzZWUgaWYgYSBzeW1ib2wgY29udGFucyBhIGZ1bmN0aW9uXHJcbiAgICAgICAgaGFzRnVuYzogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdmFyIGZuX2dyb3VwID0gdGhpcy5ncm91cCA9PT0gRk4gfHwgdGhpcy5ncm91cCA9PT0gRVg7XHJcbiAgICAgICAgICAgIGlmKGZuX2dyb3VwICYmICF2IHx8IGZuX2dyb3VwICYmIHRoaXMuY29udGFpbnModikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzW3hdLmhhc0Z1bmModikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN1YjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgYSA9ICFpc1N5bWJvbChhKSA/IF8ucGFyc2UoYSkgOiBhLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGIgPSAhaXNTeW1ib2woYikgPyBfLnBhcnNlKGIpIDogYi5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZihhLmdyb3VwID09PSBOIHx8IGEuZ3JvdXAgPT09IFApXHJcbiAgICAgICAgICAgICAgICBlcnIoJ0Nhbm5vdCBzdWJzdGl0dXRlIGEgbnVtYmVyLiBNdXN0IGJlIGEgdmFyaWFibGUnKTtcclxuICAgICAgICAgICAgdmFyIHNhbWVfcG93ID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgYV9pc191bml0X211bHRpcGxpZXIgPSBhLm11bHRpcGxpZXIuZXF1YWxzKDEpLFxyXG4gICAgICAgICAgICAgICAgICAgIG0gPSB0aGlzLm11bHRpcGxpZXIuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWw7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIEluIG9yZGVyIHRvIG1ha2UgdGhlIHN1YnN0aXR1dGlvbiB0aGUgYmFzZXMgaGF2ZSB0byBmaXJzdCBtYXRjaCB0YWtlXHJcbiAgICAgICAgICAgICAqICh4KzEpXnggLT4gKHgrMSk9eSB8fCB4XjIgLT4geD15XjZcclxuICAgICAgICAgICAgICogSW4gYm90aCBjYXNlcyB0aGUgZmlyc3QgY29uZGl0aW9uIGlzIHRoYXQgdGhlIGJhc2VzIG1hdGNoIHNvIHdlIGJlZ2luIHRoZXJlXHJcbiAgICAgICAgICAgICAqIEVpdGhlciBib3RoIGFyZSBQTCBvciBib3RoIGFyZSBub3QgUEwgYnV0IHdlIGNhbm5vdCBoYXZlIFBMIGFuZCBhIG5vbi1QTCBncm91cCBtYXRjaFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYodGhpcy52YWx1ZSA9PT0gYS52YWx1ZSAmJiAodGhpcy5ncm91cCAhPT0gUEwgJiYgYS5ncm91cCAhPT0gUEwgfHwgdGhpcy5ncm91cCA9PT0gUEwgJiYgYS5ncm91cCA9PT0gUEwpKSB7XHJcbiAgICAgICAgICAgICAgICAvL3dlIGNsZWFyZWQgdGhlIGZpcnN0IGh1cmRsZSBidXQgYSBzdWJzaXR1dGlvbiBtYXkgbm90IGJlIHBvc3NpYmxlIGp1c3QgeWV0XHJcbiAgICAgICAgICAgICAgICBpZihhX2lzX3VuaXRfbXVsdGlwbGllciB8fCBhLm11bHRpcGxpZXIuZXF1YWxzKHRoaXMubXVsdGlwbGllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihhLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gYjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhLnBvd2VyLmVxdWFscyh0aGlzLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1lX3BvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEubXVsdGlwbGllci5lcXVhbHModGhpcy5tdWx0aXBsaWVyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IG5ldyBGcmFjKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdGhlIG5leHQgdGhpbmcgaXMgdG8gaGFuZGxlIENCXHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5ncm91cCA9PT0gQ0IgfHwgdGhpcy5wcmV2aW91c0dyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJiZWQgPSBfLnBhcnNlKHguc3ViKGEsIGIpKTsgLy9wYXJzZSBpdCBhZ2FpbiBmb3Igc2FmZXR5XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIHN1YmJlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSB0aGlzLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYS5pc0NvbXBvc2l0ZSgpICYmIHN5bWJvbC5pc0NvbXBvc2l0ZSgpICYmIHN5bWJvbC5pc0xpbmVhcigpICYmIGEuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaW5kID0gZnVuY3Rpb24gKHN0YWNrLCBuZWVkbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHN0YWNrLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBzdGFjay5zeW1ib2xzW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgc3ltYm9sIGVxdWFscyB0aGUgbmVlZGxlIG9yIGl0J3Mgd2l0aGluIHRoZSBzdWItc3ltYm9scyB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0uaXNDb21wb3NpdGUoKSAmJiBmaW5kKHN5bSwgbmVlZGxlKSB8fCBzeW0uZXF1YWxzKG5lZWRsZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nbyBmaXNoXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIGEuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZmluZChzeW1ib2wsIGEuc3ltYm9sc1t4XSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKF8uc3VidHJhY3Qoc3ltYm9sLmNsb25lKCksIGEpLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCB4LnN1YihhLCBiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmdyb3VwID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcnNlZCB2YWx1ZSBjb3VsZCBiZSBhIGZ1bmN0aW9uIHNvIHBhcnNlIGFuZCBzdWJcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UodGhpcy52YWx1ZSkuc3ViKGEsIGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5ncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSB0aGlzLmFyZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWlzU3ltYm9sKGFyZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IF8ucGFyc2UoYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICBuYXJncy5wdXNoKGFyZy5zdWIoYSwgYikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbih0aGlzLmZuYW1lLCBuYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiB3ZSBkaWQgbWFuYWdlIGEgc3Vic3RpdHV0aW9uXHJcbiAgICAgICAgICAgIGlmKHJldHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoIXNhbWVfcG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdWJzdGl0dXRlIHRoZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdGhpcy5ncm91cCA9PT0gRVggPyB0aGlzLnBvd2VyLnN1YihhLCBiKSA6IF8ucGFyc2UodGhpcy5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3cgcmFpc2UgdGhlIHN5bWJvbCB0byB0aGF0IHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wb3cocmV0dmFsLCBwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3RyYW5zZmVyIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICByZXR2YWwubXVsdGlwbGllciA9IHJldHZhbC5tdWx0aXBsaWVyLm11bHRpcGx5KG0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZG9uZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIGFsbCBlbHNlIGZhaWxzXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc01vbm9taWFsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IFMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzW3hdLmdyb3VwICE9PSBTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzUGk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAgPT09IFMgJiYgdGhpcy52YWx1ZSA9PT0gJ3BpJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNpZ246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGllci5zaWduKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09ICdlJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzU1FSVDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbmFtZSA9PT0gU1FSVDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzQ29uc3RhbnQ6IGZ1bmN0aW9uIChjaGVja19hbGwsIGNoZWNrX3N5bWJvbHMpIHtcclxuICAgICAgICAgICAgaWYoY2hlY2tfc3ltYm9scyAmJiB0aGlzLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sc1t4XS5pc0NvbnN0YW50KHRydWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoY2hlY2tfYWxsID09PSAnZnVuY3Rpb25zJyAmJiB0aGlzLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0NvbnN0YW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZigheC5pc0NvbnN0YW50KGNoZWNrX2FsbCwgY2hlY2tfc3ltYm9scykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25zdGFudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0NvbnN0YW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihjaGVja19hbGwgPT09ICdhbGwnICYmICh0aGlzLmlzUGkoKSB8fCB0aGlzLmlzRSgpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGNoZWNrX2FsbCAmJiB0aGlzLmdyb3VwID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLmFyZ3NbaV0uaXNDb25zdGFudChjaGVja19hbGwpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoY2hlY2tfYWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTnVtZXJpY1N5bWJvbCh0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IENPTlNUX0hBU0g7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL3RoZSBzeW1ib2xzIGlzIGltYWdpbmFyeSBpZlxyXG4gICAgICAgIC8vMS4gbippXHJcbiAgICAgICAgLy8yLiBhK2IqaVxyXG4gICAgICAgIC8vMy4gYSppXHJcbiAgICAgICAgaXNJbWFnaW5hcnk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pbWFnaW5hcnkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzW3hdLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlYWwgcGFydCBvZiBhIHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVhbHBhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmltYWdpbmFyeSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIHgucmVhbHBhcnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGltYWdpbmFyeSBwYXJ0IG9mIGEgc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbWFncGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBTICYmIHRoaXMuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIHguaW1hZ3BhcnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gQ0IpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpcFZhcihTZXR0aW5ncy5JTUFHSU5BUlkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzSW50ZWdlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0NvbnN0YW50KCkgJiYgdGhpcy5tdWx0aXBsaWVyLmlzSW50ZWdlcigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNMaW5lYXI6IGZ1bmN0aW9uICh3cnQpIHtcclxuICAgICAgICAgICAgaWYod3J0KSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnZhbHVlID09PSB3cnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvd2VyLmVxdWFscygxKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNDb21wb3NpdGUoKSAmJiB0aGlzLnBvd2VyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMuc3ltYm9sc1t4XS5pc0xpbmVhcih3cnQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBDQiAmJiB0aGlzLnN5bWJvbHNbd3J0XSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xzW3dydF0uaXNMaW5lYXIod3J0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3dlci5lcXVhbHMoMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgc3ltYm9sIGhhcyBhIGZ1bmN0aW9uIGJ5IGEgc3BlY2lmaWVkIG5hbWUgb3Igd2l0aGluIGEgc3BlY2lmaWVkIGxpc3RcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gbmFtZXNcclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb250YWluc0Z1bmN0aW9uOiBmdW5jdGlvbiAobmFtZXMpIHtcclxuICAgICAgICAgICAgaWYodHlwZW9mIG5hbWVzID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIG5hbWVzID0gW25hbWVzXTtcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gRk4gJiYgbmFtZXMuaW5kZXhPZih0aGlzLmZuYW1lKSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzW3hdLmNvbnRhaW5zRnVuY3Rpb24obmFtZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtdWx0aXBseVBvd2VyOiBmdW5jdGlvbiAocDIpIHtcclxuICAgICAgICAgICAgLy9sZWF2ZSBvdXQgMVxyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBOICYmIHRoaXMubXVsdGlwbGllci5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgIHZhciBwMSA9IHRoaXMucG93ZXI7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwICE9PSBFWCAmJiBwMi5ncm91cCA9PT0gTikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwMi5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTiAmJiAhcC5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmVydChQKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvd2VyID0gcDEuZXF1YWxzKDEpID8gcC5jbG9uZSgpIDogcDEubXVsdGlwbHkocCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gUCAmJiBpc0ludCh0aGlzLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vYnJpbmcgaXQgYmFjayB0byBhbiBOXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IE1hdGgucG93KHRoaXMudmFsdWUsIHRoaXMucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnQoTik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdyb3VwICE9PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAxID0gbmV3IFN5bWJvbChwMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0KEVYKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucG93ZXIgPSBfLm11bHRpcGx5KHAxLCBwMik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0UG93ZXI6IGZ1bmN0aW9uIChwLCByZXRhaW5TaWduKSB7XHJcbiAgICAgICAgICAgIC8vbGVhdmUgb3V0IDFcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTiAmJiB0aGlzLm11bHRpcGxpZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBFWCAmJiAhaXNTeW1ib2wocCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSB0aGlzLnByZXZpb3VzR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wcmV2aW91c0dyb3VwO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGllciA9IG5ldyBGcmFjKHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBDT05TVF9IQVNIO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG93ZXIgPSBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzU3ltYm9saWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmKGlzU3ltYm9sKHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocC5ncm91cCA9PT0gTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Agc2hvdWxkIGJlIHRoZSBtdWx0aXBsaWVyIGluc3RlYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubXVsdGlwbGllcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1N5bWJvbGljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBpc1N5bWJvbGljID8gRVggOiBQO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3dlciA9IHA7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBOICYmIGdyb3VwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmVydChncm91cCwgcmV0YWluU2lnbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiBzeW1ib2wgaXMgbG9jYXRlZCBpbiB0aGUgZGVub21pbmF0b3JcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0ludmVyc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gRVgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMucG93ZXIubXVsdGlwbGllci5sZXNzVGhhbigwKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvd2VyIDwgMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ha2UgYSBkdXBsaWNhdGUgb2YgYSBzeW1ib2wgYnkgY29weWluZyBhIHByZWRlZmluZWQgbGlzdCBvZiBpdGVtcy5cclxuICAgICAgICAgKiBUaGUgbmFtZSAnY29weScgd291bGQgcHJvYmFibHkgYmUgYSBtb3JlIGFwcHJvcHJpYXRlIG5hbWUuXHJcbiAgICAgICAgICogdG8gYSBuZXcgc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGNcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBjIHx8IG5ldyBTeW1ib2woMCksXHJcbiAgICAgICAgICAgICAgICAgICAgLy9saXN0IG9mIHByb3BlcnRpZXMgZXhjbHVkaW5nIHBvd2VyIGFzIHRoaXMgbWF5IGJlIGEgc3ltYm9sIGFuZCB3b3VsZCBhbHNvIG5lZWQgdG8gYmUgYSBjbG9uZS5cclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAndmFsdWUnLCAnZ3JvdXAnLCAnbGVuZ3RoJywgJ3ByZXZpb3VzR3JvdXAnLCAnaW1hZ2luYXJ5JywgJ2ZuYW1lJywgJ2FyZ3MnLCAnaXNJbmZpbml0eScsICdzY2llbnRpZmljJ10sXHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IHByb3BlcnRpZXMubGVuZ3RoLCBpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgIGNsb25lLnN5bWJvbHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZS5zeW1ib2xzW3hdID0gdGhpcy5zeW1ib2xzW3hdLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpc1twcm9wZXJ0aWVzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVbcHJvcGVydGllc1tpXV0gPSB0aGlzW3Byb3BlcnRpZXNbaV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjbG9uZS5wb3dlciA9IHRoaXMucG93ZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgY2xvbmUubXVsdGlwbGllciA9IHRoaXMubXVsdGlwbGllci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvL2FkZCBiYWNrIHRoZSBmbGFnIHRvIHRyYWNrIGlmIHRoaXMgc3ltYm9sIGlzIGEgY29udmVyc2lvbiBzeW1ib2xcclxuICAgICAgICAgICAgaWYodGhpcy5pc0NvbnZlcnNpb24pXHJcbiAgICAgICAgICAgICAgICBjbG9uZS5pc0NvbnZlcnNpb24gPSB0aGlzLmlzQ29udmVyc2lvbjtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuaXNVbml0KVxyXG4gICAgICAgICAgICAgICAgY2xvbmUuaXNVbml0ID0gdGhpcy5pc1VuaXQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHN5bWJvbCBtdWx0aXBsaWVyIHRvIG9uZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGtlZXBTaWduIEtlZXAgdGhlIG11bHRpcGxpZXIgYXMgbmVnYXRpdmUgaWYgdGhlIG11bHRpcGxpZXIgaXMgbmVnYXRpdmUgYW5kIGtlZXBTaWduIGlzIHRydWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvVW5pdE11bHRpcGxpZXI6IGZ1bmN0aW9uIChrZWVwU2lnbikge1xyXG4gICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIubnVtID0gbmV3IGJpZ0ludCh0aGlzLm11bHRpcGxpZXIubnVtLmlzTmVnYXRpdmUoKSAmJiBrZWVwU2lnbiA/IC0xIDogMSk7XHJcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGllci5kZW4gPSBuZXcgYmlnSW50KDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgU3ltYm9sJ3MgcG93ZXIgdG8gb25lLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9MaW5lYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBpdCdzIGFscmVhZHkgbGluZWFyXHJcbiAgICAgICAgICAgIGlmKHRoaXMucG93ZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldFBvd2VyKG5ldyBGcmFjKDEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCB0aGUgc3ViLXN5bWJvbHMuIElmIG5vIHN1Yi1zeW1ib2xzIGV4aXN0IHRoZW4gaXQncyBjYWxsZWQgb24gaXRzZWxmXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgICAgICAgKiBAQHBhcmFtIHtCb29sZWFufSBkZWVwIElmIHRydWUgaXQgd2lsbCBpdHRlcmF0ZSBvdmVyIHRoZSBzdWItc3ltYm9scyB0aGVpciBzeW1ib2xzIGFzIHdlbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoZm4sIGRlZXApIHtcclxuICAgICAgICAgICAgaWYoIXRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCB0aGlzLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gdGhpcy5zeW1ib2xzW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bS5ncm91cCA9PT0gUEwgJiYgZGVlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHkgaW4gc3ltLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoeCwgc3ltLnN5bWJvbHNbeV0sIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBzeW0sIHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIG51bWVyaWMgdmFsdWUgdG8gYmUgcmV0dXJuZWQgZm9yIEphdmFzY3JpcHQuIEl0IHdpbGwgdHJ5IHRvXHJcbiAgICAgICAgICogcmV0dXJuIGEgbnVtYmVyIGFzIGZhciBhIHBvc3NpYmxlIGJ1dCBpbiBjYXNlIG9mIGEgcHVyZSBzeW1ib2xpY1xyXG4gICAgICAgICAqIHN5bWJvbCBpdCB3aWxsIGp1c3QgcmV0dXJuIGl0cyB0ZXh0IHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBOKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGllci52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5wb3dlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLm11bHRpcGxpZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQodGhpcywgJ2RlY2ltYWxzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0byBzZWUgaWYgYSBzeW1ib2xzIGhhcyBhIHBhcnRpY3VsYXIgdmFyaWFibGUgd2l0aGluIGl0LlxyXG4gICAgICAgICAqIFBhc3MgaW4gdHJ1ZSBhcyBzZWNvbmQgYXJndW1lbnQgdG8gaW5jbHVkZSB0aGUgcG93ZXIgb2YgZXhwb25lbnRpYWxzXHJcbiAgICAgICAgICogd2hpY2ggYXJlbid0IGNoZWNrIGJ5IGRlZmF1bHQuXHJcbiAgICAgICAgICogQGV4YW1wbGUgdmFyIHMgPSBfLnBhcnNlKCd4K3kreicpOyBzLmNvbnRhaW5zKCd5Jyk7XHJcbiAgICAgICAgICogLy9yZXR1cm5zIHRydWVcclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFyaWFibGVcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAodmFyaWFibGUsIGFsbCkge1xyXG4gICAgICAgICAgICAvL2NvbnRhaW5zIGV4cGVjdHMgYSBzdHJpbmdcclxuICAgICAgICAgICAgdmFyaWFibGUgPSBTdHJpbmcodmFyaWFibGUpO1xyXG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgIGlmKHRoaXMudmFsdWUgPT09IHZhcmlhYmxlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sc1t4XS5jb250YWlucyh2YXJpYWJsZSwgYWxsKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZyA9PT0gRk4gfHwgdGhpcy5wcmV2aW91c0dyb3VwID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuYXJnc1tpXS5jb250YWlucyh2YXJpYWJsZSwgYWxsKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGcgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAvL2V4aXQgb25seSBpZiBpdCBkb2VzXHJcbiAgICAgICAgICAgICAgICBpZihhbGwgJiYgdGhpcy5wb3dlci5jb250YWlucyh2YXJpYWJsZSwgYWxsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy52YWx1ZSA9PT0gdmFyaWFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gdmFyaWFibGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOZWdhdGVzIGEgc3ltYm9sc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IENQIHx8IHRoaXMuZ3JvdXAgPT09IFBMKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludmVydHMgYSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBvd2VyX29ubHlcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGludmVydDogZnVuY3Rpb24gKHBvd2VyX29ubHksIGFsbCkge1xyXG4gICAgICAgICAgICAvL2ludmVydCB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICBpZighcG93ZXJfb25seSlcclxuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGllciA9IHRoaXMubXVsdGlwbGllci5pbnZlcnQoKTtcclxuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIHJlc3RcclxuICAgICAgICAgICAgaWYoaXNTeW1ib2wodGhpcy5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG93ZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmdyb3VwID09PSBDQiAmJiBhbGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnBvd2VyICYmIHRoaXMuZ3JvdXAgIT09IE4pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3dlci5uZWdhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN5bWJvbHMgb2YgZ3JvdXAgQ1Agb3IgUEwgbWF5IGhhdmUgdGhlIG11bHRpcGxpZXIgYmVpbmcgY2FycmllZCBieVxyXG4gICAgICAgICAqIHRoZSB0b3AgbGV2ZWwgc3ltYm9sIGF0IGFueSBnaXZlbiB0aW1lIGUuZy4gMiooeCt5K3opLiBUaGlzIGlzXHJcbiAgICAgICAgICogY29udmVuaWVudCBpbiBtYW55IGNhc2VzLCBob3dldmVyIGluIHNvbWUgY2FzZXMgdGhlIG11bHRpcGxpZXIgbmVlZHNcclxuICAgICAgICAgKiB0byBiZSBjYXJyaWVkIGluZGl2aWR1YWxseSBlLmcuIDIqeCsyKnkrMip6LlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGRpc3RyaWJ1dGVzIHRoZSBtdWx0aXBsaWVyIG92ZXIgdGhlIGVudGlyZSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGlzdHJpYnV0ZU11bHRpcGxpZXI6IGZ1bmN0aW9uIChhbGwpIHtcclxuICAgICAgICAgICAgdmFyIGlzX29uZSA9IGFsbCA/IHRoaXMucG93ZXIuYWJzRXF1YWxzKDEpIDogdGhpcy5wb3dlci5lcXVhbHMoMSk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9scyAmJiBpc19vbmUgJiYgdGhpcy5ncm91cCAhPT0gQ0IgJiYgIXRoaXMubXVsdGlwbGllci5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuc3ltYm9sc1t4XTtcclxuICAgICAgICAgICAgICAgICAgICBzLm11bHRpcGxpZXIgPSBzLm11bHRpcGxpZXIubXVsdGlwbHkodGhpcy5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBzLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBleHBhbmRzIHRoZSBleHBvbmVudCBvdmVyIHRoZSBlbnRpcmUgc3ltYm9sIGp1c3QgbGlrZVxyXG4gICAgICAgICAqIGRpc3RyaWJ1dGVNdWx0aXBsaWVyXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaXN0cmlidXRlRXhwb25lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYoIXRoaXMucG93ZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucG93ZXI7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnN5bWJvbHNbeF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocy5ncm91cCA9PT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcy5wb3dlciA9IF8ubXVsdGlwbHkocy5wb3dlciwgbmV3IFN5bWJvbChwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbHNbeF0ucG93ZXIgPSB0aGlzLnN5bWJvbHNbeF0ucG93ZXIubXVsdGlwbHkocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2lsbCBhdHRlbXB0IHRvIHVwLWNvbnZlcnQgb3IgZG93bi1jb252ZXJ0IG9uZSBzeW1ib2xcclxuICAgICAgICAgKiBmcm9tIG9uZSBncm91cCB0byBhbm90aGVyLiBOb3QgYWxsIHN5bWJvbHMgYXJlIGNvbnZlcnRpYmxlIGZyb20gb25lXHJcbiAgICAgICAgICogZ3JvdXAgdG8gYW5vdGhlciBob3dldmVyLiBJbiB0aGF0IGNhc2UgdGhlIHN5bWJvbCB3aWxsIHJlbWFpblxyXG4gICAgICAgICAqIHVuY2hhbmdlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZ3JvdXBcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2luYXJ5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29udmVydDogZnVuY3Rpb24gKGdyb3VwLCBpbWFnaW5hcnkpIHtcclxuICAgICAgICAgICAgaWYoZ3JvdXAgPiBGTikge1xyXG4gICAgICAgICAgICAgICAgLy9tYWtlIGEgY2xvbmUgb2YgdGhpcyBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3AgPSB0aGlzLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9hdHRhY2ggYSBzeW1ib2xzIG9iamVjdCBhbmQgdXBncmFkZSB0aGUgZ3JvdXBcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9scyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc3ltYm9sIG9mIGdyb3VwIENCIGhvbGQgc3ltYm9scyBib3VuZCB0b2dldGhlciB0aHJvdWdoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy9iZWNhdXNlIG9mIGNvbW11dGF0aXZpdHkgdGhpcyBtdWx0aXBsaWVyIGNhbiB0ZWNobmljYWxseSBiZSBhbnl3aGVyZSB3aXRoaW4gdGhlIGdyb3VwXHJcbiAgICAgICAgICAgICAgICAgICAgLy90byBrZWVwIHRyYWNrIG9mIGl0IGhvd2V2ZXIgaXQncyBlYXNpZXIgdG8gYWx3YXlzIGhhdmUgdGhlIHRvcCBsZXZlbCBjYXJyeSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIGNwLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzZXQgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3AuYXJncyA9IHRoaXMuYXJncztcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZuYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vdGhlIHN5bWJvbCBtYXkgb3JpZ2luYXRlIGZyb20gdGhlIHN5bWJvbCBpIGJ1dCB0aGlzIHByb3BlcnR5IG5vIGxvbmdlciBob2xkcyB0cnVlXHJcbiAgICAgICAgICAgICAgICAvL2FmdGVyIGNvcHlpbmdcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaXNJbWdTeW1ib2wpXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaXNJbWdTeW1ib2w7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgLy9hdHRhY2ggYSBjbG9uZSBvZiB0aGlzIHN5bWJvbCB0byB0aGUgc3ltYm9scyBvYmplY3QgdXNpbmcgaXRzIHByb3BlciBrZXlcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sc1tjcC5rZXlGb3JHcm91cChncm91cCldID0gY3A7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAvL29iamVjdHMgYnkgZGVmYXVsdCBkb24ndCBoYXZlIGEgbGVuZ3RoIHByb3BlcnR5LiBIb3dldmVyLCBpbiBvcmRlciB0byBrZWVwIHRyYWNrIG9mIHRoZSBudW1iZXJcclxuICAgICAgICAgICAgICAgIC8vb2Ygc3ViLXN5bWJvbHMgd2UgaGF2ZSB0byBpbXBsaW1lbnQgb3VyIG93bi5cclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgLy8xXnggaXMganVzdCBvbmUgc28gY2hlY2sgYW5kIG1ha2Ugc3VyZVxyXG4gICAgICAgICAgICAgICAgaWYoISh0aGlzLmdyb3VwID09PSBOICYmIHRoaXMubXVsdGlwbGllci5lcXVhbHMoMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCAhPT0gRVgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNHcm91cCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5tdWx0aXBsaWVyLm51bS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgdGhlIGhhc2ggdG8gcmVmbGVjdCB0aGUgYWNjdXJhdGUgaGFzaFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRleHQodGhpcywgJ2hhc2gnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cCA9IEVYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gdGhpcy5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9scyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIG5ldyBTeW1ib2wodGhpcy5ncm91cCA9PT0gUCA/IG0gKiBNYXRoLnBvdyh0aGlzLnZhbHVlLCB0aGlzLnBvd2VyKSA6IG0pLmNsb25lKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IFAgJiYgdGhpcy5ncm91cCA9PT0gTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGltYWdpbmFyeSA/IHRoaXMubXVsdGlwbGllci5udW0udG9TdHJpbmcoKSA6IE1hdGguYWJzKHRoaXMubXVsdGlwbGllci5udW0udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRvVW5pdE11bHRpcGxpZXIoIWltYWdpbmFyeSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwID0gUDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIG9uZSBvZiB0aGUgcHJpbmNpcGFsIG1ldGhvZHMgdG8gbWFrZSBpdCBhbGwgcG9zc2libGUuXHJcbiAgICAgICAgICogSXQgcGVyZm9ybXMgY2xlYW51cCBhbmQgcHJlcCBvcGVyYXRpb25zIHdoZW5ldmVyIGEgc3ltYm9scyBpc1xyXG4gICAgICAgICAqIGluc2VydGVkLiBJZiB0aGUgc3ltYm9scyByZXN1bHRzIGluIGEgMSBpbiBhIENCIChtdWx0aXBsaWNhdGlvbilcclxuICAgICAgICAgKiBncm91cCBmb3IgaW5zdGFuY2UgaXQgd2lsbCByZW1vdmUgdGhlIHJlZHVuZGFudCBzeW1ib2wuIFNpbWlsYXJseVxyXG4gICAgICAgICAqIGluIGEgc3ltYm9sIG9mIGdyb3VwIFBMIG9yIENQIChzeW1ib2xzIGdsdWVkIGJ5IG11bHRpcGxpY2F0aW9uKSBpdFxyXG4gICAgICAgICAqIHdpbGwgcmVtb3ZlIGFueSBkYW5nbGluZyB6ZXJvZXMgZnJvbSB0aGUgc3ltYm9sLiBJdCB3aWxsIGFsc29cclxuICAgICAgICAgKiB1cC1jb252ZXJ0IG9yIGRvd24tY29udmVydCBhIHN5bWJvbCBpZiBpdCBkZXRlY3RzIHRoYXQgaXQnc1xyXG4gICAgICAgICAqIGluY29ycmVjdGx5IGdyb3VwZWQuIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0IHRoaXMgbWV0aG9kIGlzIG5vdFxyXG4gICAgICAgICAqIGNhbGxlZCBkaXJlY3RseSBidXQgcmF0aGVyIGJ5IHRoZSAnYXR0YWNoJyBtZXRob2QgZm9yIGFkZGl0aW9uIGdyb3Vwc1xyXG4gICAgICAgICAqIGFuZCB0aGUgJ2NvbWJpbmUnIG1ldGhvZCBmb3IgbXVsdGlwbGljYXRpb24gZ3JvdXBzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zZXJ0OiBmdW5jdGlvbiAoc3ltYm9sLCBhY3Rpb24pIHtcclxuICAgICAgICAgICAgLy90aGlzIGNoZWNrIGNhbiBiZSByZW1vdmVkIGJ1dCBzYXZlcyBhIGxvdCBvZiBhZ2dyYXZhdGlvbiB3aGVuIHRyeWluZyB0byBodW50IGRvd25cclxuICAgICAgICAgICAgLy9hIGJ1Zy4gSWYgbGVmdCwgeW91IHdpbGwgaW5zdGFudGx5IGtub3cgdGhhdCB0aGUgZXJyb3IgY2FuIG9ubHkgYmUgYmV0d2VlbiAyIHN5bWJvbHMuXHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbChzeW1ib2wpKVxyXG4gICAgICAgICAgICAgICAgZXJyKCdPYmplY3QgJyArIHN5bWJvbCArICcgaXMgbm90IG9mIHR5cGUgU3ltYm9sIScpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZihncm91cCA+IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHN5bWJvbC5rZXlGb3JHcm91cChncm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0ga2V5IGluIHRoaXMuc3ltYm9scyA/IHRoaXMuc3ltYm9sc1trZXldIDogZmFsc2U7IC8vY2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgc3ltYm9sIHRoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYWN0aW9uID09PSAnYWRkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZW0gdG9nZXRoZXIgdXNpbmcgdGhlIHBhcnNlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW1ib2xzW2hhc2hdID0gXy5hZGQoZXhpc3RpbmcsIHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBhZGRpdGlvbiByZXN1bHRlZCBpbiBhIHplcm8gbXVsdGlwbGllciByZW1vdmUgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sc1toYXNoXS5tdWx0aXBsaWVyLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnN5bWJvbHNbaGFzaF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0KE4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBuZXcgRnJhYygwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbHNba2V5XSA9IHN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhpcyBpcyBvZiBncm91cCBQIGFuZCB1bndyYXAgYmVmb3JlIGluc2VydGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IFAgJiYgaXNJbnQoc3ltYm9sLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmNvbnZlcnQoTik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJhbnNmZXIgdGhlIG11bHRpcGxpZXIgdG8gdGhlIHVwcGVyIHN5bWJvbCBidXQgb25seSBpZiB0aGUgc3ltYm9sIG51bWVyaWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwICE9PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gdGhpcy5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wucGFyZW5zID0gc3ltYm9sLm11bHRpcGxpZXIubGVzc1RoYW4oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSB0aGlzLm11bHRpcGxpZXIubXVsdGlwbHkoc3ltYm9sLm11bHRpcGxpZXIuY2xvbmUoKS5hYnMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9Vbml0TXVsdGlwbGllcih0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGJlY2F1c2UgdGhlIHN5bWJvbCBtYXkgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLm11bHRpcGx5KHJlbW92ZSh0aGlzLnN5bWJvbHMsIGtleSksIHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gdGhpcy5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sKDEpOyAvL3RoZSBkaXJ0eSB3b3JrIGdldHMgZG9uZSBkb3duIHRoZSBsaW5lIHdoZW4gaXQgZGV0ZWN0cyAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2xlYW4gdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kb24ndCBpbnNlcnQgdGhlIHN5bWJvbCBpZiBpdCdzIDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXN5bWJvbC5pc09uZSh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW1ib2xzW2tleV0gPSBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmVnYXRlKCk7IC8vcHV0IGJhY2sgdGhlIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jbGVhbiB1cFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnQoTik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGUgdGhlIGhhc2hcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBDUCB8fCB0aGlzLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUhhc2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy90aGUgaW5zZXJ0IG1ldGhvZCBmb3IgYWRkaXRpb25cclxuICAgICAgICBhdHRhY2g6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoaXNBcnJheShzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ltYm9sLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHN5bWJvbFtpXSwgJ2FkZCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHN5bWJvbCwgJ2FkZCcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy90aGUgaW5zZXJ0IG1ldGhvZCBmb3IgbXVsdGlwbGljYXRpb25cclxuICAgICAgICBjb21iaW5lOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKGlzQXJyYXkoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydChzeW1ib2xbaV0sICdtdWx0aXBseScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHN5bWJvbCwgJ211bHRpcGx5Jyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFueSBtYWpvciBcInN1cmdlcnlcIiBvbiBhIHN5bWJvbC5cclxuICAgICAgICAgKiBJdCB1cGRhdGVzIHRoZSBoYXNoIG9mIHRoZSBzeW1ib2wgZm9yIGV4YW1wbGUgaWYgdGhlIGZuYW1lIG9mIGFcclxuICAgICAgICAgKiBmdW5jdGlvbiBoYXMgY2hhbmdlZCBpdCB3aWxsIHVwZGF0ZSB0aGUgaGFzaCBvZiB0aGUgc3ltYm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZUhhc2g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTilcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IHRoaXMuYXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNfcGFyZW5zID0gdGhpcy5mbmFtZSA9PT0gUEFSRU5USEVTSVM7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyArPSAoaSA9PT0gMCA/ICcnIDogJywnKSArIHRleHQoYXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm5fbmFtZSA9IGlzX3BhcmVucyA/ICcnIDogdGhpcy5mbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBmbl9uYW1lICsgKGlzX3BhcmVucyA/IGNvbnRlbnRzIDogaW5CcmFja2V0cyhjb250ZW50cykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoISh0aGlzLmdyb3VwID09PSBTIHx8IHRoaXMuZ3JvdXAgPT09IFBMKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRleHQodGhpcywgJ2hhc2gnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdGhpcyBmdW5jdGlvbiBkZWZpbmVzIGhvdyBldmVyeSBncm91cCBpbiBzdG9yZWQgd2l0aGluIGEgZ3JvdXAgb2ZcclxuICAgICAgICAgKiBoaWdoZXIgb3JkZXIgdGhpbmsgb2YgaXQgYXMgdGhlIHN3aXRjaGJvYXJkIGZvciB0aGUgbGlicmFyeS4gSXRcclxuICAgICAgICAgKiBkZWZpbmVzIHRoZSBoYXNoZXMgZm9yIHN5bWJvbHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGdyb3VwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAga2V5Rm9yR3JvdXA6IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgIHZhciBrZXk7XHJcblxyXG4gICAgICAgICAgICBpZihnID09PSBOKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gUyB8fCBnID09PSBQKSB7XHJcbiAgICAgICAgICAgICAgICBpZihncm91cCA9PT0gUEwpXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wb3dlci50b0RlY2ltYWwoKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgIGlmKGdyb3VwID09PSBQTClcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBvd2VyLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRleHQodGhpcywgJ2hhc2gnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBvcmRlciBpcyByZXZlcnNlZCB0aGVuIHdlJ2xsIGFzc3VtZSBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBwb3NzaWJsZSBmdXR1cmUgZGlsZW1tYVxyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPT09IENCKVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRleHQodGhpcywgJ2hhc2gnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5wb3dlci5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBpbkJyYWNrZXRzKHRleHQodGhpcywgJ2hhc2gnKSkgKyBTZXR0aW5ncy5QT1dFUl9PUEVSQVRPUiArIHRoaXMucG93ZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBQTClcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBvd2VyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihnID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGV4dCh0aGlzLCAnaGFzaCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPT09IFBMKVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucG93ZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICBpZihncm91cCA9PT0gUEwpXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wb3dlci50b0RlY2ltYWwoKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0ZXh0KHRoaXMsICdoYXNoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihnID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPT09IFBMKVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRleHQodGhpcy5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGV4dCh0aGlzLCAnaGFzaCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3ltYm9scyBhcmUgdHlwaWNhbGx5IHN0b3JlZCBpbiBhbiBvYmplY3Qgd2hpY2ggd29ya3MgZmluZSBmb3IgbW9zdFxyXG4gICAgICAgICAqIGNhc2VzIGJ1dCBwcmVzZW50cyBhIHByb2JsZW0gd2hlbiB0aGUgb3JkZXIgb2YgdGhlIHN5bWJvbHMgbWFrZXNcclxuICAgICAgICAgKiBhIGRpZmZlcmVuY2UuIFRoaXMgZnVuY3Rpb24gc2ltcGx5IGNvbGxlY3RzIGFsbCB0aGUgc3ltYm9scyBhbmRcclxuICAgICAgICAgKiByZXR1cm5zIHRoZW0gYXMgYW4gYXJyYXkuIElmIGEgZnVuY3Rpb24gaXMgc3VwcGxpZWQgdGhlbiB0aGF0XHJcbiAgICAgICAgICogZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5IHN5bWJvbCBjb250YWluZWQgd2l0aGluIHRoZSBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0XHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydF9mblxyXG4gICAgICAgICAqIEBAcGFyYW0ge0Jvb2xlYW59IGV4cGFuZF9zeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29sbGVjdFN5bWJvbHM6IGZ1bmN0aW9uIChmbiwgb3B0LCBzb3J0X2ZuLCBleHBhbmRfc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xsZWN0ZWQgPSBbXTtcclxuICAgICAgICAgICAgaWYoIXRoaXMuc3ltYm9scylcclxuICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5zeW1ib2xzW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGV4cGFuZF9zeW1ib2wgJiYgKHN5bWJvbC5ncm91cCA9PT0gUEwgfHwgc3ltYm9sLmdyb3VwID09PSBDUCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkID0gY29sbGVjdGVkLmNvbmNhdChzeW1ib2wuY29sbGVjdFN5bWJvbHMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkLnB1c2goZm4gPyBmbihzeW1ib2wsIG9wdCkgOiBzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHNvcnRfZm4gPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBzb3J0X2ZuID0gdW5kZWZpbmVkOyAvL1dURiBGaXJlZm94PyBTZXJpb3VzbHk/XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGVkLnNvcnQoc29ydF9mbik7Ly9zb3J0IGhvcGVmdWxseSBnaXZlcyB1cyBzb21lIHNvcnQgb2YgY29uc2lzdGVuY3lcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxhdGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBsYXRleDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gTGFUZVgubGF0ZXgodGhpcywgb3B0aW9uKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHRleHQgcmVwcmVzZW50YXRpb24gb2YgYSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0ZXh0OiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0KHRoaXMsIG9wdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byAxLiBlLmcuIHheMCBvciAxIDopXHJcbiAgICAgICAgICogQEBwYXJhbSB7Ym9vbH0gYWJzIENvbXBhcmVzIHRoZSBhYnNvbHV0ZSB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzT25lOiBmdW5jdGlvbiAoYWJzKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gYWJzID8gJ2Fic0VxdWFscycgOiAnZXF1YWxzJztcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTilcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGxpZXJbZl0oMSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvd2VyLmVxdWFscygwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzQ29tcG9zaXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBnID0gdGhpcy5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICBwZyA9IHRoaXMucHJldmlvdXNHcm91cDtcclxuICAgICAgICAgICAgcmV0dXJuIGcgPT09IENQIHx8IGcgPT09IFBMIHx8IHBnID09PSBQTCB8fCBwZyA9PT0gQ1A7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0NvbWJpbmF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBnID0gdGhpcy5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICBwZyA9IHRoaXMucHJldmlvdXNHcm91cDtcclxuICAgICAgICAgICAgcmV0dXJuIGcgPT09IENCIHx8IHBnID09PSBDQjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxlc3NUaGFuOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsaWVyLmxlc3NUaGFuKG4pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3JlYXRlclRoYW46IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbChuKSkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBTeW1ib2wobik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IHRlbGwgZm9yIHN1cmUgaWYgYSBpcyBncmVhdGVyIHRoYW4gYmUgaWYgdGhleSdyZSBub3QgYm90aCBudW1iZXJzXHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzQ29uc3RhbnQodHJ1ZSkgfHwgIW4uaXNDb25zdGFudCh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsaWVyLmdyZWF0ZXJUaGFuKG4ubXVsdGlwbGllcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQncyB0aGUgZGVub21pbmF0b3Igb2YgdGhlIHN5bWJvbCBpZiB0aGUgc3ltYm9sIGlzIG9mIGNsYXNzIENCIChtdWx0aXBsaWNhdGlvbilcclxuICAgICAgICAgKiB3aXRoIG90aGVyIGNsYXNzZXMgdGhlIHN5bWJvbCBpcyBlaXRoZXIgdGhlIGRlbm9taW5hdG9yIG9yIG5vdC5cclxuICAgICAgICAgKiBUYWtlIHheLTEreF4tMi4gSWYgdGhlIHN5bWJvbCB3YXMgdG8gYmUgbWl4ZWQgc3VjaCBhcyB4K3heLTIgdGhlbiB0aGUgc3ltYm9sIGRvZXNuJ3QgaGF2ZSBoYXZlIGFuIGV4Y2x1c2l2ZVxyXG4gICAgICAgICAqIGRlbm9taW5hdG9yIGFuZCBoYXMgdG8gYmUgZm91bmQgYnkgbG9va2luZyBhdCB0aGUgYWN0dWFsIHN5bWJvbHMgdGhlbXNlbHZlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXREZW5vbTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsLCBzeW1ib2w7XHJcbiAgICAgICAgICAgIHN5bWJvbCA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy9lLmcuIDEvKHgqKHgrMSkpXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IENCICYmIHRoaXMucG93ZXIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgLy9pZiB0aGUgc3ltYm9sIGFscmVhZHkgaXMgdGhlIGRlbm9taW5hdG9yLi4uIERPTkUhISFcclxuICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIuZGVuKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwucG93ZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KGQsIHJldHZhbCk7IC8vcHV0IGJhY2sgdGhlIGNvZWZmXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyLmRlbik7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gc3ltYm9sLnN5bWJvbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLnN5bWJvbHNbeF0ucG93ZXIgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgc3ltYm9sLnN5bWJvbHNbeF0uY2xvbmUoKS5pbnZlcnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShzeW1ib2wubXVsdGlwbGllci5kZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0TnVtOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXR2YWwsIHN5bWJvbDtcclxuICAgICAgICAgICAgc3ltYm9sID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICAvL2UuZy4gMS8oeCooeCsxKSlcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBDQiAmJiBzeW1ib2wucG93ZXIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG4gICAgICAgICAgICAvL2lmIHRoZSBzeW1ib2wgYWxyZWFkeSBpcyB0aGUgZGVub21pbmF0b3IuLi4gRE9ORSEhIVxyXG4gICAgICAgICAgICBpZihzeW1ib2wucG93ZXIuZ3JlYXRlclRoYW4oMCkgJiYgc3ltYm9sLmdyb3VwICE9PSBDQikge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyLm51bSksIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShzeW1ib2wubXVsdGlwbGllci5udW0pO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih4LnBvd2VyID4gMCB8fCB4Lmdyb3VwID09PSBFWCAmJiB4LnBvd2VyLm11bHRpcGxpZXIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCB4LmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShzeW1ib2wubXVsdGlwbGllci5udW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbi8vUGFyc2VyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvL1VzZXMgbW9kaWZpZWQgU2h1bnRpbmcteWFyZCBhbGdvcml0aG0uIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2h1bnRpbmcteWFyZF9hbGdvcml0aG1cclxuICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcclxuICAgICAgICAvL1BvaW50IHRvIHRoZSBsb2NhbCBwYXJzZXIgaW5zdGVhZCBvZiB0aGUgZ2xvYmFsIG9uZVxyXG4gICAgICAgIHZhciBfID0gdGhpcztcclxuICAgICAgICB2YXIgYmluID0ge307XHJcbiAgICAgICAgdmFyIHByZXByb2Nlc3NvcnMgPSB7bmFtZXM6IFtdLCBhY3Rpb25zOiBbXX07XHJcblxyXG4vL1BhcnNlci5jbGFzc2VzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgIGZ1bmN0aW9uIFNsaWNlKHVwcGVyLCBsb3dlcikge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdXBwZXI7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbG93ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICBTbGljZS5wcm90b3R5cGUuaXNDb25zdGFudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuaXNDb25zdGFudCgpICYmIHRoaXMuZW5kLmlzQ29uc3RhbnQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFNsaWNlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dCh0aGlzLnN0YXJ0KSArICc6JyArIHRleHQodGhpcy5lbmQpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsYXNzIHVzZWQgdG8gY29sbGVjdCBhcmd1bWVudHMgZm9yIGZ1bmN0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtQYXJzZXIuQ29sbGVjdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaChlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLmdldEl0ZW1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5wcmV0dHlfcHJpbnQodGhpcy5lbGVtZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xsZWN0aW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgaWYoZSlcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uYXBwZW5kKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBUb2tlbihub2RlLCBub2RlX3R5cGUsIGNvbHVtbikge1xyXG4gICAgICAgICAgICB0aGlzLnR5cGUgPSBub2RlX3R5cGU7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBub2RlO1xyXG4gICAgICAgICAgICBpZihjb2x1bW4gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uICsgMTtcclxuICAgICAgICAgICAgaWYobm9kZV90eXBlID09PSBUb2tlbi5PUEVSQVRPUikge1xyXG4gICAgICAgICAgICAgICAgLy9jb3B5IGV2ZXJ5dGhpbmcgb3ZlciBmcm9tIHRoZSBvcGVyYXRvclxyXG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gb3BlcmF0b3JzW25vZGVdO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIG9wZXJhdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbeF0gPSBvcGVyYXRvclt4XTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihub2RlX3R5cGUgPT09IFRva2VuLkZVTkNUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZWNlZGVuY2UgPSBUb2tlbi5NQVhfUFJFQ0VERU5DRTsgLy9sZWF2ZSBlbm91Z2ggcm9vblxyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0QXNzb2MgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBUb2tlbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmlzX3ByZWZpeClcclxuICAgICAgICAgICAgICAgIHJldHVybiAnYCcgKyB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vc29tZSBjb25zdGFudHNcclxuICAgICAgICBUb2tlbi5PUEVSQVRPUiA9ICdPUEVSQVRPUic7XHJcbiAgICAgICAgVG9rZW4uVkFSSUFCTEVfT1JfTElURVJBTCA9ICdWQVJJQUJMRV9PUl9MSVRFUkFMJztcclxuICAgICAgICBUb2tlbi5GVU5DVElPTiA9ICdGVU5DVElPTic7XHJcbiAgICAgICAgVG9rZW4uVU5JVCA9ICdVTklUJztcclxuICAgICAgICBUb2tlbi5LRVlXT1JEID0gJ0tFWVdPUkQnO1xyXG4gICAgICAgIFRva2VuLk1BWF9QUkVDRURFTkNFID0gOTk5O1xyXG4gICAgICAgIC8vY3JlYXRlIGxpbmsgdG8gY2xhc3Nlc1xyXG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IHtcclxuICAgICAgICAgICAgQ29sbGVjdGlvbjogQ29sbGVjdGlvbixcclxuICAgICAgICAgICAgU2xpY2U6IFNsaWNlLFxyXG4gICAgICAgICAgICBUb2tlbjogVG9rZW5cclxuICAgICAgICB9O1xyXG4vL1BhcnNlci5tb2R1bGVzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgIC8vb2JqZWN0IGZvciBmdW5jdGlvbnMgd2hpY2ggaGFuZGxlIGNvbXBsZXggbnVtYmVyXHJcbiAgICAgICAgdmFyIGNvbXBsZXggPSB7XHJcbiAgICAgICAgICAgIHByZWM6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgY29zOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlLCBpbTtcclxuICAgICAgICAgICAgICAgIHJlID0gXy5wYXJzZShNYXRoLmNvcyhyKSAqIE1hdGguY29zaChpKSk7XHJcbiAgICAgICAgICAgICAgICBpbSA9IF8ucGFyc2UoTWF0aC5zaW4ocikgKiBNYXRoLnNpbmgoaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QocmUsIF8ubXVsdGlwbHkoaW0sIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzaW46IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmUsIGltO1xyXG4gICAgICAgICAgICAgICAgcmUgPSBfLnBhcnNlKE1hdGguc2luKHIpICogTWF0aC5jb3NoKGkpKTtcclxuICAgICAgICAgICAgICAgIGltID0gXy5wYXJzZShNYXRoLmNvcyhyKSAqIE1hdGguc2luaChpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zdWJ0cmFjdChyZSwgXy5tdWx0aXBseShpbSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRhbjogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZSwgaW07XHJcbiAgICAgICAgICAgICAgICByZSA9IF8ucGFyc2UoTWF0aC5zaW4oMiAqIHIpIC8gKE1hdGguY29zKDIgKiByKSArIE1hdGguY29zaCgyICogaSkpKTtcclxuICAgICAgICAgICAgICAgIGltID0gXy5wYXJzZShNYXRoLnNpbmgoMiAqIGkpIC8gKE1hdGguY29zKDIgKiByKSArIE1hdGguY29zaCgyICogaSkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChyZSwgXy5tdWx0aXBseShpbSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlYzogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5yZW1vdmVEZW4odGhpcy5jb3MociwgaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QodFswXSwgXy5tdWx0aXBseSh0WzFdLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3NjOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnJlbW92ZURlbih0aGlzLnNpbihyLCBpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQodFswXSwgXy5tdWx0aXBseSh0WzFdLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY290OiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnJlbW92ZURlbih0aGlzLnRhbihyLCBpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zdWJ0cmFjdCh0WzBdLCBfLm11bHRpcGx5KHRbMV0sIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY29zOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCwgc3EsIGEsIGIsIGMsIHNxdWFyZWQ7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSB0aGlzLmZyb21BcnJheShbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgc3F1YXJlZCA9IF8ucG93KHN5bWJvbC5jbG9uZSgpLCBuZXcgU3ltYm9sKDIpKTtcclxuICAgICAgICAgICAgICAgIHNxID0gXy5leHBhbmQoc3F1YXJlZCk7IC8veip6XHJcbiAgICAgICAgICAgICAgICBhID0gXy5tdWx0aXBseShzcXJ0KF8uc3VidHJhY3QobmV3IFN5bWJvbCgxKSwgc3EpKSwgU3ltYm9sLmltYWdpbmFyeSgpKTtcclxuICAgICAgICAgICAgICAgIGIgPSBfLmV4cGFuZChfLmFkZChzeW1ib2wuY2xvbmUoKSwgYSkpO1xyXG4gICAgICAgICAgICAgICAgYyA9IGxvZyhiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmV4cGFuZChfLm11bHRpcGx5KFN5bWJvbC5pbWFnaW5hcnkoKS5uZWdhdGUoKSwgYykpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhc2luOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QoXy5wYXJzZSgncGkvMicpLCB0aGlzLmFjb3MociwgaSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdGFuOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGkgYW5kIC1pXHJcbiAgICAgICAgICAgICAgICBpZihyLmVxdWFscygwKSAmJiAoaS5lcXVhbHMoMSkgfHwgaS5lcXVhbHMoLTEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgY29weSBXb2xmcmFtIEFscGhhIGZvciBub3cuIFRoZSBwYXJlbnRoZXNpcyBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShgJHtTeW1ib2wuaW5maW5pdHkoKX0qJHtTZXR0aW5ncy5JTUFHSU5BUll9KiR7aX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBjLCBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBjb21wbGV4LmZyb21BcnJheShbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgYSA9IF8uZXhwYW5kKF8ubXVsdGlwbHkoU3ltYm9sLmltYWdpbmFyeSgpLCBzeW1ib2wuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgYiA9IGxvZyhfLmV4cGFuZChfLnN1YnRyYWN0KG5ldyBTeW1ib2woMSksIGEuY2xvbmUoKSkpKTtcclxuICAgICAgICAgICAgICAgIGMgPSBsb2coXy5leHBhbmQoXy5hZGQobmV3IFN5bWJvbCgxKSwgYS5jbG9uZSgpKSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZXhwYW5kKF8ubXVsdGlwbHkoXy5kaXZpZGUoU3ltYm9sLmltYWdpbmFyeSgpLCBuZXcgU3ltYm9sKDIpKSwgXy5zdWJ0cmFjdChiLCBjKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhc2VjOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLnJlbW92ZURlbihbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgZFsxXS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjb3MuYXBwbHkodGhpcywgZCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjc2M6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMucmVtb3ZlRGVuKFtyLCBpXSk7XHJcbiAgICAgICAgICAgICAgICBkWzFdLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNpbi5hcHBseSh0aGlzLCBkKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNvdDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5yZW1vdmVEZW4oW3IsIGldKTtcclxuICAgICAgICAgICAgICAgIGRbMV0ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdGFuLmFwcGx5KHRoaXMsIGQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL0h5cGVyYm9saWMgdHJpZ1xyXG4gICAgICAgICAgICBjb3NoOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlLCBpbTtcclxuICAgICAgICAgICAgICAgIHJlID0gXy5wYXJzZShNYXRoLmNvc2gocikgKiBNYXRoLmNvcyhpKSk7XHJcbiAgICAgICAgICAgICAgICBpbSA9IF8ucGFyc2UoTWF0aC5zaW5oKHIpICogTWF0aC5zaW4oaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKHJlLCBfLm11bHRpcGx5KGltLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2luaDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZSwgaW07XHJcbiAgICAgICAgICAgICAgICByZSA9IF8ucGFyc2UoTWF0aC5zaW5oKHIpICogTWF0aC5jb3MoaSkpO1xyXG4gICAgICAgICAgICAgICAgaW0gPSBfLnBhcnNlKE1hdGguY29zaChyKSAqIE1hdGguc2luKGkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChyZSwgXy5tdWx0aXBseShpbSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRhbmg6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmUsIGltO1xyXG4gICAgICAgICAgICAgICAgcmUgPSBfLnBhcnNlKE1hdGguc2luaCgyICogcikgLyAoTWF0aC5jb3MoMiAqIGkpICsgTWF0aC5jb3NoKDIgKiByKSkpO1xyXG4gICAgICAgICAgICAgICAgaW0gPSBfLnBhcnNlKE1hdGguc2luKDIgKiBpKSAvIChNYXRoLmNvcygyICogaSkgKyBNYXRoLmNvc2goMiAqIHIpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zdWJ0cmFjdChyZSwgXy5tdWx0aXBseShpbSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlY2g6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMucmVtb3ZlRGVuKHRoaXMuY29zaChyLCBpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zdWJ0cmFjdCh0WzBdLCBfLm11bHRpcGx5KHRbMV0sIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjc2NoOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnJlbW92ZURlbih0aGlzLnNpbmgociwgaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QodFswXSwgXy5tdWx0aXBseSh0WzFdLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY290aDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5yZW1vdmVEZW4odGhpcy50YW5oKHIsIGkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZCh0WzBdLCBfLm11bHRpcGx5KHRbMV0sIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY29zaDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCBiLCB6O1xyXG4gICAgICAgICAgICAgICAgeiA9IHRoaXMuZnJvbUFycmF5KFtyLCBpXSk7XHJcbiAgICAgICAgICAgICAgICBhID0gc3FydChfLmFkZCh6LmNsb25lKCksIG5ldyBTeW1ib2woMSkpKTtcclxuICAgICAgICAgICAgICAgIGIgPSBzcXJ0KF8uc3VidHJhY3Qoei5jbG9uZSgpLCBuZXcgU3ltYm9sKDEpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5leHBhbmQobG9nKF8uYWRkKHosIF8uZXhwYW5kKF8ubXVsdGlwbHkoYSwgYikpKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhc2luaDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCB6O1xyXG4gICAgICAgICAgICAgICAgeiA9IHRoaXMuZnJvbUFycmF5KFtyLCBpXSk7XHJcbiAgICAgICAgICAgICAgICBhID0gc3FydChfLmFkZChuZXcgU3ltYm9sKDEpLCBfLmV4cGFuZChfLnBvdyh6LmNsb25lKCksIG5ldyBTeW1ib2woMikpKSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZXhwYW5kKGxvZyhfLmFkZCh6LCBhKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdGFuaDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCBiLCB6O1xyXG4gICAgICAgICAgICAgICAgeiA9IHRoaXMuZnJvbUFycmF5KFtyLCBpXSk7XHJcbiAgICAgICAgICAgICAgICBhID0gbG9nKF8uYWRkKHouY2xvbmUoKSwgbmV3IFN5bWJvbCgxKSkpO1xyXG4gICAgICAgICAgICAgICAgYiA9IGxvZyhfLnN1YnRyYWN0KG5ldyBTeW1ib2woMSksIHopKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmV4cGFuZChfLmRpdmlkZShfLnN1YnRyYWN0KGEsIGIpLCBuZXcgU3ltYm9sKDIpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFzZWNoOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnJlbW92ZURlbihbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgdFsxXS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjb3NoLmFwcGx5KHRoaXMsIHQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3NjaDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5yZW1vdmVEZW4oW3IsIGldKTtcclxuICAgICAgICAgICAgICAgIHRbMV0ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hc2luaC5hcHBseSh0aGlzLCB0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNvdGg6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMucmVtb3ZlRGVuKFtyLCBpXSk7XHJcbiAgICAgICAgICAgICAgICB0WzFdLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRhbmguYXBwbHkodGhpcywgdCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNxcnQ6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZSwgaW0sIGgsIGEsIGQ7XHJcbiAgICAgICAgICAgICAgICByZSA9IHN5bWJvbC5yZWFscGFydCgpO1xyXG4gICAgICAgICAgICAgICAgaW0gPSBzeW1ib2wuaW1hZ3BhcnQoKTtcclxuICAgICAgICAgICAgICAgIGggPSBTeW1ib2wuaHlwKHJlLCBpbSk7XHJcbiAgICAgICAgICAgICAgICBhID0gXy5hZGQocmUuY2xvbmUoKSwgaCk7XHJcbiAgICAgICAgICAgICAgICBkID0gc3FydChfLm11bHRpcGx5KG5ldyBTeW1ib2woMiksIGEuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKF8uZGl2aWRlKGEuY2xvbmUoKSwgZC5jbG9uZSgpKSwgXy5tdWx0aXBseShfLmRpdmlkZShpbSwgZCksIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsb2c6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmUsIGltLCBwaGk7XHJcbiAgICAgICAgICAgICAgICByZSA9IGxvZyhTeW1ib2wuaHlwKHIsIGkpKTtcclxuICAgICAgICAgICAgICAgIHBoaSA9IFNldHRpbmdzLlVTRV9CSUcgPyBTeW1ib2woYmlnRGVjLmF0YW4yKGkubXVsdGlwbGllci50b0RlY2ltYWwoKSwgci5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSkgOiBNYXRoLmF0YW4yKGksIHIpO1xyXG4gICAgICAgICAgICAgICAgaW0gPSBfLnBhcnNlKHBoaSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQocmUsIF8ubXVsdGlwbHkoU3ltYm9sLmltYWdpbmFyeSgpLCBpbSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlcmYoc3ltYm9sLCBuKSB7XHJcbiAgICAgICAgICAgICAgICAvL0RvIG5vdGhpbmcgZm9yIG5vdy4gUmV2aXNpdCB0aGlzIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignZXJmJywgW3N5bWJvbF0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG4gPSBuIHx8IDMwO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmID0gZnVuY3Rpb24gKFIsIEkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhLCBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF8ucGFyc2UoYmlnRGVjLmV4cChiaWdEZWMoaSkudG9Qb3dlcigyKS5uZWcoKS5kaXZpZGVkQnkoYmlnRGVjKG4pLnBvdygyKS5wbHVzKGJpZ0RlYyhSKS50b1Bvd2VyKDIpLnRpbWVzKDQpKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBfLnBhcnNlKGZvcm1hdCgnMiooezF9KS1lXigtKDIqezB9KnsxfSp7Mn0pKSooMip7MX0qY29zaCh7Mn0qezN9KS17MH0qezN9KnNpbmgoezN9KnsyfSkpJywgU2V0dGluZ3MuSU1BR0lOQVJZLCBSLCBJLCBpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF8ubXVsdGlwbHkoYSwgYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHJldHZhbCwgbmV3IFN5bWJvbCgyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlLCBpbSwgYSwgYiwgYywgaztcclxuICAgICAgICAgICAgICAgIHJlID0gc3ltYm9sLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICBpbSA9IHN5bWJvbC5pbWFncGFydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGsgPSBfLnBhcnNlKGZvcm1hdCgnKGVeKC17MH1eMikpL3BpJywgcmUpKTtcclxuICAgICAgICAgICAgICAgIGEgPSBfLnBhcnNlKGZvcm1hdCgnKDEtZV4oLSgyKnswfSp7MX0qezJ9KSkpLygyKnsxfSknLCBTZXR0aW5ncy5JTUFHSU5BUlksIHJlLCBpbSkpO1xyXG4gICAgICAgICAgICAgICAgYiA9IGYocmUudG9TdHJpbmcoKSwgaW0udG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKF8ucGFyc2UoTWF0aDIuZXJmKHJlLnRvU3RyaW5nKCkpKSwgXy5tdWx0aXBseShrLCBfLmFkZChhLCBiKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZW1vdmVEZW46IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZW4sIHIsIGksIHJlLCBpbTtcclxuICAgICAgICAgICAgICAgIGlmKGlzQXJyYXkoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBzeW1ib2xbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IHN5bWJvbFsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBzeW1ib2wucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gc3ltYm9sLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVuID0gTWF0aC5wb3cociwgMikgKyBNYXRoLnBvdyhpLCAyKTtcclxuICAgICAgICAgICAgICAgIHJlID0gXy5wYXJzZShyIC8gZGVuKTtcclxuICAgICAgICAgICAgICAgIGltID0gXy5wYXJzZShpIC8gZGVuKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbcmUsIGltXTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnJvbUFycmF5OiBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQoYXJyWzBdLCBfLm11bHRpcGx5KFN5bWJvbC5pbWFnaW5hcnkoKSwgYXJyWzFdKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoc3ltYm9sLCBmKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmUsIGltLCBzaWduO1xyXG5cclxuICAgICAgICAgICAgICAgIHNpZ24gPSBzeW1ib2wucG93ZXIuc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgaXQgZnJvbSB1bmRlciB0aGUgZGVub21pbmF0b3JcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5wb3dlciA9IHN5bWJvbC5wb3dlci5hYnMoKTtcclxuICAgICAgICAgICAgICAgIC8vZXhwYW5kXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wucG93ZXIuZ3JlYXRlclRoYW4oMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5leHBhbmQoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBkZW5vbWluYXRvclxyXG4gICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMucmVtb3ZlRGVuKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmUgPSBkWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGltID0gZFsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlID0gc3ltYm9sLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW0gPSBzeW1ib2wuaW1hZ3BhcnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihyZS5pc0NvbnN0YW50KCdhbGwnKSAmJiBpbS5pc0NvbnN0YW50KCdhbGwnKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tmXS5jYWxsKHRoaXMsIHJlLCBpbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oZiwgW3N5bWJvbF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL29iamVjdCBmb3IgZnVuY3Rpb25zIHdoaWNoIGhhbmRsZSB0cmlnXHJcbiAgICAgICAgdmFyIHRyaWcgPSB0aGlzLnRyaWcgPSB7XHJcbiAgICAgICAgICAgIC8vY29udGFpbmVyIGZvciB0cmlnb25vbWV0cmljIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGNvczogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmVxdWFscygncGknKSAmJiBzeW1ib2wubXVsdGlwbGllci5kZW4uZXF1YWxzKDIpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMobmV3IFN5bWJvbChTZXR0aW5ncy5QSSAvIDIpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfQklHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChiaWdEZWMuY29zKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguY29zKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnY29zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBnZXRRdWFkcmFudChzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBzeW1ib2wubXVsdGlwbGllci5hYnMoKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyID0gbTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNQaSgpICYmIHN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZm9yIDEgb3IgLTEgZm9yIG11bHRpcGxlcyBvZiBwaVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzSW50KG0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woZXZlbihtKSA/IDEgOiAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IE51bWJlcihtLm51bSksIGQgPSBOdW1iZXIobS5kZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkID09PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCcxLzInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnMS9zcXJ0KDIpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT09IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoJ3NxcnQoMykvMicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignY29zJywgW3N5bWJvbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihjICYmIChxID09PSAyIHx8IHEgPT09IDMpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbC5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZighcmV0dmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2NvcycsIFtzeW1ib2xdKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzaW46IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sICUgTWF0aC5QSSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlVTRV9CSUcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKGJpZ0RlYy5zaW4oc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5zaW4oc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnc2luJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBnZXRRdWFkcmFudChzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSBzeW1ib2wubXVsdGlwbGllci5zaWduKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBzeW1ib2wubXVsdGlwbGllci5hYnMoKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyID0gbTtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoJ3BpJykpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzUGkoKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGZvciAwIGZvciBtdWx0aXBsZXMgb2YgcGlcclxuICAgICAgICAgICAgICAgICAgICBpZihpc0ludChtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBtLm51bSwgZCA9IG0uZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkID09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnc3FydCgzKS8yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCcxL3NxcnQoMiknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCcxLzInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkobmV3IFN5bWJvbChzaWduKSwgXy5zeW1mdW5jdGlvbignc2luJywgW3N5bWJvbF0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIXJldHZhbClcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KG5ldyBTeW1ib2woc2lnbiksIF8uc3ltZnVuY3Rpb24oJ3NpbicsIFtzeW1ib2xdKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYyAmJiAocSA9PT0gMyB8fCBxID09PSA0KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGFuOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wgJSBNYXRoLlBJID09PSAwICYmIHN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlVTRV9CSUcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKGJpZ0RlYy50YW4oc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC50YW4oc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAndGFuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBnZXRRdWFkcmFudChzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBzeW1ib2wubXVsdGlwbGllcjtcclxuXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IG07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzUGkoKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIDAgZm9yIGFsbCBtdWx0aXBsZXMgb2YgcGlcclxuICAgICAgICAgICAgICAgICAgICBpZihpc0ludChtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBtLm51bSwgZCA9IG0uZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkID09IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJ3RhbiBpcyB1bmRlZmluZWQgZm9yICcgKyBzeW1ib2wudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCdzcXJ0KDMpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCcxL3NxcnQoMyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ3RhbicsIFtzeW1ib2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIXJldHZhbClcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCd0YW4nLCBbc3ltYm9sXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYyAmJiAocSA9PT0gMiB8fCBxID09PSA0KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2VjOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlVTRV9CSUcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKG5ldyBiaWdEZWMoMSkuZGl2aWRlZEJ5KGJpZ0RlYy5jb3Moc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGgyLnNlYyhzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdzZWMnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJzEvY29zKHswfSknLCBzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBnZXRRdWFkcmFudChzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBzeW1ib2wubXVsdGlwbGllci5hYnMoKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyID0gbTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNQaSgpICYmIHN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZm9yIDEgb3IgLTEgZm9yIG11bHRpcGxlcyBvZiBwaVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzSW50KG0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woZXZlbihtKSA/IDEgOiAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG0ubnVtLCBkID0gbS5kZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGQgPT0gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignc2VjIGlzIHVuZGVmaW5lZCBmb3IgJyArIHN5bWJvbC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnc3FydCgyKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoJzIvc3FydCgzKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignc2VjJywgW3N5bWJvbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihjICYmIChxID09PSAyIHx8IHEgPT09IDMpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbC5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZighcmV0dmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ3NlYycsIFtzeW1ib2xdKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjc2M6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuVVNFX0JJRykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2wobmV3IGJpZ0RlYygxKS5kaXZpZGVkQnkoYmlnRGVjLnNpbihzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aDIuY3NjKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ2NzYycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnMS9zaW4oezB9KScsIHN5bWJvbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGdldFF1YWRyYW50KHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IHN5bWJvbC5tdWx0aXBsaWVyLnNpZ24oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHN5bWJvbC5tdWx0aXBsaWVyLmFicygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyID0gbTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNQaSgpICYmIHN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gZm9yIDAgZm9yIG11bHRpcGxlcyBvZiBwaVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzSW50KG0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignY3NjIGlzIHVuZGVmaW5lZCBmb3IgJyArIHN5bWJvbC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbS5udW0sIGQgPSBtLmRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoJzIvc3FydCgzKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnc3FydCgyKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KG5ldyBTeW1ib2woc2lnbiksIF8uc3ltZnVuY3Rpb24oJ2NzYycsIFtzeW1ib2xdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKCFyZXR2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShuZXcgU3ltYm9sKHNpZ24pLCBfLnN5bWZ1bmN0aW9uKCdjc2MnLCBbc3ltYm9sXSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGMgJiYgKHEgPT09IDMgfHwgcSA9PT0gNCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvdDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sICUgKE1hdGguUEkvMikgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuVVNFX0JJRykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2wobmV3IGJpZ0RlYygxKS5kaXZpZGVkQnkoYmlnRGVjLnRhbihzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aDIuY290KHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ2NvdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnMS90YW4oezB9KScsIHN5bWJvbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gZ2V0UXVhZHJhbnQoc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gc3ltYm9sLm11bHRpcGxpZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIgPSBtO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc1BpKCkgJiYgc3ltYm9sLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiAwIGZvciBhbGwgbXVsdGlwbGVzIG9mIHBpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNJbnQobSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKCdjb3QgaXMgdW5kZWZpbmVkIGZvciAnICsgc3ltYm9sLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBtLm51bSwgZCA9IG0uZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkID09IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnMS9zcXJ0KDMpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCdzcXJ0KDMpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdjb3QnLCBbc3ltYm9sXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKCFyZXR2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignY290JywgW3N5bWJvbF0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGMgJiYgKHEgPT09IDIgfHwgcSA9PT0gNCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjb3M6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHZhbHVlcyBpbiB0aGUgY29tcGxleCBkb21haW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmd0KDEpIHx8IHN5bWJvbC5sdCgtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gc3ltYm9sLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kKGV2YWx1YXRlKGBwaS8yLWFzaW4oJHt4fSlgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGJpZyBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlVTRV9CSUcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKGJpZ0RlYy5hY29zKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguYWNvcyhzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhY29zJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignYWNvcycsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFzaW46IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHZhbHVlcyBpbiB0aGUgY29tcGxleCBkb21haW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmd0KDEpIHx8IHN5bWJvbC5sdCgtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gU2V0dGluZ3MuSU1BR0lOQVJZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmQoZXZhbHVhdGUoYCR7aX0qbG9nKHNxcnQoMS0ke3h9XjIpLSR7aX0qJHt4fSlgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGJpZyBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlVTRV9CSUcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKGJpZ0RlYy5hc2luKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguYXNpbihzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhc2luJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignYXNpbicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0YW46IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGJpZyBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlVTRV9CSUcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKGJpZ0RlYy5hdGFuKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguYXRhbihzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhdGFuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2F0YW4nLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZXF1YWxzKC0xKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCctcGkvNCcpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2F0YW4nLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXNlYzogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3V0T2ZGdW5jdGlvbkRvbWFpbkVycm9yKCdJbnB1dCBpcyBvdXQgb2YgdGhlIGRvbWFpbiBvZiBzZWMhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyaWcuYWNvcyhzeW1ib2wuaW52ZXJ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhc2VjJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2FzZWMnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3NjOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmlnLmFzaW4oc3ltYm9sLmludmVydCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhY3NjJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignYWNzYycsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjb3Q6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfLmFkZChfLnBhcnNlKCdwaS8yJyksIHRyaWcuYXRhbihzeW1ib2wpLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhY290Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignYWNvdCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0YW4yOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgaWYoYS5lcXVhbHMoMCkgJiYgYi5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKCdhdGFuMiBpcyB1bmRlZmluZWQgZm9yIDAsIDAnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgYS5pc0NvbnN0YW50KCkgJiYgYi5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmF0YW4yKGEsIGIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdhdGFuMicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vb2JqZWN0IGZvciBmdW5jdGlvbnMgd2hpY2ggaGFuZGxlIGh5cGVyYm9saWMgdHJpZ1xyXG4gICAgICAgIHZhciB0cmlnaCA9IHRoaXMudHJpZ2ggPSB7XHJcbiAgICAgICAgICAgIC8vY29udGFpbmVyIGZvciBoeXBlcmJvbGljIHRyaWcgZnVuY3Rpb25cclxuICAgICAgICAgICAgY29zaDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguY29zaChzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnY29zaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsID0gXy5zeW1mdW5jdGlvbignY29zaCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNpbmg6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLnNpbmgoc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ3NpbmgnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ3NpbmgnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0YW5oOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC50YW5oKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICd0YW5oJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCd0YW5oJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2VjaDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5zZWNoKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnc2VjaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJzEvY29zaCh7MH0pJywgc3ltYm9sKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ3NlY2gnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjc2NoOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5jc2NoKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdjc2NoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnMS9zaW5oKHswfSknLCBzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsID0gXy5zeW1mdW5jdGlvbignY3NjaCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvdGg6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmNvdGgoc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ2NvdGgnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcxL3RhbmgoezB9KScsIHN5bWJvbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdjb3RoJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNvc2g6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhY29zaCcpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZXZhbHVhdGUoXy5wYXJzZShmb3JtYXQoU2V0dGluZ3MuTE9HICsgJygoezB9KStzcXJ0KCh7MH0pXjItMSkpJywgc3ltYm9sLnRvU3RyaW5nKCkpKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignYWNvc2gnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXNpbmg6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhc2luaCcpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZXZhbHVhdGUoXy5wYXJzZShmb3JtYXQoU2V0dGluZ3MuTE9HICsgJygoezB9KStzcXJ0KCh7MH0pXjIrMSkpJywgc3ltYm9sLnRvU3RyaW5nKCkpKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignYXNpbmgnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXRhbmg6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhdGFuaCcpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBldmFsdWF0ZShfLnBhcnNlKGZvcm1hdCgnKDEvMikqJyArIFNldHRpbmdzLkxPRyArICcoKDErKHswfSkpLygxLSh7MH0pKSknLCBzeW1ib2wudG9TdHJpbmcoKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdhdGFuaCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhc2VjaDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUiAmJiBzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ2FzZWNoJyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUilcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBldmFsdWF0ZShsb2coXy5hZGQoc3ltYm9sLmNsb25lKCkuaW52ZXJ0KCksIHNxcnQoXy5zdWJ0cmFjdChfLnBvdyhzeW1ib2wsIG5ldyBTeW1ib2woLTIpKSwgbmV3IFN5bWJvbCgxKSkpKSkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2FzZWNoJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjc2NoOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYWNzY2gnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGV2YWx1YXRlKF8ucGFyc2UoZm9ybWF0KFNldHRpbmdzLkxPRyArICcoKDErc3FydCgxKyh7MH0pXjIpKS8oezB9KSknLCBzeW1ib2wudG9TdHJpbmcoKSkpKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdhY3NjaCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY290aDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUiAmJiBzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ2Fjb3RoJyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IFN5bWJvbC5pbmZpbml0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZXZhbHVhdGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5kaXZpZGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coXy5kaXZpZGUoXy5hZGQoc3ltYm9sLmNsb25lKCksIG5ldyBTeW1ib2woMSkpLCBfLnN1YnRyYWN0KHN5bWJvbC5jbG9uZSgpLCBuZXcgU3ltYm9sKDEpKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN5bWJvbCgyKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2Fjb3RoJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vbGlzdCBvZiBzdXBwb3J0ZWQgdW5pdHNcclxuICAgICAgICB0aGlzLnVuaXRzID0ge307XHJcbiAgICAgICAgLy9saXN0IGFsbCB0aGUgc3VwcG9ydGVkIG9wZXJhdG9yc1xyXG4gICAgICAgIHZhciBvcGVyYXRvcnMgPSB7XHJcbiAgICAgICAgICAgICdcXFxcJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogOCxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnXFxcXCcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdzbGFzaCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTsgLy9ieXBhc3MgdGhlIHNsYXNoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICchISc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDcsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJyEhJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2RmYWN0b3JpYWwnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oU2V0dGluZ3MuRE9VQkxFRkFDVE9SSUFMLCBbZV0pOyAvL3dyYXAgaXQgaW4gYSBmYWN0b3JpYWwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJyEnOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiA3LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICchJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2ZhY3RvcmlhbCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yaWFsKGUpOyAvL3dyYXAgaXQgaW4gYSBmYWN0b3JpYWwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ14nOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiA2LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdeJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3BvdycsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJyoqJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogNixcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnKionLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncG93JyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnJSc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDQsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJyUnLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncGVyY2VudCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG92ZXJsb2FkZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvdmVybG9hZEFjdGlvbjogJ21vZCcsXHJcbiAgICAgICAgICAgICAgICBvdmVybG9hZExlZnRBc3NvYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKHgsIG5ldyBTeW1ib2woMTAwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcqJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogNCxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnKicsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdtdWx0aXBseScsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcvJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogNCxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnLycsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdkaXZpZGUnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnKyc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDMsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJysnLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnYWRkJyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ3BsdXMnOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAzLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdwbHVzJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2FkZCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICctJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMyxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnLScsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdzdWJ0cmFjdCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICc9Jzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMixcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnPScsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdlcXVhbHMnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnPT0nOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICc9PScsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdlcScsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICc8Jzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnPCcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdsdCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICc8PSc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDEsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJzw9JyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2x0ZScsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICc+Jzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnPicsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdndCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICc9Pic6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDEsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJz0+JyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2d0ZScsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcsJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMCxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnLCcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdjb21tYScsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICc6Jzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMCxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnLCcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdhc3NpZ24nLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZlY3RvckZuOiAnc2xpY2UnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICc6PSc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDAsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJywnLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnZnVuY3Rpb25fYXNzaWduJyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL2JyYWNrZXRzXHJcbiAgICAgICAgdmFyIGJyYWNrZXRzID0ge1xyXG4gICAgICAgICAgICAnKCc6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdyb3VuZCcsXHJcbiAgICAgICAgICAgICAgICBpZDogMSxcclxuICAgICAgICAgICAgICAgIGlzX29wZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpc19jbG9zZTogZmFsc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJyknOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAncm91bmQnLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDIsXHJcbiAgICAgICAgICAgICAgICBpc19vcGVuOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzX2Nsb3NlOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdbJzoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3NxdWFyZScsXHJcbiAgICAgICAgICAgICAgICBpZDogMyxcclxuICAgICAgICAgICAgICAgIGlzX29wZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpc19jbG9zZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBtYXBzX3RvOiAndmVjdG9yJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnXSc6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzcXVhcmUnLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDQsXHJcbiAgICAgICAgICAgICAgICBpc19vcGVuOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzX2Nsb3NlOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICd7Jzoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2N1cmx5JyxcclxuICAgICAgICAgICAgICAgIGlkOiA1LFxyXG4gICAgICAgICAgICAgICAgaXNfb3BlbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGlzX2Nsb3NlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG1hcHNfdG86ICdTZXQnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICd9Jzoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2N1cmx5JyxcclxuICAgICAgICAgICAgICAgIGlkOiA2LFxyXG4gICAgICAgICAgICAgICAgaXNfb3BlbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc19jbG9zZTogdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTdXBwb3J0ZWQgZnVuY3Rpb25zLlxyXG4gICAgICAgIC8vIEZvcm1hdDogZnVuY3Rpb25fbmFtZTogW21hcHBlZF9mdW5jdGlvbiwgbnVtYmVyX29mX3BhcmFtZXRlcnNdXHJcbiAgICAgICAgdmFyIGZ1bmN0aW9ucyA9IHRoaXMuZnVuY3Rpb25zID0ge1xyXG4gICAgICAgICAgICAnY29zJzogW3RyaWcuY29zLCAxXSxcclxuICAgICAgICAgICAgJ3Npbic6IFt0cmlnLnNpbiwgMV0sXHJcbiAgICAgICAgICAgICd0YW4nOiBbdHJpZy50YW4sIDFdLFxyXG4gICAgICAgICAgICAnc2VjJzogW3RyaWcuc2VjLCAxXSxcclxuICAgICAgICAgICAgJ2NzYyc6IFt0cmlnLmNzYywgMV0sXHJcbiAgICAgICAgICAgICdjb3QnOiBbdHJpZy5jb3QsIDFdLFxyXG4gICAgICAgICAgICAnYWNvcyc6IFt0cmlnLmFjb3MsIDFdLFxyXG4gICAgICAgICAgICAnYXNpbic6IFt0cmlnLmFzaW4sIDFdLFxyXG4gICAgICAgICAgICAnYXRhbic6IFt0cmlnLmF0YW4sIDFdLFxyXG4gICAgICAgICAgICAnYXJjY29zJzogW3RyaWcuYWNvcywgMV0sXHJcbiAgICAgICAgICAgICdhcmNzaW4nOiBbdHJpZy5hc2luLCAxXSxcclxuICAgICAgICAgICAgJ2FyY3Rhbic6IFt0cmlnLmF0YW4sIDFdLFxyXG4gICAgICAgICAgICAnYXNlYyc6IFt0cmlnLmFzZWMsIDFdLFxyXG4gICAgICAgICAgICAnYWNzYyc6IFt0cmlnLmFjc2MsIDFdLFxyXG4gICAgICAgICAgICAnYWNvdCc6IFt0cmlnLmFjb3QsIDFdLFxyXG4gICAgICAgICAgICAnYXRhbjInOiBbdHJpZy5hdGFuMiwgMl0sXHJcbiAgICAgICAgICAgICdhY290aCc6IFt0cmlnaC5hY290aCwgMV0sXHJcbiAgICAgICAgICAgICdhc2VjaCc6IFt0cmlnaC5hc2VjaCwgMV0sXHJcbiAgICAgICAgICAgICdhY3NjaCc6IFt0cmlnaC5hY3NjaCwgMV0sXHJcbiAgICAgICAgICAgICdzaW5oJzogW3RyaWdoLnNpbmgsIDFdLFxyXG4gICAgICAgICAgICAnY29zaCc6IFt0cmlnaC5jb3NoLCAxXSxcclxuICAgICAgICAgICAgJ3RhbmgnOiBbdHJpZ2gudGFuaCwgMV0sXHJcbiAgICAgICAgICAgICdhc2luaCc6IFt0cmlnaC5hc2luaCwgMV0sXHJcbiAgICAgICAgICAgICdzZWNoJzogW3RyaWdoLnNlY2gsIDFdLFxyXG4gICAgICAgICAgICAnY3NjaCc6IFt0cmlnaC5jc2NoLCAxXSxcclxuICAgICAgICAgICAgJ2NvdGgnOiBbdHJpZ2guY290aCwgMV0sXHJcbiAgICAgICAgICAgICdhY29zaCc6IFt0cmlnaC5hY29zaCwgMV0sXHJcbiAgICAgICAgICAgICdhdGFuaCc6IFt0cmlnaC5hdGFuaCwgMV0sXHJcbiAgICAgICAgICAgICdsb2cxMCc6IFssIDFdLFxyXG4gICAgICAgICAgICAnZXhwJzogW2V4cCwgMV0sXHJcbiAgICAgICAgICAgICdyYWRpYW5zJzogW3JhZGlhbnMsIDFdLFxyXG4gICAgICAgICAgICAnZGVncmVlcyc6IFtkZWdyZWVzLCAxXSxcclxuICAgICAgICAgICAgJ21pbic6IFttaW4sIC0xXSxcclxuICAgICAgICAgICAgJ21heCc6IFttYXgsIC0xXSxcclxuICAgICAgICAgICAgJ2VyZic6IFssIDFdLFxyXG4gICAgICAgICAgICAnZmxvb3InOiBbLCAxXSxcclxuICAgICAgICAgICAgJ2NlaWwnOiBbLCAxXSxcclxuICAgICAgICAgICAgJ3RydW5jJzogWywgMV0sXHJcbiAgICAgICAgICAgICdTaSc6IFssIDFdLFxyXG4gICAgICAgICAgICAnc3RlcCc6IFssIDFdLFxyXG4gICAgICAgICAgICAncmVjdCc6IFssIDFdLFxyXG4gICAgICAgICAgICAnc2luYyc6IFtzaW5jLCAxXSxcclxuICAgICAgICAgICAgJ3RyaSc6IFssIDFdLFxyXG4gICAgICAgICAgICAnc2lnbic6IFtzaWduLCAxXSxcclxuICAgICAgICAgICAgJ0NpJzogWywgMV0sXHJcbiAgICAgICAgICAgICdFaSc6IFssIDFdLFxyXG4gICAgICAgICAgICAnU2hpJzogWywgMV0sXHJcbiAgICAgICAgICAgICdDaGknOiBbLCAxXSxcclxuICAgICAgICAgICAgJ0xpJzogWywgMV0sXHJcbiAgICAgICAgICAgICdmaWInOiBbLCAxXSxcclxuICAgICAgICAgICAgJ2ZhY3QnOiBbZmFjdG9yaWFsLCAxXSxcclxuICAgICAgICAgICAgJ2ZhY3RvcmlhbCc6IFtmYWN0b3JpYWwsIDFdLFxyXG4gICAgICAgICAgICAnY29udGludWVkX2ZyYWN0aW9uJzogW2NvbnRpbnVlZF9mcmFjdGlvbiwgWzEsIDJdXSxcclxuICAgICAgICAgICAgJ2RmYWN0b3JpYWwnOiBbLCAxXSxcclxuICAgICAgICAgICAgJ2dhbW1hX2luY29tcGxldGUnOiBbLCBbMSwgMl1dLFxyXG4gICAgICAgICAgICAncm91bmQnOiBbcm91bmQsIFsxLCAyXV0sXHJcbiAgICAgICAgICAgICdzY2llbnRpZmljJzogW3NjaWVudGlmaWMsIFsxLCAyXV0sXHJcbiAgICAgICAgICAgICdtb2QnOiBbbW9kLCAyXSxcclxuICAgICAgICAgICAgJ3BmYWN0b3InOiBbcGZhY3RvciwgMV0sXHJcbiAgICAgICAgICAgICd2ZWN0b3InOiBbdmVjdG9yLCAtMV0sXHJcbiAgICAgICAgICAgICdtYXRyaXgnOiBbbWF0cml4LCAtMV0sXHJcbiAgICAgICAgICAgICdTZXQnOiBbc2V0LCAtMV0sXHJcbiAgICAgICAgICAgICdpbWF0cml4JzogW2ltYXRyaXgsIC0xXSxcclxuICAgICAgICAgICAgJ3BhcmVucyc6IFtwYXJlbnMsIC0xXSxcclxuICAgICAgICAgICAgJ3NxcnQnOiBbc3FydCwgMV0sXHJcbiAgICAgICAgICAgICdjYnJ0JzogW2NicnQsIDFdLFxyXG4gICAgICAgICAgICAnbnRocm9vdCc6IFtudGhyb290LCAyXSxcclxuICAgICAgICAgICAgJ2xvZyc6IFtsb2csIFsxLCAyXV0sXHJcbiAgICAgICAgICAgICdleHBhbmQnOiBbZXhwYW5kYWxsLCAxXSxcclxuICAgICAgICAgICAgJ2Ficyc6IFthYnMsIDFdLFxyXG4gICAgICAgICAgICAnaW52ZXJ0JzogW2ludmVydCwgMV0sXHJcbiAgICAgICAgICAgICdkZXRlcm1pbmFudCc6IFtkZXRlcm1pbmFudCwgMV0sXHJcbiAgICAgICAgICAgICdzaXplJzogW3NpemUsIDFdLFxyXG4gICAgICAgICAgICAndHJhbnNwb3NlJzogW3RyYW5zcG9zZSwgMV0sXHJcbiAgICAgICAgICAgICdkb3QnOiBbZG90LCAyXSxcclxuICAgICAgICAgICAgJ2Nyb3NzJzogW2Nyb3NzLCAyXSxcclxuICAgICAgICAgICAgJ3ZlY2dldCc6IFt2ZWNnZXQsIDJdLFxyXG4gICAgICAgICAgICAndmVjc2V0JzogW3ZlY3NldCwgM10sXHJcbiAgICAgICAgICAgICd2ZWN0cmltJzogW3ZlY3RyaW0sIFsxLCAyXV0sXHJcbiAgICAgICAgICAgICdtYXRnZXQnOiBbbWF0Z2V0LCAzXSxcclxuICAgICAgICAgICAgJ21hdHNldCc6IFttYXRzZXQsIDRdLFxyXG4gICAgICAgICAgICAnbWF0Z2V0cm93JzogW21hdGdldHJvdywgMl0sXHJcbiAgICAgICAgICAgICdtYXRzZXRyb3cnOiBbbWF0c2V0cm93LCAzXSxcclxuICAgICAgICAgICAgJ21hdGdldGNvbCc6IFttYXRnZXRjb2wsIDJdLFxyXG4gICAgICAgICAgICAnbWF0c2V0Y29sJzogW21hdHNldGNvbCwgM10sXHJcbiAgICAgICAgICAgICdyYXRpb25hbGl6ZSc6IFtyYXRpb25hbGl6ZSwgMV0sXHJcbiAgICAgICAgICAgICdJRic6IFtJRiwgM10sXHJcbiAgICAgICAgICAgICdpc19pbic6IFtpc19pbiwgMl0sXHJcbiAgICAgICAgICAgIC8vaW1hZ2luYXJ5IHN1cHBvcnRcclxuICAgICAgICAgICAgJ3JlYWxwYXJ0JzogW3JlYWxwYXJ0LCAxXSxcclxuICAgICAgICAgICAgJ2ltYWdwYXJ0JzogW2ltYWdwYXJ0LCAxXSxcclxuICAgICAgICAgICAgJ2Nvbmp1Z2F0ZSc6IFtjb25qdWdhdGUsIDFdLFxyXG4gICAgICAgICAgICAnYXJnJzogW2FyZywgMV0sXHJcbiAgICAgICAgICAgICdwb2xhcmZvcm0nOiBbcG9sYXJmb3JtLCAxXSxcclxuICAgICAgICAgICAgJ3JlY3Rmb3JtJzogW3JlY3Rmb3JtLCAxXSxcclxuICAgICAgICAgICAgJ3NvcnQnOiBbc29ydCwgWzEsIDJdXSxcclxuICAgICAgICAgICAgJ2ludGVnZXJfcGFydCc6IFssIDFdLFxyXG4gICAgICAgICAgICAndW5pb24nOiBbdW5pb24sIDJdLFxyXG4gICAgICAgICAgICAnY29udGFpbnMnOiBbY29udGFpbnMsIDJdLFxyXG4gICAgICAgICAgICAnaW50ZXJzZWN0aW9uJzogW2ludGVyc2VjdGlvbiwgMl0sXHJcbiAgICAgICAgICAgICdkaWZmZXJlbmNlJzogW2RpZmZlcmVuY2UsIDJdLFxyXG4gICAgICAgICAgICAnaW50ZXJzZWN0cyc6IFtpbnRlcnNlY3RzLCAyXSxcclxuICAgICAgICAgICAgJ2lzX3N1YnNldCc6IFtpc19zdWJzZXQsIDJdLFxyXG4gICAgICAgICAgICAvL3N5c3RlbSBzdXBwb3J0XHJcbiAgICAgICAgICAgICdwcmludCc6IFtwcmludCwgLTFdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy9lcnJvciBoYW5kbGVyXHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycjtcclxuICAgICAgICAvL3RoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb21iIHRocm91Z2ggdGhlIGZ1bmN0aW9uIG1vZHVsZXMgYW5kIGZpbmQgYSBmdW5jdGlvbiBnaXZlbiBpdHMgbmFtZVxyXG4gICAgICAgIHZhciBmaW5kRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGZtb2R1bGVzID0gU2V0dGluZ3MuRlVOQ1RJT05fTU9EVUxFUyxcclxuICAgICAgICAgICAgICAgICAgICBsID0gZm1vZHVsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm1vZHVsZSA9IGZtb2R1bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoZm5hbWUgaW4gZm1vZHVsZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm1vZHVsZVtmbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXJyKCdUaGUgZnVuY3Rpb24gJyArIGZuYW1lICsgJyBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgZ2l2ZXMgdGhlIGFiaWxpdHkgdG8gb3ZlcnJpZGUgb3BlcmF0b3JzIHdpdGggbmV3IG1ldGhvZHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHdoaWNoXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd2l0aF93aGF0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vdmVycmlkZSA9IGZ1bmN0aW9uICh3aGljaCwgd2l0aF93aGF0KSB7XHJcbiAgICAgICAgICAgIGlmKCFiaW5bd2hpY2hdKVxyXG4gICAgICAgICAgICAgICAgYmluW3doaWNoXSA9IFtdO1xyXG4gICAgICAgICAgICBiaW5bd2hpY2hdLnB1c2godGhpc1t3aGljaF0pO1xyXG4gICAgICAgICAgICB0aGlzW3doaWNoXSA9IHdpdGhfd2hhdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXN0b3JlcyBhIHByZXZpb3VzbHkgb3ZlcnJpZGRlbiBvcGVyYXRvclxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aGF0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZXN0b3JlID0gZnVuY3Rpb24gKHdoYXQpIHtcclxuICAgICAgICAgICAgaWYodGhpc1t3aGF0XSlcclxuICAgICAgICAgICAgICAgIHRoaXNbd2hhdF0gPSBiaW5bd2hhdF0ucG9wKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgc3VwcG9zZWQgdG8gYmVoYXZlIHNpbWlsYXJseSB0byB0aGUgb3ZlcnJpZGUgbWV0aG9kIGJ1dCBpdCBkb2VzIG5vdCBvdmVycmlkZVxyXG4gICAgICAgICAqIHRoZSBleGlzdGluZyBmdW5jdGlvbiByYXRoZXIgaXQgb25seSBleHRlbmRzIGl0XHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHdoYXRcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3aXRoX3doYXRcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlX2NhbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uICh3aGF0LCB3aXRoX3doYXQsIGZvcmNlX2NhbGwpIHtcclxuICAgICAgICAgICAgdmFyIF8gPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkID0gdGhpc1t3aGF0XTtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGV4dGVuZGVkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB3aXRoX3doYXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gdGhpc1t3aGF0XTtcclxuICAgICAgICAgICAgICAgIHRoaXNbd2hhdF0gPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzU3ltYm9sKGEpICYmIGlzU3ltYm9sKGIpICYmICFmb3JjZV9jYWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZi5jYWxsKF8sIGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhfd2hhdC5jYWxsKF8sIGEsIGIsIGYpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdlbmVyYXRlcyBsaWJyYXJ5J3MgcmVwcmVzZW50YXRpb24gb2YgYSBmdW5jdGlvbi4gSXQncyBhIGZhbmN5IHdheSBvZiBzYXlpbmcgYSBzeW1ib2wgd2l0aFxyXG4gICAgICAgICAqIGEgZmV3IGV4dHJhcy4gVGhlIG1vc3QgaW1wb3J0YW50IHRoaW5nIGlzIHRoYXQgdGhhdCBpdCBnaXZlcyBhIGZuYW1lIGFuZFxyXG4gICAgICAgICAqIGFuIGFyZ3MgcHJvcGVydHkgdG8gdGhlIHN5bWJvbHMgaW4gYWRkaXRpb24gdG8gY2hhbmdpbmcgaXRzIGdyb3VwIHRvIEZOXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZuX25hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3ltZnVuY3Rpb24gPSBmdW5jdGlvbiAoZm5fbmFtZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgICAgIC8vY2FsbCB0aGUgcHJvcGVyIGZ1bmN0aW9uIGFuZCByZXR1cm4gdGhlIHJlc3VsdDtcclxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgU3ltYm9sKGZuX25hbWUpO1xyXG4gICAgICAgICAgICBmLmdyb3VwID0gRk47XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gW10uc2xpY2UuY2FsbChwYXJhbXMpOy8vZW5zdXJlIGFuIGFycmF5XHJcbiAgICAgICAgICAgIGYuYXJncyA9IHBhcmFtcztcclxuICAgICAgICAgICAgZi5mbmFtZSA9IGZuX25hbWUgPT09IFBBUkVOVEhFU0lTID8gJycgOiBmbl9uYW1lO1xyXG4gICAgICAgICAgICBmLnVwZGF0ZUhhc2goKTtcclxuICAgICAgICAgICAgcmV0dXJuIGY7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gaW50ZXJuYWwgZnVuY3Rpb24gY2FsbCBmb3IgdGhlIFBhcnNlci4gVGhpcyB3aWxsIGVpdGhlciB0cmlnZ2VyIGEgcmVhbFxyXG4gICAgICAgICAqIGZ1bmN0aW9uIGNhbGwgaWYgaXQgY2FuIGRvIHNvIG9yIGp1c3QgcmV0dXJuIGEgc3ltYm9saWMgcmVwcmVzZW50YXRpb24gb2YgdGhlXHJcbiAgICAgICAgICogZnVuY3Rpb24gdXNpbmcgc3ltZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZuX25hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGFsbG93ZWRfYXJnc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYWxsZnVuY3Rpb24gPSBmdW5jdGlvbiAoZm5fbmFtZSwgYXJncywgYWxsb3dlZF9hcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBmbl9zZXR0aW5ncyA9IGZ1bmN0aW9uc1tmbl9uYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGlmKCFmbl9zZXR0aW5ncylcclxuICAgICAgICAgICAgICAgIGVycignTmVyZGFtZXIgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgdGhlIGZ1bmN0aW9uICcgKyBmbl9uYW1lKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBudW1fYWxsb3dlZF9hcmdzID0gZm5fc2V0dGluZ3NbMV0gfHwgYWxsb3dlZF9hcmdzLCAvL2dldCB0aGUgbnVtYmVyIG9mIGFsbG93ZWQgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBmbl9zZXR0aW5nc1swXSwgLy9nZXQgdGhlIG1hcHBlZCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbDtcclxuICAgICAgICAgICAgLy9XZSB3YW50IHRvIGJlIGFibGUgdG8gY2FsbCBhcHBseSBvbiB0aGUgYXJndW1lbnRzIG9yIGNyZWF0ZSBhIHN5bWZ1bmN0aW9uLiBCb3RoIHJlcXVpcmVcclxuICAgICAgICAgICAgLy9hbiBhcnJheSBzbyBtYWtlIHN1cmUgdG8gd3JhcCB0aGUgYXJndW1lbnQgaW4gYW4gYXJyYXkuXHJcbiAgICAgICAgICAgIGlmKCEoYXJncyBpbnN0YW5jZW9mIEFycmF5KSlcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzICE9PSB1bmRlZmluZWQgPyBbYXJnc10gOiBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmKG51bV9hbGxvd2VkX2FyZ3MgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNfYXJyYXkgPSBpc0FycmF5KG51bV9hbGxvd2VkX2FyZ3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5fYXJncyA9IGlzX2FycmF5ID8gbnVtX2FsbG93ZWRfYXJnc1swXSA6IG51bV9hbGxvd2VkX2FyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF9hcmdzID0gaXNfYXJyYXkgPyBudW1fYWxsb3dlZF9hcmdzWzFdIDogbnVtX2FsbG93ZWRfYXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtX2FyZ3MgPSBhcmdzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JfbXNnID0gZm5fbmFtZSArICcgcmVxdWlyZXMgYSB7MH0gb2YgezF9IGFyZ3VtZW50cy4gezJ9IHByb3ZpZGVkISc7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobnVtX2FyZ3MgPCBtaW5fYXJncylcclxuICAgICAgICAgICAgICAgICAgICBlcnIoZm9ybWF0KGVycm9yX21zZywgJ21pbmltdW0nLCBtaW5fYXJncywgbnVtX2FyZ3MpKTtcclxuICAgICAgICAgICAgICAgIGlmKG51bV9hcmdzID4gbWF4X2FyZ3MpXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyKGZvcm1hdChlcnJvcl9tc2csICdtYXhpbXVtJywgbWF4X2FyZ3MsIG51bV9hcmdzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRoZSBmb2xsb3dpbmcgYXJlIHZlcnkgaW1wb3J0YW50IHRvIHRoZSBob3cgbmVyZGFtZXIgY29uc3RydWN0cyBmdW5jdGlvbnMhXHJcbiAgICAgICAgICAgICAqIEFzc3VtcHRpb24gMSAtIGlmIGZuIGlzIHVuZGVmaW5lZCB0aGVuIGhhbmRsaW5nIG9mIHRoZSBmdW5jdGlvbiBpcyBwdXJlbHkgbnVtZXJpYy4gVGhpc1xyXG4gICAgICAgICAgICAgKiAgICAgZW5hYmxlcyB1cyB0byByZXVzZSBNYXRoLCBNYXRoMiwgLi4uLCBhbnkgZnVuY3Rpb24gZnJvbSBTZXR0aW5ncy5GVU5DVElPTlNfTU9EVUxFUyBlbnRyeVxyXG4gICAgICAgICAgICAgKiBBc3N1bXB0aW9uIDIgLSBpZiBmbiBpcyBkZWZpbmVkIHRoZW4gdGhhdCBmdW5jdGlvbiB0YWtlcyBjYXJlIG9mIEVWRVJZVEhJTkcgaW5jbHVkaW5nIHN5bWJvbGljc1xyXG4gICAgICAgICAgICAgKiBBc3N1bXB0aW9uIDMgLSBpZiB0aGUgdXNlciBjYWxscyBzeW1ib2xpY3Mgb24gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBudW1lcmljIHZhbHVlIHRoZW5cclxuICAgICAgICAgICAgICogICAgIHRoZXkgYXJlIGV4cGVjdGluZyBhIHN5bWJvbGljIG91dHB1dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgYXJndW1lbnRzIGFyZSBhbGwgbnVtZXJzXHJcbiAgICAgICAgICAgIHZhciBudW1lcmljQXJncyA9IGFsbE51bWJlcnMoYXJncyk7XHJcbiAgICAgICAgICAgIC8vQmlnIG51bWJlciBzdXBwb3J0LiBDaGVjayBpZiBCaWcgbnVtYmVyIGlzIHJlcXVlc3RlZCBhbmQgdGhlIGFyZ3VtZW50cyBhcmUgYWxsIG51bWVyaWMgYW5kLCBub3QgaW1hZ2luYXJ5XHJcbi8vICAgICAgICAgICAgaWYgKFNldHRpbmdzLlVTRV9CSUcgJiYgbnVtZXJpY0FyZ3MpIHtcclxuLy8gICAgICAgICAgICAgICAgcmV0dmFsID0gQmlnW2ZuX25hbWVdLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XHJcbi8vICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZighZm4pIHtcclxuICAgICAgICAgICAgICAgIC8vUmVtZW1iZXIgYXNzdW1wdGlvbiAxLiBObyBmdW5jdGlvbiBkZWZpbmVkIHNvIGl0IE1VU1QgYmUgbnVtZXJpYyBpbiBuYXR1cmVcclxuICAgICAgICAgICAgICAgIGZuID0gZmluZEZ1bmN0aW9uKGZuX25hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIG51bWVyaWNBcmdzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGJpZ0NvbnZlcnQoZm4uYXBwbHkoZm4sIGFyZ3MpKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKGZuX25hbWUsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9SZW1lbWJlciBhc3N1bXB0aW9uIDIuIFRoZSBmdW5jdGlvbiBpcyBkZWZpbmVkIHNvIGl0IE1VU1QgaGFuZGxlIGFsbCBhc3BlY3RzIGluY2x1ZGluZyBudW1lcmljIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gZm4uYXBwbHkoZm5fc2V0dGluZ3NbMl0sIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkIGEgcmVnZXggYmFzZWQgb24gdGhlIG9wZXJhdG9ycyBjdXJyZW50bHkgbG9hZGVkLiBUaGVzZSBvcGVyYXRvcnMgYXJlIHRvIGJlIGlnbm9yZWQgd2hlblxyXG4gICAgICAgICAqIHN1YnN0aXR1dGluZyBzcGFjZXMgZm9yIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vcGVyYXRvcl9maWx0ZXJfcmVnZXggPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL3dlIG9ubHkgd2FudCB0aGUgb3BlcmF0b3JzIHdoaWNoIGFyZSBzaW5ndWxhciBzaW5jZSB0aG9zZSBhcmUgdGhlIG9uZXNcclxuICAgICAgICAgICAgLy90aGF0IG5lcmRhbWVyIHVzZXMgYW55d2F5XHJcbiAgICAgICAgICAgIHZhciBvc3RyID0gJ15cXFxcJyArIE9iamVjdC5rZXlzKG9wZXJhdG9ycykuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBpZih4Lmxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgICAgfSkuam9pbignXFxcXCcpO1xyXG4gICAgICAgICAgICAvL2NyZWF0ZSBhIHJlZ2V4IHdoaWNoIGNhcHR1cmVzIGFsbCBzcGFjZXMgYmV0d2VlbiBjaGFyYWN0ZXJzIGV4Y2VwdCB0aG9zZVxyXG4gICAgICAgICAgICAvL2hhdmUgYW4gb3BlcmF0b3Igb24gb25lIGVuZFxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKFsnICsgb3N0ciArICddKVxcXFxzKyhbJyArIG9zdHIgKyAnXSknKTtcclxuICAgICAgICB9KSgpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXBsYWNlcyBuZXJkYW1lci5zZXRPcGVyYXRvclxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcGVyYXRvclxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hpZnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNldE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yLCBhY3Rpb24sIHNoaWZ0KSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gb3BlcmF0b3Iub3BlcmF0b3I7IC8vdGFrZSB0aGUgbmFtZSB0byBiZSB0aGUgc3ltYm9sXHJcbiAgICAgICAgICAgIG9wZXJhdG9yc1tuYW1lXSA9IG9wZXJhdG9yO1xyXG4gICAgICAgICAgICBpZihhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICB0aGlzW29wZXJhdG9yLmFjdGlvbl0gPSBhY3Rpb247XHJcbiAgICAgICAgICAgIC8vbWFrZSB0aGUgcGFyc2VyIGF3YXJlIG9mIHRoZSBvcGVyYXRvclxyXG4gICAgICAgICAgICBfW25hbWVdID0gb3BlcmF0b3Iub3BlcmF0aW9uO1xyXG4gICAgICAgICAgICAvL21ha2UgdGhlIGFjdGlvbiBhdmFpbGFibGUgdG8gdGhlIHBhcnNlciBpZiBpbmZpeFxyXG4gICAgICAgICAgICBpZighb3BlcmF0b3IuYWN0aW9uICYmICEob3BlcmF0b3IucHJlZml4IHx8IG9wZXJhdG9yLnBvc3RpZikpIHtcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yLmFjdGlvbiA9IG5hbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiB0aGlzIG9wZXJhdG9yIGlzIGV4Y2x1c2l2ZSB0aGVuIGFsbCBzdWNjZXNzaXZlIG9wZXJhdG9ycyBzaG91bGQgYmUgc2hpZnRlZFxyXG4gICAgICAgICAgICBpZihzaGlmdCA9PT0gJ292ZXInIHx8IHNoaWZ0ID09PSAndW5kZXInKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlY2VkZW5jZSA9IG9wZXJhdG9yLnByZWNlZGVuY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIG9wZXJhdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gb3BlcmF0b3JzW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBzaGlmdCA9PT0gJ292ZXInID8gby5wcmVjZWRlbmNlID49IHByZWNlZGVuY2UgOiBvLnByZWNlZGVuY2UgPiBwcmVjZWRlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmRpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgby5wcmVjZWRlbmNlKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGFuIG9wZXJlcmF0b3IgYnkgaXRzIHN5bWJvbFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5nZXRPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3JzW29wZXJhdG9yXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmFsaWFzT3BlcmF0b3IgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBvcGVyYXRvcnNbb107XHJcbiAgICAgICAgICAgIC8vY29weSBldmVyeXRoaW5nIG92ZXIgdG8gdGhlIG5ldyBvcGVyYXRvclxyXG4gICAgICAgICAgICBmb3IodmFyIHggaW4gb3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIHRbeF0gPSBvcGVyYXRvclt4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgc3ltYm9sXHJcbiAgICAgICAgICAgIHQub3BlcmF0b3IgPSBuO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zZXRPcGVyYXRvcih0KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIG9wZXJhdG9ycy4gQ2F1dGlvbiEgQ2FuIGJyZWFrIHBhcnNlciFcclxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ2V0T3BlcmF0b3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvL3dpbGwgcmVwbGFjZSB0aGlzIHdpdGggc29tZSBjbG9uaW5nIGFjdGlvbiBpbiB0aGUgZnV0dXJlXHJcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvcnM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRCcmFja2V0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJyYWNrZXRzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBQcmVmb3JtcyBwcmVwcm9jZXNzaW5nIG9uIHRoZSBzdHJpbmcuIFVzZWZ1bCBmb3IgbWFraW5nIGVhcmx5IG1vZGlmaWNhdGlvbiBiZWZvcmVcclxuICAgICAgICAgKiBzZW5kaW5nIHRvIHRoZSBwYXJzZXJcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBwcmVwYXJlX2V4cHJlc3Npb24gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBTaW5jZSB2YXJpYWJsZXMgY2Fubm90IHN0YXJ0IHdpdGggYSBudW1iZXIsIHRoZSBhc3N1bXB0aW9uIGlzIG1hZGUgdGhhdCB3aGVuIHRoaXMgb2NjdXJzIHRoZVxyXG4gICAgICAgICAgICAgKiB1c2VyIGludGVudHMgZm9yIHRoaXMgdG8gYmUgYSBjb2VmZmljaWVudC4gVGhlIG11bHRpcGxpY2F0aW9uIHN5bWJvbCBpbiB0aGVuIGFkZGVkLiBUaGUgc2FtZSBnb2VzIGZvclxyXG4gICAgICAgICAgICAgKiBhIHNpZGUtYnktc2lkZSBjbG9zZSBhbmQgb3BlbiBwYXJlbnRoZXNpc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZSA9IFN0cmluZyhlKTtcclxuICAgICAgICAgICAgLy9hcHBseSBwcmVwcm9jZXNzb3JzXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwcmVwcm9jZXNzb3JzLmFjdGlvbnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBlID0gcHJlcHJvY2Vzc29ycy5hY3Rpb25zW2ldLmNhbGwodGhpcywgZSk7XHJcblxyXG4gICAgICAgICAgICAvL2UgPSBlLnNwbGl0KCcgJykuam9pbignJyk7Ly9zdHJpcCBlbXB0eSBzcGFjZXNcclxuICAgICAgICAgICAgLy9yZXBsYWNlIG11bHRpcGxlIHNwYWNlcyB3aXRoIG9uZSBzcGFjZVxyXG4gICAgICAgICAgICBlID0gZS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XHJcblxyXG4gICAgICAgICAgICAvL29ubHkgZXZlbiBib3RoZXIgdG8gY2hlY2sgaWYgdGhlIHN0cmluZyBjb250YWlucyBlLiBUaGlzIHJlZ2V4IGlzIHBhaW5mdWxseSBzbG93IGFuZCBtaWdodCBuZWVkIGEgYmV0dGVyIHNvbHV0aW9uLiBlLmcuIGhhbmdzIG9uICgwLjA2LzM2NTApKV4oMzY1KVxyXG4gICAgICAgICAgICBpZigvZS9naS50ZXN0KGUpKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gZS5yZXBsYWNlKC9cXC0qXFxkK1xcLipcXGQqZVxcKz9cXC0/XFxkKy9naSwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NpZW50aWZpY1RvRGVjaW1hbCh4KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vcmVwbGFjZSBzY2llbnRpZmljIG51bWJlcnNcclxuXHJcbiAgICAgICAgICAgIC8vYWxsb3cgb21pc3Npb24gb2YgbXVsdGlwbGljYXRpb24gYWZ0ZXIgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgIGUgPSBlLnJlcGxhY2UoU2V0dGluZ3MuSU1QTElFRF9NVUxUSVBMSUNBVElPTl9SRUdFWCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IGFyZ3VtZW50c1s0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAxID0gYXJndW1lbnRzWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cDIgPSBhcmd1bWVudHNbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gYXJndW1lbnRzWzNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHN0ci5jaGFyQXQoc3RhcnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSAnJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9ICcqJztcclxuICAgICAgICAgICAgICAgIGlmKCFmaXJzdC5tYXRjaCgvW1xcK1xcLVxcL1xcKl0vKSlcclxuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSBzdHIuY2hhckF0KHN0YXJ0IC0gMSk7XHJcbiAgICAgICAgICAgICAgICBpZihiZWZvcmUubWF0Y2goL1thLXpdL2kpKVxyXG4gICAgICAgICAgICAgICAgICAgIGQgPSAnJztcclxuICAgICAgICAgICAgICAgIHJldHVybiBncm91cDEgKyBkICsgZ3JvdXAyO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oW2EtejAtOV9dKykvZ2ksIGZ1bmN0aW9uIChtYXRjaCwgYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfTVVMVElDSEFSQUNURVJfVkFSUyA9PT0gZmFsc2UgJiYgIShhIGluIGZ1bmN0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFpc05hTihhKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnNwbGl0KCcnKS5qb2luKCcqJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAvL2FsbG93IG9taXNzaW9uIG9mIG11bHRpcGxpY2F0aW9uIHNpZ24gYmV0d2VlbiBicmFja2V0c1xyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXClcXCgvZywgJykqKCcpIHx8ICcwJztcclxuICAgICAgICAgICAgLy9yZXBsYWNlIHgoeCthKSB3aXRoIHgqKHgrYSlcclxuICAgICAgICAgICAgd2hpbGUodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVfb3JnID0gZTsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgICAgIGUgPSBlLnJlcGxhY2UoLyhbYS16MC05X10rKShcXCgpfChcXCkpKFthLXowLTldKykvZ2ksIGZ1bmN0aW9uIChtYXRjaCwgYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnMSA9IGEgfHwgYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gYiB8fCBkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGcxIGluIGZ1bmN0aW9ucykgLy9jcmVhdGUgYSBwYXNzdGhyb3VnaCBmb3IgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnMSArIGcyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnMSArICcqJyArIGcyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBvcmlnaW5hbCBlcXVhbHMgdGhlIHJlcGxhY2Ugd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgaWYoZV9vcmcgPT09IGUpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL2RlbGF5IHNldHRpbmcgb2YgY29uc3RhbnRzIHVudGlsIFNldHRpbmdzIGlzIHJlYWR5XHJcbiAgICAgICAgdGhpcy5pbml0Q29uc3RhbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLkNPTlNUQU5UUyA9IHtcclxuICAgICAgICAgICAgICAgIEU6IG5ldyBTeW1ib2woU2V0dGluZ3MuRSksXHJcbiAgICAgICAgICAgICAgICBQSTogbmV3IFN5bWJvbChTZXR0aW5ncy5QSSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRGVidWdnaW5nIG1ldGhvZCB1c2VkIHRvIGJldHRlciB2aXN1YWxpemUgdmVjdG9yIGFuZCBhcnJheXNcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcmV0dHlfcHJpbnQgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG8pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG8ubWFwKHggPT4gXy5wcmV0dHlfcHJpbnQoeCkpLmpvaW4oJywgJyk7XHJcbiAgICAgICAgICAgICAgICBpZihvLnR5cGUgPT09ICd2ZWN0b3InKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndmVjdG9yPCcgKyBzICsgJz4nO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcoJyArIHMgKyAnKSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG8udG9TdHJpbmcoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucGVla2VycyA9IHtcclxuICAgICAgICAgICAgcHJlX29wZXJhdG9yOiBbXSxcclxuICAgICAgICAgICAgcG9zdF9vcGVyYXRvcjogW10sXHJcbiAgICAgICAgICAgIHByZV9mdW5jdGlvbjogW10sXHJcbiAgICAgICAgICAgIHBvc3RfZnVuY3Rpb246IFtdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5jYWxsUGVla2VycyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmKFNldHRpbmdzLmNhbGxQZWVrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGVla2VycyA9IHRoaXMucGVla2Vyc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBmaXJzdCBpdGVtcyBhbmQgc3RyaW5naWZ5XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50czJBcnJheShhcmd1bWVudHMpLnNsaWNlKDEpLm1hcChzdHJpbmdpZnkpO1xyXG4gICAgICAgICAgICAgICAgLy9jYWxsIGVhY2ggb25lIG9mIHRoZSBwZWVrZXJzXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGVla2Vycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlZWtlcnNbaV0uYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVG9rZW5pemVzIHRoZSBzdHJpbmdcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtUb2tlbltdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG9rZW5pemUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAvL2Nhc3QgdG8gU3RyaW5nXHJcbiAgICAgICAgICAgIGUgPSBTdHJpbmcoZSk7XHJcbiAgICAgICAgICAgIC8vcmVtb3ZlIG11bHRpcGxlIHdoaXRlIHNwYWNlcyBhbmQgc3BhY2VzIGF0IGJlZ2lubmluZyBhbmQgZW5kIG9mIHN0cmluZ1xyXG4gICAgICAgICAgICBlID0gZS50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xyXG4gICAgICAgICAgICAvL3JlbW92ZSBzcGFjZXMgYmVmb3JlIGFuZCBhZnRlciBicmFja2V0c1xyXG4gICAgICAgICAgICBmb3IodmFyIHggaW4gYnJhY2tldHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoYnJhY2tldHNbeF0uaXNfY2xvc2UgPyAnXFxcXHMrXFxcXCcgKyB4IDogJ1xcXFwnICsgeCArICdcXFxccysnLCAnZycpO1xyXG4gICAgICAgICAgICAgICAgZSA9IGUucmVwbGFjZShyZWdleCwgeCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjb2wgPSAwOyAvL3RoZSBjb2x1bW4gcG9zaXRpb25cclxuICAgICAgICAgICAgdmFyIEwgPSBlLmxlbmd0aDsgLy9leHByZXNzaW9uIGxlbmd0aFxyXG4gICAgICAgICAgICB2YXIgbHBvcyA9IDA7IC8vbWFya3MgYmVnaW5uaW5nIG9mIG5leHQgdG9rZW5cclxuICAgICAgICAgICAgdmFyIHRva2VucyA9IFtdOyAvL3RoZSB0b2tlbnMgY29udGFpbmVyXHJcbiAgICAgICAgICAgIHZhciBzY29wZXMgPSBbdG9rZW5zXTsgLy9pbml0aWF0ZSB3aXRoIHRoZSB0b2tlbnMgYXMgdGhlIGhpZ2hlc3Qgc2NvcGVcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHNjb3Blc1swXTsgLy90aGUgdGFyZ2V0IHRvIHdoaWNoIHRoZSB0b2tlbnMgYXJlIGFkZGVkLiBUaGlzIGNhbiBzd2luZyB1cCBvciBkb3duXHJcbiAgICAgICAgICAgIHZhciBkZXB0aCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBvcGVuX2JyYWNrZXRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBoYXNfc3BhY2UgPSBmYWxzZTsgLy9tYXJrcyBpZiBhbiBvcGVuIHNwYWNlIGNoYXJhY3RlciB3YXMgZm91bmRcclxuICAgICAgICAgICAgdmFyIFNQQUNFID0gJyAnO1xyXG4gICAgICAgICAgICB2YXIgRU1QVFlfU1RSSU5HID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBDT01NQSA9ICcsJztcclxuICAgICAgICAgICAgdmFyIE1JTlVTID0gJy0nO1xyXG4gICAgICAgICAgICB2YXIgTVVMVCA9ICcqJztcclxuICAgICAgICAgICAgLy9Qb3NzaWJsZSBzb3VyY2Ugb2YgYnVnLiBSZXZpZXdcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgIC8vZ2V0cyB0aGUgbmV4dCBzcGFjZVxyXG4gICAgICAgICAgICAgdmFyIG5leHRfc3BhY2UgPSBmdW5jdGlvbihmcm9tKSB7XHJcbiAgICAgICAgICAgICBmb3IodmFyIGk9ZnJvbTsgaTxMOyBpKyspIHtcclxuICAgICAgICAgICAgIGlmKGUuY2hhckF0KGkpID09PSAnICcpXHJcbiAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgcmV0dXJuIEw7IC8vYXNzdW1lIHRoZSBlbmQgb2YgdGhlIHN0cmluZyBpbnN0ZWFkXHJcbiAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBzY29wZSB0byB0b2tlbnNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNjb3BlX3R5cGVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtpbnR9IGNvbHVtblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGFkZFNjb3BlID0gZnVuY3Rpb24gKHNjb3BlX3R5cGUsIGNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld19zY29wZSA9IFtdOyAvL2NyZWF0ZSBhIG5ldyBzY29wZVxyXG4gICAgICAgICAgICAgICAgaWYoc2NvcGVfdHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3X3Njb3BlLnR5cGUgPSBzY29wZV90eXBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3X3Njb3BlLmNvbHVtbiA9IGNvbHVtbjsgLy9tYXJrIHRoZSBjb2x1bW4gb2YgdGhlIHNjb3BlXHJcbiAgICAgICAgICAgICAgICBzY29wZXMucHVzaChuZXdfc2NvcGUpOyAvL2FkZCBpdCB0byB0aGUgbGlzdCBvZiBzY29wZXNcclxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ld19zY29wZSk7IC8vYWRkIGl0IHRvIHRoZSB0b2tlbnMgbGlzdCBzaW5jZSBub3cgaXQncyBhIHNjb3BlXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBuZXdfc2NvcGU7IC8vcG9pbnQgdG8gaXRcclxuICAgICAgICAgICAgICAgIGRlcHRoKys7IC8vZ28gZG93biBvbmUgaW4gc2NvcGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdvZXMgdXAgaW4gc2NvcGUgYnkgb25lXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgZ29VcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHNjb3Blcy5wb3AoKTsgLy9yZW1vdmUgdGhlIHNjb3BlIGZyb20gdGhlIHNjb3BlcyBzdGFja1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gc2NvcGVzWy0tZGVwdGhdOyAvL3BvaW50IHRoZSBhYm92ZSBzY29wZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXh0cmFjdHMgYWxsIHRoZSBvcGVyYXRvcnMgZnJvbSB0aGUgZXhwcmVzc2lvbiBzdHJpbmcgc3RhcnRpbmcgYXQgcG9zdGlvbiBzdGFydF9hdFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludH0gc3RhcnRfYXRcclxuICAgICAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBnZXRfb3BlcmF0b3Jfc3RyID0gZnVuY3Rpb24gKHN0YXJ0X2F0KSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydF9hdCA9IHN0YXJ0X2F0ICE9PSB1bmRlZmluZWQgPyBzdGFydF9hdCA6IGNvbDtcclxuICAgICAgICAgICAgICAgIC8vbWFyayB0aGUgZW5kIG9mIHRoZSBvcGVyYXRvciBhcyB0aGUgc3RhcnQgc2luY2Ugd2UncmUganVzdCBnb2luZ1xyXG4gICAgICAgICAgICAgICAgLy90byBiZSB3YWxraW5nIGFsb25nIHRoZSBzdHJpbmdcclxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydF9hdCArIDE7XHJcbiAgICAgICAgICAgICAgICAvL2p1c3Qga2VlcCBtb3ZpbmcgYWxvbmdcclxuICAgICAgICAgICAgICAgIHdoaWxlKGUuY2hhckF0KGVuZCsrKSBpbiBvcGVyYXRvcnMpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vcmVtZW1iZXIgdGhhdCB3ZSBzdGFydGVkIGF0IG9uZSBwb3NpdGlvbiBhaGVhZC4gVGhlIGJlZ2lubmluZyBvcGVyYXRvciBpcyB3aGF0IHRyaWdnZXJlZFxyXG4gICAgICAgICAgICAgICAgLy90aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiB0aGUgZmlyc3QgcGxhY2UuIFN0cmluZy5DaGFyQXQgaXMgemVybyBiYXNlZCBzbyB3ZSBub3dcclxuICAgICAgICAgICAgICAgIC8vaGF2ZSB0byBjb3JyZWN0IHR3byBwbGFjZXMuIFRoZSBpbml0aWFsIGluY3JlbWVudCArIHRoZSBleHRyYSsrIGF0IHRoZSBlbmQgb2YgZW5kIGR1cmluZ1xyXG4gICAgICAgICAgICAgICAgLy90aGUgbGFzdCBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5zdWJzdHJpbmcoc3RhcnRfYXQsIGVuZCAtIDEpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnJlYWtzIG9wZXJhdG9yIHVwIGluIHRvIHNldmVyYWwgZGlmZmVyZW50IG9wZXJhdG9ycyBhcyBkZWZpbmVkIGluIG9wZXJhdG9yc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3Jfc3RyXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBjaHVua2lmeSA9IGZ1bmN0aW9uIChvcGVyYXRvcl9zdHIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGNvbCAtIG9wZXJhdG9yX3N0ci5sZW5ndGg7IC8vc3RhcnQgb2Ygb3BlcmF0b3JcclxuICAgICAgICAgICAgICAgIHZhciBfb3BlcmF0b3JzID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBvcGVyYXRvcl9zdHIuY2hhckF0KDApO1xyXG4gICAgICAgICAgICAgICAgLy9ncmFiIHRoZSBsYXJnZXN0IHBvc3NpYmxlIGNodW5rcyBidXQgc3RhcnQgYXQgMiBzaW5jZSB3ZSBhbHJlYWR5IGtub3dcclxuICAgICAgICAgICAgICAgIC8vdGhhdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIGFuIG9wZXJhdG9yXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMSwgTCA9IG9wZXJhdG9yX3N0ci5sZW5ndGg7IGkgPCBMOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSBvcGVyYXRvcl9zdHIuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gb3BlcmF0b3IgKyBjaDtcclxuICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIHRoZSBvcGVyYXRvciBub3cgaXMgdW5kZWZpbmVkIHRoZW4gdGhlIGxhc3Qgb3BlcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAvL3dhcyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBjb21iaW5hdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICBpZighKG8gaW4gb3BlcmF0b3JzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfb3BlcmF0b3JzLnB1c2gobmV3IFRva2VuKG9wZXJhdG9yLCBUb2tlbi5PUEVSQVRPUiwgc3RhcnQgKyBpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gY2g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBvOy8vbm93IHRoZSBvcGVyYXRvciBpcyB0aGUgbGFyZ2VyIGNodW5rXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2FkZCB0aGUgbGFzdCBvcGVyYXRvclxyXG4gICAgICAgICAgICAgICAgX29wZXJhdG9ycy5wdXNoKG5ldyBUb2tlbihvcGVyYXRvciwgVG9rZW4uT1BFUkFUT1IsIHN0YXJ0ICsgaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vcGVyYXRvcnM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSXMgdXNlZCB0byBhZGQgYSB0b2tlbiB0byB0aGUgdG9rZW5zIGFycmF5LiBNYWtlcyBzdXJlIHRoYXQgbm8gZW1wdHkgdG9rZW4gaXMgYWRkZWRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtpbnR9IGF0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGFkZF90b2tlbiA9IGZ1bmN0aW9uIChhdCwgdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIC8vZ3JhYiB0aGUgdG9rZW4gaWYgd2UncmUgbm90IHN1cHBsaWVkIG9uZVxyXG4gICAgICAgICAgICAgICAgaWYodG9rZW4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGUuc3Vic3RyaW5nKGxwb3MsIGF0KTtcclxuICAgICAgICAgICAgICAgIC8vb25seSBhZGQgaXQgaWYgaXQncyBub3QgYW4gZW1wdHkgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBpZih0b2tlbiBpbiBfLnVuaXRzKVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUb2tlbih0b2tlbiwgVG9rZW4uVU5JVCwgbHBvcykpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih0b2tlbiAhPT0gJycpXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRva2VuKHRva2VuLCBUb2tlbi5WQVJJQUJMRV9PUl9MSVRFUkFMLCBscG9zKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgZnVuY3Rpb24gdG8gdGhlIG91dHB1dFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGFkZF9mdW5jdGlvbiA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVG9rZW4oZiwgVG9rZW4uRlVOQ1RJT04sIGxwb3MpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRva2VucyBhcmUgZm91bmQgYmV0d2VlbiBvcGVyYXRvcnMgc28gdGhpcyBtYXJrcyB0aGUgbG9jYXRpb24gb2Ygd2hlcmUgdGhlIGxhc3QgdG9rZW4gd2FzIGZvdW5kXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7aW50fSBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIHNldF9sYXN0X3Bvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBscG9zID0gcG9zaXRpb24gKyAxO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hlbiBhIG9wZXJhdG9yIGlzIGZvdW5kIGFuZCBhZGRlZCwgZXNwZWNpYWxseSBhIGNvbWJvIG9wZXJhdG9yLCB0aGVuIHRoZSBjb2x1bW4gbG9jYXRpb25cclxuICAgICAgICAgICAgICogaGFzIHRvIGJlIGFkanVzdGVkIHRvIHRoZSBlbmQgb2YgdGhlIG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgYWRqdXN0X2NvbHVtbl9wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxwb3MgPSBscG9zICsgb3BlcmF0b3Jfc3RyLmxlbmd0aCAtIDI7XHJcbiAgICAgICAgICAgICAgICBjb2wgPSBscG9zIC0gMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yKDsgY29sIDwgTDsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaCA9IGUuY2hhckF0KGNvbCk7XHJcbiAgICAgICAgICAgICAgICBpZihjaCBpbiBvcGVyYXRvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRfdG9rZW4oY29sKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2lzIHRoZSBsYXN0IHRva2VuIG51bWVyaWM/XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RfdG9rZW5faXNfbnVtZXJpYyA9IHRhcmdldFswXSAmJiBpc051bWJlcih0YXJnZXRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaXMgdGhpcyBjaGFyYWN0ZXIgbXVsdGlwbGljYXRpb24/XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX211bHRpcGxpY2F0aW9uID0gbGFzdF90b2tlbl9pc19udW1lcmljICYmIGNoID09PSBNVUxUO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgd2UncmUgaW4gYSBuZXcgc2NvcGUgdGhlbiBnbyB1cCBieSBvbmUgYnV0IGlmIHRoZSBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vaXMgcmlnaHQgYmVmb3IgYW4gb3BlcmF0b3IgdGhlbiBpdCBtYWtlcyBubyBzZW5zZSB0byBnbyB1cCBpbiBzY29wZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc2lkZXIgc2luIC14LiBUaGUgbGFzdCBwb3NpdGlvbiA9IGN1cnJlbnQgcG9zaXRpb24gYXQgdGhlIG1pbnVzIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbWVhbnMgdGhhdCB3ZSdyZSBnb2luZyBmb3Igc2luKHgpIC14IHdoaWNoIGlzIHdyb25nXHJcbiAgICAgICAgICAgICAgICAgICAgLy9JZ25vcmUgY29tbWEgc2luY2UgY29tbWEgaXMgc3RpbGwgcGFydCBvZiB0aGUgZXhpc3Rpbmcgc2NvcGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzX3NwYWNlICYmIGxwb3MgPCBjb2wgJiYgIShjaCA9PT0gQ09NTUEgfHwgaXNfbXVsdGlwbGljYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc19zcGFjZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnb1VwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vbWFyayB0aGUgbGFzdCBwb3NpdGlvbiB0aGF0IGFcclxuICAgICAgICAgICAgICAgICAgICBzZXRfbGFzdF9wb3NpdGlvbihjb2wgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3Jfc3RyID0gZ2V0X29wZXJhdG9yX3N0cihjb2wpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhZGp1c3RfY29sdW1uX3Bvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2guYXBwbHkodGFyZ2V0LCBjaHVua2lmeShvcGVyYXRvcl9zdHIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoY2ggaW4gYnJhY2tldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnJhY2tldCA9IGJyYWNrZXRzW2NoXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYnJhY2tldC5pc19vcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFyayB0aGUgYnJhY2tldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuX2JyYWNrZXRzLnB1c2goW2JyYWNrZXQsIGxwb3NdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBlLnN1YnN0cmluZyhscG9zLCBjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmIGluIGZ1bmN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2Z1bmN0aW9uKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZiAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXNzdW1lIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IEFkZCB0aGUgbXVsdGlwbGljYXRpb24gdG8gc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUb2tlbihmLCBUb2tlbi5WQVJJQUJMRV9PUl9MSVRFUkFMLCBscG9zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nbyBkb3duIG9uZSBpbiBzY29wZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTY29wZShicmFja2V0Lm1hcHNfdG8sIGNvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYnJhY2tldC5pc19jbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgbWF0Y2hpbmcgYnJhY2tldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IG9wZW5fYnJhY2tldHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgZXJyb3JzIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWlzc2luZyBvcGVuIGJyYWNrZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXBhaXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyaXR5RXJyb3IoJ01pc3Npbmcgb3BlbiBicmFja2V0IGZvciBicmFja2V0IGF0OiAnICsgKGNvbCArIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pbmNvcnJlY3QgcGFpclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHBhaXJbMF0uaWQgIT09IGJyYWNrZXQuaWQgLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcml0eUVycm9yKCdQYXJpdHkgZXJyb3InKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b2tlbihjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnb1VwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNldF9sYXN0X3Bvc2l0aW9uKGNvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNoID09PSBTUEFDRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gZS5zdWJzdHJpbmcobHBvcywgY29sKTsgLy9sb29rIGJhY2tcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gZS5jaGFyQXQoY29sICsgMSk7IC8vbG9vayBmb3J3YXJkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzX3NwYWNlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2IGluIG9wZXJhdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRva2VuKHByZXYsIFRva2VuLk9QRVJBVE9SLCBjb2wpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b2tlbih1bmRlZmluZWQsIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSdyZSBhdCB0aGUgY2xvc2luZyBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ29VcCgpOyAvL2dvIHVwIGluIHNjb3BlIGlmIHdlJ3JlIGF0IGEgc3BhY2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc3VtZSBtdWx0aXBsaWNhdGlvbiBpZiBpdCdzIG5vdCBhbiBvcGVyYXRvciBleGNlcHQgZm9yIG1pbnVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNfb3BlcmF0b3IgPSBueHQgaW4gb3BlcmF0b3JzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKChpc19vcGVyYXRvciAmJiBvcGVyYXRvcnNbbnh0XS52YWx1ZSA9PT0gTUlOVVMpIHx8ICFpc19vcGVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUb2tlbihNVUxULCBUb2tlbi5PUEVSQVRPUiwgY29sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzX3NwYWNlID0gZmFsc2U7IC8vcmVtb3ZlIHRoZSBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSdyZSBhdCB0aGUgY2xvc2luZyBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGl0J3MgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGUuc3Vic3RyaW5nKGxwb3MsIGNvbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmIGluIGZ1bmN0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGVyZSdzIG5vIG5lZWQgdG8gZ28gdXAgaW4gc2NvcGUgaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFuIG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfc3BhY2UgPSB0cnVlOyAvL21hcmsgdGhhdCBhIHNwYWNlIHdhcyBmb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX2Z1bmN0aW9uKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU2NvcGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGYgaW4gb3BlcmF0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVG9rZW4oZiwgVG9rZW4uT1BFUkFUT1IsIGNvbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3Rva2VuKHVuZGVmaW5lZCwgZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BlZWsgYWhlYWQgdG8gdGhlIG5leHQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gZS5jaGFyQXQoY29sICsgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBpdCdzIGEgbnVtYmVyIHRoZW4gYWRkIHRoZSBtdWx0aXBsaWNhdGlvbiBvcGVyYXRvciB0byB0aGUgc3RhY2sgYnV0IG1ha2Ugc3VyZSB0aGF0IHRoZSBuZXh0IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pcyBub3QgYW4gb3BlcmF0b3JcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwcmV2ICE9PSBFTVBUWV9TVFJJTkcgJiYgbnh0ICE9PSBFTVBUWV9TVFJJTkcgJiYgIShwcmV2IGluIG9wZXJhdG9ycykgJiYgIShueHQgaW4gb3BlcmF0b3JzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVG9rZW4oTVVMVCwgVG9rZW4uT1BFUkFUT1IsIGNvbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vUG9zc2libGUgc291cmNlIG9mIGJ1Zy4gUmV2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAvL3NwYWNlIGNhbiBtZWFuIG11bHRpcGxpY2F0aW9uIHNvIGFkZCB0aGUgc3ltYm9sIGlmIHRoZSBpcyBlbmNvdW50ZXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYoL1xcZCt8XFxkK1xcLj9cXGQqZVtcXCtcXC1dKlxcZCsvaS50ZXN0KGYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGUuY2hhckF0KGNvbCsxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0X2lzX29wZXJhdG9yID0gbmV4dCBpbiBvcGVyYXRvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnMgPSBuZXh0X3NwYWNlKGNvbCsxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0X3dvcmQgPSBlLnN1YnN0cmluZyhjb2wrMSwgbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBjYW4gZWl0aGVyIGJlIGEgcHJlZml4IG9wZXJhdG9yIG9yIG5vIG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZigobmV4dF9pc19vcGVyYXRvciAmJiBvcGVyYXRvcnNbbmV4dF0ucHJlZml4KSB8fCAhKG5leHRfaXNfb3BlcmF0b3IgfHwgbmV4dF93b3JkIGluIG9wZXJhdG9ycykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVG9rZW4oJyonLCBUb2tlbi5PUEVSQVRPUiwgY29sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZXRfbGFzdF9wb3NpdGlvbihjb2wpOyAvL21hcmsgdGhpcyBsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY2hlY2sgdGhhdCBhbGwgYnJhY2tldHMgd2VyZSBjbG9zZWRcclxuICAgICAgICAgICAgaWYob3Blbl9icmFja2V0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gb3Blbl9icmFja2V0cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJpdHlFcnJvcignTWlzc2luZyBjbG9zZWQgYnJhY2tldCBmb3IgYnJhY2tldCBhdCAnICsgKGJbMV0gKyAxKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9hZGQgdGhlIGxhc3QgdG9rZW5cclxuICAgICAgICAgICAgYWRkX3Rva2VuKGNvbCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBQdXRzIHRva2VuIGFycmF5IGluIFJldmVyc2UgUG9saXNoIE5vdGF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7VG9rZW5bXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRvUlBOID0gZnVuY3Rpb24gKHRva2Vucykge1xyXG4gICAgICAgICAgICB2YXIgZm4gPSB0b2tlbnMudHlwZTtcclxuICAgICAgICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoLCBpO1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgcHJlZml4ZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGNvbGxhcHNlID0gZnVuY3Rpb24gKHRhcmdldCwgZGVzdGluYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlKHRhcmdldC5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24ucHVzaCh0YXJnZXQucG9wKCkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvL21hcmsgYWxsIHRoZSBwcmVmaXhlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYodG9rZW4udHlwZSAhPT0gVG9rZW4uT1BFUkFUT1IpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBpZighdG9rZW4ucHJlZml4KVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRvckVycm9yKCdOb3QgYSBwcmVmaXggb3BlcmF0b3InKTtcclxuICAgICAgICAgICAgICAgIHRva2VuLmlzX3ByZWZpeCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2JlZ2luIHdpdGggcmVtYWluaW5nIHRva2Vuc1xyXG4gICAgICAgICAgICBmb3IoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKGUudHlwZSA9PT0gVG9rZW4uT1BFUkFUT1IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3IgPSBlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NyZWF0ZSB0aGUgb3B0aW9uIGZvciB0aGUgb3BlcmF0b3IgYmVpbmcgb3ZlcmxvYWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wZXJhdG9yLm92ZXJsb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSB0b2tlbnNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3MgZm9sbG93ZWQgYnkgYSBudW1iZXIgb3IgdmFyaWFibGUgdGhlbiB3ZSBhc3N1bWUgaXQncyBub3QgYSBwb3N0Zml4IG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5leHQgJiYgbmV4dC50eXBlID09PSBUb2tlbi5WQVJJQUJMRV9PUl9MSVRFUkFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci5wb3N0Zml4ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL292ZXJyaWRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBvdmVybG9hZCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IuYWN0aW9uID0gb3BlcmF0b3Iub3ZlcmxvYWRBY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci5sZWZ0QXNzb2MgPSBvcGVyYXRvci5vdmVybG9hZExlZnRBc3NvYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgc3RhY2sgaXMgbm90IGVtcHR5XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKHRoZXJlIGlzIGFuIG9wZXJhdG9yIGF0IHRoZSB0b3Agb2YgdGhlIG9wZXJhdG9yIHN0YWNrIHdpdGggZ3JlYXRlciBwcmVjZWRlbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL29yICh0aGUgb3BlcmF0b3IgYXQgdGhlIHRvcCBvZiB0aGUgb3BlcmF0b3Igc3RhY2sgaGFzIGVxdWFsIHByZWNlZGVuY2UgYW5kIGlzIGxlZnQgYXNzb2NpYXRpdmUpKSB+IHdpa2lwZWRpYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSAhcHJlZml4ZXMubGVuZ3RoIG1ha2VzIHN1cmUgdGhhdCB0aGUgb3BlcmF0b3Igb24gc3RhY2sgaXNuJ3QgcHJlbWF0dXJlbHkgdGFrZW4gZnJvbXQgaGUgc3RhY2suXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCEobGFzdC5wcmVjZWRlbmNlID4gb3BlcmF0b3IucHJlY2VkZW5jZSB8fCAhb3BlcmF0b3IubGVmdEFzc29jICYmIGxhc3QucHJlY2VkZW5jZSA9PT0gb3BlcmF0b3IucHJlY2VkZW5jZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RhY2sucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIHRoZSBvcGVyYXRvciBpZiBpdCdzIGEgdmVjdG9yIGFuZCB3ZSd2ZSBiZWVuIGFza2VkIHRvIGRvIHNvXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoKGZuID09PSAndmVjdG9yJyB8fCBmbiA9PT0gJ3NldCcpICYmICd2ZWN0b3JGbicgaW4gb3BlcmF0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmFjdGlvbiA9IG9wZXJhdG9yLnZlY3RvckZuO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgb3BlcmF0b3IgaXMgYSBwb3N0Zml4IG9wZXJhdG9yIHRoZW4gd2UncmUgcmVhZHkgdG8gZ28gc2luY2UgaXQgYmVsb25nc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdG8gdGhlIHByZWNlZGluZyB0b2tlbi4gSG93ZXZlciB0aGUgb3V0cHV0IGNhbm5vdCBiZSBlbXB0eS4gSXQgbXVzdCBoYXZlIGVpdGhlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vYW4gb3BlcmF0b3Igb3IgYSB2YXJpYWJsZS9saXRlcmFsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3BlcmF0b3IucG9zdGZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0b2tlbnNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighcHJldmlvdXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0b3JFcnJvcihcIlVuZXhwZWN0ZWQgcHJlZml4IG9wZXJhdG9yICdcIiArIGUudmFsdWUgKyBcIichIGF0IFwiICsgZS5jb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHByZXZpb3VzLnR5cGUgPT09IFRva2VuLk9QRVJBVE9SKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2EgcG9zdGZpeCBjYW4gb25seSBiZSBmb2xsb3dlZCBieSBhIHBvc3RmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFwcmV2aW91cy5wb3N0Zml4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRvckVycm9yKFwiVW5leHBlY3RlZCBwcmVmaXggb3BlcmF0b3IgJ1wiICsgcHJldmlvdXMudmFsdWUgKyBcIichIGF0IFwiICsgcHJldmlvdXMuY29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBtdXN0IGJlIGF0IGFuIGluZml4IHNvIHBvaW50IHRoZSBvcGVyYXRvciB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGZpcnN0IG9uZSBpcyBhbiBpbmZpeCBvcGVyYXRvciBhbGwgb3RoZXJzIGhhdmUgdG8gYmUgcHJlZml4IG9wZXJhdG9ycyBzbyBqdW1wIHRvIHRoZSBlbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdG9rZW5zW2kgKyAxXTsgLy90YWtlIGEgbG9vayBhaGVhZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRfaXNfb3BlcmF0b3IgPSBuZXh0ID8gbmV4dC50eXBlID09PSBUb2tlbi5PUEVSQVRPUiA6IGZhbHNlOyAvL2NoZWNrIGlmIGl0J3MgYW4gb3BlcmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5leHRfaXNfb3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3Mgbm90IGEgcHJlZml4IG9wZXJhdG9yIHRoZW4gaXQgbm90IGluIHRoZSByaWdodCBwbGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFuZXh0LnByZWZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0b3JFcnJvcignQSBwcmVmaXggb3BlcmF0b3Igd2FzIGV4cGVjdGVkIGF0ICcgKyBuZXh0LmNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFyayBpdCBhcyBhIGNvbmZpcm1lZCBwcmVmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmlzX3ByZWZpeCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgaXQgdG8gdGhlIHByZWZpeGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ZXMucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUobmV4dF9pc19vcGVyYXRvcilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaXQncyBhIHByZWZpeCBpdCBzaG91bGQgYmUgb24gYSBzcGVjaWFsIHN0YWNrIGNhbGxlZCBwcmVmaXhlc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vd2UgZG8gdGhpcyB0byBob2xkIG9uIHRvIHByZWZpeGVzIGJlY2F1c2Ugb2YgbGVmdCBhc3NvY2lhdGl2ZSBvcGVyYXRvcnMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGV5IGJlbG9uZyB0byB0aGUgdmFyaWFibGUvbGl0ZXJhbCBidXQgaWYgcGxhY2VkIG9uIGVpdGhlciB0aGUgc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAvL29yIG91dHB1dCB0aGVyZSdzIG5vIHdheSBvZiBrbm93aW5nIHRoaXMuIEkgbWlnaHQgYmUgd3Jvbmcgc28gSSB3ZWxjb21lXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hbnkgZGlzY3Vzc2lvbiBhYm91dCB0aGlzLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihvcGVyYXRvci5pc19wcmVmaXgpIC8vQUREIEFMTCBFWENFUFRJT05TIEZPUiBBRERJTkcgVE8gUFJFRklYIFNUQUNLIEhFUkUuICEhIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXhlcy5wdXNoKG9wZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gob3BlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbW92ZSB0aGUgcHJlZml4ZXMgdG8gdGhlIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUocHJlZml4ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG9wZXJhdG9yLmxlZnRBc3NvYyB8fCAhb3BlcmF0b3IubGVmdEFzc29jICYmIHByZWZpeGVzW3ByZWZpeGVzLmxlbmd0aCAtIDFdLnByZWNlZGVuY2UgPj0gb3BlcmF0b3IucHJlY2VkZW5jZSkgLy9yZXZpc2l0IGZvciBjb21tYXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocHJlZml4ZXMucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGUudHlwZSA9PT0gVG9rZW4uVkFSSUFCTEVfT1JfTElURVJBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbW92ZSBwcmVmaXhlcyB0byBzdGFjayBhdCBiZWdpbm5pbmcgb2Ygc2NvcGVcclxuICAgICAgICAgICAgICAgICAgICBpZihvdXRwdXQubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZShwcmVmaXhlcywgc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZG9uZSB3aXRoIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3Rfb25fc3RhY2sgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAvL3RoZW4gbW92ZSBhbGwgdGhlIHByZWZpeGVzIHRvIHRoZSBvdXRwdXRcclxuICAgICAgICAgICAgICAgICAgICBpZighbGFzdF9vbl9zdGFjayB8fCAhbGFzdF9vbl9zdGFjay5sZWZ0QXNzb2MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlKHByZWZpeGVzLCBvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihlLnR5cGUgPT09IFRva2VuLkZVTkNUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZS50eXBlID09PSBUb2tlbi5VTklUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGEgdW5pdCBpdCBiZWxvbmdzIG9uIHRoZSBzdGFjayBzaW5jZSBpdCdzIHRpZWQgdG8gdGhlIHByZXZpb3VzIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2lmIGl0J3MgYW4gYWRkaXRvbmFsIHNjb3BlIHRoZW4gcHV0IHRoYXQgaW50byBSUE4gZm9ybVxyXG4gICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHRoaXMudG9SUE4oZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGUudHlwZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gobmV3IFRva2VuKGUudHlwZSwgVG9rZW4uRlVOQ1RJT04sIGUuY29sdW1uKSk7IC8vc2luY2UgaXQncyBoaWRkZW4gaXQgbmVlZHMgbm8gY29sdW1uXHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY29sbGFwc2UgdGhlIHJlbWFpbmRlciBvZiB0aGUgc3RhY2sgYW5kIHByZWZpeGVzIHRvIG91dHB1dFxyXG4gICAgICAgICAgICBjb2xsYXBzZShzdGFjaywgb3V0cHV0KTtcclxuICAgICAgICAgICAgY29sbGFwc2UocHJlZml4ZXMsIG91dHB1dCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBQYXJzZXMgdGhlIHRva2Vuc1xyXG4gICAgICAgICAqIEBwYXJhbSB7VG9rZW5zW119IHJwblxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdWJzdGl0dXRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhcnNlUlBOID0gZnVuY3Rpb24gKHJwbiwgc3Vic3RpdHV0aW9ucykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy9kZWZhdWx0IHN1YnN0aXR1dGlvbnNcclxuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMgPSBzdWJzdGl0dXRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgLy9wcmVwYXJlIHRoZSBzdWJzdGl0dXRpb25zLlxyXG4gICAgICAgICAgICAgICAgLy93ZSBmaXJzdCBwYXJzZSB0aGVtIG91dCBhcy1pc1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHN1YnN0aXR1dGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9uc1t4XSA9IF8ucGFyc2Uoc3Vic3RpdHV0aW9uc1t4XSwge30pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQWx0aG91Z2ggdGVjaG5pY2FsbHkgY29uc3RhbnRzLFxyXG4gICAgICAgICAgICAgICAgLy9waSBhbmQgZSBhcmUgb25seSBhdmFpbGFibGUgd2hlbiBldmFsdWF0aW5nIHRoZSBleHByZXNzaW9uIHNvIGFkZCB0byB0aGUgc3Vicy5cclxuICAgICAgICAgICAgICAgIC8vRG9pbmcgdGhpcyBhdm9pZHMgcm91bmRpbmcgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAvL2xpbmsgZSBhbmQgcGlcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlIHRoZSB2YWx1ZSBwcm92aWRlZCBpZiB0aGUgaW5kaXZpZHVhbCBmb3Igc29tZSBzdHJhbmdlIHJlYXNvbiBwcmVmZXJzIHRoaXMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vbmUgcmVhc29uIGNvdWxkIGJlIHRvIHN1YiBlIGJ1dCBub3QgcGkgb3IgdmljZSB2ZXJzYVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCEoJ2UnIGluIHN1YnN0aXR1dGlvbnMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLmUgPSBuZXcgU3ltYm9sKFNldHRpbmdzLkUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCghKCdwaScgaW4gc3Vic3RpdHV0aW9ucykpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnBpID0gbmV3IFN5bWJvbChTZXR0aW5ncy5QSSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIFEgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBycG4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBycG5baV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vQXJyYXlzIGluZGljYXRlIGEgbmV3IHNjb3BlIHNvIHBhcnNlIHRoYXQgb3V0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy5wYXJzZVJQTihlLCBzdWJzdGl0dXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZS50eXBlID09PSBUb2tlbi5PUEVSQVRPUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZS5pc19wcmVmaXggfHwgZS5wb3N0Zml4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzb2x2ZSB0aGUgb3BlcmF0aW9uIGFzc29jYXRlZCB3aXRoIHRoZSBwcmVmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRLnB1c2goZS5vcGVyYXRpb24oUS5wb3AoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1Rocm93IGFuIGVycm9yIGlmIHRoZSBSSCB2YWx1ZSBpcyBlbXB0eS4gVGhpcyBjYW5ub3QgYmUgYSBwb3N0Zml4IHNpbmNlIHdlIGFscmVhZHkgY2hlY2tlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdG9yRXJyb3IoZSArICcgaXMgbm90IGEgdmFsaWQgcG9zdGZpeCBvcGVyYXRvciBhdCAnICsgZS5jb2x1bW4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNfY29tbWEgPSBlLmFjdGlvbiA9PT0gJ2NvbW1hJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnZlcnQgU2V0cyB0byBWZWN0b3JzIG9uIGFsbCBvcGVyYXRpb25zIGF0IHRoaXMgcG9pbnQuIFNldHMgYXJlIG9ubHkgcmVjb2duaXplZCBmdW5jdGlvbnMgb3IgaW5kaXZpZHVhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYSBpbnN0YW5jZW9mIFNldCAmJiAhaXNfY29tbWEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBWZWN0b3IuZnJvbVNldChhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYiBpbnN0YW5jZW9mIFNldCAmJiAhaXNfY29tbWEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBWZWN0b3IuZnJvbVNldChiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxsIGFsbCB0aGUgcHJlLW9wZXJhdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFBlZWtlcnMoJ3ByZV9vcGVyYXRvcicsIGEsIGIsIGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5zID0gX1tlLmFjdGlvbl0oYSwgYik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsbCBhbGwgdGhlIHByZS1vcGVyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxQZWVrZXJzKCdwb3N0X29wZXJhdG9yJywgYW5zLCBhLCBiLCBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGFucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihlLnR5cGUgPT09IFRva2VuLkZVTkNUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gYXJncy5wYXJlbnQ7IC8vbWFrZSBhIG5vdGUgb2YgdGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIShhcmdzIGluc3RhbmNlb2YgQ29sbGVjdGlvbikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IENvbGxlY3Rpb24uY3JlYXRlKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgcmV0dXJuIHZhbHVlIG1heSBiZSBhIHZlY3Rvci4gSWYgaXQgaXMgdGhlbiB3ZSBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9RIHRvIHNlZSBpZiB0aGVyZSdzIGFub3RoZXIgdmVjdG9yIG9uIHRoZSBzdGFjay4gSWYgaXQgaXMgdGhlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBjaGVjayBpZiBoYXMgZWxlbWVudHMuIElmIGl0IGRvZXMgdGhlbiB3ZSBrbm93IHRoYXQgd2UncmUgZGVhbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93aXRoIGFuIFwiZ2V0dGVyXCIgb2JqZWN0IGFuZCByZXR1cm4gdGhlIHJlcXVlc3RlZCB2YWx1ZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGwgdGhlIGZ1bmN0aW9uLiBUaGlzIGlzIHRoZSBfLmNhbGxmdW5jdGlvbiBtZXRob2QgaW4gbmVyZGFtZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsbCB0aGUgZnVuY3Rpb24uIFRoaXMgaXMgdGhlIF8uY2FsbGZ1bmN0aW9uIG1ldGhvZCBpbiBuZXJkYW1lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuX25hbWUgPSBlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuX2FyZ3MgPSBhcmdzLmdldEl0ZW1zKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxsIHRoZSBwcmUtZnVuY3Rpb24gcGVla2Vyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsUGVla2VycygncHJlX2Z1bmN0aW9uJywgZm5fbmFtZSwgZm5fYXJncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IF8uY2FsbGZ1bmN0aW9uKGZuX25hbWUsIGZuX2FyZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsbCB0aGUgcG9zdC1mdW5jdGlvbiBwZWVrZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxQZWVrZXJzKCdwb3N0X2Z1bmN0aW9uJywgcmV0LCBmbl9uYW1lLCBmbl9hcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IFFbUS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gcnBuW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0X2lzX2NvbW1hID0gbmV4dCAmJiBuZXh0LnR5cGUgPT09IFRva2VuLk9QRVJBVE9SICYmIG5leHQudmFsdWUgPT09ICcsJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighbmV4dF9pc19jb21tYSAmJiByZXQgaW5zdGFuY2VvZiBWZWN0b3IgJiYgbGFzdCAmJiBsYXN0LmVsZW1lbnRzICYmICEobGFzdCBpbnN0YW5jZW9mIENvbGxlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgcXVldWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IFEucG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZXR0ZXIgPSByZXQuZWxlbWVudHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBpdCdzIHN5bWJvbGljLiBJZiBzbyBwdXQgaXQgYmFjayBhbmQgYWRkIHRoZSBpdGVtIHRvIHRoZSBzdGFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFnZXR0ZXIuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZ2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFEucHVzaChyZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGdldHRlciBpbnN0YW5jZW9mIFNsaWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgaXQncyBhIFNsaWNlIHJldHVybiB0aGUgc2xpY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUS5wdXNoKFZlY3Rvci5mcm9tQXJyYXkoaXRlbS5lbGVtZW50cy5zbGljZShnZXR0ZXIuc3RhcnQsIGdldHRlci5lbmQpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBOdW1iZXIoZ2V0dGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlsID0gaXRlbS5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3VwcG9ydCBmb3IgbmVnYXRpdmUgaW5kaWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlsICsgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaXQgaXQncyBzdGlsbCBvdXQgb2YgYm91bmRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGluZGV4IDwgMCB8fCBpbmRleCA+PSBpbCkgLy9pbmRleCBzaG91bGQgbm8gbG9uZ2VyIGJlIG5lZ2F0aXZlIHNpbmNlIGl0J3MgYmVlbiByZXNldCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yYW5nZSBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlICcgKyAoZS5jb2x1bW4gKyAxKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGl0ZW0uZWxlbWVudHNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2N5Y2xpYyBidXQgd2UgbmVlZCB0byBtYXJrIHRoaXMgZm9yIGZ1dHVyZSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5nZXR0ZXIgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBpdGVtO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXh0ZW5kIHRoZSBwYXJlbnQgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFEucHVzaChyZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJiZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGUudmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodiBpbiBTZXR0aW5ncy5BTElBU0VTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBfLnBhcnNlKFNldHRpbmdzLkFMSUFTRVNbZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93cmFwIGl0IGluIGEgc3ltYm9sIGlmIG5lZWQgYmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZS50eXBlID09PSBUb2tlbi5WQVJJQUJMRV9PUl9MSVRFUkFMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgU3ltYm9sKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihlLnR5cGUgPT09IFRva2VuLlVOSVQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3IFN5bWJvbCh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmlzVW5pdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHN1YnN0aXR1dGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQWx3YXlzIGNvbnN0YW50cyBmaXJzdC4gVGhpcyBhdm9pZHMgdGhlIGJlaW5nIG92ZXJyaWRkZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHYgaW4gXy5DT05TVEFOVFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJiZWQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgU3ltYm9sKF8uQ09OU1RBTlRTW3ZdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmV4dCBzdWJzdGl0dXRpb25zLiBUaGlzIGFsbG93cyBkZWNsYXJlZCB2YXJpYWJsZSB0byBiZSBvdmVycmlkZGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSB2YWx1ZXMgbWF0Y2ggdG8gYXZvaWQgZXJhc2luZyB0aGUgbXVsdGlwbGllci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRXhhbXBsZTovZSA9IDMqYS4gc3Vic3R1dGl0aW5nIGEgZm9yIGEgd2lsbCB3aXBlIG91dCB0aGUgbXVsdGlwbGllci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodiBpbiBzdWJzdGl0dXRpb25zICYmIHYgIT09IHN1YnN0aXR1dGlvbnNbdl0udG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmJlZCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHN1YnN0aXR1dGlvbnNbdl0uY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmV4dCBkZWNsYXJlIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih2IGluIFZBUlMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJiZWQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBWQVJTW3ZdLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2Ugbm90YXRpb24gb2Ygd2hhdCBpdCB3YXMgYmVmb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzdWJiZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdWJiZWQgPSBzdWJiZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBRWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKFsndW5kZWZpbmVkJywgJ3N0cmluZycsICdudW1iZXInXS5pbmRleE9mKHR5cGVvZiByZXR2YWwpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVG9rZW5FcnJvcignVW5leHBlY3RlZCB0b2tlbiEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0aHJvd0Vycm9ycyA9IFtPdXRPZkZ1bmN0aW9uRG9tYWluRXJyb3JdO1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0aHJvdyBjZXJ0YWluIGVycm9ycyBpbiB0aGUgc2FtZSBjbGFzcyB0byBwcmVzZXJ2ZSB0aGVtXHJcbiAgICAgICAgICAgICAgICByZXRocm93RXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKEUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihlcnJvciBpbnN0YW5jZW9mIEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoZXJyb3IubWVzc2FnZSArICc6ICcgKyBlLmNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoZXJyb3IubWVzc2FnZSArICc6ICcgKyBlLmNvbHVtbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIG1ldGhvZCB0aGF0IHRyaWdnZXJzIHRoZSBwYXJzaW5nIG9mIHRoZSBzdHJpbmcuIEl0IGdlbmVyYXRlcyBhIHBhcnNlIHRyZWUgYnV0IHByb2Nlc3Nlc1xyXG4gICAgICAgICAqIGl0IHJpZ2h0IGF3YXkuIFRoZSBvcGVyYXRvciBmdW5jdGlvbnMgYXJlIGNhbGxlZCB3aGVuIHRoZWlyIHJlc3BlY3RpdmUgb3BlcmF0b3JzIGFyZSByZWFjaGVkLiBGb3IgaW5zdGFuY2VcclxuICAgICAgICAgKiArIHdpdGggY2F1c2UgdGhpcy5hZGQgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGxlZnQgYW5kIHJpZ2h0IGhhbmQgdmFsdWVzLiBJdCB3b3JrcyBieSB3YWxraW5nIGFsb25nIGVhY2hcclxuICAgICAgICAgKiBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyBhbmQgcGxhY2luZyB0aGUgb3BlcmF0b3JzIG9uIHRoZSBzdGFjayBhbmQgdmFsdWVzIG9uIHRoZSBvdXRwdXQuIFdoZW4gYW4gb3BlcmF0b3JcclxuICAgICAgICAgKiBoYXZpbmcgYSBsb3dlciBvcmRlciB0aGFuIHRoZSBsYXN0IGlzIHJlYWNoZWQgdGhlbiB0aGUgc3RhY2sgaXMgcHJvY2Vzc2VkIGZyb20gdGhlIGxhc3Qgb3BlcmF0b3Igb24gdGhlXHJcbiAgICAgICAgICogc3RhY2suXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIE5vZGUodG9rZW4pIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlID0gdG9rZW4udHlwZTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRva2VuLnZhbHVlO1xyXG4gICAgICAgICAgICAvL3RoZSBpbmNvbWluZyB0b2tlbiBtYXkgYWxyZWFkeSBiZSBhIE5vZGUgdHlwZVxyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSB0b2tlbi5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gdG9rZW4ucmlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQgPyB0aGlzLmxlZnQudG9TdHJpbmcoKSArICctLS0nIDogJyc7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQgPyAnLS0tJyArIHRoaXMucmlnaHQudG9TdHJpbmcoKSA6ICcnO1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdCArICcoJyArIHRoaXMudmFsdWUgKyAnKScgKyByaWdodDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBOb2RlLnByb3RvdHlwZS50b0hUTUwgPSBmdW5jdGlvbiAoZGVwdGgsIGluZGVudCkge1xyXG4gICAgICAgICAgICBkZXB0aCA9IGRlcHRoIHx8IDA7XHJcbiAgICAgICAgICAgIGluZGVudCA9IHR5cGVvZiBpbmRlbnQgPT09ICd1bmRlZmluZWQnID8gNCA6IGluZGVudDtcclxuICAgICAgICAgICAgdmFyIHRhYiA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyAnLnJlcGVhdChpbmRlbnQgKiBuKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQgPyB0YWIoZGVwdGggKyAxKSArICc8bGk+XFxuJyArIHRoaXMubGVmdC50b0hUTUwoZGVwdGggKyAyLCBpbmRlbnQpICsgdGFiKGRlcHRoICsgMSkgKyAnPC9saT4gXFxuJyA6ICcnO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0ID8gdGFiKGRlcHRoICsgMSkgKyAnPGxpPlxcbicgKyB0aGlzLnJpZ2h0LnRvSFRNTChkZXB0aCArIDIsIGluZGVudCkgKyB0YWIoZGVwdGggKyAxKSArICc8L2xpPlxcbicgOiAnJztcclxuICAgICAgICAgICAgdmFyIGh0bWwgPSB0YWIoZGVwdGgpICsgJzxkaXYgY2xhc3M9XCInICsgdGhpcy50eXBlLnRvTG93ZXJDYXNlKCkgKyAnXCI+PHNwYW4+JyArIHRoaXMudmFsdWUgKyAnPC9zcGFuPjwvZGl2PicgKyB0YWIoZGVwdGgpICsgJ1xcbic7XHJcbiAgICAgICAgICAgIGlmKGxlZnQgfHwgcmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGh0bWwgKz0gdGFiKGRlcHRoKSArICc8dWw+XFxuJyArIGxlZnQgKyByaWdodCArIHRhYihkZXB0aCkgKyAnPC91bD5cXG4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGh0bWwgKz0gJyc7XHJcbiAgICAgICAgICAgIHJldHVybiBodG1sO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudHJlZSA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcclxuICAgICAgICAgICAgdmFyIFEgPSBbXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0b2tlbnNbaV07XHJcbiAgICAgICAgICAgICAgICAvL0FycmF5cyBpbmRpY2F0ZSBhIG5ldyBzY29wZSBzbyBwYXJzZSB0aGF0IG91dFxyXG4gICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLnRyZWUoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGEgY29tbWEgdGhlbiBpdCdzIGp1c3QgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoZS50eXBlID09PSBUb2tlbi5PUEVSQVRPUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGUuaXNfcHJlZml4IHx8IGUucG9zdGZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ByZWZpeGVzIGdvIHRvIHRoZSBsZWZ0LCBwb3N0Zml4IHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBlLmlzX3ByZWZpeCA/ICdsZWZ0JyA6ICdyaWdodCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyBOb2RlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlW2xvY2F0aW9uXSA9IGxhc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFEucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgTm9kZShlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5yaWdodCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubGVmdCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFEucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGUudHlwZSA9PT0gVG9rZW4uRlVOQ1RJT04pIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gbmV3IE5vZGUoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGUucmlnaHQgPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGUudmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgUSBoYXMgYSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IFFbUS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUobGFzdC5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBsYXN0LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdC5yaWdodCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUS5wdXNoKG5ldyBOb2RlKGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFFbMF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnBhcnNlID0gZnVuY3Rpb24gKGUsIHN1YnN0aXR1dGlvbnMpIHtcclxuICAgICAgICAgICAgZSA9IHByZXBhcmVfZXhwcmVzc2lvbihlKTtcclxuICAgICAgICAgICAgc3Vic3RpdHV0aW9ucyA9IHN1YnN0aXR1dGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIC8vdGhyZWUgcGFzc2VzIGJ1dCBlYXNpZXIgdG8gZGVidWdcclxuICAgICAgICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5pemUoZSk7XHJcbiAgICAgICAgICAgIHZhciBycG4gPSB0aGlzLnRvUlBOKHRva2Vucyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUlBOKHJwbiwgc3Vic3RpdHV0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUT0RPOiBTd2l0Y2ggdG8gUGFyc2VyLnRva2VuaXplIGZvciB0aGlzIG1ldGhvZFxyXG4gICAgICAgICAqIFJlYWRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgU3ltYm9scyBhbmQgb3BlcmF0b3JzXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb25fc3RyaW5nXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG9PYmplY3QgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbl9zdHJpbmcpIHtcclxuICAgICAgICAgICAgdmFyIG9iamVjdGlmeSA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdG9rZW4udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodG9rZW4udHlwZSA9PT0gVG9rZW4uVkFSSUFCTEVfT1JfTElURVJBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChuZXcgU3ltYm9sKHYpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih0b2tlbi50eXBlID09PSBUb2tlbi5GVU5DVElPTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2p1bXAgYWhlYWQgc2luY2UgdGhlIG5leHQgb2JqZWN0IGFyZSB0aGUgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgYSBzeW1ib2xpYyBmdW5jdGlvbiBhbmQgc3RpY2sgaXQgb24gb3V0cHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gXy5zeW1mdW5jdGlvbih2LCBvYmplY3RpZnkodG9rZW5zW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYuaXNDb252ZXJzaW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udHlwZSA9PT0gVG9rZW4uT1BFUkFUT1IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvYmplY3RpZnkodG9rZW4pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdGlmeShfLnRva2VuaXplKGV4cHJlc3Npb25fc3RyaW5nKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gQSBoZWxwZXIgbWV0aG9kIGZvciB0b1RlWFxyXG4gICAgICAgIHZhciBjaHVua0F0Q29tbWFzID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICB2YXIgaiwgayA9IDAsIGNodW5rcyA9IFtbXV07XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDAsIGwgPSBhcnIubGVuZ3RoOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZihhcnJbal0gPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICBjaHVua3Nba10gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNodW5rc1trXS5wdXNoKGFycltqXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNodW5rcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBIZWxwZXIgbWV0aG9kIGZvciB0b1RlWFxyXG4gICAgICAgIHZhciByZW1fYnJhY2tldHMgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXlxcXFxsZWZ0XFwoKC4rKVxcXFxyaWdodFxcKSQvZywgZnVuY3Rpb24gKHN0ciwgYSkge1xyXG4gICAgICAgICAgICAgICAgaWYoYSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciByZW1vdmVfcmVkdW5kYW50X3Bvd2VycyA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGZpbHRlcmVkIGFycmF5XHJcbiAgICAgICAgICAgIHZhciBuYXJyID0gW107XHJcblxyXG4gICAgICAgICAgICB3aGlsZShhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZnJvbnRcclxuICAgICAgICAgICAgICAgIHZhciBlID0gYXJyLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGFyclswXTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0X2lzX2FycmF5ID0gaXNBcnJheShuZXh0KTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0X2lzX21pbnVzID0gbmV4dCA9PT0gJy0nO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSByZWR1bmRhbnQgcGx1c3NlcyBcclxuICAgICAgICAgICAgICAgIGlmKGUgPT09ICdeJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5leHQgPT09ICcrJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihuZXh0X2lzX2FycmF5ICYmIG5leHRbMF0gPT09ICcrJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcmVkdW5kYW50IHBhcmVudGhlc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYobmV4dF9pc19hcnJheSAmJiBuZXh0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIudW5zaGlmdChhcnIuc2hpZnQoKVswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBuZWdhdGl2ZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgaWYoZSA9PT0gJ14nICYmIChuZXh0X2lzX2FycmF5ICYmIG5leHRbMF0gPT09ICctJyB8fCBuZXh0X2lzX21pbnVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNvOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gUmVtb3ZlIGl0IGZyb20gdGhlIG5ldyBhcnJheSwgcGxhY2UgYSBvbmUgYW5kIGEgZGl2aXNpb24gc2lnbiBpbiB0aGF0IGFycmF5IGFuZCBwdXQgaXQgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gbmFyci5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHNvbWV0aGluZyBtdWx0aXBsaWVkIGJ5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IG5hcnJbbmFyci5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmVmb3JlX2xhc3QgPSAnMSc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGJlZm9yZSA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hcnIucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBzaW1wbGljaXR5IHdlIGp1c3QgcG9wIGl0LiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlX2xhc3QgPSBuYXJyLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbXBsaWVkIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpc0FycmF5KGJlZm9yZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlX2xhc3QgPSBuYXJyLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbmFyci5wdXNoKGJlZm9yZV9sYXN0LCAnLycsIGxhc3QsIGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ24gZnJvbSB0aGUgcG93ZXIgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYobmV4dF9pc19hcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIHRoZSBhcnJheSBzbyB3ZSBkb24ndCBlbmQgdXAgd2l0aCByZWR1bmRhbnQgcGFyZW50aGVzZXMgaWYgd2UgY2FuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYobmV4dF9pc19hcnJheSAmJiBuZXh0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXJyLnB1c2goYXJyLnNoaWZ0KClbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hcnIucHVzaChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5hcnI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIENvbnZlcnQgZXhwcmVzc2lvbiBvciBvYmplY3QgdG8gTGFUZVhcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbl9vcl9vYmpcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0XHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRvVGVYID0gZnVuY3Rpb24gKGV4cHJlc3Npb25fb3Jfb2JqLCBvcHQpIHtcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgICAgICAvLyBBZGQgZGVjaW1hbCBvcHRpb24gYXMgcGVyIGlzc3VlICM1NzkuIENvbnNpZGVyIHBhc3NpbmcgYW4gb2JqZWN0IHRvIExhdGV4LmxhdGV4IGFzIG9wdGlvbiBpbnN0ZWFkIG9mIHN0cmluZ1xyXG4gICAgICAgICAgICB2YXIgZGVjaW1hbHMgPSBvcHQuZGVjaW1hbHMgPT09IHRydWUgPyAnZGVjaW1hbHMnIDogdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgdmFyIG9iaiA9IHR5cGVvZiBleHByZXNzaW9uX29yX29iaiA9PT0gJ3N0cmluZycgPyB0aGlzLnRvT2JqZWN0KGV4cHJlc3Npb25fb3Jfb2JqKSA6IGV4cHJlc3Npb25fb3Jfb2JqLFxyXG4gICAgICAgICAgICAgICAgICAgIFRlWCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNkb3QgPSB0eXBlb2Ygb3B0LmNkb3QgPT09ICd1bmRlZmluZWQnID8gJ1xcXFxjZG90JyA6IG9wdC5jZG90OyAvL3NldCBvbWl0IGNkb3QgdG8gdHJ1ZSBieSBkZWZhdWx0XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgbmVnYXRpdmUgcG93ZXJzIGFzIHBlciBpc3N1ZSAjNTcwXHJcbiAgICAgICAgICAgIG9iaiA9IHJlbW92ZV9yZWR1bmRhbnRfcG93ZXJzKG9iaik7XHJcblxyXG4gICAgICAgICAgICBpZihpc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2JqID0gW10sIGEsIGI7XHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0IGhhbmRsZSBeXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IG9ialtpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYob2JqW2kgKyAxXSA9PT0gJ14nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBvYmpbaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2JqLnB1c2goTGFUZVguYnJhY2VzKHRoaXMudG9UZVgoW2FdKSkgKyAnXicgKyBMYVRlWC5icmFjZXModGhpcy50b1RlWChbYl0pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vYmoucHVzaChhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvYmogPSBub2JqO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBvYmpbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCAqIHRvIGNkb3RcclxuICAgICAgICAgICAgICAgIGlmKGUgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBjZG90O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGlzU3ltYm9sKGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZS5ncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuYW1lID0gZS5mbmFtZSwgZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZuYW1lID09PSBTUVJUKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9ICdcXFxcc3FydCcgKyBMYVRlWC5icmFjZXModGhpcy50b1RlWChlLmFyZ3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gQUJTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IExhVGVYLmJyYWNrZXRzKHRoaXMudG9UZVgoZS5hcmdzKSwgJ2FicycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSBQQVJFTlRIRVNJUylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBMYVRlWC5icmFja2V0cyh0aGlzLnRvVGVYKGUuYXJncyksICdwYXJlbnMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gU2V0dGluZ3MuTE9HMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAnXFxcXCcgKyBTZXR0aW5ncy5MT0cxMF9MQVRFWCArICdcXFxcbGVmdCggJyArIHRoaXMudG9UZVgoZS5hcmdzKSArICdcXFxccmlnaHQpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnaW50ZWdyYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogUmV0cml2ZSBbRXhwcmVzc2lvbiwgeF0gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua3MgPSBjaHVua0F0Q29tbWFzKGUuYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBCdWlsZCBUZVggKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByID0gTGFUZVguYnJhY2VzKHRoaXMudG9UZVgoY2h1bmtzWzBdKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gdGhpcy50b1RlWChjaHVua3NbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9ICdcXFxcaW50ICcgKyBleHByICsgJ1xcXFwsIGQnICsgZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2RlZmludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua3MgPSBjaHVua0F0Q29tbWFzKGUuYXJncyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIgPSBMYVRlWC5icmFjZXModGhpcy50b1RlWChjaHVua3NbMF0pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggPSB0aGlzLnRvVGVYKGNodW5rc1szXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxiID0gdGhpcy50b1RlWChjaHVua3NbMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1YiA9IHRoaXMudG9UZVgoY2h1bmtzWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAnXFxcXGludFxcXFxsaW1pdHNfeycgKyBsYiArICd9XnsnICsgdWIgKyAnfSAnICsgZXhwciArICdcXFxcLCBkJyArIGR4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnZGlmZicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHVua3MgPSBjaHVua0F0Q29tbWFzKGUuYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSAnJywgZXhwciA9IExhVGVYLmJyYWNlcyh0aGlzLnRvVGVYKGNodW5rc1swXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogSGFuZGxlIGNhc2VzOiBvbmUgYXJndW1lbnQgcHJvdmlkZWQsIHdlIG5lZWQgdG8gZ3Vlc3MgdGhlIHZhcmlhYmxlLCBhbmQgYXNzdW1lIG4gPSAxICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjaHVua3MubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCBjaHVua3NbMF0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2h1bmtzWzBdW2pdLmdyb3VwID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnB1c2goY2h1bmtzWzBdW2pdLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnNvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCA9IHZhcnMubGVuZ3RoID4gMCA/ICgnXFxcXGZyYWN7ZH17ZCAnICsgdmFyc1swXSArICd9JykgOiAnXFxcXGZyYWN7ZH17ZCB4fSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB0d28gYXJndW1lbnRzLCB3ZSBoYXZlIGV4cHJlc3Npb24gYW5kIHZhcmlhYmxlLCB3ZSBhc3N1bWUgbiA9IDEgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2h1bmtzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gJ1xcXFxmcmFje2R9e2QgJyArIGNodW5rc1sxXSArICd9JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgbW9yZSB0aGFuIDIgYXJndW1lbnRzLCB3ZSBhc3N1bWUgd2UndmUgZ290IGV2ZXJ5dGhpbmcgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gJ1xcXFxmcmFje2ReeycgKyBjaHVua3NbMl0gKyAnfX17ZCAnICsgdGhpcy50b1RlWChjaHVua3NbMV0pICsgJ157JyArIGNodW5rc1syXSArICd9fSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGR4ICsgJ1xcXFxsZWZ0KCcgKyBleHByICsgJ1xcXFxyaWdodCknO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnc3VtJyB8fCBmbmFtZSA9PT0gJ3Byb2R1Y3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGxpdCBlLmFyZ3MgaW50byA0IHBhcnRzIGJhc2VkIG9uIGxvY2F0aW9ucyBvZiAsIHN5bWJvbHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnU3BsaXQgPSBbW10sIFtdLCBbXSwgW11dLCBqID0gMCwgaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGUuYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGUuYXJnc1tpXSA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1NwbGl0W2pdLnB1c2goZS5hcmdzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gYnVpbGQgVGVYIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAoZm5hbWUgPT09ICdzdW0nID8gJ1xcXFxzdW1fJyA6ICdcXFxccHJvZF8nKSArIExhVGVYLmJyYWNlcyh0aGlzLnRvVGVYKGFyZ1NwbGl0WzFdKSArICcgPSAnICsgdGhpcy50b1RlWChhcmdTcGxpdFsyXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiArPSAnXicgKyBMYVRlWC5icmFjZXModGhpcy50b1RlWChhcmdTcGxpdFszXSkpICsgTGFUZVguYnJhY2VzKHRoaXMudG9UZVgoYXJnU3BsaXRbMF0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnbGltaXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGNodW5rQXRDb21tYXMoZS5hcmdzKS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KHgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy50b1RlWCh4LmpvaW4oJycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy50b1RlWChTdHJpbmcoeCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gJ1xcXFxsaW1fJyArIExhVGVYLmJyYWNlcyhhcmdzWzFdICsgJ1xcXFx0byAnICsgYXJnc1syXSkgKyAnICcgKyBMYVRlWC5icmFjZXMoYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gRkFDVE9SSUFMIHx8IGZuYW1lID09PSBET1VCTEVGQUNUT1JJQUwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gdGhpcy50b1RlWChlLmFyZ3MpICsgKGZuYW1lID09PSBGQUNUT1JJQUwgPyAnIScgOiAnISEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IExhVGVYLmxhdGV4KGUsIGRlY2ltYWxzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZiA9ICdcXFxcbWF0aHJtJytMYVRlWC5icmFjZXMoZm5hbWUucmVwbGFjZSgvXy9nLCAnXFxcXF8nKSkgKyBMYVRlWC5icmFja2V0cyh0aGlzLnRvVGVYKGUuYXJncyksICdwYXJlbnMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVGVYLnB1c2goZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUZVgucHVzaChMYVRlWC5sYXRleChlLCBkZWNpbWFscykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNBcnJheShlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFRlWC5wdXNoKExhVGVYLmJyYWNrZXRzKHRoaXMudG9UZVgoZSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGUgPT09ICcvJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgVGVYLnB1c2goTGFUZVguZnJhYyhyZW1fYnJhY2tldHMoVGVYLnBvcCgpKSwgcmVtX2JyYWNrZXRzKHRoaXMudG9UZVgoW29ialsrK2ldXSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBUZVgucHVzaChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFRlWC5qb2luKCcgJyk7XHJcbiAgICAgICAgfTtcclxuXHJcbi8vUGFyc2VyLmZ1bmN0aW9ucyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgICAgIC8qIEFsdGhvdWdoIHBhcmVucyBpcyBub3QgYSBcInJlYWxcIiBmdW5jdGlvbiBpdCBpcyBpbXBvcnRhbnQgaW4gc29tZSBjYXNlcyB3aGVuIHRoZVxyXG4gICAgICAgICAqIHN5bWJvbCBtdXN0IGNhcnJ5IHBhcmVudGhlc2lzLiBPbmNlIHNldCB5b3UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBpdCBhbnltb3JlXHJcbiAgICAgICAgICogYXMgdGhlIHBhcnNlciB3aWxsIGdldCByaWQgb2YgaXQgYXQgdGhlIGZpcnN0IG9wcG9ydHVuaXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcGFyZW5zKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ3BhcmVucycsIFtzeW1ib2xdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFicyhzeW1ib2wpIHtcclxuXHJcbiAgICAgICAgICAgIC8vfC3iiJ58ID0g4oieXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5pc0luZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sLmluZmluaXR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc3ltYm9sLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllci5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmUgPSBzeW1ib2wucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpbSA9IHN5bWJvbC5pbWFncGFydCgpO1xyXG4gICAgICAgICAgICAgICAgaWYocmUuaXNDb25zdGFudCgpICYmIGltLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3FydChfLmFkZChfLnBvdyhyZSwgbmV3IFN5bWJvbCgyKSksIF8ucG93KGltLCBuZXcgU3ltYm9sKDIpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoaXNOdW1lcmljU3ltYm9sKHN5bWJvbCkgfHwgZXZlbihzeW1ib2wucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1zID0gW107XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1zLnB1c2goeC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdjZCA9IE1hdGgyLlFHQ0QuYXBwbHkobnVsbCwgbXMpO1xyXG4gICAgICAgICAgICAgICAgaWYoZ2NkLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIgPSBzeW1ib2wubXVsdGlwbGllci5tdWx0aXBseShuZXcgRnJhYygtMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2NvbnZlcnQgfG4qeHwgdG8gbip8eHxcclxuICAgICAgICAgICAgdmFyIG0gPSBfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgc3ltYm9sLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KG0sIF8uc3ltZnVuY3Rpb24oQUJTLCBbc3ltYm9sXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZmFjdG9yaWFsIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm4ge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBmYWN0b3JpYWwoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgIGlmKGlzVmVjdG9yKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBWID0gbmV3IFZlY3RvcigpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2kgc3RhcnQgYXQgb25lLlxyXG4gICAgICAgICAgICAgICAgICAgIFYuc2V0KGkgLSAxLCBmYWN0b3JpYWwoeCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihpc01hdHJpeChzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4LCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pIHN0YXJ0IGF0IG9uZS5cclxuICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBmYWN0b3JpYWwoeCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYoaXNJbnQoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IE1hdGgyLmJpZ2ZhY3RvcmlhbChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gTWF0aDIuZ2FtbWEoc3ltYm9sLm11bHRpcGxpZXIuYWRkKG5ldyBGcmFjKDEpKS50b0RlY2ltYWwoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gYmlnQ29udmVydChyZXR2YWwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZW4gPSBzeW1ib2wuZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgICAgIGlmKGRlbi5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gc3ltYm9sLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhLCBiLCBjLCBuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZighc3ltYm9sLm11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBfLmFkZChudW0sIG5ldyBTeW1ib2woMSkpLm11bHRpcGxpZXIuZGl2aWRlKG5ldyBGcmFjKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IE1hdGgyLmJpZ2ZhY3RvcmlhbChuZXcgRnJhYygyKS5tdWx0aXBseShuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBfLnBvdyhuZXcgU3ltYm9sKDQpLCBuZXcgU3ltYm9sKG4pKS5tdWx0aXBsaWVyLm11bHRpcGx5KE1hdGgyLmJpZ2ZhY3RvcmlhbChuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gXy5zdWJ0cmFjdChudW0ubmVnYXRlKCksIG5ldyBTeW1ib2woMSkpLm11bHRpcGxpZXIuZGl2aWRlKG5ldyBGcmFjKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF8ucG93KG5ldyBTeW1ib2woLTQpLCBuZXcgU3ltYm9sKG4pKS5tdWx0aXBsaWVyLm11bHRpcGx5KE1hdGgyLmJpZ2ZhY3RvcmlhbChuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBNYXRoMi5iaWdmYWN0b3JpYWwobmV3IEZyYWMoMikubXVsdGlwbHkobikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjID0gYS5kaXZpZGUoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoXy5wYXJzZSgnc3FydChwaSknKSwgbmV3IFN5bWJvbChjKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oRkFDVE9SSUFMLCBbc3ltYm9sXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb250aW51ZWQgZnJhY3Rpb24gb2YgYSBudW1iZXJcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IG5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlZF9mcmFjdGlvbihzeW1ib2wsIG4pIHtcclxuICAgICAgICAgICAgdmFyIF9zeW1ib2wgPSBldmFsdWF0ZShzeW1ib2wpO1xyXG4gICAgICAgICAgICBpZihfc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNmID0gTWF0aDIuY29udGludWVkRnJhY3Rpb24oX3N5bWJvbCwgbik7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdGhlIGZyYWN0aW9ucyBhcnJheSB0byBhIG5ldyBWZWN0b3JcclxuICAgICAgICAgICAgICAgIHZhciBmcmFjdGlvbnMgPSBWZWN0b3IuZnJvbUFycmF5KGNmLmZyYWN0aW9ucy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCh4KTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3IuZnJvbUFycmF5KFtuZXcgU3ltYm9sKGNmLnNpZ24pLCBuZXcgU3ltYm9sKGNmLndob2xlKSwgZnJhY3Rpb25zXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2NvbnRpbnVlZF9mcmFjdGlvbicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGVycm9yIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZXJmKHN5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgX3N5bWJvbCA9IGV2YWx1YXRlKHN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICBpZihfc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgyLmVyZihfc3ltYm9sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKF9zeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXJmKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2VyZicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbW9kIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbDFcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sMlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbW9kKHN5bWJvbDEsIHN5bWJvbDIpIHtcclxuICAgICAgICAgICAgaWYoc3ltYm9sMS5pc0NvbnN0YW50KCkgJiYgc3ltYm9sMi5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsLm11bHRpcGxpZXIgPSByZXR2YWwubXVsdGlwbGllci5tdWx0aXBseShzeW1ib2wxLm11bHRpcGxpZXIubW9kKHN5bWJvbDIubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3RyeSB0byBzZWUgaWYgZGl2aXNpb24gaGFzIHJlbWFpbmRlciBvZiB6ZXJvXHJcbiAgICAgICAgICAgIHZhciByID0gXy5kaXZpZGUoc3ltYm9sMS5jbG9uZSgpLCBzeW1ib2wyLmNsb25lKCkpO1xyXG4gICAgICAgICAgICBpZihpc0ludChyKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignbW9kJywgW3N5bWJvbDEsIHN5bWJvbDJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBicmFuZ2hpbmcgZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmRpdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBhXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElGKGNvbmRpdGlvbiwgYSwgYikge1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgY29uZGl0aW9uICE9PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICBpZihpc051bWVyaWNTeW1ib2woY29uZGl0aW9uKSlcclxuICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24gPSAhIU51bWJlcihjb25kaXRpb24pO1xyXG4gICAgICAgICAgICBpZihjb25kaXRpb24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtNYXRyaXh8VmVjdG9yfFNldHxDb2xsZWN0aW9ufSBvYmpcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gaXRlbVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGlzX2luKG9iaiwgaXRlbSkge1xyXG4gICAgICAgICAgICBpZihpc01hdHJpeChvYmopKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gb2JqLnJvd3MoKTsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDAsIGwyID0gb2JqLmNvbHMoKTsgaiA8IGwyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBvYmouZWxlbWVudHNbaV1bal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQuZXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYob2JqLmVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gb2JqLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9iai5lbGVtZW50c1tpXS5lcXVhbHMoaXRlbSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc3ltYm9saWMgZXh0ZW5zaW9uIGZvciBzaW5jXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gc2luYyhzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aDIuc2luYyhzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnc2luKHswfSkvKHswfSknLCBzeW1ib2wpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignc2luYycsIFtzeW1ib2xdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc3ltYm9saWMgZXh0ZW5zaW9uIGZvciBleHAuIFRoaXMgd2lsbCBhdXRvLWNvbnZlcnQgYWxsIGluc3RhbmNlcyBvZiBleHAoeCkgdG8gZV54LlxyXG4gICAgICAgICAqIFRoYW5rcyBAIEhhcHB5cGlnMzc1XHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZXhwKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZihzeW1ib2wuZm5hbWUgPT09IFNldHRpbmdzLkxPRyAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucG93KHN5bWJvbC5hcmdzWzBdLCBTeW1ib2wuY3JlYXRlKHN5bWJvbC5tdWx0aXBsaWVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCdlXih7MH0pJywgc3ltYm9sKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB2YWx1ZSBkZWdyZWVzIHRvIHJhZGlhbnNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiByYWRpYW5zKHN5bWJvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJyh7MH0pKnBpLzE4MCcsIHN5bWJvbCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdmFsdWUgZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBkZWdyZWVzKHN5bWJvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJyh7MH0pKjE4MC9waScsIHN5bWJvbCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbnJvb3RzKHN5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgYSwgYjtcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBGTiAmJiBzeW1ib2wuZm5hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gU3ltYm9sLnVud3JhcFBBUkVOUyhfLnBhcnNlKHN5bWJvbCkudG9MaW5lYXIoKSk7XHJcbiAgICAgICAgICAgICAgICBiID0gXy5wYXJzZShzeW1ib2wucG93ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBQKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gXy5wYXJzZShzeW1ib2wudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYiA9IF8ucGFyc2Uoc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoYSAmJiBiICYmIGEuZ3JvdXAgPT09IE4gJiYgYi5ncm91cCA9PT0gTikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9yb290cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gU3ltYm9sLnRvUG9sYXJGb3JtQXJyYXkoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIHZhciByID0gXy5wYXJzZShhKS5hYnMoKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZV9Nb2l2cmUlMjdzX2Zvcm11bGFcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gYXJnKGEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGIubXVsdGlwbGllci5kZW4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gYi5tdWx0aXBsaWVyLm51bS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmb3JtdWxhID0gXCIoKHswfSleKHsxfSkqKGNvcyh7M30pKyh7Mn0pKnNpbih7M30pKSleKHs0fSlcIjtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGV2YWx1YXRlKF8ucGFyc2UoZm9ybWF0KFwiKCh7MH0pKzIqcGkqKHsxfSkpLyh7Mn0pXCIsIHgsIGksIG4pKSkubXVsdGlwbGllci50b0RlY2ltYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICBfcm9vdHMucHVzaChldmFsdWF0ZShfLnBhcnNlKGZvcm1hdChmb3JtdWxhLCByLCBuLCBTZXR0aW5ncy5JTUFHSU5BUlksIHQsIHApKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlY3Rvci5mcm9tQXJyYXkoX3Jvb3RzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5pc0NvbnN0YW50KHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHN5bWJvbC5zaWduKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGV2YWx1YXRlKHN5bWJvbC5hYnMoKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IF8uc3FydCh4KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jvb3RzID0gW3Jvb3QuY2xvbmUoKSwgcm9vdC5uZWdhdGUoKV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgX3Jvb3RzID0gX3Jvb3RzLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseSh4LCBTeW1ib2wuaW1hZ2luYXJ5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX3Jvb3RzID0gW18ucGFyc2Uoc3ltYm9sKV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuZnJvbUFycmF5KF9yb290cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSYXRpb25hbGl6ZXMgYSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiByYXRpb25hbGl6ZShzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bSwgZGVuLCByZXRudW0sIHJldGRlbiwgYSwgYiwgbiwgZDtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0geC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBkZW4gPSB4LmdldERlbm9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0bnVtID0gcmV0dmFsLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldGRlbiA9IHJldHZhbC5nZXREZW5vbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBfLm11bHRpcGx5KGRlbiwgcmV0bnVtKTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gXy5tdWx0aXBseShudW0sIHJldGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IF8uZXhwYW5kKF8uYWRkKGEsIGIpKTtcclxuICAgICAgICAgICAgICAgICAgICBkID0gXy5tdWx0aXBseShyZXRkZW4sIGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUobiwgZCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3F1YXJlIHJvb3QgZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBzcXJ0KHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2woc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZShzeW1ib2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGZvciBFWFxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbihTUVJULCBbc3ltYm9sXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5mbmFtZSA9PT0gJycgJiYgc3ltYm9sLnBvd2VyLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5hcmdzWzBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGlzX25lZ2F0aXZlID0gc3ltYm9sLm11bHRpcGxpZXIuc2lnbigpIDwgMDtcclxuXHJcbiAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSAmJiAhaXNfbmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChiaWdEZWMuc3FydChzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LnNxcnQoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ3NxcnQnLCBbc3ltYm9sXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbWcsIHJldHZhbCxcclxuICAgICAgICAgICAgICAgICAgICBpc0NvbnN0YW50ID0gc3ltYm9sLmlzQ29uc3RhbnQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IgJiYgc3ltYm9sLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gc3FydChTeW1ib2woc3ltYm9sLm11bHRpcGxpZXIpKTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgcyBpbiBzeW1ib2wuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gc3ltYm9sLnN5bWJvbHNbc107XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IF8ubXVsdGlwbHkobSwgc3FydCh4KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIHRoZSBzeW1ib2wgaXMgYWxyZWFkeSBzcXJ0IHRoZW4gaXQncyB0aGF0IHN5bWJvbF4oMS80KSBhbmQgd2UgY2FuIHVud3JhcCBpdFxyXG4gICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5mbmFtZSA9PT0gU1FSVCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2wuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIHZhciBtcyA9IHN5bWJvbC5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgcy5zZXRQb3dlcihzeW1ib2wucG93ZXIubXVsdGlwbHkobmV3IEZyYWMoMC4yNSkpKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHM7XHJcbiAgICAgICAgICAgICAgICAvL2dyYWIgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgIGlmKCFtcy5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShzcXJ0KF8ucGFyc2UobXMpKSwgcmV0dmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIHRoZSBzeW1ib2wgaXMgYSBmcmFjdGlvbiB0aGVuIHdlIGRvbid0IGtlZXAgY2FuIHVud3JhcCBpdC4gRm9yIGluc3RhbmNlXHJcbiAgICAgICAgICAgIC8vbm8gbmVlZCB0byBrZWVwIHNxcnQoeF4oMS8zKSlcclxuICAgICAgICAgICAgZWxzZSBpZighc3ltYm9sLnBvd2VyLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuc2V0UG93ZXIoc3ltYm9sLnBvd2VyLm11bHRpcGx5KG5ldyBGcmFjKDAuNSkpKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5tdWx0aXBsaWVyIDwgMCAmJiBzeW1ib2wuZ3JvdXAgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gXy5wYXJzZShzeW1ib2wubXVsdGlwbGllcikubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IF8ucGFyc2Uoc3ltYm9sKS50b1VuaXRNdWx0aXBsaWVyKCkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KF8uc3ltZnVuY3Rpb24oU2V0dGluZ3MuU1FSVCwgW2JdKSwgc3FydChhKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZWxhdGVkIHRvIGlzc3VlICM0MDEuIFNpbmNlIHNxcnQoYSkqc3FydChiXi0xKSByZWxhdGVzIGluIGlzc3Vlcywgd2UnbGwgY2hhbmdlIHRoZSBmb3JtXHJcbiAgICAgICAgICAgICAgICAvL3RvIHNxcnQoYSkqc3FydChiKV4xIGZvciBiZXR0ZXIgc2ltcGxpZmljYXRpb25cclxuICAgICAgICAgICAgICAgIC8vdGhlIHNpZ24gb2YgdGhlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHN5bWJvbC5wb3dlci5zaWduKCk7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgc2lnblxyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnBvd2VyID0gc3ltYm9sLnBvd2VyLmFicygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlIHN5bWJvbHMgaXMgaW1hZ2FyeSB0aGVuIHdlIHBsYWNlIGluIHRoZSBpbWFnaW5hcnkgcGFydC4gV2UnbGwgcmV0dXJuIGl0XHJcbiAgICAgICAgICAgICAgICAvL2FzIGEgcHJvZHVjdFxyXG4gICAgICAgICAgICAgICAgaWYoaXNDb25zdGFudCAmJiBzeW1ib2wubXVsdGlwbGllci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGltZyA9IFN5bWJvbC5pbWFnaW5hcnkoKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IHN5bWJvbC5tdWx0aXBsaWVyLmFicygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBxID0gc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFhID0gTWF0aC5hYnMocSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBNYXRoLnNxcnQocWEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBtO1xyXG4gICAgICAgICAgICAgICAgLy9pdCdzIGEgcGVyZmVjdCBzcXVhcmUgc28gdGFrZSB0aGUgc3F1YXJlXHJcbiAgICAgICAgICAgICAgICBpZihpc0ludCh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBuZXcgU3ltYm9sKHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihpc0ludChxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JzID0gTWF0aDIuaWZhY3RvcihxKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHcgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZmFjdG9yc1t4XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBubiA9IChuIC0gKG4gJSAyKSk7IC8vZ2V0IG91dCB0aGUgd2hvbGUgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihubikgeyAvL2lmIHRoZXJlIGlzIGEgd2hvbGUgbnVtYmVyIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSBNYXRoLnBvdyh4LCBubik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dyAqPSBNYXRoLnBvdyh4LCBubiAvIDIpOyAvL2FkZCB0byB0b3RhbCB3aG9sZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgLz0gdzsgLy9yZWR1Y2UgdGhlIG51bWJlciBieSB0aGUgd2hvbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IF8ubXVsdGlwbHkoXy5zeW1mdW5jdGlvbihTUVJULCBbbmV3IFN5bWJvbChxKV0pLCBuZXcgU3ltYm9sKHR3KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JlZHVjZSB0aGUgbnVtZXJhdG9yIGFuZCBkZW5vbWluYXRvciB1c2luZyBwcmltZSBmYWN0b3JpemF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBbbmV3IFN5bWJvbChzeW1ib2wubXVsdGlwbGllci5udW0pLCBuZXcgU3ltYm9sKHN5bWJvbC5tdWx0aXBsaWVyLmRlbildO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gW25ldyBTeW1ib2woMSksIG5ldyBTeW1ib2woMSldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcSA9IFtuZXcgU3ltYm9sKDEpLCBuZXcgU3ltYm9sKDEpXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gY1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIHByaW1lIGZhY3RvcnMgYW5kIGxvb3AgdGhyb3VnaCBlYWNoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZmFjdG9yKG4pLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBTeW1ib2wudW53cmFwUEFSRU5TKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB4LmNsb25lKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKHgucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9XZSdsbCBjb25zaWRlciBpdCBzYWZlIHRvIHVzZSB0aGUgbmF0aXZlIE51bWJlciBzaW5jZSAyXjEwMDAgaXMgYWxyZWFkeSBhIHByZXR0eSBodWdlIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbSA9IHAgJSAyOyAvL2dldCB0aGUgcmVtYWluZGVyLiBUaGlzIHdpbGwgYmUgMSBpZiAzIHNpbmNlIHNxcnQobl4yKSA9IG4gd2hlcmUgbiBpcyBwb3NpdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSAocCAtIHJlbSkgLyAyOyAvL2dldCB0aGUgd2hvbGUgbnVtYmVycyBvZiBuLzJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbaV0gPSBfLm11bHRpcGx5KHJbaV0sIF8ucG93KGIsIG5ldyBTeW1ib2wodykpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxW2ldID0gXy5tdWx0aXBseShzcVtpXSwgc3FydChfLnBvdyhiLCBuZXcgU3ltYm9sKHJlbSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtID0gXy5kaXZpZGUoXy5tdWx0aXBseShyWzBdLCBzcVswXSksIF8ubXVsdGlwbHkoclsxXSwgc3FbMV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9zdHJpcCB0aGUgbXVsdGlwbGllciBzaW5jZSB3ZSBhbHJlYWR5IHRvb2sgdGhlIHNxcnRcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgc3ltYm9sIGlzIG9uZSBqdXN0IHJldHVybiBvbmUgYW5kIG5vdCB0aGUgc3FydCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzT25lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGV2ZW4oc3ltYm9sLnBvd2VyLnRvU3RyaW5nKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9qdXN0IHJhaXNlIGl0IHRvIHRoZSAxLzJcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBvdyhzeW1ib2wuY2xvbmUoKSwgbmV3IFN5bWJvbCgwLjUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oU1FSVCwgW3N5bWJvbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgdGhlIHNpZ24gdGhhdCB3YXMgcmVtb3ZlZCBlYXJsaWVyXHJcbiAgICAgICAgICAgICAgICBpZihzaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwucG93ZXIubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KG0sIHJldHZhbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoaW1nKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoaW1nLCByZXR2YWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihpc19uZWdhdGl2ZSAmJiBTZXR0aW5ncy5QQVJTRTJOVU1CRVIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShyZXR2YWwpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjdWJlIHJvb3QgZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBjYnJ0KHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZighc3ltYm9sLmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzeW1ib2wucG93ZXIgLyAzO1xyXG4gICAgICAgICAgICAgICAgLy90YWtlIHRoZSBjdWJlIHJvb3Qgb2YgdGhlIG11bHRwbGllclxyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBfLnBvdyhfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyKSwgbmV3IFN5bWJvbCgxIC8gMykpO1xyXG4gICAgICAgICAgICAgICAgLy9zdHJpcCB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgdmFyIHN5bSA9IHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zaW1wbGlmeSB0aGUgcG93ZXJcclxuICAgICAgICAgICAgICAgIGlmKGlzSW50KG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wb3coc3ltLnRvTGluZWFyKCksIF8ucGFyc2UobikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIGNicnQoeCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2NicnQnLCBbc3ltXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KG0sIHJldHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG50aHJvb3Qoc3ltYm9sLCBuZXcgU3ltYm9sKDMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHNjaWVudGlmaWMoc3ltYm9sLCBzaWdmaWdzKSB7XHJcbiAgICAgICAgICAgIC8vSnVzdCBzZXQgdGhlIGZsYWcgYW5kIGtlZXAgaXQgbW92aW5nLiBTeW1ib2wudG9TdHJpbmcgd2lsbCBkZWFsIHdpdGggaG93IHRvXHJcbiAgICAgICAgICAgIC8vZGlzcGxheSB0aGlzXHJcbiAgICAgICAgICAgIHN5bWJvbC5zY2llbnRpZmljID0gc2lnZmlncyB8fCAxMDtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IG51bSAtIHRoZSBudW1iZXIgYmVpbmcgcmFpc2VkXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHAgLSB0aGUgZXhwb25lbnRcclxuICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IHByZWMgLSB0aGUgcHJlY2lzaW9uIHdhbnRlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gYXNiaWcgLSB0cnVlIGlmIGEgYmlnRGVjaW1hbCBpcyB3YW50ZWRcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG50aHJvb3QobnVtLCBwLCBwcmVjLCBhc2JpZykge1xyXG4gICAgICAgICAgICAvL2Nsb25lIHAgYW5kIGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgcCA9IGV2YWx1YXRlKF8ucGFyc2UocCkpO1xyXG5cclxuICAgICAgICAgICAgLy9jYW5ub3QgY2FsY3VsYXRlIGlmIHAgPSAwLiBudGhyb290KDAsIDApID0+IDBeKDEvMCkgPT4gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIGlmKHAuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJ1VuYWJsZSB0byBjYWxjdWxhdGUgbnRocm9vdHMgb2YgemVybycpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1N0b3AgY29tcHV0YXRpb24gaWYgaXQgbmVnYXRpdmUgYW5kIGV2ZW4gc2luY2Ugd2UgaGF2ZSBhbiBpbWFnaW5hcnkgcmVzdWx0XHJcbiAgICAgICAgICAgIGlmKG51bSA8IDAgJiYgZXZlbihwKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGN1bGF0ZSBudGhyb290IG9mIG5lZ2F0aXZlIG51bWJlciBmb3IgZXZlbiBwb3dlcnMnKTtcclxuXHJcbiAgICAgICAgICAgIC8vcmV0dXJuIG5vbiBudW1lcmljIHZhbHVlcyB1bmV2YWx1YXRlZFxyXG4gICAgICAgICAgICBpZighbnVtLmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdudGhyb290JywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9ldmFsdWF0ZSBudW1lcmljIHZhbHVlc1xyXG4gICAgICAgICAgICBpZihudW0uZ3JvdXAgIT09IE4pIHtcclxuICAgICAgICAgICAgICAgIG51bSA9IGV2YWx1YXRlKG51bSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZGVmYXVsdCBpcyB0byByZXR1cm4gYSBiaWcgdmFsdWVcclxuICAgICAgICAgICAgaWYodHlwZW9mIGFzYmlnID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIGFzYmlnID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHByZWMgPSBwcmVjIHx8IDI1O1xyXG5cclxuICAgICAgICAgICAgdmFyIHNpZ24gPSBudW0uc2lnbigpO1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICB2YXIgYW5zO1xyXG5cclxuICAgICAgICAgICAgaWYoc2lnbiA8IDApIHtcclxuICAgICAgICAgICAgICAgIG51bSA9IGFicyhudW0pOyAvL3JlbW92ZSB0aGUgc2lnblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihpc0ludChudW0pICYmIHAuaXNDb25zdGFudCgpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobnVtIDwgMTg0NDY3NDQwNzM3MDk1NTE2MTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLzJeNjRcclxuICAgICAgICAgICAgICAgICAgICBhbnMgPSBGcmFjLmNyZWF0ZShNYXRoLnBvdyhudW0sIDEgLyBwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbnMgPSBNYXRoMi5udGhyb290KG51bSwgcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKGFzYmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbChhbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbChhbnMudG9EZWNpbWFsKHByZWMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShuZXcgU3ltYm9sKHNpZ24pLCByZXR2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwZmFjdG9yKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAvL0ZpeCBpc3N1ZSAjNDU4IHwgbmVyZGFtZXIoXCJzcXJ0KDEtKDMuMzMzMzMzMzU1MDUyMDkyNmUtNyleMilcIikuZXZhbHVhdGUoKS50ZXh0KClcclxuICAgICAgICAgICAgLy9Nb3JlIEJpZyBOdW1iZXIgaXNzdWVzID46KFxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZ3JlYXRlclRoYW4oOS45OTk5OTk5OTk5OTg4OTFlKzQxKSB8fCBzeW1ib2wuZXF1YWxzKC0xKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIC8vRml4IGlzc3VlICMyOThcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmVxdWFscyhNYXRoLlBJKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguUEkpO1xyXG4gICAgICAgICAgICAvL2V2YWx1YXRlIHRoZSBzeW1ib2wgdG8gbWVyZ2UgY29uc3RhbnRzXHJcbiAgICAgICAgICAgIHN5bWJvbCA9IGV2YWx1YXRlKHN5bWJvbC5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBzeW1ib2wudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmKGlzSW50KG0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvcnMgPSBNYXRoMi5pZmFjdG9yKG0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgZmFjdG9yIGluIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBmYWN0b3JzW2ZhY3Rvcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBfLnN5bWZ1bmN0aW9uKCdwYXJlbnMnLCBbbmV3IFN5bWJvbChmYWN0b3IpLnNldFBvd2VyKG5ldyBGcmFjKHApKV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHBmYWN0b3IobmV3IFN5bWJvbChzeW1ib2wubXVsdGlwbGllci5udW0pKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHBmYWN0b3IobmV3IFN5bWJvbChzeW1ib2wubXVsdGlwbGllci5kZW4pKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KF8uc3ltZnVuY3Rpb24oJ3BhcmVucycsIFtuXSksIF8uc3ltZnVuY3Rpb24oJ3BhcmVucycsIFtkXSkuaW52ZXJ0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ3BmYWN0b3InLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0J3MgdGhlIHJlYWwgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyLiBSZXR1cm4gbnVtYmVyIGlmIHJlYWxcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiByZWFscGFydChzeW1ib2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5yZWFscGFydCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0J3MgdGhlIGltYWdpbmFyeSBwYXJ0IG9mIGEgY29tcGxleCBudW1iZXJcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBpbWFncGFydChzeW1ib2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5pbWFncGFydCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tcHV0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIGNvbXBsZXggbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gY29uanVnYXRlKHN5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgcmUgPSBzeW1ib2wucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgdmFyIGltID0gc3ltYm9sLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLmFkZChyZSwgXy5tdWx0aXBseShpbS5uZWdhdGUoKSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhcnVnbWVudCBvZiBhIGNvbXBsZXggbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gYXJnKHN5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgcmUgPSBzeW1ib2wucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgdmFyIGltID0gc3ltYm9sLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgICAgIGlmKHJlLmlzQ29uc3RhbnQoKSAmJiBpbS5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmF0YW4yKGltLCByZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignYXRhbjInLCBbaW0sIHJlXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBhcnVnbWVudCBvZiBhIGNvbXBsZXggbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gYXJnKHN5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgcmUgPSBzeW1ib2wucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgdmFyIGltID0gc3ltYm9sLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgICAgIGlmKHJlLmlzQ29uc3RhbnQoKSAmJiBpbS5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmKGltLmVxdWFscygwKSAmJiByZS5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoJ3BpJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGltLmVxdWFscygxKSAmJiByZS5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZSgncGkvMicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihpbS5lcXVhbHMoMSkgJiYgcmUuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoJ3BpLzQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguYXRhbjIoaW0sIHJlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2F0YW4yJywgW2ltLCByZV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcG9sYXJmb3JtIG9mIGEgY29tcGxleCBudW1iZXJcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBwb2xhcmZvcm0oc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHZhciBwLCByLCBlLCB0aGV0YTtcclxuICAgICAgICAgICAgcCA9IFN5bWJvbC50b1BvbGFyRm9ybUFycmF5KHN5bWJvbCk7XHJcbiAgICAgICAgICAgIHRoZXRhID0gcFsxXTtcclxuICAgICAgICAgICAgciA9IHBbMF07XHJcbiAgICAgICAgICAgIGUgPSBfLnBhcnNlKGZvcm1hdCgnZV4oezB9Kih7MX0pKScsIFNldHRpbmdzLklNQUdJTkFSWSwgdGhldGEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkociwgZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZWN0YW5ndWxhciBmb3JtIG9mIGEgY29tcGxleCBudW1iZXIuIERvZXMgbm90IHdvcmsgZm9yIHN5bWJvbGljIGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Rmb3JtKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAvL1RPRE86IGVeKChpKnBpKS80KVxyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBzeW1ib2wuY2xvbmUoKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBmLCBwLCBxLCBzLCBoLCBkLCBuO1xyXG4gICAgICAgICAgICAgICAgZiA9IGRlY29tcG9zZV9mbihzeW1ib2wsICdlJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBwID0gXy5kaXZpZGUoZi54LnBvd2VyLCBTeW1ib2wuaW1hZ2luYXJ5KCkpO1xyXG4gICAgICAgICAgICAgICAgcSA9IGV2YWx1YXRlKHRyaWcudGFuKHApKTtcclxuICAgICAgICAgICAgICAgIHMgPSBfLnBvdyhmLmEsIG5ldyBTeW1ib2woMikpO1xyXG4gICAgICAgICAgICAgICAgZCA9IHEuZ2V0RGVub20odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcS5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgIGggPSBTeW1ib2wuaHlwKG4sIGQpO1xyXG4gICAgICAgICAgICAgICAgLy9jaGVja1xyXG4gICAgICAgICAgICAgICAgaWYoaC5lcXVhbHMoZi5hKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChkLCBfLm11bHRpcGx5KFN5bWJvbC5pbWFnaW5hcnkoKSwgbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc3ltTWluTWF4KGYsIGFyZ3MpIHtcclxuICAgICAgICAgICAgYXJncy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHgubnVtVmFsID0gZXZhbHVhdGUoeCkubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHZhciBsLCBhLCBiLCBhX3ZhbCwgYl92YWw7XHJcbiAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGwgPSBhcmdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmKGwgPCAyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgYSA9IGFyZ3MucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBiID0gYXJnc1tsIC0gMl07XHJcbiAgICAgICAgICAgICAgICBpZihmID09PSAnbWluJyA/IGEubnVtVmFsIDwgYi5udW1WYWwgOiBhLm51bVZhbCA+IGIubnVtVmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgbWF4aW11bSBvZiBhIHNldCBvZiBudW1iZXJzXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBtYXgoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBpZihhbGxTYW1lKGFyZ3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGlmKGFsbE51bWJlcnMoYXJncykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLm1heC5hcHBseShudWxsLCBhcmdzKSk7XHJcbiAgICAgICAgICAgIGlmKFNldHRpbmdzLlNZTUJPTElDX01JTl9NQVggJiYgYWxsQ29uc3RhbnRzKGFyZ3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bU1pbk1heCgnbWF4JywgYXJncyk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdtYXgnLCBhcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgbWluaW11bSBvZiBhIHNldCBvZiBudW1iZXJzXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBtaW4oKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBpZihhbGxTYW1lKGFyZ3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGlmKGFsbE51bWJlcnMoYXJncykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLm1pbi5hcHBseShudWxsLCBhcmdzKSk7XHJcbiAgICAgICAgICAgIGlmKFNldHRpbmdzLlNZTUJPTElDX01JTl9NQVggJiYgYWxsQ29uc3RhbnRzKGFyZ3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bU1pbk1heCgnbWluJywgYXJncyk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdtaW4nLCBhcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNpZ24gb2YgYSBudW1iZXJcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0geFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gc2lnbih4KSB7XHJcbiAgICAgICAgICAgIGlmKHguaXNDb25zdGFudCh0cnVlKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguc2lnbihldmFsdWF0ZSh4KSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignc2lnbicsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzb3J0KHN5bWJvbCwgb3B0KSB7XHJcbiAgICAgICAgICAgIG9wdCA9IG9wdCA/IG9wdC50b1N0cmluZygpIDogJ2FzYyc7XHJcbiAgICAgICAgICAgIHZhciBnZXR2YWwgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoZS5ncm91cCA9PT0gTilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgaWYoZS5ncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihlLmZuYW1lID09PSAnJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHZhbChlLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmZuYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoZS5ncm91cCA9PT0gUylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5wb3dlcjtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHN5bWJvbHMgPSBpc1ZlY3RvcihzeW1ib2wpID8gc3ltYm9sLmVsZW1lbnRzIDogc3ltYm9sLmNvbGxlY3RTeW1ib2xzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHN5bWJvbHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF2YWwgPSBnZXR2YWwoYSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ2YWwgPSBnZXR2YWwoYik7XHJcbiAgICAgICAgICAgICAgICBpZihvcHQgPT09ICdkZXNjJylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnZhbCAtIGF2YWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhbCAtIGJ2YWw7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb2cgZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJhc2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGxvZyhzeW1ib2wsIGJhc2UpIHtcclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG5cclxuICAgICAgICAgICAgaWYoc3ltYm9sLmZuYW1lID09PSBTUVJUICYmIHN5bWJvbC5tdWx0aXBsaWVyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUobG9nKHN5bWJvbC5hcmdzWzBdKSwgbmV3IFN5bWJvbCgyKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyLnNpZ24oKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9sb2coMCkgaXMgdW5kZWZpbmVkIHNvIGNvbXBsYWluXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcihTZXR0aW5ncy5MT0cgKyAnKDApIGlzIHVuZGVmaW5lZCEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9kZWFsIHdpdGggaW1hZ2luYXJ5IHZhbHVlc1xyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCBTZXR0aW5ncy5MT0cpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpICYmIHR5cGVvZiBiYXNlICE9PSAndW5kZWZpbmVkJyAmJiBiYXNlLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvZ19zeW0gPSBNYXRoLmxvZyhzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvZ19iYXNlID0gTWF0aC5sb2coYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKGxvZ19zeW0gLyBsb2dfYmFzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IEVYICYmIHN5bWJvbC5wb3dlci5tdWx0aXBsaWVyLmxlc3NUaGFuKDApIHx8IHN5bWJvbC5wb3dlci50b1N0cmluZygpID09PSAnLTEnKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wucG93ZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAvL21vdmUgdGhlIG5lZ2F0aXZlIG91dHNpZGUgYnV0IGtlZXAgdGhlIHBvc2l0aXZlIGluc2lkZSA6KVxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbG9nKHN5bWJvbCkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wudmFsdWUgPT09ICdlJyAmJiBzeW1ib2wubXVsdGlwbGllci5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gc3ltYm9sLnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gaXNTeW1ib2wocCkgPyBwIDogbmV3IFN5bWJvbChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gRk4gJiYgc3ltYm9sLmZuYW1lID09PSAnZXhwJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2wuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5tdWx0aXBsaWVyLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHMsIG5ldyBTeW1ib2woc3ltYm9sLnBvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbihTZXR0aW5ncy5MT0csIFtzeW1ib2xdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUiAmJiBpc051bWVyaWNTeW1ib2woc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgZm9yIHNhZmV0eS5cclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2Uoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW1nX3BhcnQ7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wubXVsdGlwbGllci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbWdfcGFydCA9IF8ubXVsdGlwbHkobmV3IFN5bWJvbChNYXRoLlBJKSwgbmV3IFN5bWJvbCgnaScpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKE1hdGgubG9nKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoaW1nX3BhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIGltZ19wYXJ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcztcclxuICAgICAgICAgICAgICAgIGlmKCFzeW1ib2wucG93ZXIuZXF1YWxzKDEpICYmICFzeW1ib2wuY29udGFpbnMoJ2UnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzeW1ib2wuZ3JvdXAgPT09IEVYID8gc3ltYm9sLnBvd2VyIDogbmV3IFN5bWJvbChzeW1ib2wucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9sb2coYSxhKSA9IDEgc2luY2UgdGhlIGJhc2UgaXMgYWxsb3dlZCB0byBiZSBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgICAgLy9UaGlzIHdhcyBwb2ludGVkIG91dCBieSBIYXBweXBpZzM3NSBpbiBpc3N1ZSAjMjgwXHJcbiAgICAgICAgICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhbGxTYW1lKGFyZ3VtZW50cykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbihTZXR0aW5ncy5MT0csIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYocylcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHMsIHJldHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSb3VuZCBhIG51bWJlciB1cCB0byBzIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gcyAtIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHMpIHtcclxuICAgICAgICAgICAgdmFyIHNJc0NvbnN0YW50ID0gcyAmJiBzLmlzQ29uc3RhbnQoKSB8fCB0eXBlb2YgcyA9PT0gJ3VuZGVmaW5lZCc7XHJcbiAgICAgICAgICAgIGlmKHguaXNDb25zdGFudCgpICYmIHNJc0NvbnN0YW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiwgZSwgZXhwLCByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB2ID0geDtcclxuICAgICAgICAgICAgICAgIC8vcm91bmQgdGhlIGNvZWZmaWNpZW50IG9mIHRoZW4gbnVtYmVyIGJ1dCBub3QgdGhlIGFjdHVhbCBkZWNpbWFsIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAvL3dlIGtub3cgdGhpcyBiZWNhdXNlIGEgbmVnYXRpdmUgbnVtYmVyIHdhcyBwYXNzZWRcclxuICAgICAgICAgICAgICAgIGlmKHMgJiYgcy5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBhYnMocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBudW1iZXIgdG8gZXhwb25lbnRpYWwgZm9ybVxyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBOdW1iZXIoeCkudG9FeHBvbmVudGlhbCgpLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3BvaW50IHYgdG8gdGhlIGNvZWZmaWNpZW50IG9mIHRoZW4gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGVbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgdGhlIGV4cG9udGVudFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cCA9IGVbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3JvdW5kIHRoZSBudW1iZXIgdG8gdGhlIHJlcXVlc3RlZCBwcmVjaXNpb25cclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2wobnJvdW5kKHYsIE51bWJlcihzIHx8IDApKSk7XHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlJ3MgYSBleHBvbmVudCB0aGVuIHB1dCBpdCBiYWNrXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShyZXR2YWwsIF8ucG93KG5ldyBTeW1ib2woMTApLCBuZXcgU3ltYm9sKGV4cCB8fCAwKSkpXHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbigncm91bmQnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgcXVhZHJhbnQgb2YgdGhlIHRyaWcgZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge0ZyYWN9IG1cclxuICAgICAgICAgKiBAcmV0dXJucyB7SW50fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGdldFF1YWRyYW50KG0pIHtcclxuICAgICAgICAgICAgdmFyIHYgPSBtICUgMiwgcXVhZHJhbnQ7XHJcblxyXG4gICAgICAgICAgICBpZih2IDwgMClcclxuICAgICAgICAgICAgICAgIHYgPSAyICsgdjsgLy9wdXQgaXQgaW4gdGVybXMgb2YgcGlcclxuXHJcbiAgICAgICAgICAgIGlmKHYgPj0gMCAmJiB2IDw9IDAuNSlcclxuICAgICAgICAgICAgICAgIHF1YWRyYW50ID0gMTtcclxuICAgICAgICAgICAgZWxzZSBpZih2ID4gMC41ICYmIHYgPD0gMSlcclxuICAgICAgICAgICAgICAgIHF1YWRyYW50ID0gMjtcclxuICAgICAgICAgICAgZWxzZSBpZih2ID4gMSAmJiB2IDw9IDEuNSlcclxuICAgICAgICAgICAgICAgIHF1YWRyYW50ID0gMztcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcXVhZHJhbnQgPSA0O1xyXG4gICAgICAgICAgICByZXR1cm4gcXVhZHJhbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFNlcnZlcyBhcyBhIGJyaWRnZSBiZXR3ZWVuIG51bWJlcnMgYW5kIGJpZ051bWJlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge0ZyYWN8TnVtYmVyfSBuXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBiaWdDb252ZXJ0KG4pIHtcclxuICAgICAgICAgICAgaWYoIWlzRmluaXRlKG4pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbihuKTtcclxuICAgICAgICAgICAgICAgIHZhciByID0gbmV3IFN5bWJvbChTdHJpbmcoTWF0aC5hYnMobikpKTtcclxuICAgICAgICAgICAgICAgIHIubXVsdGlwbGllciA9IHIubXVsdGlwbGllci5tdWx0aXBseShuZXcgRnJhYyhzaWduKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihpc1N5bWJvbChuKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgbiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IEZyYWMuc2ltcGxlKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuZXcgRnJhYyhuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHN5bWJvbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyID0gbjtcclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjbGVhbihzeW1ib2wpIHtcclxuICAgICAgICAgICAgLy8gaGFuZGxlIGZ1bmN0aW9ucyB3aXRoIG51bWVyaWMgdmFsdWVzXHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBkZW5vbWluYXRvciB3aXRoaW4gZGVub21pbmF0b3JcclxuICAgICAgICAgICAgLy8gaGFuZGxlIHRyaWcgc2ltcGxpZmljYXRpb25zXHJcbiAgICAgICAgICAgIHZhciBnID0gc3ltYm9sLmdyb3VwLCByZXR2YWw7XHJcbiAgICAgICAgICAgIC8vTm93IGxldCdzIGdldCB0byB3b3JrXHJcbiAgICAgICAgICAgIGlmKGcgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gc3ltYm9sLmdldE51bSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW4gPSBzeW1ib2wuZ2V0RGVub20oKSB8fCBuZXcgU3ltYm9sKDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gTnVtYmVyKHN5bWJvbC5wb3dlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvciA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhwKSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbi5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IgPSBfLm11bHRpcGx5KGZhY3RvciwgY2xlYW4oeC5nZXREZW5vbSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih4LnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IgPSBfLm11bHRpcGx5KGZhY3RvciwgY2xlYW4oeC5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdfZGVuID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAvL25vdyBkaXZpZGUgb3V0IHRoZSBmYWN0b3IgYW5kIGFkZCB0byBuZXcgZGVuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVuLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2RlbiA9IF8uYWRkKF8uZGl2aWRlKHgsIGZhY3Rvci5jbG9uZSgpKSwgbmV3X2Rlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZhY3Rvci5pbnZlcnQoKTsgLy9pbnZlcnQgc28gaXQgY2FuIGJlIGFkZGVkIHRvIHRoZSB0b3BcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X251bTtcclxuICAgICAgICAgICAgICAgICAgICBpZihudW0uaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfbnVtID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19udW0gPSBfLmFkZChfLm11bHRpcGx5KGNsZWFuKHgpLCBmYWN0b3IuY2xvbmUoKSksIG5ld19udW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfbnVtID0gXy5tdWx0aXBseShmYWN0b3IsIG51bSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKG5ld19udW0sIG5ld19kZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBfLmNsZWFuKHgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5hcmdzLmxlbmd0aCA9PT0gMSAmJiBzeW1ib2wuYXJnc1swXS5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2Uoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoIXJldHZhbClcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHN5bWJvbDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHdyYXBwZXIgZm9yIHRoZSBleHBhbmQgZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBleHBhbmRhbGwoc3ltYm9sLCBvcHQpIHtcclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHtcclxuICAgICAgICAgICAgICAgIGV4cGFuZF9kZW5vbWluYXRvcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGV4cGFuZF9mdW5jdGlvbnM6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZChzeW1ib2wsIG9wdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV4cGFuZHMgYSBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0gc3ltYm9sXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gT2xkIGV4cGFuZFxyXG4gICAgICAgIGZ1bmN0aW9uIGV4cGFuZChzeW1ib2wsIG9wdCkge1xyXG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2wubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZCh4LCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xyXG4gICAgICAgICAgICAvL2RlYWwgd2l0aCBwYXJlbnRoZXNpc1xyXG4gICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEZOICYmIHN5bWJvbC5mbmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gZXhwYW5kKHN5bWJvbC5hcmdzWzBdLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBleHBhbmQoXy5wb3coZiwgXy5wYXJzZShzeW1ib2wucG93ZXIpKSwgb3B0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIpLCB4KS5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhlc2UgZ3JvdXBzIHNvIG5vIG5lZWQgdG8gd2FzdGUgdGltZS4gSnVzdCByZXR1cm4gYW5kIGJlIGRvbmUuXHJcbiAgICAgICAgICAgIGlmKFtOLCBQLCBTXS5pbmRleE9mKHN5bWJvbC5ncm91cCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sOyAvL25vdGhpbmcgdG8gZG9cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gc3ltYm9sLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdXAgYSB0cnktY2F0Y2ggYmxvY2suIElmIGFueXRoaW5nIGdvZXMgd3JvbmcgdGhlbiB3ZSBzaW1wbHkgcmV0dXJuIHRoZSBvcmlnaW5hbCBzeW1ib2xcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBwb3dlciBhbmQgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBzeW1ib2wubXVsdGlwbGllci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBOdW1iZXIoc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBzeW1ib2w7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIChhK2IpXjIgfCAoeCt4XjIpXjJcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpICYmIGlzSW50KHN5bWJvbC5wb3dlcikgJiYgc3ltYm9sLnBvd2VyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gcCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgdGhlIGV4cHJlc3Npb24gb2YgaXQncyBtdWx0aXBsaWVyIGFuZCBwb3dlci4gV2UnbGwgY2FsbCBpdCBmLiBUaGUgcG93ZXIgd2lsbCBiZSBwIGFuZCB0aGUgbXVsdGlwbGllciBtLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IF8uYWRkKGYsIGV4cGFuZChfLnBhcnNlKHgpLCBvcHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkID0gXy5wYXJzZShmKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA9IG1peChleHBhbmRlZCwgZiwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoXy5wYXJzZShtKSwgZXhwYW5kZWQpLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gRk4gJiYgb3B0LmV4cGFuZF9mdW5jdGlvbnMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBmdW5jdGlvbiB0aGUgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwYW5kKHgsIG9wdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFB1dCBiYWNrIHRoZSBwb3dlciBhbmQgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucG93KF8uc3ltZnVuY3Rpb24oc3ltYm9sLmZuYW1lLCBhcmdzKSwgXy5wYXJzZShzeW1ib2wucG93ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgXy5wYXJzZShzeW1ib2wubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSAmJiBpc0ludChzeW1ib2wucG93ZXIpICYmIHN5bWJvbC5wb3dlciA8IDAgJiYgb3B0LmV4cGFuZF9kZW5vbWluYXRvciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEludmVydCBpdC4gRXhwYW5kIGl0IGFuZCB0aGVuIHJlLWludmVydCBpdC5cclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZXhwYW5kKHN5bWJvbCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuayA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChzLmdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQTDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ0I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEZOOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgKGErYikoYytkKS4gVGhlIHJlc3VsdCB3aWxsIGJlIChhKmMrYSpkKSsoYipjK2IqZCkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc3RhcnQgYnkgbW92aW5nIGNvbGxlY3RpbmcgdGhlIHN5bWJvbHMuIFdlIHdhbnQgb3RoZXJzPkZOPkNCPlBMPkNQXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbHMgPSBzeW1ib2wuY29sbGVjdFN5bWJvbHMoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5rKGIpIC0gcmFuayhhKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzdHJpYnV0ZSB0aGUgcG93ZXIgdG8gZWFjaCBzeW1ib2wgYW5kIGV4cGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gXy5wb3cocywgXy5wYXJzZShwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBleHBhbmQoeCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHN5bWJvbHMucG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBzeW1ib2xzIGlzbid0IGEgY29tcG9zaXRlIHRoZW4gd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGYuaXNDb21wb3NpdGUoKSAmJiBmLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gbWl4KGYsIHMsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZiBpcyBvZiBncm91cCBQTCBvciBDUCB0aGVuIHdlIGNhbiBleHBhbmQgc29tZSBtb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGYuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZi5wb3dlciA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gZXhwYW5kKF8ucG93KGYsIF8ucGFyc2UoZi5wb3dlcikpLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGJhY2sgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoXy5wYXJzZShtKSwgZikuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgZXhwYW5kZWQgYXQgdGhpcyBwb2ludCBzbyBpZiBpdCdzIHN0aWxsIGEgQ0JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4ganVzdCByZXR1cm4gdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBtdWx0aXBseSBiYWNrIGluIHRoZSBleHBhbmRlZCBmb3JtIG9mIGVhY2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXQgYmFjayB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgXy5wYXJzZShtKSkuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXhpc3RzIHNvbGVseSBhcyBhIHF1aWNrIGZpeCBmb3Igc3FydCgxMSkqc3FydCgzMykgbm90IHNpbXBsaWZ5aW5nLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHJldHZhbC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShyZXR2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IHJldHVybiB0aGUgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHN5bWJvbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEZpbmFsIGNsZWFudXAgYW5kIHJldHVyblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gaWRlbnRpdHkgbWF0cml4IG9mIG54blxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXHJcbiAgICAgICAgICogQHJldHVybnMge01hdHJpeH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBpbWF0cml4KG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdHJpeC5pZGVudGl0eShuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHJpZXZlcyBhbmQgaXRlbSBmcm9tIGEgdmVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3J9IHZlY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtWZWN0b3J8U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlY2dldCh2ZWN0b3IsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIGlmKGluZGV4LmlzQ29uc3RhbnQoKSAmJiBpc0ludChpbmRleCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjdG9yLmVsZW1lbnRzW2luZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ3ZlY2dldCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBhIHZlY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yfSB2ZWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdG9sZXJhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge1ZlY3Rvcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiB2ZWN0cmltKHZlY3RvciwgdG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgIHRvbGVyYW5jZSA9IHR5cGVvZiB0b2xlcmFuY2UgPT09ICd1bmRlZmluZWQnID8gMWUtMTQgOiB0b2xlcmFuY2U7XHJcblxyXG4gICAgICAgICAgICB2ZWN0b3IgPSB2ZWN0b3IuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIHRvbGVyYW5jZSA9IE51bWJlcih0b2xlcmFuY2UpO1xyXG4gICAgICAgICAgICAvL3BsYWNlIGFsZ2VicmFpYyBzb2x1dGlvbnMgZmlyc3RcclxuICAgICAgICAgICAgdmVjdG9yLmVsZW1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiLmdyb3VwIC0gYS5ncm91cDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIHRoZSBzdGFydCBwb2ludCB3ZSBtYXkgaGF2ZSBkdXBsaWNhdGVzIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhvc2UgdXAgYSBiaXQuXHJcbiAgICAgICAgICAgIC8vc3RhcnQgYnkgY3JlYXRpbmcgYW4gb2JqZWN0IHdpdGggdGhlIHNvbHV0aW9uIGFuZCB0aGUgbnVtZXJpYyB2YWx1ZS4gVGhpcyB3YXkgd2UgZG9uJ3QgZGVzdHJveSBhbGdlYnJhaWMgdmFsdWVzXHJcbiAgICAgICAgICAgIHZlY3Rvci5lbGVtZW50cyA9IHJlbW92ZUR1cGxpY2F0ZXModmVjdG9yLmVsZW1lbnRzLCBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBOdW1iZXIoXy5zdWJ0cmFjdChldmFsdWF0ZShhKSwgZXZhbHVhdGUoYikpLmFicygpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIDw9IHRvbGVyYW5jZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IGEgdmFsdWUgZm9yIGEgdmVjdG9yIGF0IGEgZ2l2ZW4gaW5kZXhcclxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMge1ZlY3Rvcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiB2ZWNzZXQodmVjdG9yLCBpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYoIWluZGV4LmlzQ29uc3RhbnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbigndmVjc2V0JywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgdmVjdG9yLmVsZW1lbnRzW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWF0Z2V0KG1hdHJpeCwgaSwgaikge1xyXG4gICAgICAgICAgICBpZihpLmlzQ29uc3RhbnQoKSAmJiBqLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRyaXguZWxlbWVudHNbaV1bal07XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdtYXRnZXQnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWF0Z2V0cm93KG1hdHJpeCwgaSkge1xyXG4gICAgICAgICAgICBpZihpLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWF0cml4KG1hdHJpeC5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdtYXRnZXRyb3cnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWF0c2V0cm93KG1hdHJpeCwgaSwgeCkge1xyXG4gICAgICAgICAgICAvL2hhbmRsZSBzeW1ib2xpY3NcclxuICAgICAgICAgICAgaWYoIWkuaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ21hdHNldHJvdycsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIGlmKG1hdHJpeC5lbGVtZW50c1tpXS5sZW5ndGggIT09IHguZWxlbWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKCdNYXRyaXggcm93IG11c3QgbWF0Y2ggcm93IGRpbWVuc2lvbnMhJyk7XHJcbiAgICAgICAgICAgIHZhciBNID0gbWF0cml4LmNsb25lKCk7XHJcbiAgICAgICAgICAgIE0uZWxlbWVudHNbaV0gPSB4LmNsb25lKCkuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIHJldHVybiBNO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWF0Z2V0Y29sKG1hdHJpeCwgY29sX2luZGV4KSB7XHJcbiAgICAgICAgICAgIC8vaGFuZGxlIHN5bWJvbGljc1xyXG4gICAgICAgICAgICBpZighY29sX2luZGV4LmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdtYXRnZXRjb2wnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBjb2xfaW5kZXggPSBOdW1iZXIoY29sX2luZGV4KTtcclxuICAgICAgICAgICAgdmFyIE0gPSBNYXRyaXguZnJvbUFycmF5KFtdKTtcclxuICAgICAgICAgICAgbWF0cml4LmVhY2goZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgIGlmKGogPT09IGNvbF9pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIE0uZWxlbWVudHMucHVzaChbeC5jbG9uZSgpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gTTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1hdHNldGNvbChtYXRyaXgsIGosIGNvbCkge1xyXG4gICAgICAgICAgICAvL2hhbmRsZSBzeW1ib2xpY3NcclxuICAgICAgICAgICAgaWYoIWouaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ21hdHNldGNvbCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIGogPSBOdW1iZXIoaik7XHJcbiAgICAgICAgICAgIGlmKG1hdHJpeC5yb3dzKCkgIT09IGNvbC5lbGVtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGltZW5zaW9uRXJyb3IoJ01hdHJpeCBjb2x1bW5zIG11c3QgbWF0Y2ggbnVtYmVyIG9mIGNvbHVtbnMhJyk7XHJcbiAgICAgICAgICAgIGNvbC5lYWNoKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGkgLSAxLCBqLCB4LmVsZW1lbnRzWzBdLmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYXRzZXQobWF0cml4LCBpLCBqLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBtYXRyaXguZWxlbWVudHNbaV1bal0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGhlIGNvbnN0cnVjdG9yIGZvciB2ZWN0b3JzXHJcbiAgICAgICAgZnVuY3Rpb24gdmVjdG9yKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90aGUgY29uc3RydWN0b3IgZm9yIG1hdHJpY2VzXHJcbiAgICAgICAgZnVuY3Rpb24gbWF0cml4KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0cml4LmZyb21BcnJheShhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90aGUgY29uc3RydWN0b3IgZm9yIHNldHNcclxuICAgICAgICBmdW5jdGlvbiBzZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTZXQuZnJvbUFycmF5KGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkZXRlcm1pbmFudChzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoaXNNYXRyaXgoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5kZXRlcm1pbmFudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzaXplKHN5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICBpZihpc01hdHJpeChzeW1ib2wpKVxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gW25ldyBTeW1ib2woc3ltYm9sLmNvbHMoKSksIG5ldyBTeW1ib2woc3ltYm9sLnJvd3MoKSldO1xyXG4gICAgICAgICAgICBlbHNlIGlmKGlzVmVjdG9yKHN5bWJvbCkgfHwgaXNTZXQoc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woc3ltYm9sLmVsZW1lbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGVycignc2l6ZSBleHBlY3RzIGEgbWF0cml4IG9yIGEgdmVjdG9yJyk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkb3QodmVjMSwgdmVjMikge1xyXG4gICAgICAgICAgICBpZihpc1ZlY3Rvcih2ZWMxKSAmJiBpc1ZlY3Rvcih2ZWMyKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZWMxLmRvdCh2ZWMyKTtcclxuICAgICAgICAgICAgZXJyKCdmdW5jdGlvbiBkb3QgZXhwZWN0cyAyIHZlY3RvcnMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNyb3NzKHZlYzEsIHZlYzIpIHtcclxuICAgICAgICAgICAgaWYoaXNWZWN0b3IodmVjMSkgJiYgaXNWZWN0b3IodmVjMikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjMS5jcm9zcyh2ZWMyKTtcclxuICAgICAgICAgICAgZXJyKCdmdW5jdGlvbiBjcm9zcyBleHBlY3RzIDIgdmVjdG9ycycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNwb3NlKG1hdCkge1xyXG4gICAgICAgICAgICBpZihpc01hdHJpeChtYXQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdC50cmFuc3Bvc2UoKTtcclxuICAgICAgICAgICAgZXJyKCdmdW5jdGlvbiB0cmFuc3Bvc2UgZXhwZWN0cyBhIG1hdHJpeCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW52ZXJ0KG1hdCkge1xyXG4gICAgICAgICAgICBpZihpc01hdHJpeChtYXQpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdC5pbnZlcnQoKTtcclxuICAgICAgICAgICAgZXJyKCdpbnZlcnQgZXhwZWN0cyBhIG1hdHJpeCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9iYXNpYyBzZXQgZnVuY3Rpb25zXHJcbiAgICAgICAgZnVuY3Rpb24gdW5pb24oc2V0MSwgc2V0Mikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0MS51bmlvbihzZXQyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXQxLCBzZXQyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXQxLmludGVyc2VjdGlvbihzZXQyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHNldDEsIGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldDEuY29udGFpbnMoZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBkaWZmZXJlbmNlKHNldDEsIHNldDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldDEuZGlmZmVyZW5jZShzZXQyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdHMoc2V0MSwgc2V0Mikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChOdW1iZXIoc2V0MS5pbnRlcnNlY3RzKHNldDIpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpc19zdWJzZXQoc2V0MSwgc2V0Mikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChOdW1iZXIoc2V0MS5pc19zdWJzZXQoc2V0MikpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHByaW50KCkge1xyXG4gICAgICAgICAgICBhcmd1bWVudHMyQXJyYXkoYXJndW1lbnRzKS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdGVzdFNRUlQoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIC8vd3JhcCB0aGUgc3ltYm9sIGluIHNxcnQuIFRoaXMgZWxpbWluYXRlcyBvbmUgbW9yZSBjaGVjayBkb3duIHRoZSBsaW5lLlxyXG4gICAgICAgICAgICBpZighaXNTeW1ib2woc3ltYm9sLnBvd2VyKSAmJiBzeW1ib2wucG93ZXIuYWJzRXF1YWxzKDAuNSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gc3ltYm9sLnBvd2VyLnNpZ24oKTtcclxuICAgICAgICAgICAgICAgIC8vZG9uJ3QgZGV2aWRlIHRoZSBwb3dlciBkaXJlY3RseS4gTm90aWNlIHRoZSB1c2Ugb2YgdG9TdHJpbmcuIFRoaXMgbWFrZXMgaXQgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIC8vdG8gdXNlIGEgYmlnTnVtYmVyIGxpYnJhcnkgaW4gdGhlIGZ1dHVyZVxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IHNxcnQoc3ltYm9sLmdyb3VwID09PSBQID8gbmV3IFN5bWJvbChzeW1ib2wudmFsdWUpIDogc3ltYm9sLnRvTGluZWFyKCkpO1xyXG4gICAgICAgICAgICAgICAgLy9wbGFjZSBiYWNrIHRoZSBzaWduIG9mIHRoZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy90cnkgdG8gcmVkdWNlIGEgc3ltYm9sIGJ5IHB1bGxpbmcgaXRzIHBvd2VyXHJcbiAgICAgICAgZnVuY3Rpb24gdGVzdFBvdyhzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBQKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHN5bWJvbC52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmN0ID0gcHJpbWVGYWN0b3JzKHYpWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2FmZXR5XHJcbiAgICAgICAgICAgICAgICBpZighZmN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignVW5hYmxlIHRvIGNvbXB1dGUgcHJpbWUgZmFjdG9ycy4gVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gUGxlYXNlIHJldmlldyBhbmQgcmVwb3J0LicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgRnJhYyhNYXRoLmxvZyh2KSAvIE1hdGgubG9nKGZjdCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gbi5tdWx0aXBseShzeW1ib2wucG93ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vd2UgZG9uJ3Qgd2FudCBhIG1vcmUgY29tcGxleCBudW1iZXIgdGhhbiBiZWZvcmVcclxuICAgICAgICAgICAgICAgIGlmKHAuZGVuID4gc3ltYm9sLnBvd2VyLmRlbilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGlzSW50KHApKVxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IFN5bWJvbChNYXRoLnBvdyhmY3QsIHApKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sKGZjdCkuc2V0UG93ZXIocCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL0xpbmsgdGhlIGZ1bmN0aW9ucyB0byB0aGUgcGFyc2Ugc28gdGhleSdyZSBhdmFpbGFibGUgb3V0c2lkZSBvZiB0aGUgbGlicmFyeS5cclxuICAgICAgICAvL1RoaXMgaXMgc3RyaWN0bHkgZm9yIGNvbnZlbmllbmNlIGFuZCBtYXkgYmUgZGVwcmVjYXRlZC5cclxuICAgICAgICB0aGlzLmV4cGFuZCA9IGV4cGFuZDtcclxuICAgICAgICB0aGlzLnJvdW5kID0gcm91bmQ7XHJcbiAgICAgICAgdGhpcy5jbGVhbiA9IGNsZWFuO1xyXG4gICAgICAgIHRoaXMuc3FydCA9IHNxcnQ7XHJcbiAgICAgICAgdGhpcy5jYnJ0ID0gY2JydDtcclxuICAgICAgICB0aGlzLmFicyA9IGFicztcclxuICAgICAgICB0aGlzLmxvZyA9IGxvZztcclxuICAgICAgICB0aGlzLnJhdGlvbmFsaXplID0gcmF0aW9uYWxpemU7XHJcbiAgICAgICAgdGhpcy5udGhyb290ID0gbnRocm9vdDtcclxuICAgICAgICB0aGlzLmFyZyA9IGFyZztcclxuICAgICAgICB0aGlzLmNvbmp1Z2F0ZSA9IGNvbmp1Z2F0ZTtcclxuICAgICAgICB0aGlzLmltYWdwYXJ0ID0gaW1hZ3BhcnQ7XHJcbiAgICAgICAgdGhpcy5yZWFscGFydCA9IHJlYWxwYXJ0O1xyXG5cclxuICAgICAgICAvL1RPRE86XHJcbiAgICAgICAgLy9VdGlsaXplIHRoZSBmdW5jdGlvbiBiZWxvdyBpbnN0ZWFkIG9mIHRoZSBsaW5rZWQgZnVuY3Rpb25cclxuICAgICAgICB0aGlzLmdldEZ1bmN0aW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uc1tuYW1lXVswXTtcclxuICAgICAgICB9O1xyXG5cclxuLy9QYXJzZXIubWV0aG9kcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICB0aGlzLmFkZFByZXByb2Nlc3NvciA9IGZ1bmN0aW9uIChuYW1lLCBhY3Rpb24sIG9yZGVyLCBzaGlmdF9jZWxscykge1xyXG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBwcmVwcm9jZXNzb3JzLm5hbWVzO1xyXG4gICAgICAgICAgICB2YXIgYWN0aW9ucyA9IHByZXByb2Nlc3NvcnMuYWN0aW9ucztcclxuICAgICAgICAgICAgaWYoKHR5cGVvZiBhY3Rpb24gIT09ICdmdW5jdGlvbicpKSAvL3RoZSBwZXJzb24gcHJvYmFibHkgZm9yZ290IHRvIHNwZWNpZnkgYSBuYW1lXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJlcHJvY2Vzc29yRXJyb3IoJ0luY29ycmVjdCBwYXJhbWV0ZXJzLiBGdW5jdGlvbiBleHBlY3RlZCEnKTtcclxuICAgICAgICAgICAgaWYoIW9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZihzaGlmdF9jZWxscykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLnNwbGljZShvcmRlciwgMCwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5zcGxpY2Uob3JkZXIsIDAsIGFjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lc1tvcmRlcl0gPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnNbb3JkZXJdID0gYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRQcmVwcm9jZXNzb3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcHJlcHJvY2Vzc29ycyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gcHJlcHJvY2Vzc29ycy5uYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gcHJlcHJvY2Vzc29ycy5uYW1lc1tpXTtcclxuICAgICAgICAgICAgICAgIHByZXByb2Nlc3NvcnNbbmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBwcmVwcm9jZXNzb3JzLmFjdGlvbnNbaV1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByZXByb2Nlc3NvcnM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5yZW1vdmVQcmVwcm9jZXNzb3IgPSBmdW5jdGlvbiAobmFtZSwgc2hpZnRfY2VsbHMpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSBwcmVwcm9jZXNzb3JzLm5hbWVzLmluZGV4T2YobmFtZSk7XHJcbiAgICAgICAgICAgIGlmKHNoaWZ0X2NlbGxzKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUocHJlcHJvY2Vzc29ycy5uYW1lcywgaSk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmUocHJlcHJvY2Vzc29ycy5hY3Rpb25zLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByZXByb2Nlc3NvcnMubmFtZXNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBwcmVwcm9jZXNzb3JzLmFjdGlvbnNbaV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvL1RoZSBsb2FkZXIgZm9yIGZ1bmN0aW9ucyB3aGljaCBhcmUgbm90IHBhcnQgb2YgTWF0aDJcclxuICAgICAgICB0aGlzLm1hcHBlZF9mdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHN1YnMgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcztcclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHN1YnNbcGFyYW1zW2ldXSA9IFN0cmluZyhhcmd1bWVudHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gXy5wYXJzZSh0aGlzLmJvZHksIHN1YnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyB0d28gc3ltYm9sc1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBhXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWRkID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGFJc1N5bWJvbCA9IGlzU3ltYm9sKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJJc1N5bWJvbCA9IGlzU3ltYm9sKGIpO1xyXG4gICAgICAgICAgICAvL3dlJ3JlIGRlYWxpbmcgd2l0aCB0d28gc3ltYm9sc1xyXG4gICAgICAgICAgICBpZihhSXNTeW1ib2wgJiYgYklzU3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAvL2ZvcndhcmQgdGhlIGFkZGluZyBvZiBzeW1ib2xzIHdpdGggdW5pdHMgdG8gdGhlIFVuaXQgbW9kdWxlXHJcbiAgICAgICAgICAgICAgICBpZihhLnVuaXQgfHwgYi51bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uVW5pdC5hZGQoYSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgLy9odHRwczovL3d3dy5lbmN5Y2xvcGVkaWFvZm1hdGgub3JnL2luZGV4LnBocC9JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgaWYoYS5pc0luZmluaXR5IHx8IGIuaXNJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmVnID0gYS5tdWx0aXBsaWVyLmxlc3NUaGFuKDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm5lZyA9IGIubXVsdGlwbGllci5sZXNzVGhhbigwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYS5pc0luZmluaXR5ICYmIGIuaXNJbmZpbml0eSAmJiBhbmVnICE9PSBibmVnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignKCcgKyBhICsgJykrKCcgKyBiICsgJykgaXMgbm90IGRlZmluZWQhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mID0gU3ltYm9sLmluZmluaXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYm5lZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYS5pc0NvbXBvc2l0ZSgpICYmIGEuaXNMaW5lYXIoKSAmJiBiLmlzQ29tcG9zaXRlKCkgJiYgYi5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaXggZm9yIGlzc3VlICM2MDZcclxuICAgICAgICAgICAgICAgICAgICBpZihiLmxlbmd0aCA+IGEubGVuZ3RoICYmIGEuZ3JvdXAgPT09IGIuZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2EsIGJdID0gW2IsIGFdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy9ubyBuZWVkIHRvIHdhc3RlIHRpbWUgb24gemVyb2VzXHJcbiAgICAgICAgICAgICAgICBpZihhLm11bHRpcGxpZXIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICAgICAgaWYoYi5tdWx0aXBsaWVyLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihhLmlzQ29uc3RhbnQoKSAmJiBiLmlzQ29uc3RhbnQoKSAmJiBTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN5bWJvbChhLm11bHRpcGxpZXIuYWRkKGIubXVsdGlwbGllcikudG9EZWNpbWFsKFNldHRpbmdzLlBSRUNJU0lPTikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGcxID0gYS5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZzIgPSBiLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcCA9IGEucG93ZXIudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnAgPSBiLnBvd2VyLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9hbHdheXMga2VlcCB0aGUgZ3JlYXRlciBncm91cCBvbiB0aGUgbGVmdC5cclxuICAgICAgICAgICAgICAgIGlmKGcxIDwgZzIgfHwgKGcxID09PSBnMiAmJiBhcCA+IGJwICYmIGJwID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoYiwgYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLypub3RlIHRvIHNlbGY6IFBsZWFzZSBkb24ndCBmb3JnZXQgYWJvdXQgdGhpcyBkaWxlbW1hIGV2ZXIgYWdhaW4uIEluIHRoaXMgbW9kZWwgUEwgYW5kIENCIGdvZXMgY3JhenlcclxuICAgICAgICAgICAgICAgICAqIGJlY2F1c2UgaXQgZG9lc24ndCBrbm93IHdoaWNoIG9uZSB0byBwcmlvcml0aXplLiAqL1xyXG4gICAgICAgICAgICAgICAgLy9jb3JyZWN0aW9uIHRvIFBMIGRpbGVtbWFcclxuICAgICAgICAgICAgICAgIGlmKGcxID09PSBDQiAmJiBnMiA9PT0gUEwgJiYgYS52YWx1ZSA9PT0gYi52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc3dhcFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBiID0gdDtcclxuICAgICAgICAgICAgICAgICAgICBnMSA9IGEuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgZzIgPSBiLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwID0gYS5wb3dlci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJwID0gYi5wb3dlci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb3dFUSA9IGFwID09PSBicCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdjEgPSBhLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MiA9IGIudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFJc0NvbXBvc2l0ZSA9IGEuaXNDb21wb3NpdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYklzQ29tcG9zaXRlID0gYi5pc0NvbXBvc2l0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoMSwgaDIsIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihhSXNDb21wb3NpdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgaDEgPSB0ZXh0KGEsICdoYXNoJyk7XHJcbiAgICAgICAgICAgICAgICBpZihiSXNDb21wb3NpdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgaDIgPSB0ZXh0KGIsICdoYXNoJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZzEgPT09IENQICYmIGcyID09PSBDUCAmJiBiLmlzTGluZWFyKCkgJiYgIWEuaXNMaW5lYXIoKSAmJiBoMSAhPT0gaDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoYiwgYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9QTCAmIFBMIHNob3VsZCBjb21wYXJlIGhhc2hlcyBhbmQgbm90IHZhbHVlcyBlLmcuIGNvbXBhcmUgeCt4XjIgd2l0aCB4K3heMyBhbmQgbm90IHggd2l0aCB4XHJcbiAgICAgICAgICAgICAgICBpZihnMSA9PT0gUEwgJiYgZzIgPT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBoMTtcclxuICAgICAgICAgICAgICAgICAgICB2MiA9IGgyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBQTiA9IGcxID09PSBQICYmIGcyID09PSBOLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBQTkVRID0gYS52YWx1ZSA9PT0gYi5tdWx0aXBsaWVyLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbEVRID0gKHYxID09PSB2MiB8fCBoMSA9PT0gaDIgJiYgaDEgIT09IHVuZGVmaW5lZCB8fCAoUE4gJiYgUE5FUSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZXF1YWwgdmFsdWVzLCBlcXVhbCBwb3dlcnNcclxuICAgICAgICAgICAgICAgIGlmKHZhbEVRICYmIHBvd0VRICYmIGcxID09PSBnMikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIHRvIGNvbnZlcnQgTiB0byBzb21ldGhpbmcgUCBjYW4gd29yayB3aXRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoUE4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiLmNvbnZlcnQoUCk7Ly9DTFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2hhbmRsZSBQTFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGcxID09PSBQTCAmJiAoZzIgPT09IFMgfHwgZzIgPT09IFApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYS5hdHRhY2goYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhOy8vQ0xcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5tdWx0aXBsaWVyLmlzT25lKCkgJiYgYi5tdWx0aXBsaWVyLmlzT25lKCkgJiYgZzEgPT09IENQICYmIGEuaXNMaW5lYXIoKSAmJiBiLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcyBpbiBiLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGIuc3ltYm9sc1tzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXR0YWNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBsaWVyID0gcmVzdWx0Lm11bHRpcGxpZXIuYWRkKGIubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9lcXVhbCB2YWx1ZXMgdW5ldmVuIHBvd2Vyc1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih2YWxFUSAmJiBnMSAhPT0gUEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2JyZWFrIHRoZSB0aWUgZm9yIGUuZy4gKHgrMSkrKCh4KzEpXjIrKHgrMSleMylcclxuICAgICAgICAgICAgICAgICAgICBpZihnMSA9PT0gQ1AgJiYgZzIgPT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuaW5zZXJ0KGEsICdhZGQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN5bWJvbC5zaGVsbChQTCkuYXR0YWNoKFthLCBiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBoYXNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGcxID09PSBQTCA/IGgxIDogdjE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhSXNDb21wb3NpdGUgJiYgYS5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbkl0ZXJhdGUgPSBnMSA9PT0gZzIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3RoUEwgPSBnMSA9PT0gUEwgJiYgZzIgPT09IFBMO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3dlIGNhbiBvbmx5IGl0ZXJhdGUgZ3JvdXAgUEwgaWYgdGhleSB2YWx1ZXMgbWF0Y2hcclxuICAgICAgICAgICAgICAgICAgICBpZihib3RoUEwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkl0ZXJhdGUgPSBhLnZhbHVlID09PSBiLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZGlzdHJpYnV0ZSB0aGUgbXVsdGlwbGllciBvdmVyIHRoZSBlbnRpcmUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgYS5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihiLmlzQ29tcG9zaXRlKCkgJiYgYi5pc0xpbmVhcigpICYmIGNhbkl0ZXJhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0NMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcyBpbiBiLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gYi5zeW1ib2xzW3NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5hdHRhY2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGUgY2FzZXMgbGlrZSAyKih4K3heMileMisyKih4K3heMileMys0Kih4K3heMileMlxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYm90aFBMICYmIGEudmFsdWUgIT09IGgyIHx8IGcxID09PSBQTCAmJiAhdmFsRVEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3ltYm9sLnNoZWxsKENQKS5hdHRhY2goW2EsIGJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnVwZGF0ZUhhc2goKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhLmF0dGFjaChiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihnMSA9PT0gRk4gJiYgYS5mbmFtZSA9PT0gU1FSVCAmJiBnMiAhPT0gRVggJiYgYi5wb3dlci5lcXVhbHMoMC41KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGIubXVsdGlwbGllci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gc3FydChiLnRvVW5pdE11bHRpcGxpZXIoKS50b0xpbmVhcigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5tdWx0aXBsaWVyID0gbTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9maXggZm9yIGlzc3VlICMzIGFuZCAjMTU5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYS5sZW5ndGggPT09IDIgJiYgYi5sZW5ndGggPT09IDIgJiYgZXZlbihhLnBvd2VyKSAmJiBldmVuKGIucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uYWRkKGV4cGFuZChhKSwgZXhwYW5kKGIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN5bWJvbC5zaGVsbChDUCkuYXR0YWNoKFthLCBiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC51cGRhdGVIYXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5tdWx0aXBsaWVyLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIHRvIHJlbW92ZSB1bm5lY2Vzc2FyeSB3cmFwc1xyXG4gICAgICAgICAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gcmVzdWx0Lm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3RPYmplY3QocmVzdWx0LnN5bWJvbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBsaWVyID0gcmVzdWx0Lm11bHRpcGxpZXIubXVsdGlwbHkobSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8va2VlcCBzeW1ib2xzIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgICAgICAgaWYoYklzU3ltYm9sICYmICFhSXNTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHQ7IC8vc3dhcFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBiSXNTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgYklzU3ltYm9sID0gYUlzU3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIGFJc1N5bWJvbCA9IHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJJc01hdHJpeCA9IGlzTWF0cml4KGIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGFJc1N5bWJvbCAmJiBiSXNNYXRyaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBiLmVhY2hFbGVtZW50KGZ1bmN0aW9uIChlLCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE0uc2V0KGksIGosIF8uYWRkKGEuY2xvbmUoKSwgZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBiID0gTVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNNYXRyaXgoYSkgJiYgYklzTWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBhLmFkZChiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhSXNTeW1ib2wgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5lYWNoKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmVsZW1lbnRzW2ldID0gXy5hZGQoYS5jbG9uZSgpLCBiLmVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpc1ZlY3RvcihhKSAmJiBpc1ZlY3RvcihiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5lYWNoKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuZWxlbWVudHNbaV0gPSBfLmFkZChhLmVsZW1lbnRzW2ldLCBiLmVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNWZWN0b3IoYSkgJiYgaXNNYXRyaXgoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IHRvIGNvbnZlcnQgYSB0byBhIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKGIsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNNYXRyaXgoYSkgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIuZWxlbWVudHMubGVuZ3RoID09PSBhLnJvd3MoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpLCBsID0gYS5jb2xzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5lYWNoKGZ1bmN0aW9uIChlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goXy5hZGQoYS5lbGVtZW50c1tpIC0gMV1bal0uY2xvbmUoKSwgZS5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTS5lbGVtZW50cy5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyKCdEaW1lbnNpb25zIG11c3QgbWF0Y2ghJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHBhcnNlciBmaW5kcyB0aGUgLSBvcGVyYXRvci4gTm90IHRoZSBwcmVmaXggb3BlcmF0b3IuIFNlZSB0aGlzLmFkZFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBhXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3VidHJhY3QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYUlzU3ltYm9sID0gYUlzU3ltYm9sID0gaXNTeW1ib2woYSksXHJcbiAgICAgICAgICAgICAgICAgICAgYklzU3ltYm9sID0gaXNTeW1ib2woYiksIHQ7XHJcblxyXG4gICAgICAgICAgICBpZihhSXNTeW1ib2wgJiYgYklzU3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihhLnVuaXQgfHwgYi51bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uVW5pdC5zdWJ0cmFjdChhLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChhLCBiLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKGJJc1N5bWJvbCAmJiBpc1ZlY3RvcihhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBhLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5zdWJ0cmFjdCh4LCBiLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhSXNTeW1ib2wgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICBiID0gYi5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QoYS5jbG9uZSgpLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNWZWN0b3IoYSkgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihhLmRpbWVuc2lvbnMoKSA9PT0gYi5kaW1lbnNpb25zKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBhLnN1YnRyYWN0KGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignVW5hYmxlIHRvIHN1YnRyYWN0IHZlY3RvcnMuIERpbWVuc2lvbnMgZG8gbm90IG1hdGNoLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihpc01hdHJpeChhKSAmJiBpc1ZlY3RvcihiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGIuZWxlbWVudHMubGVuZ3RoID09PSBhLnJvd3MoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKSwgbCA9IGEuY29scygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmVhY2goZnVuY3Rpb24gKGUsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaChfLnN1YnRyYWN0KGEuZWxlbWVudHNbaSAtIDFdW2pdLmNsb25lKCksIGUuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTS5lbGVtZW50cy5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIoJ0RpbWVuc2lvbnMgbXVzdCBtYXRjaCEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNWZWN0b3IoYSkgJiYgaXNNYXRyaXgoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IGIuY2xvbmUoKS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQoTSwgYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzTWF0cml4KGEpICYmIGlzTWF0cml4KGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGEuc3VidHJhY3QoYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzTWF0cml4KGEpICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuZWFjaChmdW5jdGlvbiAoeCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBfLnN1YnRyYWN0KHgsIGIuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBNO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihhSXNTeW1ib2wgJiYgaXNNYXRyaXgoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBiLmVhY2goZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgXy5zdWJ0cmFjdChhLmNsb25lKCksIHgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gTTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBwYXJzZXIgZmluZHMgdGhlICogb3BlcmF0b3IuIFNlZSB0aGlzLmFkZFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBhXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYUlzU3ltYm9sID0gaXNTeW1ib2woYSksXHJcbiAgICAgICAgICAgICAgICAgICAgYklzU3ltYm9sID0gaXNTeW1ib2woYik7XHJcbiAgICAgICAgICAgIC8vd2UncmUgZGVhbGluZyB3aXRoIGZ1bmN0aW9uIGFzc2lnbm1lbnQgaGVyZVxyXG4gICAgICAgICAgICBpZihhSXNTeW1ib2wgJiYgYiBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGIuZWxlbWVudHMucHVzaChhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGFJc1N5bWJvbCAmJiBiSXNTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIC8vaWYgaXQgaGFzIGEgdW5pdCB0aGVuIGFkZCBpdCBhbmQgcmV0dXJuIGl0IHJpZ2h0IGF3YXkuXHJcbiAgICAgICAgICAgICAgICBpZihiLmlzVW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBhLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS51bml0ID0gYjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvL2lmIGl0IGhhcyB1bml0cyB0aGVuIGp1c3QgZm9yd2FyZCB0aGF0IHByb2JsZW0gdG8gdGhlIHVuaXQgbW9kdWxlXHJcbiAgICAgICAgICAgICAgICBpZihhLnVuaXQgfHwgYi51bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uVW5pdC5tdWx0aXBseShhLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBJbmZpbnR5XHJcbiAgICAgICAgICAgICAgICBpZihhLmlzSW5maW5pdHkgfHwgYi5pc0luZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYS5lcXVhbHMoMCkgfHwgYi5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcihhICsgJyonICsgYiArICcgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8veC9pbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGIucG93ZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWEuaXNJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJ0luZmluaXR5L0luZmluaXR5IGlzIG5vdCBkZWZpbmVkIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IGEubXVsdGlwbGllci5tdWx0aXBseShiLm11bHRpcGxpZXIpLnNpZ24oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZiA9IFN5bWJvbC5pbmZpbml0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEuaXNDb25zdGFudCgpIHx8IGIuaXNDb25zdGFudCgpIHx8IChhLmlzSW5maW5pdHkgJiYgYi5pc0luZmluaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZi5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy90aGUgcXVpY2tpZXNcclxuICAgICAgICAgICAgICAgIGlmKGEuaXNDb25zdGFudCgpICYmIGIuaXNDb25zdGFudCgpICYmIFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IGJpZ0RlYyhhLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpLnRpbWVzKG5ldyBiaWdEZWMoYi5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSkudG9GaXhlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgU3ltYm9sKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9kb24ndCB3YXN0ZSB0aW1lXHJcbiAgICAgICAgICAgICAgICBpZihhLmlzT25lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoYi5pc09uZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihhLm11bHRpcGxpZXIuZXF1YWxzKDApIHx8IGIubXVsdGlwbGllci5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYi5ncm91cCA+IGEuZ3JvdXAgJiYgIShiLmdyb3VwID09PSBDUCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYiwgYSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvcnJlY3Rpb24gZm9yIFBML0NCIGRpbGVtbWFcclxuICAgICAgICAgICAgICAgIGlmKGEuZ3JvdXAgPT09IENCICYmIGIuZ3JvdXAgPT09IFBMICYmIGEudmFsdWUgPT09IGIudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHQ7Ly9zd2FwXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGcxID0gYS5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZzIgPSBiLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBibnVtID0gYi5tdWx0aXBsaWVyLm51bSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmRlbiA9IGIubXVsdGlwbGllci5kZW47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZzEgPT09IEZOICYmIGEuZm5hbWUgPT09IFNRUlQgJiYgIWIuaXNDb25zdGFudCgpICYmIGEuYXJnc1swXS52YWx1ZSA9PT0gYi52YWx1ZSAmJiAhYS5hcmdzWzBdLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3Vud3JhcCBzcXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFfcG93ID0gYS5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYV9tdWx0aXBsaWVyID0gXy5wYXJzZShhLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBfLm11bHRpcGx5KGFfbXVsdGlwbGllciwgYS5hcmdzWzBdLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuc2V0UG93ZXIobmV3IEZyYWMoMC41KS5tdWx0aXBseShhX3BvdykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGcxID0gYS5ncm91cDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vc2ltcGxpZnkgbi9zcXJ0KG4pLiBCZWluZyB2ZXJ5IHNwZWNpZmljXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcxID09PSBGTiAmJiBhLmZuYW1lID09PSBTUVJUICYmIGEubXVsdGlwbGllci5lcXVhbHMoMSkgJiYgYS5wb3dlci5lcXVhbHMoLTEpICYmIGIuaXNDb25zdGFudCgpICYmIGEuYXJnc1swXS5lcXVhbHMoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gXy5zeW1mdW5jdGlvbihTUVJULCBbYi5jbG9uZSgpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHYxID0gYS52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBiLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gbmV3IEZyYWMoYS5zaWduKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIFAgaXMganVzdCBhIG1vcnBoZWQgdmVyc2lvbiBvZiBOIHdlIG5lZWQgdG8gc2VlIGlmIHRoZXkgcmVsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9OTiA9IChnMSA9PT0gUCAmJiBnMiA9PT0gTiAmJiBiLm11bHRpcGxpZXIuZXF1YWxzKGEudmFsdWUpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kb24ndCBtdWx0aXBseSB0aGUgbXVsdGlwbGllciBvZiBiIHNpbmNlIHRoYXQncyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gT05OID8gbmV3IEZyYWMoMSkubXVsdGlwbHkoYS5tdWx0aXBsaWVyKS5hYnMoKSA6IGEubXVsdGlwbGllci5tdWx0aXBseShiLm11bHRpcGxpZXIpLmFicygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhLmNsb25lKCkudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgYiA9IGIuY2xvbmUoKS50b1VuaXRNdWx0aXBsaWVyKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZnVydGhlciBzaW1wbGlmaWNhdGlvbiBvZiBzcXJ0XHJcbiAgICAgICAgICAgICAgICBpZihnMSA9PT0gRk4gJiYgZzIgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBhLmFyZ3NbMF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGIuYXJnc1swXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEuZm5hbWUgPT09IFNRUlQgJiYgYi5mbmFtZSA9PT0gU1FSVCAmJiBhLmlzTGluZWFyKCkgJiYgYi5pc0xpbmVhcigpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IF8uZGl2aWRlKHUsIHYpLmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihxLmd0KDEpICYmIGlzSW50KHEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2IgY29udGFpbnMgYSBmYWN0b3IgYSB3aGljaCBjYW4gYmUgbW92ZWQgdG8gYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShhLmFyZ3NbMF0uY2xvbmUoKSwgc3FydChxLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2ltcGxpZnkgZmFjdG9yaWFsIGJ1dCBvbmx5IGlmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8xIC0gSXQncyBkaXZpc2lvbiBzbyBiIHdpbGwgaGF2ZSBhIG5lZ2F0aXZlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8yIC0gV2UncmUgbm90IGRlYWxpbmcgd2l0aCBmYWN0b3JpYWxzIG9mIG51bWJlcnNcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGEuZm5hbWUgPT09IEZBQ1RPUklBTCAmJiBiLmZuYW1lID09PSBGQUNUT1JJQUwgJiYgIXUuaXNDb25zdGFudCgpICYmICF2LmlzQ29uc3RhbnQoKSAmJiBiLnBvd2VyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc3VtZSB0aGF0IG4gPSBwb3NpdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF8uc3VidHJhY3QodS5jbG9uZSgpLCB2LmNsb25lKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIG5vdCBudW1lcmljIHRoZW4gd2UgZG9uJ3Qga25vdyBpZiB3ZSBjYW4gc2ltcGxpZnkgc28ganVzdCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZC5pc0NvbnN0YW50KCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZXJlIHdpbGwgbmV2ZXIgYmUgYSBjYXNlIHdoZXJlIGQgPT0gMCBzaW5jZSB0aGlzIHdpbGwgYWxyZWFkeSBoYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2JlZW4gaGFuZGxlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIGQgaXMgbmVnYXRpdmUgdGhlbiB0aGUgbnVtZXJhdG9yIGlzIGxhcmdlciBzbyBleHBhbmQgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSBNYXRoLmFicyhkKTsgaSA8PSBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfLmFkZCh1LmNsb25lKCksIG5ldyBTeW1ib2woaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5tdWx0aXBseSh0LCBzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ubXVsdGlwbHkoXy5wb3codSwgbmV3IFN5bWJvbChhLnBvd2VyKSksIF8ucG93KHQsIG5ldyBTeW1ib2woYi5wb3dlcikpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL090aGVyd2lzZSB0aGUgZGVub21pbmF0b3IgaXMgbGFyZ2VyIHNvIGV4cGFuZCB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbiA9IE1hdGguYWJzKGQpOyBpIDw9IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IF8uYWRkKHYuY2xvbmUoKSwgbmV3IFN5bWJvbChpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLm11bHRpcGx5KHQsIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShfLnBvdyh0LCBuZXcgU3ltYm9sKGEucG93ZXIpKSwgXy5wb3codiwgbmV3IFN5bWJvbChiLnBvd2VyKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiBib3RoIGFyZSBQTCB0aGVuIHRoZWlyIGhhc2hlcyBoYXZlIHRvIG1hdGNoXHJcbiAgICAgICAgICAgICAgICBpZih2MSA9PT0gdjIgJiYgZzEgPT09IFBMICYmIGcxID09PSBnMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHYxID0gYS50ZXh0KCdoYXNoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdjIgPSBiLnRleHQoJ2hhc2gnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3NhbWUgaXNzdWUgd2l0aCAoeF4yKzEpXngqKHheMisxKVxyXG4gICAgICAgICAgICAgICAgLy9FWCBuZWVkcyBhbiBleGNlcHRpb24gd2hlbiBtdWx0aXBseWluZyBiZWNhdXNlIGl0IG5lZWRzIHRvIHJlY29nbml6ZVxyXG4gICAgICAgICAgICAgICAgLy90aGF0ICh4K3heMileeCBoYXMgdGhlIHNhbWUgaGFzaCBhcyAoeCt4XjIpLiBUaGUgbGF0dGVyIGlzIGtlcHQgYXMgeFxyXG4gICAgICAgICAgICAgICAgaWYoZzIgPT09IEVYICYmIGIucHJldmlvdXNHcm91cCA9PT0gUEwgJiYgZzEgPT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdjEgPSB0ZXh0KGEsICdoYXNoJywgRVgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKCh2MSA9PT0gdjIgfHwgT05OKSAmJiAhKGcxID09PSBQTCAmJiAoZzIgPT09IFMgfHwgZzIgPT09IFAgfHwgZzIgPT09IEZOKSkgJiYgIShnMSA9PT0gUEwgJiYgZzIgPT09IENCKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IGEucG93ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IGIucG93ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1N5bWJvbFAxID0gaXNTeW1ib2wocDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTeW1ib2xQMiA9IGlzU3ltYm9sKHAyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvRVggPSAoaXNTeW1ib2xQMSB8fCBpc1N5bWJvbFAyKTtcclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IHRoaXMgbmVlZHMgY2xlYW5pbmcgdXBcclxuICAgICAgICAgICAgICAgICAgICBpZihnMSA9PT0gUEwgJiYgZzIgIT09IFBMICYmIGIucHJldmlvdXNHcm91cCAhPT0gUEwgJiYgcDEuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5hZGQocmVzdWx0LCBfLm11bHRpcGx5KHgsIGIuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZSBwb3dlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvd2VyID0gdG9FWCA/IF8uYWRkKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoaXNTeW1ib2wocDEpKSA/IG5ldyBTeW1ib2wocDEpIDogcDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIShpc1N5bWJvbChwMikpID8gbmV3IFN5bWJvbChwMikgOiBwMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoZzEgPT09IE4gLypkb24ndCBhZGQgcG93ZXJzIGZvciBOKi8gPyBwMSA6IHAxLmFkZChwMikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9lbGltaW5hdGUgemVybyBwb3dlciB2YWx1ZXMgYW5kIGNvbnZlcnQgdGhlbSB0byBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5wb3dlci5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29udmVydChOKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcHJvcGVybHkgY29udmVydCB0byBFWFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0b0VYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvbnZlcnQoRVgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90YWtlIGNhcmUgb2YgaW1hZ2luYXJpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5pbWFnaW5hcnkgJiYgYi5pbWFnaW5hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0V2ZW4gPSBldmVuKHJlc3VsdC5wb3dlciAlIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNFdmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NsZWFudXA6IHRoaXMgY2F1c2VzIHRoZSBMYVRlWCBnZW5lcmF0b3IgdG8gZ2V0IGNvbmZ1c2VkIGFzIHRvIGhvdyB0byByZW5kZXIgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuZ3JvdXAgIT09IEVYICYmIHJlc3VsdC5wcmV2aW91c0dyb3VwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnByZXZpb3VzR3JvdXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIHNpZ24gZm9yIGIgaXMgZmxvYXRpbmcgYXJvdW5kLiBSZW1lbWJlciB3ZSBhcmUgYXNzdW1pbmcgdGhhdCB0aGUgb2RkIHZhcmlhYmxlIHdpbGwgY2FycnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgc2lnbiBidXQgdGhpcyBpc24ndCB0cnVlIGlmIHRoZXkncmUgZXF1YWxzIHN5bWJvbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm11bHRpcGxpZXIgPSByZXN1bHQubXVsdGlwbGllci5tdWx0aXBseShiLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZzEgPT09IENCICYmIGEuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGcyID09PSBDQilcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5kaXN0cmlidXRlRXhwb25lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihnMiA9PT0gQ0IgJiYgYi5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcyBpbiBiLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gYi5zeW1ib2xzW3NdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbWJpbmUoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm11bHRpcGxpZXIgPSByZXN1bHQubXVsdGlwbGllci5tdWx0aXBseShiLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvbWJpbmUoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbXVsdGlwbGllciB3YXMgYWxyZWFkeSBoYW5kbGVkIHNvIG5vdGhpbmcgbGVmdCB0byBkb1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGcxICE9PSBOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGcxID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3RyaWJ1dGVFeHBvbmVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvbWJpbmUoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZighYi5pc09uZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm0gPSBiLm11bHRpcGxpZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gU3ltYm9sLnNoZWxsKENCKS5jb21iaW5lKFtyZXN1bHQsIGJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJhbnNmZXIgdGhlIG11bHRpcGxpZXIgdG8gdGhlIG91dHNpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBsaWVyID0gcmVzdWx0Lm11bHRpcGxpZXIubXVsdGlwbHkoYm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBiLmNsb25lKCkudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQuZ3JvdXAgPT09IFApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9nViA9IE1hdGgubG9nKHJlc3VsdC52YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuMSA9IE1hdGgubG9nKGJudW0pIC8gbG9nVixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4yID0gTWF0aC5sb2coYmRlbikgLyBsb2dWLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmRpdiA9IG0ubnVtIC8gYm51bSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRkaXYgPSBtLmRlbiAvIGJkZW47XHJcbiAgICAgICAgICAgICAgICAgICAgLy93ZSBkb24ndCB3YW50IHRvIGRpdmlkZSBieSB6ZXJvIG5vIGRvIHdlPyBTdHJhbmdlIHRoaW5ncyBoYXBwZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYobjEgIT09IDAgJiYgaXNJbnQobjEpICYmIGlzSW50KG5kaXYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wb3dlciA9IHJlc3VsdC5wb3dlci5hZGQobmV3IEZyYWMobjEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5udW0gLz0gYm51bTsgLy9CaWdJbnQ/IEtlZXAgdGhhdCBpbiBtaW5kIGZvciB0aGUgZnV0dXJlLlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihuMiAhPT0gMCAmJiBpc0ludChuMikgJiYgaXNJbnQoZGRpdikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvd2VyID0gcmVzdWx0LnBvd2VyLnN1YnRyYWN0KG5ldyBGcmFjKG4yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0uZGVuIC89IGJkZW47IC8vQmlnSW50PyBLZWVwIHRoYXQgaW4gbWluZCBmb3IgdGhlIGZ1dHVyZS5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy91bnBhY2sgQ0IgaWYgbGVuZ3RoIGlzIG9ubHkgb25lXHJcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSByZXN1bHQubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICAvL3RyYW5zZmVyIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZmlyc3RPYmplY3QocmVzdWx0LnN5bWJvbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBsaWVyID0gcmVzdWx0Lm11bHRpcGxpZXIubXVsdGlwbHkodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZWR1Y2Ugc3F1YXJlIHJvb3RcclxuICAgICAgICAgICAgICAgIHZhciBwcyA9IHJlc3VsdC5wb3dlci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgaWYoZXZlbihwcykgJiYgcmVzdWx0LmZuYW1lID09PSBTUVJUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ncmFiIHRoZSBzaWduIG9mIHRoZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICBzaWduID0gc2lnbiAqIHJlc3VsdC5zaWduKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSByZXN1bHQucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShuZXcgU3ltYm9sKG0pLCBfLnBvdyhyZXN1bHQsIG5ldyBTeW1ib2wocC5kaXZpZGUobmV3IEZyYWMoMikpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZmxpcCBpdCBiYWNrIHRvIHRoZSBjb3JyZWN0IHNpZ25cclxuICAgICAgICAgICAgICAgICAgICBpZihzaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm5lZ2F0ZSgpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlwbGllciA9IHJlc3VsdC5tdWx0aXBsaWVyLm11bHRpcGx5KG0pLm11bHRpcGx5KHNpZ24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5ncm91cCA9PT0gQ1AgJiYgcmVzdWx0LmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vYmFjayBjb252ZXJ0IGdyb3VwIFAgdG8gYSBzaW1wbGVyIGdyb3VwIE4gaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5ncm91cCA9PT0gUCAmJiBpc0ludChyZXN1bHQucG93ZXIudG9EZWNpbWFsKCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb252ZXJ0KE4pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyoqKioqKiBNYXRyaWNlcyAmIFZlY3RvciAqKioqKi8vXHJcbiAgICAgICAgICAgICAgICBpZihiSXNTeW1ib2wgJiYgIWFJc1N5bWJvbCkgeyAvL2tlZXAgc3ltYm9scyB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICB0ID0gYTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgICAgICBiID0gdDsgLy9zd2FwXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IGJJc1N5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICBiSXNTeW1ib2wgPSBhSXNTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgYUlzU3ltYm9sID0gdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaXNNYXRyaXhCID0gaXNNYXRyaXgoYiksIGlzTWF0cml4QSA9IGlzTWF0cml4KGEpO1xyXG4gICAgICAgICAgICAgICAgaWYoYUlzU3ltYm9sICYmIGlzTWF0cml4Qikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuZWFjaEVsZW1lbnQoZnVuY3Rpb24gKGUsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgXy5tdWx0aXBseShhLmNsb25lKCksIGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IE07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihpc01hdHJpeEEgJiYgaXNNYXRyaXhCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBhLm11bHRpcGx5KGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGFJc1N5bWJvbCAmJiBpc1ZlY3RvcihiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmVhY2goZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuZWxlbWVudHNbaV0gPSBfLm11bHRpcGx5KGEuY2xvbmUoKSwgYi5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNWZWN0b3IoYSkgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuZWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmVsZW1lbnRzW2ldID0gXy5tdWx0aXBseShhLmVsZW1lbnRzW2ldLCBiLmVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNWZWN0b3IoYSkgJiYgaXNNYXRyaXgoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IHRvIGNvbnZlcnQgYSB0byBhIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYiwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpc01hdHJpeChhKSAmJiBpc1ZlY3RvcihiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYi5lbGVtZW50cy5sZW5ndGggPT09IGEucm93cygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCksIGwgPSBhLmNvbHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmVhY2goZnVuY3Rpb24gKGUsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaChfLm11bHRpcGx5KGEuZWxlbWVudHNbaSAtIDFdW2pdLmNsb25lKCksIGUuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0uZWxlbWVudHMucHVzaChyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycignRGltZW5zaW9ucyBtdXN0IG1hdGNoIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBwYXJzZXIgZmluZHMgdGhlIC8gb3BlcmF0b3IuIFNlZSB0aGlzLmFkZFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBhXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGl2aWRlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGFJc1N5bWJvbCA9IGlzU3ltYm9sKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJJc1N5bWJvbCA9IGlzU3ltYm9sKGIpO1xyXG5cclxuICAgICAgICAgICAgaWYoYUlzU3ltYm9sICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgLy9mb3J3YXJkIHRvIFVuaXQgZGl2aXNpb25cclxuICAgICAgICAgICAgICAgIGlmKGEudW5pdCB8fCBiLnVuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5Vbml0LmRpdmlkZShhLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZihiLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGl2aXNpb25CeVplcm8oJ0RpdmlzaW9uIGJ5IHplcm8gbm90IGFsbG93ZWQhJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYS5pc0NvbnN0YW50KCkgJiYgYi5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm11bHRpcGxpZXIgPSByZXN1bHQubXVsdGlwbGllci5kaXZpZGUoYi5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShhLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyoqKioqKiogVmVjdG9ycyAmIE1hdHJpY2VzICoqKioqKioqKi8vXHJcbiAgICAgICAgICAgICAgICB2YXIgaXNWZWN0b3JBID0gaXNWZWN0b3IoYSksIGlzVmVjdG9yQiA9IGlzVmVjdG9yKGIpO1xyXG4gICAgICAgICAgICAgICAgaWYoYUlzU3ltYm9sICYmIGlzVmVjdG9yQikge1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBiLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoYS5jbG9uZSgpLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNWZWN0b3JBICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBhLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoeCwgYi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNWZWN0b3JBICYmIGlzVmVjdG9yQikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEuZGltZW5zaW9ucygpID09PSBiLmRpbWVuc2lvbnMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYi5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShhLmVsZW1lbnRzWy0taV0sIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVycm9yKCdDYW5ub3QgZGl2aWRlIHZlY3RvcnMuIERpbWVuc2lvbnMgZG8gbm90IG1hdGNoIScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTWF0cml4QSA9IGlzTWF0cml4KGEpLCBpc01hdHJpeEIgPSBpc01hdHJpeChiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihpc01hdHJpeEEgJiYgYklzU3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmVhY2hFbGVtZW50KGZ1bmN0aW9uICh4LCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBfLmRpdmlkZSh4LCBiLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBNO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGFJc1N5bWJvbCAmJiBpc01hdHJpeEIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuZWFjaEVsZW1lbnQoZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0uc2V0KGksIGosIF8uZGl2aWRlKGEuY2xvbmUoKSwgeCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IE07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNNYXRyaXhBICYmIGlzTWF0cml4Qikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5yb3dzKCkgPT09IGIucm93cygpICYmIGEuY29scygpID09PSBiLmNvbHMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5lYWNoRWxlbWVudChmdW5jdGlvbiAoeCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0uc2V0KGksIGosIF8uZGl2aWRlKHgsIGIuZWxlbWVudHNbaV1bal0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IE07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVycm9yKCdEaW1lbnNpb25zIGRvIG5vdCBtYXRjaCEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzTWF0cml4QSAmJiBpc1ZlY3RvckIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5jb2xzKCkgPT09IGIuZGltZW5zaW9ucygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZWFjaEVsZW1lbnQoZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBfLmRpdmlkZSh4LCBiLmVsZW1lbnRzW2ldLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IE07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVycm9yKCdVbmFibGUgdG8gZGl2aWRlIG1hdHJpeCBieSB2ZWN0b3IuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgcGFyc2VyIGZpbmRzIHRoZSBeIG9wZXJhdG9yLiBTZWUgdGhpcy5hZGRcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvdyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBhSXNTeW1ib2wgPSBpc1N5bWJvbChhKSxcclxuICAgICAgICAgICAgICAgICAgICBiSXNTeW1ib2wgPSBpc1N5bWJvbChiKTtcclxuICAgICAgICAgICAgaWYoYUlzU3ltYm9sICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgLy9pdCBoYXMgdW5pdHMgdGhlbiBpdCdzIHRoZSBVbml0IG1vZHVsZSdzIHByb2JsZW1cclxuICAgICAgICAgICAgICAgIGlmKGEudW5pdCB8fCBiLnVuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5Vbml0LnBvdyhhLCBiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGFic1xyXG4gICAgICAgICAgICAgICAgaWYoYS5ncm91cCA9PT0gRk4gJiYgYS5mbmFtZSA9PT0gQUJTICYmIGV2ZW4oYikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGEubXVsdGlwbGllci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByYWlzZWQgPSBfLnBvdyhhLmFyZ3NbMF0sIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlZC5tdWx0aXBsaWVyID0gbTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFpc2VkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaW5maW5pdHlcclxuICAgICAgICAgICAgICAgIGlmKGEuaXNJbmZpbml0eSB8fCBiLmlzSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihhLmlzSW5maW5pdHkgJiYgYi5pc0luZmluaXR5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJygnICsgYSArICcpXignICsgYiArICcpIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYS5pc0NvbnN0YW50KCkgJiYgYi5pc0luZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihiLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignMF5JbmZpbml0eSBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignMV4nICsgYi50b1N0cmluZygpICsgJyBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYV4tb29cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYi5sZXNzVGhhbigwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Feb29cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWEubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sLmluZmluaXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihhLmlzSW5maW5pdHkgJiYgYi5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYi5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoYSArICdeMCBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoU3ltYm9sLmluZmluaXR5KCksIF8ucG93KG5ldyBTeW1ib2woYS5zaWduKCkpLCBiLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGFJc1plcm8gPSBhLmVxdWFscygwKTtcclxuICAgICAgICAgICAgICAgIHZhciBiSXNaZXJvID0gYi5lcXVhbHMoMCk7XHJcbiAgICAgICAgICAgICAgICBpZihhSXNaZXJvICYmIGJJc1plcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKCcwXjAgaXMgdW5kZWZpbmVkIScpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldHVybiAwIHJpZ2h0IGF3YXkgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIGlmKGFJc1plcm8gJiYgYi5pc0NvbnN0YW50KCkgJiYgYi5tdWx0aXBsaWVyLmdyZWF0ZXJUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGJJc1plcm8pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJJc0NvbnN0YW50ID0gYi5pc0NvbnN0YW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFJc0NvbnN0YW50ID0gYS5pc0NvbnN0YW50KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJJc0ludCA9IGIuaXNJbnRlZ2VyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBhLm11bHRpcGxpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGEuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwXjAsIDEvMCwgZXRjLiBDb21wbGFpbi5cclxuICAgICAgICAgICAgICAgIGlmKGFJc0NvbnN0YW50ICYmIGJJc0NvbnN0YW50ICYmIGEuZXF1YWxzKDApICYmIGIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKCdEaXZpc2lvbiBieSB6ZXJvIGlzIG5vdCBhbGxvd2VkIScpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgaW1hZ2luYXJ5IG51bWJlcnMgcmlnaHQgYXdheVxyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIGFJc0NvbnN0YW50ICYmIGJJc0NvbnN0YW50ICYmIGEuc2lnbigpIDwgMCAmJiBldmVuRnJhY3Rpb24oYikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaywgcmUsIGltO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSBNYXRoLlBJICogYjtcclxuICAgICAgICAgICAgICAgICAgICByZSA9IG5ldyBTeW1ib2woTWF0aC5jb3MoaykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltID0gXy5tdWx0aXBseShTeW1ib2wuaW1hZ2luYXJ5KCksIG5ldyBTeW1ib2woTWF0aC5zaW4oaykpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQocmUsIGltKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbWFnaW5hcnkgbnVtYmVyIHVuZGVyIG5lZ2F0aXZlIG50aHJvb3Qgb3IgdG8gdGhlIG5cclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUiAmJiBhLmlzSW1hZ2luYXJ5KCkgJiYgYklzQ29uc3RhbnQgJiYgaXNJbnQoYikgJiYgIWIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmUsIGltLCByLCB0aGV0YSwgbnJlLCBuaW0sIHBoaTtcclxuICAgICAgICAgICAgICAgICAgICByZSA9IGEucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpbSA9IGEuaW1hZ3BhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihyZS5pc0NvbnN0YW50KCdhbGwnKSAmJiBpbS5pc0NvbnN0YW50KCdhbGwnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwaGkgPSBTZXR0aW5ncy5VU0VfQklHID8gU3ltYm9sKGJpZ0RlYy5hdGFuMihpLm11bHRpcGxpZXIudG9EZWNpbWFsKCksIHIubXVsdGlwbGllci50b0RlY2ltYWwoKSkudGltZXMoYi50b1N0cmluZygpKSkgOiBNYXRoLmF0YW4yKGltLCByZSkgKiBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IG5ldyBTeW1ib2wocGhpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IF8ucG93KFN5bWJvbC5oeXAocmUsIGltKSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5yZSA9IF8ubXVsdGlwbHkoci5jbG9uZSgpLCBfLnRyaWcuY29zKHRoZXRhLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmltID0gXy5tdWx0aXBseShyLCBfLnRyaWcuc2luKHRoZXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChucmUsIF8ubXVsdGlwbHkoU3ltYm9sLmltYWdpbmFyeSgpLCBuaW0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGFrZSBjYXJlIG9mIHRoZSBzeW1ib2xpYyBwYXJ0XHJcbiAgICAgICAgICAgICAgICByZXN1bHQudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgLy9zaW1waWZseSBzcXJ0XHJcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQuZ3JvdXAgPT09IEZOICYmIHJlc3VsdC5mbmFtZSA9PT0gU1FSVCAmJiAhYklzQ29uc3RhbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHJlc3VsdC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHMubXVsdGlwbHlQb3dlcihuZXcgU3ltYm9sKDAuNSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMubXVsdGlwbGllci5tdWx0aXBseShyZXN1bHQubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5tdWx0aXBseVBvd2VyKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IG0uc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaGFuZGxlIGNhc2VzIHN1Y2ggYXMgKC1hXjMpXigxLzQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZXZlbkZyYWN0aW9uKGIpICYmIHNpZ24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN3YXBlcm9vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHB1dCB0aGUgc2lnbiBiYWNrIG9uIHRoZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXcmFwIGl0IGluIGJyYWNrZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uc3ltZnVuY3Rpb24oUEFSRU5USEVTSVMsIFtyZXN1bHRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgc2lnbiBiYWNrIHRoZSBleHRlcmlvciBhbmQgbGV0IG5lcmRhbWVyIGhhbmRsZSB0aGUgcmVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlwbHlQb3dlcihiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihhSXNDb25zdGFudCAmJiBiSXNDb25zdGFudCAmJiBTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYztcclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNpZ24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIubXVsdGlwbGllci5kZW4uZXF1YWxzKDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBrbm93IHRoYXQgdGhlIG51bWVyYXRvciBoYXMgdG8gYmUgb2RkIGFuZCB0aGVyZWZvcmUgaXQncyBpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbmV3IFN5bWJvbChTZXR0aW5ncy5JTUFHSU5BUlkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzSW50KGIubXVsdGlwbGllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV2ZW4oYi5tdWx0aXBsaWVyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gbmV3IFN5bWJvbCgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZighZXZlbihiLm11bHRpcGxpZXIuZGVuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBTeW1ib2woTWF0aC5wb3coc2lnbiwgYi5tdWx0aXBsaWVyLm51bSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IF8ucG93KF8uc3ltZnVuY3Rpb24oUEFSRU5USEVTSVMsIFtuZXcgU3ltYm9sKHNpZ24pXSksIGIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBTeW1ib2woTWF0aC5wb3coYS5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpLCBiLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXN1bHQgPSBuZXcgU3ltYm9sKE1hdGgyLmJpZ3BvdyhhLm11bHRpcGxpZXIsIGIubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcHV0IHRoZSBiYWNrIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICBpZihjKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLm11bHRpcGx5KHJlc3VsdCwgYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGJJc0ludCAmJiAhbS5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWJzX2IgPSBiLmFicygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgZmFsbCBiYWNrIHRvIEpTIHVudGlsIGJpZyBudW1iZXIgaW1wbGVtZW50YXRpb24gaXMgaW1wcm92ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZihhYnNfYi5ndChTZXR0aW5ncy5NQVhfRVhQKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihiLnNpZ24oKSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbC5pbmZpbml0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBiLm11bHRpcGxpZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZ24gPSBNYXRoLnNpZ24ocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBNYXRoLmFicyhwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBuZXcgRnJhYygxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5udW0gPSBtLm51bS5wb3cocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIuZGVuID0gbS5kZW4ucG93KHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzZ24gPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5pbnZlcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tdWx0aXBseWluZyBpcyBqdXN0aWZpZWQgc2luY2UgYWZ0ZXIgbXVsbHRpcGx5UG93ZXIgaWYgaXQgd2FzIG9mIGdyb3VwIFAgaXQgd2lsbCBub3cgYmUgb2YgZ3JvdXAgTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlwbGllciA9IHJlc3VsdC5tdWx0aXBsaWVyLm11bHRpcGx5KG11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gYS5zaWduKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYi5pc0NvbnN0YW50KCkgJiYgYS5pc0NvbnN0YW50KCkgJiYgIWIubXVsdGlwbGllci5kZW4uZXF1YWxzKDEpICYmIHNpZ24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2Uga25vdyB0aGUgc2lnbiBpcyBuZWdhdGl2ZSBzbyBpZiB0aGUgZGVub21pbmF0b3IgZm9yIGIgPT0gMiB0aGVuIGl0J3MgaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihiLm11bHRpcGxpZXIuZGVuLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBuZXcgU3ltYm9sKFNldHRpbmdzLklNQUdJTkFSWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLm5lZ2F0ZSgpOy8vcmVtb3ZlIHRoZSBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBwb3dlciBpcyBuZWdhdGl2ZSB0aGVuIGkgaXMgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIubmVnYXRlKCk7Ly9yZW1vdmUgdGhlIHNpZ24gZnJvbSB0aGUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHVsbCB0aGUgcG93ZXIgbm9ybWFsbHkgYW5kIHB1dCBiYWNrIHRoZSBpbWFnaW5hcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ubXVsdGlwbHkoXy5wb3coYSwgYiksIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFhID0gYS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWEubXVsdGlwbGllci5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ucG93KF8uc3ltZnVuY3Rpb24oUEFSRU5USEVTSVMsIFtuZXcgU3ltYm9sKHNpZ24pXSksIGIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfLnBvdyhuZXcgU3ltYm9sKGFhLm11bHRpcGxpZXIubnVtKSwgYi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IF8ucG93KG5ldyBTeW1ib2woYWEubXVsdGlwbGllci5kZW4pLCBiLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBfLmRpdmlkZShfYSwgX2IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShyZXN1bHQsIHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIGIuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLzReKGkgKyAyKSA9IGVeKC0gKDIgLSA0IGkpIM+AIG4gKyAoMiArIGkpIGxvZyg0KSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZSA9IGIucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltID0gYi5pbWFncGFydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYoYi5ncm91cCA9PT0gQ1AgJiYgZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleCA9IF8ucG93KGEuY2xvbmUoKSwgcmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhpID0gXy5tdWx0aXBseShfLm11bHRpcGx5KGV4LmNsb25lKCksIHRyaWcuc2luKGltLmNsb25lKCkpKSwgU3ltYm9sLmltYWdpbmFyeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4YSA9IF8ubXVsdGlwbHkodHJpZy5jb3MoaW0pLCBleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLmFkZCh4aSwgeGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWEgPSBhLmNsb25lKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGExID0gXy5wb3coYWEuY2xvbmUoKSwgcmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9nX2EgPSBsb2coYWEuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiMSA9IHRyaWcuY29zKF8ubXVsdGlwbHkoaW0uY2xvbmUoKSwgbG9nX2EpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMxID0gXy5tdWx0aXBseSh0cmlnLnNpbihfLm11bHRpcGx5KGltLCBsb2coYWEpKSksIFN5bWJvbC5pbWFnaW5hcnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ubXVsdGlwbHkoYTEsIF8uYWRkKGIxLCBjMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLmV4cGFuZChfLnBhcnNlKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYiBpcyBhIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVnX251bSA9IGEuZ3JvdXAgPT09IE4gJiYgc2lnbiA8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW0gPSB0ZXN0U1FSVChuZXcgU3ltYm9sKG5lZ19udW0gPyBtLm51bSA6IE1hdGguYWJzKG0ubnVtKSkuc2V0UG93ZXIoYi5jbG9uZSgpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW4gPSB0ZXN0U1FSVChuZXcgU3ltYm9sKG0uZGVuKS5zZXRQb3dlcihiLmNsb25lKCkpLmludmVydCgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZWxpbWluYXRlIGltYWdpbmFyeSBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhLmltYWdpbmFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYklzSW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMsIHAsIG47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IE1hdGguc2lnbihiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gYWJzKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBwICUgNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgU3ltYm9sKGV2ZW4obikgPyAtMSA6IFNldHRpbmdzLklNQUdJTkFSWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobiA9PT0gMCB8fCBzIDwgMCAmJiAobiA9PT0gMSkgfHwgcyA+IDAgJiYgKG4gPT09IDMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc3VtZSBpID0gc3FydCgtMSkgLT4gKC0xKV4oMS8yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuciA9IGIubXVsdGlwbGllci5tdWx0aXBseShGcmFjLnF1aWNrKDEsIDIpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGRlbm9taW5hdG9yIGRlbm90ZXMgdGhlIHBvd2VyIHNvIHJhaXNlIHRvIGl0LiBJdCB3aWxsIHR1cm4gcG9zaXRpdmUgaXQgcm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRuID0gTWF0aC5wb3coLTEsIG5yLm51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZXZlbihuci5kZW4pID8gbmV3IFN5bWJvbCgtMSkuc2V0UG93ZXIobnIsIHRydWUpIDogbmV3IFN5bWJvbCh0bik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9lbnN1cmUgdGhhdCB0aGUgc2lnbiBpcyBjYXJyaWVkIGJ5IHRoZSBzeW1ib2wgYW5kIG5vdCB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgZW5hYmxlcyB1cyB0byBjaGVjayBkb3duIHRoZSBsaW5lIGlmIHRoZSBtdWx0aXBsaWVyIGNhbiBpbmRlZWQgYmUgdHJhbnNmZXJyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lnbiA8IDAgJiYgIW5lZ19udW0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JldGFpbiB0aGUgYWJzb2x1dGUgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYklzQ29uc3RhbnQgJiYgYS5ncm91cCAhPT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVuciA9IGV2ZW4oYi5tdWx0aXBsaWVyLmRlbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW5wID0gZXZlbihhLnBvd2VyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHJlc3VsdC5wb3dlci50b0RlY2ltYWwoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbm5wID0gZXZlbihuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV2ZW5yICYmIGV2ZW5wICYmICFldmVubnApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihuID09PSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLnN5bWZ1bmN0aW9uKEFCUywgW3Jlc3VsdF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoIWlzSW50KG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gcmVzdWx0LnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLnN5bWZ1bmN0aW9uKEFCUywgW3Jlc3VsdC50b0xpbmVhcigpXSkuc2V0UG93ZXIocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLm11bHRpcGx5KF8uc3ltZnVuY3Rpb24oQUJTLCBbcmVzdWx0LmNsb25lKCkudG9MaW5lYXIoKV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbG9uZSgpLnNldFBvd2VyKG5ldyBGcmFjKG4gLSAxKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3F1aWNrIHdvcmthcm91bmQuIFJldmlzaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QT1NJVElWRV9NVUxUSVBMSUVSUyAmJiByZXN1bHQuZm5hbWUgPT09IEFCUylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tdWx0aXBseSBvdXQgc3FydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihiLmVxdWFscygyKSAmJiByZXN1bHQuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3Jlc3VsdCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZWFjaChmdW5jdGlvbiAoc3ltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdCA9IF8ubXVsdGlwbHkoX3Jlc3VsdCwgXy5wb3coc3ltLCBiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGVzdFNRUlQocmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBtdWx0aXBseSB1bnRpbCB3ZSd2ZSB0ZXN0ZWQgdGhlIHJlbWFpbmluZyBzeW1ib2xcclxuICAgICAgICAgICAgICAgIGlmKG51bSAmJiBkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLm11bHRpcGx5KHJlc3VsdCwgdGVzdFBvdyhfLm11bHRpcGx5KG51bSwgZGVuKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlZHVjZSBzcXVhcmUgcm9vdFxyXG4gICAgICAgICAgICAgICAgaWYocmVzdWx0LmZuYW1lID09PSBTUVJUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRVggPSByZXN1bHQuZ3JvdXAgPT09IEVYO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaXNFWCA/IHJlc3VsdC5wb3dlci5tdWx0aXBsaWVyLnRvU3RyaW5nKCkgOiByZXN1bHQucG93ZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihldmVuKHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwdCA9IGlzRVggPyBfLmRpdmlkZShyZXN1bHQucG93ZXIsIG5ldyBTeW1ib2woMikpIDogbmV3IFN5bWJvbChyZXN1bHQucG93ZXIuZGl2aWRlKG5ldyBGcmFjKDIpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHJlc3VsdC5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLnBvdyhyZXN1bHQuYXJnc1swXSwgcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlwbGllciA9IHJlc3VsdC5tdWx0aXBsaWVyLm11bHRpcGx5KG0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERldGVjdCBFdWxlcidzIGlkZW50aXR5XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKCFTZXR0aW5ncy5JR05PUkVfRSAmJiByZXN1bHQuaXNFKCkgJiYgcmVzdWx0Lmdyb3VwID09PSBFWCAmJiByZXN1bHQucG93ZXIuY29udGFpbnMoJ3BpJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcmVzdWx0LnBvd2VyLmNvbnRhaW5zKFNldHRpbmdzLklNQUdJTkFSWSkgJiYgYi5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBiLnN0cmlwVmFyKFNldHRpbmdzLklNQUdJTkFSWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5hZGQodHJpZy5jb3ModGhldGEpLCBfLm11bHRpcGx5KFN5bWJvbC5pbWFnaW5hcnkoKSwgdHJpZy5zaW4odGhldGEpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKGEpICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBhLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wb3coeCwgYi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNNYXRyaXgoYSkgJiYgYklzU3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYS5lYWNoRWxlbWVudChmdW5jdGlvbiAoeCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBfLnBvdyh4LCBiLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gTTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYUlzU3ltYm9sICYmIGlzTWF0cml4KGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5lYWNoRWxlbWVudChmdW5jdGlvbiAoeCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBfLnBvdyhhLmNsb25lKCksIHgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gTTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZXRzIGNhbGxlZCB3aGVuIHRoZSBwYXJzZXIgZmluZHMgdGhlICwgb3BlcmF0b3IuXHJcbiAgICAgICAgLy8gQ29tbWFzIHJldHVybiBhIENvbGxlY3RvciBvYmplY3Qgd2hpY2ggaXMgcm91Z2hseSBhbiBhcnJheVxyXG4gICAgICAgIHRoaXMuY29tbWEgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZighKGEgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSlcclxuICAgICAgICAgICAgICAgIGEgPSBDb2xsZWN0aW9uLmNyZWF0ZShhKTtcclxuICAgICAgICAgICAgYS5hcHBlbmQoYik7XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gTGluayB0byBtb2R1bHVzXHJcbiAgICAgICAgdGhpcy5tb2QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kKGEsIGIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVXNlZCB0byBzbGljZSBlbGVtZW50cyBmcm9tIGFycmF5c1xyXG4gICAgICAgIHRoaXMuc2xpY2UgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGEsIGIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gVGhlIGVxdWFsaXR5IHNldHRlclxyXG4gICAgICAgIHRoaXMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgLy8gRXF1YWxpdHkgY2FuIG9ubHkgYmUgc2V0IGZvciBncm91cCBTIHNvIGNvbXBsYWluIGl0J3Mgbm90XHJcbiAgICAgICAgICAgIGlmKGEuZ3JvdXAgIT09IFMgJiYgIWEuaXNMaW5lYXIoKSlcclxuICAgICAgICAgICAgICAgIGVycignQ2Fubm90IHNldCBlcXVhbGl0eSBmb3IgJyArIGEudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIFZBUlNbYS52YWx1ZV0gPSBiLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gUGVyY2VudFxyXG4gICAgICAgIHRoaXMucGVyY2VudCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShhLCBuZXcgU3ltYm9sKDEwMCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU2V0IHZhcmlhYmxlXHJcbiAgICAgICAgdGhpcy5hc3NpZ24gPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZihhIGluc3RhbmNlb2YgQ29sbGVjdGlvbiAmJiBiIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgYS5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5hc3NpZ24oeCwgYi5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3IuZnJvbUFycmF5KGIuZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGEucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJdCdzIHJlZmVycmluZyB0byB0aGUgcGFyZW50IGluc3RlYWQuIFRoZSBjdXJyZW50IGl0ZW0gY2FuIGJlIGRpc2NhcmRlZFxyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBhLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGUuZWxlbWVudHNbZS5nZXR0ZXJdID0gYjtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlLmdldHRlcjtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihhLmdyb3VwICE9PSBTKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5lcmRhbWVyVmFsdWVFcnJvcignQ2Fubm90IGNvbXBsZXRlIG9wZXJhdGlvbi4gSW5jb3JyZWN0IExIIHZhbHVlIGZvciAnICsgYSk7XHJcbiAgICAgICAgICAgIFZBUlNbYS52YWx1ZV0gPSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZnVuY3Rpb25fYXNzaWduID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGYgPSBhLmVsZW1lbnRzLnBvcCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0RnVuY3Rpb24oZiwgYS5lbGVtZW50cywgYik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBGdW5jdGlvbiB0byBxdWlja2x5IGNvbnZlcnQgYm9vbHMgdG8gU3ltYm9sc1xyXG4gICAgICAgIHZhciBib29sMlN5bWJvbCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKHggPT09IHRydWUgPyAxIDogMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL2NoZWNrIGZvciBlcXVhbGl0eVxyXG4gICAgICAgIHRoaXMuZXEgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYm9vbDJTeW1ib2woYS5lcXVhbHMoYikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9jaGVja3MgZm9yIGdyZWF0ZXIgdGhhblxyXG4gICAgICAgIHRoaXMuZ3QgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYm9vbDJTeW1ib2woYS5ndChiKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL2NoZWNrcyBmb3IgZ3JlYXRlciB0aGFuIGVxdWFsXHJcbiAgICAgICAgdGhpcy5ndGUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYm9vbDJTeW1ib2woYS5ndGUoYikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9jaGVja3MgZm9yIGxlc3MgdGhhblxyXG4gICAgICAgIHRoaXMubHQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYm9vbDJTeW1ib2woYS5sdChiKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL2NoZWNrcyBmb3IgbGVzcyB0aGFuIGVxdWFsXHJcbiAgICAgICAgdGhpcy5sdGUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYm9vbDJTeW1ib2woYS5sdGUoYikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gd3JhcHMgdGhlIGZhY3RvcmlhbFxyXG4gICAgICAgIHRoaXMuZmFjdG9yaWFsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltZnVuY3Rpb24oRkFDVE9SSUFMLCBbYV0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gd3JhcHMgdGhlIGRvdWJsZSBmYWN0b3JpYWxcclxuICAgICAgICB0aGlzLmRmYWN0b3JpYWwgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW1mdW5jdGlvbihET1VCTEVGQUNUT1JJQUwsIFthXSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIDtcclxuXHJcbiAgICAvKiBcIlNUQVRJQ1wiICovXHJcbiAgICAvLyBjb252ZXJ0cyBhIG51bWJlciB0byBhIGZyYWN0aW9uLlxyXG4gICAgdmFyIEZyYWN0aW9uID0ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgZGVjaW1hbCB0byBhIGZyYWN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHNcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgZGVub21pbmF0b3IgYW5kIHRoZSBudW1lcmF0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbiAodmFsdWUsIG9wdHMpIHtcclxuICAgICAgICAgICAgdmFyIGZyYWM7XHJcbiAgICAgICAgICAgIGlmKHZhbHVlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFjID0gWzAsIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYodmFsdWUgPCAxZS02IHx8IHZhbHVlID4gMWUyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxYyA9IHRoaXMucXVpY2tDb252ZXJzaW9uKE51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHFjWzFdIDw9IDFlMjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWx1ZSAvIGFicztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhYyA9IHRoaXMuZnVsbENvbnZlcnNpb24oYWJzLnRvRml4ZWQoKHFjWzFdICsgJycpLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhY1swXSA9IGZyYWNbMF0gKiBzaWduO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhYyA9IHFjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWMgPSB0aGlzLmZ1bGxDb252ZXJzaW9uKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZnJhYztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBmcmFjdGlvbiBpcyB0b28gc21hbGwgb3IgdG9vIGxhcmdlIHRoaXMgZ2V0cyBjYWxsZWQgaW5zdGVhZCBvZiBmdWxsQ29udmVyc2lvbiBtZXRob2RcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVjXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSAtIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRlbm9taW5hdG9yIGFuZCB0aGUgbnVtZXJhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcXVpY2tDb252ZXJzaW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHN0cmlwU2lnbiA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGVseSBjb252ZXJ0IHRvIGEgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgcyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzaWduID0gJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFuZCBzdG9yZSB0aGUgc2lnblxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcy5jaGFyQXQoMCk7XHJcbiAgICAgICAgICAgICAgICBpZihzdGFydCA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMuc3Vic3RyKDEsIHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdGFydCA9PT0gJysnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCByZW1vdmUgdGhlIHBsdXMgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cigxLCBzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBzaWduOiBzaWduLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnQodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0ZWx5IGNvbnZlcnQgdG8gYSBkZWNpbWFsXHJcbiAgICAgICAgICAgICAgICBpZihTY2llbnRpZmljLmlzU2NpZW50aWZpYyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNjaWVudGlmaWNUb0RlY2ltYWwodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IHRoZSB2YWx1ZSBpbnRvIHRoZSBzaWduIGFuZCB0aGUgdmFsdWVcclxuICAgICAgICAgICAgICAgIHZhciBucGFydHMgPSBzdHJpcFNpZ24odmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IGl0IGF0IHRoZSBkZWNpbWFsLiBXZSdsbCByZWZlciB0byBpdCBhcyB0aGUgY29lZmZpZW50IHBhcnRzXHJcbiAgICAgICAgICAgICAgICB2YXIgY3BhcnRzID0gbnBhcnRzLnZhbHVlLnNwbGl0KCcuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tYmluZSB0aGUgZW50aXJlIG51bWJlciBieSByZW1vdmluZyBsZWFkaW5nIHplcm8gYW5kIGFkZGluZyB0aGUgZGVjaW1hbCBwYXJ0XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdvdWxkIGJlIHRlaCBzYW1lIGFzIG1vdmluZyB0aGUgZGVjaW1hbCBwb2ludCB0byB0aGUgZW5kXHJcbiAgICAgICAgICAgICAgICB2YXIgbnVtO1xyXG4gICAgICAgICAgICAgICAgLy8gV2UncmUgZGVhbGluZyB3aXRoIGludGVnZXJzXHJcbiAgICAgICAgICAgICAgICBpZihjcGFydHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gY3BhcnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gY3BhcnRzWzBdICsgY3BhcnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBjcGFydHNbMV0gPyBjcGFydHNbMV0ubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSBwYWRkaW5nIGZvciB0aGUgemVyb3NcclxuICAgICAgICAgICAgICAgIHZhciBkZW4gPSBgMSR7JzAnLnJlcGVhdChuKX1gO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKG51bSAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtID0gbnVtLnJlcGxhY2UoL14wKy8sICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBbbnBhcnRzLnNpZ24gKyBudW0sIGRlbl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0KHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBnb29kIGFwcHJveGltYXRpb24gb2YgYSBmcmFjdGlvbi4gVGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgYnkgY29udmVydFxyXG4gICAgICAgICAqIGh0dHA6Ly9tYXRoZm9ydW0ub3JnL2xpYnJhcnkvZHJtYXRoL3ZpZXcvNjE3NzIuaHRtbFxyXG4gICAgICAgICAqIERlY2ltYWwgVG8gRnJhY3Rpb24gQ29udmVyc2lvbiAtIEEgU2ltcGxlciBWZXJzaW9uXHJcbiAgICAgICAgICogRHIgUGV0ZXJzb25cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVjXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSAtIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRlbm9taW5hdG9yIGFuZCB0aGUgbnVtZXJhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVsbENvbnZlcnNpb246IGZ1bmN0aW9uIChkZWMpIHtcclxuICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8geW91IGNhbiBhZGp1c3QgdGhlIGVwc2lsb24gdG8gYSBsYXJnZXIgbnVtYmVyIGlmIHlvdSBkb24ndCBuZWVkIHZlcnkgaGlnaCBwcmVjaXNpb25cclxuICAgICAgICAgICAgdmFyIG4xID0gMCwgZDEgPSAxLCBuMiA9IDEsIGQyID0gMCwgbiA9IDAsIHEgPSBkZWMsIGVwc2lsb24gPSAxZS0xNjtcclxuICAgICAgICAgICAgd2hpbGUoIWRvbmUpIHtcclxuICAgICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICAgIGlmKG4gPiAxMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBNYXRoLmZsb29yKHEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IG4xICsgYSAqIG4yO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbiA9IGQxICsgYSAqIGQyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSAocSAtIGEpO1xyXG4gICAgICAgICAgICAgICAgaWYoZSA8IGVwc2lsb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHEgPSAxIC8gZTtcclxuICAgICAgICAgICAgICAgIG4xID0gbjI7XHJcbiAgICAgICAgICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgICAgICAgICAgbjIgPSBudW07XHJcbiAgICAgICAgICAgICAgICBkMiA9IGRlbjtcclxuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKG51bSAvIGRlbiAtIGRlYykgPCBlcHNpbG9uIHx8IG4gPiAzMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbbnVtLCBkZW5dO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvL0RlcGVuZHMgb24gRnJhY3Rpb25cclxuXHJcbiAgICAvL1RoZSBsYXRleCBnZW5lcmF0b3JcclxuICAgIHZhciBMYVRlWCA9IHtcclxuICAgICAgICBwYXJzZXI6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHBhcnNlciBhbmQgc3RyaXAgaXQgZnJvbSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgaXRlbXMgdGhhdCB5b3UgbmVlZFxyXG4gICAgICAgICAgICB2YXIga2VlcCA9IFsnY2xhc3NlcycsICdzZXRPcGVyYXRvcicsICdnZXRPcGVyYXRvcnMnLCAnZ2V0QnJhY2tldHMnLCAndG9rZW5pemUnLCAndG9SUE4nLCAndHJlZScsICd1bml0cyddO1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcigpO1xyXG4gICAgICAgICAgICBmb3IodmFyIHggaW4gcGFyc2VyKSB7XHJcbiAgICAgICAgICAgICAgICBpZihrZWVwLmluZGV4T2YoeCkgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJzZXJbeF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZGVjbGFyZSB0aGUgb3BlcmF0b3JzXHJcbiAgICAgICAgICAgIHBhcnNlci5zZXRPcGVyYXRvcih7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiA4LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdcXFxcJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3NsYXNoJyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlOyAvLyBieXBhc3MgdGhlIHNsYXNoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwYXJzZXIuc2V0T3BlcmF0b3Ioe1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogOCxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnXFxcXCwnLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnc2xhc2hfY29tbWEnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7IC8vIGJ5cGFzcyB0aGUgc2xhc2hcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIGhhdmUgYnJhY2VzIG5vdCBtYXAgdG8gYW55dGhpbmcuIFdlIHdhbnQgdGhlbSB0byBiZSByZXR1cm4gYXMtaXNcclxuICAgICAgICAgICAgdmFyIGJyYWNrZXRzID0gcGFyc2VyLmdldEJyYWNrZXRzKCk7XHJcbiAgICAgICAgICAgIGJyYWNrZXRzWyd7J10ubWFwc190byA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcclxuICAgICAgICB9KSgpLFxyXG4gICAgICAgIHNwYWNlOiAnficsXHJcbiAgICAgICAgZG90OiAnIFxcXFxjZG90ICcsXHJcbiAgICAgICAgLy8gZ3JhYiBhIGxpc3Qgb2Ygc3VwcG9ydGVkIGZ1bmN0aW9ucyBidXQgcmVtb3ZlIHRoZSBleGNsdWRlZCBvbmVzIGZvdW5kIGluIGV4Y2xGTlxyXG5cclxuICAgICAgICBsYXRleDogZnVuY3Rpb24gKHN5bWJvbCwgb3B0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vIGl0IG1pZ2h0IGJlIGFuIGFycmF5XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5jbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLmNsb25lKCk7IC8vIGxlYXZlIG9yaWdpbmFsIGFzLWlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc3ltYm9sIGluc3RhbmNlb2YgXy5jbGFzc2VzLkNvbGxlY3Rpb24pXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuZWxlbWVudHM7XHJcblxyXG4gICAgICAgICAgICBpZihpc0FycmF5KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBMYVRlWEFycmF5ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ltYm9sLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IHN5bWJvbFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAvL1RoaXMgd2F5IEkgY2FuIGdlbmVyYXRlIExhVGVYIG9uIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWlzU3ltYm9sKHN5bSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bSA9IF8ucGFyc2Uoc3ltKTtcclxuICAgICAgICAgICAgICAgICAgICBMYVRlWEFycmF5LnB1c2godGhpcy5sYXRleChzeW0sIG9wdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnJhY2tldHMoTGFUZVhBcnJheS5qb2luKCcsICcpLCAnc3F1YXJlJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsc2UgaWYoaXNNYXRyaXgoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIFRlWCA9ICdcXFxcYmVnaW57cG1hdHJpeH1cXG4nO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbC5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dUZVggPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBzeW1ib2wuZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGUubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93VGVYLnB1c2godGhpcy5sYXRleChlW2pdLCBvcHRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgVGVYICs9IHJvd1RlWC5qb2luKCcgJiAnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihpIDwgc3ltYm9sLmVsZW1lbnRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVGVYICs9ICdcXFxcXFxcXFxcbic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgVGVYICs9ICdcXFxcZW5ke3BtYXRyaXh9JztcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZVg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsc2UgaWYoaXNWZWN0b3Ioc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIFRlWCA9ICdcXFxcbGVmdFsnO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbC5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIFRlWCArPSB0aGlzLmxhdGV4KHN5bWJvbC5lbGVtZW50c1tpXSwgb3B0aW9uKSArICcgJyArIChpICE9PSBzeW1ib2wuZWxlbWVudHMubGVuZ3RoIC0gMSA/ICcsXFxcXCwnIDogJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgVGVYICs9ICdcXFxccmlnaHRdJztcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZVg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsc2UgaWYoaXNTZXQoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIFRlWCA9ICdcXFxceyc7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3ltYm9sLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVGVYICs9IHRoaXMubGF0ZXgoc3ltYm9sLmVsZW1lbnRzW2ldLCBvcHRpb24pICsgJyAnICsgKGkgIT09IHN5bWJvbC5lbGVtZW50cy5sZW5ndGggLSAxID8gJyxcXFxcLCcgOiAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBUZVggKz0gJ1xcXFx9JztcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZVg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRlY2ltYWwgPSAob3B0aW9uID09PSAnZGVjaW1hbCcgfHwgb3B0aW9uID09PSAnZGVjaW1hbHMnKSxcclxuICAgICAgICAgICAgICAgICAgICBwb3dlciA9IHN5bWJvbC5wb3dlcixcclxuICAgICAgICAgICAgICAgICAgICBpbnZlcnQgPSBpc05lZ2F0aXZlKHBvd2VyKSxcclxuICAgICAgICAgICAgICAgICAgICBuZWdhdGl2ZSA9IHN5bWJvbC5tdWx0aXBsaWVyLmxlc3NUaGFuKDApO1xyXG5cclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBQICYmIGRlY2ltYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcoc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkgKiBNYXRoLnBvdyhzeW1ib2wudmFsdWUsIHN5bWJvbC5wb3dlci50b0RlY2ltYWwoKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIgPSBzeW1ib2wubXVsdGlwbGllci5hYnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdXNlciB3YW50cyB0aGUgcmVzdWx0IGluIGRlY2ltYWwgZm9ybWF0IHRoZW4gcmV0dXJuIGl0IGFzIHN1Y2ggYnkgcGxhY2luZyBpdCBhdCB0aGUgdG9wIHBhcnRcclxuICAgICAgICAgICAgICAgIHZhciBtX2FycmF5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGRlY2ltYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IFN0cmluZyhzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYoU3RyaW5nKG0pID09PSAnMScgJiYgIWRlY2ltYWwpIG0gPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBtX2FycmF5ID0gW20sICcnXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1fYXJyYXkgPSBbc3ltYm9sLm11bHRpcGxpZXIubnVtLCBzeW1ib2wubXVsdGlwbGllci5kZW5dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSBhcyBhIHR3byBwYXJ0IGFycmF5XHJcbiAgICAgICAgICAgICAgICB2YXIgdl9hcnJheSA9IHRoaXMudmFsdWUoc3ltYm9sLCBpbnZlcnQsIG9wdGlvbiwgbmVnYXRpdmUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBpdCBhbGwgcG9zaXRpdmUgc2luY2Ugd2Uga25vdyB3aGV0aGVyIHRvIHB1c2ggdGhlIHBvd2VyIHRvIHRoZSBudW1lcmF0b3Igb3IgZGVub21pbmF0b3IgYWxyZWFkeS5cclxuICAgICAgICAgICAgICAgIGlmKGludmVydClcclxuICAgICAgICAgICAgICAgICAgICBwb3dlci5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBwb3dlciBpcyBzaW1wbGUgc2luY2UgaXQgcmVxdWlyZXMgbm8gYWRkaXRpb25hbCBmb3JtYXR0aW5nLiBXZSBjYW4gZ2V0IGl0IHRvIGFcclxuICAgICAgICAgICAgICAgIC8vIHN0cmluZyByaWdodCBhd2F5LiBwYXNzIGluIHRydWUgdG8gbmVnbGVjdCB1bml0IHBvd2Vyc1xyXG4gICAgICAgICAgICAgICAgaWYoZGVjaW1hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBpc1N5bWJvbChwb3dlcikgPyBMYVRlWC5sYXRleChwb3dlciwgb3B0aW9uKSA6IFN0cmluZyhwb3dlci50b0RlY2ltYWwoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoU3RyaW5nKHApID09PSAnMScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgbGF0ZXggcmVwcmVzZW50YXRpb25cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNTeW1ib2wocG93ZXIpKVxyXG4gICAgICAgICAgICAgICAgICAgIHAgPSB0aGlzLmxhdGV4KHBvd2VyLCBvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGl0IGFzIGEgZnJhY3Rpb25cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5mb3JtYXRGcmFjKHBvd2VyLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGlzIGFycmF5IHRvIHNwZWNpZnkgaWYgdGhlIHBvd2VyIGlzIGdldHRpbmcgYXR0YWNoZWQgdG8gdGhlIHRvcCBvciB0aGUgYm90dG9tXHJcbiAgICAgICAgICAgICAgICB2YXIgcF9hcnJheSA9IFsnJywgJyddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGljayBpdCB0byB0aGUgdG9wIG9yIHRoZSBib3R0b20uIElmIGl0J3MgbmVnYXRpdmUgdGhlbiB0aGUgcG93ZXIgZ2V0cyBwbGFjZWQgb24gdGhlIGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGludmVydCA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgcF9hcnJheVtpbmRleF0gPSBwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBncm91cCBQIGFuZCBkZWNpbWFsXHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gKG5lZ2F0aXZlID8gJy0nIDogJycpICsgdGhpcy5zZXQobV9hcnJheSwgdl9hcnJheSwgcF9hcnJheSwgc3ltYm9sLmdyb3VwID09PSBDQik7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbC5yZXBsYWNlKC9cXCtcXC0vZ2ksICctJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBncmVlayBtYXBwaW5nXHJcbiAgICAgICAgZ3JlZWs6IHtcclxuICAgICAgICAgICAgYWxwaGE6ICdcXFxcYWxwaGEnLFxyXG4gICAgICAgICAgICBiZXRhOiAnXFxcXGJldGEnLFxyXG4gICAgICAgICAgICBnYW1tYTogJ1xcXFxnYW1tYScsXHJcbiAgICAgICAgICAgIGRlbHRhOiAnXFxcXGRlbHRhJyxcclxuICAgICAgICAgICAgZXBzaWxvbjogJ1xcXFxlcHNpbG9uJyxcclxuICAgICAgICAgICAgemV0YTogJ1xcXFx6ZXRhJyxcclxuICAgICAgICAgICAgZXRhOiAnXFxcXGV0YScsXHJcbiAgICAgICAgICAgIHRoZXRhOiAnXFxcXHRoZXRhJyxcclxuICAgICAgICAgICAgaW90YTogJ1xcXFxpb3RhJyxcclxuICAgICAgICAgICAga2FwcGE6ICdcXFxca2FwcGEnLFxyXG4gICAgICAgICAgICBsYW1iZGE6ICdcXFxcbGFtYmRhJyxcclxuICAgICAgICAgICAgbXU6ICdcXFxcbXUnLFxyXG4gICAgICAgICAgICBudTogJ1xcXFxudScsXHJcbiAgICAgICAgICAgIHhpOiAnXFxcXHhpJyxcclxuICAgICAgICAgICAgb21uaWtyb246ICdcXFxcb21uaWtyb24nLFxyXG4gICAgICAgICAgICBwaTogJ1xcXFxwaScsXHJcbiAgICAgICAgICAgIHJobzogJ1xcXFxyaG8nLFxyXG4gICAgICAgICAgICBzaWdtYTogJ1xcXFxzaWdtYScsXHJcbiAgICAgICAgICAgIHRhdTogJ1xcXFx0YXUnLFxyXG4gICAgICAgICAgICB1cHNpbG9uOiAnXFxcXHVwc2lsb24nLFxyXG4gICAgICAgICAgICBwaGk6ICdcXFxccGhpJyxcclxuICAgICAgICAgICAgY2hpOiAnXFxcXGNoaScsXHJcbiAgICAgICAgICAgIHBzaTogJ1xcXFxwc2knLFxyXG4gICAgICAgICAgICBvbWVnYTogJ1xcXFxvbWVnYScsXHJcbiAgICAgICAgICAgIEdhbW1hOiAnXFxcXEdhbW1hJyxcclxuICAgICAgICAgICAgRGVsdGE6ICdcXFxcRGVsdGEnLFxyXG4gICAgICAgICAgICBFcHNpbG9uOiAnXFxcXEVwc2lsb24nLFxyXG4gICAgICAgICAgICBUaGV0YTogJ1xcXFxUaGV0YScsXHJcbiAgICAgICAgICAgIExhbWJkYTogJ1xcXFxMYW1iZGEnLFxyXG4gICAgICAgICAgICBYaTogJ1xcXFxYaScsXHJcbiAgICAgICAgICAgIFBpOiAnXFxcXFBpJyxcclxuICAgICAgICAgICAgU2lnbWE6ICdcXFxcU2lnbWEnLFxyXG4gICAgICAgICAgICBQaGk6ICdcXFxcUGhpJyxcclxuICAgICAgICAgICAgUHNpOiAnXFxcXFBzaScsXHJcbiAgICAgICAgICAgIE9tZWdhOiAnXFxcXE9tZWdhJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3ltYm9sczoge1xyXG4gICAgICAgICAgICBhcmNjb3M6ICdcXFxcYXJjY29zJyxcclxuICAgICAgICAgICAgY29zOiAnXFxcXGNvcycsXHJcbiAgICAgICAgICAgIGNzYzogJ1xcXFxjc2MnLFxyXG4gICAgICAgICAgICBleHA6ICdcXFxcZXhwJyxcclxuICAgICAgICAgICAga2VyOiAnXFxcXGtlcicsXHJcbiAgICAgICAgICAgIGxpbXN1cDogJ1xcXFxsaW1zdXAnLFxyXG4gICAgICAgICAgICBtaW46ICdcXFxcbWluJyxcclxuICAgICAgICAgICAgc2luaDogJ1xcXFxzaW5oJyxcclxuICAgICAgICAgICAgYXJjc2luOiAnXFxcXGFyY3NpbicsXHJcbiAgICAgICAgICAgIGNvc2g6ICdcXFxcY29zaCcsXHJcbiAgICAgICAgICAgIGRlZzogJ1xcXFxkZWcnLFxyXG4gICAgICAgICAgICBnY2Q6ICdcXFxcZ2NkJyxcclxuICAgICAgICAgICAgbGc6ICdcXFxcbGcnLFxyXG4gICAgICAgICAgICBsbjogJ1xcXFxsbicsXHJcbiAgICAgICAgICAgIFByOiAnXFxcXFByJyxcclxuICAgICAgICAgICAgc3FydDogJ1xcXFxzcXJ0JyxcclxuICAgICAgICAgICAgc3VwOiAnXFxcXHN1cCcsXHJcbiAgICAgICAgICAgIGFyY3RhbjogJ1xcXFxhcmN0YW4nLFxyXG4gICAgICAgICAgICBjb3Q6ICdcXFxcY290JyxcclxuICAgICAgICAgICAgZGV0OiAnXFxcXGRldCcsXHJcbiAgICAgICAgICAgIGhvbTogJ1xcXFxob20nLFxyXG4gICAgICAgICAgICBsaW06ICdcXFxcbGltJyxcclxuICAgICAgICAgICAgbG9nOiAnXFxcXGxvZycsXHJcbiAgICAgICAgICAgIExOOiAnXFxcXExOJyxcclxuICAgICAgICAgICAgc2VjOiAnXFxcXHNlYycsXHJcbiAgICAgICAgICAgIHRhbjogJ1xcXFx0YW4nLFxyXG4gICAgICAgICAgICBhcmc6ICdcXFxcYXJnJyxcclxuICAgICAgICAgICAgY290aDogJ1xcXFxjb3RoJyxcclxuICAgICAgICAgICAgZGltOiAnXFxcXGRpbScsXHJcbiAgICAgICAgICAgIGluZjogJ1xcXFxpbmYnLFxyXG4gICAgICAgICAgICBsaW1pbmY6ICdcXFxcbGltaW5mJyxcclxuICAgICAgICAgICAgbWF4OiAnXFxcXG1heCcsXHJcbiAgICAgICAgICAgIHNpbjogJ1xcXFxzaW4nLFxyXG4gICAgICAgICAgICB0YW5oOiAnXFxcXHRhbmgnXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBnZXQgdGhlIHJhdyB2YWx1ZSBvZiB0aGUgc3ltYm9sIGFzIGFuIGFycmF5XHJcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzeW1ib2wsIGludmVydGVkLCBvcHRpb24sIG5lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IHN5bWJvbC5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0dyb3VwID0gc3ltYm9sLnByZXZpb3VzR3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IFsnJywgJyddLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaW52ZXJ0ZWQgPyAxIDogMDtcclxuICAgICAgICAgICAgLyppZihncm91cCA9PT0gTikgLy8gZG8gbm90aGluZyBzaW5jZSB3ZSB3YW50IHRvIHJldHVybiB0b3AgJiBib3R0b20gYmxhbms7ICovXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5pc0luZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcaW5mdHknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IFMgfHwgZ3JvdXAgPT09IFAgfHwgcHJldmlvdXNHcm91cCA9PT0gUyB8fCBwcmV2aW91c0dyb3VwID09PSBQIHx8IHByZXZpb3VzR3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZm9ybWF0U3Vic2NyaXB0cyhzeW1ib2wudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYodmFsdWUucmVwbGFjZSlcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyguKylfJC8sICckMVxcXFxfJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBpdCBzbyB3ZSBjYW4gY2hlY2sgZm9yIGluc3RhbmNlcyBvZiBhbHBoYSBhcyB3ZWxsIGFzIGFscGhhX2JcclxuICAgICAgICAgICAgICAgIHZhciB0X3ZhcnJheSA9IFN0cmluZyh2YWx1ZSkuc3BsaXQoJ18nKTtcclxuICAgICAgICAgICAgICAgIHZhciBncmVlayA9IHRoaXMuZ3JlZWtbdF92YXJyYXlbMF1dO1xyXG4gICAgICAgICAgICAgICAgaWYoZ3JlZWspIHtcclxuICAgICAgICAgICAgICAgICAgICB0X3ZhcnJheVswXSA9IGdyZWVrO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdF92YXJyYXkuam9pbignXycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHRoaXMuc3ltYm9sc1t0X3ZhcnJheVswXV07XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB0X3ZhcnJheVswXSA9IHN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRfdmFycmF5LmpvaW4oJ18nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihncm91cCA9PT0gRk4gfHwgcHJldmlvdXNHcm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbmFtZSA9IHN5bWJvbC5mbmFtZTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgdGhlIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbC5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzW2ldLCBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5sYXRleChhcmcsIG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZm5hbWUgPT09IFNRUlQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcc3FydCcgKyB0aGlzLmJyYWNlcyhpbnB1dC5qb2luKCcsJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gQUJTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSB0aGlzLmJyYWNrZXRzKGlucHV0LmpvaW4oJywnKSwgJ2FicycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gUEFSRU5USEVTSVMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9IHRoaXMuYnJhY2tldHMoaW5wdXQuam9pbignLCcpLCAncGFyZW5zJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnbGltaXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnIFxcXFxsaW1cXFxcbGltaXRzX3snICsgaW5wdXRbMV0gKyAnIFxcXFx0byAnICsgaW5wdXRbMl0gKyAnfSAnICsgaW5wdXRbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnaW50ZWdyYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gJ1xcXFxpbnQnICsgdGhpcy5icmFjZXMoaW5wdXRbMF0pICsgdGhpcy5icmFjZXMoJ2QnICsgaW5wdXRbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2RlZmludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcaW50XFxcXGxpbWl0c18nICsgdGhpcy5icmFjZXMoaW5wdXRbMV0pICsgJ14nICsgdGhpcy5icmFjZXMoaW5wdXRbMl0pICsgJyAnICsgaW5wdXRbMF0gKyAnIGQnICsgaW5wdXRbM107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSBGQUNUT1JJQUwgfHwgZm5hbWUgPT09IERPVUJMRUZBQ1RPUklBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBzeW1ib2wuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhcmcucG93ZXIuZXF1YWxzKDEpICYmIChhcmcuaXNDb21wb3NpdGUoKSB8fCBhcmcuaXNDb21iaW5hdGlvbigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFswXSA9IHRoaXMuYnJhY2tldHMoaW5wdXRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9IGlucHV0WzBdICsgKGZuYW1lID09PSBGQUNUT1JJQUwgPyAnIScgOiAnISEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdmbG9vcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcbGVmdCBcXFxcbGZsb29yJyArIHRoaXMuYnJhY2VzKGlucHV0WzBdKSArICdcXFxccmlnaHQgXFxcXHJmbG9vcic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnY2VpbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcbGVmdCBcXFxcbGNlaWwnICsgdGhpcy5icmFjZXMoaW5wdXRbMF0pICsgJ1xcXFxyaWdodCBcXFxccmNlaWwnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZSBsb2coYSwgYilcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IFNldHRpbmdzLkxPRyAmJiBpbnB1dC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXG1hdGhybScgKyB0aGlzLmJyYWNlcyhTZXR0aW5ncy5MT0cpICsgJ18nICsgdGhpcy5icmFjZXMoaW5wdXRbMV0pICsgdGhpcy5icmFja2V0cyhpbnB1dFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIGxvZyhhLCBiKVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gU2V0dGluZ3MuTE9HMTApIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcbWF0aHJtJyArIHRoaXMuYnJhY2VzKFNldHRpbmdzLkxPRykgKyAnXycgKyB0aGlzLmJyYWNlcygxMCkgKyB0aGlzLmJyYWNrZXRzKGlucHV0WzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdzdW0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpbnB1dFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBpbnB1dFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBpbnB1dFsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBpbnB1dFszXTtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcc3VtXFxcXGxpbWl0c197JyArIHRoaXMuYnJhY2VzKGIpICsgJz0nICsgdGhpcy5icmFjZXMoYykgKyAnfV4nICsgdGhpcy5icmFjZXMoZCkgKyAnICcgKyB0aGlzLmJyYWNlcyhhKSArICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ3Byb2R1Y3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBpbnB1dFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBpbnB1dFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBpbnB1dFsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBpbnB1dFszXTtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxccHJvZFxcXFxsaW1pdHNfeycgKyB0aGlzLmJyYWNlcyhiKSArICc9JyArIHRoaXMuYnJhY2VzKGMpICsgJ31eJyArIHRoaXMuYnJhY2VzKGQpICsgJyAnICsgdGhpcy5icmFjZXMoYSkgKyAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdudGhyb290Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gJ1xcXFxzcXJ0WycgKyBpbnB1dFsxXSArICddJyArIHRoaXMuYnJhY2VzKGlucHV0WzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdtb2QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSBpbnB1dFswXSArICcgXFxcXGJtb2QgJyArIGlucHV0WzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ3JlYWxwYXJ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gJ1xcXFxvcGVyYXRvcm5hbWV7UmV9JyArIHRoaXMuYnJhY2tldHMoaW5wdXRbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2ltYWdwYXJ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gJ1xcXFxvcGVyYXRvcm5hbWV7SW19JyArIHRoaXMuYnJhY2tldHMoaW5wdXRbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmbmFtZSAhPT0gJycgPyAnXFxcXG1hdGhybScgKyB0aGlzLmJyYWNlcyhmbmFtZS5yZXBsYWNlKC9fL2csICdcXFxcXycpKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnZlcnNpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gbmFtZSArIHRoaXMuYnJhY2tldHMoaW5wdXQuam9pbignJyksICdwYXJlbnMnKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gbmFtZSArIHRoaXMuYnJhY2tldHMoaW5wdXQuam9pbignLCcpLCAncGFyZW5zJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbGxlY3RlZCA9IHN5bWJvbC5jb2xsZWN0U3ltYm9scygpLnNvcnQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID09PSBDUCB8fCBwcmV2aW91c0dyb3VwID09PSBDUCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5ncm91cCAtIGEuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBpc1N5bWJvbChhLnBvd2VyKSA/IC0xIDogYS5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gaXNTeW1ib2woYi5wb3dlcikgPyAtMSA6IGIucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geSAtIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IGNvbGxlY3RlZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9scy5wdXNoKExhVGVYLmxhdGV4KGNvbGxlY3RlZFtpXSwgb3B0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzeW1ib2xzLmpvaW4oJysnKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICEoc3ltYm9sLmlzTGluZWFyKCkgJiYgc3ltYm9sLm11bHRpcGxpZXIuZXF1YWxzKDEpKSB8fCBuZWdhdGl2ZSA/IHRoaXMuYnJhY2tldHModmFsdWUsICdwYXJlbnMnKSA6IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IENCIHx8IHByZXZpb3VzR3JvdXAgPT09IEVYIHx8IHByZXZpb3VzR3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICBpZihncm91cCA9PT0gQ0IpXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmRpc3RyaWJ1dGVFeHBvbmVudCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhbG1vc3QgZmVlbHMgYSBsaXR0bGUgbGlrZSBjaGVhdGluZyBidXQgSSBuZWVkIHRvIGtub3cgaWYgSSBzaG91bGQgYmUgd3JhcHBpbmcgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgLy8gaW4gYnJhY2tldHMgb3Igbm90LiBXZSdsbCBkbyB0aGlzIGJ5IGNoZWNraW5nIHRoZSB2YWx1ZSBvZiB0aGUgbnVtZXJhdG9yIGFuZCB0aGVuIGNvbXBhcmluZyBpdFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gd2hldGhlciB0aGUgc3ltYm9sIHZhbHVlIGlzIFwic2ltcGxlXCIgb3Igbm90LlxyXG4gICAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWVyYXRvciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBwcm9maWxlXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVuX21hcCA9IFtdLCBudW1fbWFwID0gW10sIG51bV9jID0gMCwgZGVuX2MgPSAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNldEJyYWNrZXRzID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgbWFwLCBjb3VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY291bnRlciA+IDEgJiYgbWFwLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBtYXAubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gbWFwW2ldLCBpdGVtID0gY29udGFpbmVyW2lkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighKC9eXFxcXGxlZnRcXCguK1xcXFxyaWdodFxcKVxcXlxcey4rXFx9JC9nLnRlc3QoaXRlbSkgfHwgL15cXFxcbGVmdFxcKC4rXFxcXHJpZ2h0XFwpJC9nLnRlc3QoaXRlbSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyW2lkeF0gPSBMYVRlWC5icmFja2V0cyhpdGVtLCAncGFyZW5zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgbGF0ZXggZm9yIGVhY2ggb2YgdGhlbVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNEZW5vbSA9IGlzTmVnYXRpdmUoeC5wb3dlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYVRleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNEZW5vbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYVRleCA9IExhVGVYLmxhdGV4KHguaW52ZXJ0KCksIG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbl9jKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLm11bHRpcGxpZXIuZGVuICE9IDEgJiYgTWF0aC5hYnMoeC5wb3dlcikgPT0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYVRleCA9IExhVGVYLmJyYWNrZXRzKGxhVGV4LCAncGFyZW5zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5fbWFwLnB1c2goZGVub21pbmF0b3IubGVuZ3RoKTsgLy8gbWFrZSBhIG5vdGUgb2Ygd2hlcmUgdGhlIGNvbXBvc2l0ZSB3YXMgZm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVub21pbmF0b3IucHVzaChsYVRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYVRleCA9IExhVGVYLmxhdGV4KHgsIG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bV9jKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLm11bHRpcGxpZXIubnVtICE9IDEgJiYgTWF0aC5hYnMoeC5wb3dlcikgPT0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYVRleCA9IExhVGVYLmJyYWNrZXRzKGxhVGV4LCAncGFyZW5zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1fbWFwLnB1c2gobnVtZXJhdG9yLmxlbmd0aCk7ICAgLy8gbWFrZSBhIG5vdGUgb2Ygd2hlcmUgdGhlIGNvbXBvc2l0ZSB3YXMgZm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1lcmF0b3IucHVzaChsYVRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgYnJhY2tldHNcclxuICAgICAgICAgICAgICAgIHNldEJyYWNrZXRzKG51bWVyYXRvciwgbnVtX21hcCwgbnVtX2MpO1xyXG4gICAgICAgICAgICAgICAgdlswXSA9IG51bWVyYXRvci5qb2luKHRoaXMuZG90KTsgLy8gY29sbGFwc2UgdGhlIG51bWVyYXRvciBpbnRvIG9uZSBzdHJpbmdcclxuXHJcbiAgICAgICAgICAgICAgICBzZXRCcmFja2V0cyhkZW5vbWluYXRvciwgZGVuX21hcCwgZGVuX2MpO1xyXG4gICAgICAgICAgICAgICAgdlsxXSA9IGRlbm9taW5hdG9yLmpvaW4odGhpcy5kb3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG0sIHYsIHAsIGNvbWJpbmVfcG93ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGlzQnJhY2tldGVkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAvXlxcXFxsZWZ0XFwoLitcXFxccmlnaHRcXCkkLy50ZXN0KHYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBmb3JtYXQgdGhlIHBvd2VyIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICBpZihwKVxyXG4gICAgICAgICAgICAgICAgcCA9IHRoaXMuZm9ybWF0UChwKTtcclxuICAgICAgICAgICAgLy8gZ3JvdXAgQ0Igd2lsbCBoYXZlIHRvIGJlIHdyYXBwZWQgc2luY2UgdGhlIHBvd2VyIGFwcGxpZXMgdG8gYm90aCBpdCdzIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3JcclxuICAgICAgICAgICAgaWYoY29tYmluZV9wb3dlcikge1xyXG4gICAgICAgICAgICAgICAgLy8gUE9TU0lCTEUgQlVHOiBJZiBwb3dlcnMgZm9yIGdyb3VwIENCIGZvcm1hdCB3cm9uZywgaW52ZXN0aWdhdGUgdGhpcyBzaW5jZSBJIG1pZ2h0IGhhdmUgb3Zlcmxvb2tlZCBzb21ldGhpbmdcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgaW4gZXZlcnkgY2FzZSB0aGUgZGVub25pbWF0b3Igc2hvdWxkIGJlIGVtcHR5IHdoZW4gZGVhbGluZyB3aXRoIENCLiBJIGNhbid0IHRoaW5rXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBhIGNhc2Ugd2hlcmUgdGhpcyBpc24ndCB0cnVlXHJcbiAgICAgICAgICAgICAgICB2YXIgdHAgPSBwWzBdO1xyXG4gICAgICAgICAgICAgICAgcFswXSA9ICcnOyAvLyB0ZW1wb3JhcmlseSBtYWtlIHAgYmxhbmtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gbWVyZ2UgdiBhbmQgcC4gTm90IHRoYXQgdiBNVVNUIGJlIGZpcnN0IHNpbmNlIHRoZSBvcmRlciBtYXR0ZXJzXHJcbiAgICAgICAgICAgIHYgPSB0aGlzLm1lcmdlKHYsIHApO1xyXG4gICAgICAgICAgICB2YXIgbW4gPSBtWzBdLCBtZCA9IG1bMV0sIHZuID0gdlswXSwgdmQgPSB2WzFdO1xyXG4gICAgICAgICAgICAvLyBmaWx0ZXJzXHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSB0b3AgaGFzIGEgdmFyaWFibGUgYnV0IHRoZSBudW1lcmF0b3IgaXMgb25lIGRyb3AgaXRcclxuICAgICAgICAgICAgaWYodm4gJiYgTnVtYmVyKG1uKSA9PT0gMSlcclxuICAgICAgICAgICAgICAgIG1uID0gJyc7XHJcbiAgICAgICAgICAgIC8vIGlmIGRlbm9taW5hdG9yIGlzIDEgZHJvcCBpdCBhbHdheXNcclxuICAgICAgICAgICAgaWYoTnVtYmVyKG1kKSA9PT0gMSlcclxuICAgICAgICAgICAgICAgIG1kID0gJyc7XHJcbiAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIHRvcCBwb3J0aW9uIGJ1dCBjaGVjayB0aGF0IGl0J3Mgbm90IGFscmVhZHkgYnJhY2tldGVkLiBJZiBpdCBpcyB0aGVuIGxlYXZlIG91dCB0aGUgY2RvdFxyXG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5qb2luKG1uLCB2biwgIWlzQnJhY2tldGVkKHZuKSA/IHRoaXMuZG90IDogJycpO1xyXG5cclxuICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgYm90dG9tIHBvcnRpb24gYnV0IGNoZWNrIHRoYXQgaXQncyBub3QgYWxyZWFkeSBicmFja2V0ZWQuIElmIGl0IGlzIHRoZW4gbGVhdmUgb3V0IHRoZSBjZG90XHJcbiAgICAgICAgICAgIHZhciBib3R0b20gPSB0aGlzLmpvaW4obWQsIHZkLCAhaXNCcmFja2V0ZWQodmQpID8gdGhpcy5kb3QgOiAnJyk7XHJcbiAgICAgICAgICAgIC8vIGZvcm1hdCB0aGUgcG93ZXIgaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgICAgIC8vIG1ha2UgaXQgYSBmcmFjdGlvbiBpZiBib3RoIHRvcCBhbmQgYm90dG9tIGV4aXN0c1xyXG4gICAgICAgICAgICBpZih0b3AgJiYgYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhYyA9IHRoaXMuZnJhYyh0b3AsIGJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICBpZihjb21iaW5lX3Bvd2VyICYmIHRwKVxyXG4gICAgICAgICAgICAgICAgICAgIGZyYWMgPSB0aGlzLmJyYWNrZXRzKGZyYWMpICsgdHA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugb25seSB0aGUgdG9wIGV4aXN0cyBzbyByZXR1cm4gdGhhdFxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9wO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAyOyBpKyspXHJcbiAgICAgICAgICAgICAgICByW2ldID0gYVtpXSArIGJbaV07XHJcbiAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gam9pbnMgdG9nZXRoZXIgdHdvIHN0cmluZ3MgaWYgYm90aCBleGlzdFxyXG4gICAgICAgIGpvaW46IGZ1bmN0aW9uIChuLCBkLCBnbHVlKSB7XHJcbiAgICAgICAgICAgIGlmKCFuICYmICFkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICBpZihuICYmICFkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgICAgIGlmKGQgJiYgIW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcclxuICAgICAgICAgICAgcmV0dXJuIG4gKyBnbHVlICsgZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBsYWNlcyBzdWJzY3JpcHRzIGluIGJyYWNlcyBmb3IgcHJvcGVyIGZvcm1hdHRpbmdcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm9ybWF0U3Vic2NyaXB0czogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgLy8gU3BsaXQgaXQgYXQgdGhlIHVuZGVyc2NvcmVcclxuICAgICAgICAgICAgdmFyIGFyciA9IHYudG9TdHJpbmcoKS5zcGxpdCgnXycpO1xyXG5cclxuICAgICAgICAgICAgdmFyIG5hbWUgPSAnJztcclxuXHJcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBhbGwgZW50cmllcyBleGNlcHQgdGhlIGZpcnN0IG9uZVxyXG4gICAgICAgICAgICB3aGlsZShhcnIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV3JhcCBhbGwgaW4gYnJhY2VzIGV4Y2VwdCBmb3IgdGhlIGxhc3Qgb25lXHJcbiAgICAgICAgICAgICAgICBpZihhcnIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnXycgKyB0aGlzLmJyYWNlcyhhcnIucG9wKCkgKyBuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFyclswXSArIG5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtYXRQOiBmdW5jdGlvbiAocF9hcnJheSkge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBfYXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICBpZihwKVxyXG4gICAgICAgICAgICAgICAgICAgIHBfYXJyYXlbaV0gPSAnXicgKyB0aGlzLmJyYWNlcyhwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcF9hcnJheTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGZvcm1hdHMgdGhlIGZyYWN0aW9ucyBhY2NvcmRpbmdseS5cclxuICAgICAgICAgKiBAcGFyYW0ge0ZyYWN9IGZcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IGlzX3Bvd1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZvcm1hdEZyYWM6IGZ1bmN0aW9uIChmLCBpc19wb3cpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBmLm51bS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGQgPSBmLmRlbi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGhhdmUgeF4xXHJcbiAgICAgICAgICAgIGlmKGlzX3BvdyAmJiBuID09PSAnMScgJiYgZCA9PT0gJzEnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGhhdmUgeC8xXHJcbiAgICAgICAgICAgIGlmKGQgPT09ICcxJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcmFjKG4sIGQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnJhYzogZnVuY3Rpb24gKG4sIGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdcXFxcZnJhYycgKyB0aGlzLmJyYWNlcyhuKSArIHRoaXMuYnJhY2VzKGQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnJhY2VzOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3snICsgZSArICd9JztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJyYWNrZXRzOiBmdW5jdGlvbiAoZSwgdHlwKSB7XHJcbiAgICAgICAgICAgIHR5cCA9IHR5cCB8fCAncGFyZW5zJztcclxuICAgICAgICAgICAgdmFyIGJyYWNrZXRUeXBlcyA9IHtcclxuICAgICAgICAgICAgICAgIHBhcmVuczogWycoJywgJyknXSxcclxuICAgICAgICAgICAgICAgIHNxdWFyZTogWydbJywgJ10nXSxcclxuICAgICAgICAgICAgICAgIGJyYWNlOiBbJ3snLCAnfSddLFxyXG4gICAgICAgICAgICAgICAgYWJzOiBbJ3wnLCAnfCddLFxyXG4gICAgICAgICAgICAgICAgYW5nbGU6IFsnXFxcXGxhbmdsZScsICdcXFxccmFuZ2xlJ11cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGJyYWNrZXQgPSBicmFja2V0VHlwZXNbdHlwXTtcclxuICAgICAgICAgICAgcmV0dXJuICdcXFxcbGVmdCcgKyBicmFja2V0WzBdICsgZSArICdcXFxccmlnaHQnICsgYnJhY2tldFsxXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgZXh0cmVuZW91cyB0b2tlbnNcclxuICAgICAgICAgKiBAcGFyYW0ge1Rva2Vuc1tdfSB0b2tlbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7VG9rZW5zW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmlsdGVyVG9rZW5zOiBmdW5jdGlvbiAodG9rZW5zKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29weSBvdmVyIHRoZSB0eXBlIG9mIHRoZSBzY29wZVxyXG4gICAgICAgICAgICBpZihpc0FycmF5KHRva2VucykpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkLnR5cGUgPSB0b2tlbnMudHlwZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdGhlIGl0ZW1zIHRoYXQgbmVlZCB0byBiZSBkaXNwb3NlZFxyXG4gICAgICAgICAgICB2YXIgZCA9IFsnXFxcXCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JpZycsICdCaWcnLCAnbGFyZ2UnLCAnTGFyZ2UnXTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0X3Rva2VuID0gdG9rZW5zW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmKHRva2VuLnZhbHVlID09PSAnXFxcXCcgJiYgbmV4dF90b2tlbi52YWx1ZSA9PT0gJ1xcXFwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzQXJyYXkodG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChMYVRlWC5maWx0ZXJUb2tlbnModG9rZW4pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZC5pbmRleE9mKHRva2VuLnZhbHVlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFBhcnNlcyB0b2tlbnMgZnJvbSBMYVRlWCBzdHJpbmcuIERvZXMgbm90IGRvIGFueSBlcnJvciBjaGVja2luZ1xyXG4gICAgICAgICAqIEBwYXJhbSB7VG9rZW5zW119IHJwblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChyYXdfdG9rZW5zKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBsO1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gJyc7XHJcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLmZpbHRlclRva2VucyhyYXdfdG9rZW5zKTtcclxuICAgICAgICAgICAgdmFyIHJlcGxhY2UgPSB7XHJcbiAgICAgICAgICAgICAgICAnY2RvdCc6ICcnLFxyXG4gICAgICAgICAgICAgICAgJ3RpbWVzJzogJycsXHJcbiAgICAgICAgICAgICAgICAnaW5mdHknOiAnSW5maW5pdHknXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgbmV4dCB0b2tlblxyXG4gICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zWyh0eXBlb2YgbiA9PT0gJ3VuZGVmaW5lZCcgPyArK2kgOiBpICs9IG4pXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHBhcnNlX25leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTGFUZVgucGFyc2UobmV4dCgpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgaWYodG9rZW4gaW4gcmVwbGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlW3Rva2VuXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEEgcXVpcmsgd2l0aCBpbXBsaWNpdCBtdWx0aXBsaWNhdGlvbiBmb3JjZXMgdXMgdG8gY2hlY2sgZm9yICpcclxuICAgICAgICAgICAgICAgIGlmKHRva2VuID09PSAnKicgJiYgdG9rZW5zW2kgKyAxXS52YWx1ZSA9PT0gJyYnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgyKTsgLy8gc2tpcCB0aGlzIGFuZCB0aGUgJlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnLCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodG9rZW4gPT09ICcmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJywnOyAvLyBTa2lwIHRoZSAqXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBlbmQgb2YgYSByb3csIHJldHVybiB0aGUgcm93IHNlcGFyYXRvclxyXG4gICAgICAgICAgICAgICAgaWYodG9rZW4gPT09ICdcXFxcJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnXSxbJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIHN0YXJ0IHBhcnNpbmcgdGhlIHRva2Vuc1xyXG4gICAgICAgICAgICBmb3IoaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XHJcbiAgICAgICAgICAgICAgICAvLyBmcmFjdGlvbnNcclxuICAgICAgICAgICAgICAgIGlmKHRva2VuLnZhbHVlID09PSAnZnJhYycpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJzZSBhbmQgd3JhcCBpdCBpbiBicmFja2V0c1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gcGFyc2VfbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gcGFyc2VfbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSBuICsgJy8nICsgZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udmFsdWUgaW4gTGFUZVguc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRva2VuLnZhbHVlID09PSBTUVJUICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3ZlY3RvcicgJiYgdG9rZW5zW2kgKyAyXS50eXBlID09PSAnU2V0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IHBhcnNlX25leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cHIgPSBwYXJzZV9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSAoZXhwciArICdeJyArIGluQnJhY2tldHMoJzEvJyArIGJhc2UpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSB0b2tlbi52YWx1ZSArIHBhcnNlX25leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnZhbHVlID09PSAnaW50Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gcGFyc2VfbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGNvbW1hXHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgdmFyaWFibGUgb2YgaW50ZWdyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBuZXh0KCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZHggPSBnZXQoZHguc3Vic3RyaW5nKDEsIGR4Lmxlbmd0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSAnaW50ZWdyYXRlJyArIGluQnJhY2tldHMoZiArICcsJyArIGR4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udmFsdWUgPT09ICdpbnRfJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gcGFyc2VfbmV4dCgpOyAvLyBsb3dlclxyXG4gICAgICAgICAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0aGUgXlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1ID0gbmV4dCgpLnZhbHVlOyAvLyB1cHBlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGluIGJyYWNrZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gcGFyc2VfbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHBhcnNlX25leHQoKTsgLy8gZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHZhcmlhYmxlIG9mIGludGVncmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbmV4dCgpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGNvbW1hXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR4ID09PSAnLCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbmV4dCgpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAnZCcsIHNraXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHggPT09ICdkaWZmZXJlbnRpYWxEJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbmV4dCgpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHggPT09ICdtYXRocm0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIG1hdGhybXtkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IG5leHQoKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsICs9ICdkZWZpbnQnICsgaW5CcmFja2V0cyhmICsgJywnICsgbCArICcsJyArIHUgKyAnLCcgKyBkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnZhbHVlICYmIHRva2VuLnZhbHVlLnN0YXJ0c1dpdGgoJ2ludF8nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBsID0gcGFyc2VfbmV4dCgpOyAvLyBsb3dlclxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsID0gdG9rZW4udmFsdWUucmVwbGFjZSgnaW50XycsICcnKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1cHBlcm5vdycpXHJcbiAgICAgICAgICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRoZSBeXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBuZXh0KCkudmFsdWU7IC8vIHVwcGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgaW4gYnJhY2tldHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBwYXJzZV9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gcGFyc2VfbmV4dCgpOyAvLyBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgdmFyaWFibGUgb2YgaW50ZWdyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBuZXh0KCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgY29tbWFcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHggPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBuZXh0KCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICdkJywgc2tpcFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkeCA9PT0gJ2RpZmZlcmVudGlhbEQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBuZXh0KCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkeCA9PT0gJ21hdGhybScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgbWF0aHJte2R9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbmV4dCgpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgKz0gJ2RlZmludCcgKyBpbkJyYWNrZXRzKGYgKyAnLCcgKyBsICsgJywnICsgdSArICcsJyArIGR4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udmFsdWUgPT09ICdtYXRocm0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB0b2tlbnNbKytpXVswXS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgKz0gZiArIHBhcnNlX25leHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHN1bSBhbmQgcHJvZHVjdFxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih0b2tlbi52YWx1ZSA9PT0gJ3N1bV8nIHx8IHRva2VuLnZhbHVlID09PSAncHJvZF8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gdG9rZW4udmFsdWUgPT09ICdzdW1fJyA/ICdzdW0nIDogJ3Byb2R1Y3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBueHQgPSBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRoZSBjYXJldFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBwYXJzZV9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBwYXJzZV9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsICs9IGZuICsgaW5CcmFja2V0cyhbZiwgZ2V0KG54dFswXSksIGdldChueHRbMl0pLCBnZXQoZW5kKV0uam9pbignLCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udmFsdWUgPT09ICdsaW1fJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBueHQgPSBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsICs9ICdsaW1pdCcgKyBpbkJyYWNrZXRzKFtwYXJzZV9uZXh0KCksIGdldChueHRbMF0pLCBnZXQobnh0WzJdKV0uam9pbignLCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udmFsdWUgPT09ICdiZWdpbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkobnh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IG54dFswXS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodiA9PT0gJ21hdHJpeCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGEgbWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgKz0gJ21hdHJpeChbJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udmFsdWUgPT09ICdlbmQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG54dCA9IG5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG54dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBueHRbMF0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHYgPT09ICdtYXRyaXgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgYSBtYXRyaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSAnXSknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsICs9IGdldChMYVRlWC5wYXJzZSh0b2tlbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsICs9IGdldCh0b2tlbi52YWx1ZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBpbkJyYWNrZXRzKHJldHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuLy9WZWN0b3IgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGZ1bmN0aW9uIFZlY3Rvcih2KSB7XHJcbiAgICAgICAgaWYoaXNWZWN0b3IodikpXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSB2Lml0ZW1zLnNsaWNlKDApO1xyXG4gICAgICAgIGVsc2UgaWYoaXNBcnJheSh2KSlcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IHYuc2xpY2UoMCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAqIEdlbmVyYXRlcyBhIHByZS1maWxsZWQgYXJyYXlcclxuICAgICAqIEBwYXJhbSB7dHlwZX0gblxyXG4gICAgICogQHBhcmFtIHt0eXBlfSB2YWxcclxuICAgICAqIEByZXR1cm5zIHt1bnJlc29sdmVkfVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuYXJyYXlQcmVmaWxsID0gZnVuY3Rpb24gKG4sIHZhbCkge1xyXG4gICAgICAgIHZhciBhID0gW107XHJcbiAgICAgICAgdmFsID0gdmFsIHx8IDA7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgYVtpXSA9IHZhbDtcclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgdmVjdG9yIGZyb20gYW5kIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGFcclxuICAgICAqIEByZXR1cm5zIHt1bnJlc29sdmVkfVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICB2YXIgdiA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgICB2LmVsZW1lbnRzID0gYTtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IGEgU2V0IHRvIGEgVmVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge1NldH0gc2V0XHJcbiAgICAgKiBAcmV0dXJucyB7VmVjdG9yfVxyXG4gICAgICovXHJcbiAgICBWZWN0b3IuZnJvbVNldCA9IGZ1bmN0aW9uIChzZXQpIHtcclxuICAgICAgICByZXR1cm4gVmVjdG9yLmZyb21BcnJheShzZXQuZWxlbWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvL1BvcnRlZCBmcm9tIFN5bHZlc3Rlci5qc1xyXG4gICAgVmVjdG9yLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjdXN0b206IHRydWUsXHJcbiAgICAgICAgLy8gUmV0dXJucyBlbGVtZW50IGkgb2YgdGhlIHZlY3RvclxyXG4gICAgICAgIGU6IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaSA8IDEgfHwgaSA+IHRoaXMuZWxlbWVudHMubGVuZ3RoKSA/IG51bGwgOiB0aGlzLmVsZW1lbnRzW2kgLSAxXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpLCB2YWwpIHtcclxuICAgICAgICAgICAgaWYoIWlzU3ltYm9sKHZhbCkpXHJcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXcgU3ltYm9sKHZhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0gPSB2YWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoZSB2ZWN0b3IgaGFzXHJcbiAgICAgICAgZGltZW5zaW9uczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgbW9kdWx1cyAoJ2xlbmd0aCcpIG9mIHRoZSB2ZWN0b3JcclxuICAgICAgICBtb2R1bHVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9jaygnU0FGRScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnBvdygodGhpcy5kb3QodGhpcy5jbG9uZSgpKSksIG5ldyBTeW1ib2woMC41KSk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIGVxdWFsIHRvIHRoZSBhcmd1bWVudFxyXG4gICAgICAgIGVxbDogZnVuY3Rpb24gKHZlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgViA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XHJcbiAgICAgICAgICAgIGlmKG4gIT09IFYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoXy5zdWJ0cmFjdCh0aGlzLmVsZW1lbnRzW24gLSAxXSwgVltuIC0gMV0pLnZhbHVlT2YoKSkgPiBQUkVDSVNJT04pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoLS1uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyBhIGNsb25lIG9mIHRoZSB2ZWN0b3JcclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgViA9IG5ldyBWZWN0b3IoKSxcclxuICAgICAgICAgICAgICAgICAgICBsID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vUnVsZTogYWxsIGl0ZW1zIHdpdGhpbiB0aGUgdmVjdG9yIG11c3QgaGF2ZSBhIGNsb25lIG1ldGhvZC5cclxuICAgICAgICAgICAgICAgIFYuZWxlbWVudHMucHVzaCh0aGlzLmVsZW1lbnRzW2ldLmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBWLmdldHRlciA9IHRoaXMuZ2V0dGVyLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFY7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gTWFwcyB0aGUgdmVjdG9yIHRvIGFub3RoZXIgdmVjdG9yIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnVuY3Rpb25cclxuICAgICAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGZuKHgsIGkpKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihlbGVtZW50cyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gQ2FsbHMgdGhlIGl0ZXJhdG9yIGZvciBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3RvciBpbiB0dXJuXHJcbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGsgPSBuLCBpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpID0gayAtIG47XHJcbiAgICAgICAgICAgICAgICBmbih0aGlzLmVsZW1lbnRzW2ldLCBpICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoLS1uKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIGEgbmV3IHZlY3RvciBjcmVhdGVkIGJ5IG5vcm1hbGl6aW5nIHRoZSByZWNlaXZlclxyXG4gICAgICAgIHRvVW5pdFZlY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2soJ1NBRkUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMubW9kdWx1cygpO1xyXG4gICAgICAgICAgICAgICAgaWYoci52YWx1ZU9mKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKHgsIHIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdmVjdG9yIGFuZCB0aGUgYXJndW1lbnQgKGFsc28gYSB2ZWN0b3IpXHJcbiAgICAgICAgYW5nbGVGcm9tOiBmdW5jdGlvbiAodmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9jaygnU0FGRScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcclxuICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZihuICE9PSBWLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRvdCA9IG5ldyBTeW1ib2woMCksIG1vZDEgPSBuZXcgU3ltYm9sKDApLCBtb2QyID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgIC8vIFdvcmsgdGhpbmdzIG91dCBpbiBwYXJhbGxlbCB0byBzYXZlIHRpbWVcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvdCA9IF8uYWRkKGRvdCwgXy5tdWx0aXBseSh4LCBWW2kgLSAxXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZDEgPSBfLmFkZChtb2QxLCBfLm11bHRpcGx5KHgsIHgpKTsvLyB3aWxsIG5vdCBjb25mbGljdCBpbiBzYWZlIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kMiA9IF8uYWRkKG1vZDIsIF8ubXVsdGlwbHkoVltpIC0gMV0sIFZbaSAtIDFdKSk7Ly8gd2lsbCBub3QgY29uZmxpY3QgaW4gc2FmZSBibG9ja1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBtb2QxID0gXy5wb3cobW9kMSwgbmV3IFN5bWJvbCgwLjUpKTtcclxuICAgICAgICAgICAgICAgIG1vZDIgPSBfLnBvdyhtb2QyLCBuZXcgU3ltYm9sKDAuNSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb2R1Y3QgPSBfLm11bHRpcGx5KG1vZDEsIG1vZDIpO1xyXG4gICAgICAgICAgICAgICAgaWYocHJvZHVjdC52YWx1ZU9mKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IF8uZGl2aWRlKGRvdCwgcHJvZHVjdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhldGFfdmFsID0gdGhldGEudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhldGFfdmFsIDwgLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYodGhldGFfdmFsID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoZXRhID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguYWNvcyh0aGV0YSkpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBwYXJhbGxlbCB0byB0aGUgYXJndW1lbnRcclxuICAgICAgICBpc1BhcmFsbGVsVG86IGZ1bmN0aW9uICh2ZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZUZyb20odmVjdG9yKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYW5nbGUgPT09IG51bGwpID8gbnVsbCA6IChhbmdsZSA8PSBQUkVDSVNJT04pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBhbnRpcGFyYWxsZWwgdG8gdGhlIGFyZ3VtZW50XHJcbiAgICAgICAgaXNBbnRpcGFyYWxsZWxUbzogZnVuY3Rpb24gKHZlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlRnJvbSh2ZWN0b3IpLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgcmV0dXJuIChhbmdsZSA9PT0gbnVsbCkgPyBudWxsIDogKE1hdGguYWJzKGFuZ2xlIC0gTWF0aC5QSSkgPD0gUFJFQ0lTSU9OKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSB2ZWN0b3IgaXMgcGVycGVuZGljdWxhciB0byB0aGUgYXJndW1lbnRcclxuICAgICAgICBpc1BlcnBlbmRpY3VsYXJUbzogZnVuY3Rpb24gKHZlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgZG90ID0gdGhpcy5kb3QodmVjdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIChkb3QgPT09IG51bGwpID8gbnVsbCA6IChNYXRoLmFicyhkb3QpIDw9IFBSRUNJU0lPTik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGluZyB0aGUgYXJndW1lbnQgdG8gdGhlIHZlY3RvclxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHZlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2soJ1NBRkUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgViA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPT0gVi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZCh4LCBWW2kgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgdGhlIGFyZ3VtZW50IGZyb20gdGhlIHZlY3RvclxyXG4gICAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAodmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9jaygnU0FGRScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudHMubGVuZ3RoICE9PSBWLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QoeCwgVltpIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGx5aW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgdmVjdG9yIGJ5IHRoZSBhcmd1bWVudFxyXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4LmNsb25lKCkgKiBrLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHg6IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGspO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIHNjYWxhciBwcm9kdWN0IG9mIHRoZSB2ZWN0b3Igd2l0aCB0aGUgYXJndW1lbnRcclxuICAgICAgICAvLyBCb3RoIHZlY3RvcnMgbXVzdCBoYXZlIGVxdWFsIGRpbWVuc2lvbmFsaXR5XHJcbiAgICAgICAgZG90OiBmdW5jdGlvbiAodmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9jaygnU0FGRScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9kdWN0ID0gbmV3IFN5bWJvbCgwKSwgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYobiAhPT0gVi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0ID0gXy5hZGQocHJvZHVjdCwgXy5tdWx0aXBseSh0aGlzLmVsZW1lbnRzW24gLSAxXSwgVltuIC0gMV0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlKC0tbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZHVjdDtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRoZSB2ZWN0b3IgcHJvZHVjdCBvZiB0aGUgdmVjdG9yIHdpdGggdGhlIGFyZ3VtZW50XHJcbiAgICAgICAgLy8gQm90aCB2ZWN0b3JzIG11c3QgaGF2ZSBkaW1lbnNpb25hbGl0eSAzXHJcbiAgICAgICAgY3Jvc3M6IGZ1bmN0aW9uICh2ZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIEIgPSB2ZWN0b3IuZWxlbWVudHMgfHwgdmVjdG9yO1xyXG4gICAgICAgICAgICBpZih0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPT0gMyB8fCBCLmxlbmd0aCAhPT0gMykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIEEgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2soJ1NBRkUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihbXHJcbiAgICAgICAgICAgICAgICAgICAgXy5zdWJ0cmFjdChfLm11bHRpcGx5KEFbMV0sIEJbMl0pLCBfLm11bHRpcGx5KEFbMl0sIEJbMV0pKSxcclxuICAgICAgICAgICAgICAgICAgICBfLnN1YnRyYWN0KF8ubXVsdGlwbHkoQVsyXSwgQlswXSksIF8ubXVsdGlwbHkoQVswXSwgQlsyXSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIF8uc3VidHJhY3QoXy5tdWx0aXBseShBWzBdLCBCWzFdKSwgXy5tdWx0aXBseShBWzFdLCBCWzBdKSlcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIChhYnNvbHV0ZSkgbGFyZ2VzdCBlbGVtZW50IG9mIHRoZSB2ZWN0b3JcclxuICAgICAgICBtYXg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG0gPSAwLCBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGsgPSBuLCBpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpID0gayAtIG47XHJcbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyh0aGlzLmVsZW1lbnRzW2ldLnZhbHVlT2YoKSkgPiBNYXRoLmFicyhtLnZhbHVlT2YoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gdGhpcy5lbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSgtLW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hZ25pdHVkZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbWFnbml0dWRlID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBtYWduaXR1ZGUgPSBfLmFkZChtYWduaXR1ZGUsIF8ucG93KGUsIG5ldyBTeW1ib2woMikpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLnNxcnQobWFnbml0dWRlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBtYXRjaCBmb3VuZFxyXG4gICAgICAgIGluZGV4T2Y6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IG51bGwsIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgayA9IG4sIGk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGkgPSBrIC0gbjtcclxuICAgICAgICAgICAgICAgIGlmKGluZGV4ID09PSBudWxsICYmIHRoaXMuZWxlbWVudHNbaV0udmFsdWVPZigpID09PSB4LnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoLS1uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYXRleDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgdGV4ID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXgucHVzaChMYVRlWC5sYXRleC5jYWxsKExhVGVYLCB0aGlzLmVsZW1lbnRzW2ldLCBvcHRpb24pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdGV4LmpvaW4oJywgJykgKyAnXSc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbi8vTWF0cml4ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBmdW5jdGlvbiBNYXRyaXgoKSB7XHJcbiAgICAgICAgdmFyIG0gPSBhcmd1bWVudHMsXHJcbiAgICAgICAgICAgICAgICBsID0gbS5sZW5ndGgsIGksIGVsID0gW107XHJcbiAgICAgICAgaWYoaXNNYXRyaXgobSkpIHsgLy8gaWYgaXQncyBhIG1hdHJpeCB0aGVuIG1ha2UgYSBjbG9uZVxyXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsLnB1c2gobVtpXS5zbGljZSgwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByb3csIGx3LCBybDtcclxuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByb3cgPSBtW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoaXNWZWN0b3Iocm93KSlcclxuICAgICAgICAgICAgICAgICAgICByb3cgPSByb3cuZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICBpZighaXNBcnJheShyb3cpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IFtyb3ddO1xyXG4gICAgICAgICAgICAgICAgcmwgPSByb3cubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYobHcgJiYgbHcgIT09IHJsKVxyXG4gICAgICAgICAgICAgICAgICAgIGVycignVW5hYmxlIHRvIGNyZWF0ZSBNYXRyaXguIFJvdyBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaCEnKTtcclxuICAgICAgICAgICAgICAgIGVsLnB1c2gocm93KTtcclxuICAgICAgICAgICAgICAgIGx3ID0gcmw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsO1xyXG4gICAgfVxyXG4gICAgTWF0cml4LmlkZW50aXR5ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB2YXIgbSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIG0uZWxlbWVudHMucHVzaChbXSk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIG0uc2V0KGksIGosIGkgPT09IGogPyBuZXcgU3ltYm9sKDEpIDogbmV3IFN5bWJvbCgwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9O1xyXG4gICAgTWF0cml4LmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICBmdW5jdGlvbiBGKGFyZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdHJpeC5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRi5wcm90b3R5cGUgPSBNYXRyaXgucHJvdG90eXBlO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEYoYXJyKTtcclxuICAgIH07XHJcbiAgICBNYXRyaXguemVyb01hdHJpeCA9IGZ1bmN0aW9uIChyb3dzLCBjb2xzKSB7XHJcbiAgICAgICAgdmFyIG0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xyXG4gICAgICAgICAgICBtLmVsZW1lbnRzLnB1c2goVmVjdG9yLmFycmF5UHJlZmlsbChjb2xzLCBuZXcgU3ltYm9sKDApKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfTtcclxuICAgIE1hdHJpeC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLy8gbmVlZHMgYmUgdHJ1ZSB0byBsZXQgdGhlIHBhcnNlciBrbm93IG5vdCB0byB0cnkgdG8gY2FzdCBpdCB0byBhIHN5bWJvbFxyXG4gICAgICAgIGN1c3RvbTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChyb3csIGNvbHVtbikge1xyXG4gICAgICAgICAgICBpZighdGhpcy5lbGVtZW50c1tyb3ddKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbcm93XVtjb2x1bW5dO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWFwOiBmdW5jdGlvbiAoZiwgcmF3X3ZhbHVlcykge1xyXG4gICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChlLCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBmLmNhbGwoTSwgZSksIHJhd192YWx1ZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIE07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChyb3csIGNvbHVtbiwgdmFsdWUsIHJhdykge1xyXG4gICAgICAgICAgICBpZighdGhpcy5lbGVtZW50c1tyb3ddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tyb3ddID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbcm93XVtjb2x1bW5dID0gcmF3ID8gdmFsdWUgOiAoaXNTeW1ib2wodmFsdWUpID8gdmFsdWUgOiBuZXcgU3ltYm9sKHZhbHVlKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2xzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvd3M6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm93OiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICBpZighbiB8fCBuID4gdGhpcy5jb2xzKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW24gLSAxXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgdmFyIG5yID0gdGhpcy5yb3dzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgY29sID0gW107XHJcbiAgICAgICAgICAgIGlmKG4gPiB0aGlzLmNvbHMoKSB8fCAhbilcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2w7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBucjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb2wucHVzaCh0aGlzLmVsZW1lbnRzW2ldW24gLSAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVhY2hFbGVtZW50OiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgdmFyIG5yID0gdGhpcy5yb3dzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmMgPSB0aGlzLmNvbHMoKSwgaSwgajtcclxuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbnI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgbmM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwodGhpcywgdGhpcy5lbGVtZW50c1tpXVtqXSwgaSwgaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIHBvcnRlZCBmcm9tIFN5bHZlc3Rlci5qc1xyXG4gICAgICAgIGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzU3F1YXJlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBNID0gdGhpcy50b1JpZ2h0VHJpYW5ndWxhcigpO1xyXG4gICAgICAgICAgICB2YXIgZGV0ID0gTS5lbGVtZW50c1swXVswXSwgbiA9IE0uZWxlbWVudHMubGVuZ3RoIC0gMSwgayA9IG4sIGk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGkgPSBrIC0gbiArIDE7XHJcbiAgICAgICAgICAgICAgICBkZXQgPSBfLm11bHRpcGx5KGRldCwgTS5lbGVtZW50c1tpXVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoLS1uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzU3F1YXJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PT0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1Npbmd1bGFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3F1YXJlKCkgJiYgdGhpcy5kZXRlcm1pbmFudCgpID09PSAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXVnbWVudDogZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnJvd3MoKSwgcnIgPSBtLnJvd3MoKTtcclxuICAgICAgICAgICAgaWYociAhPT0gcnIpXHJcbiAgICAgICAgICAgICAgICBlcnIoXCJDYW5ub3QgYXVnbWVudCBtYXRyaXguIFJvd3MgZG9uJ3QgbWF0Y2guXCIpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldID0gdGhpcy5lbGVtZW50c1tpXS5jb25jYXQobS5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnJvd3MoKSwgYyA9IHRoaXMuY29scygpLFxyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCByOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG0uZWxlbWVudHNbaV0gPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBjOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5lbGVtZW50c1tpXVtqXTtcclxuICAgICAgICAgICAgICAgICAgICBtLmVsZW1lbnRzW2ldW2pdID0gaXNTeW1ib2woc3ltYm9sKSA/IHN5bWJvbC5jbG9uZSgpIDogc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gcG9ydGVkIGZyb20gU3lsdmVzdGVyLmpzXHJcbiAgICAgICAgaW52ZXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzU3F1YXJlKCkpXHJcbiAgICAgICAgICAgICAgICBlcnIoJ01hdHJpeCBpcyBub3Qgc3F1YXJlIScpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2soJ1NBRkUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwga2kgPSBuaSwgaSwgajtcclxuICAgICAgICAgICAgICAgIHZhciBpbWF0cml4ID0gTWF0cml4LmlkZW50aXR5KG5pKTtcclxuICAgICAgICAgICAgICAgIHZhciBNID0gdGhpcy5hdWdtZW50KGltYXRyaXgpLnRvUmlnaHRUcmlhbmd1bGFyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnAsIGtwID0gTS5lbGVtZW50c1swXS5sZW5ndGgsIHAsIGVscywgZGl2aXNvcjtcclxuICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlX2VsZW1lbnRzID0gW10sIG5ld19lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0cml4IGlzIG5vbi1zaW5ndWxhciBzbyB0aGVyZSB3aWxsIGJlIG5vIHplcm9zIG9uIHRoZSBkaWFnb25hbFxyXG4gICAgICAgICAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCByb3dzIGZyb20gbGFzdCB0byBmaXJzdFxyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBuaSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QsIG5vcm1hbGlzZSBkaWFnb25hbCBlbGVtZW50cyB0byAxXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcclxuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlX2VsZW1lbnRzW2ldID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aXNvciA9IE0uZWxlbWVudHNbaV1baV07XHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2VsZW1lbnQgPSBfLmRpdmlkZShNLmVsZW1lbnRzW2ldW3BdLCBkaXZpc29yLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHMucHVzaChuZXdfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodWZmbGUgb2YgdGhlIGN1cnJlbnQgcm93IG9mIHRoZSByaWdodCBoYW5kIHNpZGUgaW50byB0aGUgcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheSBhcyBpdCB3aWxsIG5vdCBiZSBtb2RpZmllZCBieSBsYXRlciBydW5zIHRocm91Z2ggdGhpcyBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHAgPj0ga2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVyc2VfZWxlbWVudHNbaV0ucHVzaChuZXdfZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoLS1ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgTS5lbGVtZW50c1tpXSA9IGVscztcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCBzdWJ0cmFjdCB0aGlzIHJvdyBmcm9tIHRob3NlIGFib3ZlIGl0IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZSB0aGUgaWRlbnRpdHkgbWF0cml4IG9uIHRoZSBsZWZ0IGhhbmQgc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IGk7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHMucHVzaChfLnN1YnRyYWN0KE0uZWxlbWVudHNbal1bcF0uY2xvbmUoKSwgXy5tdWx0aXBseShNLmVsZW1lbnRzW2ldW3BdLmNsb25lKCksIE0uZWxlbWVudHNbal1baV0uY2xvbmUoKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSgtLW5wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTS5lbGVtZW50c1tqXSA9IGVscztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSgtLW5pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRyaXguZnJvbUFycmF5KGludmVyc2VfZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gcG9ydGVkIGZyb20gU3lsdmVzdGVyLmpzXHJcbiAgICAgICAgdG9SaWdodFRyaWFuZ3VsYXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrKCdTQUZFJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIE0gPSB0aGlzLmNsb25lKCksIGVscywgZmVsLCBuZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgayA9IG4sIGksIG5wLCBrcCA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBwO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBrIC0gbjtcclxuICAgICAgICAgICAgICAgICAgICBmZWwgPSBNLmVsZW1lbnRzW2ldW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGZlbC52YWx1ZU9mKCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gaSArIDE7IGogPCBrOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lbCA9IE0uZWxlbWVudHNbal1baV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihuZWwgJiYgbmVsLnZhbHVlT2YoKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVscyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5wID0ga3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzLnB1c2goXy5hZGQoTS5lbGVtZW50c1tpXVtwXS5jbG9uZSgpLCBNLmVsZW1lbnRzW2pdW3BdLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoLS1ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTS5lbGVtZW50c1tpXSA9IGVscztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmVsID0gTS5lbGVtZW50c1tpXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihmZWwudmFsdWVPZigpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqID0gaSArIDE7IGogPCBrOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gXy5kaXZpZGUoTS5lbGVtZW50c1tqXVtpXS5jbG9uZSgpLCBNLmVsZW1lbnRzW2ldW2ldLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBucCA9IGtwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsZW1lbnRzIHdpdGggY29sdW1uIG51bWJlcnMgdXAgdG8gYW4gaW5jbHVkaW5nIHRoZSBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgcm93IHRoYXQgd2UncmUgc3VidHJhY3RpbmcgY2FuIHNhZmVseSBiZSBzZXQgc3RyYWlnaHQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB6ZXJvLCBzaW5jZSB0aGF0J3MgdGhlIHBvaW50IG9mIHRoaXMgcm91dGluZSBhbmQgaXQgYXZvaWRzIGhhdmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGxvb3Agb3ZlciBhbmQgY29ycmVjdCByb3VuZGluZyBlcnJvcnMgbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHMucHVzaChwIDw9IGkgPyBuZXcgU3ltYm9sKDApIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uc3VidHJhY3QoTS5lbGVtZW50c1tqXVtwXS5jbG9uZSgpLCBfLm11bHRpcGx5KE0uZWxlbWVudHNbaV1bcF0uY2xvbmUoKSwgbXVsdGlwbGllci5jbG9uZSgpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoLS1ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNLmVsZW1lbnRzW2pdID0gZWxzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUoLS1uKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTTtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBjb2xzID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpLCBuaSA9IGNvbHMsIGksIG5qLCBqO1xyXG5cclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaSA9IGNvbHMgLSBuaTtcclxuICAgICAgICAgICAgICAgIE0uZWxlbWVudHNbaV0gPSBbXTtcclxuICAgICAgICAgICAgICAgIG5qID0gcm93cztcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBqID0gcm93cyAtIG5qO1xyXG4gICAgICAgICAgICAgICAgICAgIE0uZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2pdW2ldLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSgtLW5qKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSgtLW5pKTtcclxuICAgICAgICAgICAgcmV0dXJuIE07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIG1hdHJpeCBjYW4gbXVsdGlwbHkgdGhlIGFyZ3VtZW50IGZyb20gdGhlIGxlZnRcclxuICAgICAgICBjYW5NdWx0aXBseUZyb21MZWZ0OiBmdW5jdGlvbiAobWF0cml4KSB7XHJcbiAgICAgICAgICAgIHZhciBsID0gaXNNYXRyaXgobWF0cml4KSA/IG1hdHJpeC5lbGVtZW50cy5sZW5ndGggOiBtYXRyaXgubGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmNvbHVtbnMgc2hvdWxkIGVxdWFsIG1hdHJpeC5yb3dzXHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5lbGVtZW50c1swXS5sZW5ndGggPT09IGwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2FtZVNpemU6IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93cygpID09PSBtYXRyaXgucm93cygpICYmIHRoaXMuY29scygpID09PSBtYXRyaXguY29scygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbXVsdGlwbHk6IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrKCdTQUZFJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIE0gPSBtYXRyaXguZWxlbWVudHMgfHwgbWF0cml4O1xyXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuY2FuTXVsdGlwbHlGcm9tTGVmdChNKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc2FtZVNpemUobWF0cml4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgTU0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gdGhpcy5yb3dzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gXy5tdWx0aXBseShuZXcgVmVjdG9yKHRoaXMuZWxlbWVudHNbaV0pLCBuZXcgVmVjdG9yKG1hdHJpeC5lbGVtZW50c1tpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTU0uZWxlbWVudHNbaV0gPSBlLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNTTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbmkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwga2kgPSBuaSwgaSwgbmosIGtqID0gTVswXS5sZW5ndGgsIGo7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29scyA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBlbGVtZW50cyA9IFtdLCBzdW0sIG5jLCBjO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBraSAtIG5pO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2ldID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgbmogPSBrajtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBraiAtIG5qO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYyA9IGNvbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBjb2xzIC0gbmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0gPSBfLmFkZChzdW0sIF8ubXVsdGlwbHkodGhpcy5lbGVtZW50c1tpXVtjXSwgTVtjXVtqXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKC0tbmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tpXVtqXSA9IHN1bTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoLS1uaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSgtLW5pKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRyaXguZnJvbUFycmF5KGVsZW1lbnRzKTtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG1hdHJpeCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc2FtZVNpemUobWF0cml4KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoRWxlbWVudChmdW5jdGlvbiAoZSwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfLmFkZChlLmNsb25lKCksIG1hdHJpeC5lbGVtZW50c1tpXVtqXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjay5jYWxsKE0sIHJlc3VsdCwgZSwgbWF0cml4LmVsZW1lbnRzW2ldW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uIChtYXRyaXgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnNhbWVTaXplKG1hdHJpeCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaEVsZW1lbnQoZnVuY3Rpb24gKGUsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXy5zdWJ0cmFjdChlLmNsb25lKCksIG1hdHJpeC5lbGVtZW50c1tpXVtqXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjay5jYWxsKE0sIHJlc3VsdCwgZSwgbWF0cml4LmVsZW1lbnRzW2ldW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvVmVjdG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMucm93cygpID09PSAxIHx8IHRoaXMuY29scygpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgICAgICAgICAgIHYuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKG5ld2xpbmUsIHRvX2RlY2ltYWwpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLnJvd3MoKSxcclxuICAgICAgICAgICAgICAgICAgICBzID0gW107XHJcbiAgICAgICAgICAgIG5ld2xpbmUgPSBuZXdsaW5lID09PSB1bmRlZmluZWQgPyAnXFxuJyA6IG5ld2xpbmU7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHMucHVzaCgnWycgKyB0aGlzLmVsZW1lbnRzW2ldLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdG9fZGVjaW1hbCA/IHgubXVsdGlwbGllci50b0RlY2ltYWwoKSA6IHgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geCAhPT0gdW5kZWZpbmVkID8gdiA6ICcnO1xyXG4gICAgICAgICAgICAgICAgfSkuam9pbignLCcpICsgJ10nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ21hdHJpeCcgKyBpbkJyYWNrZXRzKHMuam9pbignLCcpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdtYXRyaXgoJyArIHRoaXMuZWxlbWVudHMudG9TdHJpbmcoJycpICsgJyknO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGF0ZXg6IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgdmFyIGNvbHMgPSB0aGlzLmNvbHMoKSwgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KCdcXFxcYmVnaW57dm1hdHJpeH17MH1cXFxcZW5ke3ZtYXRyaXh9JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciByb3cgaW4gZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm93X3RleCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93X3RleC5wdXNoKExhVGVYLmxhdGV4LmNhbGwoTGFUZVgsIGVsZW1lbnRzW3Jvd11baV0sIG9wdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ZXgucHVzaChyb3dfdGV4LmpvaW4oJyAmICcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXguam9pbignIFxcXFxjciAnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGFsaWFzZXNcclxuICAgIE1hdHJpeC5wcm90b3R5cGUuZWFjaCA9IE1hdHJpeC5wcm90b3R5cGUuZWFjaEVsZW1lbnQ7XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIFNldChzZXQpIHtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XHJcbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IG9iamVjdCBpc24ndCBhbiBhcnJheSwgY29udmVydCBpdCB0byBvbmUuXHJcbiAgICAgICAgaWYoIWlzVmVjdG9yKHNldCkpXHJcbiAgICAgICAgICAgIHNldCA9IFZlY3Rvci5mcm9tQXJyYXkoYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgaWYoc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHNldC5lbGVtZW50cztcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoZWxlbWVudHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRihhcmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTZXQuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEYucHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBGKGFycik7XHJcbiAgICB9O1xyXG5cclxuICAgIFNldC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZighdGhpcy5jb250YWlucyh4KSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaCh4LmNsb25lKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZih4LmVxdWFscyhlKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICB2YXIgc2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZi5jYWxsKHRoaXMsIGUsIHNldCwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHNldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0LmFkZChlLmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHNldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVuaW9uOiBmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdW5pb24gPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHNldC5lYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBfdW5pb24uYWRkKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfdW5pb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBkaWZmID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICBzZXQuZWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZGlmZi5yZW1vdmUoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZihlLmVxdWFscyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSh0aGlzLmVsZW1lbnRzLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChzZXQpIHtcclxuICAgICAgICAgICAgdmFyIF9pbnRlcnNlY3Rpb24gPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHZhciBBID0gdGhpcztcclxuICAgICAgICAgICAgc2V0LmVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKEEuY29udGFpbnMoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfaW50ZXJzZWN0aW9uLmFkZChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX2ludGVyc2VjdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uIChzZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uKHNldCkuZWxlbWVudHMubGVuZ3RoID4gMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzX3N1YnNldDogZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBzZXQuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmNvbnRhaW5zKGVsZW1lbnRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAneycgKyB0aGlzLmVsZW1lbnRzLmpvaW4oJywnKSArICd9JztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuLy9idWlsZCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIHZhciBCdWlsZCA9IHtcclxuICAgICAgICBkZXBlbmRlbmNpZXM6IHtcclxuICAgICAgICAgICAgX3JlbmFtZToge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLmZhY3RvcmlhbCc6ICdmYWN0b3JpYWwnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZhY3RvcmlhbDoge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLmdhbW1hJzogTWF0aDIuZ2FtbWFcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2FtbWFfaW5jb21wbGV0ZToge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLmZhY3RvcmlhbCc6IE1hdGgyLmZhY3RvcmlhbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBMaToge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLkVpJzogTWF0aDIuRWksXHJcbiAgICAgICAgICAgICAgICAnTWF0aDIuYmlnTG9nJzogTWF0aDIuYmlnTG9nLFxyXG4gICAgICAgICAgICAgICAgJ0ZyYWMnOiBGcmFjXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIENpOiB7XHJcbiAgICAgICAgICAgICAgICAnTWF0aDIuZmFjdG9yaWFsJzogTWF0aDIuZmFjdG9yaWFsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIEVpOiB7XHJcbiAgICAgICAgICAgICAgICAnTWF0aDIuZmFjdG9yaWFsJzogTWF0aDIuZmFjdG9yaWFsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFNpOiB7XHJcbiAgICAgICAgICAgICAgICAnTWF0aDIuZmFjdG9yaWFsJzogTWF0aDIuZmFjdG9yaWFsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFNoaToge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLmZhY3RvcmlhbCc6IE1hdGgyLmZhY3RvcmlhbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBDaGk6IHtcclxuICAgICAgICAgICAgICAgICdpc0ludCc6IGlzSW50LFxyXG4gICAgICAgICAgICAgICAgJ25yb3VuZCc6IG5yb3VuZCxcclxuICAgICAgICAgICAgICAgICdNYXRoMi5udW1faW50ZWdyYXRlJzogTWF0aDIubnVtX2ludGVncmF0ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmYWN0b3I6IHtcclxuICAgICAgICAgICAgICAgICdNYXRoMi5pZmFjdG9yJzogTWF0aDIuaWZhY3RvcixcclxuICAgICAgICAgICAgICAgICdTeW1ib2wnOiBTeW1ib2xcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbnVtX2ludGVncmF0ZToge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLnNpbXBzb24nOiBNYXRoMi5zaW1wc29uLFxyXG4gICAgICAgICAgICAgICAgJ25yb3VuZCc6IG5yb3VuZFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmaWI6IHtcclxuICAgICAgICAgICAgICAgICdldmVuJzogZXZlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKiBTb21lIGZ1bmN0aW9ucyBuZWVkIHRvIGJlIG1hZGUgbnVtZXJpYyBzYWZlLiBCdWlsZCBjaGVja3MgaWYgdGhlcmUncyBhXHJcbiAgICAgICAgICogcmVmb3JtYXQgb3B0aW9uIGFuZCBjYWxscyB0aGF0IGluc3RlYWQgd2hlbiBjb21waWxpbmcgdGhlIGZ1bmN0aW9uIHN0cmluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZWZvcm1hdDoge1xyXG4gICAgICAgICAgICAvLyB0aGlzIHNpbXBseSBleHRlbmRzIHRoZSBidWlsZCBmdW5jdGlvblxyXG4gICAgICAgICAgICBkaWZmOiBmdW5jdGlvbiAoc3ltYm9sLCBkZXBzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHN5bWJvbC5hcmdzWzFdLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9ICd2YXIgZiA9ICcgKyBCdWlsZC5idWlsZChzeW1ib2wuYXJnc1swXS50b1N0cmluZygpLCBbdl0pICsgJzsnO1xyXG4gICAgICAgICAgICAgICAgZGVwc1sxXSArPSAndmFyIGRpZmYgPSAnICsgTWF0aDIuZGlmZi50b1N0cmluZygpICsgJzsnO1xyXG4gICAgICAgICAgICAgICAgZGVwc1sxXSArPSBmO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbJ2RpZmYoZikoJyArIHYgKyAnKScsIGRlcHNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRQcm9wZXJOYW1lOiBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICB2YXIgbWFwID0ge1xyXG4gICAgICAgICAgICAgICAgY29udGludWVkX2ZyYWN0aW9uOiAnY29udGludWVkRnJhY3Rpb24nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBtYXBbZl0gfHwgZjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGFzc3VtZXMgdGhhdCBkZXBlbmRlbmNlcyBhcmUgYXQgbWF4IDIgbGV2ZWxzXHJcbiAgICAgICAgY29tcGlsZURlcGVuZGVuY2llczogZnVuY3Rpb24gKGYsIGRlcHMpIHtcclxuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgcHJlZGVmaW5lZCBkZXBlbmRpZW5jZXNcclxuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IEJ1aWxkLmRlcGVuZGVuY2llc1tmXTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZSBkZXBlbmRlbmN5IHN0cmluZ1xyXG4gICAgICAgICAgICB2YXIgZGVwX3N0cmluZyA9IGRlcHMgJiYgZGVwc1sxXSA/IGRlcHNbMV0gOiAnJztcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbnMgdG8gYmUgcmVwbGFjZWRcclxuICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50cyA9IGRlcHMgJiYgZGVwc1swXSA/IGRlcHNbMF0gOiB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGVtIGFuZCBhZGQgdGhlbSB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICBmb3IodmFyIHggaW4gZGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgZGVwZW5kZW5jaWVzW3hdID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBvYmplY3RcclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0geC5zcGxpdCgnLicpOyAvL01hdGguZiBiZWNvbWVzIGZcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmdW5jdGlvbiBpc24ndCBwYXJ0IG9mIGFuIG9iamVjdCB0aGVuIHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gaXRzZWxmXHJcbiAgICAgICAgICAgICAgICBkZXBfc3RyaW5nICs9ICd2YXIgJyArIChjb21wb25lbnRzLmxlbmd0aCA+IDEgPyBjb21wb25lbnRzWzFdIDogY29tcG9uZW50c1swXSkgKyAnPScgKyBkZXBlbmRlbmNpZXNbeF0gKyAnOyc7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudHNbeF0gPSBjb21wb25lbnRzLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW3JlcGxhY2VtZW50cywgZGVwX3N0cmluZ107XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRBcmdzRGVwczogZnVuY3Rpb24gKHN5bWJvbCwgZGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gc3ltYm9sLmFyZ3M7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuYXJnc1tpXS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gRk4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IEJ1aWxkLmNvbXBpbGVEZXBlbmRlbmNpZXMoeC5mbmFtZSwgZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBidWlsZDogZnVuY3Rpb24gKHN5bWJvbCwgYXJnX2FycmF5KSB7XHJcbiAgICAgICAgICAgIHN5bWJvbCA9IGJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShzeW1ib2wpO1xyXG4gICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB2YXJpYWJsZXMoc3ltYm9sKTtcclxuICAgICAgICAgICAgdmFyIHN1cHBsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGZ0ZXh0ID0gZnVuY3Rpb24gKHN5bWJvbCwgeHBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAvL0ZpeCBmb3IgIzU0NSAtIFBhcmVudGhlc2VzIGNvbmZ1c2UgYnVpbGQuXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZm5hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gU3ltYm9sLnVud3JhcFBBUkVOUyhzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeHBvcnRzID0geHBvcnRzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBzeW1ib2wuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmdGV4dF9jb21wbGV4ID0gZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBncm91cCA9PT0gQ0IgPyAnKicgOiAnKycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gc3ltYm9sLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IHN5bWJvbC5zeW1ib2xzW3hdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ0ID0gZnRleHQoc3ltLCB4cG9ydHMpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3cmFwIGl0IGluIGJyYWNrZXRzIGlmIGl0J3MgZ3JvdXAgUEwgb3IgQ1BcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltLmlzQ29tcG9zaXRlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdCA9IGluQnJhY2tldHMoZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5wdXNoKGZ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IGNjLmpvaW4oZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcmV0dmFsICYmICFzeW1ib2wubXVsdGlwbGllci5lcXVhbHMoMSkgPyBpbkJyYWNrZXRzKHJldHZhbCkgOiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ0ZXh0X2Z1bmN0aW9uID0gZnVuY3Rpb24gKGJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYm4gaW4gTWF0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSAnTWF0aC4nICsgYm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibiA9IEJ1aWxkLmdldFByb3Blck5hbWUoYm4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN1cHBsZW1lbnRzLmluZGV4T2YoYm4pID09PSAtMSkgeyAvLyBtYWtlIHN1cmUgeW91J3JlIG5vdCBhZGRpbmcgdGhlIGZ1bmN0aW9uIHR3aWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTWF0aDIgZnVuY3Rpb25zIGFyZW4ndCBwYXJ0IG9mIHRoZSBzdGFuZGFyZCBqYXZhc2NyaXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTWF0aCBsaWJyYXJ5IGFuZCBtdXN0IGJlIGV4cG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4cG9ydHMucHVzaCgndmFyICcgKyBibiArICcgPSAnICsgTWF0aDJbYm5dLnRvU3RyaW5nKCkgKyAnOyAnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcGxlbWVudHMucHVzaChibik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gcmV0dmFsICsgaW5CcmFja2V0cyhzeW1ib2wuYXJncy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnRleHQoeCwgeHBvcnRzKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPT09IE4pXHJcbiAgICAgICAgICAgICAgICAgICAgYy5wdXNoKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLm11bHRpcGxpZXIuZXF1YWxzKC0xKSlcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSAnLSc7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKCFzeW1ib2wubXVsdGlwbGllci5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgYy5wdXNoKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGdyb3VwID09PSBTIHx8IGdyb3VwID09PSBQKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3ltYm9sLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBCdWlsZC5jb21waWxlRGVwZW5kZW5jaWVzKHN5bWJvbC5mbmFtZSwgZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBCdWlsZC5nZXRBcmdzRGVwcyhzeW1ib2wsIGRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoQnVpbGQucmVmb3JtYXRbc3ltYm9sLmZuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IEJ1aWxkLnJlZm9ybWF0W3N5bWJvbC5mbmFtZV0oc3ltYm9sLCBkZXBlbmRlbmNpZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBjb21wb25lbnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXBvbmVudHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZ0ZXh0X2Z1bmN0aW9uKHN5bWJvbC5mbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBnID0gc3ltYm9sLnByZXZpb3VzR3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocGcgPT09IE4gfHwgcGcgPT09IFMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3ltYm9sLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYocGcgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZnRleHRfZnVuY3Rpb24oc3ltYm9sLmZuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gQnVpbGQuY29tcGlsZURlcGVuZGVuY2llcyhzeW1ib2wuZm5hbWUsIGRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IEJ1aWxkLmdldEFyZ3NEZXBzKHN5bWJvbCwgZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZ0ZXh0X2NvbXBsZXgoc3ltYm9sLnByZXZpb3VzR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmdGV4dF9jb21wbGV4KHN5bWJvbC5ncm91cCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwICE9PSBOICYmICFzeW1ib2wucG93ZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvdyA9IGZ0ZXh0KF8ucGFyc2Uoc3ltYm9sLnBvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeHBvcnRzLnB1c2gocG93WzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICdNYXRoLnBvdycgKyBpbkJyYWNrZXRzKHZhbHVlICsgJywnICsgcG93WzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICBjLnB1c2gocHJlZml4ICsgdmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbYy5qb2luKCcqJyksIHhwb3J0cy5qb2luKCcnKS5yZXBsYWNlKC9cXG4rXFxzKy9nLCAnICcpXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYoYXJnX2FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaXggZm9yIGlzc3VlICM1NDZcclxuICAgICAgICAgICAgICAgIC8vIERpc2FibGUgYXJndW1lbnQgY2hlY2tpbmcgc2luY2UgaXQncyBhIGJpdCBwcmVzdW1wdHVvdXMuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBmKHgpID0gNTsgSWYgSSBleHBsaWNpdGVseSBwYXNzIGluIGFuIGFyZ3VtZW50IGFycmF5IGNvbnRhaW4geCBcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hlY2sgd2lsbCBmYWlsIGFuZCBjb21wbGFpbiBzaW5jZSB0aGUgZnVuY3Rpb24gZG9lc24ndCBjb250YWluIHguXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgIGlmIChhcmdfYXJyYXkuaW5kZXhPZihhcmcpID09PSAtMSlcclxuICAgICAgICAgICAgICAgICBlcnIoYXJnICsgJyBub3QgZm91bmQgaW4gYXJndW1lbnQgYXJyYXknKTtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdfYXJyYXk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmX2FycmF5ID0gZnRleHQoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1ha2UgYWxsIHRoZSBzdWJzdGl0dXRpb25zO1xyXG4gICAgICAgICAgICBmb3IodmFyIHggaW4gZGVwZW5kZW5jaWVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSBkZXBlbmRlbmNpZXNbMF1beF07XHJcbiAgICAgICAgICAgICAgICBmX2FycmF5WzFdID0gZl9hcnJheVsxXS5yZXBsYWNlKHgsIGFsaWFzKTtcclxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llc1sxXSA9IGRlcGVuZGVuY2llc1sxXS5yZXBsYWNlKHgsIGFsaWFzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgRnVuY3Rpb24oYXJncywgKGRlcGVuZGVuY2llc1sxXSB8fCAnJykgKyBmX2FycmF5WzFdICsgJyByZXR1cm4gJyArIGZfYXJyYXlbMF0gKyAnOycpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGY7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcblxyXG4vL2ZpbmFsaXplID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLyogRklOQUxJWkUgKi9cclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmVzZXJ2ZU5hbWVzKF8uQ09OU1RBTlRTKTtcclxuICAgICAgICByZXNlcnZlTmFtZXMoXy5mdW5jdGlvbnMpO1xyXG4gICAgICAgIF8uaW5pdENvbnN0YW50cygpO1xyXG4gICAgICAgIC8vYnVnIGZpeCBmb3IgZXJyb3IgYnV0IG5lZWRzIHRvIGJlIHJldmlzaXRlZFxyXG4gICAgICAgIGlmKCFfLmVycm9yKVxyXG4gICAgICAgICAgICBfLmVycm9yID0gZXJyO1xyXG5cclxuICAgICAgICAvL1N0b3JlIHRoZSBsb2cgYW5kIGxvZzEwIGZ1bmN0aW9uc1xyXG4gICAgICAgIFNldHRpbmdzLkxPR19GTlMgPSB7XHJcbiAgICAgICAgICAgIGxvZzogXy5mdW5jdGlvbnNbJ2xvZyddLFxyXG4gICAgICAgICAgICBsb2cxMDogXy5mdW5jdGlvbnNbJ2xvZzEwJ11cclxuICAgICAgICB9O1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLyogRU5EIEZJTkFMSVpFICovXHJcblxyXG4vL0NvcmUgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgdmFyIFV0aWxzID0ge1xyXG4gICAgICAgIGFsbFNhbWU6IGFsbFNhbWUsXHJcbiAgICAgICAgYWxsTnVtZXJpYzogYWxsTnVtZXJpYyxcclxuICAgICAgICBhcmd1bWVudHMyQXJyYXk6IGFyZ3VtZW50czJBcnJheSxcclxuICAgICAgICBhcnJheUFkZFNsaWNlczogYXJyYXlBZGRTbGljZXMsXHJcbiAgICAgICAgYXJyYXlDbG9uZTogYXJyYXlDbG9uZSxcclxuICAgICAgICBhcnJheU1heDogYXJyYXlNYXgsXHJcbiAgICAgICAgYXJyYXlNaW46IGFycmF5TWluLFxyXG4gICAgICAgIGFycmF5RXF1YWw6IGFycmF5RXF1YWwsXHJcbiAgICAgICAgYXJyYXlVbmlxdWU6IGFycmF5VW5pcXVlLFxyXG4gICAgICAgIGFycmF5R2V0VmFyaWFibGVzOiBhcnJheUdldFZhcmlhYmxlcyxcclxuICAgICAgICBhcnJheVN1bTogYXJyYXlTdW0sXHJcbiAgICAgICAgYmxvY2s6IGJsb2NrLFxyXG4gICAgICAgIGJ1aWxkOiBCdWlsZC5idWlsZCxcclxuICAgICAgICBjbGVhclU6IGNsZWFyVSxcclxuICAgICAgICBjb21ib1NvcnQ6IGNvbWJvU29ydCxcclxuICAgICAgICBjb21wYXJlOiBjb21wYXJlLFxyXG4gICAgICAgIGNvbnZlcnRUb1ZlY3RvcjogY29udmVydFRvVmVjdG9yLFxyXG4gICAgICAgIGN1c3RvbUVycm9yOiBjdXN0b21FcnJvcixcclxuICAgICAgICBjdXN0b21UeXBlOiBjdXN0b21UeXBlLFxyXG4gICAgICAgIGRlY29tcG9zZV9mbjogZGVjb21wb3NlX2ZuLFxyXG4gICAgICAgIGVhY2g6IGVhY2gsXHJcbiAgICAgICAgZXZhbHVhdGU6IGV2YWx1YXRlLFxyXG4gICAgICAgIGV2ZW46IGV2ZW4sXHJcbiAgICAgICAgZXZlbkZyYWN0aW9uOiBldmVuRnJhY3Rpb24sXHJcbiAgICAgICAgZmlsbEhvbGVzOiBmaWxsSG9sZXMsXHJcbiAgICAgICAgZmlyc3RPYmplY3Q6IGZpcnN0T2JqZWN0LFxyXG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxyXG4gICAgICAgIGdlbmVyYXRlUHJpbWVzOiBnZW5lcmF0ZVByaW1lcyxcclxuICAgICAgICBnZXRDb2VmZnM6IGdldENvZWZmcyxcclxuICAgICAgICBnZXRVOiBnZXRVLFxyXG4gICAgICAgIGltcG9ydEZ1bmN0aW9uczogaW1wb3J0RnVuY3Rpb25zLFxyXG4gICAgICAgIGluQnJhY2tldHM6IGluQnJhY2tldHMsXHJcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcclxuICAgICAgICBpc0V4cHJlc3Npb246IGlzRXhwcmVzc2lvbixcclxuICAgICAgICBpc0ZyYWN0aW9uOiBpc0ZyYWN0aW9uLFxyXG4gICAgICAgIGlzSW50OiBpc0ludCxcclxuICAgICAgICBpc01hdHJpeDogaXNNYXRyaXgsXHJcbiAgICAgICAgaXNOZWdhdGl2ZTogaXNOZWdhdGl2ZSxcclxuICAgICAgICBpc051bWVyaWNTeW1ib2w6IGlzTnVtZXJpY1N5bWJvbCxcclxuICAgICAgICBpc1ByaW1lOiBpc1ByaW1lLFxyXG4gICAgICAgIGlzUmVzZXJ2ZWQ6IGlzUmVzZXJ2ZWQsXHJcbiAgICAgICAgaXNTeW1ib2w6IGlzU3ltYm9sLFxyXG4gICAgICAgIGlzVmFyaWFibGVTeW1ib2w6IGlzVmFyaWFibGVTeW1ib2wsXHJcbiAgICAgICAgaXNWZWN0b3I6IGlzVmVjdG9yLFxyXG4gICAgICAgIGtleXM6IGtleXMsXHJcbiAgICAgICAga25vd25WYXJpYWJsZToga25vd25WYXJpYWJsZSxcclxuICAgICAgICBucm9vdHM6IG5yb290cyxcclxuICAgICAgICByZW1vdmU6IHJlbW92ZSxcclxuICAgICAgICByZXNlcnZlTmFtZXM6IHJlc2VydmVOYW1lcyxcclxuICAgICAgICByYW5nZTogcmFuZ2UsXHJcbiAgICAgICAgcm91bmQ6IG5yb3VuZCxcclxuICAgICAgICBzYW1lU2lnbjogc2FtZVNpZ24sXHJcbiAgICAgICAgc2NpZW50aWZpY1RvRGVjaW1hbDogc2NpZW50aWZpY1RvRGVjaW1hbCxcclxuICAgICAgICBzZXBhcmF0ZTogc2VwYXJhdGUsXHJcbiAgICAgICAgc3RyaW5nUmVwbGFjZTogc3RyaW5nUmVwbGFjZSxcclxuICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgIHZhbGlkYXRlTmFtZTogdmFsaWRhdGVOYW1lLFxyXG4gICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxyXG4gICAgICAgIHdhcm46IHdhcm5cclxuICAgIH07XHJcblxyXG4gICAgLy9UaGlzIGNvbnRhaW5zIGFsbCB0aGUgcGFydHMgb2YgbmVyZGFtZXIgYW5kIGVuYWJsZXMgbmVyZGFtZXIncyBpbnRlcm5hbCBmdW5jdGlvbnNcclxuICAgIC8vdG8gYmUgdXNlZC5cclxuICAgIHZhciBDID0ge1xyXG4gICAgICAgIGdyb3VwczogR3JvdXBzLFxyXG4gICAgICAgIFN5bWJvbDogU3ltYm9sLFxyXG4gICAgICAgIEV4cHJlc3Npb246IEV4cHJlc3Npb24sXHJcbiAgICAgICAgRnJhYzogRnJhYyxcclxuICAgICAgICBWZWN0b3I6IFZlY3RvcixcclxuICAgICAgICBNYXRyaXg6IE1hdHJpeCxcclxuICAgICAgICBQYXJzZXI6IFBhcnNlcixcclxuICAgICAgICBTY2llbnRpZmljOiBTY2llbnRpZmljLFxyXG4gICAgICAgIEZyYWN0aW9uOiBGcmFjdGlvbixcclxuICAgICAgICBNYXRoMjogTWF0aDIsXHJcbiAgICAgICAgTGFUZVg6IExhVGVYLFxyXG4gICAgICAgIFV0aWxzOiBVdGlscyxcclxuICAgICAgICBQQVJTRVI6IF8sXHJcbiAgICAgICAgUEFSRU5USEVTSVM6IFBBUkVOVEhFU0lTLFxyXG4gICAgICAgIFNldHRpbmdzOiBTZXR0aW5ncyxcclxuICAgICAgICBlcnI6IGVycixcclxuICAgICAgICBiaWdJbnQ6IGJpZ0ludCxcclxuICAgICAgICBiaWdEZWM6IGJpZ0RlYyxcclxuICAgICAgICBleGNlcHRpb25zOiBleGNlcHRpb25zXHJcbiAgICB9O1xyXG5cclxuLy9saWJFeHBvcnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uIHRoZSBleHByZXNzaW9uIHRvIGJlIGV2YWx1YXRlZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN1YnMgdGhlIG9iamVjdCBjb250YWluaW5nIHRoZSB2YXJpYWJsZSB2YWx1ZXNcclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbG9jYXRpb24gYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgZXF1YXRpb24gbGlzdCB0b1xyXG4gICAgICogaW5zZXJ0IHRoZSBldmFsdWF0ZWQgZXhwcmVzc2lvblxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBhZGRpdGlvbmFsIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtFeHByZXNzaW9ufVxyXG4gICAgICovXHJcbiAgICB2YXIgbGliRXhwb3J0cyA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBzdWJzLCBvcHRpb24sIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgLy8gSW5pdGlhdGUgdGhlIG51bWVyIGZsYWdcclxuICAgICAgICB2YXIgbnVtZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gSXMgdGhlIHVzZXIgZGVjbGFyaW5nIGEgZnVuY3Rpb24/XHJcbiAgICAgICAgdmFyIGZuZGVjID0gL14oW2Etel9dW2EtelxcZFxcX10qKVxcKChbYS16XyxcXHNdKilcXCk6PSguKykkL2dpLmV4ZWMoZXhwcmVzc2lvbik7XHJcbiAgICAgICAgaWYoZm5kZWMpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXJkYW1lci5zZXRGdW5jdGlvbihmbmRlY1sxXSwgZm5kZWNbMl0uc3BsaXQoJywnKSwgZm5kZWNbM10pO1xyXG5cclxuICAgICAgICAvLyB2YXIgdmFyaWFibGUsIGZuLCBhcmdzO1xyXG4gICAgICAgIC8vIENvbnZlcnQgYW55IGV4cHJlc3Npb24gcGFzc2VkIGluIHRvIGEgc3RyaW5nXHJcbiAgICAgICAgaWYoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgaXQgdG8gYW4gYXJyYXkgZm9yIHNpbXBsaWNpdHlcclxuICAgICAgICBpZighaXNBcnJheShvcHRpb24pKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbiA9IHR5cGVvZiBvcHRpb24gPT09ICd1bmRlZmluZWQnID8gW10gOiBbb3B0aW9uXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICAgIC8vIFR1cm4gb24gdGhlIG51bWVyIGZsYWcgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgIGlmKG8gPT09ICdudW1lcicpIHtcclxuICAgICAgICAgICAgICAgIG51bWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXcmFwIGl0IGluIGEgZnVuY3Rpb24gaWYgcmVxdWVzdGVkLiBUaGlzIG9ubHkgaG9sZHMgdHJ1ZSBmb3JcclxuICAgICAgICAgICAgLy8gZnVuY3Rpb25zIHRoYXQgdGFrZSBhIHNpbmdsZSBhcmd1bWVudCB3aGljaCBpcyB0aGUgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICB2YXIgZiA9IF8uZnVuY3Rpb25zW29wdGlvbl07XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBmdW5jdGlvbiBhbmQgaXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQsIHRoZW4gd3JhcFxyXG4gICAgICAgICAgICAvLyB0aGUgZXhwcmVzc2lvbiBpbiBpdFxyXG4gICAgICAgICAgICBpZihmICYmIGZbMV0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBgJHtvfSgke2V4cHJlc3Npb259KWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIGUgPSBibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5wYXJzZShleHByZXNzaW9uLCBzdWJzKTtcclxuICAgICAgICB9LCBudW1lciB8fCBTZXR0aW5ncy5QQVJTRTJOVU1CRVIpO1xyXG5cclxuICAgICAgICBpZihsb2NhdGlvbikge1xyXG4gICAgICAgICAgICBFWFBSRVNTSU9OU1tsb2NhdGlvbiAtIDFdID0gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIEVYUFJFU1NJT05TLnB1c2goZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24oZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBleHByZXNzaW9uIGludG8gcnBuIGZvcm1cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uXHJcbiAgICAgKiBAcmV0dXJucyB7VG9rZW5bXX1cclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5ycG4gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xyXG4gICAgICAgIHJldHVybiBfLnRva2VuaXplKF8udG9SUE4oZXhwcmVzc2lvbikpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBMYVRlWCBmcm9tIGV4cHJlc3Npb24gc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5jb252ZXJ0VG9MYVRlWCA9IGZ1bmN0aW9uIChlLCBvcHQpIHtcclxuICAgICAgICByZXR1cm4gXy50b1RlWChlLCBvcHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGxhdGV4IHRvIHRleHQgLSBWZXJ5IHZlcnkgdmVyeSBiYXNpYyBhdCB0aGUgbW9tZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZVxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5jb252ZXJ0RnJvbUxhVGVYID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgdHh0ID0gTGFUZVgucGFyc2UoXy50b2tlbml6ZShlKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKF8ucGFyc2UodHh0KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIG5lcmRhbWVyIG9yIGEgbG9hZGVkIGFkZC1vblxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZF9vbiAtIFRoZSBhZGQtb24gYmVpbmcgY2hlY2tlZFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcmV0dXJucyB0aGUgdmVyc2lvbiBvZiBuZXJkYW1lclxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLnZlcnNpb24gPSBmdW5jdGlvbiAoYWRkX29uKSB7XHJcbiAgICAgICAgaWYoYWRkX29uKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQ1thZGRfb25dLnZlcnNpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gbW9kdWxlIG5hbWVkIFwiICsgYWRkX29uICsgXCIgZm91bmQhXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG5lcmRhbWVyIGdlbmVyYXRlZCB3YXJuaW5nc1xyXG4gICAgICogQHJldHVybnMge1N0cmluZ1tdfVxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmdldFdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBXQVJOSU5HUztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnN0YW50IFRoZSBuYW1lIG9mIHRoZSBjb25zdGFudCB0byBiZSBzZXRcclxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgY29uc3RhbnRcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5lcmRhbWVyIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLnNldENvbnN0YW50ID0gZnVuY3Rpb24gKGNvbnN0YW50LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhbGlkYXRlTmFtZShjb25zdGFudCk7XHJcbiAgICAgICAgaWYoIWlzUmVzZXJ2ZWQoY29uc3RhbnQpKSB7XHJcbiAgICAgICAgICAgIC8vZml4IGZvciBpc3N1ZSAjMTI3XHJcbiAgICAgICAgICAgIGlmKHZhbHVlID09PSAnZGVsZXRlJyB8fCB2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfLkNPTlNUQU5UU1tjb25zdGFudF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZihpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5lcmRhbWVyVHlwZUVycm9yKCdDb25zdGFudCBtdXN0IGJlIGEgbnVtYmVyIScpO1xyXG4gICAgICAgICAgICAgICAgXy5DT05TVEFOVFNbY29uc3RhbnRdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBwcmV2aW91c2x5IHNldCBjb25zdGFudFxyXG4gICAgICogQHBhcmFtIHt0eXBlfSBjb25zdGFudFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5nZXRDb25zdGFudCA9IGZ1bmN0aW9uIChjb25zdGFudCkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoXy5jb25zdGFudFtjb25zdGFudF0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtc19hcnJheSBBIGxpc3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVyIG5hbWUgb2YgdGhlIGZ1bmN0aW9uc1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJvZHkgVGhlIGJvZHkgb2YgdGhlIGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHN1Y2NlZWRlZCBhbmQgZmFsbHMgb24gZmFpbFxyXG4gICAgICogQGV4YW1wbGUgbmVyZGFtZXIuc2V0RnVuY3Rpb24oJ2YnLFsneCddLCAneF4yKzInKTtcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5zZXRGdW5jdGlvbiA9IHNldEZ1bmN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtDfSBFeHBvcnRzIHRoZSBuZXJkYW1lciBjb3JlIGZ1bmN0aW9ucyBhbmQgb2JqZWN0c1xyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmdldENvcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEM7XHJcbiAgICB9O1xyXG5cclxuICAgIGxpYkV4cG9ydHMuZ2V0RXhwcmVzc2lvbiA9IGxpYkV4cG9ydHMuZ2V0RXF1YXRpb24gPSBFeHByZXNzaW9uLmdldEV4cHJlc3Npb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhc0FycmF5IFRoZSByZXR1cm5lZCBuYW1lcyBhcmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkgaWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZTtcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMucmVzZXJ2ZWQgPSBmdW5jdGlvbiAoYXNBcnJheSkge1xyXG4gICAgICAgIGlmKGFzQXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJFU0VSVkVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUkVTRVJWRUQuam9pbignLCAnKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBlcXVhdGlvbl9udW1iZXIgdGhlIG51bWJlciBvZiB0aGUgZXF1YXRpb24gdG8gY2xlYXIuXHJcbiAgICAgKiBJZiAnYWxsJyBpcyBzdXBwbGllZCB0aGVuIGFsbCBlcXVhdGlvbnMgYXJlIGNsZWFyZWRcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0ga2VlcF9FWFBSRVNTSU9OU19maXhlZCB1c2UgdHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCB0byBrZWVwIEVYUFJFU1NJT05TIGxlbmd0aCBmaXhlZFxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmVyZGFtZXIgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuY2xlYXIgPSBmdW5jdGlvbiAoZXF1YXRpb25fbnVtYmVyLCBrZWVwX0VYUFJFU1NJT05TX2ZpeGVkKSB7XHJcbiAgICAgICAgaWYoZXF1YXRpb25fbnVtYmVyID09PSAnYWxsJykge1xyXG4gICAgICAgICAgICBFWFBSRVNTSU9OUyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGVxdWF0aW9uX251bWJlciA9PT0gJ2xhc3QnKSB7XHJcbiAgICAgICAgICAgIEVYUFJFU1NJT05TLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGVxdWF0aW9uX251bWJlciA9PT0gJ2ZpcnN0Jykge1xyXG4gICAgICAgICAgICBFWFBSRVNTSU9OUy5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gIWVxdWF0aW9uX251bWJlciA/IEVYUFJFU1NJT05TLmxlbmd0aCA6IGVxdWF0aW9uX251bWJlciAtIDE7XHJcbiAgICAgICAgICAgIGtlZXBfRVhQUkVTU0lPTlNfZml4ZWQgPT09IHRydWUgPyBFWFBSRVNTSU9OU1tpbmRleF0gPSB1bmRlZmluZWQgOiByZW1vdmUoRVhQUkVTU0lPTlMsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIG5lcmRhbWVyLmNsZWFyKCdhbGwnKVxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmZsdXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoJ2FsbCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFzT2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFzTGFUZVhcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBvcHRpb25cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5leHByZXNzaW9ucyA9IGZ1bmN0aW9uIChhc09iamVjdCwgYXNMYVRlWCwgb3B0aW9uKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFzT2JqZWN0ID8ge30gOiBbXTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgRVhQUkVTU0lPTlMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGVxID0gYXNMYVRlWCA/IExhVGVYLmxhdGV4KEVYUFJFU1NJT05TW2ldLCBvcHRpb24pIDogdGV4dChFWFBSRVNTSU9OU1tpXSwgb3B0aW9uKTtcclxuICAgICAgICAgICAgYXNPYmplY3QgPyByZXN1bHRbaSArIDFdID0gZXEgOiByZXN1bHQucHVzaChlcSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vdGhlIG1ldGhvZCBmb3IgcmVnaXN0ZXJpbmcgbW9kdWxlc1xyXG4gICAgbGliRXhwb3J0cy5yZWdpc3RlciA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICB2YXIgY29yZSA9IHRoaXMuZ2V0Q29yZSgpO1xyXG5cclxuICAgICAgICBpZihpc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYob2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIob2JqW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKG9iaiAmJiBTZXR0aW5ncy5leGNsdWRlLmluZGV4T2Yob2JqLm5hbWUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAvL21ha2Ugc3VyZSBhbGwgdGhlIGRlcGVuZGVuY2llcyBhcmUgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGlmKG9iai5kZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmouZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFjb3JlW29iai5kZXBlbmRlbmNpZXNbaV1dKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCd7MH0gcmVxdWlyZXMgezF9IHRvIGJlIGxvYWRlZCEnLCBvYmoubmFtZSwgb2JqLmRlcGVuZGVuY2llc1tpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgbm8gcGFyZW50IG9iamVjdCBpcyBwcm92aWRlZCB0aGVuIHRoZSBmdW5jdGlvbiBkb2VzIG5vdCBoYXZlIGFuIGFkZHJlc3MgYW5kIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHlcclxuICAgICAgICAgICAgdmFyIHBhcmVudF9vYmogPSBvYmoucGFyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gb2JqLmJ1aWxkLmNhbGwoY29yZSk7IC8vY2FsbCBjb25zdHJ1Y3RvciB0byBnZXQgZnVuY3Rpb25cclxuICAgICAgICAgICAgaWYocGFyZW50X29iaikge1xyXG4gICAgICAgICAgICAgICAgaWYoIWNvcmVbcGFyZW50X29ial0pXHJcbiAgICAgICAgICAgICAgICAgICAgY29yZVtvYmoucGFyZW50XSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZWZfb2JqID0gcGFyZW50X29iaiA9PT0gJ25lcmRhbWVyJyA/IHRoaXMgOiBjb3JlW3BhcmVudF9vYmpdO1xyXG4gICAgICAgICAgICAgICAgLy9hdHRhY2ggdGhlIGZ1bmN0aW9uIHRvIHRoZSBjb3JlXHJcbiAgICAgICAgICAgICAgICByZWZfb2JqW29iai5uYW1lXSA9IGZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG9iai52aXNpYmxlKVxyXG4gICAgICAgICAgICAgICAgXy5mdW5jdGlvbnNbb2JqLm5hbWVdID0gW2ZuLCBvYmoubnVtYXJnc107IC8vbWFrZSB0aGUgZnVuY3Rpb24gYXZhaWxhYmxlXHJcblxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB2YXJpYWJsZSBuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdmFsaWRhdGVzIGlmIHRoZSBwcm9maWRlZCBzdHJpbmcgaXMgYSB2YWxpZCB2YXJpYWJsZSBuYW1lXHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhcm5hbWUgdmFyaWFibGUgbmFtZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHZhbGlkYXRlcyBpZiB0aGUgcHJvZmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgdmFyaWFibGUgbmFtZVxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLnZhbGlkVmFyTmFtZSA9IGZ1bmN0aW9uICh2YXJuYW1lKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFsaWRhdGVOYW1lKHZhcm5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gUkVTRVJWRUQuaW5kZXhPZih2YXJuYW1lKSA9PT0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBmdW5jdGlvbnMgY3VycmVudGx5IHN1cHBvcnRlZCBieSBuZXJkYW1lclxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLnN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ga2V5cyhfLmZ1bmN0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgZXF1YXRpb25zL2V4cHJlc3Npb25zIGN1cnJlbnRseSBsb2FkZWRcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5udW1FcXVhdGlvbnMgPSBsaWJFeHBvcnRzLm51bUV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBFWFBSRVNTSU9OUy5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgLyogRU5EIEVYUE9SVFMgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdiB2YXJpYWJsZSB0byBiZSBzZXRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgdmFsdWUgb2YgdmFyaWFibGUuIFRoaXMgY2FuIGJlIGEgdmFyaWFibGUgZXhwcmVzc2lvbiBvciBudW1iZXJcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5lcmRhbWVyIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLnNldFZhciA9IGZ1bmN0aW9uICh2LCB2YWwpIHtcclxuICAgICAgICB2YWxpZGF0ZU5hbWUodik7XHJcbiAgICAgICAgLy9jaGVjayBpZiBpdCdzIG5vdCBhbHJlYWR5IGEgY29uc3RhbnRcclxuICAgICAgICBpZih2IGluIF8uQ09OU1RBTlRTKVxyXG4gICAgICAgICAgICBlcnIoJ0Nhbm5vdCBzZXQgdmFsdWUgZm9yIGNvbnN0YW50ICcgKyB2KTtcclxuICAgICAgICBpZih2YWwgPT09ICdkZWxldGUnIHx8IHZhbCA9PT0gJycpXHJcbiAgICAgICAgICAgIGRlbGV0ZSBWQVJTW3ZdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBWQVJTW3ZdID0gaXNTeW1ib2wodmFsKSA/IHZhbCA6IF8ucGFyc2UodmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBzZXQgdmFyaWFibGVcclxuICAgICAqIEBwYXJhbSB7dHlwZX0gdlxyXG4gICAgICogQHJldHVybnMge3Zhcmllc31cclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5nZXRWYXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBWQVJTW3ZdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgdGhlIHZhcmlhYmxlcyBmcm9tIHRoZSBWQVJTIG9iamVjdFxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmVyZGFtZXIgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuY2xlYXJWYXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIFZBUlMgPSB7fTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbG9hZGVyXHJcbiAgICAgKiBAcmV0dXJucyB7bmVyZGFtZXJ9XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcclxuICAgICAgICBsb2FkZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0IC0gb3V0cHV0IGZvcm1hdC4gQ2FuIGJlICdvYmplY3QnIChqdXN0IHJldHVybnMgdGhlIFZBUlMgb2JqZWN0KSwgJ3RleHQnIG9yICdsYXRleCcuIERlZmF1bHQ6ICd0ZXh0J1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IG9wdGlvblxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgdmFyaWFibGVzXHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuZ2V0VmFycyA9IGZ1bmN0aW9uIChvdXRwdXQsIG9wdGlvbikge1xyXG4gICAgICAgIG91dHB1dCA9IG91dHB1dCB8fCAndGV4dCc7XHJcbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHt9O1xyXG4gICAgICAgIGlmKG91dHB1dCA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIHZhcmlhYmxlcyA9IFZBUlM7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgdiBpbiBWQVJTKSB7XHJcbiAgICAgICAgICAgICAgICBpZihvdXRwdXQgPT09ICdsYXRleCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNbdl0gPSBWQVJTW3ZdLmxhdGV4KG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKG91dHB1dCA9PT0gJ3RleHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzW3ZdID0gVkFSU1t2XS50ZXh0KG9wdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIGEgc2V0dGluZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNldHRpbmcgVGhlIHNldHRpbmcgdG8gYmUgY2hhbmdlZFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLnNldCA9IGZ1bmN0aW9uIChzZXR0aW5nLCB2YWx1ZSkge1xyXG4gICAgICAgIC8vY3VycmVudCBvcHRpb25zOlxyXG4gICAgICAgIC8vUEFSU0UyTlVNQkVSLCBzdXBwcmVzc19lcnJvcnNcclxuICAgICAgICBpZih0eXBlb2Ygc2V0dGluZyA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIGZvcih2YXIgeCBpbiBzZXR0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBsaWJFeHBvcnRzLnNldCh4LCBzZXR0aW5nW3hdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGlzYWxsb3dlZCA9IFsnU0FGRSddO1xyXG4gICAgICAgIGlmKGRpc2FsbG93ZWQuaW5kZXhPZihzZXR0aW5nKSAhPT0gLTEpXHJcbiAgICAgICAgICAgIGVycignQ2Fubm90IG1vZGlmeSBzZXR0aW5nOiAnICsgc2V0dGluZyk7XHJcblxyXG4gICAgICAgIGlmKHNldHRpbmcgPT09ICdQUkVDSVNJT04nKSB7XHJcbiAgICAgICAgICAgIGJpZ0RlYy5zZXQoe3ByZWNpc2lvbjogdmFsdWV9KTtcclxuICAgICAgICAgICAgU2V0dGluZ3MuUFJFQ0lTSU9OID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAvLyBBdm9pZCB0aGF0IG5lcmRhbWVyIHB1dHMgb3V0IGdhcmJhZ2UgYWZ0ZXIgMjEgZGVjaW1hbCBwbGFjZVxyXG4gICAgICAgICAgICBpZih2YWx1ZSA+IDIxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldCgnVVNFX0JJRycsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoc2V0dGluZyA9PT0gJ1VTRV9MTicgJiYgdmFsdWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgLy9zZXQgbG9nIGFzIExOXHJcbiAgICAgICAgICAgIFNldHRpbmdzLkxPRyA9ICdMTic7XHJcbiAgICAgICAgICAgIC8vc2V0IGxvZzEwIGFzIGxvZ1xyXG4gICAgICAgICAgICBTZXR0aW5ncy5MT0cxMCA9ICdsb2cnO1xyXG4gICAgICAgICAgICAvL3BvaW50IHRoZSBmdW5jdGlvbnMgaW4gdGhlIHJpZ2h0IGRpcmVjdGlvblxyXG4gICAgICAgICAgICBfLmZ1bmN0aW9uc1snbG9nJ10gPSBTZXR0aW5ncy5MT0dfRk5TLmxvZzEwOyAvL2xvZyBpcyBub3cgbG9nMTBcclxuICAgICAgICAgICAgLy90aGUgbG9nMTAgZnVuY3Rpb24gbXVzdCBiZSBleHBsaWNpdGx5IHNldFxyXG4gICAgICAgICAgICBfLmZ1bmN0aW9uc1snbG9nJ11bMF0gPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgaWYoeC5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5sb2cxMCh4KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbihTZXR0aW5ncy5MT0cxMCwgW3hdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXy5mdW5jdGlvbnNbJ0xOJ10gPSBTZXR0aW5ncy5MT0dfRk5TLmxvZzsgLy9MTiBpcyBub3cgbG9nXHJcblxyXG4gICAgICAgICAgICAvL3JlbW92ZSBsb2cxMFxyXG4gICAgICAgICAgICBkZWxldGUgXy5mdW5jdGlvbnNbJ2xvZzEwJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgU2V0dGluZ3Nbc2V0dGluZ10gPSB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgc2V0dGluZ1xyXG4gICAgICogQHBhcmFtIHt0eXBlfSBzZXR0aW5nXHJcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmdldCA9IGZ1bmN0aW9uIChzZXR0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIFNldHRpbmdzW3NldHRpbmddO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb25zIG1ha2VzIGludGVybmFsIGZ1bmN0aW9ucyBhdmFpbGFibGUgZXh0ZXJuYWxseVxyXG4gICAgICogQHBhcmFtIHtib29sfSBvdmVycmlkZSBPdmVycmlkZSB0aGUgZnVuY3Rpb25zIHdoZW4gY2FsbGluZyBhcGkgaWYgaXQgZXhpc3RzXHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuYXBpID0gZnVuY3Rpb24gKG92ZXJyaWRlKSB7XHJcbiAgICAgICAgLy9NYXAgaW50ZXJuYWwgZnVuY3Rpb25zIHRvIGV4dGVybmFsIG9uZXNcclxuICAgICAgICB2YXIgbGlua2VyID0gZnVuY3Rpb24gKGZuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBfLnBhcnNlKGFyZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKGJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uY2FsbGZ1bmN0aW9uKGZuYW1lLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vcGVyZm9ybSB0aGUgbWFwcGluZ1xyXG4gICAgICAgIGZvcih2YXIgeCBpbiBfLmZ1bmN0aW9ucylcclxuICAgICAgICAgICAgaWYoISh4IGluIGxpYkV4cG9ydHMpIHx8IG92ZXJyaWRlKVxyXG4gICAgICAgICAgICAgICAgbGliRXhwb3J0c1t4XSA9IGxpbmtlcih4KTtcclxuICAgIH07XHJcblxyXG4gICAgbGliRXhwb3J0cy5yZXBsYWNlRnVuY3Rpb24gPSBmdW5jdGlvbiAobmFtZSwgZm4sIG51bV9hcmdzKSB7XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gXy5mdW5jdGlvbnNbbmFtZV07XHJcbiAgICAgICAgdmFyIG5ld19udW1fYXJncyA9IHR5cGVvZiBudW1fYXJncyA9PT0gJ3VuZGVmaW5lZCcgPyBleGlzdGluZ1sxXSA6IG51bV9hcmdzO1xyXG4gICAgICAgIF8uZnVuY3Rpb25zW25hbWVdID0gW2ZuLmNhbGwodW5kZWZpbmVkLCBleGlzdGluZ1swXSwgQyksIG5ld19udW1fYXJnc107XHJcbiAgICB9O1xyXG5cclxuICAgIGxpYkV4cG9ydHMuc2V0T3BlcmF0b3IgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHNoaWZ0KSB7XHJcbiAgICAgICAgXy5zZXRPcGVyYXRvcihvcGVyYXRvciwgc2hpZnQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLmdldE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uZ2V0T3BlcmF0b3Iob3BlcmF0b3IpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLmFsaWFzT3BlcmF0b3IgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHdpdGhPcGVyYXRvcikge1xyXG4gICAgICAgIF8uYWxpYXNPcGVyYXRvcihvcGVyYXRvciwgd2l0aE9wZXJhdG9yKTtcclxuICAgIH07XHJcblxyXG4gICAgbGliRXhwb3J0cy50cmVlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcclxuICAgICAgICByZXR1cm4gXy50cmVlKF8udG9SUE4oXy50b2tlbml6ZShleHByZXNzaW9uKSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLmh0bWxUcmVlID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGluZGVudCkge1xyXG4gICAgICAgIHZhciB0cmVlID0gdGhpcy50cmVlKGV4cHJlc3Npb24pO1xyXG5cclxuICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJ0cmVlXCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDx1bD5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgICAgIDxsaT5cXG4nICtcclxuICAgICAgICAgICAgICAgIHRyZWUudG9IVE1MKDMsIGluZGVudCkgKyAnXFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgICAgICA8L2xpPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8L3VsPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XHJcbiAgICB9O1xyXG5cclxuICAgIGxpYkV4cG9ydHMuYWRkUGVla2VyID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcclxuICAgICAgICBpZihfLnBlZWtlcnNbbmFtZV0pXHJcbiAgICAgICAgICAgIF8ucGVla2Vyc1tuYW1lXS5wdXNoKGYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLnJlbW92ZVBlZWtlciA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XHJcbiAgICAgICAgcmVtb3ZlKF8ucGVla2Vyc1tuYW1lXSwgZik7XHJcbiAgICB9O1xyXG5cclxuICAgIGxpYkV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoZSkuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoeCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxpYkV4cG9ydHMuYXBpKCk7XHJcblxyXG4gICAgcmV0dXJuIGxpYkV4cG9ydHM7IC8vRG9uZVxyXG4vL2ltcG9ydHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG59KSh7XHJcbiAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9wZXRlcm9sc29uL0JpZ0ludGVnZXIuanNcclxuICAgIGJpZ0ludDogKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGJpZ0ludD1mdW5jdGlvbih1bmRlZmluZWQpe1widXNlIHN0cmljdFwiO3ZhciBCQVNFPTFlNyxMT0dfQkFTRT03LE1BWF9JTlQ9OTAwNzE5OTI1NDc0MDk5MixNQVhfSU5UX0FSUj1zbWFsbFRvQXJyYXkoTUFYX0lOVCksTE9HX01BWF9JTlQ9TWF0aC5sb2coTUFYX0lOVCk7ZnVuY3Rpb24gSW50ZWdlcih2LHJhZGl4KXtpZih0eXBlb2Ygdj09PVwidW5kZWZpbmVkXCIpcmV0dXJuIEludGVnZXJbMF07aWYodHlwZW9mIHJhZGl4IT09XCJ1bmRlZmluZWRcIilyZXR1cm4rcmFkaXg9PT0xMD9wYXJzZVZhbHVlKHYpOnBhcnNlQmFzZSh2LHJhZGl4KTtyZXR1cm4gcGFyc2VWYWx1ZSh2KX1mdW5jdGlvbiBCaWdJbnRlZ2VyKHZhbHVlLHNpZ24pe3RoaXMudmFsdWU9dmFsdWU7dGhpcy5zaWduPXNpZ247dGhpcy5pc1NtYWxsPWZhbHNlfUJpZ0ludGVnZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO2Z1bmN0aW9uIFNtYWxsSW50ZWdlcih2YWx1ZSl7dGhpcy52YWx1ZT12YWx1ZTt0aGlzLnNpZ249dmFsdWU8MDt0aGlzLmlzU21hbGw9dHJ1ZX1TbWFsbEludGVnZXIucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO2Z1bmN0aW9uIGlzUHJlY2lzZShuKXtyZXR1cm4tTUFYX0lOVDxuJiZuPE1BWF9JTlR9ZnVuY3Rpb24gc21hbGxUb0FycmF5KG4pe2lmKG48MWU3KXJldHVybltuXTtpZihuPDFlMTQpcmV0dXJuW24lMWU3LE1hdGguZmxvb3Iobi8xZTcpXTtyZXR1cm5bbiUxZTcsTWF0aC5mbG9vcihuLzFlNyklMWU3LE1hdGguZmxvb3Iobi8xZTE0KV19ZnVuY3Rpb24gYXJyYXlUb1NtYWxsKGFycil7dHJpbShhcnIpO3ZhciBsZW5ndGg9YXJyLmxlbmd0aDtpZihsZW5ndGg8NCYmY29tcGFyZUFicyhhcnIsTUFYX0lOVF9BUlIpPDApe3N3aXRjaChsZW5ndGgpe2Nhc2UgMDpyZXR1cm4gMDtjYXNlIDE6cmV0dXJuIGFyclswXTtjYXNlIDI6cmV0dXJuIGFyclswXSthcnJbMV0qQkFTRTtkZWZhdWx0OnJldHVybiBhcnJbMF0rKGFyclsxXSthcnJbMl0qQkFTRSkqQkFTRX19cmV0dXJuIGFycn1mdW5jdGlvbiB0cmltKHYpe3ZhciBpPXYubGVuZ3RoO3doaWxlKHZbLS1pXT09PTApO3YubGVuZ3RoPWkrMX1mdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpe3ZhciB4PW5ldyBBcnJheShsZW5ndGgpO3ZhciBpPS0xO3doaWxlKCsraTxsZW5ndGgpe3hbaV09MH1yZXR1cm4geH1mdW5jdGlvbiB0cnVuY2F0ZShuKXtpZihuPjApcmV0dXJuIE1hdGguZmxvb3Iobik7cmV0dXJuIE1hdGguY2VpbChuKX1mdW5jdGlvbiBhZGQoYSxiKXt2YXIgbF9hPWEubGVuZ3RoLGxfYj1iLmxlbmd0aCxyPW5ldyBBcnJheShsX2EpLGNhcnJ5PTAsYmFzZT1CQVNFLHN1bSxpO2ZvcihpPTA7aTxsX2I7aSsrKXtzdW09YVtpXStiW2ldK2NhcnJ5O2NhcnJ5PXN1bT49YmFzZT8xOjA7cltpXT1zdW0tY2FycnkqYmFzZX13aGlsZShpPGxfYSl7c3VtPWFbaV0rY2Fycnk7Y2Fycnk9c3VtPT09YmFzZT8xOjA7cltpKytdPXN1bS1jYXJyeSpiYXNlfWlmKGNhcnJ5PjApci5wdXNoKGNhcnJ5KTtyZXR1cm4gcn1mdW5jdGlvbiBhZGRBbnkoYSxiKXtpZihhLmxlbmd0aD49Yi5sZW5ndGgpcmV0dXJuIGFkZChhLGIpO3JldHVybiBhZGQoYixhKX1mdW5jdGlvbiBhZGRTbWFsbChhLGNhcnJ5KXt2YXIgbD1hLmxlbmd0aCxyPW5ldyBBcnJheShsKSxiYXNlPUJBU0Usc3VtLGk7Zm9yKGk9MDtpPGw7aSsrKXtzdW09YVtpXS1iYXNlK2NhcnJ5O2NhcnJ5PU1hdGguZmxvb3Ioc3VtL2Jhc2UpO3JbaV09c3VtLWNhcnJ5KmJhc2U7Y2FycnkrPTF9d2hpbGUoY2Fycnk+MCl7cltpKytdPWNhcnJ5JWJhc2U7Y2Fycnk9TWF0aC5mbG9vcihjYXJyeS9iYXNlKX1yZXR1cm4gcn1CaWdJbnRlZ2VyLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KTtpZih0aGlzLnNpZ24hPT1uLnNpZ24pe3JldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpfXZhciBhPXRoaXMudmFsdWUsYj1uLnZhbHVlO2lmKG4uaXNTbWFsbCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGEsTWF0aC5hYnMoYikpLHRoaXMuc2lnbil9cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZEFueShhLGIpLHRoaXMuc2lnbil9O0JpZ0ludGVnZXIucHJvdG90eXBlLnBsdXM9QmlnSW50ZWdlci5wcm90b3R5cGUuYWRkO1NtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodik7dmFyIGE9dGhpcy52YWx1ZTtpZihhPDAhPT1uLnNpZ24pe3JldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpfXZhciBiPW4udmFsdWU7aWYobi5pc1NtYWxsKXtpZihpc1ByZWNpc2UoYStiKSlyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhK2IpO2I9c21hbGxUb0FycmF5KE1hdGguYWJzKGIpKX1yZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwoYixNYXRoLmFicyhhKSksYTwwKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wbHVzPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkO2Z1bmN0aW9uIHN1YnRyYWN0KGEsYil7dmFyIGFfbD1hLmxlbmd0aCxiX2w9Yi5sZW5ndGgscj1uZXcgQXJyYXkoYV9sKSxib3Jyb3c9MCxiYXNlPUJBU0UsaSxkaWZmZXJlbmNlO2ZvcihpPTA7aTxiX2w7aSsrKXtkaWZmZXJlbmNlPWFbaV0tYm9ycm93LWJbaV07aWYoZGlmZmVyZW5jZTwwKXtkaWZmZXJlbmNlKz1iYXNlO2JvcnJvdz0xfWVsc2UgYm9ycm93PTA7cltpXT1kaWZmZXJlbmNlfWZvcihpPWJfbDtpPGFfbDtpKyspe2RpZmZlcmVuY2U9YVtpXS1ib3Jyb3c7aWYoZGlmZmVyZW5jZTwwKWRpZmZlcmVuY2UrPWJhc2U7ZWxzZXtyW2krK109ZGlmZmVyZW5jZTticmVha31yW2ldPWRpZmZlcmVuY2V9Zm9yKDtpPGFfbDtpKyspe3JbaV09YVtpXX10cmltKHIpO3JldHVybiByfWZ1bmN0aW9uIHN1YnRyYWN0QW55KGEsYixzaWduKXt2YXIgdmFsdWU7aWYoY29tcGFyZUFicyhhLGIpPj0wKXt2YWx1ZT1zdWJ0cmFjdChhLGIpfWVsc2V7dmFsdWU9c3VidHJhY3QoYixhKTtzaWduPSFzaWdufXZhbHVlPWFycmF5VG9TbWFsbCh2YWx1ZSk7aWYodHlwZW9mIHZhbHVlPT09XCJudW1iZXJcIil7aWYoc2lnbil2YWx1ZT0tdmFsdWU7cmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpfXJldHVybiBuZXcgQmlnSW50ZWdlcih2YWx1ZSxzaWduKX1mdW5jdGlvbiBzdWJ0cmFjdFNtYWxsKGEsYixzaWduKXt2YXIgbD1hLmxlbmd0aCxyPW5ldyBBcnJheShsKSxjYXJyeT0tYixiYXNlPUJBU0UsaSxkaWZmZXJlbmNlO2ZvcihpPTA7aTxsO2krKyl7ZGlmZmVyZW5jZT1hW2ldK2NhcnJ5O2NhcnJ5PU1hdGguZmxvb3IoZGlmZmVyZW5jZS9iYXNlKTtkaWZmZXJlbmNlJT1iYXNlO3JbaV09ZGlmZmVyZW5jZTwwP2RpZmZlcmVuY2UrYmFzZTpkaWZmZXJlbmNlfXI9YXJyYXlUb1NtYWxsKHIpO2lmKHR5cGVvZiByPT09XCJudW1iZXJcIil7aWYoc2lnbilyPS1yO3JldHVybiBuZXcgU21hbGxJbnRlZ2VyKHIpfXJldHVybiBuZXcgQmlnSW50ZWdlcihyLHNpZ24pfUJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodik7aWYodGhpcy5zaWduIT09bi5zaWduKXtyZXR1cm4gdGhpcy5hZGQobi5uZWdhdGUoKSl9dmFyIGE9dGhpcy52YWx1ZSxiPW4udmFsdWU7aWYobi5pc1NtYWxsKXJldHVybiBzdWJ0cmFjdFNtYWxsKGEsTWF0aC5hYnMoYiksdGhpcy5zaWduKTtyZXR1cm4gc3VidHJhY3RBbnkoYSxiLHRoaXMuc2lnbil9O0JpZ0ludGVnZXIucHJvdG90eXBlLm1pbnVzPUJpZ0ludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KTt2YXIgYT10aGlzLnZhbHVlO2lmKGE8MCE9PW4uc2lnbil7cmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpfXZhciBiPW4udmFsdWU7aWYobi5pc1NtYWxsKXtyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhLWIpfXJldHVybiBzdWJ0cmFjdFNtYWxsKGIsTWF0aC5hYnMoYSksYT49MCl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubWludXM9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwhdGhpcy5zaWduKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGU9ZnVuY3Rpb24oKXt2YXIgc2lnbj10aGlzLnNpZ247dmFyIHNtYWxsPW5ldyBTbWFsbEludGVnZXIoLXRoaXMudmFsdWUpO3NtYWxsLnNpZ249IXNpZ247cmV0dXJuIHNtYWxsfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSxmYWxzZSl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTbWFsbEludGVnZXIoTWF0aC5hYnModGhpcy52YWx1ZSkpfTtmdW5jdGlvbiBtdWx0aXBseUxvbmcoYSxiKXt2YXIgYV9sPWEubGVuZ3RoLGJfbD1iLmxlbmd0aCxsPWFfbCtiX2wscj1jcmVhdGVBcnJheShsKSxiYXNlPUJBU0UscHJvZHVjdCxjYXJyeSxpLGFfaSxiX2o7Zm9yKGk9MDtpPGFfbDsrK2kpe2FfaT1hW2ldO2Zvcih2YXIgaj0wO2o8Yl9sOysrail7Yl9qPWJbal07cHJvZHVjdD1hX2kqYl9qK3JbaStqXTtjYXJyeT1NYXRoLmZsb29yKHByb2R1Y3QvYmFzZSk7cltpK2pdPXByb2R1Y3QtY2FycnkqYmFzZTtyW2kraisxXSs9Y2Fycnl9fXRyaW0ocik7cmV0dXJuIHJ9ZnVuY3Rpb24gbXVsdGlwbHlTbWFsbChhLGIpe3ZhciBsPWEubGVuZ3RoLHI9bmV3IEFycmF5KGwpLGJhc2U9QkFTRSxjYXJyeT0wLHByb2R1Y3QsaTtmb3IoaT0wO2k8bDtpKyspe3Byb2R1Y3Q9YVtpXSpiK2NhcnJ5O2NhcnJ5PU1hdGguZmxvb3IocHJvZHVjdC9iYXNlKTtyW2ldPXByb2R1Y3QtY2FycnkqYmFzZX13aGlsZShjYXJyeT4wKXtyW2krK109Y2FycnklYmFzZTtjYXJyeT1NYXRoLmZsb29yKGNhcnJ5L2Jhc2UpfXJldHVybiByfWZ1bmN0aW9uIHNoaWZ0TGVmdCh4LG4pe3ZhciByPVtdO3doaWxlKG4tLSA+MClyLnB1c2goMCk7cmV0dXJuIHIuY29uY2F0KHgpfWZ1bmN0aW9uIG11bHRpcGx5S2FyYXRzdWJhKHgseSl7dmFyIG49TWF0aC5tYXgoeC5sZW5ndGgseS5sZW5ndGgpO2lmKG48PTMwKXJldHVybiBtdWx0aXBseUxvbmcoeCx5KTtuPU1hdGguY2VpbChuLzIpO3ZhciBiPXguc2xpY2UobiksYT14LnNsaWNlKDAsbiksZD15LnNsaWNlKG4pLGM9eS5zbGljZSgwLG4pO3ZhciBhYz1tdWx0aXBseUthcmF0c3ViYShhLGMpLGJkPW11bHRpcGx5S2FyYXRzdWJhKGIsZCksYWJjZD1tdWx0aXBseUthcmF0c3ViYShhZGRBbnkoYSxiKSxhZGRBbnkoYyxkKSk7dmFyIHByb2R1Y3Q9YWRkQW55KGFkZEFueShhYyxzaGlmdExlZnQoc3VidHJhY3Qoc3VidHJhY3QoYWJjZCxhYyksYmQpLG4pKSxzaGlmdExlZnQoYmQsMipuKSk7dHJpbShwcm9kdWN0KTtyZXR1cm4gcHJvZHVjdH1mdW5jdGlvbiB1c2VLYXJhdHN1YmEobDEsbDIpe3JldHVybi0uMDEyKmwxLS4wMTIqbDIrMTVlLTYqbDEqbDI+MH1CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih2KXt2YXIgbj1wYXJzZVZhbHVlKHYpLGE9dGhpcy52YWx1ZSxiPW4udmFsdWUsc2lnbj10aGlzLnNpZ24hPT1uLnNpZ24sYWJzO2lmKG4uaXNTbWFsbCl7aWYoYj09PTApcmV0dXJuIEludGVnZXJbMF07aWYoYj09PTEpcmV0dXJuIHRoaXM7aWYoYj09PS0xKXJldHVybiB0aGlzLm5lZ2F0ZSgpO2Ficz1NYXRoLmFicyhiKTtpZihhYnM8QkFTRSl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYSxhYnMpLHNpZ24pfWI9c21hbGxUb0FycmF5KGFicyl9aWYodXNlS2FyYXRzdWJhKGEubGVuZ3RoLGIubGVuZ3RoKSlyZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlLYXJhdHN1YmEoYSxiKSxzaWduKTtyZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGEsYiksc2lnbil9O0JpZ0ludGVnZXIucHJvdG90eXBlLnRpbWVzPUJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O2Z1bmN0aW9uIG11bHRpcGx5U21hbGxBbmRBcnJheShhLGIsc2lnbil7aWYoYTxCQVNFKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlTbWFsbChiLGEpLHNpZ24pfXJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUxvbmcoYixzbWFsbFRvQXJyYXkoYSkpLHNpZ24pfVNtYWxsSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbD1mdW5jdGlvbihhKXtpZihpc1ByZWNpc2UoYS52YWx1ZSp0aGlzLnZhbHVlKSl7cmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYS52YWx1ZSp0aGlzLnZhbHVlKX1yZXR1cm4gbXVsdGlwbHlTbWFsbEFuZEFycmF5KE1hdGguYWJzKGEudmFsdWUpLHNtYWxsVG9BcnJheShNYXRoLmFicyh0aGlzLnZhbHVlKSksdGhpcy5zaWduIT09YS5zaWduKX07QmlnSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbD1mdW5jdGlvbihhKXtpZihhLnZhbHVlPT09MClyZXR1cm4gSW50ZWdlclswXTtpZihhLnZhbHVlPT09MSlyZXR1cm4gdGhpcztpZihhLnZhbHVlPT09LTEpcmV0dXJuIHRoaXMubmVnYXRlKCk7cmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSx0aGlzLnZhbHVlLHRoaXMuc2lnbiE9PWEuc2lnbil9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odil7cmV0dXJuIHBhcnNlVmFsdWUodikuX211bHRpcGx5QnlTbWFsbCh0aGlzKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS50aW1lcz1TbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5O2Z1bmN0aW9uIHNxdWFyZShhKXt2YXIgbD1hLmxlbmd0aCxyPWNyZWF0ZUFycmF5KGwrbCksYmFzZT1CQVNFLHByb2R1Y3QsY2FycnksaSxhX2ksYV9qO2ZvcihpPTA7aTxsO2krKyl7YV9pPWFbaV07Y2Fycnk9MC1hX2kqYV9pO2Zvcih2YXIgaj1pO2o8bDtqKyspe2Ffaj1hW2pdO3Byb2R1Y3Q9MiooYV9pKmFfaikrcltpK2pdK2NhcnJ5O2NhcnJ5PU1hdGguZmxvb3IocHJvZHVjdC9iYXNlKTtyW2kral09cHJvZHVjdC1jYXJyeSpiYXNlfXJbaStsXT1jYXJyeX10cmltKHIpO3JldHVybiByfUJpZ0ludGVnZXIucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbigpe3JldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUodGhpcy52YWx1ZSksZmFsc2UpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbigpe3ZhciB2YWx1ZT10aGlzLnZhbHVlKnRoaXMudmFsdWU7aWYoaXNQcmVjaXNlKHZhbHVlKSlyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSk7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHNxdWFyZShzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpKSxmYWxzZSl9O2Z1bmN0aW9uIGRpdk1vZDEoYSxiKXt2YXIgYV9sPWEubGVuZ3RoLGJfbD1iLmxlbmd0aCxiYXNlPUJBU0UscmVzdWx0PWNyZWF0ZUFycmF5KGIubGVuZ3RoKSxkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQ9YltiX2wtMV0sbGFtYmRhPU1hdGguY2VpbChiYXNlLygyKmRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCkpLHJlbWFpbmRlcj1tdWx0aXBseVNtYWxsKGEsbGFtYmRhKSxkaXZpc29yPW11bHRpcGx5U21hbGwoYixsYW1iZGEpLHF1b3RpZW50RGlnaXQsc2hpZnQsY2FycnksYm9ycm93LGksbCxxO2lmKHJlbWFpbmRlci5sZW5ndGg8PWFfbClyZW1haW5kZXIucHVzaCgwKTtkaXZpc29yLnB1c2goMCk7ZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0PWRpdmlzb3JbYl9sLTFdO2ZvcihzaGlmdD1hX2wtYl9sO3NoaWZ0Pj0wO3NoaWZ0LS0pe3F1b3RpZW50RGlnaXQ9YmFzZS0xO2lmKHJlbWFpbmRlcltzaGlmdCtiX2xdIT09ZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KXtxdW90aWVudERpZ2l0PU1hdGguZmxvb3IoKHJlbWFpbmRlcltzaGlmdCtiX2xdKmJhc2UrcmVtYWluZGVyW3NoaWZ0K2JfbC0xXSkvZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KX1jYXJyeT0wO2JvcnJvdz0wO2w9ZGl2aXNvci5sZW5ndGg7Zm9yKGk9MDtpPGw7aSsrKXtjYXJyeSs9cXVvdGllbnREaWdpdCpkaXZpc29yW2ldO3E9TWF0aC5mbG9vcihjYXJyeS9iYXNlKTtib3Jyb3crPXJlbWFpbmRlcltzaGlmdCtpXS0oY2FycnktcSpiYXNlKTtjYXJyeT1xO2lmKGJvcnJvdzwwKXtyZW1haW5kZXJbc2hpZnQraV09Ym9ycm93K2Jhc2U7Ym9ycm93PS0xfWVsc2V7cmVtYWluZGVyW3NoaWZ0K2ldPWJvcnJvdztib3Jyb3c9MH19d2hpbGUoYm9ycm93IT09MCl7cXVvdGllbnREaWdpdC09MTtjYXJyeT0wO2ZvcihpPTA7aTxsO2krKyl7Y2FycnkrPXJlbWFpbmRlcltzaGlmdCtpXS1iYXNlK2Rpdmlzb3JbaV07aWYoY2Fycnk8MCl7cmVtYWluZGVyW3NoaWZ0K2ldPWNhcnJ5K2Jhc2U7Y2Fycnk9MH1lbHNle3JlbWFpbmRlcltzaGlmdCtpXT1jYXJyeTtjYXJyeT0xfX1ib3Jyb3crPWNhcnJ5fXJlc3VsdFtzaGlmdF09cXVvdGllbnREaWdpdH1yZW1haW5kZXI9ZGl2TW9kU21hbGwocmVtYWluZGVyLGxhbWJkYSlbMF07cmV0dXJuW2FycmF5VG9TbWFsbChyZXN1bHQpLGFycmF5VG9TbWFsbChyZW1haW5kZXIpXX1mdW5jdGlvbiBkaXZNb2QyKGEsYil7dmFyIGFfbD1hLmxlbmd0aCxiX2w9Yi5sZW5ndGgscmVzdWx0PVtdLHBhcnQ9W10sYmFzZT1CQVNFLGd1ZXNzLHhsZW4saGlnaHgsaGlnaHksY2hlY2s7d2hpbGUoYV9sKXtwYXJ0LnVuc2hpZnQoYVstLWFfbF0pO3RyaW0ocGFydCk7aWYoY29tcGFyZUFicyhwYXJ0LGIpPDApe3Jlc3VsdC5wdXNoKDApO2NvbnRpbnVlfXhsZW49cGFydC5sZW5ndGg7aGlnaHg9cGFydFt4bGVuLTFdKmJhc2UrcGFydFt4bGVuLTJdO2hpZ2h5PWJbYl9sLTFdKmJhc2UrYltiX2wtMl07aWYoeGxlbj5iX2wpe2hpZ2h4PShoaWdoeCsxKSpiYXNlfWd1ZXNzPU1hdGguY2VpbChoaWdoeC9oaWdoeSk7ZG97Y2hlY2s9bXVsdGlwbHlTbWFsbChiLGd1ZXNzKTtpZihjb21wYXJlQWJzKGNoZWNrLHBhcnQpPD0wKWJyZWFrO2d1ZXNzLS19d2hpbGUoZ3Vlc3MpO3Jlc3VsdC5wdXNoKGd1ZXNzKTtwYXJ0PXN1YnRyYWN0KHBhcnQsY2hlY2spfXJlc3VsdC5yZXZlcnNlKCk7cmV0dXJuW2FycmF5VG9TbWFsbChyZXN1bHQpLGFycmF5VG9TbWFsbChwYXJ0KV19ZnVuY3Rpb24gZGl2TW9kU21hbGwodmFsdWUsbGFtYmRhKXt2YXIgbGVuZ3RoPXZhbHVlLmxlbmd0aCxxdW90aWVudD1jcmVhdGVBcnJheShsZW5ndGgpLGJhc2U9QkFTRSxpLHEscmVtYWluZGVyLGRpdmlzb3I7cmVtYWluZGVyPTA7Zm9yKGk9bGVuZ3RoLTE7aT49MDstLWkpe2Rpdmlzb3I9cmVtYWluZGVyKmJhc2UrdmFsdWVbaV07cT10cnVuY2F0ZShkaXZpc29yL2xhbWJkYSk7cmVtYWluZGVyPWRpdmlzb3ItcSpsYW1iZGE7cXVvdGllbnRbaV09cXwwfXJldHVybltxdW90aWVudCxyZW1haW5kZXJ8MF19ZnVuY3Rpb24gZGl2TW9kQW55KHNlbGYsdil7dmFyIHZhbHVlLG49cGFyc2VWYWx1ZSh2KTt2YXIgYT1zZWxmLnZhbHVlLGI9bi52YWx1ZTt2YXIgcXVvdGllbnQ7aWYoYj09PTApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRpdmlkZSBieSB6ZXJvXCIpO2lmKHNlbGYuaXNTbWFsbCl7aWYobi5pc1NtYWxsKXtyZXR1cm5bbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZShhL2IpKSxuZXcgU21hbGxJbnRlZ2VyKGElYildfXJldHVybltJbnRlZ2VyWzBdLHNlbGZdfWlmKG4uaXNTbWFsbCl7aWYoYj09PTEpcmV0dXJuW3NlbGYsSW50ZWdlclswXV07aWYoYj09LTEpcmV0dXJuW3NlbGYubmVnYXRlKCksSW50ZWdlclswXV07dmFyIGFicz1NYXRoLmFicyhiKTtpZihhYnM8QkFTRSl7dmFsdWU9ZGl2TW9kU21hbGwoYSxhYnMpO3F1b3RpZW50PWFycmF5VG9TbWFsbCh2YWx1ZVswXSk7dmFyIHJlbWFpbmRlcj12YWx1ZVsxXTtpZihzZWxmLnNpZ24pcmVtYWluZGVyPS1yZW1haW5kZXI7aWYodHlwZW9mIHF1b3RpZW50PT09XCJudW1iZXJcIil7aWYoc2VsZi5zaWduIT09bi5zaWduKXF1b3RpZW50PS1xdW90aWVudDtyZXR1cm5bbmV3IFNtYWxsSW50ZWdlcihxdW90aWVudCksbmV3IFNtYWxsSW50ZWdlcihyZW1haW5kZXIpXX1yZXR1cm5bbmV3IEJpZ0ludGVnZXIocXVvdGllbnQsc2VsZi5zaWduIT09bi5zaWduKSxuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildfWI9c21hbGxUb0FycmF5KGFicyl9dmFyIGNvbXBhcmlzb249Y29tcGFyZUFicyhhLGIpO2lmKGNvbXBhcmlzb249PT0tMSlyZXR1cm5bSW50ZWdlclswXSxzZWxmXTtpZihjb21wYXJpc29uPT09MClyZXR1cm5bSW50ZWdlcltzZWxmLnNpZ249PT1uLnNpZ24/MTotMV0sSW50ZWdlclswXV07aWYoYS5sZW5ndGgrYi5sZW5ndGg8PTIwMCl2YWx1ZT1kaXZNb2QxKGEsYik7ZWxzZSB2YWx1ZT1kaXZNb2QyKGEsYik7cXVvdGllbnQ9dmFsdWVbMF07dmFyIHFTaWduPXNlbGYuc2lnbiE9PW4uc2lnbixtb2Q9dmFsdWVbMV0sbVNpZ249c2VsZi5zaWduO2lmKHR5cGVvZiBxdW90aWVudD09PVwibnVtYmVyXCIpe2lmKHFTaWduKXF1b3RpZW50PS1xdW90aWVudDtxdW90aWVudD1uZXcgU21hbGxJbnRlZ2VyKHF1b3RpZW50KX1lbHNlIHF1b3RpZW50PW5ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LHFTaWduKTtpZih0eXBlb2YgbW9kPT09XCJudW1iZXJcIil7aWYobVNpZ24pbW9kPS1tb2Q7bW9kPW5ldyBTbWFsbEludGVnZXIobW9kKX1lbHNlIG1vZD1uZXcgQmlnSW50ZWdlcihtb2QsbVNpZ24pO3JldHVybltxdW90aWVudCxtb2RdfUJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZD1mdW5jdGlvbih2KXt2YXIgcmVzdWx0PWRpdk1vZEFueSh0aGlzLHYpO3JldHVybntxdW90aWVudDpyZXN1bHRbMF0scmVtYWluZGVyOnJlc3VsdFsxXX19O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2bW9kPUJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZDtCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGU9ZnVuY3Rpb24odil7cmV0dXJuIGRpdk1vZEFueSh0aGlzLHYpWzBdfTtTbWFsbEludGVnZXIucHJvdG90eXBlLm92ZXI9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGU9QmlnSW50ZWdlci5wcm90b3R5cGUub3Zlcj1CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZpZGU7QmlnSW50ZWdlci5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHYpe3JldHVybiBkaXZNb2RBbnkodGhpcyx2KVsxXX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXI9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2Q9QmlnSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyPUJpZ0ludGVnZXIucHJvdG90eXBlLm1vZDtCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KSxhPXRoaXMudmFsdWUsYj1uLnZhbHVlLHZhbHVlLHgseTtpZihiPT09MClyZXR1cm4gSW50ZWdlclsxXTtpZihhPT09MClyZXR1cm4gSW50ZWdlclswXTtpZihhPT09MSlyZXR1cm4gSW50ZWdlclsxXTtpZihhPT09LTEpcmV0dXJuIG4uaXNFdmVuKCk/SW50ZWdlclsxXTpJbnRlZ2VyWy0xXTtpZihuLnNpZ24pe3JldHVybiBJbnRlZ2VyWzBdfWlmKCFuLmlzU21hbGwpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGV4cG9uZW50IFwiK24udG9TdHJpbmcoKStcIiBpcyB0b28gbGFyZ2UuXCIpO2lmKHRoaXMuaXNTbWFsbCl7aWYoaXNQcmVjaXNlKHZhbHVlPU1hdGgucG93KGEsYikpKXJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKHZhbHVlKSl9eD10aGlzO3k9SW50ZWdlclsxXTt3aGlsZSh0cnVlKXtpZihiJjE9PT0xKXt5PXkudGltZXMoeCk7LS1ifWlmKGI9PT0wKWJyZWFrO2IvPTI7eD14LnNxdWFyZSgpfXJldHVybiB5fTtTbWFsbEludGVnZXIucHJvdG90eXBlLnBvdz1CaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3c7QmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93PWZ1bmN0aW9uKGV4cCxtb2Qpe2V4cD1wYXJzZVZhbHVlKGV4cCk7bW9kPXBhcnNlVmFsdWUobW9kKTtpZihtb2QuaXNaZXJvKCkpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRha2UgbW9kUG93IHdpdGggbW9kdWx1cyAwXCIpO3ZhciByPUludGVnZXJbMV0sYmFzZT10aGlzLm1vZChtb2QpO3doaWxlKGV4cC5pc1Bvc2l0aXZlKCkpe2lmKGJhc2UuaXNaZXJvKCkpcmV0dXJuIEludGVnZXJbMF07aWYoZXhwLmlzT2RkKCkpcj1yLm11bHRpcGx5KGJhc2UpLm1vZChtb2QpO2V4cD1leHAuZGl2aWRlKDIpO2Jhc2U9YmFzZS5zcXVhcmUoKS5tb2QobW9kKX1yZXR1cm4gcn07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3c9QmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93O2Z1bmN0aW9uIGNvbXBhcmVBYnMoYSxiKXtpZihhLmxlbmd0aCE9PWIubGVuZ3RoKXtyZXR1cm4gYS5sZW5ndGg+Yi5sZW5ndGg/MTotMX1mb3IodmFyIGk9YS5sZW5ndGgtMTtpPj0wO2ktLSl7aWYoYVtpXSE9PWJbaV0pcmV0dXJuIGFbaV0+YltpXT8xOi0xfXJldHVybiAwfUJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnM9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KSxhPXRoaXMudmFsdWUsYj1uLnZhbHVlO2lmKG4uaXNTbWFsbClyZXR1cm4gMTtyZXR1cm4gY29tcGFyZUFicyhhLGIpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnM9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KSxhPU1hdGguYWJzKHRoaXMudmFsdWUpLGI9bi52YWx1ZTtpZihuLmlzU21hbGwpe2I9TWF0aC5hYnMoYik7cmV0dXJuIGE9PT1iPzA6YT5iPzE6LTF9cmV0dXJuLTF9O0JpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24odil7aWYodj09PUluZmluaXR5KXtyZXR1cm4tMX1pZih2PT09LUluZmluaXR5KXtyZXR1cm4gMX12YXIgbj1wYXJzZVZhbHVlKHYpLGE9dGhpcy52YWx1ZSxiPW4udmFsdWU7aWYodGhpcy5zaWduIT09bi5zaWduKXtyZXR1cm4gbi5zaWduPzE6LTF9aWYobi5pc1NtYWxsKXtyZXR1cm4gdGhpcy5zaWduPy0xOjF9cmV0dXJuIGNvbXBhcmVBYnMoYSxiKSoodGhpcy5zaWduPy0xOjEpfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG89QmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24odil7aWYodj09PUluZmluaXR5KXtyZXR1cm4tMX1pZih2PT09LUluZmluaXR5KXtyZXR1cm4gMX12YXIgbj1wYXJzZVZhbHVlKHYpLGE9dGhpcy52YWx1ZSxiPW4udmFsdWU7aWYobi5pc1NtYWxsKXtyZXR1cm4gYT09Yj8wOmE+Yj8xOi0xfWlmKGE8MCE9PW4uc2lnbil7cmV0dXJuIGE8MD8tMToxfXJldHVybiBhPDA/MTotMX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG89U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlO0JpZ0ludGVnZXIucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbih2KXtyZXR1cm4gdGhpcy5jb21wYXJlKHYpPT09MH07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5lcT1TbWFsbEludGVnZXIucHJvdG90eXBlLmVxdWFscz1CaWdJbnRlZ2VyLnByb3RvdHlwZS5lcT1CaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHM7QmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzPWZ1bmN0aW9uKHYpe3JldHVybiB0aGlzLmNvbXBhcmUodikhPT0wfTtTbWFsbEludGVnZXIucHJvdG90eXBlLm5lcT1TbWFsbEludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscz1CaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXE9QmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzO0JpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odil7cmV0dXJuIHRoaXMuY29tcGFyZSh2KT4wfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmd0PVNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlcj1CaWdJbnRlZ2VyLnByb3RvdHlwZS5ndD1CaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyO0JpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlcj1mdW5jdGlvbih2KXtyZXR1cm4gdGhpcy5jb21wYXJlKHYpPDB9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubHQ9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXI9QmlnSW50ZWdlci5wcm90b3R5cGUubHQ9QmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyO0JpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscz1mdW5jdGlvbih2KXtyZXR1cm4gdGhpcy5jb21wYXJlKHYpPj0wfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmdlcT1TbWFsbEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscz1CaWdJbnRlZ2VyLnByb3RvdHlwZS5nZXE9QmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzO0JpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzPWZ1bmN0aW9uKHYpe3JldHVybiB0aGlzLmNvbXBhcmUodik8PTB9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubGVxPVNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHM9QmlnSW50ZWdlci5wcm90b3R5cGUubGVxPUJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzO0JpZ0ludGVnZXIucHJvdG90eXBlLmlzRXZlbj1mdW5jdGlvbigpe3JldHVybih0aGlzLnZhbHVlWzBdJjEpPT09MH07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW49ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy52YWx1ZSYxKT09PTB9O0JpZ0ludGVnZXIucHJvdG90eXBlLmlzT2RkPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMudmFsdWVbMF0mMSk9PT0xfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmlzT2RkPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMudmFsdWUmMSk9PT0xfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuc2lnbn07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWU+MH07QmlnSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpZ259O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNOZWdhdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlPDB9O0JpZ0ludGVnZXIucHJvdG90eXBlLmlzVW5pdD1mdW5jdGlvbigpe3JldHVybiBmYWxzZX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQ9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5hYnModGhpcy52YWx1ZSk9PT0xfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4gZmFsc2V9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWU9PT0wfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5PWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodik7dmFyIHZhbHVlPW4udmFsdWU7aWYodmFsdWU9PT0wKXJldHVybiBmYWxzZTtpZih2YWx1ZT09PTEpcmV0dXJuIHRydWU7aWYodmFsdWU9PT0yKXJldHVybiB0aGlzLmlzRXZlbigpO3JldHVybiB0aGlzLm1vZChuKS5lcXVhbHMoSW50ZWdlclswXSl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeT1CaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5O2Z1bmN0aW9uIGlzQmFzaWNQcmltZSh2KXt2YXIgbj12LmFicygpO2lmKG4uaXNVbml0KCkpcmV0dXJuIGZhbHNlO2lmKG4uZXF1YWxzKDIpfHxuLmVxdWFscygzKXx8bi5lcXVhbHMoNSkpcmV0dXJuIHRydWU7aWYobi5pc0V2ZW4oKXx8bi5pc0RpdmlzaWJsZUJ5KDMpfHxuLmlzRGl2aXNpYmxlQnkoNSkpcmV0dXJuIGZhbHNlO2lmKG4ubGVzc2VyKDQ5KSlyZXR1cm4gdHJ1ZX1mdW5jdGlvbiBtaWxsZXJSYWJpblRlc3QobixhKXt2YXIgblByZXY9bi5wcmV2KCksYj1uUHJldixyPTAsZCx0LGkseDt3aGlsZShiLmlzRXZlbigpKWI9Yi5kaXZpZGUoMikscisrO25leHQ6Zm9yKGk9MDtpPGEubGVuZ3RoO2krKyl7aWYobi5sZXNzZXIoYVtpXSkpY29udGludWU7eD1iaWdJbnQoYVtpXSkubW9kUG93KGIsbik7aWYoeC5lcXVhbHMoSW50ZWdlclsxXSl8fHguZXF1YWxzKG5QcmV2KSljb250aW51ZTtmb3IoZD1yLTE7ZCE9MDtkLS0pe3g9eC5zcXVhcmUoKS5tb2Qobik7aWYoeC5pc1VuaXQoKSlyZXR1cm4gZmFsc2U7aWYoeC5lcXVhbHMoblByZXYpKWNvbnRpbnVlIG5leHR9cmV0dXJuIGZhbHNlfXJldHVybiB0cnVlfUJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJpbWU9ZnVuY3Rpb24oc3RyaWN0KXt2YXIgaXNQcmltZT1pc0Jhc2ljUHJpbWUodGhpcyk7aWYoaXNQcmltZSE9PXVuZGVmaW5lZClyZXR1cm4gaXNQcmltZTt2YXIgbj10aGlzLmFicygpO3ZhciBiaXRzPW4uYml0TGVuZ3RoKCk7aWYoYml0czw9NjQpcmV0dXJuIG1pbGxlclJhYmluVGVzdChuLFsyLDMyNSw5Mzc1LDI4MTc4LDQ1MDc3NSw5NzgwNTA0LDE3OTUyNjUwMjJdKTt2YXIgbG9nTj1NYXRoLmxvZygyKSpiaXRzO3ZhciB0PU1hdGguY2VpbChzdHJpY3Q9PT10cnVlPzIqTWF0aC5wb3cobG9nTiwyKTpsb2dOKTtmb3IodmFyIGE9W10saT0wO2k8dDtpKyspe2EucHVzaChiaWdJbnQoaSsyKSl9cmV0dXJuIG1pbGxlclJhYmluVGVzdChuLGEpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJpbWU9QmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU9ZnVuY3Rpb24oaXRlcmF0aW9ucyl7dmFyIGlzUHJpbWU9aXNCYXNpY1ByaW1lKHRoaXMpO2lmKGlzUHJpbWUhPT11bmRlZmluZWQpcmV0dXJuIGlzUHJpbWU7dmFyIG49dGhpcy5hYnMoKTt2YXIgdD1pdGVyYXRpb25zPT09dW5kZWZpbmVkPzU6aXRlcmF0aW9ucztmb3IodmFyIGE9W10saT0wO2k8dDtpKyspe2EucHVzaChiaWdJbnQucmFuZEJldHdlZW4oMixuLm1pbnVzKDIpKSl9cmV0dXJuIG1pbGxlclJhYmluVGVzdChuLGEpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZT1CaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU7QmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52PWZ1bmN0aW9uKG4pe3ZhciB0PWJpZ0ludC56ZXJvLG5ld1Q9YmlnSW50Lm9uZSxyPXBhcnNlVmFsdWUobiksbmV3Uj10aGlzLmFicygpLHEsbGFzdFQsbGFzdFI7d2hpbGUoIW5ld1IuZXF1YWxzKGJpZ0ludC56ZXJvKSl7cT1yLmRpdmlkZShuZXdSKTtsYXN0VD10O2xhc3RSPXI7dD1uZXdUO3I9bmV3UjtuZXdUPWxhc3RULnN1YnRyYWN0KHEubXVsdGlwbHkobmV3VCkpO25ld1I9bGFzdFIuc3VidHJhY3QocS5tdWx0aXBseShuZXdSKSl9aWYoIXIuZXF1YWxzKDEpKXRocm93IG5ldyBFcnJvcih0aGlzLnRvU3RyaW5nKCkrXCIgYW5kIFwiK24udG9TdHJpbmcoKStcIiBhcmUgbm90IGNvLXByaW1lXCIpO2lmKHQuY29tcGFyZSgwKT09PS0xKXt0PXQuYWRkKG4pfWlmKHRoaXMuaXNOZWdhdGl2ZSgpKXtyZXR1cm4gdC5uZWdhdGUoKX1yZXR1cm4gdH07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnY9QmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52O0JpZ0ludGVnZXIucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXt2YXIgdmFsdWU9dGhpcy52YWx1ZTtpZih0aGlzLnNpZ24pe3JldHVybiBzdWJ0cmFjdFNtYWxsKHZhbHVlLDEsdGhpcy5zaWduKX1yZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwodmFsdWUsMSksdGhpcy5zaWduKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHZhbHVlPXRoaXMudmFsdWU7aWYodmFsdWUrMTxNQVhfSU5UKXJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKzEpO3JldHVybiBuZXcgQmlnSW50ZWdlcihNQVhfSU5UX0FSUixmYWxzZSl9O0JpZ0ludGVnZXIucHJvdG90eXBlLnByZXY9ZnVuY3Rpb24oKXt2YXIgdmFsdWU9dGhpcy52YWx1ZTtpZih0aGlzLnNpZ24pe3JldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbCh2YWx1ZSwxKSx0cnVlKX1yZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwxLHRoaXMuc2lnbil9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUucHJldj1mdW5jdGlvbigpe3ZhciB2YWx1ZT10aGlzLnZhbHVlO2lmKHZhbHVlLTE+LU1BWF9JTlQpcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUtMSk7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKE1BWF9JTlRfQVJSLHRydWUpfTt2YXIgcG93ZXJzT2ZUd289WzFdO3doaWxlKDIqcG93ZXJzT2ZUd29bcG93ZXJzT2ZUd28ubGVuZ3RoLTFdPD1CQVNFKXBvd2Vyc09mVHdvLnB1c2goMipwb3dlcnNPZlR3b1twb3dlcnNPZlR3by5sZW5ndGgtMV0pO3ZhciBwb3dlcnMyTGVuZ3RoPXBvd2Vyc09mVHdvLmxlbmd0aCxoaWdoZXN0UG93ZXIyPXBvd2Vyc09mVHdvW3Bvd2VyczJMZW5ndGgtMV07ZnVuY3Rpb24gc2hpZnRfaXNTbWFsbChuKXtyZXR1cm4odHlwZW9mIG49PT1cIm51bWJlclwifHx0eXBlb2Ygbj09PVwic3RyaW5nXCIpJiYrTWF0aC5hYnMobik8PUJBU0V8fG4gaW5zdGFuY2VvZiBCaWdJbnRlZ2VyJiZuLnZhbHVlLmxlbmd0aDw9MX1CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQ9ZnVuY3Rpb24obil7aWYoIXNoaWZ0X2lzU21hbGwobikpe3Rocm93IG5ldyBFcnJvcihTdHJpbmcobikrXCIgaXMgdG9vIGxhcmdlIGZvciBzaGlmdGluZy5cIil9bj0rbjtpZihuPDApcmV0dXJuIHRoaXMuc2hpZnRSaWdodCgtbik7dmFyIHJlc3VsdD10aGlzO2lmKHJlc3VsdC5pc1plcm8oKSlyZXR1cm4gcmVzdWx0O3doaWxlKG4+PXBvd2VyczJMZW5ndGgpe3Jlc3VsdD1yZXN1bHQubXVsdGlwbHkoaGlnaGVzdFBvd2VyMik7bi09cG93ZXJzMkxlbmd0aC0xfXJldHVybiByZXN1bHQubXVsdGlwbHkocG93ZXJzT2ZUd29bbl0pfTtTbWFsbEludGVnZXIucHJvdG90eXBlLnNoaWZ0TGVmdD1CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQ7QmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodD1mdW5jdGlvbihuKXt2YXIgcmVtUXVvO2lmKCFzaGlmdF9pc1NtYWxsKG4pKXt0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pK1wiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpfW49K247aWYobjwwKXJldHVybiB0aGlzLnNoaWZ0TGVmdCgtbik7dmFyIHJlc3VsdD10aGlzO3doaWxlKG4+PXBvd2VyczJMZW5ndGgpe2lmKHJlc3VsdC5pc1plcm8oKXx8cmVzdWx0LmlzTmVnYXRpdmUoKSYmcmVzdWx0LmlzVW5pdCgpKXJldHVybiByZXN1bHQ7cmVtUXVvPWRpdk1vZEFueShyZXN1bHQsaGlnaGVzdFBvd2VyMik7cmVzdWx0PXJlbVF1b1sxXS5pc05lZ2F0aXZlKCk/cmVtUXVvWzBdLnByZXYoKTpyZW1RdW9bMF07bi09cG93ZXJzMkxlbmd0aC0xfXJlbVF1bz1kaXZNb2RBbnkocmVzdWx0LHBvd2Vyc09mVHdvW25dKTtyZXR1cm4gcmVtUXVvWzFdLmlzTmVnYXRpdmUoKT9yZW1RdW9bMF0ucHJldigpOnJlbVF1b1swXX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0PUJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQ7ZnVuY3Rpb24gYml0d2lzZSh4LHksZm4pe3k9cGFyc2VWYWx1ZSh5KTt2YXIgeFNpZ249eC5pc05lZ2F0aXZlKCkseVNpZ249eS5pc05lZ2F0aXZlKCk7dmFyIHhSZW09eFNpZ24/eC5ub3QoKTp4LHlSZW09eVNpZ24/eS5ub3QoKTp5O3ZhciB4RGlnaXQ9MCx5RGlnaXQ9MDt2YXIgeERpdk1vZD1udWxsLHlEaXZNb2Q9bnVsbDt2YXIgcmVzdWx0PVtdO3doaWxlKCF4UmVtLmlzWmVybygpfHwheVJlbS5pc1plcm8oKSl7eERpdk1vZD1kaXZNb2RBbnkoeFJlbSxoaWdoZXN0UG93ZXIyKTt4RGlnaXQ9eERpdk1vZFsxXS50b0pTTnVtYmVyKCk7aWYoeFNpZ24pe3hEaWdpdD1oaWdoZXN0UG93ZXIyLTEteERpZ2l0fXlEaXZNb2Q9ZGl2TW9kQW55KHlSZW0saGlnaGVzdFBvd2VyMik7eURpZ2l0PXlEaXZNb2RbMV0udG9KU051bWJlcigpO2lmKHlTaWduKXt5RGlnaXQ9aGlnaGVzdFBvd2VyMi0xLXlEaWdpdH14UmVtPXhEaXZNb2RbMF07eVJlbT15RGl2TW9kWzBdO3Jlc3VsdC5wdXNoKGZuKHhEaWdpdCx5RGlnaXQpKX12YXIgc3VtPWZuKHhTaWduPzE6MCx5U2lnbj8xOjApIT09MD9iaWdJbnQoLTEpOmJpZ0ludCgwKTtmb3IodmFyIGk9cmVzdWx0Lmxlbmd0aC0xO2k+PTA7aS09MSl7c3VtPXN1bS5tdWx0aXBseShoaWdoZXN0UG93ZXIyKS5hZGQoYmlnSW50KHJlc3VsdFtpXSkpfXJldHVybiBzdW19QmlnSW50ZWdlci5wcm90b3R5cGUubm90PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmVnYXRlKCkucHJldigpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLm5vdD1CaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3Q7QmlnSW50ZWdlci5wcm90b3R5cGUuYW5kPWZ1bmN0aW9uKG4pe3JldHVybiBiaXR3aXNlKHRoaXMsbixmdW5jdGlvbihhLGIpe3JldHVybiBhJmJ9KX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5hbmQ9QmlnSW50ZWdlci5wcm90b3R5cGUuYW5kO0JpZ0ludGVnZXIucHJvdG90eXBlLm9yPWZ1bmN0aW9uKG4pe3JldHVybiBiaXR3aXNlKHRoaXMsbixmdW5jdGlvbihhLGIpe3JldHVybiBhfGJ9KX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vcj1CaWdJbnRlZ2VyLnByb3RvdHlwZS5vcjtCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3I9ZnVuY3Rpb24obil7cmV0dXJuIGJpdHdpc2UodGhpcyxuLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGFeYn0pfTtTbWFsbEludGVnZXIucHJvdG90eXBlLnhvcj1CaWdJbnRlZ2VyLnByb3RvdHlwZS54b3I7dmFyIExPQk1BU0tfST0xPDwzMCxMT0JNQVNLX0JJPShCQVNFJi1CQVNFKSooQkFTRSYtQkFTRSl8TE9CTUFTS19JO2Z1bmN0aW9uIHJvdWdoTE9CKG4pe3ZhciB2PW4udmFsdWUseD10eXBlb2Ygdj09PVwibnVtYmVyXCI/dnxMT0JNQVNLX0k6dlswXSt2WzFdKkJBU0V8TE9CTUFTS19CSTtyZXR1cm4geCYteH1mdW5jdGlvbiBpbnRlZ2VyTG9nYXJpdGhtKHZhbHVlLGJhc2Upe2lmKGJhc2UuY29tcGFyZVRvKHZhbHVlKTw9MCl7dmFyIHRtcD1pbnRlZ2VyTG9nYXJpdGhtKHZhbHVlLGJhc2Uuc3F1YXJlKGJhc2UpKTt2YXIgcD10bXAucDt2YXIgZT10bXAuZTt2YXIgdD1wLm11bHRpcGx5KGJhc2UpO3JldHVybiB0LmNvbXBhcmVUbyh2YWx1ZSk8PTA/e3A6dCxlOmUqMisxfTp7cDpwLGU6ZSoyfX1yZXR1cm57cDpiaWdJbnQoMSksZTowfX1CaWdJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGg9ZnVuY3Rpb24oKXt2YXIgbj10aGlzO2lmKG4uY29tcGFyZVRvKGJpZ0ludCgwKSk8MCl7bj1uLm5lZ2F0ZSgpLnN1YnRyYWN0KGJpZ0ludCgxKSl9aWYobi5jb21wYXJlVG8oYmlnSW50KDApKT09PTApe3JldHVybiBiaWdJbnQoMCl9cmV0dXJuIGJpZ0ludChpbnRlZ2VyTG9nYXJpdGhtKG4sYmlnSW50KDIpKS5lKS5hZGQoYmlnSW50KDEpKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5iaXRMZW5ndGg9QmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoO2Z1bmN0aW9uIG1heChhLGIpe2E9cGFyc2VWYWx1ZShhKTtiPXBhcnNlVmFsdWUoYik7cmV0dXJuIGEuZ3JlYXRlcihiKT9hOmJ9ZnVuY3Rpb24gbWluKGEsYil7YT1wYXJzZVZhbHVlKGEpO2I9cGFyc2VWYWx1ZShiKTtyZXR1cm4gYS5sZXNzZXIoYik/YTpifWZ1bmN0aW9uIGdjZChhLGIpe2E9cGFyc2VWYWx1ZShhKS5hYnMoKTtiPXBhcnNlVmFsdWUoYikuYWJzKCk7aWYoYS5lcXVhbHMoYikpcmV0dXJuIGE7aWYoYS5pc1plcm8oKSlyZXR1cm4gYjtpZihiLmlzWmVybygpKXJldHVybiBhO3ZhciBjPUludGVnZXJbMV0sZCx0O3doaWxlKGEuaXNFdmVuKCkmJmIuaXNFdmVuKCkpe2Q9TWF0aC5taW4ocm91Z2hMT0IoYSkscm91Z2hMT0IoYikpO2E9YS5kaXZpZGUoZCk7Yj1iLmRpdmlkZShkKTtjPWMubXVsdGlwbHkoZCl9d2hpbGUoYS5pc0V2ZW4oKSl7YT1hLmRpdmlkZShyb3VnaExPQihhKSl9ZG97d2hpbGUoYi5pc0V2ZW4oKSl7Yj1iLmRpdmlkZShyb3VnaExPQihiKSl9aWYoYS5ncmVhdGVyKGIpKXt0PWI7Yj1hO2E9dH1iPWIuc3VidHJhY3QoYSl9d2hpbGUoIWIuaXNaZXJvKCkpO3JldHVybiBjLmlzVW5pdCgpP2E6YS5tdWx0aXBseShjKX1mdW5jdGlvbiBsY20oYSxiKXthPXBhcnNlVmFsdWUoYSkuYWJzKCk7Yj1wYXJzZVZhbHVlKGIpLmFicygpO3JldHVybiBhLmRpdmlkZShnY2QoYSxiKSkubXVsdGlwbHkoYil9ZnVuY3Rpb24gcmFuZEJldHdlZW4oYSxiKXthPXBhcnNlVmFsdWUoYSk7Yj1wYXJzZVZhbHVlKGIpO3ZhciBsb3c9bWluKGEsYiksaGlnaD1tYXgoYSxiKTt2YXIgcmFuZ2U9aGlnaC5zdWJ0cmFjdChsb3cpLmFkZCgxKTtpZihyYW5nZS5pc1NtYWxsKXJldHVybiBsb3cuYWRkKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpyYW5nZSkpO3ZhciBsZW5ndGg9cmFuZ2UudmFsdWUubGVuZ3RoLTE7dmFyIHJlc3VsdD1bXSxyZXN0cmljdGVkPXRydWU7Zm9yKHZhciBpPWxlbmd0aDtpPj0wO2ktLSl7dmFyIHRvcD1yZXN0cmljdGVkP3JhbmdlLnZhbHVlW2ldOkJBU0U7dmFyIGRpZ2l0PXRydW5jYXRlKE1hdGgucmFuZG9tKCkqdG9wKTtyZXN1bHQudW5zaGlmdChkaWdpdCk7aWYoZGlnaXQ8dG9wKXJlc3RyaWN0ZWQ9ZmFsc2V9cmVzdWx0PWFycmF5VG9TbWFsbChyZXN1bHQpO3JldHVybiBsb3cuYWRkKHR5cGVvZiByZXN1bHQ9PT1cIm51bWJlclwiP25ldyBTbWFsbEludGVnZXIocmVzdWx0KTpuZXcgQmlnSW50ZWdlcihyZXN1bHQsZmFsc2UpKX12YXIgcGFyc2VCYXNlPWZ1bmN0aW9uKHRleHQsYmFzZSl7dmFyIGxlbmd0aD10ZXh0Lmxlbmd0aDt2YXIgaTt2YXIgYWJzQmFzZT1NYXRoLmFicyhiYXNlKTtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3ZhciBjPXRleHRbaV0udG9Mb3dlckNhc2UoKTtpZihjPT09XCItXCIpY29udGludWU7aWYoL1thLXowLTldLy50ZXN0KGMpKXtpZigvWzAtOV0vLnRlc3QoYykmJitjPj1hYnNCYXNlKXtpZihjPT09XCIxXCImJmFic0Jhc2U9PT0xKWNvbnRpbnVlO3Rocm93IG5ldyBFcnJvcihjK1wiIGlzIG5vdCBhIHZhbGlkIGRpZ2l0IGluIGJhc2UgXCIrYmFzZStcIi5cIil9ZWxzZSBpZihjLmNoYXJDb2RlQXQoMCktODc+PWFic0Jhc2Upe3Rocm93IG5ldyBFcnJvcihjK1wiIGlzIG5vdCBhIHZhbGlkIGRpZ2l0IGluIGJhc2UgXCIrYmFzZStcIi5cIil9fX1pZigyPD1iYXNlJiZiYXNlPD0zNil7aWYobGVuZ3RoPD1MT0dfTUFYX0lOVC9NYXRoLmxvZyhiYXNlKSl7dmFyIHJlc3VsdD1wYXJzZUludCh0ZXh0LGJhc2UpO2lmKGlzTmFOKHJlc3VsdCkpe3Rocm93IG5ldyBFcnJvcihjK1wiIGlzIG5vdCBhIHZhbGlkIGRpZ2l0IGluIGJhc2UgXCIrYmFzZStcIi5cIil9cmV0dXJuIG5ldyBTbWFsbEludGVnZXIocGFyc2VJbnQodGV4dCxiYXNlKSl9fWJhc2U9cGFyc2VWYWx1ZShiYXNlKTt2YXIgZGlnaXRzPVtdO3ZhciBpc05lZ2F0aXZlPXRleHRbMF09PT1cIi1cIjtmb3IoaT1pc05lZ2F0aXZlPzE6MDtpPHRleHQubGVuZ3RoO2krKyl7dmFyIGM9dGV4dFtpXS50b0xvd2VyQ2FzZSgpLGNoYXJDb2RlPWMuY2hhckNvZGVBdCgwKTtpZig0ODw9Y2hhckNvZGUmJmNoYXJDb2RlPD01NylkaWdpdHMucHVzaChwYXJzZVZhbHVlKGMpKTtlbHNlIGlmKDk3PD1jaGFyQ29kZSYmY2hhckNvZGU8PTEyMilkaWdpdHMucHVzaChwYXJzZVZhbHVlKGMuY2hhckNvZGVBdCgwKS04NykpO2Vsc2UgaWYoYz09PVwiPFwiKXt2YXIgc3RhcnQ9aTtkb3tpKyt9d2hpbGUodGV4dFtpXSE9PVwiPlwiKTtkaWdpdHMucHVzaChwYXJzZVZhbHVlKHRleHQuc2xpY2Uoc3RhcnQrMSxpKSkpfWVsc2UgdGhyb3cgbmV3IEVycm9yKGMrXCIgaXMgbm90IGEgdmFsaWQgY2hhcmFjdGVyXCIpfXJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLGJhc2UsaXNOZWdhdGl2ZSl9O2Z1bmN0aW9uIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMsYmFzZSxpc05lZ2F0aXZlKXt2YXIgdmFsPUludGVnZXJbMF0scG93PUludGVnZXJbMV0saTtmb3IoaT1kaWdpdHMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhbD12YWwuYWRkKGRpZ2l0c1tpXS50aW1lcyhwb3cpKTtwb3c9cG93LnRpbWVzKGJhc2UpfXJldHVybiBpc05lZ2F0aXZlP3ZhbC5uZWdhdGUoKTp2YWx9ZnVuY3Rpb24gc3RyaW5naWZ5KGRpZ2l0KXtpZihkaWdpdDw9MzUpe3JldHVyblwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuY2hhckF0KGRpZ2l0KX1yZXR1cm5cIjxcIitkaWdpdCtcIj5cIn1mdW5jdGlvbiB0b0Jhc2UobixiYXNlKXtiYXNlPWJpZ0ludChiYXNlKTtpZihiYXNlLmlzWmVybygpKXtpZihuLmlzWmVybygpKXJldHVybnt2YWx1ZTpbMF0saXNOZWdhdGl2ZTpmYWxzZX07dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbm9uemVybyBudW1iZXJzIHRvIGJhc2UgMC5cIil9aWYoYmFzZS5lcXVhbHMoLTEpKXtpZihuLmlzWmVybygpKXJldHVybnt2YWx1ZTpbMF0saXNOZWdhdGl2ZTpmYWxzZX07aWYobi5pc05lZ2F0aXZlKCkpcmV0dXJue3ZhbHVlOltdLmNvbmNhdC5hcHBseShbXSxBcnJheS5hcHBseShudWxsLEFycmF5KC1uKSkubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLFsxLDBdKSksaXNOZWdhdGl2ZTpmYWxzZX07dmFyIGFycj1BcnJheS5hcHBseShudWxsLEFycmF5KCtuLTEpKS5tYXAoQXJyYXkucHJvdG90eXBlLnZhbHVlT2YsWzAsMV0pO2Fyci51bnNoaWZ0KFsxXSk7cmV0dXJue3ZhbHVlOltdLmNvbmNhdC5hcHBseShbXSxhcnIpLGlzTmVnYXRpdmU6ZmFsc2V9fXZhciBuZWc9ZmFsc2U7aWYobi5pc05lZ2F0aXZlKCkmJmJhc2UuaXNQb3NpdGl2ZSgpKXtuZWc9dHJ1ZTtuPW4uYWJzKCl9aWYoYmFzZS5lcXVhbHMoMSkpe2lmKG4uaXNaZXJvKCkpcmV0dXJue3ZhbHVlOlswXSxpc05lZ2F0aXZlOmZhbHNlfTtyZXR1cm57dmFsdWU6QXJyYXkuYXBwbHkobnVsbCxBcnJheSgrbikpLm1hcChOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YsMSksaXNOZWdhdGl2ZTpuZWd9fXZhciBvdXQ9W107dmFyIGxlZnQ9bixkaXZtb2Q7d2hpbGUobGVmdC5pc05lZ2F0aXZlKCl8fGxlZnQuY29tcGFyZUFicyhiYXNlKT49MCl7ZGl2bW9kPWxlZnQuZGl2bW9kKGJhc2UpO2xlZnQ9ZGl2bW9kLnF1b3RpZW50O3ZhciBkaWdpdD1kaXZtb2QucmVtYWluZGVyO2lmKGRpZ2l0LmlzTmVnYXRpdmUoKSl7ZGlnaXQ9YmFzZS5taW51cyhkaWdpdCkuYWJzKCk7bGVmdD1sZWZ0Lm5leHQoKX1vdXQucHVzaChkaWdpdC50b0pTTnVtYmVyKCkpfW91dC5wdXNoKGxlZnQudG9KU051bWJlcigpKTtyZXR1cm57dmFsdWU6b3V0LnJldmVyc2UoKSxpc05lZ2F0aXZlOm5lZ319ZnVuY3Rpb24gdG9CYXNlU3RyaW5nKG4sYmFzZSl7dmFyIGFycj10b0Jhc2UobixiYXNlKTtyZXR1cm4oYXJyLmlzTmVnYXRpdmU/XCItXCI6XCJcIikrYXJyLnZhbHVlLm1hcChzdHJpbmdpZnkpLmpvaW4oXCJcIil9QmlnSW50ZWdlci5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihyYWRpeCl7cmV0dXJuIHRvQmFzZSh0aGlzLHJhZGl4KX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKHJhZGl4KXtyZXR1cm4gdG9CYXNlKHRoaXMscmFkaXgpfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihyYWRpeCl7aWYocmFkaXg9PT11bmRlZmluZWQpcmFkaXg9MTA7aWYocmFkaXghPT0xMClyZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMscmFkaXgpO3ZhciB2PXRoaXMudmFsdWUsbD12Lmxlbmd0aCxzdHI9U3RyaW5nKHZbLS1sXSksemVyb3M9XCIwMDAwMDAwXCIsZGlnaXQ7d2hpbGUoLS1sPj0wKXtkaWdpdD1TdHJpbmcodltsXSk7c3RyKz16ZXJvcy5zbGljZShkaWdpdC5sZW5ndGgpK2RpZ2l0fXZhciBzaWduPXRoaXMuc2lnbj9cIi1cIjpcIlwiO3JldHVybiBzaWduK3N0cn07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbihyYWRpeCl7aWYocmFkaXg9PT11bmRlZmluZWQpcmFkaXg9MTA7aWYocmFkaXghPTEwKXJldHVybiB0b0Jhc2VTdHJpbmcodGhpcyxyYWRpeCk7cmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKX07QmlnSW50ZWdlci5wcm90b3R5cGUudG9KU09OPVNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9TdHJpbmcoKX07QmlnSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiBwYXJzZUludCh0aGlzLnRvU3RyaW5nKCksMTApfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS50b0pTTnVtYmVyPUJpZ0ludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7U21hbGxJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUudG9KU051bWJlcj1TbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7ZnVuY3Rpb24gcGFyc2VTdHJpbmdWYWx1ZSh2KXtpZihpc1ByZWNpc2UoK3YpKXt2YXIgeD0rdjtpZih4PT09dHJ1bmNhdGUoeCkpcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoeCk7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIit2KX12YXIgc2lnbj12WzBdPT09XCItXCI7aWYoc2lnbil2PXYuc2xpY2UoMSk7dmFyIHNwbGl0PXYuc3BsaXQoL2UvaSk7aWYoc3BsaXQubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIitzcGxpdC5qb2luKFwiZVwiKSk7aWYoc3BsaXQubGVuZ3RoPT09Mil7dmFyIGV4cD1zcGxpdFsxXTtpZihleHBbMF09PT1cIitcIilleHA9ZXhwLnNsaWNlKDEpO2V4cD0rZXhwO2lmKGV4cCE9PXRydW5jYXRlKGV4cCl8fCFpc1ByZWNpc2UoZXhwKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiK2V4cCtcIiBpcyBub3QgYSB2YWxpZCBleHBvbmVudC5cIik7dmFyIHRleHQ9c3BsaXRbMF07dmFyIGRlY2ltYWxQbGFjZT10ZXh0LmluZGV4T2YoXCIuXCIpO2lmKGRlY2ltYWxQbGFjZT49MCl7ZXhwLT10ZXh0Lmxlbmd0aC1kZWNpbWFsUGxhY2UtMTt0ZXh0PXRleHQuc2xpY2UoMCxkZWNpbWFsUGxhY2UpK3RleHQuc2xpY2UoZGVjaW1hbFBsYWNlKzEpfWlmKGV4cDwwKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbmNsdWRlIG5lZ2F0aXZlIGV4cG9uZW50IHBhcnQgZm9yIGludGVnZXJzXCIpO3RleHQrPW5ldyBBcnJheShleHArMSkuam9pbihcIjBcIik7dj10ZXh0fXZhciBpc1ZhbGlkPS9eKFswLTldWzAtOV0qKSQvLnRlc3Qodik7aWYoIWlzVmFsaWQpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIit2KTt2YXIgcj1bXSxtYXg9di5sZW5ndGgsbD1MT0dfQkFTRSxtaW49bWF4LWw7d2hpbGUobWF4PjApe3IucHVzaCgrdi5zbGljZShtaW4sbWF4KSk7bWluLT1sO2lmKG1pbjwwKW1pbj0wO21heC09bH10cmltKHIpO3JldHVybiBuZXcgQmlnSW50ZWdlcihyLHNpZ24pfWZ1bmN0aW9uIHBhcnNlTnVtYmVyVmFsdWUodil7aWYoaXNQcmVjaXNlKHYpKXtpZih2IT09dHJ1bmNhdGUodikpdGhyb3cgbmV3IEVycm9yKHYrXCIgaXMgbm90IGFuIGludGVnZXIuXCIpO3JldHVybiBuZXcgU21hbGxJbnRlZ2VyKHYpfXJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYudG9TdHJpbmcoKSl9ZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KXtpZih0eXBlb2Ygdj09PVwibnVtYmVyXCIpe3JldHVybiBwYXJzZU51bWJlclZhbHVlKHYpfWlmKHR5cGVvZiB2PT09XCJzdHJpbmdcIil7cmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodil9cmV0dXJuIHZ9Zm9yKHZhciBpPTA7aTwxZTM7aSsrKXtJbnRlZ2VyW2ldPW5ldyBTbWFsbEludGVnZXIoaSk7aWYoaT4wKUludGVnZXJbLWldPW5ldyBTbWFsbEludGVnZXIoLWkpfUludGVnZXIub25lPUludGVnZXJbMV07SW50ZWdlci56ZXJvPUludGVnZXJbMF07SW50ZWdlci5taW51c09uZT1JbnRlZ2VyWy0xXTtJbnRlZ2VyLm1heD1tYXg7SW50ZWdlci5taW49bWluO0ludGVnZXIuZ2NkPWdjZDtJbnRlZ2VyLmxjbT1sY207SW50ZWdlci5pc0luc3RhbmNlPWZ1bmN0aW9uKHgpe3JldHVybiB4IGluc3RhbmNlb2YgQmlnSW50ZWdlcnx8eCBpbnN0YW5jZW9mIFNtYWxsSW50ZWdlcn07SW50ZWdlci5yYW5kQmV0d2Vlbj1yYW5kQmV0d2VlbjtJbnRlZ2VyLmZyb21BcnJheT1mdW5jdGlvbihkaWdpdHMsYmFzZSxpc05lZ2F0aXZlKXtyZXR1cm4gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cy5tYXAocGFyc2VWYWx1ZSkscGFyc2VWYWx1ZShiYXNlfHwxMCksaXNOZWdhdGl2ZSl9O3JldHVybiBJbnRlZ2VyfSgpO2lmKHR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiJiZtb2R1bGUuaGFzT3duUHJvcGVydHkoXCJleHBvcnRzXCIpKXttb2R1bGUuZXhwb3J0cz1iaWdJbnR9aWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFwiYmlnLWludGVnZXJcIixbXSxmdW5jdGlvbigpe3JldHVybiBiaWdJbnR9KX1cclxuICAgICAgICByZXR1cm4gYmlnSW50O1xyXG4gICAgfSkoKSxcclxuICAgIC8qXHJcbiAgICAgKiAgZGVjaW1hbC5qcyB2MTAuMi4xXHJcbiAgICAgKiAgQW4gYXJiaXRyYXJ5LXByZWNpc2lvbiBEZWNpbWFsIHR5cGUgZm9yIEphdmFTY3JpcHQuXHJcbiAgICAgKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qc1xyXG4gICAgICogIENvcHlyaWdodCAoYykgMjAyMCBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gICAgICogIE1JVCBMaWNlbmNlXHJcbiAgICAgKi9cclxuICAgIGJpZ0RlYzogZnVuY3Rpb24obil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGUsaSx0LHIscz05ZTE1LG89MWU5LHU9XCIwMTIzNDU2Nzg5YWJjZGVmXCIsYz1cIjIuMzAyNTg1MDkyOTk0MDQ1Njg0MDE3OTkxNDU0Njg0MzY0MjA3NjAxMTAxNDg4NjI4NzcyOTc2MDMzMzI3OTAwOTY3NTcyNjA5Njc3MzUyNDgwMjM1OTk3MjA1MDg5NTk4Mjk4MzQxOTY3Nzg0MDQyMjg2MjQ4NjMzNDA5NTI1NDY1MDgyODA2NzU2NjY2Mjg3MzY5MDk4NzgxNjg5NDgyOTA3MjA4MzI1NTU0NjgwODQzNzk5ODk0ODI2MjMzMTk4NTI4MzkzNTA1MzA4OTY1Mzc3NzMyNjI4ODQ2MTYzMzY2MjIyMjg3Njk4MjE5ODg2NzQ2NTQzNjY3NDc0NDA0MjQzMjc0MzY1MTU1MDQ4OTM0MzE0OTM5MzkxNDc5NjE5NDA0NDAwMjIyMTA1MTAxNzE0MTc0ODAwMzY4ODA4NDAxMjY0NzA4MDY4NTU2Nzc0MzIxNjIyODM1NTIyMDExNDgwNDY2MzcxNTY1OTEyMTM3MzQ1MDc0Nzg1Njk0NzY4MzQ2MzYxNjc5MjEwMTgwNjQ0NTA3MDY0ODAwMDI3NzUwMjY4NDkxNjc0NjU1MDU4Njg1NjkzNTY3MzQyMDY3MDU4MTEzNjQyOTIyNDU1NDQwNTc1ODkyNTcyNDIwODI0MTMxNDY5NTY4OTAxNjc1ODk0MDI1Njc3NjMxMTM1NjkxOTI5MjAzMzM3NjU4NzE0MTY2MDIzMDEwNTcwMzA4OTYzNDU3MjA3NTQ0MDM3MDg0NzQ2OTk0MDE2ODI2OTI4MjgwODQ4MTE4NDI4OTMxNDg0ODUyNDk0ODY0NDg3MTkyNzgwOTY3NjI3MTI3NTc3NTM5NzAyNzY2ODYwNTk1MjQ5NjcxNjY3NDE4MzQ4NTcwNDQyMjUwNzE5Nzk2NTAwNDcxNDk1MTA1MDQ5MjIxNDc3NjU2NzYzNjkzODY2Mjk3Njk3OTUyMjExMDcxODI2NDU0OTczNDc3MjY2MjQyNTcwOTQyOTMyMjU4Mjc5ODUwMjU4NTUwOTc4NTI2NTM4MzIwNzYwNjcyNjMxNzE2NDMwOTUwNTk5NTA4NzgwNzUyMzcxMDMzMzEwMTE5Nzg1NzU0NzMzMTU0MTQyMTgwODQyNzU0Mzg2MzU5MTc3ODExNzA1NDMwOTgyNzQ4MjM4NTA0NTY0ODAxOTA5NTYxMDI5OTI5MTgyNDMxODIzNzUyNTM1NzcwOTc1MDUzOTU2NTE4NzY5NzUxMDM3NDk3MDg4ODY5MjE4MDIwNTE4OTMzOTUwNzIzODUzOTIwNTE0NDYzNDE5NzI2NTI4NzI4Njk2NTExMDg2MjU3MTQ5MjE5ODg0OTk3ODc0ODg3Mzc3MTM0NTY4NjIwOTE2NzA1OFwiLGY9XCIzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjI4NjIwODk5ODYyODAzNDgyNTM0MjExNzA2Nzk4MjE0ODA4NjUxMzI4MjMwNjY0NzA5Mzg0NDYwOTU1MDU4MjIzMTcyNTM1OTQwODEyODQ4MTExNzQ1MDI4NDEwMjcwMTkzODUyMTEwNTU1OTY0NDYyMjk0ODk1NDkzMDM4MTk2NDQyODgxMDk3NTY2NTkzMzQ0NjEyODQ3NTY0ODIzMzc4Njc4MzE2NTI3MTIwMTkwOTE0NTY0ODU2NjkyMzQ2MDM0ODYxMDQ1NDMyNjY0ODIxMzM5MzYwNzI2MDI0OTE0MTI3MzcyNDU4NzAwNjYwNjMxNTU4ODE3NDg4MTUyMDkyMDk2MjgyOTI1NDA5MTcxNTM2NDM2Nzg5MjU5MDM2MDAxMTMzMDUzMDU0ODgyMDQ2NjUyMTM4NDE0Njk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ2MjM3OTk2Mjc0OTU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0NjM5NTIyNDczNzE5MDcwMjE3OTg2MDk0MzcwMjc3MDUzOTIxNzE3NjI5MzE3Njc1MjM4NDY3NDgxODQ2NzY2OTQwNTEzMjAwMDU2ODEyNzE0NTI2MzU2MDgyNzc4NTc3MTM0Mjc1Nzc4OTYwOTE3MzYzNzE3ODcyMTQ2ODQ0MDkwMTIyNDk1MzQzMDE0NjU0OTU4NTM3MTA1MDc5MjI3OTY4OTI1ODkyMzU0MjAxOTk1NjExMjEyOTAyMTk2MDg2NDAzNDQxODE1OTgxMzYyOTc3NDc3MTMwOTk2MDUxODcwNzIxMTM0OTk5OTk5ODM3Mjk3ODA0OTk1MTA1OTczMTczMjgxNjA5NjMxODU5NTAyNDQ1OTQ1NTM0NjkwODMwMjY0MjUyMjMwODI1MzM0NDY4NTAzNTI2MTkzMTE4ODE3MTAxMDAwMzEzNzgzODc1Mjg4NjU4NzUzMzIwODM4MTQyMDYxNzE3NzY2OTE0NzMwMzU5ODI1MzQ5MDQyODc1NTQ2ODczMTE1OTU2Mjg2Mzg4MjM1Mzc4NzU5Mzc1MTk1Nzc4MTg1Nzc4MDUzMjE3MTIyNjgwNjYxMzAwMTkyNzg3NjYxMTE5NTkwOTIxNjQyMDE5ODkzODA5NTI1NzIwMTA2NTQ4NTg2MzI3ODlcIixhPXtwcmVjaXNpb246MjAscm91bmRpbmc6NCxtb2R1bG86MSx0b0V4cE5lZzotNyx0b0V4cFBvczoyMSxtaW5FOi1zLG1heEU6cyxjcnlwdG86ITF9LGg9ITAsZD1cIltEZWNpbWFsRXJyb3JdIFwiLGw9ZCtcIkludmFsaWQgYXJndW1lbnQ6IFwiLHA9ZCtcIlByZWNpc2lvbiBsaW1pdCBleGNlZWRlZFwiLGc9ZCtcImNyeXB0byB1bmF2YWlsYWJsZVwiLG09TWF0aC5mbG9vcix3PU1hdGgucG93LHY9L14wYihbMDFdKyhcXC5bMDFdKik/fFxcLlswMV0rKShwWystXT9cXGQrKT8kL2ksTj0vXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaSxiPS9eMG8oWzAtN10rKFxcLlswLTddKik/fFxcLlswLTddKykocFsrLV0/XFxkKyk/JC9pLEU9L14oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLHg9MWU3LHk9NyxNPWMubGVuZ3RoLTEscT1mLmxlbmd0aC0xLE89e25hbWU6XCJbb2JqZWN0IERlY2ltYWxdXCJ9O2Z1bmN0aW9uIEQobil7dmFyIGUsaSx0LHI9bi5sZW5ndGgtMSxzPVwiXCIsbz1uWzBdO2lmKHI+MCl7Zm9yKHMrPW8sZT0xO2U8cjtlKyspdD1uW2VdK1wiXCIsKGk9eS10Lmxlbmd0aCkmJihzKz1rKGkpKSxzKz10O289bltlXSwoaT15LSh0PW8rXCJcIikubGVuZ3RoKSYmKHMrPWsoaSkpfWVsc2UgaWYoMD09PW8pcmV0dXJuXCIwXCI7Zm9yKDtvJTEwPT0wOylvLz0xMDtyZXR1cm4gcytvfWZ1bmN0aW9uIEYobixlLGkpe2lmKG4hPT1+fm58fG48ZXx8bj5pKXRocm93IEVycm9yKGwrbil9ZnVuY3Rpb24gQShuLGUsaSx0KXt2YXIgcixzLG8sdTtmb3Iocz1uWzBdO3M+PTEwO3MvPTEwKS0tZTtyZXR1cm4tLWU8MD8oZSs9eSxyPTApOihyPU1hdGguY2VpbCgoZSsxKS95KSxlJT15KSxzPXcoMTAseS1lKSx1PW5bcl0lc3wwLG51bGw9PXQ/ZTwzPygwPT1lP3U9dS8xMDB8MDoxPT1lJiYodT11LzEwfDApLG89aTw0JiY5OTk5OT09dXx8aT4zJiY0OTk5OT09dXx8NWU0PT11fHwwPT11KTpvPShpPDQmJnUrMT09c3x8aT4zJiZ1KzE9PXMvMikmJihuW3IrMV0vcy8xMDB8MCk9PXcoMTAsZS0yKS0xfHwodT09cy8yfHwwPT11KSYmMD09KG5bcisxXS9zLzEwMHwwKTplPDQ/KDA9PWU/dT11LzFlM3wwOjE9PWU/dT11LzEwMHwwOjI9PWUmJih1PXUvMTB8MCksbz0odHx8aTw0KSYmOTk5OT09dXx8IXQmJmk+MyYmNDk5OT09dSk6bz0oKHR8fGk8NCkmJnUrMT09c3x8IXQmJmk+MyYmdSsxPT1zLzIpJiYobltyKzFdL3MvMWUzfDApPT13KDEwLGUtMyktMSxvfWZ1bmN0aW9uIFMobixlLGkpe2Zvcih2YXIgdCxyLHM9WzBdLG89MCxjPW4ubGVuZ3RoO288Yzspe2ZvcihyPXMubGVuZ3RoO3ItLTspc1tyXSo9ZTtmb3Ioc1swXSs9dS5pbmRleE9mKG4uY2hhckF0KG8rKykpLHQ9MDt0PHMubGVuZ3RoO3QrKylzW3RdPmktMSYmKHZvaWQgMD09PXNbdCsxXSYmKHNbdCsxXT0wKSxzW3QrMV0rPXNbdF0vaXwwLHNbdF0lPWkpfXJldHVybiBzLnJldmVyc2UoKX1PLmFic29sdXRlVmFsdWU9Ty5hYnM9ZnVuY3Rpb24oKXt2YXIgbj1uZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtyZXR1cm4gbi5zPDAmJihuLnM9MSksUChuKX0sTy5jZWlsPWZ1bmN0aW9uKCl7cmV0dXJuIFAobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksdGhpcy5lKzEsMil9LE8uY29tcGFyZWRUbz1PLmNtcD1mdW5jdGlvbihuKXt2YXIgZSxpLHQscixzPXRoaXMsbz1zLmQsdT0obj1uZXcgcy5jb25zdHJ1Y3RvcihuKSkuZCxjPXMucyxmPW4ucztpZighb3x8IXUpcmV0dXJuIGMmJmY/YyE9PWY/YzpvPT09dT8wOiFvXmM8MD8xOi0xOk5hTjtpZighb1swXXx8IXVbMF0pcmV0dXJuIG9bMF0/Yzp1WzBdPy1mOjA7aWYoYyE9PWYpcmV0dXJuIGM7aWYocy5lIT09bi5lKXJldHVybiBzLmU+bi5lXmM8MD8xOi0xO2ZvcihlPTAsaT0odD1vLmxlbmd0aCk8KHI9dS5sZW5ndGgpP3Q6cjtlPGk7KytlKWlmKG9bZV0hPT11W2VdKXJldHVybiBvW2VdPnVbZV1eYzwwPzE6LTE7cmV0dXJuIHQ9PT1yPzA6dD5yXmM8MD8xOi0xfSxPLmNvc2luZT1PLmNvcz1mdW5jdGlvbigpe3ZhciBuLGUsaT10aGlzLHQ9aS5jb25zdHJ1Y3RvcjtyZXR1cm4gaS5kP2kuZFswXT8obj10LnByZWNpc2lvbixlPXQucm91bmRpbmcsdC5wcmVjaXNpb249bitNYXRoLm1heChpLmUsaS5zZCgpKSt5LHQucm91bmRpbmc9MSxpPWZ1bmN0aW9uKG4sZSl7dmFyIGksdCxyPWUuZC5sZW5ndGg7cjwzMj8oaT1NYXRoLmNlaWwoci8zKSx0PSgxL3ooNCxpKSkudG9TdHJpbmcoKSk6KGk9MTYsdD1cIjIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTBcIik7bi5wcmVjaXNpb24rPWksZT1KKG4sMSxlLnRpbWVzKHQpLG5ldyBuKDEpKTtmb3IodmFyIHM9aTtzLS07KXt2YXIgbz1lLnRpbWVzKGUpO2U9by50aW1lcyhvKS5taW51cyhvKS50aW1lcyg4KS5wbHVzKDEpfXJldHVybiBuLnByZWNpc2lvbi09aSxlfSh0LEcodCxpKSksdC5wcmVjaXNpb249bix0LnJvdW5kaW5nPWUsUCgyPT1yfHwzPT1yP2kubmVnKCk6aSxuLGUsITApKTpuZXcgdCgxKTpuZXcgdChOYU4pfSxPLmN1YmVSb290PU8uY2JydD1mdW5jdGlvbigpe3ZhciBuLGUsaSx0LHIscyxvLHUsYyxmLGE9dGhpcyxkPWEuY29uc3RydWN0b3I7aWYoIWEuaXNGaW5pdGUoKXx8YS5pc1plcm8oKSlyZXR1cm4gbmV3IGQoYSk7Zm9yKGg9ITEsKHM9YS5zKncoYS5zKmEsMS8zKSkmJk1hdGguYWJzKHMpIT0xLzA/dD1uZXcgZChzLnRvU3RyaW5nKCkpOihpPUQoYS5kKSwocz0oKG49YS5lKS1pLmxlbmd0aCsxKSUzKSYmKGkrPTE9PXN8fC0yPT1zP1wiMFwiOlwiMDBcIikscz13KGksMS8zKSxuPW0oKG4rMSkvMyktKG4lMz09KG48MD8tMToyKSksKHQ9bmV3IGQoaT1zPT0xLzA/XCI1ZVwiK246KGk9cy50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsaS5pbmRleE9mKFwiZVwiKSsxKStuKSkucz1hLnMpLG89KG49ZC5wcmVjaXNpb24pKzM7OylpZihmPShjPSh1PXQpLnRpbWVzKHUpLnRpbWVzKHUpKS5wbHVzKGEpLHQ9WihmLnBsdXMoYSkudGltZXModSksZi5wbHVzKGMpLG8rMiwxKSxEKHUuZCkuc2xpY2UoMCxvKT09PShpPUQodC5kKSkuc2xpY2UoMCxvKSl7aWYoXCI5OTk5XCIhPShpPWkuc2xpY2Uoby0zLG8rMSkpJiYocnx8XCI0OTk5XCIhPWkpKXsraSYmKCtpLnNsaWNlKDEpfHxcIjVcIiE9aS5jaGFyQXQoMCkpfHwoUCh0LG4rMSwxKSxlPSF0LnRpbWVzKHQpLnRpbWVzKHQpLmVxKGEpKTticmVha31pZighciYmKFAodSxuKzEsMCksdS50aW1lcyh1KS50aW1lcyh1KS5lcShhKSkpe3Q9dTticmVha31vKz00LHI9MX1yZXR1cm4gaD0hMCxQKHQsbixkLnJvdW5kaW5nLGUpfSxPLmRlY2ltYWxQbGFjZXM9Ty5kcD1mdW5jdGlvbigpe3ZhciBuLGU9dGhpcy5kLGk9TmFOO2lmKGUpe2lmKGk9KChuPWUubGVuZ3RoLTEpLW0odGhpcy5lL3kpKSp5LG49ZVtuXSlmb3IoO24lMTA9PTA7bi89MTApaS0tO2k8MCYmKGk9MCl9cmV0dXJuIGl9LE8uZGl2aWRlZEJ5PU8uZGl2PWZ1bmN0aW9uKG4pe3JldHVybiBaKHRoaXMsbmV3IHRoaXMuY29uc3RydWN0b3IobikpfSxPLmRpdmlkZWRUb0ludGVnZXJCeT1PLmRpdlRvSW50PWZ1bmN0aW9uKG4pe3ZhciBlPXRoaXMuY29uc3RydWN0b3I7cmV0dXJuIFAoWih0aGlzLG5ldyBlKG4pLDAsMSwxKSxlLnByZWNpc2lvbixlLnJvdW5kaW5nKX0sTy5lcXVhbHM9Ty5lcT1mdW5jdGlvbihuKXtyZXR1cm4gMD09PXRoaXMuY21wKG4pfSxPLmZsb29yPWZ1bmN0aW9uKCl7cmV0dXJuIFAobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksdGhpcy5lKzEsMyl9LE8uZ3JlYXRlclRoYW49Ty5ndD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5jbXAobik+MH0sTy5ncmVhdGVyVGhhbk9yRXF1YWxUbz1PLmd0ZT1mdW5jdGlvbihuKXt2YXIgZT10aGlzLmNtcChuKTtyZXR1cm4gMT09ZXx8MD09PWV9LE8uaHlwZXJib2xpY0Nvc2luZT1PLmNvc2g9ZnVuY3Rpb24oKXt2YXIgbixlLGksdCxyLHM9dGhpcyxvPXMuY29uc3RydWN0b3IsdT1uZXcgbygxKTtpZighcy5pc0Zpbml0ZSgpKXJldHVybiBuZXcgbyhzLnM/MS8wOk5hTik7aWYocy5pc1plcm8oKSlyZXR1cm4gdTtpPW8ucHJlY2lzaW9uLHQ9by5yb3VuZGluZyxvLnByZWNpc2lvbj1pK01hdGgubWF4KHMuZSxzLnNkKCkpKzQsby5yb3VuZGluZz0xLChyPXMuZC5sZW5ndGgpPDMyP2U9KDEveig0LG49TWF0aC5jZWlsKHIvMykpKS50b1N0cmluZygpOihuPTE2LGU9XCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCIpLHM9SihvLDEscy50aW1lcyhlKSxuZXcgbygxKSwhMCk7Zm9yKHZhciBjLGY9bixhPW5ldyBvKDgpO2YtLTspYz1zLnRpbWVzKHMpLHM9dS5taW51cyhjLnRpbWVzKGEubWludXMoYy50aW1lcyhhKSkpKTtyZXR1cm4gUChzLG8ucHJlY2lzaW9uPWksby5yb3VuZGluZz10LCEwKX0sTy5oeXBlcmJvbGljU2luZT1PLnNpbmg9ZnVuY3Rpb24oKXt2YXIgbixlLGksdCxyPXRoaXMscz1yLmNvbnN0cnVjdG9yO2lmKCFyLmlzRmluaXRlKCl8fHIuaXNaZXJvKCkpcmV0dXJuIG5ldyBzKHIpO2lmKGU9cy5wcmVjaXNpb24saT1zLnJvdW5kaW5nLHMucHJlY2lzaW9uPWUrTWF0aC5tYXgoci5lLHIuc2QoKSkrNCxzLnJvdW5kaW5nPTEsKHQ9ci5kLmxlbmd0aCk8MylyPUoocywyLHIsciwhMCk7ZWxzZXtuPShuPTEuNCpNYXRoLnNxcnQodCkpPjE2PzE2OjB8bixyPUoocywyLHI9ci50aW1lcygxL3ooNSxuKSksciwhMCk7Zm9yKHZhciBvLHU9bmV3IHMoNSksYz1uZXcgcygxNiksZj1uZXcgcygyMCk7bi0tOylvPXIudGltZXMocikscj1yLnRpbWVzKHUucGx1cyhvLnRpbWVzKGMudGltZXMobykucGx1cyhmKSkpKX1yZXR1cm4gcy5wcmVjaXNpb249ZSxzLnJvdW5kaW5nPWksUChyLGUsaSwhMCl9LE8uaHlwZXJib2xpY1RhbmdlbnQ9Ty50YW5oPWZ1bmN0aW9uKCl7dmFyIG4sZSxpPXRoaXMsdD1pLmNvbnN0cnVjdG9yO3JldHVybiBpLmlzRmluaXRlKCk/aS5pc1plcm8oKT9uZXcgdChpKToobj10LnByZWNpc2lvbixlPXQucm91bmRpbmcsdC5wcmVjaXNpb249bis3LHQucm91bmRpbmc9MSxaKGkuc2luaCgpLGkuY29zaCgpLHQucHJlY2lzaW9uPW4sdC5yb3VuZGluZz1lKSk6bmV3IHQoaS5zKX0sTy5pbnZlcnNlQ29zaW5lPU8uYWNvcz1mdW5jdGlvbigpe3ZhciBuLGU9dGhpcyxpPWUuY29uc3RydWN0b3IsdD1lLmFicygpLmNtcCgxKSxyPWkucHJlY2lzaW9uLHM9aS5yb3VuZGluZztyZXR1cm4tMSE9PXQ/MD09PXQ/ZS5pc05lZygpP1UoaSxyLHMpOm5ldyBpKDApOm5ldyBpKE5hTik6ZS5pc1plcm8oKT9VKGkscis0LHMpLnRpbWVzKC41KTooaS5wcmVjaXNpb249cis2LGkucm91bmRpbmc9MSxlPWUuYXNpbigpLG49VShpLHIrNCxzKS50aW1lcyguNSksaS5wcmVjaXNpb249cixpLnJvdW5kaW5nPXMsbi5taW51cyhlKSl9LE8uaW52ZXJzZUh5cGVyYm9saWNDb3NpbmU9Ty5hY29zaD1mdW5jdGlvbigpe3ZhciBuLGUsaT10aGlzLHQ9aS5jb25zdHJ1Y3RvcjtyZXR1cm4gaS5sdGUoMSk/bmV3IHQoaS5lcSgxKT8wOk5hTik6aS5pc0Zpbml0ZSgpPyhuPXQucHJlY2lzaW9uLGU9dC5yb3VuZGluZyx0LnByZWNpc2lvbj1uK01hdGgubWF4KE1hdGguYWJzKGkuZSksaS5zZCgpKSs0LHQucm91bmRpbmc9MSxoPSExLGk9aS50aW1lcyhpKS5taW51cygxKS5zcXJ0KCkucGx1cyhpKSxoPSEwLHQucHJlY2lzaW9uPW4sdC5yb3VuZGluZz1lLGkubG4oKSk6bmV3IHQoaSl9LE8uaW52ZXJzZUh5cGVyYm9saWNTaW5lPU8uYXNpbmg9ZnVuY3Rpb24oKXt2YXIgbixlLGk9dGhpcyx0PWkuY29uc3RydWN0b3I7cmV0dXJuIWkuaXNGaW5pdGUoKXx8aS5pc1plcm8oKT9uZXcgdChpKToobj10LnByZWNpc2lvbixlPXQucm91bmRpbmcsdC5wcmVjaXNpb249bisyKk1hdGgubWF4KE1hdGguYWJzKGkuZSksaS5zZCgpKSs2LHQucm91bmRpbmc9MSxoPSExLGk9aS50aW1lcyhpKS5wbHVzKDEpLnNxcnQoKS5wbHVzKGkpLGg9ITAsdC5wcmVjaXNpb249bix0LnJvdW5kaW5nPWUsaS5sbigpKX0sTy5pbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQ9Ty5hdGFuaD1mdW5jdGlvbigpe3ZhciBuLGUsaSx0LHI9dGhpcyxzPXIuY29uc3RydWN0b3I7cmV0dXJuIHIuaXNGaW5pdGUoKT9yLmU+PTA/bmV3IHMoci5hYnMoKS5lcSgxKT9yLnMvMDpyLmlzWmVybygpP3I6TmFOKToobj1zLnByZWNpc2lvbixlPXMucm91bmRpbmcsdD1yLnNkKCksTWF0aC5tYXgodCxuKTwyKi1yLmUtMT9QKG5ldyBzKHIpLG4sZSwhMCk6KHMucHJlY2lzaW9uPWk9dC1yLmUscj1aKHIucGx1cygxKSxuZXcgcygxKS5taW51cyhyKSxpK24sMSkscy5wcmVjaXNpb249bis0LHMucm91bmRpbmc9MSxyPXIubG4oKSxzLnByZWNpc2lvbj1uLHMucm91bmRpbmc9ZSxyLnRpbWVzKC41KSkpOm5ldyBzKE5hTil9LE8uaW52ZXJzZVNpbmU9Ty5hc2luPWZ1bmN0aW9uKCl7dmFyIG4sZSxpLHQscj10aGlzLHM9ci5jb25zdHJ1Y3RvcjtyZXR1cm4gci5pc1plcm8oKT9uZXcgcyhyKTooZT1yLmFicygpLmNtcCgxKSxpPXMucHJlY2lzaW9uLHQ9cy5yb3VuZGluZywtMSE9PWU/MD09PWU/KChuPVUocyxpKzQsdCkudGltZXMoLjUpKS5zPXIucyxuKTpuZXcgcyhOYU4pOihzLnByZWNpc2lvbj1pKzYscy5yb3VuZGluZz0xLHI9ci5kaXYobmV3IHMoMSkubWludXMoci50aW1lcyhyKSkuc3FydCgpLnBsdXMoMSkpLmF0YW4oKSxzLnByZWNpc2lvbj1pLHMucm91bmRpbmc9dCxyLnRpbWVzKDIpKSl9LE8uaW52ZXJzZVRhbmdlbnQ9Ty5hdGFuPWZ1bmN0aW9uKCl7dmFyIG4sZSxpLHQscixzLG8sdSxjLGY9dGhpcyxhPWYuY29uc3RydWN0b3IsZD1hLnByZWNpc2lvbixsPWEucm91bmRpbmc7aWYoZi5pc0Zpbml0ZSgpKXtpZihmLmlzWmVybygpKXJldHVybiBuZXcgYShmKTtpZihmLmFicygpLmVxKDEpJiZkKzQ8PXEpcmV0dXJuKG89VShhLGQrNCxsKS50aW1lcyguMjUpKS5zPWYucyxvfWVsc2V7aWYoIWYucylyZXR1cm4gbmV3IGEoTmFOKTtpZihkKzQ8PXEpcmV0dXJuKG89VShhLGQrNCxsKS50aW1lcyguNSkpLnM9Zi5zLG99Zm9yKGEucHJlY2lzaW9uPXU9ZCsxMCxhLnJvdW5kaW5nPTEsbj1pPU1hdGgubWluKDI4LHUveSsyfDApO247LS1uKWY9Zi5kaXYoZi50aW1lcyhmKS5wbHVzKDEpLnNxcnQoKS5wbHVzKDEpKTtmb3IoaD0hMSxlPU1hdGguY2VpbCh1L3kpLHQ9MSxjPWYudGltZXMoZiksbz1uZXcgYShmKSxyPWY7LTEhPT1uOylpZihyPXIudGltZXMoYykscz1vLm1pbnVzKHIuZGl2KHQrPTIpKSxyPXIudGltZXMoYyksdm9pZCAwIT09KG89cy5wbHVzKHIuZGl2KHQrPTIpKSkuZFtlXSlmb3Iobj1lO28uZFtuXT09PXMuZFtuXSYmbi0tOyk7cmV0dXJuIGkmJihvPW8udGltZXMoMjw8aS0xKSksaD0hMCxQKG8sYS5wcmVjaXNpb249ZCxhLnJvdW5kaW5nPWwsITApfSxPLmlzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmR9LE8uaXNJbnRlZ2VyPU8uaXNJbnQ9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuZCYmbSh0aGlzLmUveSk+dGhpcy5kLmxlbmd0aC0yfSxPLmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuc30sTy5pc05lZ2F0aXZlPU8uaXNOZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zPDB9LE8uaXNQb3NpdGl2ZT1PLmlzUG9zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucz4wfSxPLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5kJiYwPT09dGhpcy5kWzBdfSxPLmxlc3NUaGFuPU8ubHQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuY21wKG4pPDB9LE8ubGVzc1RoYW5PckVxdWFsVG89Ty5sdGU9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuY21wKG4pPDF9LE8ubG9nYXJpdGhtPU8ubG9nPWZ1bmN0aW9uKG4pe3ZhciBlLGksdCxyLHMsbyx1LGMsZj10aGlzLmNvbnN0cnVjdG9yLGE9Zi5wcmVjaXNpb24sZD1mLnJvdW5kaW5nO2lmKG51bGw9PW4pbj1uZXcgZigxMCksZT0hMDtlbHNle2lmKGk9KG49bmV3IGYobikpLmQsbi5zPDB8fCFpfHwhaVswXXx8bi5lcSgxKSlyZXR1cm4gbmV3IGYoTmFOKTtlPW4uZXEoMTApfWlmKGk9dGhpcy5kLHRoaXMuczwwfHwhaXx8IWlbMF18fHRoaXMuZXEoMSkpcmV0dXJuIG5ldyBmKGkmJiFpWzBdPy0xLzA6MSE9dGhpcy5zP05hTjppPzA6MS8wKTtpZihlKWlmKGkubGVuZ3RoPjEpcz0hMDtlbHNle2ZvcihyPWlbMF07ciUxMD09MDspci89MTA7cz0xIT09cn1pZihoPSExLG89Vih0aGlzLHU9YSs1KSx0PWU/VChmLHUrMTApOlYobix1KSxBKChjPVoobyx0LHUsMSkpLmQscj1hLGQpKWRve2lmKG89Vih0aGlzLHUrPTEwKSx0PWU/VChmLHUrMTApOlYobix1KSxjPVoobyx0LHUsMSksIXMpeytEKGMuZCkuc2xpY2UocisxLHIrMTUpKzE9PTFlMTQmJihjPVAoYyxhKzEsMCkpO2JyZWFrfX13aGlsZShBKGMuZCxyKz0xMCxkKSk7cmV0dXJuIGg9ITAsUChjLGEsZCl9LE8ubWludXM9Ty5zdWI9ZnVuY3Rpb24obil7dmFyIGUsaSx0LHIscyxvLHUsYyxmLGEsZCxsLHA9dGhpcyxnPXAuY29uc3RydWN0b3I7aWYobj1uZXcgZyhuKSwhcC5kfHwhbi5kKXJldHVybiBwLnMmJm4ucz9wLmQ/bi5zPS1uLnM6bj1uZXcgZyhuLmR8fHAucyE9PW4ucz9wOk5hTik6bj1uZXcgZyhOYU4pLG47aWYocC5zIT1uLnMpcmV0dXJuIG4ucz0tbi5zLHAucGx1cyhuKTtpZihmPXAuZCxsPW4uZCx1PWcucHJlY2lzaW9uLGM9Zy5yb3VuZGluZywhZlswXXx8IWxbMF0pe2lmKGxbMF0pbi5zPS1uLnM7ZWxzZXtpZighZlswXSlyZXR1cm4gbmV3IGcoMz09PWM/LTA6MCk7bj1uZXcgZyhwKX1yZXR1cm4gaD9QKG4sdSxjKTpufWlmKGk9bShuLmUveSksYT1tKHAuZS95KSxmPWYuc2xpY2UoKSxzPWEtaSl7Zm9yKChkPXM8MCk/KGU9ZixzPS1zLG89bC5sZW5ndGgpOihlPWwsaT1hLG89Zi5sZW5ndGgpLHM+KHQ9TWF0aC5tYXgoTWF0aC5jZWlsKHUveSksbykrMikmJihzPXQsZS5sZW5ndGg9MSksZS5yZXZlcnNlKCksdD1zO3QtLTspZS5wdXNoKDApO2UucmV2ZXJzZSgpfWVsc2V7Zm9yKChkPSh0PWYubGVuZ3RoKTwobz1sLmxlbmd0aCkpJiYobz10KSx0PTA7dDxvO3QrKylpZihmW3RdIT1sW3RdKXtkPWZbdF08bFt0XTticmVha31zPTB9Zm9yKGQmJihlPWYsZj1sLGw9ZSxuLnM9LW4ucyksbz1mLmxlbmd0aCx0PWwubGVuZ3RoLW87dD4wOy0tdClmW28rK109MDtmb3IodD1sLmxlbmd0aDt0PnM7KXtpZihmWy0tdF08bFt0XSl7Zm9yKHI9dDtyJiYwPT09ZlstLXJdOylmW3JdPXgtMTstLWZbcl0sZlt0XSs9eH1mW3RdLT1sW3RdfWZvcig7MD09PWZbLS1vXTspZi5wb3AoKTtmb3IoOzA9PT1mWzBdO2Yuc2hpZnQoKSktLWk7cmV0dXJuIGZbMF0/KG4uZD1mLG4uZT1MKGYsaSksaD9QKG4sdSxjKTpuKTpuZXcgZygzPT09Yz8tMDowKX0sTy5tb2R1bG89Ty5tb2Q9ZnVuY3Rpb24obil7dmFyIGUsaT10aGlzLHQ9aS5jb25zdHJ1Y3RvcjtyZXR1cm4gbj1uZXcgdChuKSwhaS5kfHwhbi5zfHxuLmQmJiFuLmRbMF0/bmV3IHQoTmFOKTohbi5kfHxpLmQmJiFpLmRbMF0/UChuZXcgdChpKSx0LnByZWNpc2lvbix0LnJvdW5kaW5nKTooaD0hMSw5PT10Lm1vZHVsbz8oZT1aKGksbi5hYnMoKSwwLDMsMSkpLnMqPW4uczplPVooaSxuLDAsdC5tb2R1bG8sMSksZT1lLnRpbWVzKG4pLGg9ITAsaS5taW51cyhlKSl9LE8ubmF0dXJhbEV4cG9uZW50aWFsPU8uZXhwPWZ1bmN0aW9uKCl7cmV0dXJuIEIodGhpcyl9LE8ubmF0dXJhbExvZ2FyaXRobT1PLmxuPWZ1bmN0aW9uKCl7cmV0dXJuIFYodGhpcyl9LE8ubmVnYXRlZD1PLm5lZz1mdW5jdGlvbigpe3ZhciBuPW5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO3JldHVybiBuLnM9LW4ucyxQKG4pfSxPLnBsdXM9Ty5hZGQ9ZnVuY3Rpb24obil7dmFyIGUsaSx0LHIscyxvLHUsYyxmLGEsZD10aGlzLGw9ZC5jb25zdHJ1Y3RvcjtpZihuPW5ldyBsKG4pLCFkLmR8fCFuLmQpcmV0dXJuIGQucyYmbi5zP2QuZHx8KG49bmV3IGwobi5kfHxkLnM9PT1uLnM/ZDpOYU4pKTpuPW5ldyBsKE5hTiksbjtpZihkLnMhPW4ucylyZXR1cm4gbi5zPS1uLnMsZC5taW51cyhuKTtpZihmPWQuZCxhPW4uZCx1PWwucHJlY2lzaW9uLGM9bC5yb3VuZGluZywhZlswXXx8IWFbMF0pcmV0dXJuIGFbMF18fChuPW5ldyBsKGQpKSxoP1Aobix1LGMpOm47aWYocz1tKGQuZS95KSx0PW0obi5lL3kpLGY9Zi5zbGljZSgpLHI9cy10KXtmb3IocjwwPyhpPWYscj0tcixvPWEubGVuZ3RoKTooaT1hLHQ9cyxvPWYubGVuZ3RoKSxyPihvPShzPU1hdGguY2VpbCh1L3kpKT5vP3MrMTpvKzEpJiYocj1vLGkubGVuZ3RoPTEpLGkucmV2ZXJzZSgpO3ItLTspaS5wdXNoKDApO2kucmV2ZXJzZSgpfWZvcigobz1mLmxlbmd0aCktKHI9YS5sZW5ndGgpPDAmJihyPW8saT1hLGE9ZixmPWkpLGU9MDtyOyllPShmWy0tcl09ZltyXSthW3JdK2UpL3h8MCxmW3JdJT14O2ZvcihlJiYoZi51bnNoaWZ0KGUpLCsrdCksbz1mLmxlbmd0aDswPT1mWy0tb107KWYucG9wKCk7cmV0dXJuIG4uZD1mLG4uZT1MKGYsdCksaD9QKG4sdSxjKTpufSxPLnByZWNpc2lvbj1PLnNkPWZ1bmN0aW9uKG4pe3ZhciBlLGk9dGhpcztpZih2b2lkIDAhPT1uJiZuIT09ISFuJiYxIT09biYmMCE9PW4pdGhyb3cgRXJyb3IobCtuKTtyZXR1cm4gaS5kPyhlPV8oaS5kKSxuJiZpLmUrMT5lJiYoZT1pLmUrMSkpOmU9TmFOLGV9LE8ucm91bmQ9ZnVuY3Rpb24oKXt2YXIgbj10aGlzLGU9bi5jb25zdHJ1Y3RvcjtyZXR1cm4gUChuZXcgZShuKSxuLmUrMSxlLnJvdW5kaW5nKX0sTy5zaW5lPU8uc2luPWZ1bmN0aW9uKCl7dmFyIG4sZSxpPXRoaXMsdD1pLmNvbnN0cnVjdG9yO3JldHVybiBpLmlzRmluaXRlKCk/aS5pc1plcm8oKT9uZXcgdChpKToobj10LnByZWNpc2lvbixlPXQucm91bmRpbmcsdC5wcmVjaXNpb249bitNYXRoLm1heChpLmUsaS5zZCgpKSt5LHQucm91bmRpbmc9MSxpPWZ1bmN0aW9uKG4sZSl7dmFyIGksdD1lLmQubGVuZ3RoO2lmKHQ8MylyZXR1cm4gSihuLDIsZSxlKTtpPShpPTEuNCpNYXRoLnNxcnQodCkpPjE2PzE2OjB8aSxlPWUudGltZXMoMS96KDUsaSkpLGU9SihuLDIsZSxlKTtmb3IodmFyIHIscz1uZXcgbig1KSxvPW5ldyBuKDE2KSx1PW5ldyBuKDIwKTtpLS07KXI9ZS50aW1lcyhlKSxlPWUudGltZXMocy5wbHVzKHIudGltZXMoby50aW1lcyhyKS5taW51cyh1KSkpKTtyZXR1cm4gZX0odCxHKHQsaSkpLHQucHJlY2lzaW9uPW4sdC5yb3VuZGluZz1lLFAocj4yP2kubmVnKCk6aSxuLGUsITApKTpuZXcgdChOYU4pfSxPLnNxdWFyZVJvb3Q9Ty5zcXJ0PWZ1bmN0aW9uKCl7dmFyIG4sZSxpLHQscixzLG89dGhpcyx1PW8uZCxjPW8uZSxmPW8ucyxhPW8uY29uc3RydWN0b3I7aWYoMSE9PWZ8fCF1fHwhdVswXSlyZXR1cm4gbmV3IGEoIWZ8fGY8MCYmKCF1fHx1WzBdKT9OYU46dT9vOjEvMCk7Zm9yKGg9ITEsMD09KGY9TWF0aC5zcXJ0KCtvKSl8fGY9PTEvMD8oKChlPUQodSkpLmxlbmd0aCtjKSUyPT0wJiYoZSs9XCIwXCIpLGY9TWF0aC5zcXJ0KGUpLGM9bSgoYysxKS8yKS0oYzwwfHxjJTIpLHQ9bmV3IGEoZT1mPT0xLzA/XCI1ZVwiK2M6KGU9Zi50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsZS5pbmRleE9mKFwiZVwiKSsxKStjKSk6dD1uZXcgYShmLnRvU3RyaW5nKCkpLGk9KGM9YS5wcmVjaXNpb24pKzM7OylpZih0PShzPXQpLnBsdXMoWihvLHMsaSsyLDEpKS50aW1lcyguNSksRChzLmQpLnNsaWNlKDAsaSk9PT0oZT1EKHQuZCkpLnNsaWNlKDAsaSkpe2lmKFwiOTk5OVwiIT0oZT1lLnNsaWNlKGktMyxpKzEpKSYmKHJ8fFwiNDk5OVwiIT1lKSl7K2UmJigrZS5zbGljZSgxKXx8XCI1XCIhPWUuY2hhckF0KDApKXx8KFAodCxjKzEsMSksbj0hdC50aW1lcyh0KS5lcShvKSk7YnJlYWt9aWYoIXImJihQKHMsYysxLDApLHMudGltZXMocykuZXEobykpKXt0PXM7YnJlYWt9aSs9NCxyPTF9cmV0dXJuIGg9ITAsUCh0LGMsYS5yb3VuZGluZyxuKX0sTy50YW5nZW50PU8udGFuPWZ1bmN0aW9uKCl7dmFyIG4sZSxpPXRoaXMsdD1pLmNvbnN0cnVjdG9yO3JldHVybiBpLmlzRmluaXRlKCk/aS5pc1plcm8oKT9uZXcgdChpKToobj10LnByZWNpc2lvbixlPXQucm91bmRpbmcsdC5wcmVjaXNpb249bisxMCx0LnJvdW5kaW5nPTEsKGk9aS5zaW4oKSkucz0xLGk9WihpLG5ldyB0KDEpLm1pbnVzKGkudGltZXMoaSkpLnNxcnQoKSxuKzEwLDApLHQucHJlY2lzaW9uPW4sdC5yb3VuZGluZz1lLFAoMj09cnx8ND09cj9pLm5lZygpOmksbixlLCEwKSk6bmV3IHQoTmFOKX0sTy50aW1lcz1PLm11bD1mdW5jdGlvbihuKXt2YXIgZSxpLHQscixzLG8sdSxjLGYsYT10aGlzLGQ9YS5jb25zdHJ1Y3RvcixsPWEuZCxwPShuPW5ldyBkKG4pKS5kO2lmKG4ucyo9YS5zLCEobCYmbFswXSYmcCYmcFswXSkpcmV0dXJuIG5ldyBkKCFuLnN8fGwmJiFsWzBdJiYhcHx8cCYmIXBbMF0mJiFsP05hTjpsJiZwPzAqbi5zOm4ucy8wKTtmb3IoaT1tKGEuZS95KSttKG4uZS95KSwoYz1sLmxlbmd0aCk8KGY9cC5sZW5ndGgpJiYocz1sLGw9cCxwPXMsbz1jLGM9ZixmPW8pLHM9W10sdD1vPWMrZjt0LS07KXMucHVzaCgwKTtmb3IodD1mOy0tdD49MDspe2ZvcihlPTAscj1jK3Q7cj50Oyl1PXNbcl0rcFt0XSpsW3ItdC0xXStlLHNbci0tXT11JXh8MCxlPXUveHwwO3Nbcl09KHNbcl0rZSkleHwwfWZvcig7IXNbLS1vXTspcy5wb3AoKTtyZXR1cm4gZT8rK2k6cy5zaGlmdCgpLG4uZD1zLG4uZT1MKHMsaSksaD9QKG4sZC5wcmVjaXNpb24sZC5yb3VuZGluZyk6bn0sTy50b0JpbmFyeT1mdW5jdGlvbihuLGUpe3JldHVybiBLKHRoaXMsMixuLGUpfSxPLnRvRGVjaW1hbFBsYWNlcz1PLnRvRFA9ZnVuY3Rpb24obixlKXt2YXIgaT10aGlzLHQ9aS5jb25zdHJ1Y3RvcjtyZXR1cm4gaT1uZXcgdChpKSx2b2lkIDA9PT1uP2k6KEYobiwwLG8pLHZvaWQgMD09PWU/ZT10LnJvdW5kaW5nOkYoZSwwLDgpLFAoaSxuK2kuZSsxLGUpKX0sTy50b0V4cG9uZW50aWFsPWZ1bmN0aW9uKG4sZSl7dmFyIGksdD10aGlzLHI9dC5jb25zdHJ1Y3RvcjtyZXR1cm4gdm9pZCAwPT09bj9pPVIodCwhMCk6KEYobiwwLG8pLHZvaWQgMD09PWU/ZT1yLnJvdW5kaW5nOkYoZSwwLDgpLGk9Uih0PVAobmV3IHIodCksbisxLGUpLCEwLG4rMSkpLHQuaXNOZWcoKSYmIXQuaXNaZXJvKCk/XCItXCIraTppfSxPLnRvRml4ZWQ9ZnVuY3Rpb24obixlKXt2YXIgaSx0LHI9dGhpcyxzPXIuY29uc3RydWN0b3I7cmV0dXJuIHZvaWQgMD09PW4/aT1SKHIpOihGKG4sMCxvKSx2b2lkIDA9PT1lP2U9cy5yb3VuZGluZzpGKGUsMCw4KSxpPVIodD1QKG5ldyBzKHIpLG4rci5lKzEsZSksITEsbit0LmUrMSkpLHIuaXNOZWcoKSYmIXIuaXNaZXJvKCk/XCItXCIraTppfSxPLnRvRnJhY3Rpb249ZnVuY3Rpb24obil7dmFyIGUsaSx0LHIscyxvLHUsYyxmLGEsZCxwLGc9dGhpcyxtPWcuZCx2PWcuY29uc3RydWN0b3I7aWYoIW0pcmV0dXJuIG5ldyB2KGcpO2lmKGY9aT1uZXcgdigxKSx0PWM9bmV3IHYoMCksbz0ocz0oZT1uZXcgdih0KSkuZT1fKG0pLWcuZS0xKSV5LGUuZFswXT13KDEwLG88MD95K286byksbnVsbD09biluPXM+MD9lOmY7ZWxzZXtpZighKHU9bmV3IHYobikpLmlzSW50KCl8fHUubHQoZikpdGhyb3cgRXJyb3IobCt1KTtuPXUuZ3QoZSk/cz4wP2U6Zjp1fWZvcihoPSExLHU9bmV3IHYoRChtKSksYT12LnByZWNpc2lvbix2LnByZWNpc2lvbj1zPW0ubGVuZ3RoKnkqMjtkPVoodSxlLDAsMSwxKSwxIT0ocj1pLnBsdXMoZC50aW1lcyh0KSkpLmNtcChuKTspaT10LHQ9cixyPWYsZj1jLnBsdXMoZC50aW1lcyhyKSksYz1yLHI9ZSxlPXUubWludXMoZC50aW1lcyhyKSksdT1yO3JldHVybiByPVoobi5taW51cyhpKSx0LDAsMSwxKSxjPWMucGx1cyhyLnRpbWVzKGYpKSxpPWkucGx1cyhyLnRpbWVzKHQpKSxjLnM9Zi5zPWcucyxwPVooZix0LHMsMSkubWludXMoZykuYWJzKCkuY21wKFooYyxpLHMsMSkubWludXMoZykuYWJzKCkpPDE/W2YsdF06W2MsaV0sdi5wcmVjaXNpb249YSxoPSEwLHB9LE8udG9IZXhhZGVjaW1hbD1PLnRvSGV4PWZ1bmN0aW9uKG4sZSl7cmV0dXJuIEsodGhpcywxNixuLGUpfSxPLnRvTmVhcmVzdD1mdW5jdGlvbihuLGUpe3ZhciBpPXRoaXMsdD1pLmNvbnN0cnVjdG9yO2lmKGk9bmV3IHQoaSksbnVsbD09bil7aWYoIWkuZClyZXR1cm4gaTtuPW5ldyB0KDEpLGU9dC5yb3VuZGluZ31lbHNle2lmKG49bmV3IHQobiksdm9pZCAwPT09ZT9lPXQucm91bmRpbmc6RihlLDAsOCksIWkuZClyZXR1cm4gbi5zP2k6bjtpZighbi5kKXJldHVybiBuLnMmJihuLnM9aS5zKSxufXJldHVybiBuLmRbMF0/KGg9ITEsaT1aKGksbiwwLGUsMSkudGltZXMobiksaD0hMCxQKGkpKToobi5zPWkucyxpPW4pLGl9LE8udG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4rdGhpc30sTy50b09jdGFsPWZ1bmN0aW9uKG4sZSl7cmV0dXJuIEsodGhpcyw4LG4sZSl9LE8udG9Qb3dlcj1PLnBvdz1mdW5jdGlvbihuKXt2YXIgZSxpLHQscixzLG8sdT10aGlzLGM9dS5jb25zdHJ1Y3RvcixmPSsobj1uZXcgYyhuKSk7aWYoISh1LmQmJm4uZCYmdS5kWzBdJiZuLmRbMF0pKXJldHVybiBuZXcgYyh3KCt1LGYpKTtpZigodT1uZXcgYyh1KSkuZXEoMSkpcmV0dXJuIHU7aWYodD1jLnByZWNpc2lvbixzPWMucm91bmRpbmcsbi5lcSgxKSlyZXR1cm4gUCh1LHQscyk7aWYoKGU9bShuLmUveSkpPj1uLmQubGVuZ3RoLTEmJihpPWY8MD8tZjpmKTw9OTAwNzE5OTI1NDc0MDk5MSlyZXR1cm4gcj1DKGMsdSxpLHQpLG4uczwwP25ldyBjKDEpLmRpdihyKTpQKHIsdCxzKTtpZigobz11LnMpPDApe2lmKGU8bi5kLmxlbmd0aC0xKXJldHVybiBuZXcgYyhOYU4pO2lmKDA9PSgxJm4uZFtlXSkmJihvPTEpLDA9PXUuZSYmMT09dS5kWzBdJiYxPT11LmQubGVuZ3RoKXJldHVybiB1LnM9byx1fXJldHVybihlPTAhPShpPXcoK3UsZikpJiZpc0Zpbml0ZShpKT9uZXcgYyhpK1wiXCIpLmU6bShmKihNYXRoLmxvZyhcIjAuXCIrRCh1LmQpKS9NYXRoLkxOMTArdS5lKzEpKSk+Yy5tYXhFKzF8fGU8Yy5taW5FLTE/bmV3IGMoZT4wP28vMDowKTooaD0hMSxjLnJvdW5kaW5nPXUucz0xLGk9TWF0aC5taW4oMTIsKGUrXCJcIikubGVuZ3RoKSwocj1CKG4udGltZXMoVih1LHQraSkpLHQpKS5kJiZBKChyPVAocix0KzUsMSkpLmQsdCxzKSYmKGU9dCsxMCwrRCgocj1QKEIobi50aW1lcyhWKHUsZStpKSksZSksZSs1LDEpKS5kKS5zbGljZSh0KzEsdCsxNSkrMT09MWUxNCYmKHI9UChyLHQrMSwwKSkpLHIucz1vLGg9ITAsYy5yb3VuZGluZz1zLFAocix0LHMpKX0sTy50b1ByZWNpc2lvbj1mdW5jdGlvbihuLGUpe3ZhciBpLHQ9dGhpcyxyPXQuY29uc3RydWN0b3I7cmV0dXJuIHZvaWQgMD09PW4/aT1SKHQsdC5lPD1yLnRvRXhwTmVnfHx0LmU+PXIudG9FeHBQb3MpOihGKG4sMSxvKSx2b2lkIDA9PT1lP2U9ci5yb3VuZGluZzpGKGUsMCw4KSxpPVIodD1QKG5ldyByKHQpLG4sZSksbjw9dC5lfHx0LmU8PXIudG9FeHBOZWcsbikpLHQuaXNOZWcoKSYmIXQuaXNaZXJvKCk/XCItXCIraTppfSxPLnRvU2lnbmlmaWNhbnREaWdpdHM9Ty50b1NEPWZ1bmN0aW9uKG4sZSl7dmFyIGk9dGhpcy5jb25zdHJ1Y3RvcjtyZXR1cm4gdm9pZCAwPT09bj8obj1pLnByZWNpc2lvbixlPWkucm91bmRpbmcpOihGKG4sMSxvKSx2b2lkIDA9PT1lP2U9aS5yb3VuZGluZzpGKGUsMCw4KSksUChuZXcgaSh0aGlzKSxuLGUpfSxPLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIG49dGhpcyxlPW4uY29uc3RydWN0b3IsaT1SKG4sbi5lPD1lLnRvRXhwTmVnfHxuLmU+PWUudG9FeHBQb3MpO3JldHVybiBuLmlzTmVnKCkmJiFuLmlzWmVybygpP1wiLVwiK2k6aX0sTy50cnVuY2F0ZWQ9Ty50cnVuYz1mdW5jdGlvbigpe3JldHVybiBQKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLHRoaXMuZSsxLDEpfSxPLnZhbHVlT2Y9Ty50b0pTT049ZnVuY3Rpb24oKXt2YXIgbj10aGlzLGU9bi5jb25zdHJ1Y3RvcixpPVIobixuLmU8PWUudG9FeHBOZWd8fG4uZT49ZS50b0V4cFBvcyk7cmV0dXJuIG4uaXNOZWcoKT9cIi1cIitpOml9O3ZhciBaPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLGUsaSl7dmFyIHQscj0wLHM9bi5sZW5ndGg7Zm9yKG49bi5zbGljZSgpO3MtLTspdD1uW3NdKmUrcixuW3NdPXQlaXwwLHI9dC9pfDA7cmV0dXJuIHImJm4udW5zaGlmdChyKSxufWZ1bmN0aW9uIGUobixlLGksdCl7dmFyIHIscztpZihpIT10KXM9aT50PzE6LTE7ZWxzZSBmb3Iocj1zPTA7cjxpO3IrKylpZihuW3JdIT1lW3JdKXtzPW5bcl0+ZVtyXT8xOi0xO2JyZWFrfXJldHVybiBzfWZ1bmN0aW9uIHQobixlLGksdCl7Zm9yKHZhciByPTA7aS0tOyluW2ldLT1yLHI9bltpXTxlW2ldPzE6MCxuW2ldPXIqdCtuW2ldLWVbaV07Zm9yKDshblswXSYmbi5sZW5ndGg+MTspbi5zaGlmdCgpfXJldHVybiBmdW5jdGlvbihyLHMsbyx1LGMsZil7dmFyIGEsaCxkLGwscCxnLHcsdixOLGIsRSxNLHEsTyxELEYsQSxTLFosUixMPXIuY29uc3RydWN0b3IsVD1yLnM9PXMucz8xOi0xLFU9ci5kLF89cy5kO2lmKCEoVSYmVVswXSYmXyYmX1swXSkpcmV0dXJuIG5ldyBMKHIucyYmcy5zJiYoVT8hX3x8VVswXSE9X1swXTpfKT9VJiYwPT1VWzBdfHwhXz8wKlQ6VC8wOk5hTik7Zm9yKGY/KHA9MSxoPXIuZS1zLmUpOihmPXgscD15LGg9bShyLmUvcCktbShzLmUvcCkpLFo9Xy5sZW5ndGgsQT1VLmxlbmd0aCxiPShOPW5ldyBMKFQpKS5kPVtdLGQ9MDtfW2RdPT0oVVtkXXx8MCk7ZCsrKTtpZihfW2RdPihVW2RdfHwwKSYmaC0tLG51bGw9PW8/KE89bz1MLnByZWNpc2lvbix1PUwucm91bmRpbmcpOk89Yz9vKyhyLmUtcy5lKSsxOm8sTzwwKWIucHVzaCgxKSxnPSEwO2Vsc2V7aWYoTz1PL3ArMnwwLGQ9MCwxPT1aKXtmb3IobD0wLF89X1swXSxPKys7KGQ8QXx8bCkmJk8tLTtkKyspRD1sKmYrKFVbZF18fDApLGJbZF09RC9ffDAsbD1EJV98MDtnPWx8fGQ8QX1lbHNle2ZvcigobD1mLyhfWzBdKzEpfDApPjEmJihfPW4oXyxsLGYpLFU9bihVLGwsZiksWj1fLmxlbmd0aCxBPVUubGVuZ3RoKSxGPVosTT0oRT1VLnNsaWNlKDAsWikpLmxlbmd0aDtNPFo7KUVbTSsrXT0wOyhSPV8uc2xpY2UoKSkudW5zaGlmdCgwKSxTPV9bMF0sX1sxXT49Zi8yJiYrK1M7ZG97bD0wLChhPWUoXyxFLFosTSkpPDA/KHE9RVswXSxaIT1NJiYocT1xKmYrKEVbMV18fDApKSwobD1xL1N8MCk+MT8obD49ZiYmKGw9Zi0xKSwxPT0oYT1lKHc9bihfLGwsZiksRSx2PXcubGVuZ3RoLE09RS5sZW5ndGgpKSYmKGwtLSx0KHcsWjx2P1I6Xyx2LGYpKSk6KDA9PWwmJihhPWw9MSksdz1fLnNsaWNlKCkpLCh2PXcubGVuZ3RoKTxNJiZ3LnVuc2hpZnQoMCksdChFLHcsTSxmKSwtMT09YSYmKGE9ZShfLEUsWixNPUUubGVuZ3RoKSk8MSYmKGwrKyx0KEUsWjxNP1I6XyxNLGYpKSxNPUUubGVuZ3RoKTowPT09YSYmKGwrKyxFPVswXSksYltkKytdPWwsYSYmRVswXT9FW00rK109VVtGXXx8MDooRT1bVVtGXV0sTT0xKX13aGlsZSgoRisrPEF8fHZvaWQgMCE9PUVbMF0pJiZPLS0pO2c9dm9pZCAwIT09RVswXX1iWzBdfHxiLnNoaWZ0KCl9aWYoMT09cClOLmU9aCxpPWc7ZWxzZXtmb3IoZD0xLGw9YlswXTtsPj0xMDtsLz0xMClkKys7Ti5lPWQraCpwLTEsUChOLGM/bytOLmUrMTpvLHUsZyl9cmV0dXJuIE59fSgpO2Z1bmN0aW9uIFAobixlLGksdCl7dmFyIHIscyxvLHUsYyxmLGEsZCxsLHA9bi5jb25zdHJ1Y3RvcjtuOmlmKG51bGwhPWUpe2lmKCEoZD1uLmQpKXJldHVybiBuO2ZvcihyPTEsdT1kWzBdO3U+PTEwO3UvPTEwKXIrKztpZigocz1lLXIpPDApcys9eSxvPWUsYz0oYT1kW2w9MF0pL3coMTAsci1vLTEpJTEwfDA7ZWxzZSBpZigobD1NYXRoLmNlaWwoKHMrMSkveSkpPj0odT1kLmxlbmd0aCkpe2lmKCF0KWJyZWFrIG47Zm9yKDt1Kys8PWw7KWQucHVzaCgwKTthPWM9MCxyPTEsbz0ocyU9eSkteSsxfWVsc2V7Zm9yKGE9dT1kW2xdLHI9MTt1Pj0xMDt1Lz0xMClyKys7Yz0obz0ocyU9eSkteStyKTwwPzA6YS93KDEwLHItby0xKSUxMHwwfWlmKHQ9dHx8ZTwwfHx2b2lkIDAhPT1kW2wrMV18fChvPDA/YTphJXcoMTAsci1vLTEpKSxmPWk8ND8oY3x8dCkmJigwPT1pfHxpPT0obi5zPDA/MzoyKSk6Yz41fHw1PT1jJiYoND09aXx8dHx8Nj09aSYmKHM+MD9vPjA/YS93KDEwLHItbyk6MDpkW2wtMV0pJTEwJjF8fGk9PShuLnM8MD84OjcpKSxlPDF8fCFkWzBdKXJldHVybiBkLmxlbmd0aD0wLGY/KGUtPW4uZSsxLGRbMF09dygxMCwoeS1lJXkpJXkpLG4uZT0tZXx8MCk6ZFswXT1uLmU9MCxuO2lmKDA9PXM/KGQubGVuZ3RoPWwsdT0xLGwtLSk6KGQubGVuZ3RoPWwrMSx1PXcoMTAseS1zKSxkW2xdPW8+MD8oYS93KDEwLHItbykldygxMCxvKXwwKSp1OjApLGYpZm9yKDs7KXtpZigwPT1sKXtmb3Iocz0xLG89ZFswXTtvPj0xMDtvLz0xMClzKys7Zm9yKG89ZFswXSs9dSx1PTE7bz49MTA7by89MTApdSsrO3MhPXUmJihuLmUrKyxkWzBdPT14JiYoZFswXT0xKSk7YnJlYWt9aWYoZFtsXSs9dSxkW2xdIT14KWJyZWFrO2RbbC0tXT0wLHU9MX1mb3Iocz1kLmxlbmd0aDswPT09ZFstLXNdOylkLnBvcCgpfXJldHVybiBoJiYobi5lPnAubWF4RT8obi5kPW51bGwsbi5lPU5hTik6bi5lPHAubWluRSYmKG4uZT0wLG4uZD1bMF0pKSxufWZ1bmN0aW9uIFIobixlLGkpe2lmKCFuLmlzRmluaXRlKCkpcmV0dXJuIGoobik7dmFyIHQscj1uLmUscz1EKG4uZCksbz1zLmxlbmd0aDtyZXR1cm4gZT8oaSYmKHQ9aS1vKT4wP3M9cy5jaGFyQXQoMCkrXCIuXCIrcy5zbGljZSgxKStrKHQpOm8+MSYmKHM9cy5jaGFyQXQoMCkrXCIuXCIrcy5zbGljZSgxKSkscz1zKyhuLmU8MD9cImVcIjpcImUrXCIpK24uZSk6cjwwPyhzPVwiMC5cIitrKC1yLTEpK3MsaSYmKHQ9aS1vKT4wJiYocys9ayh0KSkpOnI+PW8/KHMrPWsocisxLW8pLGkmJih0PWktci0xKT4wJiYocz1zK1wiLlwiK2sodCkpKTooKHQ9cisxKTxvJiYocz1zLnNsaWNlKDAsdCkrXCIuXCIrcy5zbGljZSh0KSksaSYmKHQ9aS1vKT4wJiYocisxPT09byYmKHMrPVwiLlwiKSxzKz1rKHQpKSksc31mdW5jdGlvbiBMKG4sZSl7dmFyIGk9blswXTtmb3IoZSo9eTtpPj0xMDtpLz0xMCllKys7cmV0dXJuIGV9ZnVuY3Rpb24gVChuLGUsaSl7aWYoZT5NKXRocm93IGg9ITAsaSYmKG4ucHJlY2lzaW9uPWkpLEVycm9yKHApO3JldHVybiBQKG5ldyBuKGMpLGUsMSwhMCl9ZnVuY3Rpb24gVShuLGUsaSl7aWYoZT5xKXRocm93IEVycm9yKHApO3JldHVybiBQKG5ldyBuKGYpLGUsaSwhMCl9ZnVuY3Rpb24gXyhuKXt2YXIgZT1uLmxlbmd0aC0xLGk9ZSp5KzE7aWYoZT1uW2VdKXtmb3IoO2UlMTA9PTA7ZS89MTApaS0tO2ZvcihlPW5bMF07ZT49MTA7ZS89MTApaSsrfXJldHVybiBpfWZ1bmN0aW9uIGsobil7Zm9yKHZhciBlPVwiXCI7bi0tOyllKz1cIjBcIjtyZXR1cm4gZX1mdW5jdGlvbiBDKG4sZSxpLHQpe3ZhciByLHM9bmV3IG4oMSksbz1NYXRoLmNlaWwodC95KzQpO2ZvcihoPSExOzspe2lmKGklMiYmUSgocz1zLnRpbWVzKGUpKS5kLG8pJiYocj0hMCksMD09PShpPW0oaS8yKSkpe2k9cy5kLmxlbmd0aC0xLHImJjA9PT1zLmRbaV0mJisrcy5kW2ldO2JyZWFrfVEoKGU9ZS50aW1lcyhlKSkuZCxvKX1yZXR1cm4gaD0hMCxzfWZ1bmN0aW9uIEkobil7cmV0dXJuIDEmbi5kW24uZC5sZW5ndGgtMV19ZnVuY3Rpb24gSChuLGUsaSl7Zm9yKHZhciB0LHI9bmV3IG4oZVswXSkscz0wOysrczxlLmxlbmd0aDspe2lmKCEodD1uZXcgbihlW3NdKSkucyl7cj10O2JyZWFrfXJbaV0odCkmJihyPXQpfXJldHVybiByfWZ1bmN0aW9uIEIobixlKXt2YXIgaSx0LHIscyxvLHUsYyxmPTAsYT0wLGQ9MCxsPW4uY29uc3RydWN0b3IscD1sLnJvdW5kaW5nLGc9bC5wcmVjaXNpb247aWYoIW4uZHx8IW4uZFswXXx8bi5lPjE3KXJldHVybiBuZXcgbChuLmQ/bi5kWzBdP24uczwwPzA6MS8wOjE6bi5zP24uczwwPzA6bjpOYU4pO2ZvcihudWxsPT1lPyhoPSExLGM9Zyk6Yz1lLHU9bmV3IGwoLjAzMTI1KTtuLmU+LTI7KW49bi50aW1lcyh1KSxkKz01O2ZvcihjKz10PU1hdGgubG9nKHcoMixkKSkvTWF0aC5MTjEwKjIrNXwwLGk9cz1vPW5ldyBsKDEpLGwucHJlY2lzaW9uPWM7Oyl7aWYocz1QKHMudGltZXMobiksYywxKSxpPWkudGltZXMoKythKSxEKCh1PW8ucGx1cyhaKHMsaSxjLDEpKSkuZCkuc2xpY2UoMCxjKT09PUQoby5kKS5zbGljZSgwLGMpKXtmb3Iocj1kO3ItLTspbz1QKG8udGltZXMobyksYywxKTtpZihudWxsIT1lKXJldHVybiBsLnByZWNpc2lvbj1nLG87aWYoIShmPDMmJkEoby5kLGMtdCxwLGYpKSlyZXR1cm4gUChvLGwucHJlY2lzaW9uPWcscCxoPSEwKTtsLnByZWNpc2lvbj1jKz0xMCxpPXM9dT1uZXcgbCgxKSxhPTAsZisrfW89dX19ZnVuY3Rpb24gVihuLGUpe3ZhciBpLHQscixzLG8sdSxjLGYsYSxkLGwscD0xLGc9bixtPWcuZCx3PWcuY29uc3RydWN0b3Isdj13LnJvdW5kaW5nLE49dy5wcmVjaXNpb247aWYoZy5zPDB8fCFtfHwhbVswXXx8IWcuZSYmMT09bVswXSYmMT09bS5sZW5ndGgpcmV0dXJuIG5ldyB3KG0mJiFtWzBdPy0xLzA6MSE9Zy5zP05hTjptPzA6Zyk7aWYobnVsbD09ZT8oaD0hMSxhPU4pOmE9ZSx3LnByZWNpc2lvbj1hKz0xMCx0PShpPUQobSkpLmNoYXJBdCgwKSwhKE1hdGguYWJzKHM9Zy5lKTwxNWUxNCkpcmV0dXJuIGY9VCh3LGErMixOKS50aW1lcyhzK1wiXCIpLGc9VihuZXcgdyh0K1wiLlwiK2kuc2xpY2UoMSkpLGEtMTApLnBsdXMoZiksdy5wcmVjaXNpb249TixudWxsPT1lP1AoZyxOLHYsaD0hMCk6Zztmb3IoO3Q8NyYmMSE9dHx8MT09dCYmaS5jaGFyQXQoMSk+MzspdD0oaT1EKChnPWcudGltZXMobikpLmQpKS5jaGFyQXQoMCkscCsrO2ZvcihzPWcuZSx0PjE/KGc9bmV3IHcoXCIwLlwiK2kpLHMrKyk6Zz1uZXcgdyh0K1wiLlwiK2kuc2xpY2UoMSkpLGQ9ZyxjPW89Zz1aKGcubWludXMoMSksZy5wbHVzKDEpLGEsMSksbD1QKGcudGltZXMoZyksYSwxKSxyPTM7Oyl7aWYobz1QKG8udGltZXMobCksYSwxKSxEKChmPWMucGx1cyhaKG8sbmV3IHcociksYSwxKSkpLmQpLnNsaWNlKDAsYSk9PT1EKGMuZCkuc2xpY2UoMCxhKSl7aWYoYz1jLnRpbWVzKDIpLDAhPT1zJiYoYz1jLnBsdXMoVCh3LGErMixOKS50aW1lcyhzK1wiXCIpKSksYz1aKGMsbmV3IHcocCksYSwxKSxudWxsIT1lKXJldHVybiB3LnByZWNpc2lvbj1OLGM7aWYoIUEoYy5kLGEtMTAsdix1KSlyZXR1cm4gUChjLHcucHJlY2lzaW9uPU4sdixoPSEwKTt3LnByZWNpc2lvbj1hKz0xMCxmPW89Zz1aKGQubWludXMoMSksZC5wbHVzKDEpLGEsMSksbD1QKGcudGltZXMoZyksYSwxKSxyPXU9MX1jPWYscis9Mn19ZnVuY3Rpb24gaihuKXtyZXR1cm4gU3RyaW5nKG4ucypuLnMvMCl9ZnVuY3Rpb24gJChuLGUpe3ZhciBpLHQscjtmb3IoKGk9ZS5pbmRleE9mKFwiLlwiKSk+LTEmJihlPWUucmVwbGFjZShcIi5cIixcIlwiKSksKHQ9ZS5zZWFyY2goL2UvaSkpPjA/KGk8MCYmKGk9dCksaSs9K2Uuc2xpY2UodCsxKSxlPWUuc3Vic3RyaW5nKDAsdCkpOmk8MCYmKGk9ZS5sZW5ndGgpLHQ9MDs0OD09PWUuY2hhckNvZGVBdCh0KTt0KyspO2ZvcihyPWUubGVuZ3RoOzQ4PT09ZS5jaGFyQ29kZUF0KHItMSk7LS1yKTtpZihlPWUuc2xpY2UodCxyKSl7aWYoci09dCxuLmU9aT1pLXQtMSxuLmQ9W10sdD0oaSsxKSV5LGk8MCYmKHQrPXkpLHQ8cil7Zm9yKHQmJm4uZC5wdXNoKCtlLnNsaWNlKDAsdCkpLHItPXk7dDxyOyluLmQucHVzaCgrZS5zbGljZSh0LHQrPXkpKTtlPWUuc2xpY2UodCksdD15LWUubGVuZ3RofWVsc2UgdC09cjtmb3IoO3QtLTspZSs9XCIwXCI7bi5kLnB1c2goK2UpLGgmJihuLmU+bi5jb25zdHJ1Y3Rvci5tYXhFPyhuLmQ9bnVsbCxuLmU9TmFOKTpuLmU8bi5jb25zdHJ1Y3Rvci5taW5FJiYobi5lPTAsbi5kPVswXSkpfWVsc2Ugbi5lPTAsbi5kPVswXTtyZXR1cm4gbn1mdW5jdGlvbiBXKG4saSl7dmFyIHQscixzLG8sdSxjLGYsYSxkO2lmKFwiSW5maW5pdHlcIj09PWl8fFwiTmFOXCI9PT1pKXJldHVybitpfHwobi5zPU5hTiksbi5lPU5hTixuLmQ9bnVsbCxuO2lmKE4udGVzdChpKSl0PTE2LGk9aS50b0xvd2VyQ2FzZSgpO2Vsc2UgaWYodi50ZXN0KGkpKXQ9MjtlbHNle2lmKCFiLnRlc3QoaSkpdGhyb3cgRXJyb3IobCtpKTt0PTh9Zm9yKChvPWkuc2VhcmNoKC9wL2kpKT4wPyhmPStpLnNsaWNlKG8rMSksaT1pLnN1YnN0cmluZygyLG8pKTppPWkuc2xpY2UoMiksdT0obz1pLmluZGV4T2YoXCIuXCIpKT49MCxyPW4uY29uc3RydWN0b3IsdSYmKG89KGM9KGk9aS5yZXBsYWNlKFwiLlwiLFwiXCIpKS5sZW5ndGgpLW8scz1DKHIsbmV3IHIodCksbywyKm8pKSxvPWQ9KGE9UyhpLHQseCkpLmxlbmd0aC0xOzA9PT1hW29dOy0tbylhLnBvcCgpO3JldHVybiBvPDA/bmV3IHIoMCpuLnMpOihuLmU9TChhLGQpLG4uZD1hLGg9ITEsdSYmKG49WihuLHMsNCpjKSksZiYmKG49bi50aW1lcyhNYXRoLmFicyhmKTw1ND93KDIsZik6ZS5wb3coMixmKSkpLGg9ITAsbil9ZnVuY3Rpb24gSihuLGUsaSx0LHIpe3ZhciBzLG8sdSxjLGY9bi5wcmVjaXNpb24sYT1NYXRoLmNlaWwoZi95KTtmb3IoaD0hMSxjPWkudGltZXMoaSksdT1uZXcgbih0KTs7KXtpZihvPVoodS50aW1lcyhjKSxuZXcgbihlKysqZSsrKSxmLDEpLHU9cj90LnBsdXMobyk6dC5taW51cyhvKSx0PVooby50aW1lcyhjKSxuZXcgbihlKysqZSsrKSxmLDEpLHZvaWQgMCE9PShvPXUucGx1cyh0KSkuZFthXSl7Zm9yKHM9YTtvLmRbc109PT11LmRbc10mJnMtLTspO2lmKC0xPT1zKWJyZWFrfXM9dSx1PXQsdD1vLG89cywwfXJldHVybiBoPSEwLG8uZC5sZW5ndGg9YSsxLG99ZnVuY3Rpb24geihuLGUpe2Zvcih2YXIgaT1uOy0tZTspaSo9bjtyZXR1cm4gaX1mdW5jdGlvbiBHKG4sZSl7dmFyIGksdD1lLnM8MCxzPVUobixuLnByZWNpc2lvbiwxKSxvPXMudGltZXMoLjUpO2lmKChlPWUuYWJzKCkpLmx0ZShvKSlyZXR1cm4gcj10PzQ6MSxlO2lmKChpPWUuZGl2VG9JbnQocykpLmlzWmVybygpKXI9dD8zOjI7ZWxzZXtpZigoZT1lLm1pbnVzKGkudGltZXMocykpKS5sdGUobykpcmV0dXJuIHI9SShpKT90PzI6Mzp0PzQ6MSxlO3I9SShpKT90PzE6NDp0PzM6Mn1yZXR1cm4gZS5taW51cyhzKS5hYnMoKX1mdW5jdGlvbiBLKG4sZSx0LHIpe3ZhciBzLGMsZixhLGgsZCxsLHAsZyxtPW4uY29uc3RydWN0b3Isdz12b2lkIDAhPT10O2lmKHc/KEYodCwxLG8pLHZvaWQgMD09PXI/cj1tLnJvdW5kaW5nOkYociwwLDgpKToodD1tLnByZWNpc2lvbixyPW0ucm91bmRpbmcpLG4uaXNGaW5pdGUoKSl7Zm9yKHc/KHM9MiwxNj09ZT90PTQqdC0zOjg9PWUmJih0PTMqdC0yKSk6cz1lLChmPShsPVIobikpLmluZGV4T2YoXCIuXCIpKT49MCYmKGw9bC5yZXBsYWNlKFwiLlwiLFwiXCIpLChnPW5ldyBtKDEpKS5lPWwubGVuZ3RoLWYsZy5kPVMoUihnKSwxMCxzKSxnLmU9Zy5kLmxlbmd0aCksYz1oPShwPVMobCwxMCxzKSkubGVuZ3RoOzA9PXBbLS1oXTspcC5wb3AoKTtpZihwWzBdKXtpZihmPDA/Yy0tOigobj1uZXcgbShuKSkuZD1wLG4uZT1jLHA9KG49WihuLGcsdCxyLDAscykpLmQsYz1uLmUsZD1pKSxmPXBbdF0sYT1zLzIsZD1kfHx2b2lkIDAhPT1wW3QrMV0sZD1yPDQ/KHZvaWQgMCE9PWZ8fGQpJiYoMD09PXJ8fHI9PT0obi5zPDA/MzoyKSk6Zj5hfHxmPT09YSYmKDQ9PT1yfHxkfHw2PT09ciYmMSZwW3QtMV18fHI9PT0obi5zPDA/ODo3KSkscC5sZW5ndGg9dCxkKWZvcig7KytwWy0tdF0+cy0xOylwW3RdPTAsdHx8KCsrYyxwLnVuc2hpZnQoMSkpO2ZvcihoPXAubGVuZ3RoOyFwW2gtMV07LS1oKTtmb3IoZj0wLGw9XCJcIjtmPGg7ZisrKWwrPXUuY2hhckF0KHBbZl0pO2lmKHcpe2lmKGg+MSlpZigxNj09ZXx8OD09ZSl7Zm9yKGY9MTY9PWU/NDozLC0taDtoJWY7aCsrKWwrPVwiMFwiO2ZvcihoPShwPVMobCxzLGUpKS5sZW5ndGg7IXBbaC0xXTstLWgpO2ZvcihmPTEsbD1cIjEuXCI7ZjxoO2YrKylsKz11LmNoYXJBdChwW2ZdKX1lbHNlIGw9bC5jaGFyQXQoMCkrXCIuXCIrbC5zbGljZSgxKTtsPWwrKGM8MD9cInBcIjpcInArXCIpK2N9ZWxzZSBpZihjPDApe2Zvcig7KytjOylsPVwiMFwiK2w7bD1cIjAuXCIrbH1lbHNlIGlmKCsrYz5oKWZvcihjLT1oO2MtLTspbCs9XCIwXCI7ZWxzZSBjPGgmJihsPWwuc2xpY2UoMCxjKStcIi5cIitsLnNsaWNlKGMpKX1lbHNlIGw9dz9cIjBwKzBcIjpcIjBcIjtsPSgxNj09ZT9cIjB4XCI6Mj09ZT9cIjBiXCI6OD09ZT9cIjBvXCI6XCJcIikrbH1lbHNlIGw9aihuKTtyZXR1cm4gbi5zPDA/XCItXCIrbDpsfWZ1bmN0aW9uIFEobixlKXtpZihuLmxlbmd0aD5lKXJldHVybiBuLmxlbmd0aD1lLCEwfWZ1bmN0aW9uIFgobil7cmV0dXJuIG5ldyB0aGlzKG4pLmFicygpfWZ1bmN0aW9uIFkobil7cmV0dXJuIG5ldyB0aGlzKG4pLmFjb3MoKX1mdW5jdGlvbiBubihuKXtyZXR1cm4gbmV3IHRoaXMobikuYWNvc2goKX1mdW5jdGlvbiBlbihuLGUpe3JldHVybiBuZXcgdGhpcyhuKS5wbHVzKGUpfWZ1bmN0aW9uIHRuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5hc2luKCl9ZnVuY3Rpb24gcm4obil7cmV0dXJuIG5ldyB0aGlzKG4pLmFzaW5oKCl9ZnVuY3Rpb24gc24obil7cmV0dXJuIG5ldyB0aGlzKG4pLmF0YW4oKX1mdW5jdGlvbiBvbihuKXtyZXR1cm4gbmV3IHRoaXMobikuYXRhbmgoKX1mdW5jdGlvbiB1bihuLGUpe249bmV3IHRoaXMobiksZT1uZXcgdGhpcyhlKTt2YXIgaSx0PXRoaXMucHJlY2lzaW9uLHI9dGhpcy5yb3VuZGluZyxzPXQrNDtyZXR1cm4gbi5zJiZlLnM/bi5kfHxlLmQ/IWUuZHx8bi5pc1plcm8oKT8oaT1lLnM8MD9VKHRoaXMsdCxyKTpuZXcgdGhpcygwKSkucz1uLnM6IW4uZHx8ZS5pc1plcm8oKT8oaT1VKHRoaXMscywxKS50aW1lcyguNSkpLnM9bi5zOmUuczwwPyh0aGlzLnByZWNpc2lvbj1zLHRoaXMucm91bmRpbmc9MSxpPXRoaXMuYXRhbihaKG4sZSxzLDEpKSxlPVUodGhpcyxzLDEpLHRoaXMucHJlY2lzaW9uPXQsdGhpcy5yb3VuZGluZz1yLGk9bi5zPDA/aS5taW51cyhlKTppLnBsdXMoZSkpOmk9dGhpcy5hdGFuKFoobixlLHMsMSkpOihpPVUodGhpcyxzLDEpLnRpbWVzKGUucz4wPy4yNTouNzUpKS5zPW4uczppPW5ldyB0aGlzKE5hTiksaX1mdW5jdGlvbiBjbihuKXtyZXR1cm4gbmV3IHRoaXMobikuY2JydCgpfWZ1bmN0aW9uIGZuKG4pe3JldHVybiBQKG49bmV3IHRoaXMobiksbi5lKzEsMil9ZnVuY3Rpb24gYW4obil7aWYoIW58fFwib2JqZWN0XCIhPXR5cGVvZiBuKXRocm93IEVycm9yKGQrXCJPYmplY3QgZXhwZWN0ZWRcIik7dmFyIGUsaSx0LHI9ITA9PT1uLmRlZmF1bHRzLHU9W1wicHJlY2lzaW9uXCIsMSxvLFwicm91bmRpbmdcIiwwLDgsXCJ0b0V4cE5lZ1wiLC1zLDAsXCJ0b0V4cFBvc1wiLDAscyxcIm1heEVcIiwwLHMsXCJtaW5FXCIsLXMsMCxcIm1vZHVsb1wiLDAsOV07Zm9yKGU9MDtlPHUubGVuZ3RoO2UrPTMpaWYoaT11W2VdLHImJih0aGlzW2ldPWFbaV0pLHZvaWQgMCE9PSh0PW5baV0pKXtpZighKG0odCk9PT10JiZ0Pj11W2UrMV0mJnQ8PXVbZSsyXSkpdGhyb3cgRXJyb3IobCtpK1wiOiBcIit0KTt0aGlzW2ldPXR9aWYoaT1cImNyeXB0b1wiLHImJih0aGlzW2ldPWFbaV0pLHZvaWQgMCE9PSh0PW5baV0pKXtpZighMCE9PXQmJiExIT09dCYmMCE9PXQmJjEhPT10KXRocm93IEVycm9yKGwraStcIjogXCIrdCk7aWYodCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGNyeXB0b3x8IWNyeXB0b3x8IWNyeXB0by5nZXRSYW5kb21WYWx1ZXMmJiFjcnlwdG8ucmFuZG9tQnl0ZXMpdGhyb3cgRXJyb3IoZyk7dGhpc1tpXT0hMH1lbHNlIHRoaXNbaV09ITF9cmV0dXJuIHRoaXN9ZnVuY3Rpb24gaG4obil7cmV0dXJuIG5ldyB0aGlzKG4pLmNvcygpfWZ1bmN0aW9uIGRuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5jb3NoKCl9ZnVuY3Rpb24gbG4obixlKXtyZXR1cm4gbmV3IHRoaXMobikuZGl2KGUpfWZ1bmN0aW9uIHBuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5leHAoKX1mdW5jdGlvbiBnbihuKXtyZXR1cm4gUChuPW5ldyB0aGlzKG4pLG4uZSsxLDMpfWZ1bmN0aW9uIG1uKCl7dmFyIG4sZSxpPW5ldyB0aGlzKDApO2ZvcihoPSExLG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7KWlmKChlPW5ldyB0aGlzKGFyZ3VtZW50c1tuKytdKSkuZClpLmQmJihpPWkucGx1cyhlLnRpbWVzKGUpKSk7ZWxzZXtpZihlLnMpcmV0dXJuIGg9ITAsbmV3IHRoaXMoMS8wKTtpPWV9cmV0dXJuIGg9ITAsaS5zcXJ0KCl9ZnVuY3Rpb24gd24obil7cmV0dXJuIG4gaW5zdGFuY2VvZiBlfHxuJiZcIltvYmplY3QgRGVjaW1hbF1cIj09PW4ubmFtZXx8ITF9ZnVuY3Rpb24gdm4obil7cmV0dXJuIG5ldyB0aGlzKG4pLmxuKCl9ZnVuY3Rpb24gTm4obixlKXtyZXR1cm4gbmV3IHRoaXMobikubG9nKGUpfWZ1bmN0aW9uIGJuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5sb2coMil9ZnVuY3Rpb24gRW4obil7cmV0dXJuIG5ldyB0aGlzKG4pLmxvZygxMCl9ZnVuY3Rpb24geG4oKXtyZXR1cm4gSCh0aGlzLGFyZ3VtZW50cyxcImx0XCIpfWZ1bmN0aW9uIHluKCl7cmV0dXJuIEgodGhpcyxhcmd1bWVudHMsXCJndFwiKX1mdW5jdGlvbiBNbihuLGUpe3JldHVybiBuZXcgdGhpcyhuKS5tb2QoZSl9ZnVuY3Rpb24gcW4obixlKXtyZXR1cm4gbmV3IHRoaXMobikubXVsKGUpfWZ1bmN0aW9uIE9uKG4sZSl7cmV0dXJuIG5ldyB0aGlzKG4pLnBvdyhlKX1mdW5jdGlvbiBEbihuKXt2YXIgZSxpLHQscixzPTAsdT1uZXcgdGhpcygxKSxjPVtdO2lmKHZvaWQgMD09PW4/bj10aGlzLnByZWNpc2lvbjpGKG4sMSxvKSx0PU1hdGguY2VpbChuL3kpLHRoaXMuY3J5cHRvKWlmKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpZm9yKGU9Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkodCkpO3M8dDspKHI9ZVtzXSk+PTQyOWU3P2Vbc109Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdOmNbcysrXT1yJTFlNztlbHNle2lmKCFjcnlwdG8ucmFuZG9tQnl0ZXMpdGhyb3cgRXJyb3IoZyk7Zm9yKGU9Y3J5cHRvLnJhbmRvbUJ5dGVzKHQqPTQpO3M8dDspKHI9ZVtzXSsoZVtzKzFdPDw4KSsoZVtzKzJdPDwxNikrKCgxMjcmZVtzKzNdKTw8MjQpKT49MjE0ZTc/Y3J5cHRvLnJhbmRvbUJ5dGVzKDQpLmNvcHkoZSxzKTooYy5wdXNoKHIlMWU3KSxzKz00KTtzPXQvNH1lbHNlIGZvcig7czx0OyljW3MrK109MWU3Kk1hdGgucmFuZG9tKCl8MDtmb3IodD1jWy0tc10sbiU9eSx0JiZuJiYocj13KDEwLHktbiksY1tzXT0odC9yfDApKnIpOzA9PT1jW3NdO3MtLSljLnBvcCgpO2lmKHM8MClpPTAsYz1bMF07ZWxzZXtmb3IoaT0tMTswPT09Y1swXTtpLT15KWMuc2hpZnQoKTtmb3IodD0xLHI9Y1swXTtyPj0xMDtyLz0xMCl0Kys7dDx5JiYoaS09eS10KX1yZXR1cm4gdS5lPWksdS5kPWMsdX1mdW5jdGlvbiBGbihuKXtyZXR1cm4gUChuPW5ldyB0aGlzKG4pLG4uZSsxLHRoaXMucm91bmRpbmcpfWZ1bmN0aW9uIEFuKG4pe3JldHVybihuPW5ldyB0aGlzKG4pKS5kP24uZFswXT9uLnM6MCpuLnM6bi5zfHxOYU59ZnVuY3Rpb24gU24obil7cmV0dXJuIG5ldyB0aGlzKG4pLnNpbigpfWZ1bmN0aW9uIFpuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5zaW5oKCl9ZnVuY3Rpb24gUG4obil7cmV0dXJuIG5ldyB0aGlzKG4pLnNxcnQoKX1mdW5jdGlvbiBSbihuLGUpe3JldHVybiBuZXcgdGhpcyhuKS5zdWIoZSl9ZnVuY3Rpb24gTG4obil7cmV0dXJuIG5ldyB0aGlzKG4pLnRhbigpfWZ1bmN0aW9uIFRuKG4pe3JldHVybiBuZXcgdGhpcyhuKS50YW5oKCl9ZnVuY3Rpb24gVW4obil7cmV0dXJuIFAobj1uZXcgdGhpcyhuKSxuLmUrMSwxKX1yZXR1cm4oZT1mdW5jdGlvbiBuKGUpe3ZhciBpLHQscjtmdW5jdGlvbiBzKG4pe3ZhciBlLGksdCxyPXRoaXM7aWYoIShyIGluc3RhbmNlb2YgcykpcmV0dXJuIG5ldyBzKG4pO2lmKHIuY29uc3RydWN0b3I9cyxuIGluc3RhbmNlb2YgcylyZXR1cm4gci5zPW4ucyx2b2lkKGg/IW4uZHx8bi5lPnMubWF4RT8oci5lPU5hTixyLmQ9bnVsbCk6bi5lPHMubWluRT8oci5lPTAsci5kPVswXSk6KHIuZT1uLmUsci5kPW4uZC5zbGljZSgpKTooci5lPW4uZSxyLmQ9bi5kP24uZC5zbGljZSgpOm4uZCkpO2lmKFwibnVtYmVyXCI9PSh0PXR5cGVvZiBuKSl7aWYoMD09PW4pcmV0dXJuIHIucz0xL248MD8tMToxLHIuZT0wLHZvaWQoci5kPVswXSk7aWYobjwwPyhuPS1uLHIucz0tMSk6ci5zPTEsbj09PX5+biYmbjwxZTcpe2ZvcihlPTAsaT1uO2k+PTEwO2kvPTEwKWUrKztyZXR1cm4gdm9pZChoP2U+cy5tYXhFPyhyLmU9TmFOLHIuZD1udWxsKTplPHMubWluRT8oci5lPTAsci5kPVswXSk6KHIuZT1lLHIuZD1bbl0pOihyLmU9ZSxyLmQ9W25dKSl9cmV0dXJuIDAqbiE9MD8obnx8KHIucz1OYU4pLHIuZT1OYU4sdm9pZChyLmQ9bnVsbCkpOiQocixuLnRvU3RyaW5nKCkpfWlmKFwic3RyaW5nXCIhPT10KXRocm93IEVycm9yKGwrbik7cmV0dXJuIDQ1PT09KGk9bi5jaGFyQ29kZUF0KDApKT8obj1uLnNsaWNlKDEpLHIucz0tMSk6KDQzPT09aSYmKG49bi5zbGljZSgxKSksci5zPTEpLEUudGVzdChuKT8kKHIsbik6VyhyLG4pfWlmKHMucHJvdG90eXBlPU8scy5ST1VORF9VUD0wLHMuUk9VTkRfRE9XTj0xLHMuUk9VTkRfQ0VJTD0yLHMuUk9VTkRfRkxPT1I9MyxzLlJPVU5EX0hBTEZfVVA9NCxzLlJPVU5EX0hBTEZfRE9XTj01LHMuUk9VTkRfSEFMRl9FVkVOPTYscy5ST1VORF9IQUxGX0NFSUw9NyxzLlJPVU5EX0hBTEZfRkxPT1I9OCxzLkVVQ0xJRD05LHMuY29uZmlnPXMuc2V0PWFuLHMuY2xvbmU9bixzLmlzRGVjaW1hbD13bixzLmFicz1YLHMuYWNvcz1ZLHMuYWNvc2g9bm4scy5hZGQ9ZW4scy5hc2luPXRuLHMuYXNpbmg9cm4scy5hdGFuPXNuLHMuYXRhbmg9b24scy5hdGFuMj11bixzLmNicnQ9Y24scy5jZWlsPWZuLHMuY29zPWhuLHMuY29zaD1kbixzLmRpdj1sbixzLmV4cD1wbixzLmZsb29yPWduLHMuaHlwb3Q9bW4scy5sbj12bixzLmxvZz1ObixzLmxvZzEwPUVuLHMubG9nMj1ibixzLm1heD14bixzLm1pbj15bixzLm1vZD1NbixzLm11bD1xbixzLnBvdz1PbixzLnJhbmRvbT1EbixzLnJvdW5kPUZuLHMuc2lnbj1BbixzLnNpbj1TbixzLnNpbmg9Wm4scy5zcXJ0PVBuLHMuc3ViPVJuLHMudGFuPUxuLHMudGFuaD1UbixzLnRydW5jPVVuLHZvaWQgMD09PWUmJihlPXt9KSxlJiYhMCE9PWUuZGVmYXVsdHMpZm9yKHI9W1wicHJlY2lzaW9uXCIsXCJyb3VuZGluZ1wiLFwidG9FeHBOZWdcIixcInRvRXhwUG9zXCIsXCJtYXhFXCIsXCJtaW5FXCIsXCJtb2R1bG9cIixcImNyeXB0b1wiXSxpPTA7aTxyLmxlbmd0aDspZS5oYXNPd25Qcm9wZXJ0eSh0PXJbaSsrXSl8fChlW3RdPXRoaXNbdF0pO3JldHVybiBzLmNvbmZpZyhlKSxzfShhKSkuZGVmYXVsdD1lLkRlY2ltYWw9ZSxjPW5ldyBlKGMpLGY9bmV3IGUoZiksXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShmdW5jdGlvbigpe3JldHVybiBlfSk6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSYmbW9kdWxlLmV4cG9ydHM/KFwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvciYmKE9bU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXT1PLnRvU3RyaW5nLE9bU3ltYm9sLnRvU3RyaW5nVGFnXT1cIkRlY2ltYWxcIiksbW9kdWxlLmV4cG9ydHM9ZSk6KG58fChuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmJiZzZWxmLnNlbGY9PXNlbGY/c2VsZjp3aW5kb3cpLHQ9bi5EZWNpbWFsLGUubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBuLkRlY2ltYWw9dCxlfSxuLkRlY2ltYWw9ZSksZX0odGhpcylcclxuLy8gICAgYmlnRGVjOiByZXF1aXJlKCdkZWNpbWFsLmpzJylcclxufSk7XHJcblxyXG5pZigodHlwZW9mIG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5lcmRhbWVyO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///182\n")},379:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92YW5pbGxhLWludGVncmF0aW9uLTJkLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzJkYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlO1xuICB2YXIgdXBkYXRlO1xuICB2YXIgcmVtb3ZlO1xuXG4gIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgfTtcbiAgfVxuXG4gIHVwZGF0ZShvYmopO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cbiAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICB9XG5cbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRvbVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5Eb21bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5Eb20uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///379\n")},987:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\nvar injectStylesIntoStyleTag = __webpack_require__(379);\nvar injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);\n// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./src/style.css\nvar style = __webpack_require__(426);\n;// CONCATENATED MODULE: ./src/style.css\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = injectStylesIntoStyleTag_default()(style/* default */.Z, options);\n\n\n\n/* harmony default export */ const src_style = (style/* default.locals */.Z.locals || {});\n// EXTERNAL MODULE: ./src/slika.png\nvar slika = __webpack_require__(984);\n;// CONCATENATED MODULE: ./src/index.js\n\r\n\r\n\r\nlet nerdamer = __webpack_require__(182);\r\n// Load additional modules. These are not required.\r\n__webpack_require__(684);\r\n__webpack_require__(238);\r\n__webpack_require__(322);\r\n__webpack_require__(518);\r\n\r\n/**\r\n * Getting the elements from the DOM.\r\n */\r\nlet ctx = document.getElementById('myChart').getContext('2d');\r\nlet src_length = document.getElementById('length');\r\nlet force_n = document.getElementById('force_n');\r\nlet src_area = document.getElementById('area');\r\nlet force_F = document.getElementById('force_F');\r\nlet number_el = document.getElementById('number_el');\r\nlet src_submit = document.getElementById('submit');\r\nlet src_form = document.getElementById(\"container__input--form\");\r\n\r\nsrc_form.addEventListener('submit', (e) => handleSubmit(e));\r\n\r\nlet parameters = [src_length.value, force_n.value, src_area.value, force_F.value, number_el.value];\r\n\r\nfunction handleSubmit(e) {\r\n    e.preventDefault();\r\n\r\n    console.log(src_length.value);\r\n\r\n    if(number_el.value <= 8 && number_el.value >= 0 && number_el.value % 2 == 0) {\r\n        calculate(src_length.value, force_n.value, src_area.value, force_F.value, number_el.value);\r\n    } else {\r\n        alert(\"Oops, you went out of bounds for this calculator!\")\r\n    }\r\n}\r\n\r\n/**\r\n * Define the variables.\r\n */\r\nlet L_ = 1;\r\nlet n1_ = 4000;\r\nlet A1_ = 4 * 10 ** -4;\r\nlet F_ = 1000;\r\nlet elements_ = 4;\r\n\r\ncalculate(L_, n1_, A1_, F_, elements_);\r\n\r\n/**\r\n * Calculate function.\r\n */\r\nfunction calculate(L, n1, A1, F, elements) {\r\n    src_length.value = L;\r\n    force_n.value = n1;\r\n    src_area.value = A1;\r\n    force_F.value = F;\r\n    number_el.value = elements;\r\n\r\n    let c = document.getElementsByClassName('container__chart')[0].children; \r\n\r\n    let Ej = 200 * 10 ** 9;\r\n\r\n    let n = parseInt(elements) + 1;\r\n    let h = L / (elements / 2);\r\n\r\n    let Ke = (Ej*A1/h);\r\n\r\n    let Ke_matrix = [1, -1, -1, 1];\r\n    Ke_matrix = Ke_matrix.map((value) => value * Ke)\r\n\r\n    /**\r\n     * Function for creating matrix with all zeros.\r\n     */\r\n    function zeros(num) {\r\n        let arr = [];\r\n        for(let i = 0; i < num; i++) {\r\n            arr.push(0);\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    /**\r\n     * Function for creating 2D matrix.\r\n     */\r\n    function create2DMatrix(i, j = i) {\r\n        let arr = [];\r\n        for(let x = 0; x < i; x++){\r\n            arr[x] = [];    \r\n            for(let y = 0; y < j; y++){ \r\n                arr[x][y] = 0;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    let K = [];\r\n    K = create2DMatrix(n);\r\n    let Ff = zeros(n);\r\n    let Fn = zeros(n);\r\n\r\n    /**\r\n     * Function for adding one matrix diagonally to another matrix.\r\n     */\r\n    Ke_matrix.forEach(function (value) {\r\n        for(let i = 0; i < elements; i++) {\r\n            K[0][0] = value;\r\n            K[i][i] = 2*value;\r\n            K[i+1][i] = -value;\r\n            K[i][i+1] = -value;\r\n            K[i+1][i+1] = value;\r\n            K[elements-1][elements-1] = 2*value;\r\n\r\n            Fn[0] =  n1 * h / 2;\r\n            Fn[i] =  2 * n1 * h / 2;\r\n            Fn[elements] =  n1 * h / 2; \r\n            /* console.log(Fn); */\r\n        }\r\n    })\r\n\r\n    let U = [];\r\n\r\n    for(let i = 0; i < n; i++) {\r\n        let j = i + 1;\r\n        U[i] = \"u\" + j;\r\n    }\r\n\r\n    U[0] = 0;\r\n    Ff[0] = \"Ra\";\r\n    Ff[Ff.length - 1] = -F;\r\n    Ff[elements / 2] = F;\r\n\r\n    function addMatrix(a,b) {\r\n        for(let i = 0; i < a.length; i++) {\r\n            a[i] += \"+\" + b[i]\r\n        }\r\n\r\n        return a;\r\n    }\r\n    console.log(Fn);\r\n    let addForces = addMatrix(Ff, Fn);\r\n    console.log(addForces);\r\n    \r\n    /**\r\n     * Function for calculating the dot product between matrix and vector.\r\n     */\r\n    function dotProduct(matrix, vector) {\r\n        let arr = [];\r\n        let equation = \"\";\r\n        for(let j = 0; j < matrix.length; j++) {\r\n            for(let i = 0; i < vector.length; i++) {\r\n                equation += `(${matrix[i][j]})*${vector[i]}+`;\r\n            }\r\n            equation = equation.slice(0, -1);\r\n            arr[j] = equation;\r\n            equation = \"\";\r\n        }\r\n\r\n        return arr;\r\n    }\r\n\r\n    let dottedProduct = dotProduct(K, U);\r\n\r\n    let equations=[];\r\n    for(let i = 0; i < dottedProduct.length;i++) {\r\n        equations[i] = dottedProduct[i] + \"=\" + addForces[i];\r\n    }\r\n    equations.forEach(el => console.log(el));\r\n\r\n\r\n    let dataSolutions = nerdamer.solveEquations(equations);\r\n\r\n    function range(start, end, step) {\r\n        let x = [];\r\n        let j = (end-start) / step;\r\n        for(let i = 0; i<=j; i++) {\r\n            x.push(i*step);\r\n        }\r\n        return x;\r\n    }\r\n\r\n    let xRange = range(0, 2* L, h);\r\n\r\n\r\n    let solutions = [];\r\n    solutions = dataSolutions.map((value, index) => value[1])\r\n\r\n    Ke_matrix = Ke_matrix.map((value) => value * Ke)\r\n\r\n    solutions[0] = 0;\r\n    console.log(solutions);\r\n\r\n    /**\r\n     * Function defining chart config.\r\n     */\r\n    const data = {\r\n        labels: xRange,\r\n        datasets: [{\r\n            label: 'u[x] Pomik v odvisnosti od razdalje',\r\n            fill: false,\r\n            backgroundColor: 'rgb(255, 99, 132)',\r\n            borderColor: 'rgb(255, 99, 132)',\r\n            data: solutions,\r\n            tension: 0.0,\r\n        }]\r\n    };\r\n\r\n    // </block:setup>\r\n    \r\n    // <block:config:0>\r\n    const config = {\r\n        type: 'line',\r\n        data,\r\n        options: {\r\n            scales: {\r\n                yAxes: [{\r\n                    scaleLabel: {\r\n                        display: true,\r\n                        labelString: 'Pomik u [m]',\r\n                        fontSize: 20,\r\n                    },\r\n                    \r\n                }],\r\n                xAxes: [{\r\n                    scaleLabel: {\r\n                        display: true,\r\n                        labelString: 'Razdalja nosilca x [m]',\r\n                        fontSize: 20,\r\n                    }\r\n                }]\r\n            }   \r\n        },\r\n    };\r\n    // </block:config>\r\n    let myChart = document.getElementById('myChart');\r\n\r\n    let myChart2 = new Chart(myChart, config);\r\n    /* console.log(myChart); */\r\n}\r\n\r\nlet img = document.createElement(\"img\");\r\nimg.src = slika;\r\n\r\nlet src = document.getElementById(\"slika\");\r\nsrc.appendChild(img);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92YW5pbGxhLWludGVncmF0aW9uLTJkLy4vc3JjL3N0eWxlLmNzcz83MTYzIiwid2VicGFjazovL3ZhbmlsbGEtaW50ZWdyYXRpb24tMmQvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXBpIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLmNzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsImltcG9ydCBjc3MgZnJvbSBcIi4vc3R5bGUuY3NzXCI7XHJcbmltcG9ydCBzbGlrYSBmcm9tIFwiLi9zbGlrYS5wbmdcIjtcclxuXHJcbmxldCBuZXJkYW1lciA9IHJlcXVpcmUoJ25lcmRhbWVyJyk7XHJcbi8vIExvYWQgYWRkaXRpb25hbCBtb2R1bGVzLiBUaGVzZSBhcmUgbm90IHJlcXVpcmVkLlxyXG5yZXF1aXJlKCduZXJkYW1lci9BbGdlYnJhJyk7XHJcbnJlcXVpcmUoJ25lcmRhbWVyL0NhbGN1bHVzJyk7XHJcbnJlcXVpcmUoJ25lcmRhbWVyL1NvbHZlJyk7XHJcbnJlcXVpcmUoJ25lcmRhbWVyL0V4dHJhJyk7XHJcblxyXG4vKipcclxuICogR2V0dGluZyB0aGUgZWxlbWVudHMgZnJvbSB0aGUgRE9NLlxyXG4gKi9cclxubGV0IGN0eCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteUNoYXJ0JykuZ2V0Q29udGV4dCgnMmQnKTtcclxubGV0IGxlbmd0aCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsZW5ndGgnKTtcclxubGV0IGZvcmNlX24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9yY2VfbicpO1xyXG5sZXQgYXJlYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcmVhJyk7XHJcbmxldCBmb3JjZV9GID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvcmNlX0YnKTtcclxubGV0IG51bWJlcl9lbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdudW1iZXJfZWwnKTtcclxubGV0IHN1Ym1pdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdWJtaXQnKTtcclxubGV0IGZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRhaW5lcl9faW5wdXQtLWZvcm1cIik7XHJcblxyXG5mb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIChlKSA9PiBoYW5kbGVTdWJtaXQoZSkpO1xyXG5cclxubGV0IHBhcmFtZXRlcnMgPSBbbGVuZ3RoLnZhbHVlLCBmb3JjZV9uLnZhbHVlLCBhcmVhLnZhbHVlLCBmb3JjZV9GLnZhbHVlLCBudW1iZXJfZWwudmFsdWVdO1xyXG5cclxuZnVuY3Rpb24gaGFuZGxlU3VibWl0KGUpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhsZW5ndGgudmFsdWUpO1xyXG5cclxuICAgIGlmKG51bWJlcl9lbC52YWx1ZSA8PSA4ICYmIG51bWJlcl9lbC52YWx1ZSA+PSAwICYmIG51bWJlcl9lbC52YWx1ZSAlIDIgPT0gMCkge1xyXG4gICAgICAgIGNhbGN1bGF0ZShsZW5ndGgudmFsdWUsIGZvcmNlX24udmFsdWUsIGFyZWEudmFsdWUsIGZvcmNlX0YudmFsdWUsIG51bWJlcl9lbC52YWx1ZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFsZXJ0KFwiT29wcywgeW91IHdlbnQgb3V0IG9mIGJvdW5kcyBmb3IgdGhpcyBjYWxjdWxhdG9yIVwiKVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lIHRoZSB2YXJpYWJsZXMuXHJcbiAqL1xyXG5sZXQgTF8gPSAxO1xyXG5sZXQgbjFfID0gNDAwMDtcclxubGV0IEExXyA9IDQgKiAxMCAqKiAtNDtcclxubGV0IEZfID0gMTAwMDtcclxubGV0IGVsZW1lbnRzXyA9IDQ7XHJcblxyXG5jYWxjdWxhdGUoTF8sIG4xXywgQTFfLCBGXywgZWxlbWVudHNfKTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWxjdWxhdGUoTCwgbjEsIEExLCBGLCBlbGVtZW50cykge1xyXG4gICAgbGVuZ3RoLnZhbHVlID0gTDtcclxuICAgIGZvcmNlX24udmFsdWUgPSBuMTtcclxuICAgIGFyZWEudmFsdWUgPSBBMTtcclxuICAgIGZvcmNlX0YudmFsdWUgPSBGO1xyXG4gICAgbnVtYmVyX2VsLnZhbHVlID0gZWxlbWVudHM7XHJcblxyXG4gICAgbGV0IGMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjb250YWluZXJfX2NoYXJ0JylbMF0uY2hpbGRyZW47IFxyXG5cclxuICAgIGxldCBFaiA9IDIwMCAqIDEwICoqIDk7XHJcblxyXG4gICAgbGV0IG4gPSBwYXJzZUludChlbGVtZW50cykgKyAxO1xyXG4gICAgbGV0IGggPSBMIC8gKGVsZW1lbnRzIC8gMik7XHJcblxyXG4gICAgbGV0IEtlID0gKEVqKkExL2gpO1xyXG5cclxuICAgIGxldCBLZV9tYXRyaXggPSBbMSwgLTEsIC0xLCAxXTtcclxuICAgIEtlX21hdHJpeCA9IEtlX21hdHJpeC5tYXAoKHZhbHVlKSA9PiB2YWx1ZSAqIEtlKVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gZm9yIGNyZWF0aW5nIG1hdHJpeCB3aXRoIGFsbCB6ZXJvcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gemVyb3MobnVtKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBudW07IGkrKykge1xyXG4gICAgICAgICAgICBhcnIucHVzaCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIGZvciBjcmVhdGluZyAyRCBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZTJETWF0cml4KGksIGogPSBpKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGZvcihsZXQgeCA9IDA7IHggPCBpOyB4Kyspe1xyXG4gICAgICAgICAgICBhcnJbeF0gPSBbXTsgICAgXHJcbiAgICAgICAgICAgIGZvcihsZXQgeSA9IDA7IHkgPCBqOyB5KyspeyBcclxuICAgICAgICAgICAgICAgIGFyclt4XVt5XSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgSyA9IFtdO1xyXG4gICAgSyA9IGNyZWF0ZTJETWF0cml4KG4pO1xyXG4gICAgbGV0IEZmID0gemVyb3Mobik7XHJcbiAgICBsZXQgRm4gPSB6ZXJvcyhuKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIGZvciBhZGRpbmcgb25lIG1hdHJpeCBkaWFnb25hbGx5IHRvIGFub3RoZXIgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBLZV9tYXRyaXguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZWxlbWVudHM7IGkrKykge1xyXG4gICAgICAgICAgICBLWzBdWzBdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIEtbaV1baV0gPSAyKnZhbHVlO1xyXG4gICAgICAgICAgICBLW2krMV1baV0gPSAtdmFsdWU7XHJcbiAgICAgICAgICAgIEtbaV1baSsxXSA9IC12YWx1ZTtcclxuICAgICAgICAgICAgS1tpKzFdW2krMV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgS1tlbGVtZW50cy0xXVtlbGVtZW50cy0xXSA9IDIqdmFsdWU7XHJcblxyXG4gICAgICAgICAgICBGblswXSA9ICBuMSAqIGggLyAyO1xyXG4gICAgICAgICAgICBGbltpXSA9ICAyICogbjEgKiBoIC8gMjtcclxuICAgICAgICAgICAgRm5bZWxlbWVudHNdID0gIG4xICogaCAvIDI7IFxyXG4gICAgICAgICAgICAvKiBjb25zb2xlLmxvZyhGbik7ICovXHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBsZXQgVSA9IFtdO1xyXG5cclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBsZXQgaiA9IGkgKyAxO1xyXG4gICAgICAgIFVbaV0gPSBcInVcIiArIGo7XHJcbiAgICB9XHJcblxyXG4gICAgVVswXSA9IDA7XHJcbiAgICBGZlswXSA9IFwiUmFcIjtcclxuICAgIEZmW0ZmLmxlbmd0aCAtIDFdID0gLUY7XHJcbiAgICBGZltlbGVtZW50cyAvIDJdID0gRjtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRNYXRyaXgoYSxiKSB7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYVtpXSArPSBcIitcIiArIGJbaV1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coRm4pO1xyXG4gICAgbGV0IGFkZEZvcmNlcyA9IGFkZE1hdHJpeChGZiwgRm4pO1xyXG4gICAgY29uc29sZS5sb2coYWRkRm9yY2VzKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gbWF0cml4IGFuZCB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvdFByb2R1Y3QobWF0cml4LCB2ZWN0b3IpIHtcclxuICAgICAgICBsZXQgYXJyID0gW107XHJcbiAgICAgICAgbGV0IGVxdWF0aW9uID0gXCJcIjtcclxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbWF0cml4Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB2ZWN0b3IubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVxdWF0aW9uICs9IGAoJHttYXRyaXhbaV1bal19KSoke3ZlY3RvcltpXX0rYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlcXVhdGlvbiA9IGVxdWF0aW9uLnNsaWNlKDAsIC0xKTtcclxuICAgICAgICAgICAgYXJyW2pdID0gZXF1YXRpb247XHJcbiAgICAgICAgICAgIGVxdWF0aW9uID0gXCJcIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGRvdHRlZFByb2R1Y3QgPSBkb3RQcm9kdWN0KEssIFUpO1xyXG5cclxuICAgIGxldCBlcXVhdGlvbnM9W107XHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZG90dGVkUHJvZHVjdC5sZW5ndGg7aSsrKSB7XHJcbiAgICAgICAgZXF1YXRpb25zW2ldID0gZG90dGVkUHJvZHVjdFtpXSArIFwiPVwiICsgYWRkRm9yY2VzW2ldO1xyXG4gICAgfVxyXG4gICAgZXF1YXRpb25zLmZvckVhY2goZWwgPT4gY29uc29sZS5sb2coZWwpKTtcclxuXHJcblxyXG4gICAgbGV0IGRhdGFTb2x1dGlvbnMgPSBuZXJkYW1lci5zb2x2ZUVxdWF0aW9ucyhlcXVhdGlvbnMpO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcclxuICAgICAgICBsZXQgeCA9IFtdO1xyXG4gICAgICAgIGxldCBqID0gKGVuZC1zdGFydCkgLyBzdGVwO1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGk8PWo7IGkrKykge1xyXG4gICAgICAgICAgICB4LnB1c2goaSpzdGVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHhSYW5nZSA9IHJhbmdlKDAsIDIqIEwsIGgpO1xyXG5cclxuXHJcbiAgICBsZXQgc29sdXRpb25zID0gW107XHJcbiAgICBzb2x1dGlvbnMgPSBkYXRhU29sdXRpb25zLm1hcCgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZVsxXSlcclxuXHJcbiAgICBLZV9tYXRyaXggPSBLZV9tYXRyaXgubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKiBLZSlcclxuXHJcbiAgICBzb2x1dGlvbnNbMF0gPSAwO1xyXG4gICAgY29uc29sZS5sb2coc29sdXRpb25zKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIGRlZmluaW5nIGNoYXJ0IGNvbmZpZy5cclxuICAgICAqL1xyXG4gICAgY29uc3QgZGF0YSA9IHtcclxuICAgICAgICBsYWJlbHM6IHhSYW5nZSxcclxuICAgICAgICBkYXRhc2V0czogW3tcclxuICAgICAgICAgICAgbGFiZWw6ICd1W3hdIFBvbWlrIHYgb2R2aXNub3N0aSBvZCByYXpkYWxqZScsXHJcbiAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjU1LCA5OSwgMTMyKScsXHJcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiKDI1NSwgOTksIDEzMiknLFxyXG4gICAgICAgICAgICBkYXRhOiBzb2x1dGlvbnMsXHJcbiAgICAgICAgICAgIHRlbnNpb246IDAuMCxcclxuICAgICAgICB9XVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyA8L2Jsb2NrOnNldHVwPlxyXG4gICAgXHJcbiAgICAvLyA8YmxvY2s6Y29uZmlnOjA+XHJcbiAgICBjb25zdCBjb25maWcgPSB7XHJcbiAgICAgICAgdHlwZTogJ2xpbmUnLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzY2FsZXM6IHtcclxuICAgICAgICAgICAgICAgIHlBeGVzOiBbe1xyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlTGFiZWw6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdQb21payB1IFttXScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAyMCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgICAgICAgICB4QXhlczogW3tcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZUxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnUmF6ZGFsamEgbm9zaWxjYSB4IFttXScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAyMCxcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9ICAgXHJcbiAgICAgICAgfSxcclxuICAgIH07XHJcbiAgICAvLyA8L2Jsb2NrOmNvbmZpZz5cclxuICAgIGxldCBteUNoYXJ0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215Q2hhcnQnKTtcclxuXHJcbiAgICBsZXQgbXlDaGFydDIgPSBuZXcgQ2hhcnQobXlDaGFydCwgY29uZmlnKTtcclxuICAgIC8qIGNvbnNvbGUubG9nKG15Q2hhcnQpOyAqL1xyXG59XHJcblxyXG5sZXQgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuaW1nLnNyYyA9IHNsaWthO1xyXG5cclxubGV0IHNyYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2xpa2FcIik7XHJcbnNyYy5hcHBlbmRDaGlsZChpbWcpO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///987\n")},984:(g,I,C)=>{"use strict";g.exports=C.p+"6952ba378173272f566a.png"}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var C=__webpack_module_cache__[g]={id:g,loaded:!1,exports:{}};return __webpack_modules__[g].call(C.exports,C,C.exports,__webpack_require__),C.loaded=!0,C.exports}__webpack_require__.n=g=>{var I=g&&g.__esModule?()=>g.default:()=>g;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(g,I)=>{for(var C in I)__webpack_require__.o(I,C)&&!__webpack_require__.o(g,C)&&Object.defineProperty(g,C,{enumerable:!0,get:I[C]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(g){if("object"==typeof window)return window}}(),__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.nmd=g=>(g.paths=[],g.children||(g.children=[]),g),(()=>{var g;__webpack_require__.g.importScripts&&(g=__webpack_require__.g.location+"");var I=__webpack_require__.g.document;if(!g&&I&&(I.currentScript&&(g=I.currentScript.src),!g)){var C=I.getElementsByTagName("script");C.length&&(g=C[C.length-1].src)}if(!g)throw new Error("Automatic publicPath is not supported in this browser");g=g.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=g})();var __webpack_exports__=__webpack_require__(987)})();