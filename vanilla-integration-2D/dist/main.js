/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\r\\n* {\\r\\n    box-sizing: border-box;\\r\\n    background: #e5e5e5;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    font-family: \\\"Poppins\\\", sans-serif;\\r\\n    margin: 0;\\r\\n    /* background-image: url(\\\"./slika.png\\\"); */\\r\\n}\\r\\n\\r\\n.container {\\r\\n    display: flex;\\r\\n    justify-content: center;\\r\\n    flex-direction: column;\\r\\n    align-items: center;\\r\\n}\\r\\n\\r\\n.container__chart {\\r\\n    box-sizing: border-box;\\r\\n    width: 500px;\\r\\n}\\r\\n\\r\\n/* .input {\\r\\n    width: 50px;\\r\\n} */\\r\\n\\r\\n#container__input--form > label {\\r\\n    margin-top: 1rem;\\r\\n}\\r\\n\\r\\n#container__input--form {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n}\\r\\n\\r\\n.input[type=\\\"text\\\"] {\\r\\n    /* background: url(search-white.png) no-repeat 10px 6px #fcfcfc; */\\r\\n    border: 1px solid #d1d1d1;\\r\\n    font: bold 12px Arial,Helvetica,Sans-serif;\\r\\n    color: #3a3838;\\r\\n    width: 200px;\\r\\n    padding: 6px 15px 6px 35px;\\r\\n    -webkit-border-radius: 20px;\\r\\n    -moz-border-radius: 20px;\\r\\n    border-radius: 20px;\\r\\n    text-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);\\r\\n    -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    -webkit-transition: all 0.7s ease 0s;\\r\\n    -moz-transition: all 0.7s ease 0s;\\r\\n    -o-transition: all 0.7s ease 0s;\\r\\n    transition: all 0.7s ease 0s;\\r\\n    outline:none;\\r\\n}\\r\\n\\r\\n.submit__button {\\r\\n    border: 1px solid #d1d1d1;\\r\\n    font: bold 12px Arial,Helvetica,Sans-serif;\\r\\n    color: #3a3838;\\r\\n    /* width: 50px; */\\r\\n    /* margin-top: 1rem; */\\r\\n    height: 20px;\\r\\n    border-radius: 20px;\\r\\n    cursor: pointer;\\r\\n    margin-top: 1.5rem;\\r\\n    margin-bottom: 1.5rem;\\r\\n  }\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/style.css\"],\"names\":[],\"mappings\":\";AACA;IACI,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,kCAAkC;IAClC,SAAS;IACT,0CAA0C;AAC9C;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,sBAAsB;IACtB,mBAAmB;AACvB;;AAEA;IACI,sBAAsB;IACtB,YAAY;AAChB;;AAEA;;GAEG;;AAEH;IACI,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,sBAAsB;AAC1B;;AAEA;IACI,kEAAkE;IAClE,yBAAyB;IACzB,0CAA0C;IAC1C,cAAc;IACd,YAAY;IACZ,0BAA0B;IAC1B,2BAA2B;IAC3B,wBAAwB;IACxB,mBAAmB;IACnB,yCAAyC;IACzC,uDAAuD;IACvD,oDAAoD;IACpD,+CAA+C;IAC/C,oCAAoC;IACpC,iCAAiC;IACjC,+BAA+B;IAC/B,4BAA4B;IAC5B,YAAY;AAChB;;AAEA;IACI,yBAAyB;IACzB,0CAA0C;IAC1C,cAAc;IACd,iBAAiB;IACjB,sBAAsB;IACtB,YAAY;IACZ,mBAAmB;IACnB,eAAe;IACf,kBAAkB;IAClB,qBAAqB;EACvB\",\"sourcesContent\":[\"\\r\\n* {\\r\\n    box-sizing: border-box;\\r\\n    background: #e5e5e5;\\r\\n}\\r\\n\\r\\nbody {\\r\\n    font-family: \\\"Poppins\\\", sans-serif;\\r\\n    margin: 0;\\r\\n    /* background-image: url(\\\"./slika.png\\\"); */\\r\\n}\\r\\n\\r\\n.container {\\r\\n    display: flex;\\r\\n    justify-content: center;\\r\\n    flex-direction: column;\\r\\n    align-items: center;\\r\\n}\\r\\n\\r\\n.container__chart {\\r\\n    box-sizing: border-box;\\r\\n    width: 500px;\\r\\n}\\r\\n\\r\\n/* .input {\\r\\n    width: 50px;\\r\\n} */\\r\\n\\r\\n#container__input--form > label {\\r\\n    margin-top: 1rem;\\r\\n}\\r\\n\\r\\n#container__input--form {\\r\\n    display: flex;\\r\\n    flex-direction: column;\\r\\n}\\r\\n\\r\\n.input[type=\\\"text\\\"] {\\r\\n    /* background: url(search-white.png) no-repeat 10px 6px #fcfcfc; */\\r\\n    border: 1px solid #d1d1d1;\\r\\n    font: bold 12px Arial,Helvetica,Sans-serif;\\r\\n    color: #3a3838;\\r\\n    width: 200px;\\r\\n    padding: 6px 15px 6px 35px;\\r\\n    -webkit-border-radius: 20px;\\r\\n    -moz-border-radius: 20px;\\r\\n    border-radius: 20px;\\r\\n    text-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);\\r\\n    -webkit-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    -moz-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15) inset;\\r\\n    -webkit-transition: all 0.7s ease 0s;\\r\\n    -moz-transition: all 0.7s ease 0s;\\r\\n    -o-transition: all 0.7s ease 0s;\\r\\n    transition: all 0.7s ease 0s;\\r\\n    outline:none;\\r\\n}\\r\\n\\r\\n.submit__button {\\r\\n    border: 1px solid #d1d1d1;\\r\\n    font: bold 12px Arial,Helvetica,Sans-serif;\\r\\n    color: #3a3838;\\r\\n    /* width: 50px; */\\r\\n    /* margin-top: 1rem; */\\r\\n    height: 20px;\\r\\n    border-radius: 20px;\\r\\n    cursor: pointer;\\r\\n    margin-top: 1.5rem;\\r\\n    margin-bottom: 1.5rem;\\r\\n  }\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9zdHlsZS5jc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmFuaWxsYS1pbnRlZ3JhdGlvbi0yZC8uL3NyYy9zdHlsZS5jc3M/MjdhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcclxcbioge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZTVlNWU1O1xcclxcbn1cXHJcXG5cXHJcXG5ib2R5IHtcXHJcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJQb3BwaW5zXFxcIiwgc2Fucy1zZXJpZjtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICAvKiBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4vc2xpa2EucG5nXFxcIik7ICovXFxyXFxufVxcclxcblxcclxcbi5jb250YWluZXIge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbnRhaW5lcl9fY2hhcnQge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICB3aWR0aDogNTAwcHg7XFxyXFxufVxcclxcblxcclxcbi8qIC5pbnB1dCB7XFxyXFxuICAgIHdpZHRoOiA1MHB4O1xcclxcbn0gKi9cXHJcXG5cXHJcXG4jY29udGFpbmVyX19pbnB1dC0tZm9ybSA+IGxhYmVsIHtcXHJcXG4gICAgbWFyZ2luLXRvcDogMXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuI2NvbnRhaW5lcl9faW5wdXQtLWZvcm0ge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdIHtcXHJcXG4gICAgLyogYmFja2dyb3VuZDogdXJsKHNlYXJjaC13aGl0ZS5wbmcpIG5vLXJlcGVhdCAxMHB4IDZweCAjZmNmY2ZjOyAqL1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZDFkMWQxO1xcclxcbiAgICBmb250OiBib2xkIDEycHggQXJpYWwsSGVsdmV0aWNhLFNhbnMtc2VyaWY7XFxyXFxuICAgIGNvbG9yOiAjM2EzODM4O1xcclxcbiAgICB3aWR0aDogMjAwcHg7XFxyXFxuICAgIHBhZGRpbmc6IDZweCAxNXB4IDZweCAzNXB4O1xcclxcbiAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDIwcHg7XFxyXFxuICAgIC1tb3otYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgdGV4dC1zaGFkb3c6IDAgMnB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxyXFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNSkgaW5zZXQ7XFxyXFxuICAgIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNSkgaW5zZXQ7XFxyXFxuICAgIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTUpIGluc2V0O1xcclxcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjdzIGVhc2UgMHM7XFxyXFxuICAgIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgLW8tdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgb3V0bGluZTpub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uc3VibWl0X19idXR0b24ge1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZDFkMWQxO1xcclxcbiAgICBmb250OiBib2xkIDEycHggQXJpYWwsSGVsdmV0aWNhLFNhbnMtc2VyaWY7XFxyXFxuICAgIGNvbG9yOiAjM2EzODM4O1xcclxcbiAgICAvKiB3aWR0aDogNTBweDsgKi9cXHJcXG4gICAgLyogbWFyZ2luLXRvcDogMXJlbTsgKi9cXHJcXG4gICAgaGVpZ2h0OiAyMHB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIG1hcmdpbi10b3A6IDEuNXJlbTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMS41cmVtO1xcclxcbiAgfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQUNBO0lBQ0ksc0JBQXNCO0lBQ3RCLG1CQUFtQjtBQUN2Qjs7QUFFQTtJQUNJLGtDQUFrQztJQUNsQyxTQUFTO0lBQ1QsMENBQTBDO0FBQzlDOztBQUVBO0lBQ0ksYUFBYTtJQUNiLHVCQUF1QjtJQUN2QixzQkFBc0I7SUFDdEIsbUJBQW1CO0FBQ3ZCOztBQUVBO0lBQ0ksc0JBQXNCO0lBQ3RCLFlBQVk7QUFDaEI7O0FBRUE7O0dBRUc7O0FBRUg7SUFDSSxnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSxhQUFhO0lBQ2Isc0JBQXNCO0FBQzFCOztBQUVBO0lBQ0ksa0VBQWtFO0lBQ2xFLHlCQUF5QjtJQUN6QiwwQ0FBMEM7SUFDMUMsY0FBYztJQUNkLFlBQVk7SUFDWiwwQkFBMEI7SUFDMUIsMkJBQTJCO0lBQzNCLHdCQUF3QjtJQUN4QixtQkFBbUI7SUFDbkIseUNBQXlDO0lBQ3pDLHVEQUF1RDtJQUN2RCxvREFBb0Q7SUFDcEQsK0NBQStDO0lBQy9DLG9DQUFvQztJQUNwQyxpQ0FBaUM7SUFDakMsK0JBQStCO0lBQy9CLDRCQUE0QjtJQUM1QixZQUFZO0FBQ2hCOztBQUVBO0lBQ0kseUJBQXlCO0lBQ3pCLDBDQUEwQztJQUMxQyxjQUFjO0lBQ2QsaUJBQWlCO0lBQ2pCLHNCQUFzQjtJQUN0QixZQUFZO0lBQ1osbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixrQkFBa0I7SUFDbEIscUJBQXFCO0VBQ3ZCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcclxcbioge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICBiYWNrZ3JvdW5kOiAjZTVlNWU1O1xcclxcbn1cXHJcXG5cXHJcXG5ib2R5IHtcXHJcXG4gICAgZm9udC1mYW1pbHk6IFxcXCJQb3BwaW5zXFxcIiwgc2Fucy1zZXJpZjtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgICAvKiBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXFxcIi4vc2xpa2EucG5nXFxcIik7ICovXFxyXFxufVxcclxcblxcclxcbi5jb250YWluZXIge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG59XFxyXFxuXFxyXFxuLmNvbnRhaW5lcl9fY2hhcnQge1xcclxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICB3aWR0aDogNTAwcHg7XFxyXFxufVxcclxcblxcclxcbi8qIC5pbnB1dCB7XFxyXFxuICAgIHdpZHRoOiA1MHB4O1xcclxcbn0gKi9cXHJcXG5cXHJcXG4jY29udGFpbmVyX19pbnB1dC0tZm9ybSA+IGxhYmVsIHtcXHJcXG4gICAgbWFyZ2luLXRvcDogMXJlbTtcXHJcXG59XFxyXFxuXFxyXFxuI2NvbnRhaW5lcl9faW5wdXQtLWZvcm0ge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbn1cXHJcXG5cXHJcXG4uaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdIHtcXHJcXG4gICAgLyogYmFja2dyb3VuZDogdXJsKHNlYXJjaC13aGl0ZS5wbmcpIG5vLXJlcGVhdCAxMHB4IDZweCAjZmNmY2ZjOyAqL1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZDFkMWQxO1xcclxcbiAgICBmb250OiBib2xkIDEycHggQXJpYWwsSGVsdmV0aWNhLFNhbnMtc2VyaWY7XFxyXFxuICAgIGNvbG9yOiAjM2EzODM4O1xcclxcbiAgICB3aWR0aDogMjAwcHg7XFxyXFxuICAgIHBhZGRpbmc6IDZweCAxNXB4IDZweCAzNXB4O1xcclxcbiAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDIwcHg7XFxyXFxuICAgIC1tb3otYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gICAgdGV4dC1zaGFkb3c6IDAgMnB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMSk7XFxyXFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNSkgaW5zZXQ7XFxyXFxuICAgIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNSkgaW5zZXQ7XFxyXFxuICAgIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTUpIGluc2V0O1xcclxcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjdzIGVhc2UgMHM7XFxyXFxuICAgIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgLW8tdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZSAwcztcXHJcXG4gICAgb3V0bGluZTpub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uc3VibWl0X19idXR0b24ge1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZDFkMWQxO1xcclxcbiAgICBmb250OiBib2xkIDEycHggQXJpYWwsSGVsdmV0aWNhLFNhbnMtc2VyaWY7XFxyXFxuICAgIGNvbG9yOiAjM2EzODM4O1xcclxcbiAgICAvKiB3aWR0aDogNTBweDsgKi9cXHJcXG4gICAgLyogbWFyZ2luLXRvcDogMXJlbTsgKi9cXHJcXG4gICAgaGVpZ2h0OiAyMHB4O1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAyMHB4O1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICAgIG1hcmdpbi10b3A6IDEuNXJlbTtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMS41cmVtO1xcclxcbiAgfVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js!./src/style.css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZhbmlsbGEtaW50ZWdyYXRpb24tMmQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92YW5pbGxhLWludGVncmF0aW9uLTJkLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanM/NzVlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyICYmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl0pOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSkge1xuICB2YXIgX2l0ZW0gPSBfc2xpY2VkVG9BcnJheShpdGVtLCA0KSxcbiAgICAgIGNvbnRlbnQgPSBfaXRlbVsxXSxcbiAgICAgIGNzc01hcHBpbmcgPSBfaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\n");

/***/ }),

/***/ "./node_modules/nerdamer/Algebra.js":
/*!******************************************!*\
  !*** ./node_modules/nerdamer/Algebra.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module, Function */\r\n\r\nif(true) {\r\n    var nerdamer = __webpack_require__(/*! ./nerdamer.core.js */ \"./node_modules/nerdamer/nerdamer.core.js\");\r\n    __webpack_require__(/*! ./Calculus.js */ \"./node_modules/nerdamer/Calculus.js\");\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    /*shortcuts*/\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            N = core.groups.N,\r\n            P = core.groups.P,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            keys = core.Utils.keys,\r\n            even = core.Utils.even,\r\n            variables = core.Utils.variables,\r\n            format = core.Utils.format,\r\n            round = core.Utils.round,\r\n            Frac = core.Frac,\r\n            isInt = core.Utils.isInt,\r\n            Symbol = core.Symbol,\r\n            CONST_HASH = core.Settings.CONST_HASH,\r\n            math = core.Utils.importFunctions(),\r\n            evaluate = core.Utils.evaluate;\r\n    //*************** CLASSES ***************//\r\n    /**\r\n     * Converts a symbol into an equivalent polynomial arrays of \r\n     * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n     * Univariate polymials only. \r\n     * @param {Symbol|Number} symbol\r\n     * @param {String} variable The variable name of the polynomial\r\n     * @param {int} order\r\n     */\r\n    function Polynomial(symbol, variable, order) {\r\n        if(core.Utils.isSymbol(symbol)) {\r\n            this.parse(symbol);\r\n            this.variable = this.variable || variable;\r\n        }\r\n        else if(!isNaN(symbol)) {\r\n            order = order || 0;\r\n            if(variable === undefined)\r\n                throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\r\n            this.coeffs = [];\r\n            this.coeffs[order] = symbol;\r\n            this.fill(symbol);\r\n        }\r\n        else if(typeof symbol === 'string') {\r\n            this.parse(_.parse(symbol));\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Polynomial given an array of coefficients\r\n     * @param {int[]} arr\r\n     * @param {String} variable\r\n     * @returns {Polynomial}\r\n     */\r\n    Polynomial.fromArray = function (arr, variable) {\r\n        if(typeof variable === 'undefined')\r\n            throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\r\n        var p = new Polynomial();\r\n        p.coeffs = arr;\r\n        p.variable = variable;\r\n        return p;\r\n    };\r\n\r\n    Polynomial.fit = function (c1, c2, n, base, p, variable) {\r\n        //after having looped through and mod 10 the number to get the matching factor\r\n        var terms = new Array(p + 1),\r\n                t = n - c2;\r\n        terms[0] = c2; //the constants is assumed to be correct\r\n        //constant for x^p is also assumed know so add\r\n        terms[p] = c1;\r\n        t -= c1 * Math.pow(base, p);\r\n        //start fitting\r\n        for(var i = p - 1; i > 0; i--) {\r\n            var b = Math.pow(base, i), //we want as many wholes as possible\r\n                    q = t / b,\r\n                    sign = Math.sign(q);\r\n            var c = sign * Math.floor(Math.abs(q));\r\n            t -= c * b;\r\n            terms[i] = c;\r\n        }\r\n        if(t !== 0)\r\n            return null;\r\n        for(var i = 0; i < terms.length; i++)\r\n            terms[i] = new Frac(terms[i]);\r\n\r\n        return Polynomial.fromArray(terms, variable);\r\n    };\r\n\r\n    Polynomial.prototype = {\r\n        /**\r\n         * Converts Symbol to Polynomial\r\n         * @param {Symbol} symbol\r\n         * @param {Array} c - a collector array\r\n         * @returns {Polynomial}\r\n         */\r\n        parse: function (symbol, c) {\r\n            this.variable = variables(symbol)[0];\r\n            if(!symbol.isPoly())\r\n                throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\r\n            c = c || [];\r\n            if(!symbol.power.absEquals(1))\r\n                symbol = _.expand(symbol);\r\n\r\n            if(symbol.group === core.groups.N) {\r\n                c[0] = symbol.multiplier;\r\n            }\r\n            else if(symbol.group === core.groups.S) {\r\n                c[symbol.power.toDecimal()] = symbol.multiplier;\r\n            }\r\n            else {\r\n                for(var x in symbol.symbols) {\r\n                    var sub = symbol.symbols[x],\r\n                            p = sub.power;\r\n                    if(core.Utils.isSymbol(p))\r\n                        throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\r\n\r\n                    p = sub.group === N ? 0 : p.toDecimal();\r\n                    if(sub.symbols) {\r\n                        this.parse(sub, c);\r\n                    }\r\n                    else {\r\n                        c[p] = sub.multiplier;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.coeffs = c;\r\n\r\n            this.fill();\r\n        },\r\n        /**\r\n         * Fills in the holes in a polynomial with zeroes\r\n         * @param {Number} x - The number to fill the holes with\r\n         */\r\n        fill: function (x) {\r\n            x = Number(x) || 0;\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(this.coeffs[i] === undefined) {\r\n                    this.coeffs[i] = new Frac(x);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Removes higher order zeros or a specific coefficient\r\n         * @returns {Array}\r\n         */\r\n        trim: function () {\r\n            var l = this.coeffs.length;\r\n            while(l--) {\r\n                var c = this.coeffs[l];\r\n                var equalsZero = c.equals(0);\r\n                if(c && equalsZero) {\r\n                    if(l === 0)\r\n                        break;\r\n                    this.coeffs.pop();\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /*\r\n         * Returns polynomial mod p **currently fails**\r\n         * @param {Number} p\r\n         * @returns {Polynomial}\r\n         */\r\n        modP: function (p) {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = this.coeffs[i];\r\n                if(c < 0) { //go borrow\r\n                    var b; //a coefficient > 0\r\n                    for(var j = i; j < l; j++) {//starting from where we left off\r\n                        if(this.coeffs[j] > 0) {\r\n                            b = this.coeffs[j];\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(b) { //if such a coefficient exists\r\n                        for(j; j > i; j--) { //go down the line and adjust using p\r\n                            this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\r\n                            this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\r\n                        }\r\n                        c = this.coeffs[i]; //reset c\r\n                    }\r\n                }\r\n\r\n                var d = c.mod(p);\r\n                var w = c.subtract(d).divide(p);\r\n                if(!w.equals(0)) {\r\n                    var up_one = i + 1;\r\n                    var next = this.coeffs[up_one] || new Frac(0);\r\n                    next = next.add(w);\r\n                    this.coeffs[up_one] = new Frac(next);\r\n                    this.coeffs[i] = new Frac(d);\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        add: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.add(b);\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        subtract: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.subtract(b);\r\n            }\r\n            return this;\r\n        },\r\n        divide: function (poly) {\r\n            var variable = this.variable,\r\n                    dividend = core.Utils.arrayClone(this.coeffs),\r\n                    divisor = core.Utils.arrayClone(poly.coeffs),\r\n                    n = dividend.length,\r\n                    mp = divisor.length - 1,\r\n                    quotient = [];\r\n\r\n            //loop through the dividend\r\n            for(var i = 0; i < n; i++) {\r\n                var p = n - (i + 1);\r\n                //get the difference of the powers\r\n                var d = p - mp;\r\n                //get the quotient of the coefficients\r\n                var q = dividend[p].divide(divisor[mp]);\r\n\r\n                if(d < 0)\r\n                    break;//the divisor is not greater than the dividend\r\n                //place it in the quotient\r\n                quotient[d] = q;\r\n\r\n                for(var j = 0; j <= mp; j++) {\r\n                    //reduce the dividend\r\n                    dividend[j + d] = dividend[j + d].subtract((divisor[j].multiply(q)));\r\n                }\r\n            }\r\n\r\n            //clean up\r\n            var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(), //pass in x for safety\r\n                    p2 = Polynomial.fromArray(quotient, variable || 'x');\r\n            return [p2, p1];\r\n        },\r\n        multiply: function (poly) {\r\n            var l1 = this.coeffs.length, l2 = poly.coeffs.length,\r\n                    c = []; //array to be returned\r\n            for(var i = 0; i < l1; i++) {\r\n                var x1 = this.coeffs[i];\r\n                for(var j = 0; j < l2; j++) {\r\n                    var k = i + j, //add the powers together\r\n                            x2 = poly.coeffs[j],\r\n                            e = c[k] || new Frac(0); //get the existing term from the new array\r\n                    c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\r\n                }\r\n            }\r\n            this.coeffs = c;\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks if a polynomial is zero\r\n         * @returns {Boolean}\r\n         */\r\n        isZero: function () {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /** \r\n         * Substitutes in a number n into the polynomial p(n)\r\n         * @param {Number} n\r\n         * @returns {Frac}\r\n         */\r\n        sub: function (n) {\r\n            var sum = new Frac(0), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var t = this.coeffs[i];\r\n                if(!t.equals(0))\r\n                    sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\r\n            }\r\n            return sum;\r\n        },\r\n        /**\r\n         * Returns a clone of the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        clone: function () {\r\n            var p = new Polynomial();\r\n            p.coeffs = this.coeffs;\r\n            p.variable = this.variable;\r\n            return p;\r\n        },\r\n        /**\r\n         * Gets the degree of the polynomial\r\n         * @returns {Number}\r\n         */\r\n        deg: function () {\r\n            this.trim();\r\n            return this.coeffs.length - 1;\r\n        },\r\n        /**\r\n         * Returns a lead coefficient\r\n         * @returns {Frac}\r\n         */\r\n        lc: function () {\r\n            return this.coeffs[this.deg()].clone();\r\n        },\r\n        /**\r\n         * Converts polynomial into a monic polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        monic: function () {\r\n            var lc = this.lc(), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++)\r\n                this.coeffs[i] = this.coeffs[i].divide(lc);\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the GCD of two polynomials\r\n         * @param {Polynomial} poly\r\n         * @returns {Polynomial}\r\n         */\r\n        gcd: function (poly) {\r\n            //get the maximum power of each\r\n            var mp1 = this.coeffs.length - 1,\r\n                    mp2 = poly.coeffs.length - 1,\r\n                    T;\r\n            //swap so we always have the greater power first\r\n            if(mp1 < mp2) {\r\n                return poly.gcd(this);\r\n            }\r\n            var a = this;\r\n\r\n            while(!poly.isZero()) {\r\n                var t = poly.clone();\r\n                a = a.clone();\r\n                T = a.divide(t);\r\n                poly = T[1];\r\n                a = t;\r\n            }\r\n\r\n            var gcd = core.Math2.QGCD.apply(null, a.coeffs);\r\n            if(!gcd.equals(1)) {\r\n                var l = a.coeffs.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    a.coeffs[i] = a.coeffs[i].divide(gcd);\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        /**\r\n         * Differentiates the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        diff: function () {\r\n            var new_array = [], l = this.coeffs.length;\r\n            for(var i = 1; i < l; i++)\r\n                new_array.push(this.coeffs[i].multiply(new Frac(i)));\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Integrates the polynomial\r\n         * @returns {Polynomial} \r\n         */\r\n        integrate: function () {\r\n            var new_array = [0], l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = new Frac(i + 1);\r\n                new_array[c] = this.coeffs[i].divide(c);\r\n            }\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the Greatest common factor of the polynomial\r\n         * @param {bool} toPolynomial - true if a polynomial is wanted\r\n         * @returns {Frac|Polynomial}\r\n         */\r\n        gcf: function (toPolynomial) {\r\n            //get the first nozero coefficient and returns its power\r\n            var fnz = function (a) {\r\n                for(var i = 0; i < a.length; i++)\r\n                    if(!a[i].equals(0))\r\n                        return i;\r\n            },\r\n                    ca = [];\r\n            for(var i = 0; i < this.coeffs.length; i++) {\r\n                var c = this.coeffs[i];\r\n                if(!c.equals(0) && ca.indexOf(c) === -1)\r\n                    ca.push(c);\r\n            }\r\n            var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\r\n\r\n            if(toPolynomial) {\r\n                var parr = [];\r\n                parr[p[1] - 1] = p[0];\r\n                p = Polynomial.fromArray(parr, this.variable).fill();\r\n            }\r\n\r\n            return p;\r\n        },\r\n        /**\r\n         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n         * @param {bool} incl_img - Include imaginary numbers \r\n         */\r\n        quad: function (incl_img) {\r\n            var roots = [];\r\n            if(this.coeffs.length > 3)\r\n                throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\r\n            if(this.coeffs.length === 0)\r\n                throw new Error('Polynomial array has no terms');\r\n            var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];\r\n            var dsc = b * b - 4 * a * c;\r\n            if(dsc < 0 && !incl_img)\r\n                return roots;\r\n            else {\r\n                roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\r\n                roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\r\n            }\r\n            return roots;\r\n        },\r\n        /**\r\n         * Makes polynomial square free\r\n         * @returns {Array}\r\n         */\r\n        squareFree: function () {\r\n\r\n            var a = this.clone(),\r\n                    i = 1,\r\n                    b = a.clone().diff(),\r\n                    c = a.clone().gcd(b),\r\n                    w = a.divide(c)[0];\r\n            var output = Polynomial.fromArray([new Frac(1)], a.variable);\r\n            while(!c.equalsNumber(1)) {\r\n                var y = w.gcd(c);\r\n                var z = w.divide(y)[0];\r\n                //one of the factors may have shown up since it's square but smaller than the \r\n                //one where finding\r\n                if(!z.equalsNumber(1) && i > 1) {\r\n                    var t = z.clone();\r\n                    for(var j = 1; j < i; j++)\r\n                        t.multiply(z.clone());\r\n                    z = t;\r\n                }\r\n                output = output.multiply(z);\r\n                i++;\r\n                w = y;\r\n                c = c.divide(y)[0];\r\n            }\r\n\r\n            return [output, w, i];\r\n        },\r\n        /**\r\n         * Converts polynomial to Symbol\r\n         * @returns {Symbol}\r\n         */\r\n        toSymbol: function () {\r\n            var l = this.coeffs.length,\r\n                    variable = this.variable;\r\n            if(l === 0)\r\n                return new core.Symbol(0);\r\n            var end = l - 1, str = '';\r\n\r\n            for(var i = 0; i < l; i++) {\r\n                //place the plus sign for all but the last one\r\n                var plus = i === end ? '' : '+',\r\n                        e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    str += (e + '*' + variable + '^' + i + plus);\r\n            }\r\n            return _.parse(str);\r\n        },\r\n        /**\r\n         * Checks if polynomial is equal to a number\r\n         * @param {Number} x\r\n         * @returns {Boolean}\r\n         */\r\n        equalsNumber: function (x) {\r\n            this.trim();\r\n            return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\r\n        },\r\n        toString: function () {\r\n            return this.toSymbol().toString();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * TODO\r\n     * ===================================================================================\r\n     * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n     * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n     * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n     * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n     * ===================================================================================\r\n     * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n     * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n     * so the symbol multiplier carries the coefficients for all contained symbols.\r\n     * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n     * @param {Array} c The coefficient array\r\n     * @param {boolean} with_order \r\n     * @return {Array}\r\n     */\r\n    Symbol.prototype.coeffs = function (c, with_order) {\r\n        if(with_order && !this.isPoly(true))\r\n            _.error('Polynomial expected when requesting coefficients with order');\r\n        c = c || [];\r\n        var s = this.clone().distributeMultiplier();\r\n        if(s.isComposite()) {\r\n            for(var x in s.symbols) {\r\n                var sub = s.symbols[x];\r\n                if(sub.isComposite()) {\r\n                    sub.clone().distributeMultiplier().coeffs(c, with_order);\r\n                }\r\n                else {\r\n                    if(with_order)\r\n                        c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;\r\n                    else {\r\n                        c.push(sub.multiplier);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if(with_order)\r\n                c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;\r\n            else {\r\n                if(s.group === CB && s.isImaginary()) {\r\n                    var m = new Symbol(s.multiplier);\r\n                    s.each(function (x) {\r\n                        //add the imaginary part\r\n                        if(x.isConstant(true) || x.imaginary)\r\n                            m = _.multiply(m, x);\r\n                    });\r\n                    c.push(m);\r\n                }\r\n                else\r\n                    c.push(s.multiplier);\r\n            }\r\n        }\r\n        //fill the holes\r\n        if(with_order) {\r\n            for(var i = 0; i < c.length; i++)\r\n                if(c[i] === undefined)\r\n                    c[i] = new Symbol(0);\r\n        }\r\n        return c;\r\n    };\r\n    Symbol.prototype.tBase = function (map) {\r\n        if(typeof map === 'undefined')\r\n            throw new Error('Symbol.tBase requires a map object!');\r\n        var terms = [];\r\n        var symbols = this.collectSymbols(null, null, null, true),\r\n                l = symbols.length;\r\n        for(var i = 0; i < l; i++) {\r\n            var symbol = symbols[i],\r\n                    g = symbol.group,\r\n                    nterm = new MVTerm(symbol.multiplier, [], map);\r\n            if(g === CB) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n                    nterm.terms[map[x]] = sym.power;\r\n                }\r\n            }\r\n            else {\r\n                nterm.terms[map[symbol.value]] = symbol.power;\r\n            }\r\n\r\n            terms.push(nterm.fill());\r\n            nterm.updateCount();\r\n        }\r\n        return terms;\r\n    };\r\n    Symbol.prototype.altVar = function (x) {\r\n        var m = this.multiplier.toString(), p = this.power.toString();\r\n        return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\r\n    };\r\n    /**\r\n     * Checks to see if the symbols contain the same variables\r\n     * @param {Symbol} symbol\r\n     * @returns {Boolean}\r\n     */\r\n    Symbol.prototype.sameVars = function (symbol) {\r\n        if(!(this.symbols || this.group === symbol.group))\r\n            return false;\r\n        for(var x in this.symbols) {\r\n            var a = this.symbols[x], b = symbol.symbols[x];\r\n            if(!b)\r\n                return false;\r\n            if(a.value !== b.value)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Groups the terms in a symbol with respect to a variable\r\n     * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n     * @returns {Factors}\r\n     */\r\n    Symbol.prototype.groupTerms = function (x) {\r\n        x = String(x);\r\n        var f, p, egrouped;\r\n        var grouped = [];\r\n        this.each(function (e) {\r\n            if(e.group === PL) {\r\n                egrouped = e.groupTerms(x);\r\n                for(var i = 0; i < egrouped.length; i++) {\r\n                    var el = egrouped[i];\r\n                    if(el)\r\n                        grouped[i] = el;\r\n                }\r\n            }\r\n            else {\r\n                f = core.Utils.decompose_fn(e, x, true);\r\n                p = f.x.value === x ? Number(f.x.power) : 0;\r\n                //check if there's an existing value\r\n                grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\r\n            }\r\n        });\r\n        return grouped;\r\n    };\r\n    /**\r\n     * Use this to collect Factors\r\n     * @returns {Symbol[]}\r\n     */\r\n    Symbol.prototype.collectFactors = function () {\r\n        var factors = [];\r\n        if(this.group === CB)\r\n            this.each(function (x) {\r\n                factors.push(x.clone());\r\n            });\r\n        else\r\n            factors.push(this.clone());\r\n        return factors;\r\n    };\r\n    /**\r\n     * A container class for factors\r\n     * @returns {Factors}\r\n     */\r\n    function Factors() {\r\n        this.factors = {};\r\n        this.length = 0;\r\n    }\r\n    ;\r\n    Factors.prototype.getNumberSymbolics = function () {\r\n        var n = 0;\r\n        this.each(function (x) {\r\n            if(!x.isConstant(true))\r\n                n++;\r\n        });\r\n        return n;\r\n    };\r\n    /**\r\n     * Adds the factors to the factor object\r\n     * @param {Symbo} s\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.add = function (s) {\r\n        if(s.equals(0))\r\n            return this; //nothing to add\r\n\r\n        //we don't want to carry -1 as a factor. If a factor already exists,\r\n        //then add the minus one to that factor and return.\r\n        if(s.equals(-1) && this.length > 0) {\r\n            var fo = core.Utils.firstObject(this.factors, null, true);\r\n            this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\r\n            delete this.factors[fo.key];\r\n            this.length--;\r\n            return this;\r\n        }\r\n\r\n        if(s.group === CB) {\r\n            var factors = this;\r\n            if(!s.multiplier.equals(1))\r\n                factors.add(new Symbol(s.multiplier));\r\n            s.each(function (x) {\r\n                factors.add(x);\r\n            });\r\n        }\r\n        else {\r\n            if(this.preAdd) //if a preAdd function was defined call it to do prep\r\n                s = this.preAdd(s);\r\n            if(this.pFactor) //if the symbol isn't linear add back the power\r\n                s = _.pow(s, new Symbol(this.pFactor));\r\n\r\n            var is_constant = s.isConstant();\r\n            if(is_constant && s.equals(1))\r\n                return this; //don't add 1\r\n            var v = is_constant ? s.value : s.text();\r\n            if(v in this.factors) {\r\n                this.factors[v] = _.multiply(this.factors[v], s);\r\n                //did the addition cancel out the existing factor? If so remove it and decrement the length\r\n                if(this.factors[v].equals(1)) {\r\n                    delete this.factors[v];\r\n                    this.length--;\r\n                }\r\n            }\r\n            else {\r\n                this.factors[v] = s;\r\n                this.length++;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the factor object to a Symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Factors.prototype.toSymbol = function () {\r\n        var factored = new Symbol(1);\r\n        var factors = Object.values(this.factors).sort(function (a, b) {\r\n            return a.group > b.group;\r\n        });\r\n\r\n        for(var i = 0, l = factors.length; i < l; i++) {\r\n            var f = factors[i];\r\n\r\n            //don't wrap group S or FN\r\n            var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */ ?\r\n                    _.symfunction(core.PARENTHESIS, [f]) : f;\r\n\r\n            factored = _.multiply(factored, factor);\r\n        }\r\n        if(factored.fname === '')\r\n            factored = Symbol.unwrapPARENS(factored);\r\n        return factored;\r\n    };\r\n    /**\r\n     * Merges 2 factor objects into one\r\n     * @param {Factor} o\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.merge = function (o) {\r\n        for(var x in o) {\r\n            if(x in this.factors)\r\n                this.factors[x] = _.multiply(this.factors[x], o[x]);\r\n            else\r\n                this.factors[x] = o[x];\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * The iterator for the factor object\r\n     * @param {Function} f - callback\r\n     * @returns {Factor}\r\n     */\r\n    Factors.prototype.each = function (f) {\r\n        for(var x in this.factors) {\r\n            var factor = this.factors[x];\r\n            if(factor.fname === core.PARENTHESIS && factor.isLinear())\r\n                factor = factor.args[0];\r\n            f.call(this, factor, x);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Return the number of factors contained in the factor object\r\n     * @returns {int}\r\n     */\r\n    Factors.prototype.count = function () {\r\n        return keys(this.factors).length;\r\n    };\r\n    /**\r\n     * Cleans up factors from -1\r\n     * @returns {undefined}\r\n     */\r\n    Factors.prototype.clean = function () {\r\n        try {\r\n            var h = core.Settings.CONST_HASH;\r\n            if(this.factors[h].lessThan(0)) {\r\n                if(this.factors[h].equals(-1))\r\n                    delete this.factors[h];\r\n                else\r\n                    this.factors[h].negate();\r\n                this.each(function (x) {\r\n                    x.negate();\r\n                });\r\n            }\r\n        }\r\n        catch(e) {\r\n        }\r\n        ;\r\n    };\r\n    Factors.prototype.toString = function () {\r\n        return this.toSymbol().toString();\r\n    };\r\n\r\n    //a wrapper for performing multivariate division\r\n    function MVTerm(coeff, terms, map) {\r\n        this.terms = terms || [];\r\n        this.coeff = coeff;\r\n        this.map = map; //careful! all maps are the same object\r\n        this.sum = new core.Frac(0);\r\n        this.image = undefined;\r\n    }\r\n    ;\r\n    MVTerm.prototype.updateCount = function () {\r\n        this.count = this.count || 0;\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            if(!this.terms[i].equals(0))\r\n                this.count++;\r\n        }\r\n        return this;\r\n    };\r\n    MVTerm.prototype.getVars = function () {\r\n        var vars = [];\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var term = this.terms[i],\r\n                    rev_map = this.getRevMap();\r\n            if(!term.equals(0))\r\n                vars.push(this.rev_map[i]);\r\n        }\r\n        return vars.join(' ');\r\n    };\r\n    MVTerm.prototype.len = function () {\r\n        if(typeof this.count === 'undefined') {\r\n            this.updateCount();\r\n        }\r\n        return this.count;\r\n    };\r\n    MVTerm.prototype.toSymbol = function (rev_map) {\r\n        rev_map = rev_map || this.getRevMap();\r\n        var symbol = new Symbol(this.coeff);\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var v = rev_map[i],\r\n                    t = this.terms[i];\r\n            if(t.equals(0) || v === CONST_HASH)\r\n                continue;\r\n            var mapped = new Symbol(v);\r\n            mapped.power = t;\r\n            symbol = _.multiply(symbol, mapped);\r\n        }\r\n        return symbol;\r\n    };\r\n    MVTerm.prototype.getRevMap = function () {\r\n        if(this.rev_map)\r\n            return this.rev_map;\r\n        var o = {};\r\n        for(var x in this.map)\r\n            o[this.map[x]] = x;\r\n        this.rev_map = o;\r\n        return o;\r\n    };\r\n    MVTerm.prototype.generateImage = function () {\r\n        this.image = this.terms.join(' ');\r\n        return this;\r\n    },\r\n            MVTerm.prototype.getImg = function () {\r\n                if(!this.image)\r\n                    this.generateImage();\r\n                return this.image;\r\n            },\r\n            MVTerm.prototype.fill = function () {\r\n                var l = this.map.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    if(typeof this.terms[i] === 'undefined')\r\n                        this.terms[i] = new core.Frac(0);\r\n                    else {\r\n                        this.sum = this.sum.add(this.terms[i]);\r\n                    }\r\n                }\r\n                return this;\r\n            };\r\n    MVTerm.prototype.divide = function (mvterm) {\r\n        var c = this.coeff.divide(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.multiply = function (mvterm) {\r\n        var c = this.coeff.multiply(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.isZero = function () {\r\n        return this.coeff.equals(0);\r\n    };\r\n    MVTerm.prototype.toString = function () {\r\n        return '{ coeff: ' + this.coeff.toString() + ', terms: [' +\r\n                this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\r\n    };\r\n\r\n    core.Utils.toMapObj = function (arr) {\r\n        var c = 0, o = {};\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var v = arr[i];\r\n            if(typeof o[v] === 'undefined') {\r\n                o[v] = c;\r\n                c++;\r\n            }\r\n        }\r\n        o.length = c;\r\n        return o;\r\n    };\r\n    core.Utils.filledArray = function (v, n, clss) {\r\n        var a = [];\r\n        while(n--) {\r\n            a[n] = clss ? new clss(v) : v;\r\n        }\r\n        return a;\r\n    };\r\n    core.Utils.arrSum = function (arr) {\r\n        var sum = 0, l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            sum += arr[i];\r\n        return sum;\r\n    };\r\n    /**\r\n     * Determines if 2 arrays have intersecting elements.\r\n     * @param {Array} a\r\n     * @param {Array} b\r\n     * @returns {Boolean} True if a and b have intersecting elements.\r\n     */\r\n    core.Utils.haveIntersection = function (a, b) {\r\n        var t;\r\n        if(b.length > a.length)\r\n            t = b, b = a, a = t; // indexOf to loop over shorter\r\n        return a.some(function (e) {\r\n            return b.indexOf(e) > -1;\r\n        });\r\n    };\r\n    /**\r\n     * Substitutes out functions as variables so they can be used in regular algorithms\r\n     * @param {Symbol} symbol\r\n     * @param {Object} map\r\n     * @returns {String} The expression string\r\n     */\r\n    core.Utils.subFunctions = function (symbol, map) {\r\n        map = map || {};\r\n        var subbed = [];\r\n        symbol.each(function (x) {\r\n            if(x.group === FN || x.previousGroup === FN) {\r\n                //we need a new variable name so why not use one of the existing\r\n                var val = core.Utils.text(x, 'hash'), tvar = map[val];\r\n                if(!tvar) {\r\n                    //generate a unique enough name\r\n                    var t = x.fname + keys(map).length;\r\n                    map[val] = t;\r\n                    subbed.push(x.altVar(t));\r\n                }\r\n                else\r\n                    subbed.push(x.altVar(tvar));\r\n            }\r\n            else if(x.group === CB || x.group === PL || x.group === CP) {\r\n                subbed.push(core.Utils.subFunctions(x, map));\r\n            }\r\n            else\r\n                subbed.push(x.text());\r\n        });\r\n        if(symbol.group === CP || symbol.group === PL)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\r\n        ;\r\n        if(symbol.group === CB)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\r\n        return symbol.text();\r\n    };\r\n    core.Utils.getFunctionsSubs = function (map) {\r\n        var subs = {};\r\n        //prepare substitutions\r\n        for(var x in map)\r\n            subs[map[x]] = _.parse(x);\r\n        return subs;\r\n    };\r\n\r\n    var __ = core.Algebra = {\r\n        version: '1.4.6',\r\n        proots: function (symbol, decp) {\r\n            //the roots will be rounded up to 7 decimal places.\r\n            //if this causes trouble you can explicitly pass in a different number of places\r\n            //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\r\n            decp = decp || 7;\r\n            var zeros = 0;\r\n            var known_roots = [];\r\n            var get_roots = function (rarr, powers, max) {\r\n                var roots = calcroots(rarr, powers, max).concat(known_roots);\r\n                for(var i = 0; i < zeros; i++)\r\n                    roots.unshift(0);\r\n                return roots;\r\n            };\r\n\r\n            if(symbol instanceof Symbol && symbol.isPoly()) {\r\n                symbol.distributeMultiplier();\r\n                //make it so the symbol has a constants as the lowest term\r\n                if(symbol.group === PL) {\r\n                    var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\r\n                    var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\r\n                    symbol = _.expand(_.divide(symbol, lowest_symbol));\r\n                    known_roots.push(0); //add zero since this is a known root\r\n                }\r\n                if(symbol.group === core.groups.S) {\r\n                    return [0];\r\n                }\r\n                else if(symbol.group === core.groups.PL) {\r\n                    var powers = keys(symbol.symbols),\r\n                            minpower = core.Utils.arrayMin(powers),\r\n                            symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\r\n                }\r\n\r\n                var variable = keys(symbol.symbols).sort().pop(),\r\n                        sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\r\n                        g = sym.group,\r\n                        powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\r\n                        rarr = [],\r\n                        max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\r\n\r\n                // Prepare the data\r\n                for(var i = 1; i <= max; i++) {\r\n                    var c = 0; //if there is no power then the hole must be filled with a zero\r\n                    if(powers.indexOf(i + '') !== -1) {\r\n                        if(g === S) {\r\n                            c = sym.multiplier;\r\n                        }\r\n                        else {\r\n                            c = sym.symbols[i].multiplier;\r\n                        }\r\n                    }\r\n                    // Insert the coeffient but from the front\r\n                    rarr.unshift(c);\r\n                }\r\n\r\n                rarr.push(symbol.symbols[CONST_HASH].multiplier);\r\n\r\n                if(sym.group === S)\r\n                    rarr[0] = sym.multiplier;//the symbol maybe of group CP with one variable\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else if(core.Utils.isArray(symbol)) {\r\n                var parr = symbol;\r\n                var rarr = [],\r\n                        powers = [],\r\n                        last_power = 0;\r\n                for(var i = 0; i < parr.length; i++) {\r\n\r\n                    var coeff = parr[i][0],\r\n                            pow = parr[i][1],\r\n                            d = pow - last_power - 1;\r\n                    //insert the zeros\r\n                    for(var j = 0; j < d; j++)\r\n                        rarr.unshift(0);\r\n\r\n                    rarr.unshift(coeff);\r\n                    if(pow !== 0)\r\n                        powers.push(pow);\r\n                    last_power = pow;\r\n                }\r\n                var max = Math.max.apply(undefined, powers);\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else {\r\n                throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\r\n            }\r\n\r\n            function calcroots(rarr, powers, max) {\r\n                var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\r\n\r\n                // Make a clone of the coefficients before appending the max power\r\n                var p = rarr.slice(0);\r\n\r\n                // Divide the string up into its individual entries, which--presumably--are separated by whitespace\r\n                rarr.unshift(max);\r\n\r\n                if(max > MAXDEGREE) {\r\n                    throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\r\n                }\r\n\r\n                var zeroi = [], // Vector of imaginary components of roots\r\n                        degreePar = {};    // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\r\n                degreePar.Degree = max;\r\n\r\n                for(i = 0; i < max; i++) {\r\n                    zeroi.push(0);\r\n                }\r\n                var zeror = zeroi.slice(0); // Vector of real components of roots\r\n\r\n                // Find the roots\r\n                //--> Begin Jenkins-Traub\r\n\r\n                /*\r\n                 * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n                 */\r\n                function QuadSD_ak1(NN, u, v, p, q, iPar) {\r\n                    // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\r\n                    // iPar is a dummy variable for passing in the two parameters--a and b--by reference\r\n                    q[0] = iPar.b = p[0];\r\n                    q[1] = iPar.a = -(u * iPar.b) + p[1];\r\n\r\n                    for(var i = 2; i < NN; i++) {\r\n                        q[i] = -(u * iPar.a + v * iPar.b) + p[i];\r\n                        iPar.b = iPar.a;\r\n                        iPar.a = q[i];\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\r\n                    // This routine calculates scalar quantities used to compute the next K polynomial and\r\n                    // new estimates of the quadratic coefficients.\r\n                    // calcSC -\tinteger variable set here indicating how the calculations are normalized\r\n                    // to avoid overflow.\r\n                    // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\r\n\r\n                    // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\r\n                    var sdPar = new Object(),\r\n                            // TYPE = 3 indicates the quadratic is almost a factor of K\r\n                            dumFlag = 3;\r\n\r\n                    // Synthetic division of K by the quadratic 1, u, v\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(N, u, v, K, qk, sdPar);\r\n                    iPar.c = sdPar.a;\r\n                    iPar.d = sdPar.b;\r\n\r\n                    if(Math.abs(iPar.c) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 1]))) {\r\n                        if(Math.abs(iPar.d) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 2])))\r\n                            return dumFlag;\r\n                    }\r\n\r\n                    iPar.h = v * b;\r\n                    if(Math.abs(iPar.d) >= Math.abs(iPar.c)) {\r\n                        // TYPE = 2 indicates that all formulas are divided by d\r\n                        dumFlag = 2;\r\n                        iPar.e = a / (iPar.d);\r\n                        iPar.f = (iPar.c) / (iPar.d);\r\n                        iPar.g = u * b;\r\n                        iPar.a3 = (iPar.e) * ((iPar.g) + a) + (iPar.h) * (b / (iPar.d));\r\n                        iPar.a1 = -a + (iPar.f) * b;\r\n                        iPar.a7 = (iPar.h) + ((iPar.f) + u) * a;\r\n                    }\r\n                    else {\r\n                        // TYPE = 1 indicates that all formulas are divided by c;\r\n                        dumFlag = 1;\r\n                        iPar.e = a / (iPar.c);\r\n                        iPar.f = (iPar.d) / (iPar.c);\r\n                        iPar.g = (iPar.e) * u;\r\n                        iPar.a3 = (iPar.e) * a + ((iPar.g) + (iPar.h) / (iPar.c)) * b;\r\n                        iPar.a1 = -(a * ((iPar.d) / (iPar.c))) + b;\r\n                        iPar.a7 = (iPar.g) * (iPar.d) + (iPar.h) * (iPar.f) + a;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\r\n                    // Computes the next K polynomials using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\r\n                    var temp;\r\n                    if(tFlag == 3) {\t// Use unscaled form of the recurrence\r\n                        K[1] = K[0] = 0.0;\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = qk[i - 2];\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    temp = ((tFlag == 1) ? b : a);\r\n                    if(Math.abs(iPar.a1) > (10.0 * DBL_EPSILON * Math.abs(temp))) {\r\n                        // Use scaled form of the recurrence\r\n                        iPar.a7 /= iPar.a1;\r\n                        iPar.a3 /= iPar.a1;\r\n                        K[0] = qp[0];\r\n                        K[1] = -(qp[0] * iPar.a7) + qp[1];\r\n                        for(var i = 2; i < N; i++)\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\r\n                    }\r\n                    else {\r\n                        // If a1 is nearly zero, then use a special form of the recurrence\r\n                        K[0] = 0.0;\r\n                        K[1] = -(qp[0] * iPar.a7);\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\r\n                    // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\r\n                    // iPar.a = uu, iPar.b = vv\r\n\r\n                    var a4, a5, b1, b2, c1, c2, c3, c4, temp;\r\n                    iPar.b = iPar.a = 0.0;// The quadratic is zeroed\r\n\r\n                    if(tFlag != 3) {\r\n                        if(tFlag != 2) {\r\n                            a4 = a + u * b + h * f;\r\n                            a5 = c + (u + v * f) * d;\r\n                        }\r\n                        else {\r\n                            a4 = (a + g) * f + h;\r\n                            a5 = (f + u) * c + v * d;\r\n                        }\r\n\r\n                        // Evaluate new quadratic coefficients\r\n                        b1 = -(K[N - 1] / p[N]);\r\n                        b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\r\n                        c1 = v * b2 * a1;\r\n                        c2 = b1 * a7;\r\n                        c3 = b1 * b1 * a3;\r\n                        c4 = -(c2 + c3) + c1;\r\n                        temp = -c4 + a5 + b1 * a4;\r\n                        if(temp != 0.0) {\r\n                            iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\r\n                            iPar.b = v * (1.0 + c4 / temp);\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function Quad_ak1(a, b1, c, iPar) {\r\n                    // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\r\n                    // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\r\n                    // zeros are real and both zeros are complex. The smaller real zero is found directly from\r\n                    // the product of the zeros c/a.\r\n\r\n                    // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\r\n\r\n                    var b, d, e;\r\n                    iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\r\n\r\n                    if(a == 0) {\r\n                        iPar.sr = ((b1 != 0) ? -(c / b1) : iPar.sr);\r\n                        return;\r\n                    }\r\n                    if(c == 0) {\r\n                        iPar.lr = -(b1 / a);\r\n                        return;\r\n                    }\r\n\r\n                    // Compute discriminant avoiding overflow\r\n                    b = b1 / 2.0;\r\n                    if(Math.abs(b) < Math.abs(c)) {\r\n                        e = ((c >= 0) ? a : -a);\r\n                        e = -e + b * (b / Math.abs(c));\r\n                        d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\r\n                    }\r\n                    else {\r\n                        e = -((a / b) * (c / b)) + 1.0;\r\n                        d = Math.sqrt(Math.abs(e)) * (Math.abs(b));\r\n                    }\r\n\r\n                    if(e >= 0) {\r\n                        // Real zeros\r\n                        d = ((b >= 0) ? -d : d);\r\n                        iPar.lr = (-b + d) / a;\r\n                        iPar.sr = ((iPar.lr != 0) ? (c / (iPar.lr)) / a : iPar.sr);\r\n                    }\r\n                    else {\r\n                        // Complex conjugate zeros\r\n                        iPar.lr = iPar.sr = -(b / a);\r\n                        iPar.si = Math.abs(d / a);\r\n                        iPar.li = -(iPar.si);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\r\n                    // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\r\n                    // zeros are equimodular or nearly so.\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\r\n                    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\r\n\r\n                    // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\r\n                    var qPar = new Object(),\r\n                            ee, mp, omp, relstp, t, u, ui, v, vi, zm,\r\n                            i, j = 0, tFlag, triedFlag = 0;   // Integer variables\r\n\r\n                    iPar.NZ = 0;// Number of zeros found\r\n                    u = uu; // uu and vv are coefficients of the starting quadratic\r\n                    v = vv;\r\n\r\n                    do {\r\n                        qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                        Quad_ak1(1.0, u, v, qPar);\r\n                        iPar.szr = qPar.sr;\r\n                        iPar.szi = qPar.si;\r\n                        iPar.lzr = qPar.lr;\r\n                        iPar.lzi = qPar.li;\r\n\r\n                        // Return if roots of the quadratic are real and not close to multiple or nearly\r\n                        // equal and of opposite sign.\r\n                        if(Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))\r\n                            break;\r\n\r\n                        // Evaluate polynomial by quadratic synthetic division\r\n\r\n                        QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n\r\n                        mp = Math.abs(-((iPar.szr) * (sdPar.b)) + (sdPar.a)) + Math.abs((iPar.szi) * (sdPar.b));\r\n\r\n                        // Compute a rigorous bound on the rounding error in evaluating p\r\n\r\n                        zm = Math.sqrt(Math.abs(v));\r\n                        ee = 2.0 * Math.abs(qp[0]);\r\n                        t = -((iPar.szr) * (sdPar.b));\r\n\r\n                        for(i = 1; i < N; i++) {\r\n                            ee = ee * zm + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        ee = ee * zm + Math.abs(t + sdPar.a);\r\n                        ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs((sdPar.a) + t) + zm * Math.abs((sdPar.b)))) * DBL_EPSILON;\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\r\n                        if(mp <= 20.0 * ee) {\r\n                            iPar.NZ = 2;\r\n                            break;\r\n                        }\r\n\r\n                        j++;\r\n                        // Stop iteration after 20 steps\r\n                        if(j > 20)\r\n                            break;\r\n                        if(j >= 2) {\r\n                            if((relstp <= 0.01) && (mp >= omp) && (!triedFlag)) {\r\n                                // A cluster appears to be stalling the convergence. Five fixed shift\r\n                                // steps are taken with a u, v close to the cluster.\r\n                                relstp = ((relstp < DBL_EPSILON) ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp));\r\n                                u -= u * relstp;\r\n                                v += v * relstp;\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                for(i = 0; i < 5; i++) {\r\n                                    tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                                    nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                                }\r\n\r\n                                triedFlag = 1;\r\n                                j = 0;\r\n\r\n                            }\r\n                        }\r\n                        omp = mp;\r\n\r\n                        // Calculate next K polynomial and new u and v\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vi = sdPar.b;\r\n\r\n                        // If vi is zero, the iteration is not converging\r\n                        if(vi != 0) {\r\n                            relstp = Math.abs((-v + vi) / vi);\r\n                            u = ui;\r\n                            v = vi;\r\n                        }\r\n                    }\r\n                    while(vi != 0);\r\n                    return;\r\n                }\r\n\r\n                function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\r\n                    // Variable-shift H-polynomial iteration for a real zero\r\n                    // sss\t- starting iterate = sdPar.a\r\n                    // NZ\t\t- number of zeros found = iPar.NZ\r\n                    // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\r\n\r\n                    var ee, kv, mp, ms, omp, pv, s, t,\r\n                            dumFlag, i, j, nm1 = N - 1;   // Integer variables\r\n\r\n                    iPar.NZ = j = dumFlag = 0;\r\n                    s = sdPar.a;\r\n\r\n                    for(; ; ) {\r\n                        pv = p[0];\r\n\r\n                        // Evaluate p at s\r\n                        qp[0] = pv;\r\n                        for(i = 1; i < NN; i++) {\r\n                            qp[i] = pv = pv * s + p[i];\r\n                        }\r\n                        mp = Math.abs(pv);\r\n\r\n                        // Compute a rigorous bound on the error in evaluating p\r\n                        ms = Math.abs(s);\r\n                        ee = 0.5 * Math.abs(qp[0]);\r\n                        for(i = 1; i < NN; i++) {\r\n                            ee = ee * ms + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than\r\n                        // 20 times this bound\r\n                        if(mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\r\n                            iPar.NZ = 1;\r\n                            iPar.szr = s;\r\n                            iPar.szi = 0.0;\r\n                            break;\r\n                        }\r\n                        j++;\r\n                        // Stop iteration after 10 steps\r\n                        if(j > 10)\r\n                            break;\r\n\r\n                        if(j >= 2) {\r\n                            if((Math.abs(t) <= 0.001 * Math.abs(-t + s)) && (mp > omp)) {\r\n                                // A cluster of zeros near the real axis has been encountered.\r\n                                // Return with iFlag set to initiate a quadratic iteration.\r\n                                dumFlag = 1;\r\n                                iPar.a = s;\r\n                                break;\r\n                            } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\r\n                        } //End if (j >= 2)\r\n\r\n                        // Return if the polynomial value has increased significantly\r\n                        omp = mp;\r\n\r\n                        // Compute t, the next polynomial and the new iterate\r\n                        qk[0] = kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            qk[i] = kv = kv * s + K[i];\r\n                        }\r\n\r\n                        if(Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\r\n                            // Use the scaled form of the recurrence if the value of K at s is non-zero\r\n                            t = -(pv / kv);\r\n                            K[0] = qp[0];\r\n                            for(i = 1; i < N; i++) {\r\n                                K[i] = t * qk[i - 1] + qp[i];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Use unscaled form\r\n                            K[0] = 0.0;\r\n                            for(i = 1; i < N; i++)\r\n                                K[i] = qk[i - 1];\r\n                        }\r\n\r\n                        kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            kv = kv * s + K[i];\r\n                        }\r\n                        t = ((Math.abs(kv) > (Math.abs(K[nm1]) * 10.0 * DBL_EPSILON)) ? -(pv / kv) : 0.0);\r\n                        s += t;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\r\n\r\n                    // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\r\n                    // quadratic case. Initiates one of the variable shift iterations and returns with the\r\n                    // number of zeros found.\r\n                    // L2\tlimit of fixed shift steps\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // NZ\tnumber of zeros found\r\n                    var sdPar = new Object(), // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\r\n                            calcPar = new Object(),\r\n                            // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\r\n\r\n                            qk = new Array(MDP1),\r\n                            svk = new Array(MDP1),\r\n                            a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv,\r\n                            fflag, i, iFlag = 1, j, spass, stry, tFlag, vpass, vtry;     // Integer variables\r\n\r\n                    iPar.NZ = 0;\r\n                    betav = betas = 0.25;\r\n                    oss = sr;\r\n                    ovv = v;\r\n\r\n                    //Evaluate polynomial by synthetic division\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                    a = sdPar.a;\r\n                    b = sdPar.b;\r\n                    calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\r\n                    tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                    for(j = 0; j < L2; j++) {\r\n                        fflag = 1;\r\n\r\n                        // Calculate next K polynomial and estimate v\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                        // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\r\n                        // sdPar.a = ui, sdPar.b = vi\r\n                        newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vv = vi = sdPar.b;\r\n\r\n                        // Estimate s\r\n                        ss = ((K[N - 1] != 0.0) ? -(p[N] / K[N - 1]) : 0.0);\r\n                        ts = tv = 1.0;\r\n\r\n                        if((j != 0) && (tFlag != 3)) {\r\n                            // Compute relative measures of convergence of s and v sequences\r\n                            tv = ((vv != 0.0) ? Math.abs((vv - ovv) / vv) : tv);\r\n                            ts = ((ss != 0.0) ? Math.abs((ss - oss) / ss) : ts);\r\n\r\n                            // If decreasing, multiply the two most recent convergence measures\r\n                            tvv = ((tv < otv) ? tv * otv : 1.0);\r\n                            tss = ((ts < ots) ? ts * ots : 1.0);\r\n\r\n                            // Compare with convergence criteria\r\n                            vpass = ((tvv < betav) ? 1 : 0);\r\n                            spass = ((tss < betas) ? 1 : 0);\r\n\r\n                            if((spass) || (vpass)) {\r\n\r\n                                // At least one sequence has passed the convergence test.\r\n                                // Store variables before iterating\r\n\r\n                                for(i = 0; i < N; i++) {\r\n                                    svk[i] = K[i];\r\n                                }\r\n                                s = ss;\r\n\r\n                                // Choose iteration according to the fastest converging sequence\r\n\r\n                                stry = vtry = 0;\r\n\r\n                                for(; ; ) {\r\n                                    if((fflag && ((fflag = 0) == 0)) && ((spass) && (!vpass || (tss < tvv)))) {\r\n                                        ;// Do nothing. Provides a quick \"short circuit\".\r\n                                    }\r\n                                    else {\r\n                                        QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\r\n                                        a = sdPar.a;\r\n                                        b = sdPar.b;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Quadratic iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        iFlag = vtry = 1;\r\n                                        betav *= 0.25;\r\n\r\n                                        // Try linear iteration if it has not been tried and the s sequence is converging\r\n                                        if(stry || (!spass)) {\r\n                                            iFlag = 0;\r\n                                        }\r\n                                        else {\r\n                                            for(i = 0; i < N; i++)\r\n                                                K[i] = svk[i];\r\n                                        }\r\n                                    }\r\n                                    //fflag = 0;\r\n                                    if(iFlag != 0) {\r\n                                        // Use sdPar for passing in s instead of defining a brand-new variable.\r\n                                        // sdPar.a = s\r\n                                        sdPar.a = s;\r\n                                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\r\n                                        s = sdPar.a;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Linear iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        stry = 1;\r\n                                        betas *= 0.25;\r\n\r\n                                        if(iFlag != 0) {\r\n                                            // If linear iteration signals an almost double real zero, attempt quadratic iteration\r\n                                            ui = -(s + s);\r\n                                            vi = s * s;\r\n                                            continue;\r\n\r\n                                        }\r\n                                    }\r\n\r\n                                    // Restore variables\r\n                                    for(i = 0; i < N; i++)\r\n                                        K[i] = svk[i];\r\n\r\n                                    // Try quadratic iteration if it has not been tried and the v sequence is converging\r\n                                    if(!vpass || vtry)\r\n                                        break;\t\t// Break out of infinite for loop\r\n\r\n                                }\r\n\r\n                                // Re-compute qp and scalar values to continue the second stage\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                a = sdPar.a;\r\n                                b = sdPar.b;\r\n\r\n                                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n                            }\r\n                        }\r\n                        ovv = vv;\r\n                        oss = ss;\r\n                        otv = tv;\r\n                        ots = ts;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function rpSolve(degPar, p, zeror, zeroi) {\r\n                    var N = degPar.Degree,\r\n                            RADFAC = 3.14159265358979323846 / 180, // Degrees-to-radians conversion factor = PI/180\r\n                            LB2 = Math.LN2, // Dummy variable to avoid re-calculating this value in loop below\r\n                            MDP1 = degPar.Degree + 1,\r\n                            K = new Array(MDP1),\r\n                            pt = new Array(MDP1),\r\n                            qp = new Array(MDP1),\r\n                            temp = new Array(MDP1),\r\n                            // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\r\n                            qPar = new Object(),\r\n                            // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\r\n                            Fxshfr_Par = new Object(),\r\n                            bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm,\r\n                            aa, bb, cc, sr, t, u, xxx,\r\n                            j, jj, l, NM1, NN, zerok;// Integer variables\r\n\r\n                    // Calculate the machine epsilon and store in the variable DBL_EPSILON.\r\n                    // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\r\n                    aa = 1.0;\r\n                    do {\r\n                        DBL_EPSILON = aa;\r\n                        aa /= 2;\r\n                        bb = 1.0 + aa;\r\n                    }\r\n                    while(bb > 1.0);\r\n\r\n                    var LO = Number.MIN_VALUE / DBL_EPSILON,\r\n                            cosr = Math.cos(94.0 * RADFAC), // = -0.069756474\r\n                            sinr = Math.sin(94.0 * RADFAC), // = 0.99756405\r\n                            xx = Math.sqrt(0.5), // = 0.70710678\r\n                            yy = -xx;\r\n\r\n                    Fxshfr_Par.NZ = j = 0;\r\n                    Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\r\n\r\n                    // Remove zeros at the origin, if any\r\n                    while(p[N] == 0) {\r\n                        zeror[j] = zeroi[j] = 0;\r\n                        N--;\r\n                        j++;\r\n                    }\r\n                    NN = N + 1;\r\n\r\n                    // >>>>> Begin Main Loop <<<<<\r\n                    while(N >= 1) { // Main loop\r\n                        // Start the algorithm for one zero\r\n                        if(N <= 2) {\r\n                            // Calculate the final zero or pair of zeros\r\n                            if(N < 2) {\r\n                                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\r\n                                zeroi[degPar.Degree - 1] = 0;\r\n                            }\r\n                            else {\r\n                                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                                Quad_ak1(p[0], p[1], p[2], qPar);\r\n                                zeror[degPar.Degree - 2] = qPar.sr;\r\n                                zeroi[degPar.Degree - 2] = qPar.si;\r\n                                zeror[degPar.Degree - 1] = qPar.lr;\r\n                                zeroi[degPar.Degree - 1] = qPar.li;\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        // Find the largest and smallest moduli of the coefficients\r\n                        moduli_max = 0.0;\r\n                        moduli_min = Number.MAX_VALUE;\r\n\r\n                        for(i = 0; i < NN; i++) {\r\n                            x = Math.abs(p[i]);\r\n                            if(x > moduli_max)\r\n                                moduli_max = x;\r\n                            if((x != 0) && (x < moduli_min))\r\n                                moduli_min = x;\r\n                        }\r\n\r\n                        // Scale if there are large or very small coefficients\r\n                        // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\r\n                        // is done to avoid overflow and to avoid undetected underflow interfering with the\r\n                        // convergence criterion.\r\n                        // The factor is a power of the base.\r\n                        sc = LO / moduli_min;\r\n\r\n                        if(((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (Number.MAX_VALUE / sc >= moduli_max))) {\r\n                            sc = ((sc == 0) ? Number.MIN_VALUE : sc);\r\n                            l = Math.floor(Math.log(sc) / LB2 + 0.5);\r\n                            factor = Math.pow(2.0, l);\r\n                            if(factor != 1.0) {\r\n                                for(i = 0; i < NN; i++)\r\n                                    p[i] *= factor;\r\n                            }\r\n                        }\r\n\r\n                        // Compute lower bound on moduli of zeros\r\n                        for(var i = 0; i < NN; i++)\r\n                            pt[i] = Math.abs(p[i]);\r\n                        pt[N] = -(pt[N]);\r\n                        NM1 = N - 1;\r\n\r\n                        // Compute upper estimate of bound\r\n                        x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\r\n\r\n                        if(pt[NM1] != 0) {\r\n                            // If Newton step at the origin is better, use it\r\n                            xm = -pt[N] / pt[NM1];\r\n                            x = ((xm < x) ? xm : x);\r\n                        }\r\n\r\n                        // Chop the interval (0, x) until ff <= 0\r\n                        xm = x;\r\n                        do {\r\n                            x = xm;\r\n                            xm = 0.1 * x;\r\n                            ff = pt[0];\r\n                            for(var i = 1; i < NN; i++) {\r\n                                ff = ff * xm + pt[i];\r\n                            }\r\n                        }\r\n                        while(ff > 0); // End do-while loop\r\n\r\n                        dx = x;\r\n                        // Do Newton iteration until x converges to two decimal places\r\n\r\n                        do {\r\n                            df = ff = pt[0];\r\n                            for(var i = 1; i < N; i++) {\r\n                                ff = x * ff + pt[i];\r\n                                df = x * df + ff;\r\n                            } // End for i\r\n                            ff = x * ff + pt[N];\r\n                            dx = ff / df;\r\n                            x -= dx;\r\n                        }\r\n                        while(Math.abs(dx / x) > 0.005); // End do-while loop\r\n\r\n                        bnd = x;\r\n\r\n                        // Compute the derivative as the initial K polynomial and do 5 steps with no shift\r\n                        for(var i = 1; i < N; i++)\r\n                            K[i] = (N - i) * p[i] / N;\r\n                        K[0] = p[0];\r\n                        aa = p[N];\r\n                        bb = p[NM1];\r\n                        zerok = ((K[NM1] == 0) ? 1 : 0);\r\n\r\n                        for(jj = 0; jj < 5; jj++) {\r\n                            cc = K[NM1];\r\n                            if(zerok) {\r\n                                // Use unscaled form of recurrence\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = K[j - 1];\r\n                                } // End for i\r\n                                K[0] = 0;\r\n                                zerok = ((K[NM1] == 0) ? 1 : 0);\r\n                            }\r\n                            else {\r\n                                // Used scaled form of recurrence if value of K at 0 is nonzero\r\n                                t = -aa / cc;\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = t * K[j - 1] + p[j];\r\n                                } // End for i\r\n                                K[0] = p[0];\r\n                                zerok = ((Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0) ? 1 : 0);\r\n                            }\r\n                        }\r\n\r\n                        // Save K for restarts with new shifts\r\n                        for(var i = 0; i < N; i++)\r\n                            temp[i] = K[i];\r\n\r\n                        // Loop to select the quadratic corresponding to each new shift\r\n                        for(jj = 1; jj <= 20; jj++) {\r\n\r\n                            // Quadratic corresponds to a double shift to a non-real point and its\r\n                            // complex conjugate. The point has modulus BND and amplitude rotated\r\n                            // by 94 degrees from the previous shift.\r\n\r\n                            xxx = -(sinr * yy) + cosr * xx;\r\n                            yy = sinr * xx + cosr * yy;\r\n                            xx = xxx;\r\n                            sr = bnd * xx;\r\n                            u = -(2.0 * sr);\r\n\r\n                            // Second stage calculation, fixed quadratic\r\n                            Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\r\n\r\n                            if(Fxshfr_Par.NZ != 0) {\r\n                                // The second stage jumps directly to one of the third stage iterations and\r\n                                // returns here if successful. Deflate the polynomial, store the zero or\r\n                                // zeros, and return to the main algorithm.\r\n                                j = degPar.Degree - N;\r\n                                zeror[j] = Fxshfr_Par.szr;\r\n                                zeroi[j] = Fxshfr_Par.szi;\r\n                                NN = NN - Fxshfr_Par.NZ;\r\n                                N = NN - 1;\r\n                                for(var i = 0; i < NN; i++)\r\n                                    p[i] = qp[i];\r\n                                if(Fxshfr_Par.NZ != 1) {\r\n                                    zeror[j + 1] = Fxshfr_Par.lzr;\r\n                                    zeroi[j + 1] = Fxshfr_Par.lzi;\r\n                                }\r\n                                break;\r\n                            }\r\n                            else {\r\n                                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\r\n                                for(var i = 0; i < N; i++) {\r\n                                    K[i] = temp[i];\r\n                                }\r\n                            }\r\n                        }\r\n                        // Return with failure if no convergence with 20 shifts\r\n                        if(jj > 20) {\r\n                            degPar.Degree -= N;\r\n                            break;\r\n                        }\r\n                    }\r\n                    // >>>>> End Main Loop <<<<<\r\n                    return;\r\n                }\r\n                //--> End Jenkins-Traub\r\n                rpSolve(degreePar, p, zeror, zeroi);\r\n\r\n                var l = zeroi.length;\r\n                //format the output\r\n                for(i = 0; i < l; i++) {\r\n                    // We round the imaginary part to avoid having something crazy like 5.67e-16.\r\n                    var img = round(zeroi[i], decp + 8),\r\n                            real = round(zeror[i], decp + 8);\r\n                    // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\r\n                    // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \r\n                    // the original otherwise the rounding was worth it.\r\n                    real = decp - String(real).length > 2 ? real : zeror[i];\r\n                    var sign = img < 0 ? '-' : '';\r\n\r\n                    // Remove the zeroes\r\n                    if(real === 0) {\r\n                        real = '';\r\n                    }\r\n                    if(img === 0) {\r\n                        img = '';\r\n                    }\r\n\r\n                    // Remove 1 as the multiplier and discard imaginary part if there isn't one.\r\n                    img = Math.abs(img) === 1 ? sign + 'i' : (img ? img + '*i' : '');\r\n\r\n                    var num = (real && img) ? real + '+' + img : real + img;\r\n                    zeror[i] = num.replace(/\\+\\-/g, '-');\r\n                }\r\n                return zeror;\r\n            }\r\n        },\r\n        roots: function (symbol) {\r\n\r\n            if(symbol.isConstant(true, true)) {\r\n                return core.Utils.nroots(symbol);\r\n            }\r\n            var roots = __.proots(symbol).map(function (x) {\r\n                return _.parse(x);\r\n            });\r\n            return core.Vector.fromArray(roots);\r\n        },\r\n        froot: function (f, guess, dx) {\r\n            var newtonraph = function (xn) {\r\n                var mesh = 1e-12,\r\n                        // If the derivative was already provided then don't recalculate.\r\n                        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\r\n                        // If the function was passed in as a function then don't recalculate.\r\n                        fn = f instanceof Function ? f : core.Utils.build(f),\r\n                        max = 10000,\r\n                        done = false,\r\n                        safety = 0;\r\n                while(!done) {\r\n                    var x = xn - (fn(xn) / df(xn));\r\n                    //absolute values for both x & xn ensures that we indeed have the radius    \r\n                    var r = Math.abs(x) - Math.abs(xn),\r\n                            delta = Math.abs(r);\r\n                    xn = x;\r\n\r\n                    if(delta < mesh)\r\n                        done = true;\r\n                    else if(safety > max) {\r\n                        xn = null;\r\n                        done = true;\r\n                    }\r\n\r\n                    safety++;\r\n                }\r\n                return xn;\r\n            };\r\n            return newtonraph(Number(guess));\r\n        },\r\n        quad: function (a, b, c) {\r\n            var q = function (a, b, c, sign) {\r\n                return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\r\n            };\r\n            return [q(a, b, c, 1), q(a, b, c, -1)];\r\n        },\r\n        sumProd: function (a, b) {\r\n            return __.quad(-b, a, -1).map(function (x) {\r\n                return x.invert();\r\n            });\r\n        },\r\n        coeffs: function (symbol, wrt, coeffs) {\r\n            wrt = String(wrt);\r\n            symbol = _.expand(symbol);\r\n            coeffs = coeffs || [new Symbol(0)];\r\n            //we cannot get coeffs for group EX\r\n            if(symbol.group === EX && symbol.contains(wrt, true))\r\n                _.error('Unable to get coefficients using expression ' + symbol.toString());\r\n            var vars = variables(symbol);\r\n            if(vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\r\n                var a = new Polynomial(symbol).coeffs.map(function (x) {\r\n                    return new Symbol(x);\r\n                });\r\n\r\n                for(var i = 0, l = a.length; i < l; i++) {\r\n                    var coeff = a[i],\r\n                            e = coeffs[i];\r\n                    if(e)\r\n                        coeff = _.add(e, coeff);\r\n                    coeffs[i] = coeff; //transfer it all over\r\n                }\r\n            }\r\n            else {\r\n                if(!wrt)\r\n                    _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\r\n                //if the variable isn't part of this polynomial then we're looking at x^0\r\n\r\n                if(vars.indexOf(wrt) === -1) {\r\n                    coeffs[0] = _.add(symbol, coeffs[0]);\r\n                }\r\n                else {\r\n                    coeffs = coeffs || [new Symbol(0)];\r\n                    if(symbol.group === CB) {\r\n                        var s = symbol.symbols[wrt];\r\n                        if(!s)\r\n                            _.error('Expression is not a polynomial!');\r\n                        var p = Number(s.power);\r\n                        coeff = _.divide(symbol.clone(), s.clone());\r\n                        if(coeff.contains(wrt, true) || p < 0 || !isInt(p))\r\n                            _.error('Expression is not a polynomial!');\r\n                        var e = coeffs[p];\r\n                        if(e)\r\n                            coeff = _.add(e, coeff);\r\n                        coeffs[p] = coeff;\r\n                    }\r\n                    else if(symbol.group === CP) {\r\n                        symbol.each(function (x) {\r\n                            __.coeffs(x.clone(), wrt, coeffs);\r\n                        }, true);\r\n                    }\r\n                }\r\n            }\r\n            //fill holes\r\n            for(var i = 0, l = coeffs.length; i < l; i++)\r\n                if(typeof coeffs[i] === 'undefined')\r\n                    coeffs[i] = new Symbol(0);\r\n\r\n            return coeffs;\r\n        },\r\n        /**\r\n         * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n         * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n         * @param {Symbol} e\r\n         * @param {String} for_variable\r\n         * @param {Array} powers\r\n         * @returns {Array} An array of the powers\r\n         */\r\n        //assumes you've already verified that it's a polynomial\r\n        polyPowers: function (e, for_variable, powers) {\r\n            powers = powers || [];\r\n            var g = g = e.group;\r\n            if(g === PL && for_variable === e.value) {\r\n                powers = powers.concat(keys(e.symbols));\r\n            }\r\n            else if(g === CP) {\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s];\r\n                    var g = symbol.group, v = symbol.value;\r\n                    if(g === S && for_variable === v)\r\n                        powers.push(symbol.power);\r\n                    else if(g === PL || g === CP)\r\n                        powers = __.polyPowers(symbol, for_variable, powers);\r\n                    else if(g === CB && symbol.contains(for_variable)) {\r\n                        var t = symbol.symbols[for_variable];\r\n                        if(t)\r\n                            powers.push((t.power));\r\n                    }\r\n                    else if(g === N || for_variable !== v)\r\n                        powers.push(0);\r\n                }\r\n            }\r\n            else if(g === CB && e.contains(for_variable)) {\r\n                powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\r\n            }\r\n            return core.Utils.arrayUnique(powers).sort();\r\n        },\r\n        //The factor object\r\n        Factor: {\r\n            //splits the symbol in symbol and constant\r\n            split: function (symbol) {\r\n                var c = new Symbol(1); //the constants part\r\n                var s = new Symbol(1); //the symbolic part\r\n                __.Factor.factor(symbol, new Factors()).each(function (x) {\r\n                    var t = _.parse(x);\r\n                    if(x.isConstant(true)) {\r\n                        c = _.multiply(c, t);\r\n                    }\r\n                    else {\r\n                        s = _.multiply(s, t);\r\n                    }\r\n                });\r\n                return [c, s];\r\n            },\r\n            mix: function (o, include_negatives) {\r\n                var factors = keys(o);\r\n                var l = factors.length;\r\n                var m = [];//create a row which we'r going to be mixing\r\n                for(var i = 0; i < l; i++) {\r\n                    var factor = factors[i],\r\n                            p = o[factor];\r\n                    var ll = m.length;\r\n                    for(var j = 0; j < ll; j++) {\r\n                        var t = m[j] * factor;\r\n                        m.push(t);\r\n                        if(include_negatives)\r\n                            m.push(-t);\r\n                    }\r\n\r\n                    for(var j = 1; j <= p; j++)\r\n                        m.push(Math.pow(factor, j));\r\n                }\r\n                return m;\r\n            },\r\n            //TODO: this method is to replace common factoring\r\n            common: function (symbol, factors) {\r\n                try {\r\n                    if(symbol.group === CP) {\r\n                        //this may have the unfortunate side effect of expanding and factoring again\r\n                        //to only end up with the same result. \r\n                        //TODO: try to avoid this\r\n                        //collect the symbols and sort to have the longest first. Thinking is that the longest terms \r\n                        //has to contain the variable in order for it to be factorable\r\n                        var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\r\n                            return (b.length || 1) - (a.length || 1);\r\n                        });\r\n\r\n                        var map = {}; //create a map of common factors\r\n                        var coeffs = [];\r\n                        for(var i = 0; i < symbols.length; i++) {\r\n                            var sym = symbols[i];\r\n                            coeffs.push(sym.multiplier.clone());\r\n                            sym.each(function (x) {\r\n                                var p = Number(x.power);\r\n                                //This check exits since we have a symbolic power.\r\n                                //For the future... think about removing this check and modify for symbolic powers\r\n                                if(isNaN(p))\r\n                                    throw new Error('exiting');\r\n                                //loop through the symbols and lump together common terms\r\n                                if(x.value in map) {\r\n                                    if(p < map[x.value][0])\r\n                                        map[x.value][0] = p;\r\n                                    map[x.value][1].push(x);\r\n                                }\r\n                                else\r\n                                    map[x.value] = [p, [x]];\r\n                            });\r\n                        }\r\n                        //the factor\r\n                        var factor = new Symbol(1);\r\n                        for(var x in map) {\r\n                            //if this factor is found in all terms since the length of \r\n                            //matching variable terms matches the number of original terms\r\n                            if(map[x][1].length === symbols.length) {\r\n                                //generate a symbol and multiply into the factor\r\n                                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\r\n                            }\r\n                        }\r\n                        //get coefficient factor\r\n                        var c = core.Math2.QGCD.apply(null, coeffs);\r\n\r\n                        if(!c.equals(1)) {\r\n                            factors.add(new Symbol(c));\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbols[i].multiplier = symbols[i].multiplier.divide(c);\r\n                            }\r\n                        }\r\n\r\n                        //if we actuall found any factors\r\n                        if(!factor.equals(1)) {\r\n                            factors.add(factor);\r\n                            symbol = new Symbol(0);\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            zeroes: function (symbol, factors) {\r\n                var exit = function () {\r\n                    throw new core.exceptions.ValueLimitExceededError('Exiting');\r\n                };\r\n                try {\r\n                    var vars, term, sum, p, e;\r\n                    symbol = _.expand(symbol.clone());\r\n                    e = symbol.toString();\r\n                    vars = variables(symbol);\r\n\r\n                    sum = new Symbol(0);\r\n\r\n                    var terms = [];\r\n                    var powers = [];\r\n\r\n                    //start setting each variable to zero\r\n                    for(var i = 0, l = vars.length; i < vars.length; i++) {\r\n                        var subs = {};\r\n                        //we want to create a subs object with all but the current variable set to zero\r\n                        for(var j = 0; j < l; j++)\r\n                            if(i !== j) //make sure we're not looking at the same variable\r\n                                subs[vars[j]] = 0;\r\n                        term = _.parse(e, subs);\r\n                        var tp = term.power;\r\n                        //the temporary power has to be an integer as well\r\n                        if(!isInt(tp))\r\n                            exit();\r\n                        terms.push(term);\r\n                        powers.push(term.power);\r\n                    }\r\n\r\n                    //get the gcd. This will be the p in (a^n+b^m)^p\r\n                    //if the gcd equals 1 meaning n = m then we need a tie breakder\r\n                    if(core.Utils.allSame(powers)) {\r\n                        //get p given x number of terms\r\n                        var n_terms = symbol.length;\r\n                        //the number of zeroes determines\r\n                        var n_zeroes = terms.length;\r\n                        if(n_zeroes === 2) {\r\n                            p = new Frac(powers[0] / (n_terms - 1));\r\n                        }\r\n                        if(n_zeroes === 3) {\r\n                            p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\r\n                        }\r\n                        /*\r\n                         //get the lowest possible power\r\n                         //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n                         symbol.each(function(x) {\r\n                         if(x.group === CB)\r\n                         x.each(function(y) {\r\n                         if(!p || y.power.lessThan(p))\r\n                         //p = Number(y.power);\r\n                         p = y.power;\r\n                         });\r\n                         else if(!p || x.power.lessThan(p))\r\n                         //p = Number(x.power);\r\n                         p = x.power;\r\n                         });\r\n                         */\r\n                    }\r\n                    else\r\n                        //p is just the gcd of the powers\r\n                        p = core.Math2.QGCD.apply(null, powers);\r\n\r\n                    //if we don't have an integer then exit\r\n                    if(!isInt(p))\r\n                        exit();\r\n\r\n                    //build the factor\r\n                    for(var i = 0; i < terms.length; i++) {\r\n                        var t = terms[i];\r\n                        var n = t.power.clone().divide(p);\r\n                        t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\r\n                        t.power = p.clone();\r\n                        sum = _.add(sum, t);\r\n                    }\r\n\r\n                    //by now we have the factor of zeroes. We'll know if we got it right because \r\n                    //we'll get a remainder of zero each time we divide by it\r\n                    if(sum.group !== CP)\r\n                        return symbol; //nothing to do\r\n\r\n                    while(true) {\r\n                        var d = __.div(symbol.clone(), sum.clone());\r\n                        if(d[1].equals(0)) {\r\n                            symbol = d[0];\r\n                            factors.add(sum.clone());\r\n                            if(symbol.equals(1)) //we've reached 1 so done.\r\n                                break;\r\n                        }\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                catch(e) {\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            },\r\n            factor: function (symbol, factors) {\r\n                // Don't try to factor constants\r\n                if(symbol.isConstant()) {\r\n                    return core.Math2.factor(symbol);\r\n                }\r\n\r\n                var _symbol = _.parse(symbol);\r\n                var retval = __.Factor._factor(_symbol, factors);\r\n                if(retval.equals(symbol)) {\r\n                    return retval;\r\n                }\r\n\r\n                if(retval.group === CB) {\r\n                    var t = new Symbol(1);\r\n                    var p = _.parse(retval.power);\r\n                    //store the multiplier and strip it\r\n                    var m = _.parse(retval.multiplier);\r\n\r\n                    retval.toUnitMultiplier();\r\n\r\n                    /* \r\n                     * NOTE: for sign issues with factor START DEBUGGING HERE\r\n                     */\r\n                    //move the sign to t\r\n                    if(retval.multiplier.lessThan(0)) {\r\n                        t.negate();\r\n                        retval.negate();\r\n                    }\r\n\r\n                    retval.each(function (x) {\r\n                        // Related to #566. Since the symbol's group may not have been properly\r\n                        // updated, it's easier to just parse the symbol and have the parser \r\n                        // do the update for us.\r\n                        var factored = _.parse(__.Factor._factor(x));\r\n\r\n                        if(factored.group === CB) {\r\n                            // Include the multiplier\r\n                            m = _.multiply(m, Symbol.create(factored.multiplier));\r\n                            factored.each(function (y) {\r\n                                var _factored = _.parse(__.Factor._factor(y));\r\n                                t = _.multiply(t, _factored);\r\n                                if(_factored.group === CB) {\r\n                                    m = _.multiply(m, Symbol.create(_factored.multiplier));\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            t = _.multiply(t, factored);\r\n                        }\r\n                    });\r\n\r\n                    //put back the multiplier and power\r\n                    retval = _.pow(_.multiply(m, t), p);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            quadFactor: function (symbol, factors) {\r\n                if(symbol.isPoly() && __.degree(symbol.equals(2))) {\r\n                    //We've  already checked that we're dealing with a polynomial\r\n                    var v = core.Utils.variables(symbol)[0]; //get the variable\r\n                    var coeffs = __.coeffs(symbol, v);\r\n                    //factor the lead coefficient\r\n                    var cf = __.Factor._factor(coeffs[2].clone());\r\n                    //check if we have factors\r\n                    if(cf.group === CB) {\r\n                        var symbols = cf.collectSymbols();\r\n                        //if the factors are greater than 2 we're done so exit\r\n                        if(symbols.length > 2)\r\n                            return symbol;\r\n                        //if we have two factors then attempt to factor the polynomial\r\n                        //let the factors be f1 and f1\r\n                        //let the factors be (ax+b)(cx+d)\r\n                        //let the coefficients be c1x^2+c2x+c3\r\n                        //then a(x1)+c(x2)=c2 and x1*x2=c3\r\n                        //we can solve for x1 and x2\r\n                        var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\r\n                        var b = _.parse(coeffs[1]).negate();\r\n                        var a = _.parse(symbols[1]);\r\n                        //solve the system\r\n                        var root = __.quad(a, b, c).filter(function (x) {\r\n                            if(core.Utils.isInt(x))\r\n                                return x;\r\n                        });\r\n                        //if we have one root then find the other one by dividing the constant\r\n                        if(root.length === 1) {\r\n                            var root1 = root[0];\r\n                            var root2 = _.divide(coeffs[0], _.parse(root1));\r\n                            if(core.Utils.isInt(root2)) {\r\n                                //we found them both\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            cubeFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var symbols = symbol.collectSymbols();\r\n                    // The symbol should be in the form of a^3+-b^3. The length\r\n                    // should therefore only be two. If it's any different from this\r\n                    // then we're done\r\n                    if(symbols.length === 2) {\r\n                        // Store the signs and then strip them from the symbols\r\n                        var sign_a = symbols[0].sign();\r\n                        var a = symbols[0].clone().abs();\r\n                        var sign_b = symbols[1].sign();\r\n                        var b = symbols[1].clone().abs();\r\n                        // Check if they're cube\r\n                        if(a.isCube() && b.isCube()) {\r\n                            // Keep the negative sign on the right, meaning b is always negative.\r\n                            if(sign_a < sign_b) {\r\n                                // Swap the signs and then the values\r\n                                [sign_a, sign_b] = [sign_b, sign_a];\r\n                                [a, b] = [b, a];\r\n                            }\r\n\r\n                            // Get teh roots\r\n                            var m_root_a = _.parse(a.getNth(3));\r\n                            var m_root_b = _.parse(b.getNth(3));\r\n\r\n                            // Remove the cube for both\r\n                            var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\r\n                            var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\r\n\r\n                            if(sign_a === 1 && sign_b === -1) {\r\n                                // Apply difference of cubes rule\r\n                                factors.add(_.parse(format('(({0})-({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                            else if(sign_a === 1 && sign_b === 1) {\r\n                                // Apply sum of cubes rule\r\n                                factors.add(_.parse(format('(({0})+({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            _factor: function (symbol, factors) {\r\n                //some items cannot be factored any further so return those right away\r\n                if(symbol.group === FN) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.group === S && arg.isSimple()) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n                else if(symbol.group === S && symbol.isSimple()) {\r\n                    return symbol;\r\n                }\r\n\r\n                // Expand the symbol to get it in a predictable form. If this step\r\n                // is skipped some factors are missed.\r\n                //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\r\n                if(symbol.group === CP) {\r\n                    symbol.distributeMultiplier(true);\r\n                    var t = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        if((x.group === CP && x.power.greaterThan(1) || x.group === CB))\r\n                            x = _.expand(x);\r\n                        t = _.add(t, x);\r\n                    });\r\n                    t.power = symbol.power;\r\n\r\n                    symbol = t;\r\n                }\r\n\r\n                if(symbol.group === FN && symbol.fname !== 'sqrt') {\r\n                    symbol = core.Utils.evaluate(symbol);\r\n                }\r\n\r\n                //make a copy of the symbol to return if something goes wrong\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    if(symbol.group === CB) {\r\n                        var p = _.parse(symbol.power);\r\n\r\n                        var den_array, num_array, den, num, dfact, nfact;\r\n                        //grab the denominator and strip the multiplier and power. Store them in an array\r\n                        den_array = __.Simplify.strip(symbol.getDenom());\r\n                        num_array = __.Simplify.strip(symbol.getNum());\r\n\r\n                        den = den_array.pop();\r\n                        num = num_array.pop();\r\n\r\n                        //if the numerator equals the symbol then we've hit the simplest form and then we're done\r\n                        if(num.equals(symbol)) {\r\n                            return symbol;\r\n                        }\r\n                        nfact = __.Factor.factor(num);\r\n                        dfact = __.Factor.factor(den);\r\n\r\n                        var n = __.Simplify.unstrip(num_array, nfact);\r\n                        var d = __.Simplify.unstrip(den_array, dfact);\r\n\r\n                        var retval = _.divide(n, d);\r\n\r\n                        return retval;\r\n                    }\r\n                    if(symbol.group === S) {\r\n                        return symbol; //absolutely nothing to do\r\n                    }\r\n\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol.equals(1))\r\n                            return symbol.clone();\r\n                        var ret = core.Math2.factor(symbol);\r\n                        return ret;\r\n                    }\r\n\r\n                    var p = symbol.power.clone();\r\n\r\n                    if(isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\r\n                        var sign = p.sign();\r\n                        symbol.toLinear();\r\n                        factors = factors || new Factors();\r\n                        var map = {};\r\n                        symbol = _.parse(core.Utils.subFunctions(symbol, map));\r\n                        if(keys(map).length > 0) { //it might have functions\r\n                            factors.preAdd = function (factor) {\r\n                                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\r\n                                return ret;\r\n                            };\r\n                        }\r\n\r\n                        //strip the power\r\n                        if(!symbol.isLinear()) {\r\n                            factors.pFactor = symbol.power.toString();\r\n                            symbol.toLinear();\r\n                        }\r\n\r\n                        var vars = variables(symbol);\r\n                        //bypass for imaginary. TODO: find a better solution\r\n                        if(symbol.isImaginary()) {\r\n                            vars.push(core.Settings.IMAGINARY);\r\n                        }\r\n                        var multiVar = vars.length > 1;\r\n\r\n                        //minor optimization. Seems to cut factor time by half in some cases.\r\n                        if(multiVar) {\r\n                            var all_S = true, all_unit = true;\r\n                            symbol.each(function (x) {\r\n                                if(x.group !== S)\r\n                                    all_S = false;\r\n                                if(!x.multiplier.equals(1))\r\n                                    all_unit = false;\r\n                            });\r\n\r\n                            if(all_S && all_unit) {\r\n                                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\r\n                            }\r\n                        }\r\n\r\n                        //factor the coefficients\r\n                        var coeff_factors = new Factors();\r\n\r\n                        symbol = __.Factor.coeffFactor(symbol, coeff_factors);\r\n\r\n                        coeff_factors.each(function (x) {\r\n                            // If the factor was negative but was within a square then it becomes positive\r\n                            if(even(p) && x.lessThan(0)) {\r\n                                x.negate();\r\n                            }\r\n\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        //factor the power\r\n                        var power_factors = new Factors();\r\n                        symbol = __.Factor.powerFactor(symbol, power_factors);\r\n                        power_factors.each(function (x) {\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        if(!multiVar) {\r\n                            //pass in vars[0] for safety\r\n                            var v = vars[0];\r\n\r\n                            symbol = __.Factor.squareFree(symbol, factors, v);\r\n\r\n                            var t_factors = new Factors();\r\n\r\n                            symbol = __.Factor.trialAndError(symbol, t_factors, v);\r\n\r\n                            //generate a symbol based off the last factors\r\n                            var tf_symbol = t_factors.toSymbol();\r\n                            //if nothing was factored then return the factors\r\n                            if(tf_symbol.equals(untouched)) {\r\n                                return tf_symbol;\r\n                            }\r\n\r\n                            for(var x in t_factors.factors) {\r\n                                //store the current factor in t_factor\r\n                                var t_factor = t_factors.factors[x];\r\n                                factors.add(_.pow(t_factor, _.parse(p)));\r\n                            }\r\n                            //if we still don't have a factor and it's quadratic then let's just do a quad factor\r\n                            if(symbol.equals(untouched)) {\r\n                                symbol = __.Factor.quadFactor(symbol, factors);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            // Try sum and difference of cubes\r\n                            symbol = __.Factor.cubeFactor(symbol, factors);\r\n\r\n                            symbol = __.Factor.mfactor(symbol, factors);\r\n\r\n                            //put back the sign of power\r\n                            factors.each(function (x) {\r\n                                if(sign < 0)\r\n                                    x.power.negate();\r\n                            });\r\n                        }\r\n\r\n                        //last minute clean up\r\n                        symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\r\n\r\n                        factors.add(_.pow(symbol, _.parse(p)));\r\n\r\n                        var retval = factors.toSymbol();\r\n\r\n                        return retval;\r\n                    }\r\n\r\n                    return symbol;\r\n                }\r\n                catch(e) {\r\n                    //no need to stop the show because something went wrong :). Just return the unfactored.\r\n                    return untouched;\r\n                }\r\n            },\r\n            reduce: function (symbol, factors) {\r\n                if(symbol.group === CP && symbol.length === 2) {\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return b.multiplier - a.multiplier;\r\n                    });\r\n                    if(symbols[0].power.equals(symbols[1].power)) {\r\n                        //x^n-a^n\r\n                        var n = _.parse(symbols[0].power),\r\n                                a = symbols[0].clone().toLinear(),\r\n                                b = symbols[1].clone().toLinear();\r\n\r\n                        //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\r\n                        factors.add(_.add(a.clone(), b.clone()));\r\n                        //flip the sign\r\n                        b.negate();\r\n                        //turn n into a number\r\n                        var nn = Number(n);\r\n                        //the remainder\r\n                        var result = new Symbol(0);\r\n                        for(var i = 1; i <= nn; i++) {\r\n                            var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\r\n                                    bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\r\n                            result = _.add(result, _.multiply(aa, bb));\r\n                        }\r\n                        return result;\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Makes Symbol square free\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @@param {String} variable The variable which is being factored \r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            squareFree: function (symbol, factors, variable) {\r\n                if(symbol.isConstant() || symbol.group === S)\r\n                    return symbol;\r\n\r\n                var poly = new Polynomial(symbol, variable);\r\n                var sqfr = poly.squareFree();\r\n                var p = sqfr[2];\r\n                //if we found a square then the p entry in the array will be non-unit\r\n                if(p !== 1) {\r\n                    //make sure the remainder doesn't have factors\r\n                    var t = sqfr[1].toSymbol();\r\n                    t.power = t.power.multiply(new Frac(p));\r\n                    //send the factor to be fatored to be sure it's completely factored\r\n                    factors.add(__.Factor.factor(t));\r\n\r\n                    var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\r\n\r\n                    return retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Factors the powers such that the lowest power is a constant\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            powerFactor: function (symbol, factors) {\r\n                //only PL need apply\r\n                if(symbol.group !== PL || symbol.previousGroup === EX)\r\n                    return symbol;\r\n                var k = keys(symbol.symbols);\r\n                //we expect only numeric powers so return all else\r\n                if(!core.Utils.allNumeric(k))\r\n                    return symbol;\r\n\r\n                var d = core.Utils.arrayMin(k);\r\n                var retval = new Symbol(0);\r\n                var q = _.parse(symbol.value + '^' + d);\r\n                symbol.each(function (x) {\r\n                    x = _.divide(x, q.clone());\r\n                    retval = _.add(retval, x);\r\n                });\r\n\r\n                factors.add(q);\r\n                return retval;\r\n            },\r\n            /**\r\n             * Removes GCD from coefficients\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @returns {Symbol}\r\n             */\r\n            coeffFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\r\n\r\n                    if(!gcd.equals(1)) {\r\n                        symbol.each(function (x) {\r\n                            if(x.isComposite()) {\r\n                                x.each(function (y) {\r\n                                    y.multiplier = y.multiplier.divide(gcd);\r\n                                });\r\n                            }\r\n                            else\r\n                                x.multiplier = x.multiplier.divide(gcd);\r\n                        });\r\n                        symbol.updateHash();\r\n                    }\r\n                    else {\r\n                        // TODO: This should probably go to the prototype\r\n                        var power = function (symbol) {\r\n                            var p;\r\n                            if(symbol.group === CB) {\r\n                                p = 0;\r\n                                symbol.each(function (x) {\r\n                                    p += x.power;\r\n                                });\r\n                            }\r\n                            else {\r\n                                p = Number(symbol.power);\r\n                            }\r\n                            return p;\r\n                        };\r\n                        // Factor out negatives from the lead term\r\n                        var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\r\n                            // Push constants to the back\r\n                            if(a.isConstant(true))\r\n                                return 1;\r\n                            return b.power - a.power;\r\n                        });\r\n\r\n                        var LT = terms[0];\r\n\r\n                        // Check if the LT is indeed the greatest\r\n                        if(power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\r\n                            if(LT.multiplier.lessThan(0)) {\r\n                                // Although the symbol should always be linear at this point, remove the negative for squares\r\n                                // to be safe.\r\n                                factors.add(new Symbol(-1));\r\n\r\n                                symbol.each(function (x) {\r\n                                    x.negate();\r\n                                }, true);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(factors) {\r\n                        factors.add(new Symbol(gcd));\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * The name says it all :)\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @@param {String} variable \r\n             * @returns {Symbol}\r\n             */\r\n            trialAndError: function (symbol, factors, variable) {\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    // At temp holder for the factors. If all goes well then\r\n                    // they'll be moved to the actual factors.\r\n                    var factor_array = [];\r\n\r\n                    if(symbol.isConstant() || symbol.group === S)\r\n                        return symbol;\r\n                    var poly = new Polynomial(symbol, variable),\r\n                            cnst = poly.coeffs[0],\r\n                            cfactors = core.Math2.ifactor(cnst),\r\n                            roots = __.proots(symbol);\r\n                    for(var i = 0; i < roots.length; i++) {\r\n                        var r = roots[i],\r\n                                p = 1;\r\n                        if(!isNaN(r)) { //if it's a number\r\n                            for(var x in cfactors) {\r\n                                //check it's raised to a power\r\n                                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\r\n                                if(isInt(n)) {\r\n                                    r = x; //x must be the root since n gave us a whole\r\n                                    p = n;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            var root = new Frac(r),\r\n                                    terms = [new Frac(root.num).negate()];\r\n                            terms[p] = new Frac(root.den);\r\n                            //convert to Frac. The den is coeff of LT and the num is coeff of constant\r\n                            var div = Polynomial.fromArray(terms, poly.variable).fill(),\r\n                                    t = poly.divide(div);\r\n                            if(t[1].equalsNumber(0)) { //if it's zero we have a root and divide it out\r\n                                poly = t[0];\r\n                                // factors.add(div.toSymbol());\r\n                                factor_array.push(div.toSymbol());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!poly.equalsNumber(1)) {\r\n                        poly = __.Factor.search(poly, factors);\r\n                    }\r\n\r\n                    // Move the factors over since all went well.\r\n                    factor_array.forEach(function (x) {\r\n                        factors.add(x);\r\n                    });\r\n\r\n                    return poly.toSymbol();\r\n                }\r\n                catch(e) {\r\n                    return untouched;\r\n                }\r\n            },\r\n            search: function (poly, factors, base) {\r\n                base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\r\n                var v = poly.variable; //the polynmial variable name\r\n                /**\r\n                 * Attempt to remove a root by division given a number by first creating\r\n                 * a polynomial fromt he given information\r\n                 * @param {int} c1 - coeffient for the constant\r\n                 * @param {int} c2 - coefficient for the LT\r\n                 * @param {int} n - the number to be used to construct the polynomial\r\n                 * @param {int} p - the power at which to create the polynomial\r\n                 * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n                 */\r\n                var check = function (c1, c2, n, p) {\r\n                    var candidate = Polynomial.fit(c1, c2, n, base, p, v);\r\n                    if(candidate && candidate.coeffs.length > 1) {\r\n                        var t = poly.divide(candidate);\r\n                        if(t[1].equalsNumber(0)) {\r\n                            factors.add(candidate.toSymbol());\r\n                            return [t[0], candidate];\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n                var cnst = poly.coeffs[0];\r\n                var cfactors = core.Math2.ifactor(cnst);\r\n                var lc = poly.lc();\r\n                var ltfactors = core.Math2.ifactor(lc);\r\n                var subbed = poly.sub(base);\r\n                var isubbed = core.Math2.ifactor(subbed);\r\n                var nfactors = __.Factor.mix(isubbed, subbed < 0);\r\n                var cp = Math.ceil(poly.coeffs.length / 2);\r\n                var lc_is_neg = lc.lessThan(0);\r\n                var cnst_is_neg = cnst.lessThan(0);\r\n                ltfactors['1'] = 1;\r\n                cfactors['1'] = 1;\r\n                while(cp--) {\r\n                    for(var x in ltfactors) {\r\n                        for(var y in cfactors) {\r\n                            for(var i = 0; i < nfactors.length; i++) {\r\n                                var factor_found = check(x, y, nfactors[i], cp);\r\n                                if(factor_found) {\r\n                                    poly = factor_found[0];\r\n                                    if(!core.Utils.isPrime(poly.sub(base)))\r\n                                        poly = __.Factor.search(poly, factors);\r\n                                    return poly;\r\n                                }\r\n                                else if(!factor_found) {\r\n                                    if(lc_is_neg && cnst_is_neg)\r\n                                        factor_found = check(-x, -y, nfactors[i], cp);\r\n                                    else if(lc_is_neg)\r\n                                        factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\r\n                                    else if(cnst_is_neg)\r\n                                        factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return poly;\r\n            },\r\n            /**\r\n             * Equivalent of square free factor for multivariate polynomials\r\n             * @param {type} symbol\r\n             * @param {type} factors\r\n             * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n             */\r\n            mSqfrFactor: function (symbol, factors) {\r\n                if(symbol.group !== FN) {\r\n                    var vars = variables(symbol).reverse();\r\n\r\n                    // Loop through all the variable and remove the partial derivatives\r\n                    for(var i = 0; i < vars.length; i++) {\r\n                        do {\r\n                            if(vars[i] === symbol.value) {\r\n                                //the derivative tells us nothing since this symbol is already the factor\r\n                                factors.add(symbol);\r\n                                symbol = new Symbol(1);\r\n                                continue;\r\n                            }\r\n\r\n                            var diff = core.Calculus.diff(symbol, vars[i]);\r\n\r\n                            var d = __.Factor.coeffFactor(diff);\r\n\r\n                            if(d.equals(0))\r\n                                break;\r\n\r\n                            //trial division to see if factors have whole numbers. \r\n                            //This can be optimized by stopping as soon as can_divide is false\r\n                            //this will also need utilize big number at some point\r\n                            var can_divide = true;\r\n                            if(d.isConstant() && symbol.isComposite()) {\r\n                                //check the coefficients\r\n\r\n                                symbol.each(function (x) {\r\n                                    if(x.multiplier % d !== 0)\r\n                                        can_divide = false;\r\n                                }, true);\r\n                            }\r\n\r\n                            //if we can divide then do so\r\n                            if(can_divide) {\r\n\r\n                                var div = __.div(symbol, d.clone()),\r\n                                        is_factor = div[1].equals(0);\r\n\r\n                                if(div[0].isConstant()) {\r\n                                    factors.add(div[0]);\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else\r\n                                is_factor = false;\r\n\r\n                            if(is_factor) {\r\n                                factors.add(div[0]);\r\n                                symbol = d;\r\n                            }\r\n                        }\r\n                        while(is_factor)\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //difference of squares factorization\r\n            sqdiff: function (symbol, factors) {\r\n                if(symbol.isConstant('all')) {\r\n                    // Nothing to do\r\n                    return symbol;\r\n                }\r\n\r\n                try {\r\n                    var remove_square = function (x) {\r\n                        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                            return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\r\n                        }, true);\r\n                    };\r\n                    var separated = core.Utils.separate(symbol.clone());\r\n\r\n                    var obj_array = [];\r\n\r\n                    //get the unique variables\r\n                    for(var x in separated) {\r\n                        if(x !== 'constants') {\r\n                            obj_array.push(separated[x]);\r\n                        }\r\n                    }\r\n                    obj_array.sort(function (a, b) {\r\n                        return b.power - a.power;\r\n                    });\r\n\r\n                    //if we have the same number of variables as unique variables then we can apply the difference of squares\r\n                    if(obj_array.length === 2) {\r\n                        var a, b;\r\n                        a = obj_array.pop();\r\n                        b = obj_array.pop();\r\n\r\n                        if(even(a.power) && even(b.power)\r\n                                && a.sign() === b.sign()\r\n                                && a.group === S && b.group === S) {\r\n                            throw new Error('Unable to factor');\r\n                        }\r\n                        ;\r\n\r\n                        if(a.isComposite() && b.power.equals(2)) {\r\n                            //remove the square from b\r\n                            b = remove_square(b);\r\n                            var f = __.Factor.factor(_.add(a, separated.constants));\r\n                            if(f.power.equals(2)) {\r\n                                f.toLinear();\r\n                                factors.add(_.subtract(f.clone(), b.clone()));\r\n                                factors.add(_.add(f, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                        else {\r\n                            a = a.powSimp();\r\n                            b = b.powSimp();\r\n\r\n                            if((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\r\n                                if(a.multiplier.lessThan(0)) {\r\n                                    var t = b;\r\n                                    b = a;\r\n                                    a = t;\r\n                                }\r\n                                if(a.multiplier.greaterThan(0)) {\r\n                                    a = remove_square(a);\r\n                                    b = remove_square(b);\r\n                                }\r\n\r\n                                factors.add(_.subtract(a.clone(), b.clone()));\r\n                                factors.add(_.add(a, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //factoring for multivariate\r\n            mfactor: function (symbol, factors) {\r\n\r\n                if(symbol.group === FN) {\r\n                    if(symbol.fname === 'sqrt') {\r\n                        var factors2 = new Factors(),\r\n                                arg = __.Factor.common(symbol.args[0].clone(), factors2);\r\n                        arg = __.Factor.coeffFactor(arg, factors2);\r\n                        symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\r\n                        factors2.each(function (x) {\r\n                            symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\r\n                        });\r\n                    }\r\n                    else\r\n                        factors.add(symbol);\r\n                }\r\n                else {\r\n\r\n                    //square free factorization\r\n                    symbol = __.Factor.mSqfrFactor(symbol, factors);\r\n\r\n                    //try factor out common factors\r\n                    //symbol = __.Factor.common(symbol, factors);\r\n\r\n                    var vars = variables(symbol),\r\n                            symbols = symbol.collectSymbols().map(function (x) {\r\n                        return Symbol.unwrapSQRT(x);\r\n                    }),\r\n                            sorted = {},\r\n                            maxes = {},\r\n                            l = vars.length, n = symbols.length;\r\n                    //take all the variables in the symbol and organize by variable name\r\n                    //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\r\n\r\n                    for(var i = 0; i < l; i++) {\r\n                        var v = vars[i];\r\n                        sorted[v] = new Symbol(0);\r\n                        for(var j = 0; j < n; j++) {\r\n                            var s = symbols[j];\r\n                            if(s.contains(v)) {\r\n                                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\r\n                                if(!maxes[v] || p < maxes[v])\r\n                                    maxes[v] = p;\r\n                                sorted[v] = _.add(sorted[v], s.clone());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    for(var x in sorted) {\r\n                        var r = _.parse(x + '^' + maxes[x]);\r\n                        var div = _.divide(sorted[x], r);\r\n                        var new_factor = _.expand(div);\r\n\r\n                        if(new_factor.equals(1))\r\n                            break; //why divide by one. Just move \r\n                        var divided = __.div(symbol.clone(), new_factor);\r\n\r\n                        if(divided[0].equals(0)) {\r\n                            //cant factor anymore\r\n                            break;\r\n                        }\r\n\r\n                        // We potentially ended up with fractional coefficients when the\r\n                        // trial division was performed. We need to remove \r\n                        // This check will more then likely become superfluous with improvements\r\n                        // to polynomial division\r\n                        if(divided[1].equals(0)) {\r\n                            var has_fractions = false;\r\n\r\n                            divided[0].each(function (x) {\r\n                                if(!isInt(x.multiplier)) {\r\n                                    has_fractions = true;\r\n                                }\r\n                            });\r\n\r\n                            // The factor isn't really a factor and needs to be put back\r\n                            if(has_fractions) {\r\n                                divided[1] = _.expand(_.multiply(divided[1], new_factor));\r\n                                // Since the new factor is not just one, we exit.\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\r\n\r\n                        if(divided[1].equals(0) && !neg_numeric_factor) { //we found at least one factor\r\n\r\n                            //factors.add(new_factor);\r\n                            var d = __.div(symbol.clone(), divided[0].clone());\r\n                            var r = d[0];\r\n\r\n                            // Nothing left to do since we didn't get a reduction\r\n                            if(r.equals(0)) {\r\n                                return symbol;\r\n                            }\r\n\r\n                            symbol = d[1];\r\n                            //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\r\n                            //and we just return the symbol;\r\n                            //If r equals zero then there's nothing left to do so we're done\r\n\r\n                            if(r.equals(-1) && !symbol.equals(0))\r\n                                return symbol;\r\n\r\n                            var factor = divided[0];\r\n\r\n                            if(symbol.equals(factor)) {\r\n                                var rem = __.Factor.reduce(factor, factors);\r\n\r\n                                if(!symbol.equals(rem))\r\n                                    return __.Factor.mfactor(rem, factors);\r\n\r\n                                return rem;\r\n                            }\r\n                            else {\r\n                                factors.add(factor);\r\n                                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\r\n                                if(symbol.equals(0))\r\n                                    return r;\r\n                            }\r\n\r\n                            if(r.isConstant('all')) {\r\n                                factors.add(r);\r\n                                return r;\r\n                            }\r\n\r\n                            return __.Factor.mfactor(r, factors);\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                //difference of squares factorization\r\n                symbol = __.Factor.sqdiff(symbol, factors);\r\n\r\n                //factors by fishing for zeroes\r\n                symbol = __.Factor.zeroes(symbol, factors);\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a set of \"equations\" is linear. \r\n         * @param {type} set\r\n         * @returns {Boolean}\r\n         */\r\n        allLinear: function (set) {\r\n            var l = set.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(!__.isLinear(set[i]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /*\r\n         * Checks to see if the \"equation\" is linear\r\n         * @param {Symbol} e\r\n         * @returns {boolean}\r\n         */\r\n        isLinear: function (e) {\r\n            var status = false, g = e.group;\r\n            if(g === PL || g === CP) {\r\n                status = true;\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s], sg = symbol.group;\r\n                    if(sg === FN || sg === EX) {\r\n                        status = false;\r\n                    }\r\n                    if(sg === CB) {\r\n                        //needs further checking since it might be imaginary\r\n                        status = variables(symbol).length === 1;\r\n                    }\r\n                    else {\r\n                        if(sg === PL || sg === CP)\r\n                            status = __.isLinear(symbol);\r\n                        else {\r\n                            if(symbol.group !== N && symbol.power.toString() !== '1') {\r\n                                status = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(g === S && e.power === 1)\r\n                status = true;\r\n            return status;\r\n        },\r\n        gcd: function () {\r\n            var args;\r\n            if(arguments.length === 1 && arguments[0] instanceof core.Vector)\r\n                args = arguments[0].elements;\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //short-circuit early\r\n            if(args.length === 0)\r\n                return new Symbol(1);\r\n            else if(args.length === 1)\r\n                return args[0];\r\n\r\n            var appeared = [], evaluate = false;\r\n            for(var i = 0; i < args.length; i++) {\r\n                if(args[i].group === FN && args[i].fname === 'gcd')\r\n                {\r\n                    //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\r\n                    args = args.concat(arguments[i].args);\r\n                    //do not keep gcd in args\r\n                    args.splice(i, 1);\r\n                }\r\n                else\r\n                {\r\n                    //Look if there are any common variables such that\r\n                    //gcd(a,b) => gcd(a,b); gcd(a,a) => a\r\n                    var vars = variables(args[i]);\r\n                    if(core.Utils.haveIntersection(vars, appeared))\r\n                    {\r\n                        //Ok, there are common variables\r\n                        evaluate = true;\r\n                        break;\r\n                    }\r\n                    else\r\n                        appeared = appeared.concat(vars);\r\n                }\r\n            }\r\n\r\n            //appeared.length is 0 when all arguments are group N\r\n            if(evaluate || appeared.length === 0) {\r\n                //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\r\n                if(args.every(function (symbol) {\r\n                    return symbol.getDenom().equals(1)\r\n                })) {\r\n                    var aggregate = args[0];\r\n\r\n                    for(var i = 1; i < args.length; i++) {\r\n                        aggregate = __.gcd_(args[i], aggregate);\r\n                    }\r\n                    return aggregate;\r\n                }\r\n                else {\r\n                    //gcd_ cannot handle denominators correctly\r\n                    return _.divide(__.gcd.apply(null, args.map(function (symbol) {\r\n                        return symbol.getNum();\r\n                    })),\r\n                            __.lcm.apply(null, args.map(function (symbol) {\r\n                                return symbol.getDenom();\r\n                            })));\r\n                }\r\n            }\r\n            else\r\n                return _.symfunction('gcd', args);\r\n        },\r\n        gcd_: function (a, b) {\r\n            if(a.group === FN || a.group === P)\r\n                a = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(a);\r\n                });\r\n\r\n            if(b.group === FN)\r\n                b = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(b);\r\n                });\r\n\r\n            if(a.isConstant() && b.isConstant()) {\r\n                // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\r\n                return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\r\n            }\r\n\r\n            var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\r\n            a = _.multiply(a.clone(), den.clone());\r\n            b = _.multiply(b.clone(), den.clone());\r\n\r\n            //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\r\n            a = _.expand(a);\r\n            b = _.expand(b);\r\n\r\n            if(a.group === CB || b.group === CB) {\r\n                var q = _.divide(a.clone(), b.clone()); //get the quotient\r\n                var t = _.multiply(b.clone(), q.getDenom().invert());//multiply by the denominator\r\n                //if they have a common factor then the result will not equal one \r\n                if(!t.equals(1))\r\n                    return t;\r\n            }\r\n\r\n            //just take the gcd of each component when either of them is in group EX\r\n            if(a.group === EX || b.group === EX)\r\n            {\r\n                var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\r\n                var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\r\n                var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\r\n                return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\r\n            }\r\n\r\n            if(a.length < b.length) { //swap'm\r\n                var t = a;\r\n                a = b;\r\n                b = t;\r\n            }\r\n            var vars_a = variables(a), vars_b = variables(b);\r\n            if((vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0])\r\n                    || vars_a.length === 1 && vars_b.length === 0\r\n                    || vars_a.length === 0 && vars_b.length === 1) {\r\n                a = new Polynomial(a);\r\n                b = new Polynomial(b);\r\n                return _.divide(a.gcd(b).toSymbol(), den);\r\n            }\r\n            else {\r\n                //get the gcd of the multipiers\r\n                //get rid of gcd in coeffs\r\n                var multipliers = [];\r\n                a.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n                b.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n\r\n                var T;\r\n                while(!b.equals(0)) {\r\n                    var t = b.clone();\r\n                    a = a.clone();\r\n                    T = __.div(a, t);\r\n\r\n                    b = T[1];\r\n                    if(T[0].equals(0)) {\r\n                        //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\r\n                        return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\r\n                    }\r\n                    a = t;\r\n                }\r\n\r\n                var gcd = core.Math2.QGCD.apply(undefined, multipliers);\r\n\r\n                if(!gcd.equals(1)) {\r\n                    a.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(gcd);\r\n                    });\r\n                }\r\n\r\n                //return symbolic function for gcd in indeterminate form\r\n                if(a.equals(1) && !a.isConstant() && !b.isConstant())\r\n                    return _.divide(_.symfunction('gcd', arguments), den);\r\n\r\n                return _.divide(a, den);\r\n            }\r\n        },\r\n        lcm: function () {\r\n            //https://math.stackexchange.com/a/319310\r\n            //generalization of the 2-variable formula of lcm\r\n\r\n            var args;\r\n            if(arguments.length === 1)\r\n                if(arguments[0] instanceof core.Vector)\r\n                    args = arguments[0].elements;\r\n                else\r\n                    _.error('lcm expects either 1 vector or 2 or more arguments');\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //product of all arguments\r\n            //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n            var numer = args.reduce(function (prev, curr) {\r\n                return _.multiply(prev, curr.clone())\r\n            }, new Symbol(1));\r\n\r\n            //gcd of complementary terms\r\n            var denom_args =\r\n                    //https://stackoverflow.com/a/18223072\r\n                //take all complementary terms, e.g.\r\n                //[a,b,c] => [a*b, b*c, a*c]\r\n                //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\r\n                (function (input, size) {\r\n                        size = Number(size);\r\n                        var results = [], result, mask, i, total = Math.pow(2, input.length);\r\n                        for(mask = size; mask < total; mask++) {\r\n                            result = [];\r\n                            i = input.length - 1;\r\n\r\n                            do {\r\n                                if((mask & (1 << i)) !== 0) {\r\n                                    result.push(input[i]);\r\n                                }\r\n                            }\r\n                            while(i--);\r\n\r\n                            if(result.length === size) {\r\n                                results.push(result);\r\n                            }\r\n                        }\r\n                        return results;\r\n                        //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n                    })(arguments, arguments.length - 1).map(function (x) {\r\n                return x.reduce(function (prev, curr) {\r\n                    return _.multiply(prev, curr.clone())\r\n                }, new Symbol(1))\r\n            });\r\n\r\n            var denom;\r\n            //don't eat the gcd term if all arguments are symbols\r\n            if(args.every(function (x) {\r\n                return core.Utils.isVariableSymbol(x)\r\n            }))\r\n                denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));\r\n            else\r\n                denom = __.gcd.apply(null, denom_args);\r\n            //divide product of all arguments by gcd of complementary terms\r\n            var div = _.divide(numer, denom);\r\n            return div;\r\n        },\r\n        /**\r\n         * Divides one expression by another\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Array}\r\n         */\r\n        divide: function (symbol1, symbol2) {\r\n            var result, remainder, factored, den;\r\n            factored = core.Algebra.Factor.factor(symbol1.clone());\r\n            den = factored.getDenom();\r\n            if(!den.isConstant('all')) {\r\n                symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\r\n            }\r\n            else\r\n                //reset the denominator since we're not dividing by it anymore\r\n                den = new Symbol(1);\r\n            result = __.div(symbol1, symbol2);\r\n            remainder = _.divide(result[1], symbol2);\r\n            return _.divide(_.add(result[0], remainder), den);\r\n        },\r\n        div: function (symbol1, symbol2) {\r\n            // If all else fails then assume that division failed with\r\n            // a remainder of zero and the original quotient\r\n            var fail = [new Symbol(0), symbol1.clone()];\r\n\r\n            try {\r\n\r\n                // Division by constants\r\n                if(symbol2.isConstant('all')) {\r\n                    symbol1.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(symbol2.multiplier);\r\n                    });\r\n                    return [symbol1, new Symbol(0)];\r\n                }\r\n                // So that factorized symbols don't affect the result\r\n                symbol1 = _.expand(symbol1);\r\n                symbol2 = _.expand(symbol2);\r\n                // Special case. May need revisiting\r\n                if(symbol1.group === S && symbol2.group === CP) {\r\n                    var x = symbol1.value;\r\n                    var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\r\n                    if(symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\r\n                        var k = Symbol.create(symbol1.multiplier);\r\n                        return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\r\n                    }\r\n                }\r\n                if(symbol1.group === S && symbol2.group === S) {\r\n                    var r = _.divide(symbol1.clone(), symbol2.clone());\r\n                    if(r.isConstant()) //we have a whole\r\n                        return [r, new Symbol(0)];\r\n                    return [new Symbol(0), symbol1.clone()];\r\n                }\r\n                var symbol1_has_func = symbol1.hasFunc(),\r\n                        symbol2_has_func = symbol2.hasFunc(),\r\n                        parse_funcs = false;\r\n\r\n                //substitute out functions so we can treat them as regular variables\r\n                if(symbol1_has_func || symbol2_has_func) {\r\n                    parse_funcs = true;\r\n                    var map = {},\r\n                            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\r\n                            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\r\n                            subs = core.Utils.getFunctionsSubs(map);\r\n                }\r\n                //get a list of the variables\r\n                var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\r\n                        quot, rem;\r\n\r\n                //treat imaginary numbers as variables\r\n                if(symbol1.isImaginary() || symbol2.isImaginary()) {\r\n                    vars.push(core.Settings.IMAGINARY);\r\n                }\r\n\r\n                if(vars.length === 1) {\r\n                    var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\r\n                    quot = q[0].toSymbol();\r\n                    rem = q[1].toSymbol();\r\n                }\r\n                else {\r\n                    vars.push(CONST_HASH); //this is for the numbers\r\n                    var reconvert = function (arr) {\r\n                        var symbol = new Symbol(0);\r\n                        for(var i = 0; i < arr.length; i++) {\r\n                            var x = arr[i].toSymbol();\r\n                            symbol = _.add(symbol, x);\r\n                        }\r\n                        return symbol;\r\n                    };\r\n\r\n                    // Silly Martin. This is why you document. I don't remember now\r\n                    var get_unique_max = function (term, any) {\r\n                        var max = Math.max.apply(null, term.terms),\r\n                                count = 0, idx;\r\n\r\n                        if(!any) {\r\n                            for(var i = 0; i < term.terms.length; i++) {\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    count++;\r\n                                }\r\n                                if(count > 1)\r\n                                    return;\r\n                            }\r\n                        }\r\n                        if(any) {\r\n                            for(i = 0; i < term.terms.length; i++)\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    break;\r\n                                }\r\n                        }\r\n                        return [max, idx, term];\r\n                    };\r\n\r\n                    // Tries to find an LT in the dividend that will satisfy division\r\n                    var get_det = function (s, lookat) {\r\n                        lookat = lookat || 0;\r\n                        var det = s[lookat], l = s.length;\r\n                        if(!det)\r\n                            return;\r\n                        //eliminate the first term if it doesn't apply\r\n                        var umax = get_unique_max(det);\r\n                        for(var i = lookat + 1; i < l; i++) {\r\n                            var term = s[i],\r\n                                    is_equal = det.sum.equals(term.sum);\r\n                            if(!is_equal && umax) {\r\n                                break;\r\n                            }\r\n                            if(is_equal) {\r\n                                // Check the differences of their maxes. The one with the biggest difference governs\r\n                                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\r\n                                var max1, max2, idx1, idx2, l2 = det.terms.length;\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var item1 = det.terms[j], item2 = term.terms[j];\r\n                                    if(typeof max1 === 'undefined' || item1.greaterThan(max1)) {\r\n                                        max1 = item1;\r\n                                        idx1 = j;\r\n                                    }\r\n                                    if(typeof max2 === 'undefined' || item2.greaterThan(max2)) {\r\n                                        max2 = item2;\r\n                                        idx2 = j;\r\n                                    }\r\n                                }\r\n                                //check their differences\r\n                                var d1 = max1.subtract(term.terms[idx1]),\r\n                                        d2 = max2.subtract(det.terms[idx2]);\r\n                                if(d2 > d1) {\r\n                                    umax = [max2, idx2, term];\r\n                                    break;\r\n                                }\r\n                                if(d1 > d2) {\r\n                                    umax = [max1, idx1, det];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                //check if it's a suitable pick to determine the order\r\n                                umax = get_unique_max(term);\r\n                                //if(umax) return umax;\r\n                                if(umax)\r\n                                    break;\r\n                            }\r\n                            umax = get_unique_max(term); //calculate a new unique max\r\n                        }\r\n\r\n                        //if still no umax then any will do since we have a tie\r\n                        if(!umax)\r\n                            return get_unique_max(s[0], true);\r\n                        var e, idx;\r\n                        for(var i = 0; i < s2.length; i++) {\r\n                            var cterm = s2[i].terms;\r\n                            //confirm that this is a good match for the denominator\r\n                            idx = umax[1];\r\n                            if(idx === cterm.length - 1)\r\n                                return;\r\n                            e = cterm[idx];\r\n                            if(!e.equals(0))\r\n                                break;\r\n                        }\r\n                        if(e.equals(0))\r\n                            return get_det(s, ++lookat); //look at the next term\r\n\r\n                        return umax;\r\n                    };\r\n\r\n                    var t_map = core.Utils.toMapObj(vars);\r\n                    var init_sort = function (a, b) {\r\n                        return b.sum.subtract(a.sum);\r\n                    };\r\n                    var is_larger = function (a, b) {\r\n                        if(!a || !b)\r\n                            return false; //it's empty so...\r\n                        for(var i = 0; i < a.terms.length; i++) {\r\n                            if(a.terms[i].lessThan(b.terms[i]))\r\n                                return false;\r\n                        }\r\n                        return true;\r\n                    };\r\n\r\n                    var s1 = symbol1.tBase(t_map).sort(init_sort),\r\n                            s2 = symbol2.tBase(t_map).sort(init_sort);\r\n                    var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\r\n                    var det = get_det(target);//we'll begin by assuming that this will let us know which term \r\n                    var quotient = [];\r\n                    if(det) {\r\n                        var lead_var = det[1];\r\n                        var can_divide = function (a, b) {\r\n                            if(a[0].sum.equals(b[0].sum))\r\n                                return a.length >= b.length;\r\n                            return true;\r\n                        };\r\n\r\n                        var try_better_lead_var = function (s1, s2, lead_var) {\r\n                            var checked = [];\r\n                            for(var i = 0; i < s1.length; i++) {\r\n                                var t = s1[i];\r\n                                for(var j = 0; j < t.terms.length; j++) {\r\n                                    var cf = checked[j], tt = t.terms[j];\r\n                                    if(i === 0)\r\n                                        checked[j] = tt; //add the terms for the first one\r\n                                    else if(cf && !cf.equals(tt))\r\n                                        checked[j] = undefined;\r\n                                }\r\n                            }\r\n                            for(var i = 0; i < checked.length; i++) {\r\n                                var t = checked[i];\r\n                                if(t && !t.equals(0))\r\n                                    return i;\r\n                            }\r\n                            return lead_var;\r\n                        };\r\n                        var sf = function (a, b) {\r\n                            var l1 = a.len(), l2 = b.len();\r\n                            var blv = b.terms[lead_var], alv = a.terms[lead_var];\r\n                            if(l2 > l1 && blv.greaterThan(alv))\r\n                                return l2 - l1;\r\n                            return blv.subtract(alv);\r\n                        };\r\n\r\n                        //check to see if there's a better lead_var\r\n                        lead_var = try_better_lead_var(s1, s2, lead_var);\r\n                        //reorder both according to the max power\r\n                        s1.sort(sf); //sort them both according to the leading variable power\r\n                        s2.sort(sf);\r\n\r\n                        //try to adjust if den is larger\r\n                        var fdt = s2[0], fnt = s1[0];\r\n\r\n                        var den = new MVTerm(new Frac(1), [], fnt.map);\r\n                        if(fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\r\n                            for(var i = 0; i < fnt.terms.length; i++) {\r\n                                var d = fdt.terms[i].subtract(fnt.terms[i]);\r\n                                if(!d.equals(0)) {\r\n                                    var nd = d.add(new Frac(1));\r\n                                    den.terms[i] = d;\r\n                                    for(var j = 0; j < s1.length; j++) {\r\n                                        s1[j].terms[i] = s1[j].terms[i].add(nd);\r\n                                    }\r\n                                }\r\n                                else\r\n                                    den.terms[i] = new Frac(0);\r\n                            }\r\n                        }\r\n\r\n                        var dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                        var safety = 0;\r\n                        var max = 200;\r\n\r\n                        while(dividend_larger && can_divide(s1, s2)) {\r\n                            if(safety++ > max) {\r\n                                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\r\n                            }\r\n\r\n                            var q = s1[0].divide(s2[0]);\r\n\r\n                            quotient.push(q); //add what's divided to the quotient\r\n                            s1.shift();//the first one is guaranteed to be gone so remove from dividend\r\n                            for(var i = 1; i < s2.length; i++) { //loop through the denominator\r\n                                var t = s2[i].multiply(q).generateImage(),\r\n                                        l2 = s1.length;\r\n                                //if we're subtracting from 0\r\n                                if(l2 === 0) {\r\n                                    t.coeff = t.coeff.neg();\r\n                                    s1.push(t);\r\n                                    s1.sort(sf);\r\n                                }\r\n\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var cur = s1[j];\r\n                                    if(cur.getImg() === t.getImg()) {\r\n                                        cur.coeff = cur.coeff.subtract(t.coeff);\r\n                                        if(cur.coeff.equals(0)) {\r\n                                            core.Utils.remove(s1, j);\r\n                                            j--; //adjust the iterator\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if(j === l2 - 1) {\r\n                                        t.coeff = t.coeff.neg();\r\n                                        s1.push(t);\r\n                                        s1.sort(sf);\r\n                                    }\r\n                                }\r\n                            }\r\n                            dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                            if(!dividend_larger && s1.length >= s2.length) {\r\n                                //One more try since there might be a terms that is larger than the LT of the divisor\r\n                                for(var i = 1; i < s1.length; i++) {\r\n                                    dividend_larger = is_larger(s1[i], s2[0]);\r\n                                    if(dividend_larger) {\r\n                                        //take it from its current position and move it to the front\r\n                                        s1.unshift(core.Utils.remove(s1, i));\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    quot = reconvert(quotient);\r\n                    rem = reconvert(s1);\r\n\r\n                    if(typeof den !== 'undefined') {\r\n                        den = den.toSymbol();\r\n                        quot = _.divide(quot, den.clone());\r\n                        rem = _.divide(rem, den);\r\n                    }\r\n                }\r\n\r\n                //put back the functions\r\n                if(parse_funcs) {\r\n                    quot = _.parse(quot.text(), subs);\r\n                    rem = _.parse(rem.text(), subs);\r\n                }\r\n\r\n                return [quot, rem];\r\n            }\r\n            catch(e) {\r\n                return fail;\r\n            }\r\n\r\n        },\r\n        line: function (v1, v2, x) {\r\n            if(core.Utils.isArray(v1))\r\n                v1 = core.Utils.convertToVector(v1);\r\n            if(core.Utils.isArray(v2))\r\n                v2 = core.Utils.convertToVector(v2);\r\n            x = _.parse(x || 'x');\r\n            if(!core.Utils.isVector(v1) || !core.Utils.isVector(v2))\r\n                _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\r\n            var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\r\n                    dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\r\n                    m = _.divide(dy, dx),\r\n                    a = _.multiply(x, m.clone()),\r\n                    b = _.multiply(v1.e(1).clone(), m);\r\n            return _.add(_.subtract(a, b), v1.e(2).clone());\r\n        },\r\n        PartFrac: {\r\n            createTemplate: function (den, denom_factors, f_array, v) {\r\n                //clean up the denominator function by factors so it reduces nicely\r\n                den = __.Factor.factor(den);\r\n\r\n                //clean up factors. This is so inefficient but factors are wrapped in parens for safety\r\n                den.each(function (x, key) {\r\n                    if(x.group === FN && x.fname === '' && x.args[0].group === S) {\r\n                        var y = x.args[0];\r\n                        if(this.symbols) {\r\n                            delete this.symbols[key];\r\n                            this.symbols[y.value] = y;\r\n                        }\r\n                        else {\r\n                            den = x.args[0];\r\n                        }\r\n                    }\r\n                });\r\n\r\n                var factors, factors_vec, f, p, deg, degrees, m;\r\n                factors = denom_factors.collectFactors();\r\n                factors_vec = []; //a vector for the template\r\n                degrees = [];\r\n                m = new Symbol(1);\r\n\r\n                for(var i = 0; i < factors.length; i++) { //loop through the factors\r\n                    var factor = Symbol.unwrapPARENS(factors[i]);\r\n                    //if in he for P^n where P is polynomial and n = integer\r\n                    if(factor.power.greaterThan(1)) {\r\n                        p = Number(factor.power);\r\n                        f = factor.clone().toLinear(); //remove the power so we have only the function\r\n                        deg = Number(__.degree(f, v)); //get the degree of f\r\n                        //expand the factor\r\n                        for(var j = 0; j < p; j++) {\r\n                            var efactor = _.pow(f.clone(), new Symbol(j + 1));\r\n                            f_array.push(efactor.clone());\r\n                            var d = _.divide(den.clone(), efactor.clone());\r\n                            degrees.push(deg);\r\n                            factors_vec.push(d);\r\n                        }\r\n                    }\r\n                    /*\r\n                     Possible bug.\r\n                     Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n                     else if(factor.isConstant('all')) {\r\n                     m = _.multiply(m, factor);\r\n                     }\r\n                     */\r\n                    else {\r\n                        //get the degree of the factor so we tack it on tot he factor. This should probably be an array\r\n                        //but for now we note it on the symbol\r\n                        deg = Number(__.degree(factor, v));\r\n                        f_array.push(factor);\r\n                        var d = _.divide(den.clone(), factor.clone());\r\n                        d = _.expand(Symbol.unwrapPARENS(d));\r\n                        degrees.push(deg);\r\n                        factors_vec.push(d);\r\n                    }\r\n                }\r\n                //put back the constant\r\n                f_array = f_array.map(function (x) {\r\n                    return _.multiply(x, m.clone());\r\n                });\r\n                return [f_array, factors_vec, degrees];\r\n            },\r\n            partfrac: function (symbol, v, as_array) {\r\n\r\n                var vars = variables(symbol);\r\n\r\n                v = v || _.parse(vars[0]); //make wrt optional and assume first variable\r\n                try {\r\n                    var num, den, factors, tfactors, ofactors, nterms, degrees,\r\n                            dterms, max, M, c, powers, div, r, factors_vec, ks,\r\n                            template, tfactors;\r\n                    num = _.expand(symbol.getNum());\r\n                    den = _.expand(symbol.getDenom().toUnitMultiplier());\r\n                    //move the entire multipier to the numerator\r\n                    num.multiplier = symbol.multiplier;\r\n                    //we only have a meaningful change if n factors > 1. This means that\r\n                    //the returned group will be a CB\r\n                    //collect the terms wrt the x\r\n                    nterms = num.groupTerms(v);\r\n                    //divide out wholes if top is larger\r\n                    if(Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\r\n                        div = __.div(num.clone(), _.expand(den.clone()));\r\n                        r = div[0]; //remove the wholes\r\n                        num = div[1]; //work with the remainder\r\n                        nterms = num.groupTerms(v); //recalculate the nterms\r\n                    }\r\n                    else\r\n                        r = new Symbol(0);\r\n\r\n                    if(Number(__.degree(den, v)) === 1) {\r\n                        var q = _.divide(num, den);\r\n                        if(as_array)\r\n                            return [r, q];\r\n                        return _.add(r, q);\r\n                    }\r\n                    //first factor the denominator. This means that the strength of this\r\n                    //algorithm depends on how well we can factor the denominator. \r\n                    ofactors = __.Factor.factor(den);\r\n                    //create the template. This method will create the template for solving \r\n                    //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\r\n                    template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\r\n                    tfactors = template[0]; //grab the factors\r\n                    factors_vec = template[1]; //grab the factor vectors\r\n                    degrees = template[2]; //grab the degrees\r\n                    //make note of the powers of each term\r\n                    powers = [nterms.length];\r\n                    //create the dterms vector\r\n                    dterms = [];\r\n                    factors = [];\r\n                    ks = [];\r\n                    var factor, deg;\r\n                    factors_vec.map(function (x, idx) {\r\n                        factor = tfactors[idx];\r\n                        deg = degrees[idx];\r\n                        for(var i = 0; i < deg; i++) {\r\n                            factors.push(factor.clone());\r\n                            var k = Symbol.create(v, i);\r\n                            var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\r\n                            //make a note of the power which corresponds to the length of the array\r\n                            var p = t.length;\r\n                            powers.push(p);\r\n                            dterms.push(t);\r\n                            ks.push(k.clone());\r\n                        }\r\n                    });\r\n                    //get the max power\r\n                    max = core.Utils.arrayMax(powers);\r\n\r\n                    //fill the holes and create a matrix\r\n                    c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\r\n                    //for each of the factors we do the same\r\n                    M = new core.Matrix();\r\n                    for(var i = 0; i < dterms.length; i++) {\r\n                        M.elements.push(core.Utils.fillHoles(dterms[i], max));\r\n                    }\r\n\r\n                    //solve the system of equations\r\n                    var partials = _.multiply(M.transpose().invert(), c);\r\n                    //the results are backwards to reverse it\r\n                    //partials.elements.reverse();\r\n                    //convert it all back\r\n                    var retval = as_array ? [r] : r;\r\n                    partials.each(function (e, i) {\r\n                        var term = _.multiply(ks[i], _.divide(e, factors[i]));\r\n                        if(as_array)\r\n                            retval.push(term);\r\n                        else\r\n                            retval = _.add(retval, term);\r\n                    });\r\n\r\n                    //done\r\n                    return retval;\r\n                }\r\n                catch(e) {\r\n                    //try to group symbols\r\n                    try {\r\n                        if(symbol.isComposite()) {\r\n                            //group denominators\r\n                            var denominators = {};\r\n\r\n                            symbol.each(function (x) {\r\n                                var d = x.getDenom();\r\n                                var n = x.getNum();\r\n                                var e = denominators[d];\r\n                                denominators[d] = e ? _.add(e, n) : n;\r\n                            });\r\n\r\n                            var t = new Symbol(0);\r\n\r\n                            for(var x in denominators) {\r\n                                t = _.add(t, _.divide(denominators[x], _.parse(x)));\r\n                            }\r\n\r\n                            symbol = t;\r\n                        }\r\n                    }\r\n                    catch(e2) {\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        degree: function (symbol, v, o) {\r\n            o = o || {\r\n                nd: [], //numeric\r\n                sd: [], //symbolic\r\n                depth: 0 //call depth\r\n            };\r\n\r\n            if(!v) {\r\n                var vars = variables(symbol);\r\n                //The user must specify the variable for multivariate\r\n                if(vars.length > 1)\r\n                    throw new Error('You must specify the variable for multivariate polynomials!');\r\n                //if it's empty then we're dealing with a constant\r\n                if(vars.length === 0)\r\n                    return new Symbol(0);\r\n                //assume the variable for univariate\r\n                v = _.parse(vars[0]);\r\n            }\r\n\r\n            //store the group\r\n            var g = symbol.group;\r\n            //we're going to trust the user and assume no EX. Calling isPoly \r\n            //would eliminate this but no sense in checking twice. \r\n            if(symbol.isComposite()) {\r\n                symbol = symbol.clone();\r\n                symbol.distributeExponent();\r\n                symbol.each(function (x) {\r\n                    o.depth++; //mark a depth increase\r\n                    __.degree(x, v, o);\r\n                    o.depth--; //we're back\r\n                });\r\n            }\r\n            else if(symbol.group === CB) {\r\n                symbol.each(function (x) {\r\n                    o.depth++;\r\n                    __.degree(x, v, o);\r\n                    o.depth++;\r\n                });\r\n            }\r\n            else if(g === EX && symbol.value === v.value) {\r\n                o.sd.push(symbol.power.clone());\r\n            }\r\n            else if(g === S && symbol.value === v.value) {\r\n                o.nd.push(_.parse(symbol.power));\r\n            }\r\n            else\r\n                o.nd.push(new Symbol(0));\r\n\r\n            //get the max out of the array\r\n            var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\r\n\r\n            if(o.depth === 0 && o.sd.length > 0) {\r\n                if(deg !== undefined)\r\n                    o.sd.unshift(deg);\r\n                return _.symfunction('max', o.sd);\r\n            }\r\n            if(!core.Utils.isSymbol(deg))\r\n                deg = _.parse(deg);\r\n            //return the degree\r\n            return deg;\r\n        },\r\n        /**\r\n         * Attempts to complete the square of a polynomial\r\n         * @param {type} symbol\r\n         * @param {type} v\r\n         * @param {type} raw\r\n         * @throws {Error} \r\n         * @returns {Object|Symbol[]}\r\n         */\r\n        sqComplete: function (symbol, v, raw) {\r\n            if(!core.Utils.isSymbol(v))\r\n                v = _.parse(v);\r\n            var stop = function (msg) {\r\n                msg = msg || 'Stopping';\r\n                throw new core.exceptions.ValueLimitExceededError(msg);\r\n            };\r\n            //if not CP then nothing to do\r\n            if(!symbol.isPoly(true))\r\n                stop('Must be a polynomial!');\r\n\r\n            //declare vars\r\n            var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\r\n\r\n            br = core.Utils.inBrackets;\r\n            //make a copy\r\n            symbol = symbol.clone();\r\n            deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\r\n            //must be in form ax^2 +/- bx +/- c\r\n            if(!deg.equals(2))\r\n                stop('Cannot complete square for degree ' + deg);\r\n            //get the coeffs\r\n            coeffs = core.Algebra.coeffs(symbol, v);\r\n            a = coeffs[2];\r\n            //store the sign\r\n            sign = coeffs[1].sign();\r\n            //divide the linear term by two and square it\r\n            b = _.divide(coeffs[1], new Symbol(2));\r\n            //add the difference to the constant\r\n            c = _.pow(b.clone(), new Symbol(2));\r\n            if(raw)\r\n                return [a, b, d];\r\n            sqrt_a = math.sqrt(a);\r\n            e = _.divide(math.sqrt(c), sqrt_a.clone());\r\n            //calculate d which is the constant\r\n            d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\r\n            //compute the square part\r\n            sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\r\n            return {\r\n                a: sym,\r\n                c: d,\r\n                f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\r\n            };\r\n        },\r\n        Simplify: {\r\n            strip: function (symbol) {\r\n                var c = _.parse(symbol.multiplier);\r\n                symbol.toUnitMultiplier();\r\n                var p = _.parse(symbol.power);\r\n                symbol.toLinear();\r\n                return [c, p, symbol];\r\n            },\r\n            unstrip: function (cp, symbol) {\r\n                var c = cp[0];\r\n                var p = cp[1];\r\n                return _.multiply(c, _.pow(symbol, p));\r\n            },\r\n            complexSimp: function (num, den) {\r\n                var ac, bd, bc, ad, cd, r1, r2, i1, i2;\r\n                r1 = num.realpart();\r\n                i1 = num.imagpart();\r\n                r2 = den.realpart();\r\n                i2 = den.imagpart();\r\n                //apply complex arithmatic rule\r\n                ac = _.multiply(r1.clone(), r2.clone());\r\n                bd = _.multiply(i1.clone(), i2.clone());\r\n                bc = _.multiply(r2.clone(), i1);\r\n                ad = _.multiply(r1, i2.clone());\r\n                cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\r\n\r\n                return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\r\n            },\r\n            trigSimp: function (symbol) {\r\n                if(symbol.containsFunction(['cos', 'sin', 'tan'])) {\r\n                    symbol = symbol.clone();\r\n                    //remove power and multiplier\r\n                    var sym_array = __.Simplify.strip(symbol);\r\n                    symbol = sym_array.pop();\r\n                    //the default return value is the symbol\r\n                    var retval = symbol.clone();\r\n\r\n                    //rewrite the symbol\r\n                    if(symbol.group === CP) {\r\n                        var sym = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            //rewrite the function\r\n                            var tr = __.Simplify.trigSimp(x.fnTransform());\r\n                            sym = _.add(sym, tr);\r\n                        }, true);\r\n\r\n                        //put back the power and multiplier and return\r\n                        retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\r\n                    }\r\n                    else if(symbol.group === CB) {\r\n\r\n                        var n = symbol.getNum();\r\n                        var d = symbol.getDenom();\r\n\r\n                        //try for tangent\r\n                        if(n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\r\n                            retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\r\n                        }\r\n                        if(retval.group === CB) {\r\n                            var t = new Symbol(1);\r\n                            retval.each(function (x) {\r\n                                if(x.fname === 'tan') {\r\n                                    x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\r\n                                }\r\n                                t = _.multiply(t, x);\r\n                            });\r\n                            retval = t;\r\n                        }\r\n                    }\r\n\r\n\r\n                    retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\r\n\r\n                    symbol = retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            fracSimp: function (symbol) {\r\n                //try a quick simplify of imaginary numbers\r\n                var den = symbol.getDenom();\r\n                var num = symbol.getNum();\r\n\r\n                if(num.isImaginary() && den.isImaginary())\r\n                    symbol = __.Simplify.complexSimp(num, den);\r\n\r\n                if(symbol.isComposite()) {\r\n                    if(symbol.power > 1) {\r\n                        symbol = _.expand(symbol);\r\n                    }\r\n\r\n                    var symbols = symbol.collectSymbols();\r\n                    //assumption 1.\r\n                    //since it's a composite, it has a length of at least 1\r\n                    var retval, a, b, d1, d2, n1, n2, x, y, c, den, num;\r\n                    a = symbols.pop(); //grab the first symbol\r\n                    //loop through each term and make denominator common\r\n                    while(symbols.length) {\r\n                        b = symbols.pop(); //grab the second symbol\r\n                        d1 = _.parse(a.getDenom());\r\n                        d2 = _.parse(b.getDenom());\r\n                        n1 = a.getNum();\r\n                        n2 = b.getNum();\r\n                        c = _.multiply(d1.clone(), d2.clone());\r\n                        x = _.multiply(n1, d2);\r\n                        y = _.multiply(n2, d1);\r\n                        a = _.divide(_.add(x, y), c);\r\n                    }\r\n                    den = _.expand(a.getDenom());\r\n                    num = _.expand(a.getNum());\r\n\r\n                    //simplify imaginary\r\n                    if(num.isImaginary() && den.isImaginary()) {\r\n                        retval = __.Simplify.complexSimp(num, den);\r\n                    }\r\n                    else {\r\n                        retval = _.divide(num, den);\r\n                    }\r\n\r\n                    //we've already hit the simplest form so return that\r\n                    if(retval.equals(symbol)) {\r\n                        return symbol;\r\n                    }\r\n\r\n                    //otherwise simplify it some more\r\n                    return __.Simplify.simplify(retval);\r\n                }\r\n                return symbol;\r\n            },\r\n            ratSimp: function (symbol) {\r\n                if(symbol.group === CB) {\r\n                    var den = symbol.getDenom();\r\n                    var num = symbol.getNum().distributeMultiplier();\r\n                    var d = __.Simplify.fracSimp(den);\r\n                    var n = __.Simplify.fracSimp(num);\r\n                    symbol = _.divide(n, d);\r\n                }\r\n                return symbol;\r\n            },\r\n            sqrtSimp: function (symbol, sym_array) {\r\n                var retval;\r\n                if(symbol.isSQRT()) {\r\n                    var factored = __.Factor.factor(symbol.args[0].clone());\r\n                    var m = _.parse(factored.multiplier);\r\n                    var sign = m.sign();\r\n\r\n                    var retval = _.sqrt(m.abs());\r\n                    var arg;\r\n\r\n                    if(isInt(retval)) {\r\n\r\n                        if(factored.group === CB) {\r\n                            var rem = new Symbol(1);\r\n\r\n                            factored.each(function (x) {\r\n                                if(x.group === N) {\r\n                                    var trial = _.sqrt(x.clone());\r\n\r\n                                    // Multiply back sqrt if it's an integer otherwise just put back the number\r\n                                    if(isInt(trial)) {\r\n                                        retval = _.multiply(retval, trial);\r\n                                    }\r\n                                    else {\r\n                                        rem = _.multiply(rem, x);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    rem = _.multiply(rem, x);\r\n                                }\r\n\r\n                            });\r\n                            var t = _.multiply(rem, _.parse(sign));\r\n                            arg = _.sqrt(t.clone());\r\n\r\n                            // Expand if it's imaginary\r\n                            if(arg.isImaginary) {\r\n                                arg = _.sqrt(_.expand(t.clone()));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Strip the multiplier\r\n                            arg = _.sqrt(factored.clone().toUnitMultiplier());\r\n                        }\r\n                        return _.multiply(retval, arg);\r\n\r\n                    }\r\n\r\n                }\r\n                else if(symbol.isComposite() && symbol.isLinear()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.Simplify.sqrtSimp(x));\r\n                    }, true);\r\n                    // Put back the multiplier\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    retval = _.parse(symbol.multiplier);\r\n                    symbol.each(function (x) {\r\n                        var simp = __.Simplify.sqrtSimp(x);\r\n                        retval = _.multiply(retval, simp);\r\n\r\n                    }, true);\r\n                    // Put back the power\r\n                    retval = _.pow(retval, _.parse(symbol.power));\r\n                }\r\n\r\n                return retval ? retval : _.parse(symbol);\r\n            },\r\n            /**\r\n             * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n             * @param {Symbol} symbol\r\n             * @return {Array} The symbol and the matched patterns\r\n             */\r\n            patternSub: function (symbol) {\r\n                var patterns = {};\r\n\r\n                var has_CP = function (symbol) {\r\n                    var found = false;\r\n                    symbol.each(function (x) {\r\n                        if(x.group === CP) {\r\n                            found = true;\r\n                        }\r\n                        else if(x.symbols) {\r\n                            found = has_CP(x);\r\n                        }\r\n                    });\r\n\r\n                    return found;\r\n                };\r\n\r\n                var collect = function (sym) {\r\n                    // We loop through each symbol looking for anything in the simplest\r\n                    // form of ax+byz+...\r\n                    sym.each(function (x) {\r\n                        // Items of group N,P,S, need to apply\r\n                        if(!x.symbols && x.group !== FN) {\r\n                            return;\r\n                        }\r\n\r\n                        // Check to see if it has any symbols of group CP\r\n                        // Get the patterns in that symbol instead if it has anything of group CP\r\n                        if(has_CP(x)) {\r\n                            collect(x);\r\n                        }\r\n                        else {\r\n                            if(!patterns[x.value]) {\r\n                                var u = core.Utils.getU(symbol);\r\n                                // Get a u value and mark it for subsitution\r\n                                patterns[x.value] = u;\r\n                                symbol = symbol.sub(x.value, u);\r\n                            }\r\n                        }\r\n                    }, true);\r\n                };\r\n\r\n                // Collect a list of patterns\r\n                collect(symbol);\r\n\r\n                return [symbol, patterns];\r\n            },\r\n            simplify: function (symbol) {\r\n                //remove the multiplier to make calculation easier;\r\n                var sym_array = __.Simplify.strip(symbol);\r\n                symbol = sym_array.pop();\r\n                //remove gcd from denominator\r\n                symbol = __.Simplify.fracSimp(symbol);\r\n\r\n                //nothing more to do\r\n                if(symbol.isConstant() || symbol.group === core.groups.S) {\r\n                    sym_array.push(symbol);\r\n                    var ret = __.Simplify.unstrip(sym_array, symbol);\r\n                    return ret;\r\n                }\r\n\r\n                //var patterns;\r\n\r\n                var simplified = symbol.clone(); //make a copy\r\n\r\n                //[simplified, patterns] = __.Simplify.patternSub(symbol);\r\n\r\n                // Simplify sqrt within the symbol\r\n//                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\r\n\r\n                // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\r\n                simplified = __.Simplify.trigSimp(simplified);\r\n\r\n                // Simplify common denominators\r\n                simplified = __.Simplify.ratSimp(simplified);\r\n\r\n                // First go for the \"cheapest\" simplification which may eliminate \r\n                // your problems right away. factor -> evaluate. Remember\r\n                // that there's no need to expand since factor already does that\r\n\r\n                simplified = __.Factor.factor(simplified);\r\n\r\n                //If the simplfied is a sum then we can make a few more simplifications\r\n                //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\r\n                if(simplified.group === core.groups.CP && simplified.isLinear()) {\r\n                    var m = simplified.multiplier.clone();\r\n                    simplified.toUnitMultiplier(); //strip the multiplier\r\n                    var r = new Symbol(0);\r\n                    //return the sum of simplifications\r\n                    simplified.each(function (x) {\r\n                        var s = __.Simplify.simplify(x);\r\n                        r = _.add(r, s);\r\n                    });\r\n                    simplified = r;\r\n                    //put back the multiplier\r\n                    r.multiplier = r.multiplier.multiply(m);\r\n                }\r\n\r\n                //place back multiplier and return\r\n                var retval = __.Simplify.unstrip(sym_array, simplified);\r\n\r\n                // Back substitute\r\n                /*\r\n                 for(var x in patterns) {\r\n                 retval = retval.sub(patterns[x], x);\r\n                 }\r\n                 */\r\n\r\n                return retval;\r\n            }\r\n        },\r\n\r\n        Classes: {\r\n            Polynomial: Polynomial,\r\n            Factors: Factors,\r\n            MVTerm: MVTerm\r\n        }\r\n    };\r\n\r\n    // Add a link to simplify\r\n    core.Expression.prototype.simplify = function () {\r\n        return __.Simplify.simplify(this.symbol);\r\n    };\r\n\r\n    nerdamer.useAlgebraDiv = function () {\r\n        var divide = __.divideFn = _.divide;\r\n        var calls = 0; //keep track of how many calls were made\r\n        _.divide = function (a, b) {\r\n            calls++;\r\n            var ans;\r\n            if(calls === 1) //check if this is the first call. If it is use algebra divide\r\n                ans = core.Algebra.divide(a, b);\r\n            else //otherwise use parser divide\r\n                ans = divide(a, b);\r\n            calls = 0; //reset the number of calls back to none\r\n            return ans;\r\n        };\r\n    };\r\n\r\n    nerdamer.useParserDiv = function () {\r\n        if(__.divideFn)\r\n            _.divide = __.divideFn;\r\n        delete __.divideFn;\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'factor',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Factor.factor;\r\n            }\r\n        },\r\n        {\r\n            name: 'simplify',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Simplify.simplify;\r\n            }\r\n        },\r\n        {\r\n            name: 'gcd',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.gcd;\r\n            }\r\n        },\r\n        {\r\n            name: 'lcm',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.lcm;\r\n            }\r\n        },\r\n        {\r\n            name: 'roots',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.roots;\r\n            }\r\n        },\r\n        {\r\n            name: 'divide',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.divide;\r\n            }\r\n        },\r\n        {\r\n            name: 'div',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.div;\r\n            }\r\n        },\r\n        {\r\n            name: 'partfrac',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.PartFrac.partfrac;\r\n            }\r\n        },\r\n        {\r\n            name: 'deg',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.degree;\r\n            }\r\n        },\r\n        {\r\n            name: 'coeffs',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function () {\r\n                    var coeffs = __.coeffs.apply(__, arguments);\r\n                    return new core.Vector(coeffs);\r\n                };\r\n                return f;\r\n            }\r\n        },\r\n        {\r\n            name: 'line',\r\n            visible: true,\r\n            numargs: [2, 3],\r\n            build: function () {\r\n                return __.line;\r\n            }\r\n        },\r\n        {\r\n            name: 'sqcomp',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function (x, v) {\r\n                    try {\r\n                        v = v || variables(x)[0];\r\n                        var sq = __.sqComplete(x.clone(), v);\r\n                        return sq.f;\r\n                    }\r\n                    catch(e) {\r\n                        return x;\r\n                    }\r\n                };\r\n                return f;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.api();\r\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmVyZGFtZXIvQWxnZWJyYS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmFuaWxsYS1pbnRlZ3JhdGlvbi0yZC8uL25vZGVfbW9kdWxlcy9uZXJkYW1lci9BbGdlYnJhLmpzP2FlYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQXV0aG9yIDogTWFydGluIERvbmtcclxuICogV2Vic2l0ZSA6IGh0dHA6Ly93d3cubmVyZGFtZXIuY29tXHJcbiAqIEVtYWlsIDogbWFydGluLnIuZG9ua0BnbWFpbC5jb21cclxuICogTGljZW5zZSA6IE1JVFxyXG4gKiBTb3VyY2UgOiBodHRwczovL2dpdGh1Yi5jb20vamlnZ3pzb24vbmVyZGFtZXJcclxuICovXHJcblxyXG4vKiBnbG9iYWwgbW9kdWxlLCBGdW5jdGlvbiAqL1xyXG5cclxuaWYoKHR5cGVvZiBtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdmFyIG5lcmRhbWVyID0gcmVxdWlyZSgnLi9uZXJkYW1lci5jb3JlLmpzJyk7XHJcbiAgICByZXF1aXJlKCcuL0NhbGN1bHVzLmpzJyk7XHJcbn1cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKnNob3J0Y3V0cyovXHJcbiAgICB2YXIgY29yZSA9IG5lcmRhbWVyLmdldENvcmUoKSxcclxuICAgICAgICAgICAgXyA9IGNvcmUuUEFSU0VSLFxyXG4gICAgICAgICAgICBOID0gY29yZS5ncm91cHMuTixcclxuICAgICAgICAgICAgUCA9IGNvcmUuZ3JvdXBzLlAsXHJcbiAgICAgICAgICAgIFMgPSBjb3JlLmdyb3Vwcy5TLFxyXG4gICAgICAgICAgICBFWCA9IGNvcmUuZ3JvdXBzLkVYLFxyXG4gICAgICAgICAgICBGTiA9IGNvcmUuZ3JvdXBzLkZOLFxyXG4gICAgICAgICAgICBQTCA9IGNvcmUuZ3JvdXBzLlBMLFxyXG4gICAgICAgICAgICBDUCA9IGNvcmUuZ3JvdXBzLkNQLFxyXG4gICAgICAgICAgICBDQiA9IGNvcmUuZ3JvdXBzLkNCLFxyXG4gICAgICAgICAgICBrZXlzID0gY29yZS5VdGlscy5rZXlzLFxyXG4gICAgICAgICAgICBldmVuID0gY29yZS5VdGlscy5ldmVuLFxyXG4gICAgICAgICAgICB2YXJpYWJsZXMgPSBjb3JlLlV0aWxzLnZhcmlhYmxlcyxcclxuICAgICAgICAgICAgZm9ybWF0ID0gY29yZS5VdGlscy5mb3JtYXQsXHJcbiAgICAgICAgICAgIHJvdW5kID0gY29yZS5VdGlscy5yb3VuZCxcclxuICAgICAgICAgICAgRnJhYyA9IGNvcmUuRnJhYyxcclxuICAgICAgICAgICAgaXNJbnQgPSBjb3JlLlV0aWxzLmlzSW50LFxyXG4gICAgICAgICAgICBTeW1ib2wgPSBjb3JlLlN5bWJvbCxcclxuICAgICAgICAgICAgQ09OU1RfSEFTSCA9IGNvcmUuU2V0dGluZ3MuQ09OU1RfSEFTSCxcclxuICAgICAgICAgICAgbWF0aCA9IGNvcmUuVXRpbHMuaW1wb3J0RnVuY3Rpb25zKCksXHJcbiAgICAgICAgICAgIGV2YWx1YXRlID0gY29yZS5VdGlscy5ldmFsdWF0ZTtcclxuICAgIC8vKioqKioqKioqKioqKioqIENMQVNTRVMgKioqKioqKioqKioqKioqLy9cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYSBzeW1ib2wgaW50byBhbiBlcXVpdmFsZW50IHBvbHlub21pYWwgYXJyYXlzIG9mIFxyXG4gICAgICogdGhlIGZvcm0gW1tjb2VmZmljaWVudF8xLCBwb3dlcl8xXSxbY29lZmZpY2llbnRfMiwgcG93ZXJfMl0sIC4uLiBdXHJcbiAgICAgKiBVbml2YXJpYXRlIHBvbHltaWFscyBvbmx5LiBcclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfE51bWJlcn0gc3ltYm9sXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFyaWFibGUgVGhlIHZhcmlhYmxlIG5hbWUgb2YgdGhlIHBvbHlub21pYWxcclxuICAgICAqIEBwYXJhbSB7aW50fSBvcmRlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBQb2x5bm9taWFsKHN5bWJvbCwgdmFyaWFibGUsIG9yZGVyKSB7XHJcbiAgICAgICAgaWYoY29yZS5VdGlscy5pc1N5bWJvbChzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2Uoc3ltYm9sKTtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZSA9IHRoaXMudmFyaWFibGUgfHwgdmFyaWFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoIWlzTmFOKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgb3JkZXIgPSBvcmRlciB8fCAwO1xyXG4gICAgICAgICAgICBpZih2YXJpYWJsZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5JbnZhbGlkVmFyaWFibGVOYW1lRXJyb3IoJ1BvbHlub21pYWwgZXhwZWN0cyBhIHZhcmlhYmxlIG5hbWUgd2hlbiBjcmVhdGluZyB1c2luZyBvcmRlcicpO1xyXG4gICAgICAgICAgICB0aGlzLmNvZWZmcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmNvZWZmc1tvcmRlcl0gPSBzeW1ib2w7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbChzeW1ib2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHR5cGVvZiBzeW1ib2wgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyc2UoXy5wYXJzZShzeW1ib2wpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBQb2x5bm9taWFsIGdpdmVuIGFuIGFycmF5IG9mIGNvZWZmaWNpZW50c1xyXG4gICAgICogQHBhcmFtIHtpbnRbXX0gYXJyXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFyaWFibGVcclxuICAgICAqIEByZXR1cm5zIHtQb2x5bm9taWFsfVxyXG4gICAgICovXHJcbiAgICBQb2x5bm9taWFsLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhcnIsIHZhcmlhYmxlKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIHZhcmlhYmxlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5JbnZhbGlkVmFyaWFibGVOYW1lRXJyb3IoJ0EgdmFyaWFibGUgbmFtZSBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIGNyZWF0aW5nIHBvbHlub21pYWwgZnJvbSBhcnJheScpO1xyXG4gICAgICAgIHZhciBwID0gbmV3IFBvbHlub21pYWwoKTtcclxuICAgICAgICBwLmNvZWZmcyA9IGFycjtcclxuICAgICAgICBwLnZhcmlhYmxlID0gdmFyaWFibGU7XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9O1xyXG5cclxuICAgIFBvbHlub21pYWwuZml0ID0gZnVuY3Rpb24gKGMxLCBjMiwgbiwgYmFzZSwgcCwgdmFyaWFibGUpIHtcclxuICAgICAgICAvL2FmdGVyIGhhdmluZyBsb29wZWQgdGhyb3VnaCBhbmQgbW9kIDEwIHRoZSBudW1iZXIgdG8gZ2V0IHRoZSBtYXRjaGluZyBmYWN0b3JcclxuICAgICAgICB2YXIgdGVybXMgPSBuZXcgQXJyYXkocCArIDEpLFxyXG4gICAgICAgICAgICAgICAgdCA9IG4gLSBjMjtcclxuICAgICAgICB0ZXJtc1swXSA9IGMyOyAvL3RoZSBjb25zdGFudHMgaXMgYXNzdW1lZCB0byBiZSBjb3JyZWN0XHJcbiAgICAgICAgLy9jb25zdGFudCBmb3IgeF5wIGlzIGFsc28gYXNzdW1lZCBrbm93IHNvIGFkZFxyXG4gICAgICAgIHRlcm1zW3BdID0gYzE7XHJcbiAgICAgICAgdCAtPSBjMSAqIE1hdGgucG93KGJhc2UsIHApO1xyXG4gICAgICAgIC8vc3RhcnQgZml0dGluZ1xyXG4gICAgICAgIGZvcih2YXIgaSA9IHAgLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gTWF0aC5wb3coYmFzZSwgaSksIC8vd2Ugd2FudCBhcyBtYW55IHdob2xlcyBhcyBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIHEgPSB0IC8gYixcclxuICAgICAgICAgICAgICAgICAgICBzaWduID0gTWF0aC5zaWduKHEpO1xyXG4gICAgICAgICAgICB2YXIgYyA9IHNpZ24gKiBNYXRoLmZsb29yKE1hdGguYWJzKHEpKTtcclxuICAgICAgICAgICAgdCAtPSBjICogYjtcclxuICAgICAgICAgICAgdGVybXNbaV0gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0ICE9PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGVybXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIHRlcm1zW2ldID0gbmV3IEZyYWModGVybXNbaV0pO1xyXG5cclxuICAgICAgICByZXR1cm4gUG9seW5vbWlhbC5mcm9tQXJyYXkodGVybXMsIHZhcmlhYmxlKTtcclxuICAgIH07XHJcblxyXG4gICAgUG9seW5vbWlhbC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgU3ltYm9sIHRvIFBvbHlub21pYWxcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYyAtIGEgY29sbGVjdG9yIGFycmF5XHJcbiAgICAgICAgICogQHJldHVybnMge1BvbHlub21pYWx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChzeW1ib2wsIGMpIHtcclxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlcyhzeW1ib2wpWzBdO1xyXG4gICAgICAgICAgICBpZighc3ltYm9sLmlzUG9seSgpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgY29yZS5leGNlcHRpb25zLk5lcmRhbWVyVHlwZUVycm9yKCdQb2x5bm9taWFsIEV4cGVjdGVkISBSZWNlaXZlZCAnICsgY29yZS5VdGlscy50ZXh0KHN5bWJvbCkpO1xyXG4gICAgICAgICAgICBjID0gYyB8fCBbXTtcclxuICAgICAgICAgICAgaWYoIXN5bWJvbC5wb3dlci5hYnNFcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBjb3JlLmdyb3Vwcy5OKSB7XHJcbiAgICAgICAgICAgICAgICBjWzBdID0gc3ltYm9sLm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLlMpIHtcclxuICAgICAgICAgICAgICAgIGNbc3ltYm9sLnBvd2VyLnRvRGVjaW1hbCgpXSA9IHN5bWJvbC5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHN5bWJvbC5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YiA9IHN5bWJvbC5zeW1ib2xzW3hdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHN1Yi5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmlzU3ltYm9sKHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5leGNlcHRpb25zLk5lcmRhbWVyVHlwZUVycm9yKCdwb3dlciBjYW5ub3QgYmUgYSBTeW1ib2wnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHN1Yi5ncm91cCA9PT0gTiA/IDAgOiBwLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN1Yi5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uoc3ViLCBjKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNbcF0gPSBzdWIubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuY29lZmZzID0gYztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZmlsbCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlsbHMgaW4gdGhlIGhvbGVzIGluIGEgcG9seW5vbWlhbCB3aXRoIHplcm9lc1xyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIG51bWJlciB0byBmaWxsIHRoZSBob2xlcyB3aXRoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZmlsbDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgeCA9IE51bWJlcih4KSB8fCAwO1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb2VmZnNbaV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZzW2ldID0gbmV3IEZyYWMoeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGhpZ2hlciBvcmRlciB6ZXJvcyBvciBhIHNwZWNpZmljIGNvZWZmaWNpZW50XHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRyaW06IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmNvZWZmcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlKGwtLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNvZWZmc1tsXTtcclxuICAgICAgICAgICAgICAgIHZhciBlcXVhbHNaZXJvID0gYy5lcXVhbHMoMCk7XHJcbiAgICAgICAgICAgICAgICBpZihjICYmIGVxdWFsc1plcm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybnMgcG9seW5vbWlhbCBtb2QgcCAqKmN1cnJlbnRseSBmYWlscyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBcclxuICAgICAgICAgKiBAcmV0dXJucyB7UG9seW5vbWlhbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBtb2RQOiBmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICB2YXIgbCA9IHRoaXMuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0aGlzLmNvZWZmc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKGMgPCAwKSB7IC8vZ28gYm9ycm93XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGI7IC8vYSBjb2VmZmljaWVudCA+IDBcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSBpOyBqIDwgbDsgaisrKSB7Ly9zdGFydGluZyBmcm9tIHdoZXJlIHdlIGxlZnQgb2ZmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29lZmZzW2pdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuY29lZmZzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGIpIHsgLy9pZiBzdWNoIGEgY29lZmZpY2llbnQgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqOyBqID4gaTsgai0tKSB7IC8vZ28gZG93biB0aGUgbGluZSBhbmQgYWRqdXN0IHVzaW5nIHBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29lZmZzW2pdID0gdGhpcy5jb2VmZnNbal0uc3VidHJhY3QobmV3IEZyYWMoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmZnNbaiAtIDFdID0gdGhpcy5jb2VmZnNbaiAtIDFdLmFkZChuZXcgRnJhYyhwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuY29lZmZzW2ldOyAvL3Jlc2V0IGNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBjLm1vZChwKTtcclxuICAgICAgICAgICAgICAgIHZhciB3ID0gYy5zdWJ0cmFjdChkKS5kaXZpZGUocCk7XHJcbiAgICAgICAgICAgICAgICBpZighdy5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBfb25lID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmNvZWZmc1t1cF9vbmVdIHx8IG5ldyBGcmFjKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0LmFkZCh3KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvZWZmc1t1cF9vbmVdID0gbmV3IEZyYWMobmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2VmZnNbaV0gPSBuZXcgRnJhYyhkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIHRvZ2V0aGVyIDIgcG9seW5vbWlhbHNcclxuICAgICAgICAgKiBAcGFyYW0ge1BvbHlub21pYWx9IHBvbHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChwb2x5KSB7XHJcbiAgICAgICAgICAgIHZhciBsID0gTWF0aC5tYXgodGhpcy5jb2VmZnMubGVuZ3RoLCBwb2x5LmNvZWZmcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9ICh0aGlzLmNvZWZmc1tpXSB8fCBuZXcgRnJhYygwKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSAocG9seS5jb2VmZnNbaV0gfHwgbmV3IEZyYWMoMCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2VmZnNbaV0gPSBhLmFkZChiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgdG9nZXRoZXIgMiBwb2x5bm9taWFsc1xyXG4gICAgICAgICAqIEBwYXJhbSB7UG9seW5vbWlhbH0gcG9seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAocG9seSkge1xyXG4gICAgICAgICAgICB2YXIgbCA9IE1hdGgubWF4KHRoaXMuY29lZmZzLmxlbmd0aCwgcG9seS5jb2VmZnMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSAodGhpcy5jb2VmZnNbaV0gfHwgbmV3IEZyYWMoMCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gKHBvbHkuY29lZmZzW2ldIHx8IG5ldyBGcmFjKDApKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZzW2ldID0gYS5zdWJ0cmFjdChiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpdmlkZTogZnVuY3Rpb24gKHBvbHkpIHtcclxuICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gdGhpcy52YXJpYWJsZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVuZCA9IGNvcmUuVXRpbHMuYXJyYXlDbG9uZSh0aGlzLmNvZWZmcyksXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2aXNvciA9IGNvcmUuVXRpbHMuYXJyYXlDbG9uZShwb2x5LmNvZWZmcyksXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IGRpdmlkZW5kLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBtcCA9IGRpdmlzb3IubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgICAgICAgICBxdW90aWVudCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggdGhlIGRpdmlkZW5kXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gbiAtIChpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAvL2dldCB0aGUgZGlmZmVyZW5jZSBvZiB0aGUgcG93ZXJzXHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHAgLSBtcDtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBxdW90aWVudCBvZiB0aGUgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgICAgICB2YXIgcSA9IGRpdmlkZW5kW3BdLmRpdmlkZShkaXZpc29yW21wXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZCA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7Ly90aGUgZGl2aXNvciBpcyBub3QgZ3JlYXRlciB0aGFuIHRoZSBkaXZpZGVuZFxyXG4gICAgICAgICAgICAgICAgLy9wbGFjZSBpdCBpbiB0aGUgcXVvdGllbnRcclxuICAgICAgICAgICAgICAgIHF1b3RpZW50W2RdID0gcTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDw9IG1wOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JlZHVjZSB0aGUgZGl2aWRlbmRcclxuICAgICAgICAgICAgICAgICAgICBkaXZpZGVuZFtqICsgZF0gPSBkaXZpZGVuZFtqICsgZF0uc3VidHJhY3QoKGRpdmlzb3Jbal0ubXVsdGlwbHkocSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jbGVhbiB1cFxyXG4gICAgICAgICAgICB2YXIgcDEgPSBQb2x5bm9taWFsLmZyb21BcnJheShkaXZpZGVuZCwgdmFyaWFibGUgfHwgJ3gnKS50cmltKCksIC8vcGFzcyBpbiB4IGZvciBzYWZldHlcclxuICAgICAgICAgICAgICAgICAgICBwMiA9IFBvbHlub21pYWwuZnJvbUFycmF5KHF1b3RpZW50LCB2YXJpYWJsZSB8fCAneCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gW3AyLCBwMV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24gKHBvbHkpIHtcclxuICAgICAgICAgICAgdmFyIGwxID0gdGhpcy5jb2VmZnMubGVuZ3RoLCBsMiA9IHBvbHkuY29lZmZzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBjID0gW107IC8vYXJyYXkgdG8gYmUgcmV0dXJuZWRcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGwxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB4MSA9IHRoaXMuY29lZmZzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGwyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGkgKyBqLCAvL2FkZCB0aGUgcG93ZXJzIHRvZ2V0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHBvbHkuY29lZmZzW2pdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGNba10gfHwgbmV3IEZyYWMoMCk7IC8vZ2V0IHRoZSBleGlzdGluZyB0ZXJtIGZyb20gdGhlIG5ldyBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIGNba10gPSBlLmFkZCh4MS5tdWx0aXBseSh4MikpOyAvL211bHRpcGx5IHRoZSBjb2VmZmljaWVudHMgYW5kIGFkZCB0byBuZXcgcG9seW5vbWlhbCBhcnJheVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29lZmZzID0gYztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgYSBwb2x5bm9taWFsIGlzIHplcm9cclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc1plcm86IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmNvZWZmcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5jb2VmZnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZighZS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFN1YnN0aXR1dGVzIGluIGEgbnVtYmVyIG4gaW50byB0aGUgcG9seW5vbWlhbCBwKG4pXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cclxuICAgICAgICAgKiBAcmV0dXJucyB7RnJhY31cclxuICAgICAgICAgKi9cclxuICAgICAgICBzdWI6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHZhciBzdW0gPSBuZXcgRnJhYygwKSwgbCA9IHRoaXMuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmNvZWZmc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKCF0LmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0uYWRkKHQubXVsdGlwbHkobmV3IEZyYWMoTWF0aC5wb3cobiwgaSkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgcG9seW5vbWlhbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2x5bm9taWFsfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwID0gbmV3IFBvbHlub21pYWwoKTtcclxuICAgICAgICAgICAgcC5jb2VmZnMgPSB0aGlzLmNvZWZmcztcclxuICAgICAgICAgICAgcC52YXJpYWJsZSA9IHRoaXMudmFyaWFibGU7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgZGVncmVlIG9mIHRoZSBwb2x5bm9taWFsXHJcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkZWc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy50cmltKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIGxlYWQgY29lZmZpY2llbnRcclxuICAgICAgICAgKiBAcmV0dXJucyB7RnJhY31cclxuICAgICAgICAgKi9cclxuICAgICAgICBsYzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2VmZnNbdGhpcy5kZWcoKV0uY2xvbmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHBvbHlub21pYWwgaW50byBhIG1vbmljIHBvbHlub21pYWxcclxuICAgICAgICAgKiBAcmV0dXJucyB7UG9seW5vbWlhbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBtb25pYzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbGMgPSB0aGlzLmxjKCksIGwgPSB0aGlzLmNvZWZmcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmc1tpXSA9IHRoaXMuY29lZmZzW2ldLmRpdmlkZShsYyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgR0NEIG9mIHR3byBwb2x5bm9taWFsc1xyXG4gICAgICAgICAqIEBwYXJhbSB7UG9seW5vbWlhbH0gcG9seVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtQb2x5bm9taWFsfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdjZDogZnVuY3Rpb24gKHBvbHkpIHtcclxuICAgICAgICAgICAgLy9nZXQgdGhlIG1heGltdW0gcG93ZXIgb2YgZWFjaFxyXG4gICAgICAgICAgICB2YXIgbXAxID0gdGhpcy5jb2VmZnMubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgICAgICAgICBtcDIgPSBwb2x5LmNvZWZmcy5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgIFQ7XHJcbiAgICAgICAgICAgIC8vc3dhcCBzbyB3ZSBhbHdheXMgaGF2ZSB0aGUgZ3JlYXRlciBwb3dlciBmaXJzdFxyXG4gICAgICAgICAgICBpZihtcDEgPCBtcDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb2x5LmdjZCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSghcG9seS5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBwb2x5LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBhID0gYS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgVCA9IGEuZGl2aWRlKHQpO1xyXG4gICAgICAgICAgICAgICAgcG9seSA9IFRbMV07XHJcbiAgICAgICAgICAgICAgICBhID0gdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGdjZCA9IGNvcmUuTWF0aDIuUUdDRC5hcHBseShudWxsLCBhLmNvZWZmcyk7XHJcbiAgICAgICAgICAgIGlmKCFnY2QuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGEuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhLmNvZWZmc1tpXSA9IGEuY29lZmZzW2ldLmRpdmlkZShnY2QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlmZmVyZW50aWF0ZXMgdGhlIHBvbHlub21pYWxcclxuICAgICAgICAgKiBAcmV0dXJucyB7UG9seW5vbWlhbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaWZmOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdfYXJyYXkgPSBbXSwgbCA9IHRoaXMuY29lZmZzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgIG5ld19hcnJheS5wdXNoKHRoaXMuY29lZmZzW2ldLm11bHRpcGx5KG5ldyBGcmFjKGkpKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29lZmZzID0gbmV3X2FycmF5O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVncmF0ZXMgdGhlIHBvbHlub21pYWxcclxuICAgICAgICAgKiBAcmV0dXJucyB7UG9seW5vbWlhbH0gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW50ZWdyYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdfYXJyYXkgPSBbMF0sIGwgPSB0aGlzLmNvZWZmcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IEZyYWMoaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgbmV3X2FycmF5W2NdID0gdGhpcy5jb2VmZnNbaV0uZGl2aWRlKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29lZmZzID0gbmV3X2FycmF5O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIEdyZWF0ZXN0IGNvbW1vbiBmYWN0b3Igb2YgdGhlIHBvbHlub21pYWxcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IHRvUG9seW5vbWlhbCAtIHRydWUgaWYgYSBwb2x5bm9taWFsIGlzIHdhbnRlZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtGcmFjfFBvbHlub21pYWx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2NmOiBmdW5jdGlvbiAodG9Qb2x5bm9taWFsKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IHRoZSBmaXJzdCBub3plcm8gY29lZmZpY2llbnQgYW5kIHJldHVybnMgaXRzIHBvd2VyXHJcbiAgICAgICAgICAgIHZhciBmbnogPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWFbaV0uZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBjYSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2VmZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb2VmZnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZighYy5lcXVhbHMoMCkgJiYgY2EuaW5kZXhPZihjKSA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgY2EucHVzaChjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcCA9IFtjb3JlLk1hdGgyLlFHQ0QuYXBwbHkodW5kZWZpbmVkLCBjYSksIGZueih0aGlzLmNvZWZmcyldLnRvRGVjaW1hbCgpO1xyXG5cclxuICAgICAgICAgICAgaWYodG9Qb2x5bm9taWFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcGFycltwWzFdIC0gMV0gPSBwWzBdO1xyXG4gICAgICAgICAgICAgICAgcCA9IFBvbHlub21pYWwuZnJvbUFycmF5KHBhcnIsIHRoaXMudmFyaWFibGUpLmZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSYWlzZXMgYSBwb2x5bm9taWFsIFAgdG8gYSBwb3dlciBwIC0+IFBecC4gZS5nLiAoeCsxKV4yXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sfSBpbmNsX2ltZyAtIEluY2x1ZGUgaW1hZ2luYXJ5IG51bWJlcnMgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcXVhZDogZnVuY3Rpb24gKGluY2xfaW1nKSB7XHJcbiAgICAgICAgICAgIHZhciByb290cyA9IFtdO1xyXG4gICAgICAgICAgICBpZih0aGlzLmNvZWZmcy5sZW5ndGggPiAzKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHF1YWRyYXRpYyBvcmRlciBvZiAnICsgKHRoaXMuY29lZmZzLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgaWYodGhpcy5jb2VmZnMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2x5bm9taWFsIGFycmF5IGhhcyBubyB0ZXJtcycpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuY29lZmZzWzJdIHx8IDAsIGIgPSB0aGlzLmNvZWZmc1sxXSB8fCAwLCBjID0gdGhpcy5jb2VmZnNbMF07XHJcbiAgICAgICAgICAgIHZhciBkc2MgPSBiICogYiAtIDQgKiBhICogYztcclxuICAgICAgICAgICAgaWYoZHNjIDwgMCAmJiAhaW5jbF9pbWcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdHM7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm9vdHNbMF0gPSAoLWIgKyBNYXRoLnNxcnQoZHNjKSkgLyAoMiAqIGEpO1xyXG4gICAgICAgICAgICAgICAgcm9vdHNbMV0gPSAoLWIgLSBNYXRoLnNxcnQoZHNjKSkgLyAoMiAqIGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByb290cztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ha2VzIHBvbHlub21pYWwgc3F1YXJlIGZyZWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3F1YXJlRnJlZTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGEuY2xvbmUoKS5kaWZmKCksXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGEuY2xvbmUoKS5nY2QoYiksXHJcbiAgICAgICAgICAgICAgICAgICAgdyA9IGEuZGl2aWRlKGMpWzBdO1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gUG9seW5vbWlhbC5mcm9tQXJyYXkoW25ldyBGcmFjKDEpXSwgYS52YXJpYWJsZSk7XHJcbiAgICAgICAgICAgIHdoaWxlKCFjLmVxdWFsc051bWJlcigxKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB3LmdjZChjKTtcclxuICAgICAgICAgICAgICAgIHZhciB6ID0gdy5kaXZpZGUoeSlbMF07XHJcbiAgICAgICAgICAgICAgICAvL29uZSBvZiB0aGUgZmFjdG9ycyBtYXkgaGF2ZSBzaG93biB1cCBzaW5jZSBpdCdzIHNxdWFyZSBidXQgc21hbGxlciB0aGFuIHRoZSBcclxuICAgICAgICAgICAgICAgIC8vb25lIHdoZXJlIGZpbmRpbmdcclxuICAgICAgICAgICAgICAgIGlmKCF6LmVxdWFsc051bWJlcigxKSAmJiBpID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gei5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDE7IGogPCBpOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQubXVsdGlwbHkoei5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB6ID0gdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5tdWx0aXBseSh6KTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIHcgPSB5O1xyXG4gICAgICAgICAgICAgICAgYyA9IGMuZGl2aWRlKHkpWzBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW291dHB1dCwgdywgaV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBwb2x5bm9taWFsIHRvIFN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9TeW1ib2w6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmNvZWZmcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUgPSB0aGlzLnZhcmlhYmxlO1xyXG4gICAgICAgICAgICBpZihsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLlN5bWJvbCgwKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGwgLSAxLCBzdHIgPSAnJztcclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vcGxhY2UgdGhlIHBsdXMgc2lnbiBmb3IgYWxsIGJ1dCB0aGUgbGFzdCBvbmVcclxuICAgICAgICAgICAgICAgIHZhciBwbHVzID0gaSA9PT0gZW5kID8gJycgOiAnKycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmNvZWZmc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKCFlLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICBzdHIgKz0gKGUgKyAnKicgKyB2YXJpYWJsZSArICdeJyArIGkgKyBwbHVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXy5wYXJzZShzdHIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHBvbHlub21pYWwgaXMgZXF1YWwgdG8gYSBudW1iZXJcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVxdWFsc051bWJlcjogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdGhpcy50cmltKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZWZmcy5sZW5ndGggPT09IDEgJiYgdGhpcy5jb2VmZnNbMF0udG9EZWNpbWFsKCkgPT09IFN0cmluZyh4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3ltYm9sKCkudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVE9ET1xyXG4gICAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAqIFRISVMgTUVUSE9EIEhBUyBBIE5BU1RZIEhJRERFTiBCVUcuIElUIEhBUyBJTkNPTlNJU1RFTlQgUkVUVVJOIFRZUEVTIFBSSU1BUklMWSBEVUUgVE8gXHJcbiAgICAgKiBXUk9ORyBBU1NVTVBUSU9OUyBBVCBUSEUgQkVHSU5OSU5HLiBUSEUgQVNTVU1QVElPTiBXQVMgVEhBVCBDT0VGRlMgV0VSRSBBTFdBWVMgR09JTkcgQkUgTlVNQkVSU1xyXG4gICAgICogTk9UIFRBS0lORyBJTlRPIEFDQ09VTlQgVEhBVCBJTUFHSU5BUlkgTlVNQkVSUy4gRklYSU5HIFRISVMgQlJFQUtTIFdBWSBUT08gTUFOWSBURVNUUyBcclxuICAgICAqIEFUIFRIRU0gTU9NRU5UIFdISUNIIEkgRE9OJ1QgSEFWRSBUTyBGSVhcclxuICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgKiBJZiB0aGUgc3ltYm9scyBpcyBvZiBncm91cCBQTCBvciBDUCBpdCB3aWxsIHJldHVybiB0aGUgbXVsdGlwbGllcnMgb2YgZWFjaCBzeW1ib2xcclxuICAgICAqIGFzIHRoZXNlIGFyZSBwb2x5bm9taWFsIGNvZWZmaWNpZW50cy4gQ0Igc3ltYm9scyBhcmUgZ2x1ZWQgdG9nZXRoZXIgYnkgbXVsdGlwbGljYXRpb25cclxuICAgICAqIHNvIHRoZSBzeW1ib2wgbXVsdGlwbGllciBjYXJyaWVzIHRoZSBjb2VmZmljaWVudHMgZm9yIGFsbCBjb250YWluZWQgc3ltYm9scy5cclxuICAgICAqIEZvciBTIGl0IGp1c3QgcmV0dXJucyBpdCdzIG93biBtdWx0aXBsaWVyLiBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3QgY2FyZSBpZiBpdCdzIGEgcG9seW5vbWlhbCBvciBub3RcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGMgVGhlIGNvZWZmaWNpZW50IGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhfb3JkZXIgXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgU3ltYm9sLnByb3RvdHlwZS5jb2VmZnMgPSBmdW5jdGlvbiAoYywgd2l0aF9vcmRlcikge1xyXG4gICAgICAgIGlmKHdpdGhfb3JkZXIgJiYgIXRoaXMuaXNQb2x5KHRydWUpKVxyXG4gICAgICAgICAgICBfLmVycm9yKCdQb2x5bm9taWFsIGV4cGVjdGVkIHdoZW4gcmVxdWVzdGluZyBjb2VmZmljaWVudHMgd2l0aCBvcmRlcicpO1xyXG4gICAgICAgIGMgPSBjIHx8IFtdO1xyXG4gICAgICAgIHZhciBzID0gdGhpcy5jbG9uZSgpLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgaWYocy5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgeCBpbiBzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBzLnN5bWJvbHNbeF07XHJcbiAgICAgICAgICAgICAgICBpZihzdWIuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Yi5jbG9uZSgpLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCkuY29lZmZzKGMsIHdpdGhfb3JkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYod2l0aF9vcmRlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY1tzdWIuaXNDb25zdGFudCgpID8gMCA6IHN1Yi5wb3dlci50b0RlY2ltYWwoKV0gPSBzdWIubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKHN1Yi5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKHdpdGhfb3JkZXIpXHJcbiAgICAgICAgICAgICAgICBjW3MuaXNDb25zdGFudCh0cnVlKSA/IDAgOiBzLnBvd2VyLnRvRGVjaW1hbCgpXSA9IHMubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZihzLmdyb3VwID09PSBDQiAmJiBzLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IG5ldyBTeW1ib2wocy5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhlIGltYWdpbmFyeSBwYXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguaXNDb25zdGFudCh0cnVlKSB8fCB4LmltYWdpbmFyeSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBfLm11bHRpcGx5KG0sIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGMucHVzaChtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjLnB1c2gocy5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2ZpbGwgdGhlIGhvbGVzXHJcbiAgICAgICAgaWYod2l0aF9vcmRlcikge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIGlmKGNbaV0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICBjW2ldID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9O1xyXG4gICAgU3ltYm9sLnByb3RvdHlwZS50QmFzZSA9IGZ1bmN0aW9uIChtYXApIHtcclxuICAgICAgICBpZih0eXBlb2YgbWFwID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTeW1ib2wudEJhc2UgcmVxdWlyZXMgYSBtYXAgb2JqZWN0IScpO1xyXG4gICAgICAgIHZhciB0ZXJtcyA9IFtdO1xyXG4gICAgICAgIHZhciBzeW1ib2xzID0gdGhpcy5jb2xsZWN0U3ltYm9scyhudWxsLCBudWxsLCBudWxsLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgIGwgPSBzeW1ib2xzLmxlbmd0aDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBzeW1ib2wuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgbnRlcm0gPSBuZXcgTVZUZXJtKHN5bWJvbC5tdWx0aXBsaWVyLCBbXSwgbWFwKTtcclxuICAgICAgICAgICAgaWYoZyA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBzeW1ib2wuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBzeW1ib2wuc3ltYm9sc1t4XTtcclxuICAgICAgICAgICAgICAgICAgICBudGVybS50ZXJtc1ttYXBbeF1dID0gc3ltLnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbnRlcm0udGVybXNbbWFwW3N5bWJvbC52YWx1ZV1dID0gc3ltYm9sLnBvd2VyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0ZXJtcy5wdXNoKG50ZXJtLmZpbGwoKSk7XHJcbiAgICAgICAgICAgIG50ZXJtLnVwZGF0ZUNvdW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXJtcztcclxuICAgIH07XHJcbiAgICBTeW1ib2wucHJvdG90eXBlLmFsdFZhciA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIG0gPSB0aGlzLm11bHRpcGxpZXIudG9TdHJpbmcoKSwgcCA9IHRoaXMucG93ZXIudG9TdHJpbmcoKTtcclxuICAgICAgICByZXR1cm4gKG0gPT09ICcxJyA/ICcnIDogbSArICcqJykgKyB4ICsgKHAgPT09ICcxJyA/ICcnIDogJ14nICsgcCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBzeW1ib2xzIGNvbnRhaW4gdGhlIHNhbWUgdmFyaWFibGVzXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgU3ltYm9sLnByb3RvdHlwZS5zYW1lVmFycyA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICBpZighKHRoaXMuc3ltYm9scyB8fCB0aGlzLmdyb3VwID09PSBzeW1ib2wuZ3JvdXApKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuc3ltYm9sc1t4XSwgYiA9IHN5bWJvbC5zeW1ib2xzW3hdO1xyXG4gICAgICAgICAgICBpZighYilcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYoYS52YWx1ZSAhPT0gYi52YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHcm91cHMgdGhlIHRlcm1zIGluIGEgc3ltYm9sIHdpdGggcmVzcGVjdCB0byBhIHZhcmlhYmxlXHJcbiAgICAgKiBGb3IgaW5zdGFuY2UgdGhlIHN5bWJvbCB7YSpiXjIqeF4yK2EqYip4XjIreCs2fSByZXR1cm5zIFs2LDEsYSpiK2EqYl4yXVxyXG4gICAgICogQHJldHVybnMge0ZhY3RvcnN9XHJcbiAgICAgKi9cclxuICAgIFN5bWJvbC5wcm90b3R5cGUuZ3JvdXBUZXJtcyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgeCA9IFN0cmluZyh4KTtcclxuICAgICAgICB2YXIgZiwgcCwgZWdyb3VwZWQ7XHJcbiAgICAgICAgdmFyIGdyb3VwZWQgPSBbXTtcclxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgaWYoZS5ncm91cCA9PT0gUEwpIHtcclxuICAgICAgICAgICAgICAgIGVncm91cGVkID0gZS5ncm91cFRlcm1zKHgpO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVncm91cGVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZWdyb3VwZWRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZWRbaV0gPSBlbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGYgPSBjb3JlLlV0aWxzLmRlY29tcG9zZV9mbihlLCB4LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHAgPSBmLngudmFsdWUgPT09IHggPyBOdW1iZXIoZi54LnBvd2VyKSA6IDA7XHJcbiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgdmFsdWVcclxuICAgICAgICAgICAgICAgIGdyb3VwZWRbcF0gPSBfLmFkZChncm91cGVkW3BdIHx8IG5ldyBTeW1ib2woMCksIGYuYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ3JvdXBlZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVzZSB0aGlzIHRvIGNvbGxlY3QgRmFjdG9yc1xyXG4gICAgICogQHJldHVybnMge1N5bWJvbFtdfVxyXG4gICAgICovXHJcbiAgICBTeW1ib2wucHJvdG90eXBlLmNvbGxlY3RGYWN0b3JzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmYWN0b3JzID0gW107XHJcbiAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gQ0IpXHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgZmFjdG9ycy5wdXNoKHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZmFjdG9ycy5wdXNoKHRoaXMuY2xvbmUoKSk7XHJcbiAgICAgICAgcmV0dXJuIGZhY3RvcnM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbnRhaW5lciBjbGFzcyBmb3IgZmFjdG9yc1xyXG4gICAgICogQHJldHVybnMge0ZhY3RvcnN9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEZhY3RvcnMoKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3JzID0ge307XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgRmFjdG9ycy5wcm90b3R5cGUuZ2V0TnVtYmVyU3ltYm9saWNzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuID0gMDtcclxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYoIXguaXNDb25zdGFudCh0cnVlKSlcclxuICAgICAgICAgICAgICAgIG4rKztcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGZhY3RvcnMgdG8gdGhlIGZhY3RvciBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7U3ltYm99IHNcclxuICAgICAqIEByZXR1cm5zIHtGYWN0b3JzfVxyXG4gICAgICovXHJcbiAgICBGYWN0b3JzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgIGlmKHMuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy9ub3RoaW5nIHRvIGFkZFxyXG5cclxuICAgICAgICAvL3dlIGRvbid0IHdhbnQgdG8gY2FycnkgLTEgYXMgYSBmYWN0b3IuIElmIGEgZmFjdG9yIGFscmVhZHkgZXhpc3RzLFxyXG4gICAgICAgIC8vdGhlbiBhZGQgdGhlIG1pbnVzIG9uZSB0byB0aGF0IGZhY3RvciBhbmQgcmV0dXJuLlxyXG4gICAgICAgIGlmKHMuZXF1YWxzKC0xKSAmJiB0aGlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGZvID0gY29yZS5VdGlscy5maXJzdE9iamVjdCh0aGlzLmZhY3RvcnMsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZChfLnN5bWZ1bmN0aW9uKGNvcmUuU2V0dGluZ3MuUEFSRU5USEVTSVMsIFtmby5vYmpdKS5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZhY3RvcnNbZm8ua2V5XTtcclxuICAgICAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihzLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICB2YXIgZmFjdG9ycyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmKCFzLm11bHRpcGxpZXIuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQobmV3IFN5bWJvbChzLm11bHRpcGxpZXIpKTtcclxuICAgICAgICAgICAgcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZCh4KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZih0aGlzLnByZUFkZCkgLy9pZiBhIHByZUFkZCBmdW5jdGlvbiB3YXMgZGVmaW5lZCBjYWxsIGl0IHRvIGRvIHByZXBcclxuICAgICAgICAgICAgICAgIHMgPSB0aGlzLnByZUFkZChzKTtcclxuICAgICAgICAgICAgaWYodGhpcy5wRmFjdG9yKSAvL2lmIHRoZSBzeW1ib2wgaXNuJ3QgbGluZWFyIGFkZCBiYWNrIHRoZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgcyA9IF8ucG93KHMsIG5ldyBTeW1ib2wodGhpcy5wRmFjdG9yKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgaXNfY29uc3RhbnQgPSBzLmlzQ29uc3RhbnQoKTtcclxuICAgICAgICAgICAgaWYoaXNfY29uc3RhbnQgJiYgcy5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy9kb24ndCBhZGQgMVxyXG4gICAgICAgICAgICB2YXIgdiA9IGlzX2NvbnN0YW50ID8gcy52YWx1ZSA6IHMudGV4dCgpO1xyXG4gICAgICAgICAgICBpZih2IGluIHRoaXMuZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWN0b3JzW3ZdID0gXy5tdWx0aXBseSh0aGlzLmZhY3RvcnNbdl0sIHMpO1xyXG4gICAgICAgICAgICAgICAgLy9kaWQgdGhlIGFkZGl0aW9uIGNhbmNlbCBvdXQgdGhlIGV4aXN0aW5nIGZhY3Rvcj8gSWYgc28gcmVtb3ZlIGl0IGFuZCBkZWNyZW1lbnQgdGhlIGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5mYWN0b3JzW3ZdLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZhY3RvcnNbdl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFjdG9yc1t2XSA9IHM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGZhY3RvciBvYmplY3QgdG8gYSBTeW1ib2xcclxuICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgKi9cclxuICAgIEZhY3RvcnMucHJvdG90eXBlLnRvU3ltYm9sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBmYWN0b3JlZCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgdmFyIGZhY3RvcnMgPSBPYmplY3QudmFsdWVzKHRoaXMuZmFjdG9ycykuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5ncm91cCA+IGIuZ3JvdXA7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBmYWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZiA9IGZhY3RvcnNbaV07XHJcblxyXG4gICAgICAgICAgICAvL2Rvbid0IHdyYXAgZ3JvdXAgUyBvciBGTlxyXG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gZi5wb3dlci5lcXVhbHMoMSkgJiYgZi5mbmFtZSAhPT0gJycgLyogZG9uJ3Qgd3JhcCBpdCB0d2ljZSAqLyA/XHJcbiAgICAgICAgICAgICAgICAgICAgXy5zeW1mdW5jdGlvbihjb3JlLlBBUkVOVEhFU0lTLCBbZl0pIDogZjtcclxuXHJcbiAgICAgICAgICAgIGZhY3RvcmVkID0gXy5tdWx0aXBseShmYWN0b3JlZCwgZmFjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZmFjdG9yZWQuZm5hbWUgPT09ICcnKVxyXG4gICAgICAgICAgICBmYWN0b3JlZCA9IFN5bWJvbC51bndyYXBQQVJFTlMoZmFjdG9yZWQpO1xyXG4gICAgICAgIHJldHVybiBmYWN0b3JlZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlcyAyIGZhY3RvciBvYmplY3RzIGludG8gb25lXHJcbiAgICAgKiBAcGFyYW0ge0ZhY3Rvcn0gb1xyXG4gICAgICogQHJldHVybnMge0ZhY3RvcnN9XHJcbiAgICAgKi9cclxuICAgIEZhY3RvcnMucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBmb3IodmFyIHggaW4gbykge1xyXG4gICAgICAgICAgICBpZih4IGluIHRoaXMuZmFjdG9ycylcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFjdG9yc1t4XSA9IF8ubXVsdGlwbHkodGhpcy5mYWN0b3JzW3hdLCBvW3hdKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWN0b3JzW3hdID0gb1t4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaXRlcmF0b3IgZm9yIHRoZSBmYWN0b3Igb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIC0gY2FsbGJhY2tcclxuICAgICAqIEByZXR1cm5zIHtGYWN0b3J9XHJcbiAgICAgKi9cclxuICAgIEZhY3RvcnMucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLmZhY3RvcnMpIHtcclxuICAgICAgICAgICAgdmFyIGZhY3RvciA9IHRoaXMuZmFjdG9yc1t4XTtcclxuICAgICAgICAgICAgaWYoZmFjdG9yLmZuYW1lID09PSBjb3JlLlBBUkVOVEhFU0lTICYmIGZhY3Rvci5pc0xpbmVhcigpKVxyXG4gICAgICAgICAgICAgICAgZmFjdG9yID0gZmFjdG9yLmFyZ3NbMF07XHJcbiAgICAgICAgICAgIGYuY2FsbCh0aGlzLCBmYWN0b3IsIHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGZhY3RvcnMgY29udGFpbmVkIGluIHRoZSBmYWN0b3Igb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7aW50fVxyXG4gICAgICovXHJcbiAgICBGYWN0b3JzLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ga2V5cyh0aGlzLmZhY3RvcnMpLmxlbmd0aDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFucyB1cCBmYWN0b3JzIGZyb20gLTFcclxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAgICAgKi9cclxuICAgIEZhY3RvcnMucHJvdG90eXBlLmNsZWFuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBoID0gY29yZS5TZXR0aW5ncy5DT05TVF9IQVNIO1xyXG4gICAgICAgICAgICBpZih0aGlzLmZhY3RvcnNbaF0ubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZmFjdG9yc1toXS5lcXVhbHMoLTEpKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmZhY3RvcnNbaF07XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWN0b3JzW2hdLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgO1xyXG4gICAgfTtcclxuICAgIEZhY3RvcnMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3ltYm9sKCkudG9TdHJpbmcoKTtcclxuICAgIH07XHJcblxyXG4gICAgLy9hIHdyYXBwZXIgZm9yIHBlcmZvcm1pbmcgbXVsdGl2YXJpYXRlIGRpdmlzaW9uXHJcbiAgICBmdW5jdGlvbiBNVlRlcm0oY29lZmYsIHRlcm1zLCBtYXApIHtcclxuICAgICAgICB0aGlzLnRlcm1zID0gdGVybXMgfHwgW107XHJcbiAgICAgICAgdGhpcy5jb2VmZiA9IGNvZWZmO1xyXG4gICAgICAgIHRoaXMubWFwID0gbWFwOyAvL2NhcmVmdWwhIGFsbCBtYXBzIGFyZSB0aGUgc2FtZSBvYmplY3RcclxuICAgICAgICB0aGlzLnN1bSA9IG5ldyBjb3JlLkZyYWMoMCk7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIE1WVGVybS5wcm90b3R5cGUudXBkYXRlQ291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IHRoaXMuY291bnQgfHwgMDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXJtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZighdGhpcy50ZXJtc1tpXS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIE1WVGVybS5wcm90b3R5cGUuZ2V0VmFycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFycyA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnRlcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXJtID0gdGhpcy50ZXJtc1tpXSxcclxuICAgICAgICAgICAgICAgICAgICByZXZfbWFwID0gdGhpcy5nZXRSZXZNYXAoKTtcclxuICAgICAgICAgICAgaWYoIXRlcm0uZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgdmFycy5wdXNoKHRoaXMucmV2X21hcFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YXJzLmpvaW4oJyAnKTtcclxuICAgIH07XHJcbiAgICBNVlRlcm0ucHJvdG90eXBlLmxlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5jb3VudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb3VudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcclxuICAgIH07XHJcbiAgICBNVlRlcm0ucHJvdG90eXBlLnRvU3ltYm9sID0gZnVuY3Rpb24gKHJldl9tYXApIHtcclxuICAgICAgICByZXZfbWFwID0gcmV2X21hcCB8fCB0aGlzLmdldFJldk1hcCgpO1xyXG4gICAgICAgIHZhciBzeW1ib2wgPSBuZXcgU3ltYm9sKHRoaXMuY29lZmYpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnRlcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gcmV2X21hcFtpXSxcclxuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy50ZXJtc1tpXTtcclxuICAgICAgICAgICAgaWYodC5lcXVhbHMoMCkgfHwgdiA9PT0gQ09OU1RfSEFTSClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgbWFwcGVkID0gbmV3IFN5bWJvbCh2KTtcclxuICAgICAgICAgICAgbWFwcGVkLnBvd2VyID0gdDtcclxuICAgICAgICAgICAgc3ltYm9sID0gXy5tdWx0aXBseShzeW1ib2wsIG1hcHBlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICB9O1xyXG4gICAgTVZUZXJtLnByb3RvdHlwZS5nZXRSZXZNYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYodGhpcy5yZXZfbWFwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZfbWFwO1xyXG4gICAgICAgIHZhciBvID0ge307XHJcbiAgICAgICAgZm9yKHZhciB4IGluIHRoaXMubWFwKVxyXG4gICAgICAgICAgICBvW3RoaXMubWFwW3hdXSA9IHg7XHJcbiAgICAgICAgdGhpcy5yZXZfbWFwID0gbztcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH07XHJcbiAgICBNVlRlcm0ucHJvdG90eXBlLmdlbmVyYXRlSW1hZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IHRoaXMudGVybXMuam9pbignICcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuICAgICAgICAgICAgTVZUZXJtLnByb3RvdHlwZS5nZXRJbWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZighdGhpcy5pbWFnZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBNVlRlcm0ucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IHRoaXMubWFwLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgdGhpcy50ZXJtc1tpXSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGVybXNbaV0gPSBuZXcgY29yZS5GcmFjKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1bSA9IHRoaXMuc3VtLmFkZCh0aGlzLnRlcm1zW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgIE1WVGVybS5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKG12dGVybSkge1xyXG4gICAgICAgIHZhciBjID0gdGhpcy5jb2VmZi5kaXZpZGUobXZ0ZXJtLmNvZWZmKSxcclxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLnRlcm1zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG5ld19tdnRlcm0gPSBuZXcgTVZUZXJtKGMsIFtdLCB0aGlzLm1hcCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBuZXdfbXZ0ZXJtLnRlcm1zW2ldID0gdGhpcy50ZXJtc1tpXS5zdWJ0cmFjdChtdnRlcm0udGVybXNbaV0pO1xyXG4gICAgICAgICAgICBuZXdfbXZ0ZXJtLnN1bSA9IG5ld19tdnRlcm0uc3VtLmFkZChuZXdfbXZ0ZXJtLnRlcm1zW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld19tdnRlcm07XHJcbiAgICB9O1xyXG4gICAgTVZUZXJtLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChtdnRlcm0pIHtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuY29lZmYubXVsdGlwbHkobXZ0ZXJtLmNvZWZmKSxcclxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLnRlcm1zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG5ld19tdnRlcm0gPSBuZXcgTVZUZXJtKGMsIFtdLCB0aGlzLm1hcCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBuZXdfbXZ0ZXJtLnRlcm1zW2ldID0gdGhpcy50ZXJtc1tpXS5hZGQobXZ0ZXJtLnRlcm1zW2ldKTtcclxuICAgICAgICAgICAgbmV3X212dGVybS5zdW0gPSBuZXdfbXZ0ZXJtLnN1bS5hZGQobmV3X212dGVybS50ZXJtc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdfbXZ0ZXJtO1xyXG4gICAgfTtcclxuICAgIE1WVGVybS5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvZWZmLmVxdWFscygwKTtcclxuICAgIH07XHJcbiAgICBNVlRlcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAneyBjb2VmZjogJyArIHRoaXMuY29lZmYudG9TdHJpbmcoKSArICcsIHRlcm1zOiBbJyArXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1zLmpvaW4oJywnKSArICddOiBzdW06ICcgKyB0aGlzLnN1bS50b1N0cmluZygpICsgJywgY291bnQ6ICcgKyB0aGlzLmNvdW50ICsgJ30nO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb3JlLlV0aWxzLnRvTWFwT2JqID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIHZhciBjID0gMCwgbyA9IHt9O1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHYgPSBhcnJbaV07XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBvW3ZdID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb1t2XSA9IGM7XHJcbiAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgby5sZW5ndGggPSBjO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfTtcclxuICAgIGNvcmUuVXRpbHMuZmlsbGVkQXJyYXkgPSBmdW5jdGlvbiAodiwgbiwgY2xzcykge1xyXG4gICAgICAgIHZhciBhID0gW107XHJcbiAgICAgICAgd2hpbGUobi0tKSB7XHJcbiAgICAgICAgICAgIGFbbl0gPSBjbHNzID8gbmV3IGNsc3ModikgOiB2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH07XHJcbiAgICBjb3JlLlV0aWxzLmFyclN1bSA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICB2YXIgc3VtID0gMCwgbCA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgc3VtICs9IGFycltpXTtcclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiAyIGFycmF5cyBoYXZlIGludGVyc2VjdGluZyBlbGVtZW50cy5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGJcclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIGEgYW5kIGIgaGF2ZSBpbnRlcnNlY3RpbmcgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvcmUuVXRpbHMuaGF2ZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgdmFyIHQ7XHJcbiAgICAgICAgaWYoYi5sZW5ndGggPiBhLmxlbmd0aClcclxuICAgICAgICAgICAgdCA9IGIsIGIgPSBhLCBhID0gdDsgLy8gaW5kZXhPZiB0byBsb29wIG92ZXIgc2hvcnRlclxyXG4gICAgICAgIHJldHVybiBhLnNvbWUoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuaW5kZXhPZihlKSA+IC0xO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3Vic3RpdHV0ZXMgb3V0IGZ1bmN0aW9ucyBhcyB2YXJpYWJsZXMgc28gdGhleSBjYW4gYmUgdXNlZCBpbiByZWd1bGFyIGFsZ29yaXRobXNcclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXBcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBleHByZXNzaW9uIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBjb3JlLlV0aWxzLnN1YkZ1bmN0aW9ucyA9IGZ1bmN0aW9uIChzeW1ib2wsIG1hcCkge1xyXG4gICAgICAgIG1hcCA9IG1hcCB8fCB7fTtcclxuICAgICAgICB2YXIgc3ViYmVkID0gW107XHJcbiAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gRk4gfHwgeC5wcmV2aW91c0dyb3VwID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgLy93ZSBuZWVkIGEgbmV3IHZhcmlhYmxlIG5hbWUgc28gd2h5IG5vdCB1c2Ugb25lIG9mIHRoZSBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGNvcmUuVXRpbHMudGV4dCh4LCAnaGFzaCcpLCB0dmFyID0gbWFwW3ZhbF07XHJcbiAgICAgICAgICAgICAgICBpZighdHZhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2VuZXJhdGUgYSB1bmlxdWUgZW5vdWdoIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHguZm5hbWUgKyBrZXlzKG1hcCkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcFt2YWxdID0gdDtcclxuICAgICAgICAgICAgICAgICAgICBzdWJiZWQucHVzaCh4LmFsdFZhcih0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViYmVkLnB1c2goeC5hbHRWYXIodHZhcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoeC5ncm91cCA9PT0gQ0IgfHwgeC5ncm91cCA9PT0gUEwgfHwgeC5ncm91cCA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgIHN1YmJlZC5wdXNoKGNvcmUuVXRpbHMuc3ViRnVuY3Rpb25zKHgsIG1hcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHN1YmJlZC5wdXNoKHgudGV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENQIHx8IHN5bWJvbC5ncm91cCA9PT0gUEwpXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2wuYWx0VmFyKGNvcmUuVXRpbHMuaW5CcmFja2V0cyhzdWJiZWQuam9pbignKycpKSk7XHJcbiAgICAgICAgO1xyXG4gICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IpXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2wuYWx0VmFyKGNvcmUuVXRpbHMuaW5CcmFja2V0cyhzdWJiZWQuam9pbignKicpKSk7XHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbC50ZXh0KCk7XHJcbiAgICB9O1xyXG4gICAgY29yZS5VdGlscy5nZXRGdW5jdGlvbnNTdWJzID0gZnVuY3Rpb24gKG1hcCkge1xyXG4gICAgICAgIHZhciBzdWJzID0ge307XHJcbiAgICAgICAgLy9wcmVwYXJlIHN1YnN0aXR1dGlvbnNcclxuICAgICAgICBmb3IodmFyIHggaW4gbWFwKVxyXG4gICAgICAgICAgICBzdWJzW21hcFt4XV0gPSBfLnBhcnNlKHgpO1xyXG4gICAgICAgIHJldHVybiBzdWJzO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX18gPSBjb3JlLkFsZ2VicmEgPSB7XHJcbiAgICAgICAgdmVyc2lvbjogJzEuNC42JyxcclxuICAgICAgICBwcm9vdHM6IGZ1bmN0aW9uIChzeW1ib2wsIGRlY3ApIHtcclxuICAgICAgICAgICAgLy90aGUgcm9vdHMgd2lsbCBiZSByb3VuZGVkIHVwIHRvIDcgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgIC8vaWYgdGhpcyBjYXVzZXMgdHJvdWJsZSB5b3UgY2FuIGV4cGxpY2l0bHkgcGFzcyBpbiBhIGRpZmZlcmVudCBudW1iZXIgb2YgcGxhY2VzXHJcbiAgICAgICAgICAgIC8vcmFyciBmb3IgcG9seW5vbWlhbCBvZiBwb3dlciBuIGlzIG9mIGZvcm1hdCBbbiwgY29lZmYgeF5uLCBjb2VmZiB4XihuLTEpLCAuLi4sIGNvZWZmIHheMF1cclxuICAgICAgICAgICAgZGVjcCA9IGRlY3AgfHwgNztcclxuICAgICAgICAgICAgdmFyIHplcm9zID0gMDtcclxuICAgICAgICAgICAgdmFyIGtub3duX3Jvb3RzID0gW107XHJcbiAgICAgICAgICAgIHZhciBnZXRfcm9vdHMgPSBmdW5jdGlvbiAocmFyciwgcG93ZXJzLCBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByb290cyA9IGNhbGNyb290cyhyYXJyLCBwb3dlcnMsIG1heCkuY29uY2F0KGtub3duX3Jvb3RzKTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB6ZXJvczsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RzLnVuc2hpZnQoMCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdHM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wgaW5zdGFuY2VvZiBTeW1ib2wgJiYgc3ltYm9sLmlzUG9seSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIC8vbWFrZSBpdCBzbyB0aGUgc3ltYm9sIGhhcyBhIGNvbnN0YW50cyBhcyB0aGUgbG93ZXN0IHRlcm1cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gUEwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXN0X3BvdyA9IGNvcmUuVXRpbHMuYXJyYXlNaW4oa2V5cyhzeW1ib2wuc3ltYm9scykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb3dlc3Rfc3ltYm9sID0gc3ltYm9sLnN5bWJvbHNbbG93ZXN0X3Bvd10uY2xvbmUoKS50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5leHBhbmQoXy5kaXZpZGUoc3ltYm9sLCBsb3dlc3Rfc3ltYm9sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAga25vd25fcm9vdHMucHVzaCgwKTsgLy9hZGQgemVybyBzaW5jZSB0aGlzIGlzIGEga25vd24gcm9vdFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBjb3JlLmdyb3Vwcy5TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFswXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBjb3JlLmdyb3Vwcy5QTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3dlcnMgPSBrZXlzKHN5bWJvbC5zeW1ib2xzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbnBvd2VyID0gY29yZS5VdGlscy5hcnJheU1pbihwb3dlcnMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gY29yZS5QQVJTRVIuZGl2aWRlKHN5bWJvbCwgY29yZS5QQVJTRVIucGFyc2Uoc3ltYm9sLnZhbHVlICsgJ14nICsgbWlucG93ZXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBrZXlzKHN5bWJvbC5zeW1ib2xzKS5zb3J0KCkucG9wKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bSA9IHN5bWJvbC5ncm91cCA9PT0gY29yZS5ncm91cHMuUEwgPyBzeW1ib2wuc3ltYm9scyA6IHN5bWJvbC5zeW1ib2xzW3ZhcmlhYmxlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHN5bS5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJzID0gZyA9PT0gUyA/IFtzeW0ucG93ZXIudG9EZWNpbWFsKCldIDoga2V5cyhzeW0uc3ltYm9scyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhcnIgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gY29yZS5VdGlscy5hcnJheU1heChwb3dlcnMpOyAvL21heGltdW0gcG93ZXIgYW5kIGRlZ3JlZSBvZiBwb2x5bm9taWFsIHRvIGJlIHNvbHZlZFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIGRhdGFcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPD0gbWF4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IDA7IC8vaWYgdGhlcmUgaXMgbm8gcG93ZXIgdGhlbiB0aGUgaG9sZSBtdXN0IGJlIGZpbGxlZCB3aXRoIGEgemVyb1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHBvd2Vycy5pbmRleE9mKGkgKyAnJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGcgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBzeW0ubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBzeW0uc3ltYm9sc1tpXS5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgY29lZmZpZW50IGJ1dCBmcm9tIHRoZSBmcm9udFxyXG4gICAgICAgICAgICAgICAgICAgIHJhcnIudW5zaGlmdChjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByYXJyLnB1c2goc3ltYm9sLnN5bWJvbHNbQ09OU1RfSEFTSF0ubXVsdGlwbGllcik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltLmdyb3VwID09PSBTKVxyXG4gICAgICAgICAgICAgICAgICAgIHJhcnJbMF0gPSBzeW0ubXVsdGlwbGllcjsvL3RoZSBzeW1ib2wgbWF5YmUgb2YgZ3JvdXAgQ1Agd2l0aCBvbmUgdmFyaWFibGVcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X3Jvb3RzKHJhcnIsIHBvd2VycywgbWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGNvcmUuVXRpbHMuaXNBcnJheShzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyciA9IHN5bWJvbDtcclxuICAgICAgICAgICAgICAgIHZhciByYXJyID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvd2VycyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0X3Bvd2VyID0gMDtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwYXJyLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZiA9IHBhcnJbaV1bMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3cgPSBwYXJyW2ldWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHBvdyAtIGxhc3RfcG93ZXIgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaW5zZXJ0IHRoZSB6ZXJvc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBkOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhcnIudW5zaGlmdCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmFyci51bnNoaWZ0KGNvZWZmKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihwb3cgIT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvd2Vycy5wdXNoKHBvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9wb3dlciA9IHBvdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseSh1bmRlZmluZWQsIHBvd2Vycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldF9yb290cyhyYXJyLCBwb3dlcnMsIG1heCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5leGNlcHRpb25zLk5lcmRhbWVyVHlwZUVycm9yKCdDYW5ub3QgY2FsY3VsYXRlIHJvb3RzLiBTeW1ib2wgbXVzdCBiZSBhIHBvbHlub21pYWwhJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGNyb290cyhyYXJyLCBwb3dlcnMsIG1heCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIE1BWERFR1JFRSA9IDEwMDsgLy8gRGVncmVlIG9mIGxhcmdlc3QgcG9seW5vbWlhbCBhY2NlcHRlZCBieSB0aGlzIHNjcmlwdC5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGEgY2xvbmUgb2YgdGhlIGNvZWZmaWNpZW50cyBiZWZvcmUgYXBwZW5kaW5nIHRoZSBtYXggcG93ZXJcclxuICAgICAgICAgICAgICAgIHZhciBwID0gcmFyci5zbGljZSgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEaXZpZGUgdGhlIHN0cmluZyB1cCBpbnRvIGl0cyBpbmRpdmlkdWFsIGVudHJpZXMsIHdoaWNoLS1wcmVzdW1hYmx5LS1hcmUgc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2VcclxuICAgICAgICAgICAgICAgIHJhcnIudW5zaGlmdChtYXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKG1heCA+IE1BWERFR1JFRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLmV4Y2VwdGlvbnMuVmFsdWVMaW1pdEV4Y2VlZGVkRXJyb3IoXCJUaGlzIHV0aWxpdHkgYWNjZXB0cyBwb2x5bm9taWFscyBvZiBkZWdyZWUgdXAgdG8gXCIgKyBNQVhERUdSRUUgKyBcIi4gXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB6ZXJvaSA9IFtdLCAvLyBWZWN0b3Igb2YgaW1hZ2luYXJ5IGNvbXBvbmVudHMgb2Ygcm9vdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVncmVlUGFyID0ge307ICAgIC8vIGRlZ3JlZVBhciBpcyBhIGR1bW15IHZhcmlhYmxlIGZvciBwYXNzaW5nIHRoZSBwYXJhbWV0ZXIgUE9MWURFR1JFRSBieSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgIGRlZ3JlZVBhci5EZWdyZWUgPSBtYXg7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB6ZXJvaS5wdXNoKDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHplcm9yID0gemVyb2kuc2xpY2UoMCk7IC8vIFZlY3RvciBvZiByZWFsIGNvbXBvbmVudHMgb2Ygcm9vdHNcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSByb290c1xyXG4gICAgICAgICAgICAgICAgLy8tLT4gQmVnaW4gSmVua2lucy1UcmF1YlxyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgKiBBIHZlcmJhdGltIGNvcHkgb2YgTXIuIERhdmlkIEJpbm5lcidzIEplbmtpbnMtVHJhdWIgcG9ydFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBRdWFkU0RfYWsxKE5OLCB1LCB2LCBwLCBxLCBpUGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGl2aWRlcyBwIGJ5IHRoZSBxdWFkcmF0aWMgMSwgdSwgdiBwbGFjaW5nIHRoZSBxdW90aWVudCBpbiBxIGFuZCB0aGUgcmVtYWluZGVyIGluIGEsIGJcclxuICAgICAgICAgICAgICAgICAgICAvLyBpUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgaW4gdGhlIHR3byBwYXJhbWV0ZXJzLS1hIGFuZCBiLS1ieSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICBxWzBdID0gaVBhci5iID0gcFswXTtcclxuICAgICAgICAgICAgICAgICAgICBxWzFdID0gaVBhci5hID0gLSh1ICogaVBhci5iKSArIHBbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDI7IGkgPCBOTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFbaV0gPSAtKHUgKiBpUGFyLmEgKyB2ICogaVBhci5iKSArIHBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuYiA9IGlQYXIuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5hID0gcVtpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGNTQ19hazEoREJMX0VQU0lMT04sIE4sIGEsIGIsIGlQYXIsIEssIHUsIHYsIHFrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByb3V0aW5lIGNhbGN1bGF0ZXMgc2NhbGFyIHF1YW50aXRpZXMgdXNlZCB0byBjb21wdXRlIHRoZSBuZXh0IEsgcG9seW5vbWlhbCBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyBuZXcgZXN0aW1hdGVzIG9mIHRoZSBxdWFkcmF0aWMgY29lZmZpY2llbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGNTQyAtXHRpbnRlZ2VyIHZhcmlhYmxlIHNldCBoZXJlIGluZGljYXRpbmcgaG93IHRoZSBjYWxjdWxhdGlvbnMgYXJlIG5vcm1hbGl6ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBvdmVyZmxvdy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgaW4gdGhlIG5pbmUgcGFyYW1ldGVycy0tYTEsIGEzLCBhNywgYywgZCwgZSwgZiwgZywgYW5kIGggLS1ieSByZWZlcmVuY2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2RQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyB0aGUgdHdvIHBhcmFtZXRlcnMtLWMgYW5kIGQtLWludG8gUXVhZFNEX2FrMSBieSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2RQYXIgPSBuZXcgT2JqZWN0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUWVBFID0gMyBpbmRpY2F0ZXMgdGhlIHF1YWRyYXRpYyBpcyBhbG1vc3QgYSBmYWN0b3Igb2YgS1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtRmxhZyA9IDM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN5bnRoZXRpYyBkaXZpc2lvbiBvZiBLIGJ5IHRoZSBxdWFkcmF0aWMgMSwgdSwgdlxyXG4gICAgICAgICAgICAgICAgICAgIHNkUGFyLmIgPSBzZFBhci5hID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgIFF1YWRTRF9hazEoTiwgdSwgdiwgSywgcWssIHNkUGFyKTtcclxuICAgICAgICAgICAgICAgICAgICBpUGFyLmMgPSBzZFBhci5hO1xyXG4gICAgICAgICAgICAgICAgICAgIGlQYXIuZCA9IHNkUGFyLmI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGlQYXIuYykgPD0gKDEwMC4wICogREJMX0VQU0lMT04gKiBNYXRoLmFicyhLW04gLSAxXSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGlQYXIuZCkgPD0gKDEwMC4wICogREJMX0VQU0lMT04gKiBNYXRoLmFicyhLW04gLSAyXSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR1bUZsYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpUGFyLmggPSB2ICogYjtcclxuICAgICAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhpUGFyLmQpID49IE1hdGguYWJzKGlQYXIuYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVFlQRSA9IDIgaW5kaWNhdGVzIHRoYXQgYWxsIGZvcm11bGFzIGFyZSBkaXZpZGVkIGJ5IGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtRmxhZyA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuZSA9IGEgLyAoaVBhci5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5mID0gKGlQYXIuYykgLyAoaVBhci5kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5nID0gdSAqIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuYTMgPSAoaVBhci5lKSAqICgoaVBhci5nKSArIGEpICsgKGlQYXIuaCkgKiAoYiAvIChpUGFyLmQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5hMSA9IC1hICsgKGlQYXIuZikgKiBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmE3ID0gKGlQYXIuaCkgKyAoKGlQYXIuZikgKyB1KSAqIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUWVBFID0gMSBpbmRpY2F0ZXMgdGhhdCBhbGwgZm9ybXVsYXMgYXJlIGRpdmlkZWQgYnkgYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVtRmxhZyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuZSA9IGEgLyAoaVBhci5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5mID0gKGlQYXIuZCkgLyAoaVBhci5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5nID0gKGlQYXIuZSkgKiB1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmEzID0gKGlQYXIuZSkgKiBhICsgKChpUGFyLmcpICsgKGlQYXIuaCkgLyAoaVBhci5jKSkgKiBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmExID0gLShhICogKChpUGFyLmQpIC8gKGlQYXIuYykpKSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuYTcgPSAoaVBhci5nKSAqIChpUGFyLmQpICsgKGlQYXIuaCkgKiAoaVBhci5mKSArIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdW1GbGFnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5leHRLX2FrMShEQkxfRVBTSUxPTiwgTiwgdEZsYWcsIGEsIGIsIGlQYXIsIEssIHFrLCBxcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGVzIHRoZSBuZXh0IEsgcG9seW5vbWlhbHMgdXNpbmcgdGhlIHNjYWxhcnMgY29tcHV0ZWQgaW4gY2FsY1NDX2FrMVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlQYXIgaXMgYSBkdW1teSB2YXJpYWJsZSBmb3IgcGFzc2luZyBpbiB0aHJlZSBwYXJhbWV0ZXJzLS1hMSwgYTMsIGFuZCBhN1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRGbGFnID09IDMpIHtcdC8vIFVzZSB1bnNjYWxlZCBmb3JtIG9mIHRoZSByZWN1cnJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEtbMV0gPSBLWzBdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAyOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLW2ldID0gcWtbaSAtIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSAoKHRGbGFnID09IDEpID8gYiA6IGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKGlQYXIuYTEpID4gKDEwLjAgKiBEQkxfRVBTSUxPTiAqIE1hdGguYWJzKHRlbXApKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2Ugc2NhbGVkIGZvcm0gb2YgdGhlIHJlY3VycmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5hNyAvPSBpUGFyLmExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmEzIC89IGlQYXIuYTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEtbMF0gPSBxcFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgS1sxXSA9IC0ocXBbMF0gKiBpUGFyLmE3KSArIHFwWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAyOyBpIDwgTjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS1tpXSA9IC0ocXBbaSAtIDFdICogaVBhci5hNykgKyBxa1tpIC0gMl0gKiBpUGFyLmEzICsgcXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhMSBpcyBuZWFybHkgemVybywgdGhlbiB1c2UgYSBzcGVjaWFsIGZvcm0gb2YgdGhlIHJlY3VycmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgS1swXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgS1sxXSA9IC0ocXBbMF0gKiBpUGFyLmE3KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMjsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS1tpXSA9IC0ocXBbaSAtIDFdICogaVBhci5hNykgKyBxa1tpIC0gMl0gKiBpUGFyLmEzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBuZXdlc3RfYWsxKHRGbGFnLCBpUGFyLCBhLCBhMSwgYTMsIGE3LCBiLCBjLCBkLCBmLCBnLCBoLCB1LCB2LCBLLCBOLCBwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXcgZXN0aW1hdGVzIG9mIHRoZSBxdWFkcmF0aWMgY29lZmZpY2llbnRzIHVzaW5nIHRoZSBzY2FsYXJzIGNvbXB1dGVkIGluIGNhbGNTQ19hazFcclxuICAgICAgICAgICAgICAgICAgICAvLyBpUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgaW4gdGhlIHR3byBwYXJhbWV0ZXJzLS11dSBhbmQgdnYtLWJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlQYXIuYSA9IHV1LCBpUGFyLmIgPSB2dlxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYTQsIGE1LCBiMSwgYjIsIGMxLCBjMiwgYzMsIGM0LCB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlQYXIuYiA9IGlQYXIuYSA9IDAuMDsvLyBUaGUgcXVhZHJhdGljIGlzIHplcm9lZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZih0RmxhZyAhPSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRGbGFnICE9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE0ID0gYSArIHUgKiBiICsgaCAqIGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhNSA9IGMgKyAodSArIHYgKiBmKSAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhNCA9IChhICsgZykgKiBmICsgaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE1ID0gKGYgKyB1KSAqIGMgKyB2ICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgbmV3IHF1YWRyYXRpYyBjb2VmZmljaWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSAtKEtbTiAtIDFdIC8gcFtOXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gLShLW04gLSAyXSArIGIxICogcFtOIC0gMV0pIC8gcFtOXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYzEgPSB2ICogYjIgKiBhMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYzIgPSBiMSAqIGE3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjMyA9IGIxICogYjEgKiBhMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYzQgPSAtKGMyICsgYzMpICsgYzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSAtYzQgKyBhNSArIGIxICogYTQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRlbXAgIT0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmEgPSAtKCh1ICogKGMzICsgYzIpICsgdiAqIChiMSAqIGExICsgYjIgKiBhNykpIC8gdGVtcCkgKyB1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5iID0gdiAqICgxLjAgKyBjNCAvIHRlbXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBRdWFkX2FrMShhLCBiMSwgYywgaVBhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZXMgdGhlIHplcm9zIG9mIHRoZSBxdWFkcmF0aWMgYSpaXjIgKyBiMSpaICsgY1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBxdWFkcmF0aWMgZm9ybXVsYSwgbW9kaWZpZWQgdG8gYXZvaWQgb3ZlcmZsb3csIGlzIHVzZWQgdG8gZmluZCB0aGUgbGFyZ2VyIHplcm8gaWYgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gemVyb3MgYXJlIHJlYWwgYW5kIGJvdGggemVyb3MgYXJlIGNvbXBsZXguIFRoZSBzbWFsbGVyIHJlYWwgemVybyBpcyBmb3VuZCBkaXJlY3RseSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb2R1Y3Qgb2YgdGhlIHplcm9zIGMvYS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaVBhciBpcyBhIGR1bW15IHZhcmlhYmxlIGZvciBwYXNzaW5nIGluIHRoZSBmb3VyIHBhcmFtZXRlcnMtLXNyLCBzaSwgbHIsIGFuZCBsaS0tYnkgcmVmZXJlbmNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiLCBkLCBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlQYXIuc3IgPSBpUGFyLnNpID0gaVBhci5sciA9IGlQYXIubGkgPSAwLjA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLnNyID0gKChiMSAhPSAwKSA/IC0oYyAvIGIxKSA6IGlQYXIuc3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGMgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmxyID0gLShiMSAvIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGRpc2NyaW1pbmFudCBhdm9pZGluZyBvdmVyZmxvd1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBiMSAvIDIuMDtcclxuICAgICAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhiKSA8IE1hdGguYWJzKGMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAoKGMgPj0gMCkgPyBhIDogLWEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gLWUgKyBiICogKGIgLyBNYXRoLmFicyhjKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBNYXRoLnNxcnQoTWF0aC5hYnMoZSkpICogTWF0aC5zcXJ0KE1hdGguYWJzKGMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAtKChhIC8gYikgKiAoYyAvIGIpKSArIDEuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IE1hdGguc3FydChNYXRoLmFicyhlKSkgKiAoTWF0aC5hYnMoYikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWwgemVyb3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9ICgoYiA+PSAwKSA/IC1kIDogZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIubHIgPSAoLWIgKyBkKSAvIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuc3IgPSAoKGlQYXIubHIgIT0gMCkgPyAoYyAvIChpUGFyLmxyKSkgLyBhIDogaVBhci5zcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wbGV4IGNvbmp1Z2F0ZSB6ZXJvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmxyID0gaVBhci5zciA9IC0oYiAvIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLnNpID0gTWF0aC5hYnMoZCAvIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmxpID0gLShpUGFyLnNpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFF1YWRJVF9hazEoREJMX0VQU0lMT04sIE4sIGlQYXIsIHV1LCB2diwgcXAsIE5OLCBzZFBhciwgcCwgcWssIGNhbGNQYXIsIEspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZS1zaGlmdCBLLXBvbHlub21pYWwgaXRlcmF0aW9uIGZvciBhIHF1YWRyYXRpYyBmYWN0b3IgY29udmVyZ2VzIG9ubHkgaWYgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gemVyb3MgYXJlIGVxdWltb2R1bGFyIG9yIG5lYXJseSBzby5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgaW4gdGhlIGZpdmUgcGFyYW1ldGVycy0tTlosIGx6aSwgbHpyLCBzemksIGFuZCBzenItLWJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNkUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgdGhlIHR3byBwYXJhbWV0ZXJzLS1hIGFuZCBiLS1pbiBieSByZWZlcmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgdGhlIG5pbmUgcGFyYW1ldGVycy0tYTEsIGEzLCBhNywgYywgZCwgZSwgZiwgZywgYW5kIGggLS1pbiBieSByZWZlcmVuY2VcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcVBhciBpcyBhIGR1bW15IHZhcmlhYmxlIGZvciBwYXNzaW5nIHRoZSBmb3VyIHBhcmFtZXRlcnMtLXN6ciwgc3ppLCBsenIsIGFuZCBsemktLWludG8gUXVhZF9hazEgYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHFQYXIgPSBuZXcgT2JqZWN0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZSwgbXAsIG9tcCwgcmVsc3RwLCB0LCB1LCB1aSwgdiwgdmksIHptLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSwgaiA9IDAsIHRGbGFnLCB0cmllZEZsYWcgPSAwOyAgIC8vIEludGVnZXIgdmFyaWFibGVzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlQYXIuTlogPSAwOy8vIE51bWJlciBvZiB6ZXJvcyBmb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgIHUgPSB1dTsgLy8gdXUgYW5kIHZ2IGFyZSBjb2VmZmljaWVudHMgb2YgdGhlIHN0YXJ0aW5nIHF1YWRyYXRpY1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSB2djtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxUGFyLmxpID0gcVBhci5sciA9IHFQYXIuc2kgPSBxUGFyLnNyID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBRdWFkX2FrMSgxLjAsIHUsIHYsIHFQYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLnN6ciA9IHFQYXIuc3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQYXIuc3ppID0gcVBhci5zaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5senIgPSBxUGFyLmxyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpUGFyLmx6aSA9IHFQYXIubGk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaWYgcm9vdHMgb2YgdGhlIHF1YWRyYXRpYyBhcmUgcmVhbCBhbmQgbm90IGNsb3NlIHRvIG11bHRpcGxlIG9yIG5lYXJseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlcXVhbCBhbmQgb2Ygb3Bwb3NpdGUgc2lnbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMoTWF0aC5hYnMoaVBhci5zenIpIC0gTWF0aC5hYnMoaVBhci5senIpKSA+IDAuMDEgKiBNYXRoLmFicyhpUGFyLmx6cikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIHBvbHlub21pYWwgYnkgcXVhZHJhdGljIHN5bnRoZXRpYyBkaXZpc2lvblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgUXVhZFNEX2FrMShOTiwgdSwgdiwgcCwgcXAsIHNkUGFyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1wID0gTWF0aC5hYnMoLSgoaVBhci5zenIpICogKHNkUGFyLmIpKSArIChzZFBhci5hKSkgKyBNYXRoLmFicygoaVBhci5zemkpICogKHNkUGFyLmIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYSByaWdvcm91cyBib3VuZCBvbiB0aGUgcm91bmRpbmcgZXJyb3IgaW4gZXZhbHVhdGluZyBwXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB6bSA9IE1hdGguc3FydChNYXRoLmFicyh2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVlID0gMi4wICogTWF0aC5hYnMocXBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gLSgoaVBhci5zenIpICogKHNkUGFyLmIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWUgPSBlZSAqIHptICsgTWF0aC5hYnMocXBbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZSA9IGVlICogem0gKyBNYXRoLmFicyh0ICsgc2RQYXIuYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVlID0gKDkuMCAqIGVlICsgMi4wICogTWF0aC5hYnModCkgLSA3LjAgKiAoTWF0aC5hYnMoKHNkUGFyLmEpICsgdCkgKyB6bSAqIE1hdGguYWJzKChzZFBhci5iKSkpKSAqIERCTF9FUFNJTE9OO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uIGhhcyBjb252ZXJnZWQgc3VmZmljaWVudGx5IGlmIHRoZSBwb2x5bm9taWFsIHZhbHVlIGlzIGxlc3MgdGhhbiAyMCB0aW1lcyB0aGlzIGJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1wIDw9IDIwLjAgKiBlZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5OWiA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGl0ZXJhdGlvbiBhZnRlciAyMCBzdGVwc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqID4gMjApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaiA+PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigocmVsc3RwIDw9IDAuMDEpICYmIChtcCA+PSBvbXApICYmICghdHJpZWRGbGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY2x1c3RlciBhcHBlYXJzIHRvIGJlIHN0YWxsaW5nIHRoZSBjb252ZXJnZW5jZS4gRml2ZSBmaXhlZCBzaGlmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbiB3aXRoIGEgdSwgdiBjbG9zZSB0byB0aGUgY2x1c3Rlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxzdHAgPSAoKHJlbHN0cCA8IERCTF9FUFNJTE9OKSA/IE1hdGguc3FydChEQkxfRVBTSUxPTikgOiBNYXRoLnNxcnQocmVsc3RwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSAtPSB1ICogcmVsc3RwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgKz0gdiAqIHJlbHN0cDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVhZFNEX2FrMShOTiwgdSwgdiwgcCwgcXAsIHNkUGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCA1OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdEZsYWcgPSBjYWxjU0NfYWsxKERCTF9FUFNJTE9OLCBOLCBzZFBhci5hLCBzZFBhci5iLCBjYWxjUGFyLCBLLCB1LCB2LCBxayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRLX2FrMShEQkxfRVBTSUxPTiwgTiwgdEZsYWcsIHNkUGFyLmEsIHNkUGFyLmIsIGNhbGNQYXIsIEssIHFrLCBxcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmllZEZsYWcgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbXAgPSBtcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBuZXh0IEsgcG9seW5vbWlhbCBhbmQgbmV3IHUgYW5kIHZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdEZsYWcgPSBjYWxjU0NfYWsxKERCTF9FUFNJTE9OLCBOLCBzZFBhci5hLCBzZFBhci5iLCBjYWxjUGFyLCBLLCB1LCB2LCBxayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRLX2FrMShEQkxfRVBTSUxPTiwgTiwgdEZsYWcsIHNkUGFyLmEsIHNkUGFyLmIsIGNhbGNQYXIsIEssIHFrLCBxcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRGbGFnID0gY2FsY1NDX2FrMShEQkxfRVBTSUxPTiwgTiwgc2RQYXIuYSwgc2RQYXIuYiwgY2FsY1BhciwgSywgdSwgdiwgcWspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdlc3RfYWsxKHRGbGFnLCBzZFBhciwgc2RQYXIuYSwgY2FsY1Bhci5hMSwgY2FsY1Bhci5hMywgY2FsY1Bhci5hNywgc2RQYXIuYiwgY2FsY1Bhci5jLCBjYWxjUGFyLmQsIGNhbGNQYXIuZiwgY2FsY1Bhci5nLCBjYWxjUGFyLmgsIHUsIHYsIEssIE4sIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1aSA9IHNkUGFyLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpID0gc2RQYXIuYjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHZpIGlzIHplcm8sIHRoZSBpdGVyYXRpb24gaXMgbm90IGNvbnZlcmdpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmkgIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsc3RwID0gTWF0aC5hYnMoKC12ICsgdmkpIC8gdmkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHVpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHZpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHZpICE9IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBSZWFsSVRfYWsxKERCTF9FUFNJTE9OLCBpUGFyLCBzZFBhciwgTiwgcCwgTk4sIHFwLCBLLCBxaykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlLXNoaWZ0IEgtcG9seW5vbWlhbCBpdGVyYXRpb24gZm9yIGEgcmVhbCB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3NzXHQtIHN0YXJ0aW5nIGl0ZXJhdGUgPSBzZFBhci5hXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTlpcdFx0LSBudW1iZXIgb2YgemVyb3MgZm91bmQgPSBpUGFyLk5aXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVtRmxhZ1x0LSBmbGFnIHRvIGluZGljYXRlIGEgcGFpciBvZiB6ZXJvcyBuZWFyIHJlYWwgYXhpcywgcmV0dXJuZWQgdG8gaUZsYWdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVlLCBrdiwgbXAsIG1zLCBvbXAsIHB2LCBzLCB0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtRmxhZywgaSwgaiwgbm0xID0gTiAtIDE7ICAgLy8gSW50ZWdlciB2YXJpYWJsZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaVBhci5OWiA9IGogPSBkdW1GbGFnID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzID0gc2RQYXIuYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKDsgOyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHYgPSBwWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXZhbHVhdGUgcCBhdCBzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFwWzBdID0gcHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IE5OOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFwW2ldID0gcHYgPSBwdiAqIHMgKyBwW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1wID0gTWF0aC5hYnMocHYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBhIHJpZ29yb3VzIGJvdW5kIG9uIHRoZSBlcnJvciBpbiBldmFsdWF0aW5nIHBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXMgPSBNYXRoLmFicyhzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWUgPSAwLjUgKiBNYXRoLmFicyhxcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IE5OOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVlID0gZWUgKiBtcyArIE1hdGguYWJzKHFwW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uIGhhcyBjb252ZXJnZWQgc3VmZmljaWVudGx5IGlmIHRoZSBwb2x5bm9taWFsIHZhbHVlIGlzIGxlc3MgdGhhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAyMCB0aW1lcyB0aGlzIGJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1wIDw9IDIwLjAgKiBEQkxfRVBTSUxPTiAqICgyLjAgKiBlZSAtIG1wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5OWiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUGFyLnN6ciA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUGFyLnN6aSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBpdGVyYXRpb24gYWZ0ZXIgMTAgc3RlcHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaiA+IDEwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqID49IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKChNYXRoLmFicyh0KSA8PSAwLjAwMSAqIE1hdGguYWJzKC10ICsgcykpICYmIChtcCA+IG9tcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGNsdXN0ZXIgb2YgemVyb3MgbmVhciB0aGUgcmVhbCBheGlzIGhhcyBiZWVuIGVuY291bnRlcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB3aXRoIGlGbGFnIHNldCB0byBpbml0aWF0ZSBhIHF1YWRyYXRpYyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtRmxhZyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVBhci5hID0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gRW5kIGlmICgoZmFicyh0KSA8PSAwLjAwMSpmYWJzKHMgLSB0KSkgJiYgKG1wID4gb21wKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAvL0VuZCBpZiAoaiA+PSAyKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGlmIHRoZSBwb2x5bm9taWFsIHZhbHVlIGhhcyBpbmNyZWFzZWQgc2lnbmlmaWNhbnRseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbXAgPSBtcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdCwgdGhlIG5leHQgcG9seW5vbWlhbCBhbmQgdGhlIG5ldyBpdGVyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFrWzBdID0ga3YgPSBLWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCBOOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFrW2ldID0ga3YgPSBrdiAqIHMgKyBLW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhrdikgPiBNYXRoLmFicyhLW25tMV0pICogMTAuMCAqIERCTF9FUFNJTE9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNjYWxlZCBmb3JtIG9mIHRoZSByZWN1cnJlbmNlIGlmIHRoZSB2YWx1ZSBvZiBLIGF0IHMgaXMgbm9uLXplcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAtKHB2IC8ga3YpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS1swXSA9IHFwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgS1tpXSA9IHQgKiBxa1tpIC0gMV0gKyBxcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB1bnNjYWxlZCBmb3JtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLWzBdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgTjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbaV0gPSBxa1tpIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGt2ID0gS1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAxOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrdiA9IGt2ICogcyArIEtbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICgoTWF0aC5hYnMoa3YpID4gKE1hdGguYWJzKEtbbm0xXSkgKiAxMC4wICogREJMX0VQU0lMT04pKSA/IC0ocHYgLyBrdikgOiAwLjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkdW1GbGFnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZ4c2hmcl9hazEoREJMX0VQU0lMT04sIE1EUDEsIEwyLCBzciwgdiwgSywgTiwgcCwgTk4sIHFwLCB1LCBpUGFyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGVzIHVwIHRvIEwyIGZpeGVkIHNoaWZ0IEstcG9seW5vbWlhbHMsIHRlc3RpbmcgZm9yIGNvbnZlcmdlbmNlIGluIHRoZSBsaW5lYXIgb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBxdWFkcmF0aWMgY2FzZS4gSW5pdGlhdGVzIG9uZSBvZiB0aGUgdmFyaWFibGUgc2hpZnQgaXRlcmF0aW9ucyBhbmQgcmV0dXJucyB3aXRoIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bWJlciBvZiB6ZXJvcyBmb3VuZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMMlx0bGltaXQgb2YgZml4ZWQgc2hpZnQgc3RlcHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgaW4gdGhlIGZpdmUgcGFyYW1ldGVycy0tTlosIGx6aSwgbHpyLCBzemksIGFuZCBzenItLWJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5aXHRudW1iZXIgb2YgemVyb3MgZm91bmRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2RQYXIgPSBuZXcgT2JqZWN0KCksIC8vIHNkUGFyIGlzIGEgZHVtbXkgdmFyaWFibGUgZm9yIHBhc3NpbmcgdGhlIHR3byBwYXJhbWV0ZXJzLS1hIGFuZCBiLS1pbnRvIFF1YWRTRF9hazEgYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjUGFyID0gbmV3IE9iamVjdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY1BhciBpcyBhIGR1bW15IHZhcmlhYmxlIGZvciBwYXNzaW5nIHRoZSBuaW5lIHBhcmFtZXRlcnMtLWExLCBhMywgYTcsIGMsIGQsIGUsIGYsIGcsIGFuZCBoIC0taW50byBjYWxjU0NfYWsxIGJ5IHJlZmVyZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFrID0gbmV3IEFycmF5KE1EUDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZrID0gbmV3IEFycmF5KE1EUDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSwgYiwgYmV0YXMsIGJldGF2LCBvc3MsIG90cywgb3R2LCBvdnYsIHMsIHNzLCB0cywgdHNzLCB0diwgdHZ2LCB1aSwgdmksIHZ2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmZsYWcsIGksIGlGbGFnID0gMSwgaiwgc3Bhc3MsIHN0cnksIHRGbGFnLCB2cGFzcywgdnRyeTsgICAgIC8vIEludGVnZXIgdmFyaWFibGVzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlQYXIuTlogPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGJldGF2ID0gYmV0YXMgPSAwLjI1O1xyXG4gICAgICAgICAgICAgICAgICAgIG9zcyA9IHNyO1xyXG4gICAgICAgICAgICAgICAgICAgIG92diA9IHY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vRXZhbHVhdGUgcG9seW5vbWlhbCBieSBzeW50aGV0aWMgZGl2aXNpb25cclxuICAgICAgICAgICAgICAgICAgICBzZFBhci5iID0gc2RQYXIuYSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBRdWFkU0RfYWsxKE5OLCB1LCB2LCBwLCBxcCwgc2RQYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBzZFBhci5hO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBzZFBhci5iO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGNQYXIuaCA9IGNhbGNQYXIuZyA9IGNhbGNQYXIuZiA9IGNhbGNQYXIuZSA9IGNhbGNQYXIuZCA9IGNhbGNQYXIuYyA9IGNhbGNQYXIuYTcgPSBjYWxjUGFyLmEzID0gY2FsY1Bhci5hMSA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICB0RmxhZyA9IGNhbGNTQ19hazEoREJMX0VQU0lMT04sIE4sIGEsIGIsIGNhbGNQYXIsIEssIHUsIHYsIHFrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgTDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmZmxhZyA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbmV4dCBLIHBvbHlub21pYWwgYW5kIGVzdGltYXRlIHZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dEtfYWsxKERCTF9FUFNJTE9OLCBOLCB0RmxhZywgYSwgYiwgY2FsY1BhciwgSywgcWssIHFwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdEZsYWcgPSBjYWxjU0NfYWsxKERCTF9FUFNJTE9OLCBOLCBhLCBiLCBjYWxjUGFyLCBLLCB1LCB2LCBxayk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2Ugc2RQYXIgZm9yIHBhc3NpbmcgaW4gdXUgYW5kIHZ2IGluc3RlYWQgb2YgZGVmaW5pbmcgYSBicmFuZC1uZXcgdmFyaWFibGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNkUGFyLmEgPSB1aSwgc2RQYXIuYiA9IHZpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2VzdF9hazEodEZsYWcsIHNkUGFyLCBhLCBjYWxjUGFyLmExLCBjYWxjUGFyLmEzLCBjYWxjUGFyLmE3LCBiLCBjYWxjUGFyLmMsIGNhbGNQYXIuZCwgY2FsY1Bhci5mLCBjYWxjUGFyLmcsIGNhbGNQYXIuaCwgdSwgdiwgSywgTiwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gc2RQYXIuYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdnYgPSB2aSA9IHNkUGFyLmI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSBzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNzID0gKChLW04gLSAxXSAhPSAwLjApID8gLShwW05dIC8gS1tOIC0gMV0pIDogMC4wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHMgPSB0diA9IDEuMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKChqICE9IDApICYmICh0RmxhZyAhPSAzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSBtZWFzdXJlcyBvZiBjb252ZXJnZW5jZSBvZiBzIGFuZCB2IHNlcXVlbmNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHYgPSAoKHZ2ICE9IDAuMCkgPyBNYXRoLmFicygodnYgLSBvdnYpIC8gdnYpIDogdHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHMgPSAoKHNzICE9IDAuMCkgPyBNYXRoLmFicygoc3MgLSBvc3MpIC8gc3MpIDogdHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGRlY3JlYXNpbmcsIG11bHRpcGx5IHRoZSB0d28gbW9zdCByZWNlbnQgY29udmVyZ2VuY2UgbWVhc3VyZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR2diA9ICgodHYgPCBvdHYpID8gdHYgKiBvdHYgOiAxLjApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHNzID0gKCh0cyA8IG90cykgPyB0cyAqIG90cyA6IDEuMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSB3aXRoIGNvbnZlcmdlbmNlIGNyaXRlcmlhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2cGFzcyA9ICgodHZ2IDwgYmV0YXYpID8gMSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhc3MgPSAoKHRzcyA8IGJldGFzKSA/IDEgOiAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigoc3Bhc3MpIHx8ICh2cGFzcykpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXQgbGVhc3Qgb25lIHNlcXVlbmNlIGhhcyBwYXNzZWQgdGhlIGNvbnZlcmdlbmNlIHRlc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdmFyaWFibGVzIGJlZm9yZSBpdGVyYXRpbmdcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2a1tpXSA9IEtbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hvb3NlIGl0ZXJhdGlvbiBhY2NvcmRpbmcgdG8gdGhlIGZhc3Rlc3QgY29udmVyZ2luZyBzZXF1ZW5jZVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJ5ID0gdnRyeSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcig7IDsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKChmZmxhZyAmJiAoKGZmbGFnID0gMCkgPT0gMCkpICYmICgoc3Bhc3MpICYmICghdnBhc3MgfHwgKHRzcyA8IHR2dikpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOy8vIERvIG5vdGhpbmcuIFByb3ZpZGVzIGEgcXVpY2sgXCJzaG9ydCBjaXJjdWl0XCIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRdWFkSVRfYWsxKERCTF9FUFNJTE9OLCBOLCBpUGFyLCB1aSwgdmksIHFwLCBOTiwgc2RQYXIsIHAsIHFrLCBjYWxjUGFyLCBLKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBzZFBhci5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHNkUGFyLmI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoKGlQYXIuTlopID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUXVhZHJhdGljIGl0ZXJhdGlvbiBoYXMgZmFpbGVkLiBGbGFnIHRoYXQgaXQgaGFzIGJlZW4gdHJpZWQgYW5kIGRlY3JlYXNlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVyZ2VuY2UgY3JpdGVyaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpRmxhZyA9IHZ0cnkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmV0YXYgKj0gMC4yNTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgbGluZWFyIGl0ZXJhdGlvbiBpZiBpdCBoYXMgbm90IGJlZW4gdHJpZWQgYW5kIHRoZSBzIHNlcXVlbmNlIGlzIGNvbnZlcmdpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0cnkgfHwgKCFzcGFzcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpRmxhZyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBOOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbaV0gPSBzdmtbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mZmxhZyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlGbGFnICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBzZFBhciBmb3IgcGFzc2luZyBpbiBzIGluc3RlYWQgb2YgZGVmaW5pbmcgYSBicmFuZC1uZXcgdmFyaWFibGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZFBhci5hID0gc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2RQYXIuYSA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpRmxhZyA9IFJlYWxJVF9hazEoREJMX0VQU0lMT04sIGlQYXIsIHNkUGFyLCBOLCBwLCBOTiwgcXAsIEssIHFrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzZFBhci5hO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKChpUGFyLk5aKSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpbmVhciBpdGVyYXRpb24gaGFzIGZhaWxlZC4gRmxhZyB0aGF0IGl0IGhhcyBiZWVuIHRyaWVkIGFuZCBkZWNyZWFzZSB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcmdlbmNlIGNyaXRlcmlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyeSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXRhcyAqPSAwLjI1O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlGbGFnICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBsaW5lYXIgaXRlcmF0aW9uIHNpZ25hbHMgYW4gYWxtb3N0IGRvdWJsZSByZWFsIHplcm8sIGF0dGVtcHQgcXVhZHJhdGljIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gLShzICsgcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmkgPSBzICogcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IE47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbaV0gPSBzdmtbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgcXVhZHJhdGljIGl0ZXJhdGlvbiBpZiBpdCBoYXMgbm90IGJlZW4gdHJpZWQgYW5kIHRoZSB2IHNlcXVlbmNlIGlzIGNvbnZlcmdpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXZwYXNzIHx8IHZ0cnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcdFx0Ly8gQnJlYWsgb3V0IG9mIGluZmluaXRlIGZvciBsb29wXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtY29tcHV0ZSBxcCBhbmQgc2NhbGFyIHZhbHVlcyB0byBjb250aW51ZSB0aGUgc2Vjb25kIHN0YWdlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFF1YWRTRF9hazEoTk4sIHUsIHYsIHAsIHFwLCBzZFBhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHNkUGFyLmE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHNkUGFyLmI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRGbGFnID0gY2FsY1NDX2FrMShEQkxfRVBTSUxPTiwgTiwgYSwgYiwgY2FsY1BhciwgSywgdSwgdiwgcWspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92diA9IHZ2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvc3MgPSBzcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3R2ID0gdHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90cyA9IHRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcnBTb2x2ZShkZWdQYXIsIHAsIHplcm9yLCB6ZXJvaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBOID0gZGVnUGFyLkRlZ3JlZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJBREZBQyA9IDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYgLyAxODAsIC8vIERlZ3JlZXMtdG8tcmFkaWFucyBjb252ZXJzaW9uIGZhY3RvciA9IFBJLzE4MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTEIyID0gTWF0aC5MTjIsIC8vIER1bW15IHZhcmlhYmxlIHRvIGF2b2lkIHJlLWNhbGN1bGF0aW5nIHRoaXMgdmFsdWUgaW4gbG9vcCBiZWxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTURQMSA9IGRlZ1Bhci5EZWdyZWUgKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSyA9IG5ldyBBcnJheShNRFAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB0ID0gbmV3IEFycmF5KE1EUDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXAgPSBuZXcgQXJyYXkoTURQMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gbmV3IEFycmF5KE1EUDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcVBhciBpcyBhIGR1bW15IHZhcmlhYmxlIGZvciBwYXNzaW5nIHRoZSBmb3VyIHBhcmFtZXRlcnMtLXNyLCBzaSwgbHIsIGFuZCBsaS0tYnkgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxUGFyID0gbmV3IE9iamVjdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnhzaGZyX1BhciBpcyBhIGR1bW15IHZhcmlhYmxlIGZvciBwYXNzaW5nIHBhcmFtZXRlcnMgYnkgcmVmZXJlbmNlIDogTlosIGx6aSwgbHpyLCBzemksIHN6cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGeHNoZnJfUGFyID0gbmV3IE9iamVjdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm5kLCBEQkxfRVBTSUxPTiwgZGYsIGR4LCBmYWN0b3IsIGZmLCBtb2R1bGlfbWF4LCBtb2R1bGlfbWluLCBzYywgeCwgeG0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYSwgYmIsIGNjLCBzciwgdCwgdSwgeHh4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiwgamosIGwsIE5NMSwgTk4sIHplcm9rOy8vIEludGVnZXIgdmFyaWFibGVzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWFjaGluZSBlcHNpbG9uIGFuZCBzdG9yZSBpbiB0aGUgdmFyaWFibGUgREJMX0VQU0lMT04uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHRoaXMgdmFsdWUsIGp1c3QgdXNlIGV4aXN0aW5nIHZhcmlhYmxlcyByYXRoZXIgdGhhbiBjcmVhdGUgbmV3IG9uZXMgdGhhdCB3aWxsIGJlIHVzZWQgb25seSBmb3IgdGhpcyBjb2RlIGJsb2NrXHJcbiAgICAgICAgICAgICAgICAgICAgYWEgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEQkxfRVBTSUxPTiA9IGFhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYSAvPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYiA9IDEuMCArIGFhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShiYiA+IDEuMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBMTyA9IE51bWJlci5NSU5fVkFMVUUgLyBEQkxfRVBTSUxPTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvc3IgPSBNYXRoLmNvcyg5NC4wICogUkFERkFDKSwgLy8gPSAtMC4wNjk3NTY0NzRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbnIgPSBNYXRoLnNpbig5NC4wICogUkFERkFDKSwgLy8gPSAwLjk5NzU2NDA1XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4eCA9IE1hdGguc3FydCgwLjUpLCAvLyA9IDAuNzA3MTA2NzhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl5ID0gLXh4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBGeHNoZnJfUGFyLk5aID0gaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgRnhzaGZyX1Bhci5zenIgPSBGeHNoZnJfUGFyLnN6aSA9IEZ4c2hmcl9QYXIubHpyID0gRnhzaGZyX1Bhci5semkgPSAwLjA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB6ZXJvcyBhdCB0aGUgb3JpZ2luLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShwW05dID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgemVyb3Jbal0gPSB6ZXJvaVtqXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE4tLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBOTiA9IE4gKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyA+Pj4+PiBCZWdpbiBNYWluIExvb3AgPDw8PDxcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShOID49IDEpIHsgLy8gTWFpbiBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBhbGdvcml0aG0gZm9yIG9uZSB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKE4gPD0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBmaW5hbCB6ZXJvIG9yIHBhaXIgb2YgemVyb3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKE4gPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb3JbZGVnUGFyLkRlZ3JlZSAtIDFdID0gLShwWzFdIC8gcFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb2lbZGVnUGFyLkRlZ3JlZSAtIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFQYXIubGkgPSBxUGFyLmxyID0gcVBhci5zaSA9IHFQYXIuc3IgPSAwLjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUXVhZF9hazEocFswXSwgcFsxXSwgcFsyXSwgcVBhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb3JbZGVnUGFyLkRlZ3JlZSAtIDJdID0gcVBhci5zcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJvaVtkZWdQYXIuRGVncmVlIC0gMl0gPSBxUGFyLnNpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9yW2RlZ1Bhci5EZWdyZWUgLSAxXSA9IHFQYXIubHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb2lbZGVnUGFyLkRlZ3JlZSAtIDFdID0gcVBhci5saTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBsYXJnZXN0IGFuZCBzbWFsbGVzdCBtb2R1bGkgb2YgdGhlIGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGlfbWF4ID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGlfbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IE5OOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLmFicyhwW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHggPiBtb2R1bGlfbWF4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsaV9tYXggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoKHggIT0gMCkgJiYgKHggPCBtb2R1bGlfbWluKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGlfbWluID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2NhbGUgaWYgdGhlcmUgYXJlIGxhcmdlIG9yIHZlcnkgc21hbGwgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGVzIGEgc2NhbGUgZmFjdG9yIHRvIG11bHRpcGx5IHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHBvbHlub21pYWwuIFRoZSBzY2FsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGRvbmUgdG8gYXZvaWQgb3ZlcmZsb3cgYW5kIHRvIGF2b2lkIHVuZGV0ZWN0ZWQgdW5kZXJmbG93IGludGVyZmVyaW5nIHdpdGggdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcmdlbmNlIGNyaXRlcmlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZhY3RvciBpcyBhIHBvd2VyIG9mIHRoZSBiYXNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYyA9IExPIC8gbW9kdWxpX21pbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCgoc2MgPD0gMS4wKSAmJiAobW9kdWxpX21heCA+PSAxMCkpIHx8ICgoc2MgPiAxLjApICYmIChOdW1iZXIuTUFYX1ZBTFVFIC8gc2MgPj0gbW9kdWxpX21heCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9ICgoc2MgPT0gMCkgPyBOdW1iZXIuTUlOX1ZBTFVFIDogc2MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IE1hdGguZmxvb3IoTWF0aC5sb2coc2MpIC8gTEIyICsgMC41KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvciA9IE1hdGgucG93KDIuMCwgbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmYWN0b3IgIT0gMS4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgTk47IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtpXSAqPSBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbG93ZXIgYm91bmQgb24gbW9kdWxpIG9mIHplcm9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBOTjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHRbaV0gPSBNYXRoLmFicyhwW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHRbTl0gPSAtKHB0W05dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTk0xID0gTiAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHVwcGVyIGVzdGltYXRlIG9mIGJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLmV4cCgoTWF0aC5sb2coLXB0W05dKSAtIE1hdGgubG9nKHB0WzBdKSkgLyBOKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHB0W05NMV0gIT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgTmV3dG9uIHN0ZXAgYXQgdGhlIG9yaWdpbiBpcyBiZXR0ZXIsIHVzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeG0gPSAtcHRbTl0gLyBwdFtOTTFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9ICgoeG0gPCB4KSA/IHhtIDogeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENob3AgdGhlIGludGVydmFsICgwLCB4KSB1bnRpbCBmZiA8PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHhtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeG0gPSAwLjEgKiB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmYgPSBwdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBOTjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmYgPSBmZiAqIHhtICsgcHRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoZmYgPiAwKTsgLy8gRW5kIGRvLXdoaWxlIGxvb3BcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gTmV3dG9uIGl0ZXJhdGlvbiB1bnRpbCB4IGNvbnZlcmdlcyB0byB0d28gZGVjaW1hbCBwbGFjZXNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmID0gZmYgPSBwdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBOOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZiA9IHggKiBmZiArIHB0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmID0geCAqIGRmICsgZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vIEVuZCBmb3IgaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmYgPSB4ICogZmYgKyBwdFtOXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gZmYgLyBkZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggLT0gZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoTWF0aC5hYnMoZHggLyB4KSA+IDAuMDA1KTsgLy8gRW5kIGRvLXdoaWxlIGxvb3BcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJuZCA9IHg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBkZXJpdmF0aXZlIGFzIHRoZSBpbml0aWFsIEsgcG9seW5vbWlhbCBhbmQgZG8gNSBzdGVwcyB3aXRoIG5vIHNoaWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBOOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLW2ldID0gKE4gLSBpKSAqIHBbaV0gLyBOO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBLWzBdID0gcFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWEgPSBwW05dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYiA9IHBbTk0xXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgemVyb2sgPSAoKEtbTk0xXSA9PSAwKSA/IDEgOiAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqaiA9IDA7IGpqIDwgNTsgamorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBLW05NMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih6ZXJvaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB1bnNjYWxlZCBmb3JtIG9mIHJlY3VycmVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgTk0xOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IE5NMSAtIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbal0gPSBLW2ogLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vIEVuZCBmb3IgaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9rID0gKChLW05NMV0gPT0gMCkgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VkIHNjYWxlZCBmb3JtIG9mIHJlY3VycmVuY2UgaWYgdmFsdWUgb2YgSyBhdCAwIGlzIG5vbnplcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gLWFhIC8gY2M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IE5NMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSBOTTEgLSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBLW2pdID0gdCAqIEtbaiAtIDFdICsgcFtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IC8vIEVuZCBmb3IgaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtbMF0gPSBwWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9rID0gKChNYXRoLmFicyhLW05NMV0pIDw9IE1hdGguYWJzKGJiKSAqIERCTF9FUFNJTE9OICogMTAuMCkgPyAxIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgSyBmb3IgcmVzdGFydHMgd2l0aCBuZXcgc2hpZnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBOOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wW2ldID0gS1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdG8gc2VsZWN0IHRoZSBxdWFkcmF0aWMgY29ycmVzcG9uZGluZyB0byBlYWNoIG5ldyBzaGlmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoamogPSAxOyBqaiA8PSAyMDsgamorKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1YWRyYXRpYyBjb3JyZXNwb25kcyB0byBhIGRvdWJsZSBzaGlmdCB0byBhIG5vbi1yZWFsIHBvaW50IGFuZCBpdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXggY29uanVnYXRlLiBUaGUgcG9pbnQgaGFzIG1vZHVsdXMgQk5EIGFuZCBhbXBsaXR1ZGUgcm90YXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnkgOTQgZGVncmVlcyBmcm9tIHRoZSBwcmV2aW91cyBzaGlmdC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4eHggPSAtKHNpbnIgKiB5eSkgKyBjb3NyICogeHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5eSA9IHNpbnIgKiB4eCArIGNvc3IgKiB5eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHh4ID0geHh4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3IgPSBibmQgKiB4eDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSAtKDIuMCAqIHNyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWNvbmQgc3RhZ2UgY2FsY3VsYXRpb24sIGZpeGVkIHF1YWRyYXRpY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRnhzaGZyX2FrMShEQkxfRVBTSUxPTiwgTURQMSwgMjAgKiBqaiwgc3IsIGJuZCwgSywgTiwgcCwgTk4sIHFwLCB1LCBGeHNoZnJfUGFyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihGeHNoZnJfUGFyLk5aICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2Vjb25kIHN0YWdlIGp1bXBzIGRpcmVjdGx5IHRvIG9uZSBvZiB0aGUgdGhpcmQgc3RhZ2UgaXRlcmF0aW9ucyBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGhlcmUgaWYgc3VjY2Vzc2Z1bC4gRGVmbGF0ZSB0aGUgcG9seW5vbWlhbCwgc3RvcmUgdGhlIHplcm8gb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB6ZXJvcywgYW5kIHJldHVybiB0byB0aGUgbWFpbiBhbGdvcml0aG0uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGRlZ1Bhci5EZWdyZWUgLSBOO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9yW2pdID0gRnhzaGZyX1Bhci5zenI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb2lbal0gPSBGeHNoZnJfUGFyLnN6aTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOTiA9IE5OIC0gRnhzaGZyX1Bhci5OWjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOID0gTk4gLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBOTjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW2ldID0gcXBbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoRnhzaGZyX1Bhci5OWiAhPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHplcm9yW2ogKyAxXSA9IEZ4c2hmcl9QYXIubHpyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJvaVtqICsgMV0gPSBGeHNoZnJfUGFyLmx6aTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaXRlcmF0aW9uIGlzIHVuc3VjY2Vzc2Z1bCwgYW5vdGhlciBxdWFkcmF0aWMgaXMgY2hvc2VuIGFmdGVyIHJlc3RvcmluZyBLXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBLW2ldID0gdGVtcFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHdpdGggZmFpbHVyZSBpZiBubyBjb252ZXJnZW5jZSB3aXRoIDIwIHNoaWZ0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqaiA+IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWdQYXIuRGVncmVlIC09IE47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyA+Pj4+PiBFbmQgTWFpbiBMb29wIDw8PDw8XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8tLT4gRW5kIEplbmtpbnMtVHJhdWJcclxuICAgICAgICAgICAgICAgIHJwU29sdmUoZGVncmVlUGFyLCBwLCB6ZXJvciwgemVyb2kpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBsID0gemVyb2kubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgLy9mb3JtYXQgdGhlIG91dHB1dFxyXG4gICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugcm91bmQgdGhlIGltYWdpbmFyeSBwYXJ0IHRvIGF2b2lkIGhhdmluZyBzb21ldGhpbmcgY3JhenkgbGlrZSA1LjY3ZS0xNi5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gcm91bmQoemVyb2lbaV0sIGRlY3AgKyA4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWwgPSByb3VuZCh6ZXJvcltpXSwgZGVjcCArIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERpZCB0aGUgcm91bmRpbmcgcGF5IG9mZj8gSWYgdGhlIHJvdW5kaW5nIGRpZCBub3RoaW5nIG1vcmUgdGhhbiBjaG9wIG9mZiBhIGZldyBkaWdpdHMgdGhlbiBuby5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgcmVzdWx0cyBpbiBhIGEgbnVtYmVyIGF0IGxlYXN0IDMgZGlnaXRzIHNob3J0ZXIgd2UnbGwga2VlcCBpdCBlbHNlIHdlJ2xsIGtlZXAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG90aGVyd2lzZSB0aGUgcm91bmRpbmcgd2FzIHdvcnRoIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWwgPSBkZWNwIC0gU3RyaW5nKHJlYWwpLmxlbmd0aCA+IDIgPyByZWFsIDogemVyb3JbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBpbWcgPCAwID8gJy0nIDogJyc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgemVyb2VzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYocmVhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGltZyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSAxIGFzIHRoZSBtdWx0aXBsaWVyIGFuZCBkaXNjYXJkIGltYWdpbmFyeSBwYXJ0IGlmIHRoZXJlIGlzbid0IG9uZS5cclxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBNYXRoLmFicyhpbWcpID09PSAxID8gc2lnbiArICdpJyA6IChpbWcgPyBpbWcgKyAnKmknIDogJycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gKHJlYWwgJiYgaW1nKSA/IHJlYWwgKyAnKycgKyBpbWcgOiByZWFsICsgaW1nO1xyXG4gICAgICAgICAgICAgICAgICAgIHplcm9yW2ldID0gbnVtLnJlcGxhY2UoL1xcK1xcLS9nLCAnLScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290czogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG5cclxuICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQodHJ1ZSwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLm5yb290cyhzeW1ib2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb290cyA9IF9fLnByb290cyhzeW1ib2wpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoeCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5WZWN0b3IuZnJvbUFycmF5KHJvb3RzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyb290OiBmdW5jdGlvbiAoZiwgZ3Vlc3MsIGR4KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXd0b25yYXBoID0gZnVuY3Rpb24gKHhuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWVzaCA9IDFlLTEyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVyaXZhdGl2ZSB3YXMgYWxyZWFkeSBwcm92aWRlZCB0aGVuIGRvbid0IHJlY2FsY3VsYXRlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZiA9IGR4ID8gZHggOiBjb3JlLlV0aWxzLmJ1aWxkKGNvcmUuQ2FsY3VsdXMuZGlmZihmLmNsb25lKCkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZ1bmN0aW9uIHdhcyBwYXNzZWQgaW4gYXMgYSBmdW5jdGlvbiB0aGVuIGRvbid0IHJlY2FsY3VsYXRlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA9IGYgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGYgOiBjb3JlLlV0aWxzLmJ1aWxkKGYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSAxMDAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZldHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUoIWRvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHhuIC0gKGZuKHhuKSAvIGRmKHhuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hYnNvbHV0ZSB2YWx1ZXMgZm9yIGJvdGggeCAmIHhuIGVuc3VyZXMgdGhhdCB3ZSBpbmRlZWQgaGF2ZSB0aGUgcmFkaXVzICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gTWF0aC5hYnMoeCkgLSBNYXRoLmFicyh4biksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IE1hdGguYWJzKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhuID0geDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZGVsdGEgPCBtZXNoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHNhZmV0eSA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4biA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2FmZXR5Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geG47XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBuZXd0b25yYXBoKE51bWJlcihndWVzcykpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVhZDogZnVuY3Rpb24gKGEsIGIsIGMpIHtcclxuICAgICAgICAgICAgdmFyIHEgPSBmdW5jdGlvbiAoYSwgYiwgYywgc2lnbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoJy0oJyArIGIgKyAnKycgKyBzaWduICsgJypzcXJ0KCgnICsgYiArICcpXjItNCooJyArIGEgKyAnKSooJyArIGMgKyAnKSkpLygyKicgKyBhICsgJyknKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFtxKGEsIGIsIGMsIDEpLCBxKGEsIGIsIGMsIC0xKV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdW1Qcm9kOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gX18ucXVhZCgtYiwgYSwgLTEpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHguaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29lZmZzOiBmdW5jdGlvbiAoc3ltYm9sLCB3cnQsIGNvZWZmcykge1xyXG4gICAgICAgICAgICB3cnQgPSBTdHJpbmcod3J0KTtcclxuICAgICAgICAgICAgc3ltYm9sID0gXy5leHBhbmQoc3ltYm9sKTtcclxuICAgICAgICAgICAgY29lZmZzID0gY29lZmZzIHx8IFtuZXcgU3ltYm9sKDApXTtcclxuICAgICAgICAgICAgLy93ZSBjYW5ub3QgZ2V0IGNvZWZmcyBmb3IgZ3JvdXAgRVhcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBFWCAmJiBzeW1ib2wuY29udGFpbnMod3J0LCB0cnVlKSlcclxuICAgICAgICAgICAgICAgIF8uZXJyb3IoJ1VuYWJsZSB0byBnZXQgY29lZmZpY2llbnRzIHVzaW5nIGV4cHJlc3Npb24gJyArIHN5bWJvbC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgdmFyIHZhcnMgPSB2YXJpYWJsZXMoc3ltYm9sKTtcclxuICAgICAgICAgICAgaWYodmFycy5sZW5ndGggPT09IDEgJiYgdmFyc1swXSA9PT0gd3J0ICYmICFzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgUG9seW5vbWlhbChzeW1ib2wpLmNvZWZmcy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCh4KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZiA9IGFbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gY29lZmZzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmID0gXy5hZGQoZSwgY29lZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZWZmc1tpXSA9IGNvZWZmOyAvL3RyYW5zZmVyIGl0IGFsbCBvdmVyXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZighd3J0KVxyXG4gICAgICAgICAgICAgICAgICAgIF8uZXJyb3IoJ1BvbHlub21pYWwgY29udGFpbnMgbW9yZSB0aGFuIG9uZSB2YXJpYWJsZS4gUGxlYXNlIHNwZWNpZnkgd2hpY2ggdmFyaWFibGUgaXMgdG8gYmUgdXNlZCEnKTtcclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlIHZhcmlhYmxlIGlzbid0IHBhcnQgb2YgdGhpcyBwb2x5bm9taWFsIHRoZW4gd2UncmUgbG9va2luZyBhdCB4XjBcclxuXHJcbiAgICAgICAgICAgICAgICBpZih2YXJzLmluZGV4T2Yod3J0KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2VmZnNbMF0gPSBfLmFkZChzeW1ib2wsIGNvZWZmc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2VmZnMgPSBjb2VmZnMgfHwgW25ldyBTeW1ib2woMCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2wuc3ltYm9sc1t3cnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZXJyb3IoJ0V4cHJlc3Npb24gaXMgbm90IGEgcG9seW5vbWlhbCEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOdW1iZXIocy5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmID0gXy5kaXZpZGUoc3ltYm9sLmNsb25lKCksIHMuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvZWZmLmNvbnRhaW5zKHdydCwgdHJ1ZSkgfHwgcCA8IDAgfHwgIWlzSW50KHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignRXhwcmVzc2lvbiBpcyBub3QgYSBwb2x5bm9taWFsIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGNvZWZmc1twXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmID0gXy5hZGQoZSwgY29lZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZnNbcF0gPSBjb2VmZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5jb2VmZnMoeC5jbG9uZSgpLCB3cnQsIGNvZWZmcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2ZpbGwgaG9sZXNcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGNvZWZmcy5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgY29lZmZzW2ldID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgICAgICBjb2VmZnNbaV0gPSBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvZWZmcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCdzIGFsbCB0aGUgcG93ZXJzIG9mIGEgcGFydGljdWxhciBwb2x5bm9taWFsIGluY2x1ZGluZyB0aGUgZGVub21pbmF0b3JzLiBUaGUgZGVub21pbmF0b3JzIHBvd2Vyc1xyXG4gICAgICAgICAqIGFyZSByZXR1cm5lZCBhcyBuZWdhdGl2ZS4gQWxsIHJlbWFpbmluZyBwb2x5bm9taWFscyBhcmUgcmV0dXJuZWQgYXMgemVybyBvcmRlciBwb2x5bm9taWFscy5cclxuICAgICAgICAgKiBmb3IgZXhhbXBsZSBwb2x5UG93ZXJzKHheMisxL3greSt0KSB3aWxsIHJldHVybiBbICctMScsIDAsICcyJyBdXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGVcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZm9yX3ZhcmlhYmxlXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcG93ZXJzXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiB0aGUgcG93ZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy9hc3N1bWVzIHlvdSd2ZSBhbHJlYWR5IHZlcmlmaWVkIHRoYXQgaXQncyBhIHBvbHlub21pYWxcclxuICAgICAgICBwb2x5UG93ZXJzOiBmdW5jdGlvbiAoZSwgZm9yX3ZhcmlhYmxlLCBwb3dlcnMpIHtcclxuICAgICAgICAgICAgcG93ZXJzID0gcG93ZXJzIHx8IFtdO1xyXG4gICAgICAgICAgICB2YXIgZyA9IGcgPSBlLmdyb3VwO1xyXG4gICAgICAgICAgICBpZihnID09PSBQTCAmJiBmb3JfdmFyaWFibGUgPT09IGUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHBvd2VycyA9IHBvd2Vycy5jb25jYXQoa2V5cyhlLnN5bWJvbHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHMgaW4gZS5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IGUuc3ltYm9sc1tzXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHN5bWJvbC5ncm91cCwgdiA9IHN5bWJvbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZihnID09PSBTICYmIGZvcl92YXJpYWJsZSA9PT0gdilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJzLnB1c2goc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IFBMIHx8IGcgPT09IENQKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3dlcnMgPSBfXy5wb2x5UG93ZXJzKHN5bWJvbCwgZm9yX3ZhcmlhYmxlLCBwb3dlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gQ0IgJiYgc3ltYm9sLmNvbnRhaW5zKGZvcl92YXJpYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBzeW1ib2wuc3ltYm9sc1tmb3JfdmFyaWFibGVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJzLnB1c2goKHQucG93ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBOIHx8IGZvcl92YXJpYWJsZSAhPT0gdilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJzLnB1c2goMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihnID09PSBDQiAmJiBlLmNvbnRhaW5zKGZvcl92YXJpYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIHBvd2Vycy5wdXNoKGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuKGUsIGZvcl92YXJpYWJsZSwgdHJ1ZSkueC5wb3dlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuYXJyYXlVbmlxdWUocG93ZXJzKS5zb3J0KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL1RoZSBmYWN0b3Igb2JqZWN0XHJcbiAgICAgICAgRmFjdG9yOiB7XHJcbiAgICAgICAgICAgIC8vc3BsaXRzIHRoZSBzeW1ib2wgaW4gc3ltYm9sIGFuZCBjb25zdGFudFxyXG4gICAgICAgICAgICBzcGxpdDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgU3ltYm9sKDEpOyAvL3RoZSBjb25zdGFudHMgcGFydFxyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBuZXcgU3ltYm9sKDEpOyAvL3RoZSBzeW1ib2xpYyBwYXJ0XHJcbiAgICAgICAgICAgICAgICBfXy5GYWN0b3IuZmFjdG9yKHN5bWJvbCwgbmV3IEZhY3RvcnMoKSkuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXy5wYXJzZSh4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZih4LmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IF8ubXVsdGlwbHkoYywgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gXy5tdWx0aXBseShzLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbYywgc107XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1peDogZnVuY3Rpb24gKG8sIGluY2x1ZGVfbmVnYXRpdmVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9ycyA9IGtleXMobyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGZhY3RvcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBbXTsvL2NyZWF0ZSBhIHJvdyB3aGljaCB3ZSdyIGdvaW5nIHRvIGJlIG1peGluZ1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBmYWN0b3JzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG9bZmFjdG9yXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGwgPSBtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG1bal0gKiBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucHVzaCh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaW5jbHVkZV9uZWdhdGl2ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnB1c2goLXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMTsgaiA8PSBwOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ucHVzaChNYXRoLnBvdyhmYWN0b3IsIGopKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvL1RPRE86IHRoaXMgbWV0aG9kIGlzIHRvIHJlcGxhY2UgY29tbW9uIGZhY3RvcmluZ1xyXG4gICAgICAgICAgICBjb21tb246IGZ1bmN0aW9uIChzeW1ib2wsIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbWF5IGhhdmUgdGhlIHVuZm9ydHVuYXRlIHNpZGUgZWZmZWN0IG9mIGV4cGFuZGluZyBhbmQgZmFjdG9yaW5nIGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG8gb25seSBlbmQgdXAgd2l0aCB0aGUgc2FtZSByZXN1bHQuIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IHRyeSB0byBhdm9pZCB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29sbGVjdCB0aGUgc3ltYm9scyBhbmQgc29ydCB0byBoYXZlIHRoZSBsb25nZXN0IGZpcnN0LiBUaGlua2luZyBpcyB0aGF0IHRoZSBsb25nZXN0IHRlcm1zIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2hhcyB0byBjb250YWluIHRoZSB2YXJpYWJsZSBpbiBvcmRlciBmb3IgaXQgdG8gYmUgZmFjdG9yYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IF8uZXhwYW5kKHN5bWJvbC5jbG9uZSgpLCB0cnVlKS5jb2xsZWN0U3ltYm9scyhudWxsLCBudWxsLCBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChiLmxlbmd0aCB8fCAxKSAtIChhLmxlbmd0aCB8fCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0ge307IC8vY3JlYXRlIGEgbWFwIG9mIGNvbW1vbiBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBzeW1ib2xzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZzLnB1c2goc3ltLm11bHRpcGxpZXIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKHgucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjaGVjayBleGl0cyBzaW5jZSB3ZSBoYXZlIGEgc3ltYm9saWMgcG93ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Gb3IgdGhlIGZ1dHVyZS4uLiB0aGluayBhYm91dCByZW1vdmluZyB0aGlzIGNoZWNrIGFuZCBtb2RpZnkgZm9yIHN5bWJvbGljIHBvd2Vyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzTmFOKHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4aXRpbmcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCB0aGUgc3ltYm9scyBhbmQgbHVtcCB0b2dldGhlciBjb21tb24gdGVybXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4LnZhbHVlIGluIG1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwIDwgbWFwW3gudmFsdWVdWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW3gudmFsdWVdWzBdID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW3gudmFsdWVdWzFdLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW3gudmFsdWVdID0gW3AsIFt4XV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBmYWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBtYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBmYWN0b3IgaXMgZm91bmQgaW4gYWxsIHRlcm1zIHNpbmNlIHRoZSBsZW5ndGggb2YgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21hdGNoaW5nIHZhcmlhYmxlIHRlcm1zIG1hdGNoZXMgdGhlIG51bWJlciBvZiBvcmlnaW5hbCB0ZXJtc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobWFwW3hdWzFdLmxlbmd0aCA9PT0gc3ltYm9scy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dlbmVyYXRlIGEgc3ltYm9sIGFuZCBtdWx0aXBseSBpbnRvIHRoZSBmYWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IgPSBfLm11bHRpcGx5KGZhY3RvciwgXy5wb3cobmV3IFN5bWJvbCh4KSwgbmV3IFN5bWJvbChtYXBbeF1bMF0pKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgY29lZmZpY2llbnQgZmFjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gY29yZS5NYXRoMi5RR0NELmFwcGx5KG51bGwsIGNvZWZmcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighYy5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKG5ldyBTeW1ib2woYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzW2ldLm11bHRpcGxpZXIgPSBzeW1ib2xzW2ldLm11bHRpcGxpZXIuZGl2aWRlKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIGFjdHVhbGwgZm91bmQgYW55IGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWZhY3Rvci5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKGZhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmFkZChzeW1ib2wsIF8uZGl2aWRlKHN5bWJvbHNbaV0sIGZhY3Rvci5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHplcm9lczogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4aXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5WYWx1ZUxpbWl0RXhjZWVkZWRFcnJvcignRXhpdGluZycpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcnMsIHRlcm0sIHN1bSwgcCwgZTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IHN5bWJvbC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcnMgPSB2YXJpYWJsZXMoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvd2VycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0IHNldHRpbmcgZWFjaCB2YXJpYWJsZSB0byB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IHZhcnMubGVuZ3RoOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VicyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dlIHdhbnQgdG8gY3JlYXRlIGEgc3VicyBvYmplY3Qgd2l0aCBhbGwgYnV0IHRoZSBjdXJyZW50IHZhcmlhYmxlIHNldCB0byB6ZXJvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBsOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpICE9PSBqKSAvL21ha2Ugc3VyZSB3ZSdyZSBub3QgbG9va2luZyBhdCB0aGUgc2FtZSB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNbdmFyc1tqXV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtID0gXy5wYXJzZShlLCBzdWJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRwID0gdGVybS5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgdGVtcG9yYXJ5IHBvd2VyIGhhcyB0byBiZSBhbiBpbnRlZ2VyIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWlzSW50KHRwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVybXMucHVzaCh0ZXJtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJzLnB1c2godGVybS5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgZ2NkLiBUaGlzIHdpbGwgYmUgdGhlIHAgaW4gKGFebitiXm0pXnBcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBnY2QgZXF1YWxzIDEgbWVhbmluZyBuID0gbSB0aGVuIHdlIG5lZWQgYSB0aWUgYnJlYWtkZXJcclxuICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmFsbFNhbWUocG93ZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBwIGdpdmVuIHggbnVtYmVyIG9mIHRlcm1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuX3Rlcm1zID0gc3ltYm9sLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgbnVtYmVyIG9mIHplcm9lcyBkZXRlcm1pbmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuX3plcm9lcyA9IHRlcm1zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobl96ZXJvZXMgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuZXcgRnJhYyhwb3dlcnNbMF0gLyAobl90ZXJtcyAtIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuX3plcm9lcyA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG5ldyBGcmFjKHBvd2Vyc1swXSAvIE1hdGgucm91bmQoKE1hdGguc3FydCg4ICogbl90ZXJtcyAtIDEpIC0gMykgLyAyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBsb3dlc3QgcG9zc2libGUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vZS5nLiBnaXZlbiBiXjQrMiphXjIqYl4yK2FeNCwgdGhlIHBvd2VyIHdlJ3JlIGxvb2tpbmcgZm9yIHdvdWxkIGJlIDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IENCKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgeC5lYWNoKGZ1bmN0aW9uKHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFwIHx8IHkucG93ZXIubGVzc1RoYW4ocCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAvL3AgPSBOdW1iZXIoeS5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBwID0geS5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZighcCB8fCB4LnBvd2VyLmxlc3NUaGFuKHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy9wID0gTnVtYmVyKHgucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHgucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wIGlzIGp1c3QgdGhlIGdjZCBvZiB0aGUgcG93ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBjb3JlLk1hdGgyLlFHQ0QuYXBwbHkobnVsbCwgcG93ZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBkb24ndCBoYXZlIGFuIGludGVnZXIgdGhlbiBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWlzSW50KHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGl0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYnVpbGQgdGhlIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHRlcm1zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHQucG93ZXIuY2xvbmUoKS5kaXZpZGUocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQubXVsdGlwbGllciA9IG5ldyBGcmFjKE1hdGgucG93KHQubXVsdGlwbGllciwgMSAvIG4pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5wb3dlciA9IHAuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gXy5hZGQoc3VtLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYnkgbm93IHdlIGhhdmUgdGhlIGZhY3RvciBvZiB6ZXJvZXMuIFdlJ2xsIGtub3cgaWYgd2UgZ290IGl0IHJpZ2h0IGJlY2F1c2UgXHJcbiAgICAgICAgICAgICAgICAgICAgLy93ZSdsbCBnZXQgYSByZW1haW5kZXIgb2YgemVybyBlYWNoIHRpbWUgd2UgZGl2aWRlIGJ5IGl0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3VtLmdyb3VwICE9PSBDUClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDsgLy9ub3RoaW5nIHRvIGRvXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfXy5kaXYoc3ltYm9sLmNsb25lKCksIHN1bS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZFsxXS5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChzdW0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKDEpKSAvL3dlJ3ZlIHJlYWNoZWQgMSBzbyBkb25lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmYWN0b3I6IGZ1bmN0aW9uIChzeW1ib2wsIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIC8vIERvbid0IHRyeSB0byBmYWN0b3IgY29uc3RhbnRzXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuTWF0aDIuZmFjdG9yKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIF9zeW1ib2wgPSBfLnBhcnNlKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gX18uRmFjdG9yLl9mYWN0b3IoX3N5bWJvbCwgZmFjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICBpZihyZXR2YWwuZXF1YWxzKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHJldHZhbC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBfLnBhcnNlKHJldHZhbC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdG9yZSB0aGUgbXVsdGlwbGllciBhbmQgc3RyaXAgaXRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IF8ucGFyc2UocmV0dmFsLm11bHRpcGxpZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwudG9Vbml0TXVsdGlwbGllcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKiBcclxuICAgICAgICAgICAgICAgICAgICAgKiBOT1RFOiBmb3Igc2lnbiBpc3N1ZXMgd2l0aCBmYWN0b3IgU1RBUlQgREVCVUdHSU5HIEhFUkVcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAvL21vdmUgdGhlIHNpZ24gdG8gdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHJldHZhbC5tdWx0aXBsaWVyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbGF0ZWQgdG8gIzU2Ni4gU2luY2UgdGhlIHN5bWJvbCdzIGdyb3VwIG1heSBub3QgaGF2ZSBiZWVuIHByb3Blcmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQsIGl0J3MgZWFzaWVyIHRvIGp1c3QgcGFyc2UgdGhlIHN5bWJvbCBhbmQgaGF2ZSB0aGUgcGFyc2VyIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyB0aGUgdXBkYXRlIGZvciB1cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvcmVkID0gXy5wYXJzZShfXy5GYWN0b3IuX2ZhY3Rvcih4KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmYWN0b3JlZC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBfLm11bHRpcGx5KG0sIFN5bWJvbC5jcmVhdGUoZmFjdG9yZWQubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yZWQuZWFjaChmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZmFjdG9yZWQgPSBfLnBhcnNlKF9fLkZhY3Rvci5fZmFjdG9yKHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5tdWx0aXBseSh0LCBfZmFjdG9yZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF9mYWN0b3JlZC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IF8ubXVsdGlwbHkobSwgU3ltYm9sLmNyZWF0ZShfZmFjdG9yZWQubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkodCwgZmFjdG9yZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgdGhlIG11bHRpcGxpZXIgYW5kIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wb3coXy5tdWx0aXBseShtLCB0KSwgcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcXVhZEZhY3RvcjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzUG9seSgpICYmIF9fLmRlZ3JlZShzeW1ib2wuZXF1YWxzKDIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vV2UndmUgIGFscmVhZHkgY2hlY2tlZCB0aGF0IHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHBvbHlub21pYWxcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGNvcmUuVXRpbHMudmFyaWFibGVzKHN5bWJvbClbMF07IC8vZ2V0IHRoZSB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZnMgPSBfXy5jb2VmZnMoc3ltYm9sLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZhY3RvciB0aGUgbGVhZCBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZiA9IF9fLkZhY3Rvci5fZmFjdG9yKGNvZWZmc1syXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHdlIGhhdmUgZmFjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNmLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IGNmLmNvbGxlY3RTeW1ib2xzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIGZhY3RvcnMgYXJlIGdyZWF0ZXIgdGhhbiAyIHdlJ3JlIGRvbmUgc28gZXhpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2xzLmxlbmd0aCA+IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIGhhdmUgdHdvIGZhY3RvcnMgdGhlbiBhdHRlbXB0IHRvIGZhY3RvciB0aGUgcG9seW5vbWlhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xldCB0aGUgZmFjdG9ycyBiZSBmMSBhbmQgZjFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgdGhlIGZhY3RvcnMgYmUgKGF4K2IpKGN4K2QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbGV0IHRoZSBjb2VmZmljaWVudHMgYmUgYzF4XjIrYzJ4K2MzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlbiBhKHgxKStjKHgyKT1jMiBhbmQgeDEqeDI9YzNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBjYW4gc29sdmUgZm9yIHgxIGFuZCB4MlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IF8ubXVsdGlwbHkoXy5wYXJzZShjb2VmZnNbMF0pLCBfLnBhcnNlKHN5bWJvbHNbMF0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBfLnBhcnNlKGNvZWZmc1sxXSkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gXy5wYXJzZShzeW1ib2xzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zb2x2ZSB0aGUgc3lzdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290ID0gX18ucXVhZChhLCBiLCBjKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaXNJbnQoeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIGhhdmUgb25lIHJvb3QgdGhlbiBmaW5kIHRoZSBvdGhlciBvbmUgYnkgZGl2aWRpbmcgdGhlIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJvb3QubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdDEgPSByb290WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QyID0gXy5kaXZpZGUoY29lZmZzWzBdLCBfLnBhcnNlKHJvb3QxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmlzSW50KHJvb3QyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgZm91bmQgdGhlbSBib3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoXy5wYXJzZShmb3JtYXQoJyh7MH0pKih7MX0pKyh7Mn0pJywgc3ltYm9sc1sxXSwgdiwgcm9vdDIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoXy5wYXJzZShmb3JtYXQoJyh7MH0pKih7MX0pKyh7Mn0pJywgc3ltYm9sc1swXSwgdiwgcm9vdDEpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGN1YmVGYWN0b3I6IGZ1bmN0aW9uIChzeW1ib2wsIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbHMgPSBzeW1ib2wuY29sbGVjdFN5bWJvbHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3ltYm9sIHNob3VsZCBiZSBpbiB0aGUgZm9ybSBvZiBhXjMrLWJeMy4gVGhlIGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCB0aGVyZWZvcmUgb25seSBiZSB0d28uIElmIGl0J3MgYW55IGRpZmZlcmVudCBmcm9tIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2xzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgc2lnbnMgYW5kIHRoZW4gc3RyaXAgdGhlbSBmcm9tIHRoZSBzeW1ib2xzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduX2EgPSBzeW1ib2xzWzBdLnNpZ24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBzeW1ib2xzWzBdLmNsb25lKCkuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduX2IgPSBzeW1ib2xzWzFdLnNpZ24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBzeW1ib2xzWzFdLmNsb25lKCkuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXkncmUgY3ViZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhLmlzQ3ViZSgpICYmIGIuaXNDdWJlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIG5lZ2F0aXZlIHNpZ24gb24gdGhlIHJpZ2h0LCBtZWFuaW5nIGIgaXMgYWx3YXlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lnbl9hIDwgc2lnbl9iKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3dhcCB0aGUgc2lnbnMgYW5kIHRoZW4gdGhlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzaWduX2EsIHNpZ25fYl0gPSBbc2lnbl9iLCBzaWduX2FdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFthLCBiXSA9IFtiLCBhXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGVoIHJvb3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbV9yb290X2EgPSBfLnBhcnNlKGEuZ2V0TnRoKDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtX3Jvb3RfYiA9IF8ucGFyc2UoYi5nZXROdGgoMykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgY3ViZSBmb3IgYm90aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBfLm11bHRpcGx5KF8uZXhwYW5kKF8ucG93KGEuY2xvbmUoKS50b1VuaXRNdWx0aXBsaWVyKCksIF8ucGFyc2UoJzEvMycpKSksIG1fcm9vdF9hKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gXy5tdWx0aXBseShfLmV4cGFuZChfLnBvdyhiLmNsb25lKCkudG9Vbml0TXVsdGlwbGllcigpLCBfLnBhcnNlKCcxLzMnKSkpLCBtX3Jvb3RfYik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lnbl9hID09PSAxICYmIHNpZ25fYiA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBkaWZmZXJlbmNlIG9mIGN1YmVzIHJ1bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnBhcnNlKGZvcm1hdCgnKCh7MH0pLSh7MX0pKScsIHgsIHkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoXy5wYXJzZShmb3JtYXQoJygoezB9KV4yKyh7MH0pKih7MX0pKyh7MX0pXjIpJywgeCwgeSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHNpZ25fYSA9PT0gMSAmJiBzaWduX2IgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBzdW0gb2YgY3ViZXMgcnVsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKF8ucGFyc2UoZm9ybWF0KCcoKHswfSkrKHsxfSkpJywgeCwgeSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnBhcnNlKGZvcm1hdCgnKCh7MH0pXjItKHswfSkqKHsxfSkrKHsxfSleMiknLCB4LCB5KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfZmFjdG9yOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAvL3NvbWUgaXRlbXMgY2Fubm90IGJlIGZhY3RvcmVkIGFueSBmdXJ0aGVyIHNvIHJldHVybiB0aG9zZSByaWdodCBhd2F5XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFyZy5ncm91cCA9PT0gUyAmJiBhcmcuaXNTaW1wbGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBTICYmIHN5bWJvbC5pc1NpbXBsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgdGhlIHN5bWJvbCB0byBnZXQgaXQgaW4gYSBwcmVkaWN0YWJsZSBmb3JtLiBJZiB0aGlzIHN0ZXBcclxuICAgICAgICAgICAgICAgIC8vIGlzIHNraXBwZWQgc29tZSBmYWN0b3JzIGFyZSBtaXNzZWQuXHJcbiAgICAgICAgICAgICAgICAvL2lmKHN5bWJvbC5ncm91cCA9PT0gQ1AgJiYgIShldmVuKHN5bWJvbC5wb3dlcikgJiYgc3ltYm9sLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZigoeC5ncm91cCA9PT0gQ1AgJiYgeC5wb3dlci5ncmVhdGVyVGhhbigxKSB8fCB4Lmdyb3VwID09PSBDQikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gXy5leHBhbmQoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLmFkZCh0LCB4KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0LnBvd2VyID0gc3ltYm9sLnBvd2VyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gRk4gJiYgc3ltYm9sLmZuYW1lICE9PSAnc3FydCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBjb3JlLlV0aWxzLmV2YWx1YXRlKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIGEgY29weSBvZiB0aGUgc3ltYm9sIHRvIHJldHVybiBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xyXG4gICAgICAgICAgICAgICAgdmFyIHVudG91Y2hlZCA9IHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gXy5wYXJzZShzeW1ib2wucG93ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbl9hcnJheSwgbnVtX2FycmF5LCBkZW4sIG51bSwgZGZhY3QsIG5mYWN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dyYWIgdGhlIGRlbm9taW5hdG9yIGFuZCBzdHJpcCB0aGUgbXVsdGlwbGllciBhbmQgcG93ZXIuIFN0b3JlIHRoZW0gaW4gYW4gYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuX2FycmF5ID0gX18uU2ltcGxpZnkuc3RyaXAoc3ltYm9sLmdldERlbm9tKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1fYXJyYXkgPSBfXy5TaW1wbGlmeS5zdHJpcChzeW1ib2wuZ2V0TnVtKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuID0gZGVuX2FycmF5LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW0gPSBudW1fYXJyYXkucG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBudW1lcmF0b3IgZXF1YWxzIHRoZSBzeW1ib2wgdGhlbiB3ZSd2ZSBoaXQgdGhlIHNpbXBsZXN0IGZvcm0gYW5kIHRoZW4gd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihudW0uZXF1YWxzKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmZhY3QgPSBfXy5GYWN0b3IuZmFjdG9yKG51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRmYWN0ID0gX18uRmFjdG9yLmZhY3RvcihkZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBfXy5TaW1wbGlmeS51bnN0cmlwKG51bV9hcnJheSwgbmZhY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF9fLlNpbXBsaWZ5LnVuc3RyaXAoZGVuX2FycmF5LCBkZmFjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gXy5kaXZpZGUobiwgZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDsgLy9hYnNvbHV0ZWx5IG5vdGhpbmcgdG8gZG9cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2wuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGNvcmUuTWF0aDIuZmFjdG9yKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHN5bWJvbC5wb3dlci5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihpc0ludChwKSAmJiAhKHAubGVzc1RoYW4oMCkgJiYgc3ltYm9sLmdyb3VwID09PSBGTikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBwLnNpZ24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMgPSBmYWN0b3JzIHx8IG5ldyBGYWN0b3JzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZShjb3JlLlV0aWxzLnN1YkZ1bmN0aW9ucyhzeW1ib2wsIG1hcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihrZXlzKG1hcCkubGVuZ3RoID4gMCkgeyAvL2l0IG1pZ2h0IGhhdmUgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLnByZUFkZCA9IGZ1bmN0aW9uIChmYWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gXy5wYXJzZShmYWN0b3IsIGNvcmUuVXRpbHMuZ2V0RnVuY3Rpb25zU3VicyhtYXApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdHJpcCB0aGUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLnBGYWN0b3IgPSBzeW1ib2wucG93ZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFycyA9IHZhcmlhYmxlcyhzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2J5cGFzcyBmb3IgaW1hZ2luYXJ5LiBUT0RPOiBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnB1c2goY29yZS5TZXR0aW5ncy5JTUFHSU5BUlkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aVZhciA9IHZhcnMubGVuZ3RoID4gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWlub3Igb3B0aW1pemF0aW9uLiBTZWVtcyB0byBjdXQgZmFjdG9yIHRpbWUgYnkgaGFsZiBpbiBzb21lIGNhc2VzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtdWx0aVZhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbF9TID0gdHJ1ZSwgYWxsX3VuaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4Lmdyb3VwICE9PSBTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxfUyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF4Lm11bHRpcGxpZXIuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxfdW5pdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYWxsX1MgJiYgYWxsX3VuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wb3coXy5wYXJzZShzeW1ib2wsIGNvcmUuVXRpbHMuZ2V0RnVuY3Rpb25zU3VicyhtYXApKSwgXy5wYXJzZShwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmFjdG9yIHRoZSBjb2VmZmljaWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmX2ZhY3RvcnMgPSBuZXcgRmFjdG9ycygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gX18uRmFjdG9yLmNvZWZmRmFjdG9yKHN5bWJvbCwgY29lZmZfZmFjdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VmZl9mYWN0b3JzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmYWN0b3Igd2FzIG5lZ2F0aXZlIGJ1dCB3YXMgd2l0aGluIGEgc3F1YXJlIHRoZW4gaXQgYmVjb21lcyBwb3NpdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXZlbihwKSAmJiB4Lmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzaWduIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9mYWN0b3IgdGhlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3dlcl9mYWN0b3JzID0gbmV3IEZhY3RvcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gX18uRmFjdG9yLnBvd2VyRmFjdG9yKHN5bWJvbCwgcG93ZXJfZmFjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvd2VyX2ZhY3RvcnMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5pbnZlcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFtdWx0aVZhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wYXNzIGluIHZhcnNbMF0gZm9yIHNhZmV0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB2YXJzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF9fLkZhY3Rvci5zcXVhcmVGcmVlKHN5bWJvbCwgZmFjdG9ycywgdik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRfZmFjdG9ycyA9IG5ldyBGYWN0b3JzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gX18uRmFjdG9yLnRyaWFsQW5kRXJyb3Ioc3ltYm9sLCB0X2ZhY3RvcnMsIHYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2VuZXJhdGUgYSBzeW1ib2wgYmFzZWQgb2ZmIHRoZSBsYXN0IGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0Zl9zeW1ib2wgPSB0X2ZhY3RvcnMudG9TeW1ib2woKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgbm90aGluZyB3YXMgZmFjdG9yZWQgdGhlbiByZXR1cm4gdGhlIGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRmX3N5bWJvbC5lcXVhbHModW50b3VjaGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0Zl9zeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHRfZmFjdG9ycy5mYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zdG9yZSB0aGUgY3VycmVudCBmYWN0b3IgaW4gdF9mYWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdF9mYWN0b3IgPSB0X2ZhY3RvcnMuZmFjdG9yc1t4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnBvdyh0X2ZhY3RvciwgXy5wYXJzZShwKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBzdGlsbCBkb24ndCBoYXZlIGEgZmFjdG9yIGFuZCBpdCdzIHF1YWRyYXRpYyB0aGVuIGxldCdzIGp1c3QgZG8gYSBxdWFkIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmVxdWFscyh1bnRvdWNoZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gX18uRmFjdG9yLnF1YWRGYWN0b3Ioc3ltYm9sLCBmYWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgc3VtIGFuZCBkaWZmZXJlbmNlIG9mIGN1YmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5GYWN0b3IuY3ViZUZhY3RvcihzeW1ib2wsIGZhY3RvcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF9fLkZhY3Rvci5tZmFjdG9yKHN5bWJvbCwgZmFjdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wdXQgYmFjayB0aGUgc2lnbiBvZiBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgucG93ZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sYXN0IG1pbnV0ZSBjbGVhbiB1cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKHN5bWJvbCwgY29yZS5VdGlscy5nZXRGdW5jdGlvbnNTdWJzKG1hcCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoXy5wb3coc3ltYm9sLCBfLnBhcnNlKHApKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gZmFjdG9ycy50b1N5bWJvbCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ubyBuZWVkIHRvIHN0b3AgdGhlIHNob3cgYmVjYXVzZSBzb21ldGhpbmcgd2VudCB3cm9uZyA6KS4gSnVzdCByZXR1cm4gdGhlIHVuZmFjdG9yZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVudG91Y2hlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVkdWNlOiBmdW5jdGlvbiAoc3ltYm9sLCBmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENQICYmIHN5bWJvbC5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IHN5bWJvbC5jb2xsZWN0U3ltYm9scygpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIubXVsdGlwbGllciAtIGEubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2xzWzBdLnBvd2VyLmVxdWFscyhzeW1ib2xzWzFdLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3hebi1hXm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBfLnBhcnNlKHN5bWJvbHNbMF0ucG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBzeW1ib2xzWzBdLmNsb25lKCkudG9MaW5lYXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gc3ltYm9sc1sxXS5jbG9uZSgpLnRvTGluZWFyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IHJ1bGU6IChhLWIpKnN1bShhXihuLWkpKmJeKGktMSksMSxuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLmFkZChhLmNsb25lKCksIGIuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZsaXAgdGhlIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90dXJuIG4gaW50byBhIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm4gPSBOdW1iZXIobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIHJlbWFpbmRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8PSBubjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWEgPSBfLnBvdyhhLmNsb25lKCksIF8uc3VidHJhY3Qobi5jbG9uZSgpLCBuZXcgU3ltYm9sKGkpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJiID0gXy5wb3coYi5jbG9uZSgpLCBfLnN1YnRyYWN0KG5ldyBTeW1ib2woaSksIG5ldyBTeW1ib2woMSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uYWRkKHJlc3VsdCwgXy5tdWx0aXBseShhYSwgYmIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYWtlcyBTeW1ib2wgc3F1YXJlIGZyZWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0ZhY3RvcnN9IGZhY3RvcnNcclxuICAgICAgICAgICAgICogQEBwYXJhbSB7U3RyaW5nfSB2YXJpYWJsZSBUaGUgdmFyaWFibGUgd2hpY2ggaXMgYmVpbmcgZmFjdG9yZWQgXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtbU3ltYm9sLCBGYWN0b3JdfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgc3F1YXJlRnJlZTogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycywgdmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkgfHwgc3ltYm9sLmdyb3VwID09PSBTKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHBvbHkgPSBuZXcgUG9seW5vbWlhbChzeW1ib2wsIHZhcmlhYmxlKTtcclxuICAgICAgICAgICAgICAgIHZhciBzcWZyID0gcG9seS5zcXVhcmVGcmVlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHNxZnJbMl07XHJcbiAgICAgICAgICAgICAgICAvL2lmIHdlIGZvdW5kIGEgc3F1YXJlIHRoZW4gdGhlIHAgZW50cnkgaW4gdGhlIGFycmF5IHdpbGwgYmUgbm9uLXVuaXRcclxuICAgICAgICAgICAgICAgIGlmKHAgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSB0aGUgcmVtYWluZGVyIGRvZXNuJ3QgaGF2ZSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBzcWZyWzFdLnRvU3ltYm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5wb3dlciA9IHQucG93ZXIubXVsdGlwbHkobmV3IEZyYWMocCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc2VuZCB0aGUgZmFjdG9yIHRvIGJlIGZhdG9yZWQgdG8gYmUgc3VyZSBpdCdzIGNvbXBsZXRlbHkgZmFjdG9yZWRcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfXy5GYWN0b3IuZmFjdG9yKHQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IF9fLkZhY3Rvci5zcXVhcmVGcmVlKHNxZnJbMF0udG9TeW1ib2woKSwgZmFjdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZhY3RvcnMgdGhlIHBvd2VycyBzdWNoIHRoYXQgdGhlIGxvd2VzdCBwb3dlciBpcyBhIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGYWN0b3JzfSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtbU3ltYm9sLCBGYWN0b3JdfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcG93ZXJGYWN0b3I6IGZ1bmN0aW9uIChzeW1ib2wsIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIC8vb25seSBQTCBuZWVkIGFwcGx5XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgIT09IFBMIHx8IHN5bWJvbC5wcmV2aW91c0dyb3VwID09PSBFWClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzKHN5bWJvbC5zeW1ib2xzKTtcclxuICAgICAgICAgICAgICAgIC8vd2UgZXhwZWN0IG9ubHkgbnVtZXJpYyBwb3dlcnMgc28gcmV0dXJuIGFsbCBlbHNlXHJcbiAgICAgICAgICAgICAgICBpZighY29yZS5VdGlscy5hbGxOdW1lcmljKGspKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBjb3JlLlV0aWxzLmFycmF5TWluKGspO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcSA9IF8ucGFyc2Uoc3ltYm9sLnZhbHVlICsgJ14nICsgZCk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBfLmRpdmlkZSh4LCBxLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgeCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIEdDRCBmcm9tIGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RmFjdG9yfSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjb2VmZkZhY3RvcjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2NkID0gY29yZS5NYXRoMi5RR0NELmFwcGx5KG51bGwsIHN5bWJvbC5jb2VmZnMoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFnY2QuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4LmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmVhY2goZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeS5tdWx0aXBsaWVyID0geS5tdWx0aXBsaWVyLmRpdmlkZShnY2QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgubXVsdGlwbGllciA9IHgubXVsdGlwbGllci5kaXZpZGUoZ2NkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC51cGRhdGVIYXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBnbyB0byB0aGUgcHJvdG90eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3dlciA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgKz0geC5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBOdW1iZXIoc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWN0b3Igb3V0IG5lZ2F0aXZlcyBmcm9tIHRoZSBsZWFkIHRlcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm1zID0gc3ltYm9sLmNvbGxlY3RTeW1ib2xzKG51bGwsIG51bGwsIG51bGwsIHRydWUpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggY29uc3RhbnRzIHRvIHRoZSBiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhLmlzQ29uc3RhbnQodHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5wb3dlciAtIGEucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIExUID0gdGVybXNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgTFQgaXMgaW5kZWVkIHRoZSBncmVhdGVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwb3dlcihMVCkgPiBwb3dlcih0ZXJtc1sxXSkgfHwgdGVybXNbMV0uaXNDb25zdGFudCh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoTFQubXVsdGlwbGllci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsdGhvdWdoIHRoZSBzeW1ib2wgc2hvdWxkIGFsd2F5cyBiZSBsaW5lYXIgYXQgdGhpcyBwb2ludCwgcmVtb3ZlIHRoZSBuZWdhdGl2ZSBmb3Igc3F1YXJlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIHNhZmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQobmV3IFN5bWJvbCgtMSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChuZXcgU3ltYm9sKGdjZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIG5hbWUgc2F5cyBpdCBhbGwgOilcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0ZhY3Rvcn0gZmFjdG9yc1xyXG4gICAgICAgICAgICAgKiBAQHBhcmFtIHtTdHJpbmd9IHZhcmlhYmxlIFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdHJpYWxBbmRFcnJvcjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycywgdmFyaWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1bnRvdWNoZWQgPSBzeW1ib2wuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGVtcCBob2xkZXIgZm9yIHRoZSBmYWN0b3JzLiBJZiBhbGwgZ29lcyB3ZWxsIHRoZW5cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGV5J2xsIGJlIG1vdmVkIHRvIHRoZSBhY3R1YWwgZmFjdG9ycy5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yX2FycmF5ID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkgfHwgc3ltYm9sLmdyb3VwID09PSBTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5ID0gbmV3IFBvbHlub21pYWwoc3ltYm9sLCB2YXJpYWJsZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbnN0ID0gcG9seS5jb2VmZnNbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZmFjdG9ycyA9IGNvcmUuTWF0aDIuaWZhY3RvcihjbnN0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RzID0gX18ucHJvb3RzKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gcm9vdHNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFpc05hTihyKSkgeyAvL2lmIGl0J3MgYSBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBjZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaXQncyByYWlzZWQgdG8gYSBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gY29yZS5VdGlscy5yb3VuZChNYXRoLmxvZyh4KSAvIE1hdGgubG9nKE1hdGguYWJzKHIpKSwgOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNJbnQobikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHg7IC8veCBtdXN0IGJlIHRoZSByb290IHNpbmNlIG4gZ2F2ZSB1cyBhIHdob2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IG5ldyBGcmFjKHIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtcyA9IFtuZXcgRnJhYyhyb290Lm51bSkubmVnYXRlKCldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybXNbcF0gPSBuZXcgRnJhYyhyb290LmRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdG8gRnJhYy4gVGhlIGRlbiBpcyBjb2VmZiBvZiBMVCBhbmQgdGhlIG51bSBpcyBjb2VmZiBvZiBjb25zdGFudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IFBvbHlub21pYWwuZnJvbUFycmF5KHRlcm1zLCBwb2x5LnZhcmlhYmxlKS5maWxsKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBwb2x5LmRpdmlkZShkaXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodFsxXS5lcXVhbHNOdW1iZXIoMCkpIHsgLy9pZiBpdCdzIHplcm8gd2UgaGF2ZSBhIHJvb3QgYW5kIGRpdmlkZSBpdCBvdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5ID0gdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWN0b3JzLmFkZChkaXYudG9TeW1ib2woKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yX2FycmF5LnB1c2goZGl2LnRvU3ltYm9sKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZighcG9seS5lcXVhbHNOdW1iZXIoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seSA9IF9fLkZhY3Rvci5zZWFyY2gocG9seSwgZmFjdG9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBmYWN0b3JzIG92ZXIgc2luY2UgYWxsIHdlbnQgd2VsbC5cclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3JfYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZCh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHkudG9TeW1ib2woKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW50b3VjaGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uIChwb2x5LCBmYWN0b3JzLCBiYXNlKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlID0gYmFzZSB8fCAxMDsgLy9JIGxpa2UgMTAgYmVjYXVzZSBudW1iZXJzIGV4aGliaXQgc2ltaWxhciBiZWhhdmlvdXJzIGF0IDEwXHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHBvbHkudmFyaWFibGU7IC8vdGhlIHBvbHlubWlhbCB2YXJpYWJsZSBuYW1lXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEF0dGVtcHQgdG8gcmVtb3ZlIGEgcm9vdCBieSBkaXZpc2lvbiBnaXZlbiBhIG51bWJlciBieSBmaXJzdCBjcmVhdGluZ1xyXG4gICAgICAgICAgICAgICAgICogYSBwb2x5bm9taWFsIGZyb210IGhlIGdpdmVuIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2ludH0gYzEgLSBjb2VmZmllbnQgZm9yIHRoZSBjb25zdGFudFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtpbnR9IGMyIC0gY29lZmZpY2llbnQgZm9yIHRoZSBMVFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtpbnR9IG4gLSB0aGUgbnVtYmVyIHRvIGJlIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwb2x5bm9taWFsXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2ludH0gcCAtIHRoZSBwb3dlciBhdCB3aGljaCB0byBjcmVhdGUgdGhlIHBvbHlub21pYWxcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudWxsfFBvbHlub21pYWx9IC0gcmV0dXJucyBwb2x5bm9taWFsIGlmIHN1Y2Nlc3NmdWwgb3RoZXJ3aXNlIG51bGxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrID0gZnVuY3Rpb24gKGMxLCBjMiwgbiwgcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBQb2x5bm9taWFsLmZpdChjMSwgYzIsIG4sIGJhc2UsIHAsIHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUuY29lZmZzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBwb2x5LmRpdmlkZShjYW5kaWRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0WzFdLmVxdWFsc051bWJlcigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoY2FuZGlkYXRlLnRvU3ltYm9sKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0WzBdLCBjYW5kaWRhdGVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciBjbnN0ID0gcG9seS5jb2VmZnNbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgY2ZhY3RvcnMgPSBjb3JlLk1hdGgyLmlmYWN0b3IoY25zdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGMgPSBwb2x5LmxjKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbHRmYWN0b3JzID0gY29yZS5NYXRoMi5pZmFjdG9yKGxjKTtcclxuICAgICAgICAgICAgICAgIHZhciBzdWJiZWQgPSBwb2x5LnN1YihiYXNlKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc3ViYmVkID0gY29yZS5NYXRoMi5pZmFjdG9yKHN1YmJlZCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmZhY3RvcnMgPSBfXy5GYWN0b3IubWl4KGlzdWJiZWQsIHN1YmJlZCA8IDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNwID0gTWF0aC5jZWlsKHBvbHkuY29lZmZzLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxjX2lzX25lZyA9IGxjLmxlc3NUaGFuKDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNuc3RfaXNfbmVnID0gY25zdC5sZXNzVGhhbigwKTtcclxuICAgICAgICAgICAgICAgIGx0ZmFjdG9yc1snMSddID0gMTtcclxuICAgICAgICAgICAgICAgIGNmYWN0b3JzWycxJ10gPSAxO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUoY3AtLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBsdGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB5IGluIGNmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbmZhY3RvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yX2ZvdW5kID0gY2hlY2soeCwgeSwgbmZhY3RvcnNbaV0sIGNwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmYWN0b3JfZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seSA9IGZhY3Rvcl9mb3VuZFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWNvcmUuVXRpbHMuaXNQcmltZShwb2x5LnN1YihiYXNlKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5ID0gX18uRmFjdG9yLnNlYXJjaChwb2x5LCBmYWN0b3JzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoIWZhY3Rvcl9mb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsY19pc19uZWcgJiYgY25zdF9pc19uZWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JfZm91bmQgPSBjaGVjaygteCwgLXksIG5mYWN0b3JzW2ldLCBjcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYobGNfaXNfbmVnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yX2ZvdW5kID0gY2hlY2soLXgsIHksIG5mYWN0b3JzW2ldLCBjcCk7IC8vY2hlY2sgYSBuZWdhdGl2ZSBsY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNuc3RfaXNfbmVnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yX2ZvdW5kID0gY2hlY2soeCwgLXksIG5mYWN0b3JzW2ldLCBjcCk7IC8vY2hlY2sgYSBuZWdhdGl2ZSBjb25zdGFudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwb2x5O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXF1aXZhbGVudCBvZiBzcXVhcmUgZnJlZSBmYWN0b3IgZm9yIG11bHRpdmFyaWF0ZSBwb2x5bm9taWFsc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IHN5bWJvbFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGZhY3RvcnNcclxuICAgICAgICAgICAgICogQHJldHVybnMge0FsZ2VicmFMIzE4LkZhY3Rvci5tU3FmckZhY3Rvci5zeW1ib2x8QXJyYXl8QWxnZWJyYUwjMTguX18uRmFjdG9yLm1TcWZyRmFjdG9yLmR9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBtU3FmckZhY3RvcjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwICE9PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0gdmFyaWFibGVzKHN5bWJvbCkucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSB2YXJpYWJsZSBhbmQgcmVtb3ZlIHRoZSBwYXJ0aWFsIGRlcml2YXRpdmVzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodmFyc1tpXSA9PT0gc3ltYm9sLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgZGVyaXZhdGl2ZSB0ZWxscyB1cyBub3RoaW5nIHNpbmNlIHRoaXMgc3ltYm9sIGlzIGFscmVhZHkgdGhlIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IGNvcmUuQ2FsY3VsdXMuZGlmZihzeW1ib2wsIHZhcnNbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gX18uRmFjdG9yLmNvZWZmRmFjdG9yKGRpZmYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGQuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJpYWwgZGl2aXNpb24gdG8gc2VlIGlmIGZhY3RvcnMgaGF2ZSB3aG9sZSBudW1iZXJzLiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpcyBjYW4gYmUgb3B0aW1pemVkIGJ5IHN0b3BwaW5nIGFzIHNvb24gYXMgY2FuX2RpdmlkZSBpcyBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIHdpbGwgYWxzbyBuZWVkIHV0aWxpemUgYmlnIG51bWJlciBhdCBzb21lIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuX2RpdmlkZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkLmlzQ29uc3RhbnQoKSAmJiBzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgdGhlIGNvZWZmaWNpZW50c1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4Lm11bHRpcGxpZXIgJSBkICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuX2RpdmlkZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgd2UgY2FuIGRpdmlkZSB0aGVuIGRvIHNvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYW5fZGl2aWRlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBfXy5kaXYoc3ltYm9sLCBkLmNsb25lKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfZmFjdG9yID0gZGl2WzFdLmVxdWFscygwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGl2WzBdLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChkaXZbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNfZmFjdG9yID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNfZmFjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoZGl2WzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGlzX2ZhY3RvcilcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy9kaWZmZXJlbmNlIG9mIHNxdWFyZXMgZmFjdG9yaXphdGlvblxyXG4gICAgICAgICAgICBzcWRpZmY6IGZ1bmN0aW9uIChzeW1ib2wsIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCdhbGwnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG9cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZV9zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5ibG9jaygnUE9TSVRJVkVfTVVMVElQTElFUlMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sLnVud3JhcFBBUkVOUyhtYXRoLnNxcnQobWF0aC5hYnMoeCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdGVkID0gY29yZS5VdGlscy5zZXBhcmF0ZShzeW1ib2wuY2xvbmUoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmpfYXJyYXkgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIHVuaXF1ZSB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gc2VwYXJhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHggIT09ICdjb25zdGFudHMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpfYXJyYXkucHVzaChzZXBhcmF0ZWRbeF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG9ial9hcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnBvd2VyIC0gYS5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiB2YXJpYWJsZXMgYXMgdW5pcXVlIHZhcmlhYmxlcyB0aGVuIHdlIGNhbiBhcHBseSB0aGUgZGlmZmVyZW5jZSBvZiBzcXVhcmVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYob2JqX2FycmF5Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IG9ial9hcnJheS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IG9ial9hcnJheS5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV2ZW4oYS5wb3dlcikgJiYgZXZlbihiLnBvd2VyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGEuc2lnbigpID09PSBiLnNpZ24oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGEuZ3JvdXAgPT09IFMgJiYgYi5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmFjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5pc0NvbXBvc2l0ZSgpICYmIGIucG93ZXIuZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgc3F1YXJlIGZyb20gYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHJlbW92ZV9zcXVhcmUoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IF9fLkZhY3Rvci5mYWN0b3IoXy5hZGQoYSwgc2VwYXJhdGVkLmNvbnN0YW50cykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZi5wb3dlci5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoXy5zdWJ0cmFjdChmLmNsb25lKCksIGIuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKF8uYWRkKGYsIGIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGEucG93U2ltcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGIucG93U2ltcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKChhLmdyb3VwID09PSBTIHx8IGEuZm5hbWUgPT09ICcnKSAmJiBhLnBvd2VyLmVxdWFscygyKSAmJiAoYi5ncm91cCA9PT0gUyB8fCBiLmZuYW1lID09PSAnJykgJiYgYi5wb3dlci5lcXVhbHMoMikgJiYgIXNlcGFyYXRlZC5jb25zdGFudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEubXVsdGlwbGllci5ncmVhdGVyVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gcmVtb3ZlX3NxdWFyZShhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHJlbW92ZV9zcXVhcmUoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmFkZChfLnN1YnRyYWN0KGEuY2xvbmUoKSwgYi5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoXy5hZGQoYSwgYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vZmFjdG9yaW5nIGZvciBtdWx0aXZhcmlhdGVcclxuICAgICAgICAgICAgbWZhY3RvcjogZnVuY3Rpb24gKHN5bWJvbCwgZmFjdG9ycykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZm5hbWUgPT09ICdzcXJ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yczIgPSBuZXcgRmFjdG9ycygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IF9fLkZhY3Rvci5jb21tb24oc3ltYm9sLmFyZ3NbMF0uY2xvbmUoKSwgZmFjdG9yczIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBfXy5GYWN0b3IuY29lZmZGYWN0b3IoYXJnLCBmYWN0b3JzMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ubXVsdGlwbHkoXy5zeW1mdW5jdGlvbignc3FydCcsIFthcmddKSwgXy5wYXJzZShzeW1ib2wubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzMi5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLm11bHRpcGx5KHN5bWJvbCwgXy5wYXJzZShjb3JlLlV0aWxzLmZvcm1hdCgnc3FydCh7MH0pJywgeCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NxdWFyZSBmcmVlIGZhY3Rvcml6YXRpb25cclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5GYWN0b3IubVNxZnJGYWN0b3Ioc3ltYm9sLCBmYWN0b3JzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90cnkgZmFjdG9yIG91dCBjb21tb24gZmFjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc3ltYm9sID0gX18uRmFjdG9yLmNvbW1vbihzeW1ib2wsIGZhY3RvcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFycyA9IHZhcmlhYmxlcyhzeW1ib2wpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9scyA9IHN5bWJvbC5jb2xsZWN0U3ltYm9scygpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sLnVud3JhcFNRUlQoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGVzID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gdmFycy5sZW5ndGgsIG4gPSBzeW1ib2xzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAvL3Rha2UgYWxsIHRoZSB2YXJpYWJsZXMgaW4gdGhlIHN5bWJvbCBhbmQgb3JnYW5pemUgYnkgdmFyaWFibGUgbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vZS5nLiBhXjIrYV4yK2IqYSAtPiB7YToge2FeMywgYV4yLCBiKmF9LCBiOiB7YiphfX1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHZhcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFt2XSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gc3ltYm9sc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHMuY29udGFpbnModikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHMudmFsdWUgPT09IHYgPyBzLnBvd2VyLnRvRGVjaW1hbCgpIDogcy5zeW1ib2xzW3ZdLnBvd2VyLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFtYXhlc1t2XSB8fCBwIDwgbWF4ZXNbdl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGVzW3ZdID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRbdl0gPSBfLmFkZChzb3J0ZWRbdl0sIHMuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBzb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBfLnBhcnNlKHggKyAnXicgKyBtYXhlc1t4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBfLmRpdmlkZShzb3J0ZWRbeF0sIHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X2ZhY3RvciA9IF8uZXhwYW5kKGRpdik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXdfZmFjdG9yLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvL3doeSBkaXZpZGUgYnkgb25lLiBKdXN0IG1vdmUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXZpZGVkID0gX18uZGl2KHN5bWJvbC5jbG9uZSgpLCBuZXdfZmFjdG9yKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpdmlkZWRbMF0uZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbnQgZmFjdG9yIGFueW1vcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBwb3RlbnRpYWxseSBlbmRlZCB1cCB3aXRoIGZyYWN0aW9uYWwgY29lZmZpY2llbnRzIHdoZW4gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaWFsIGRpdmlzaW9uIHdhcyBwZXJmb3JtZWQuIFdlIG5lZWQgdG8gcmVtb3ZlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNoZWNrIHdpbGwgbW9yZSB0aGVuIGxpa2VseSBiZWNvbWUgc3VwZXJmbHVvdXMgd2l0aCBpbXByb3ZlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcG9seW5vbWlhbCBkaXZpc2lvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkaXZpZGVkWzFdLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc19mcmFjdGlvbnMgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZpZGVkWzBdLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighaXNJbnQoeC5tdWx0aXBsaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNfZnJhY3Rpb25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmFjdG9yIGlzbid0IHJlYWxseSBhIGZhY3RvciBhbmQgbmVlZHMgdG8gYmUgcHV0IGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGhhc19mcmFjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZpZGVkWzFdID0gXy5leHBhbmQoXy5tdWx0aXBseShkaXZpZGVkWzFdLCBuZXdfZmFjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5ldyBmYWN0b3IgaXMgbm90IGp1c3Qgb25lLCB3ZSBleGl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVnX251bWVyaWNfZmFjdG9yID0gaXNJbnQobmV3X2ZhY3RvcikgJiYgbmV3X2ZhY3Rvci5sZXNzVGhhbigwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpdmlkZWRbMV0uZXF1YWxzKDApICYmICFuZWdfbnVtZXJpY19mYWN0b3IpIHsgLy93ZSBmb3VuZCBhdCBsZWFzdCBvbmUgZmFjdG9yXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mYWN0b3JzLmFkZChuZXdfZmFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gX18uZGl2KHN5bWJvbC5jbG9uZSgpLCBkaXZpZGVkWzBdLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBkWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgbGVmdCB0byBkbyBzaW5jZSB3ZSBkaWRuJ3QgZ2V0IGEgcmVkdWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gZFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgZG9uJ3Qgd2FudCB0byBqdXN0IGZsaXAgdGhlIHNpZ24uIElmIHRoZSByZW1haW5kZXIgaXMgLTEgdGhlbiB3ZSBhY2NvbXBsaXNoZWQgbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hbmQgd2UganVzdCByZXR1cm4gdGhlIHN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgciBlcXVhbHMgemVybyB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIHNvIHdlJ3JlIGRvbmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyLmVxdWFscygtMSkgJiYgIXN5bWJvbC5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gZGl2aWRlZFswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKGZhY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtID0gX18uRmFjdG9yLnJlZHVjZShmYWN0b3IsIGZhY3RvcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighc3ltYm9sLmVxdWFscyhyZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uRmFjdG9yLm1mYWN0b3IocmVtLCBmYWN0b3JzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMuYWRkKGZhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBzeW1ib2wgaXMgemVybyB0aGVuIHdlJ3JlIGRvbmUuIFRPRE86IFJldGhpbmsgdGhpcyBsb2dpYyBhIGJpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyLmlzQ29uc3RhbnQoJ2FsbCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5hZGQocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLkZhY3Rvci5tZmFjdG9yKHIsIGZhY3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2RpZmZlcmVuY2Ugb2Ygc3F1YXJlcyBmYWN0b3JpemF0aW9uXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5GYWN0b3Iuc3FkaWZmKHN5bWJvbCwgZmFjdG9ycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9mYWN0b3JzIGJ5IGZpc2hpbmcgZm9yIHplcm9lc1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gX18uRmFjdG9yLnplcm9lcyhzeW1ib2wsIGZhY3RvcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0byBzZWUgaWYgYSBzZXQgb2YgXCJlcXVhdGlvbnNcIiBpcyBsaW5lYXIuIFxyXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYWxsTGluZWFyOiBmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBsID0gc2V0Lmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYoIV9fLmlzTGluZWFyKHNldFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBcImVxdWF0aW9uXCIgaXMgbGluZWFyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0xpbmVhcjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXR1cyA9IGZhbHNlLCBnID0gZS5ncm91cDtcclxuICAgICAgICAgICAgaWYoZyA9PT0gUEwgfHwgZyA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHMgaW4gZS5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IGUuc3ltYm9sc1tzXSwgc2cgPSBzeW1ib2wuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc2cgPT09IEZOIHx8IHNnID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc2cgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbmVlZHMgZnVydGhlciBjaGVja2luZyBzaW5jZSBpdCBtaWdodCBiZSBpbWFnaW5hcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gdmFyaWFibGVzKHN5bWJvbCkubGVuZ3RoID09PSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2cgPT09IFBMIHx8IHNnID09PSBDUClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IF9fLmlzTGluZWFyKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwICE9PSBOICYmIHN5bWJvbC5wb3dlci50b1N0cmluZygpICE9PSAnMScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IFMgJiYgZS5wb3dlciA9PT0gMSlcclxuICAgICAgICAgICAgICAgIHN0YXR1cyA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnY2Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3M7XHJcbiAgICAgICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgY29yZS5WZWN0b3IpXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzWzBdLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gY29yZS5VdGlscy5hcmd1bWVudHMyQXJyYXkoYXJndW1lbnRzKTtcclxuXHJcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBlYXJseVxyXG4gICAgICAgICAgICBpZihhcmdzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICBlbHNlIGlmKGFyZ3MubGVuZ3RoID09PSAxKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XHJcblxyXG4gICAgICAgICAgICB2YXIgYXBwZWFyZWQgPSBbXSwgZXZhbHVhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmKGFyZ3NbaV0uZ3JvdXAgPT09IEZOICYmIGFyZ3NbaV0uZm5hbWUgPT09ICdnY2QnKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29tcHJlc3MgZ2NkKGEsZ2NkKGIsYykpIGludG8gZ2NkKGEsYixjKVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChhcmd1bWVudHNbaV0uYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9kbyBub3Qga2VlcCBnY2QgaW4gYXJnc1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vTG9vayBpZiB0aGVyZSBhcmUgYW55IGNvbW1vbiB2YXJpYWJsZXMgc3VjaCB0aGF0XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nY2QoYSxiKSA9PiBnY2QoYSxiKTsgZ2NkKGEsYSkgPT4gYVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0gdmFyaWFibGVzKGFyZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaGF2ZUludGVyc2VjdGlvbih2YXJzLCBhcHBlYXJlZCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL09rLCB0aGVyZSBhcmUgY29tbW9uIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVhcmVkID0gYXBwZWFyZWQuY29uY2F0KHZhcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2FwcGVhcmVkLmxlbmd0aCBpcyAwIHdoZW4gYWxsIGFyZ3VtZW50cyBhcmUgZ3JvdXAgTlxyXG4gICAgICAgICAgICBpZihldmFsdWF0ZSB8fCBhcHBlYXJlZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETzogZGlzdHJpYnV0ZSBleHBvbmVudCBzbyB0aGF0IChhXi0xKmJeLTEpXi0xID0+IGEqYlxyXG4gICAgICAgICAgICAgICAgaWYoYXJncy5ldmVyeShmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5nZXREZW5vbSgpLmVxdWFscygxKVxyXG4gICAgICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWdncmVnYXRlID0gYXJnc1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlID0gX18uZ2NkXyhhcmdzW2ldLCBhZ2dyZWdhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWdncmVnYXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nY2RfIGNhbm5vdCBoYW5kbGUgZGVub21pbmF0b3JzIGNvcnJlY3RseVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShfXy5nY2QuYXBwbHkobnVsbCwgYXJncy5tYXAoZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmxjbS5hcHBseShudWxsLCBhcmdzLm1hcChmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5nZXREZW5vbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignZ2NkJywgYXJncyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnY2RfOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICBpZihhLmdyb3VwID09PSBGTiB8fCBhLmdyb3VwID09PSBQKVxyXG4gICAgICAgICAgICAgICAgYSA9IGNvcmUuVXRpbHMuYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShhKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYoYi5ncm91cCA9PT0gRk4pXHJcbiAgICAgICAgICAgICAgICBiID0gY29yZS5VdGlscy5ibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZihhLmlzQ29uc3RhbnQoKSAmJiBiLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGNvcmUuTWF0aDIuUUdDRChuZXcgRnJhYygrYSksIG5ldyBGcmFjKCtiKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChjb3JlLk1hdGgyLlFHQ0QobmV3IEZyYWMoK2EpLCBuZXcgRnJhYygrYikpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRlbiA9IF8ubXVsdGlwbHkoYS5nZXREZW5vbSgpIHx8IG5ldyBTeW1ib2woMSksIGIuZ2V0RGVub20oKSB8fCBuZXcgU3ltYm9sKDEpKS5pbnZlcnQoKTtcclxuICAgICAgICAgICAgYSA9IF8ubXVsdGlwbHkoYS5jbG9uZSgpLCBkZW4uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIGIgPSBfLm11bHRpcGx5KGIuY2xvbmUoKSwgZGVuLmNsb25lKCkpO1xyXG5cclxuICAgICAgICAgICAgLy9mZWVscyBjb3VudGVyIGludHVpdGl2ZSBidXQgaXQgd29ya3MuIElzc3VlICMxMjMgKG5lcmRhbWVyKFwiZ2NkKHgreSwoeCt5KV4yKVwiKSlcclxuICAgICAgICAgICAgYSA9IF8uZXhwYW5kKGEpO1xyXG4gICAgICAgICAgICBiID0gXy5leHBhbmQoYik7XHJcblxyXG4gICAgICAgICAgICBpZihhLmdyb3VwID09PSBDQiB8fCBiLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHEgPSBfLmRpdmlkZShhLmNsb25lKCksIGIuY2xvbmUoKSk7IC8vZ2V0IHRoZSBxdW90aWVudFxyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBfLm11bHRpcGx5KGIuY2xvbmUoKSwgcS5nZXREZW5vbSgpLmludmVydCgpKTsvL211bHRpcGx5IGJ5IHRoZSBkZW5vbWluYXRvclxyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGV5IGhhdmUgYSBjb21tb24gZmFjdG9yIHRoZW4gdGhlIHJlc3VsdCB3aWxsIG5vdCBlcXVhbCBvbmUgXHJcbiAgICAgICAgICAgICAgICBpZighdC5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vanVzdCB0YWtlIHRoZSBnY2Qgb2YgZWFjaCBjb21wb25lbnQgd2hlbiBlaXRoZXIgb2YgdGhlbSBpcyBpbiBncm91cCBFWFxyXG4gICAgICAgICAgICBpZihhLmdyb3VwID09PSBFWCB8fCBiLmdyb3VwID09PSBFWClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdjZF9tID0gbmV3IFN5bWJvbChjb3JlLk1hdGgyLkdDRChhLm11bHRpcGxpZXIsIGIubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdjZF92ID0gX18uZ2NkXyhhLnZhbHVlID09PSBDT05TVF9IQVNIID8gbmV3IFN5bWJvbCgxKSA6IF8ucGFyc2UoYS52YWx1ZSksIGIudmFsdWUgPT09IENPTlNUX0hBU0ggPyBuZXcgU3ltYm9sKDEpIDogXy5wYXJzZShiLnZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2NkX3AgPSBfXy5nY2RfKF8ucGFyc2UoYS5wb3dlciksIF8ucGFyc2UoYi5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoZ2NkX20sIF8ucG93KGdjZF92LCBnY2RfcCkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihhLmxlbmd0aCA8IGIubGVuZ3RoKSB7IC8vc3dhcCdtXHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGE7XHJcbiAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgIGIgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YXJzX2EgPSB2YXJpYWJsZXMoYSksIHZhcnNfYiA9IHZhcmlhYmxlcyhiKTtcclxuICAgICAgICAgICAgaWYoKHZhcnNfYS5sZW5ndGggPT09IHZhcnNfYi5sZW5ndGggJiYgdmFyc19hLmxlbmd0aCA9PT0gMSAmJiB2YXJzX2FbMF0gPT09IHZhcnNfYlswXSlcclxuICAgICAgICAgICAgICAgICAgICB8fCB2YXJzX2EubGVuZ3RoID09PSAxICYmIHZhcnNfYi5sZW5ndGggPT09IDBcclxuICAgICAgICAgICAgICAgICAgICB8fCB2YXJzX2EubGVuZ3RoID09PSAwICYmIHZhcnNfYi5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGEgPSBuZXcgUG9seW5vbWlhbChhKTtcclxuICAgICAgICAgICAgICAgIGIgPSBuZXcgUG9seW5vbWlhbChiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShhLmdjZChiKS50b1N5bWJvbCgpLCBkZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIGdjZCBvZiB0aGUgbXVsdGlwaWVyc1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgcmlkIG9mIGdjZCBpbiBjb2VmZnNcclxuICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgYS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllcnMucHVzaCh4Lm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBiLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVycy5wdXNoKHgubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgVDtcclxuICAgICAgICAgICAgICAgIHdoaWxlKCFiLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gYi5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBhLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgVCA9IF9fLmRpdihhLCB0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IFRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoVFswXS5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gXy5tdWx0aXBseShuZXcgU3ltYm9sKGNvcmUuTWF0aDIuUUdDRChhLm11bHRpcGxpZXIsIGIubXVsdGlwbGllcikpLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKG5ldyBTeW1ib2woY29yZS5NYXRoMi5RR0NEKGEubXVsdGlwbGllciwgYi5tdWx0aXBsaWVyKSksIGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBnY2QgPSBjb3JlLk1hdGgyLlFHQ0QuYXBwbHkodW5kZWZpbmVkLCBtdWx0aXBsaWVycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIWdjZC5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeC5tdWx0aXBsaWVyID0geC5tdWx0aXBsaWVyLmRpdmlkZShnY2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHN5bWJvbGljIGZ1bmN0aW9uIGZvciBnY2QgaW4gaW5kZXRlcm1pbmF0ZSBmb3JtXHJcbiAgICAgICAgICAgICAgICBpZihhLmVxdWFscygxKSAmJiAhYS5pc0NvbnN0YW50KCkgJiYgIWIuaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShfLnN5bWZ1bmN0aW9uKCdnY2QnLCBhcmd1bWVudHMpLCBkZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShhLCBkZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsY206IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy9odHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vYS8zMTkzMTBcclxuICAgICAgICAgICAgLy9nZW5lcmFsaXphdGlvbiBvZiB0aGUgMi12YXJpYWJsZSBmb3JtdWxhIG9mIGxjbVxyXG5cclxuICAgICAgICAgICAgdmFyIGFyZ3M7XHJcbiAgICAgICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICBpZihhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBjb3JlLlZlY3RvcilcclxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzWzBdLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIF8uZXJyb3IoJ2xjbSBleHBlY3RzIGVpdGhlciAxIHZlY3RvciBvciAyIG9yIG1vcmUgYXJndW1lbnRzJyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBjb3JlLlV0aWxzLmFyZ3VtZW50czJBcnJheShhcmd1bWVudHMpO1xyXG5cclxuICAgICAgICAgICAgLy9wcm9kdWN0IG9mIGFsbCBhcmd1bWVudHNcclxuICAgICAgICAgICAgLy9zdGFydCB3aXRoIG5ldyBTeW1ib2woMSkgc28gdGhhdCBwcmV2LmNsb25lKCkgd2hpY2ggbWFrZXMgdW5uZXNzZXNhcnkgY2xvbmVzIGNhbiBiZSBhdm9pZGVkXHJcbiAgICAgICAgICAgIHZhciBudW1lciA9IGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShwcmV2LCBjdXJyLmNsb25lKCkpXHJcbiAgICAgICAgICAgIH0sIG5ldyBTeW1ib2woMSkpO1xyXG5cclxuICAgICAgICAgICAgLy9nY2Qgb2YgY29tcGxlbWVudGFyeSB0ZXJtc1xyXG4gICAgICAgICAgICB2YXIgZGVub21fYXJncyA9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTgyMjMwNzJcclxuICAgICAgICAgICAgICAgIC8vdGFrZSBhbGwgY29tcGxlbWVudGFyeSB0ZXJtcywgZS5nLlxyXG4gICAgICAgICAgICAgICAgLy9bYSxiLGNdID0+IFthKmIsIGIqYywgYSpjXVxyXG4gICAgICAgICAgICAgICAgLy9bYSxiLGMsZF0gPT4gW2EqYipjLCBhKmIqZCwgYSpjKmQsIGIqYypkXVxyXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChpbnB1dCwgc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplID0gTnVtYmVyKHNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLCByZXN1bHQsIG1hc2ssIGksIHRvdGFsID0gTWF0aC5wb3coMiwgaW5wdXQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKG1hc2sgPSBzaXplOyBtYXNrIDwgdG90YWw7IG1hc2srKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaW5wdXQubGVuZ3RoIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoKG1hc2sgJiAoMSA8PCBpKSkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5wdXRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGktLSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA9PT0gc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0IHdpdGggbmV3IFN5bWJvbCgxKSBzbyB0aGF0IHByZXYuY2xvbmUoKSB3aGljaCBtYWtlcyB1bm5lc3Nlc2FyeSBjbG9uZXMgY2FuIGJlIGF2b2lkZWRcclxuICAgICAgICAgICAgICAgICAgICB9KShhcmd1bWVudHMsIGFyZ3VtZW50cy5sZW5ndGggLSAxKS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4LnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHByZXYsIGN1cnIuY2xvbmUoKSlcclxuICAgICAgICAgICAgICAgIH0sIG5ldyBTeW1ib2woMSkpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRlbm9tO1xyXG4gICAgICAgICAgICAvL2Rvbid0IGVhdCB0aGUgZ2NkIHRlcm0gaWYgYWxsIGFyZ3VtZW50cyBhcmUgc3ltYm9sc1xyXG4gICAgICAgICAgICBpZihhcmdzLmV2ZXJ5KGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5pc1ZhcmlhYmxlU3ltYm9sKHgpXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAgICAgZGVub20gPSBfLnN5bWZ1bmN0aW9uKCdnY2QnLCBjb3JlLlV0aWxzLmFycmF5VW5pcXVlKGRlbm9tX2FyZ3MpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZGVub20gPSBfXy5nY2QuYXBwbHkobnVsbCwgZGVub21fYXJncyk7XHJcbiAgICAgICAgICAgIC8vZGl2aWRlIHByb2R1Y3Qgb2YgYWxsIGFyZ3VtZW50cyBieSBnY2Qgb2YgY29tcGxlbWVudGFyeSB0ZXJtc1xyXG4gICAgICAgICAgICB2YXIgZGl2ID0gXy5kaXZpZGUobnVtZXIsIGRlbm9tKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpdmlkZXMgb25lIGV4cHJlc3Npb24gYnkgYW5vdGhlclxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2wxXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbDJcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiAoc3ltYm9sMSwgc3ltYm9sMikge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCByZW1haW5kZXIsIGZhY3RvcmVkLCBkZW47XHJcbiAgICAgICAgICAgIGZhY3RvcmVkID0gY29yZS5BbGdlYnJhLkZhY3Rvci5mYWN0b3Ioc3ltYm9sMS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgZGVuID0gZmFjdG9yZWQuZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgaWYoIWRlbi5pc0NvbnN0YW50KCdhbGwnKSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sMSA9IF8uZXhwYW5kKFN5bWJvbC51bndyYXBQQVJFTlMoXy5tdWx0aXBseShmYWN0b3JlZCwgZGVuLmNsb25lKCkpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgLy9yZXNldCB0aGUgZGVub21pbmF0b3Igc2luY2Ugd2UncmUgbm90IGRpdmlkaW5nIGJ5IGl0IGFueW1vcmVcclxuICAgICAgICAgICAgICAgIGRlbiA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IF9fLmRpdihzeW1ib2wxLCBzeW1ib2wyKTtcclxuICAgICAgICAgICAgcmVtYWluZGVyID0gXy5kaXZpZGUocmVzdWx0WzFdLCBzeW1ib2wyKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKF8uYWRkKHJlc3VsdFswXSwgcmVtYWluZGVyKSwgZGVuKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpdjogZnVuY3Rpb24gKHN5bWJvbDEsIHN5bWJvbDIpIHtcclxuICAgICAgICAgICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMgdGhlbiBhc3N1bWUgdGhhdCBkaXZpc2lvbiBmYWlsZWQgd2l0aFxyXG4gICAgICAgICAgICAvLyBhIHJlbWFpbmRlciBvZiB6ZXJvIGFuZCB0aGUgb3JpZ2luYWwgcXVvdGllbnRcclxuICAgICAgICAgICAgdmFyIGZhaWwgPSBbbmV3IFN5bWJvbCgwKSwgc3ltYm9sMS5jbG9uZSgpXTtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGl2aXNpb24gYnkgY29uc3RhbnRzXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wyLmlzQ29uc3RhbnQoJ2FsbCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sMS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgubXVsdGlwbGllciA9IHgubXVsdGlwbGllci5kaXZpZGUoc3ltYm9sMi5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3N5bWJvbDEsIG5ldyBTeW1ib2woMCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU28gdGhhdCBmYWN0b3JpemVkIHN5bWJvbHMgZG9uJ3QgYWZmZWN0IHRoZSByZXN1bHRcclxuICAgICAgICAgICAgICAgIHN5bWJvbDEgPSBfLmV4cGFuZChzeW1ib2wxKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbDIgPSBfLmV4cGFuZChzeW1ib2wyKTtcclxuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZS4gTWF5IG5lZWQgcmV2aXNpdGluZ1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sMS5ncm91cCA9PT0gUyAmJiBzeW1ib2wyLmdyb3VwID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gc3ltYm9sMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuKHN5bWJvbDIuY2xvbmUoKSwgeCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sMS5pc0xpbmVhcigpICYmIGYueCAmJiBmLnguaXNMaW5lYXIoKSAmJiBzeW1ib2wyLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBTeW1ib2wuY3JlYXRlKHN5bWJvbDEubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXy5kaXZpZGUoay5jbG9uZSgpLCBmLmEuY2xvbmUoKSksIF8uZGl2aWRlKF8ubXVsdGlwbHkoaywgZi5iKSwgZi5hKS5uZWdhdGUoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sMS5ncm91cCA9PT0gUyAmJiBzeW1ib2wyLmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBfLmRpdmlkZShzeW1ib2wxLmNsb25lKCksIHN5bWJvbDIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoci5pc0NvbnN0YW50KCkpIC8vd2UgaGF2ZSBhIHdob2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbciwgbmV3IFN5bWJvbCgwKV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgU3ltYm9sKDApLCBzeW1ib2wxLmNsb25lKCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbDFfaGFzX2Z1bmMgPSBzeW1ib2wxLmhhc0Z1bmMoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sMl9oYXNfZnVuYyA9IHN5bWJvbDIuaGFzRnVuYygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZV9mdW5jcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc3Vic3RpdHV0ZSBvdXQgZnVuY3Rpb25zIHNvIHdlIGNhbiB0cmVhdCB0aGVtIGFzIHJlZ3VsYXIgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wxX2hhc19mdW5jIHx8IHN5bWJvbDJfaGFzX2Z1bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZV9mdW5jcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sMSA9IF8ucGFyc2UoY29yZS5VdGlscy5zdWJGdW5jdGlvbnMoc3ltYm9sMSwgbWFwKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wyID0gXy5wYXJzZShjb3JlLlV0aWxzLnN1YkZ1bmN0aW9ucyhzeW1ib2wyLCBtYXApKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnMgPSBjb3JlLlV0aWxzLmdldEZ1bmN0aW9uc1N1YnMobWFwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vZ2V0IGEgbGlzdCBvZiB0aGUgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICB2YXIgdmFycyA9IGNvcmUuVXRpbHMuYXJyYXlVbmlxdWUodmFyaWFibGVzKHN5bWJvbDEpLmNvbmNhdCh2YXJpYWJsZXMoc3ltYm9sMikpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdCwgcmVtO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdHJlYXQgaW1hZ2luYXJ5IG51bWJlcnMgYXMgdmFyaWFibGVzXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wxLmlzSW1hZ2luYXJ5KCkgfHwgc3ltYm9sMi5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFycy5wdXNoKGNvcmUuU2V0dGluZ3MuSU1BR0lOQVJZKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih2YXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IFBvbHlub21pYWwoc3ltYm9sMSkuZGl2aWRlKG5ldyBQb2x5bm9taWFsKHN5bWJvbDIpKTtcclxuICAgICAgICAgICAgICAgICAgICBxdW90ID0gcVswXS50b1N5bWJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHFbMV0udG9TeW1ib2woKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcnMucHVzaChDT05TVF9IQVNIKTsgLy90aGlzIGlzIGZvciB0aGUgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvbnZlcnQgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGFycltpXS50b1N5bWJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5hZGQoc3ltYm9sLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbGx5IE1hcnRpbi4gVGhpcyBpcyB3aHkgeW91IGRvY3VtZW50LiBJIGRvbid0IHJlbWVtYmVyIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRfdW5pcXVlX21heCA9IGZ1bmN0aW9uICh0ZXJtLCBhbnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRlcm0udGVybXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMCwgaWR4O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRlcm0udGVybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ZXJtLnRlcm1zW2ldLmVxdWFscyhtYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvdW50ID4gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgdGVybS50ZXJtcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ZXJtLnRlcm1zW2ldLmVxdWFscyhtYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21heCwgaWR4LCB0ZXJtXTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmllcyB0byBmaW5kIGFuIExUIGluIHRoZSBkaXZpZGVuZCB0aGF0IHdpbGwgc2F0aXNmeSBkaXZpc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRfZGV0ID0gZnVuY3Rpb24gKHMsIGxvb2thdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb29rYXQgPSBsb29rYXQgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRldCA9IHNbbG9va2F0XSwgbCA9IHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighZGV0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2VsaW1pbmF0ZSB0aGUgZmlyc3QgdGVybSBpZiBpdCBkb2Vzbid0IGFwcGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bWF4ID0gZ2V0X3VuaXF1ZV9tYXgoZGV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gbG9va2F0ICsgMTsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm0gPSBzW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc19lcXVhbCA9IGRldC5zdW0uZXF1YWxzKHRlcm0uc3VtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFpc19lcXVhbCAmJiB1bWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc19lcXVhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBkaWZmZXJlbmNlcyBvZiB0aGVpciBtYXhlcy4gVGhlIG9uZSB3aXRoIHRoZSBiaWdnZXN0IGRpZmZlcmVuY2UgZ292ZXJuc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4geF4yKnleMyB2cyB4XjIqeV4zIGlzIHVuY2xlYXIgYnV0IHRoaXMgaXNuJ3QgdGhlIGNhc2UgaW4geCp5IGFuZCB4XjJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4MSwgbWF4MiwgaWR4MSwgaWR4MiwgbDIgPSBkZXQudGVybXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBsMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtMSA9IGRldC50ZXJtc1tqXSwgaXRlbTIgPSB0ZXJtLnRlcm1zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgbWF4MSA9PT0gJ3VuZGVmaW5lZCcgfHwgaXRlbTEuZ3JlYXRlclRoYW4obWF4MSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDEgPSBpdGVtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeDEgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBtYXgyID09PSAndW5kZWZpbmVkJyB8fCBpdGVtMi5ncmVhdGVyVGhhbihtYXgyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4MiA9IGl0ZW0yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4MiA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayB0aGVpciBkaWZmZXJlbmNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkMSA9IG1heDEuc3VidHJhY3QodGVybS50ZXJtc1tpZHgxXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkMiA9IG1heDIuc3VidHJhY3QoZGV0LnRlcm1zW2lkeDJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkMiA+IGQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVtYXggPSBbbWF4MiwgaWR4MiwgdGVybV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkMSA+IGQyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVtYXggPSBbbWF4MSwgaWR4MSwgZGV0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBpdCdzIGEgc3VpdGFibGUgcGljayB0byBkZXRlcm1pbmUgdGhlIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW1heCA9IGdldF91bmlxdWVfbWF4KHRlcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYodW1heCkgcmV0dXJuIHVtYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodW1heClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bWF4ID0gZ2V0X3VuaXF1ZV9tYXgodGVybSk7IC8vY2FsY3VsYXRlIGEgbmV3IHVuaXF1ZSBtYXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBzdGlsbCBubyB1bWF4IHRoZW4gYW55IHdpbGwgZG8gc2luY2Ugd2UgaGF2ZSBhIHRpZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdW1heClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRfdW5pcXVlX21heChzWzBdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUsIGlkeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHMyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Rlcm0gPSBzMltpXS50ZXJtcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uZmlybSB0aGF0IHRoaXMgaXMgYSBnb29kIG1hdGNoIGZvciB0aGUgZGVub21pbmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IHVtYXhbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpZHggPT09IGN0ZXJtLmxlbmd0aCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IGN0ZXJtW2lkeF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighZS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0X2RldChzLCArK2xvb2thdCk7IC8vbG9vayBhdCB0aGUgbmV4dCB0ZXJtXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW1heDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdF9tYXAgPSBjb3JlLlV0aWxzLnRvTWFwT2JqKHZhcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbml0X3NvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5zdW0uc3VidHJhY3QoYS5zdW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2xhcmdlciA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFhIHx8ICFiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvL2l0J3MgZW1wdHkgc28uLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGEudGVybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEudGVybXNbaV0ubGVzc1RoYW4oYi50ZXJtc1tpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzMSA9IHN5bWJvbDEudEJhc2UodF9tYXApLnNvcnQoaW5pdF9zb3J0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gc3ltYm9sMi50QmFzZSh0X21hcCkuc29ydChpbml0X3NvcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBpc19sYXJnZXIoczFbMF0sIHMyWzBdKSAmJiBzMVswXS5jb3VudCA+IHMyWzBdLmNvdW50ID8gczIgOiBzMTsgLy9zaW5jZSB0aGUgbnVtIGlzIGFscmVhZHkgbGFyZ2VyIHRoYW4gd2UgY2FuIGdldCB0aGUgZGV0IGZyb20gZGVub21cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGV0ID0gZ2V0X2RldCh0YXJnZXQpOy8vd2UnbGwgYmVnaW4gYnkgYXNzdW1pbmcgdGhhdCB0aGlzIHdpbGwgbGV0IHVzIGtub3cgd2hpY2ggdGVybSBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVvdGllbnQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihkZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlYWRfdmFyID0gZGV0WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuX2RpdmlkZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhWzBdLnN1bS5lcXVhbHMoYlswXS5zdW0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+PSBiLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyeV9iZXR0ZXJfbGVhZF92YXIgPSBmdW5jdGlvbiAoczEsIHMyLCBsZWFkX3Zhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gczFbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHQudGVybXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNmID0gY2hlY2tlZFtqXSwgdHQgPSB0LnRlcm1zW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZFtqXSA9IHR0OyAvL2FkZCB0aGUgdGVybXMgZm9yIHRoZSBmaXJzdCBvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZiAmJiAhY2YuZXF1YWxzKHR0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWRbal0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNoZWNrZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGNoZWNrZWRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodCAmJiAhdC5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlYWRfdmFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2YgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwxID0gYS5sZW4oKSwgbDIgPSBiLmxlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsdiA9IGIudGVybXNbbGVhZF92YXJdLCBhbHYgPSBhLnRlcm1zW2xlYWRfdmFyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGwyID4gbDEgJiYgYmx2LmdyZWF0ZXJUaGFuKGFsdikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwyIC0gbDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmx2LnN1YnRyYWN0KGFsdik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgYmV0dGVyIGxlYWRfdmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWRfdmFyID0gdHJ5X2JldHRlcl9sZWFkX3ZhcihzMSwgczIsIGxlYWRfdmFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW9yZGVyIGJvdGggYWNjb3JkaW5nIHRvIHRoZSBtYXggcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgczEuc29ydChzZik7IC8vc29ydCB0aGVtIGJvdGggYWNjb3JkaW5nIHRvIHRoZSBsZWFkaW5nIHZhcmlhYmxlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMyLnNvcnQoc2YpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90cnkgdG8gYWRqdXN0IGlmIGRlbiBpcyBsYXJnZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZkdCA9IHMyWzBdLCBmbnQgPSBzMVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZW4gPSBuZXcgTVZUZXJtKG5ldyBGcmFjKDEpLCBbXSwgZm50Lm1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZkdC5zdW0uZ3JlYXRlclRoYW4oZm50LnN1bSkgJiYgZm50LmxlbigpID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGZudC50ZXJtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gZmR0LnRlcm1zW2ldLnN1YnRyYWN0KGZudC50ZXJtc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWQuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZCA9IGQuYWRkKG5ldyBGcmFjKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuLnRlcm1zW2ldID0gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHMxLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMVtqXS50ZXJtc1tpXSA9IHMxW2pdLnRlcm1zW2ldLmFkZChuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW4udGVybXNbaV0gPSBuZXcgRnJhYygwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdmlkZW5kX2xhcmdlciA9IGlzX2xhcmdlcihzMVswXSwgczJbMF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmV0eSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSAyMDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShkaXZpZGVuZF9sYXJnZXIgJiYgY2FuX2RpdmlkZShzMSwgczIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzYWZldHkrKyA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLmV4Y2VwdGlvbnMuSW5maW5pdGVMb29wRXJyb3IoJ1VuYWJsZSB0byBjb21wdXRlIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gczFbMF0uZGl2aWRlKHMyWzBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90aWVudC5wdXNoKHEpOyAvL2FkZCB3aGF0J3MgZGl2aWRlZCB0byB0aGUgcXVvdGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxLnNoaWZ0KCk7Ly90aGUgZmlyc3Qgb25lIGlzIGd1YXJhbnRlZWQgdG8gYmUgZ29uZSBzbyByZW1vdmUgZnJvbSBkaXZpZGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IHMyLmxlbmd0aDsgaSsrKSB7IC8vbG9vcCB0aHJvdWdoIHRoZSBkZW5vbWluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gczJbaV0ubXVsdGlwbHkocSkuZ2VuZXJhdGVJbWFnZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbDIgPSBzMS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSdyZSBzdWJ0cmFjdGluZyBmcm9tIDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsMiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmNvZWZmID0gdC5jb2VmZi5uZWcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEucHVzaCh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEuc29ydChzZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyID0gczFbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGN1ci5nZXRJbWcoKSA9PT0gdC5nZXRJbWcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyLmNvZWZmID0gY3VyLmNvZWZmLnN1YnRyYWN0KHQuY29lZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY3VyLmNvZWZmLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMucmVtb3ZlKHMxLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqLS07IC8vYWRqdXN0IHRoZSBpdGVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaiA9PT0gbDIgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmNvZWZmID0gdC5jb2VmZi5uZWcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxLnB1c2godCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMS5zb3J0KHNmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmlkZW5kX2xhcmdlciA9IGlzX2xhcmdlcihzMVswXSwgczJbMF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkaXZpZGVuZF9sYXJnZXIgJiYgczEubGVuZ3RoID49IHMyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vT25lIG1vcmUgdHJ5IHNpbmNlIHRoZXJlIG1pZ2h0IGJlIGEgdGVybXMgdGhhdCBpcyBsYXJnZXIgdGhhbiB0aGUgTFQgb2YgdGhlIGRpdmlzb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgczEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2aWRlbmRfbGFyZ2VyID0gaXNfbGFyZ2VyKHMxW2ldLCBzMlswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpdmlkZW5kX2xhcmdlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90YWtlIGl0IGZyb20gaXRzIGN1cnJlbnQgcG9zaXRpb24gYW5kIG1vdmUgaXQgdG8gdGhlIGZyb250XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMS51bnNoaWZ0KGNvcmUuVXRpbHMucmVtb3ZlKHMxLCBpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcXVvdCA9IHJlY29udmVydChxdW90aWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gcmVjb252ZXJ0KHMxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuID0gZGVuLnRvU3ltYm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3QgPSBfLmRpdmlkZShxdW90LCBkZW4uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IF8uZGl2aWRlKHJlbSwgZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9wdXQgYmFjayB0aGUgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAgICBpZihwYXJzZV9mdW5jcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1b3QgPSBfLnBhcnNlKHF1b3QudGV4dCgpLCBzdWJzKTtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSBfLnBhcnNlKHJlbS50ZXh0KCksIHN1YnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBbcXVvdCwgcmVtXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFpbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbmU6IGZ1bmN0aW9uICh2MSwgdjIsIHgpIHtcclxuICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc0FycmF5KHYxKSlcclxuICAgICAgICAgICAgICAgIHYxID0gY29yZS5VdGlscy5jb252ZXJ0VG9WZWN0b3IodjEpO1xyXG4gICAgICAgICAgICBpZihjb3JlLlV0aWxzLmlzQXJyYXkodjIpKVxyXG4gICAgICAgICAgICAgICAgdjIgPSBjb3JlLlV0aWxzLmNvbnZlcnRUb1ZlY3Rvcih2Mik7XHJcbiAgICAgICAgICAgIHggPSBfLnBhcnNlKHggfHwgJ3gnKTtcclxuICAgICAgICAgICAgaWYoIWNvcmUuVXRpbHMuaXNWZWN0b3IodjEpIHx8ICFjb3JlLlV0aWxzLmlzVmVjdG9yKHYyKSlcclxuICAgICAgICAgICAgICAgIF8uZXJyb3IoJ0xpbmUgZXhwZWN0cyBhIHZlY3RvciEgUmVjZWl2ZWQgXCInICsgdjEgKyAnXCIgJiBcIicgKyB2MiArICdcIicpO1xyXG4gICAgICAgICAgICB2YXIgZHggPSBfLnN1YnRyYWN0KHYyLmUoMSkuY2xvbmUoKSwgdjEuZSgxKS5jbG9uZSgpKSxcclxuICAgICAgICAgICAgICAgICAgICBkeSA9IF8uc3VidHJhY3QodjIuZSgyKS5jbG9uZSgpLCB2MS5lKDIpLmNsb25lKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBfLmRpdmlkZShkeSwgZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBfLm11bHRpcGx5KHgsIG0uY2xvbmUoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IF8ubXVsdGlwbHkodjEuZSgxKS5jbG9uZSgpLCBtKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8uYWRkKF8uc3VidHJhY3QoYSwgYiksIHYxLmUoMikuY2xvbmUoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBQYXJ0RnJhYzoge1xyXG4gICAgICAgICAgICBjcmVhdGVUZW1wbGF0ZTogZnVuY3Rpb24gKGRlbiwgZGVub21fZmFjdG9ycywgZl9hcnJheSwgdikge1xyXG4gICAgICAgICAgICAgICAgLy9jbGVhbiB1cCB0aGUgZGVub21pbmF0b3IgZnVuY3Rpb24gYnkgZmFjdG9ycyBzbyBpdCByZWR1Y2VzIG5pY2VseVxyXG4gICAgICAgICAgICAgICAgZGVuID0gX18uRmFjdG9yLmZhY3RvcihkZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY2xlYW4gdXAgZmFjdG9ycy4gVGhpcyBpcyBzbyBpbmVmZmljaWVudCBidXQgZmFjdG9ycyBhcmUgd3JhcHBlZCBpbiBwYXJlbnMgZm9yIHNhZmV0eVxyXG4gICAgICAgICAgICAgICAgZGVuLmVhY2goZnVuY3Rpb24gKHgsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IEZOICYmIHguZm5hbWUgPT09ICcnICYmIHguYXJnc1swXS5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHguYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zeW1ib2xzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbHNbeS52YWx1ZV0gPSB5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuID0geC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvcnMsIGZhY3RvcnNfdmVjLCBmLCBwLCBkZWcsIGRlZ3JlZXMsIG07XHJcbiAgICAgICAgICAgICAgICBmYWN0b3JzID0gZGVub21fZmFjdG9ycy5jb2xsZWN0RmFjdG9ycygpO1xyXG4gICAgICAgICAgICAgICAgZmFjdG9yc192ZWMgPSBbXTsgLy9hIHZlY3RvciBmb3IgdGhlIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICBkZWdyZWVzID0gW107XHJcbiAgICAgICAgICAgICAgICBtID0gbmV3IFN5bWJvbCgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZmFjdG9ycy5sZW5ndGg7IGkrKykgeyAvL2xvb3AgdGhyb3VnaCB0aGUgZmFjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBTeW1ib2wudW53cmFwUEFSRU5TKGZhY3RvcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaW4gaGUgZm9yIFBebiB3aGVyZSBQIGlzIHBvbHlub21pYWwgYW5kIG4gPSBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmFjdG9yLnBvd2VyLmdyZWF0ZXJUaGFuKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBOdW1iZXIoZmFjdG9yLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGZhY3Rvci5jbG9uZSgpLnRvTGluZWFyKCk7IC8vcmVtb3ZlIHRoZSBwb3dlciBzbyB3ZSBoYXZlIG9ubHkgdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZyA9IE51bWJlcihfXy5kZWdyZWUoZiwgdikpOyAvL2dldCB0aGUgZGVncmVlIG9mIGZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9leHBhbmQgdGhlIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgcDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWZhY3RvciA9IF8ucG93KGYuY2xvbmUoKSwgbmV3IFN5bWJvbChqICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZl9hcnJheS5wdXNoKGVmYWN0b3IuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF8uZGl2aWRlKGRlbi5jbG9uZSgpLCBlZmFjdG9yLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVncmVlcy5wdXNoKGRlZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzX3ZlYy5wdXNoKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgIFBvc3NpYmxlIGJ1Zy5cclxuICAgICAgICAgICAgICAgICAgICAgUmVtb3ZlZDogY2F1c2VzIDEvKDIwKzI0KngrNCp4XjIpIHRvIHJlc3VsdCBpbiAoLTEvNjQpKig1K3gpXigtMSkrKDEvNjQpKigxK3gpXigtMSlcclxuICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmYWN0b3IuaXNDb25zdGFudCgnYWxsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgbSA9IF8ubXVsdGlwbHkobSwgZmFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgZGVncmVlIG9mIHRoZSBmYWN0b3Igc28gd2UgdGFjayBpdCBvbiB0b3QgaGUgZmFjdG9yLiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2J1dCBmb3Igbm93IHdlIG5vdGUgaXQgb24gdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWcgPSBOdW1iZXIoX18uZGVncmVlKGZhY3RvciwgdikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmX2FycmF5LnB1c2goZmFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfLmRpdmlkZShkZW4uY2xvbmUoKSwgZmFjdG9yLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gXy5leHBhbmQoU3ltYm9sLnVud3JhcFBBUkVOUyhkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZ3JlZXMucHVzaChkZWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzX3ZlYy5wdXNoKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgdGhlIGNvbnN0YW50XHJcbiAgICAgICAgICAgICAgICBmX2FycmF5ID0gZl9hcnJheS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseSh4LCBtLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2ZfYXJyYXksIGZhY3RvcnNfdmVjLCBkZWdyZWVzXTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFydGZyYWM6IGZ1bmN0aW9uIChzeW1ib2wsIHYsIGFzX2FycmF5KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHZhcnMgPSB2YXJpYWJsZXMoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ID0gdiB8fCBfLnBhcnNlKHZhcnNbMF0pOyAvL21ha2Ugd3J0IG9wdGlvbmFsIGFuZCBhc3N1bWUgZmlyc3QgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bSwgZGVuLCBmYWN0b3JzLCB0ZmFjdG9ycywgb2ZhY3RvcnMsIG50ZXJtcywgZGVncmVlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR0ZXJtcywgbWF4LCBNLCBjLCBwb3dlcnMsIGRpdiwgciwgZmFjdG9yc192ZWMsIGtzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUsIHRmYWN0b3JzO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IF8uZXhwYW5kKHN5bWJvbC5nZXROdW0oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVuID0gXy5leHBhbmQoc3ltYm9sLmdldERlbm9tKCkudG9Vbml0TXVsdGlwbGllcigpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL21vdmUgdGhlIGVudGlyZSBtdWx0aXBpZXIgdG8gdGhlIG51bWVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgIG51bS5tdWx0aXBsaWVyID0gc3ltYm9sLm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy93ZSBvbmx5IGhhdmUgYSBtZWFuaW5nZnVsIGNoYW5nZSBpZiBuIGZhY3RvcnMgPiAxLiBUaGlzIG1lYW5zIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAvL3RoZSByZXR1cm5lZCBncm91cCB3aWxsIGJlIGEgQ0JcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbGxlY3QgdGhlIHRlcm1zIHdydCB0aGUgeFxyXG4gICAgICAgICAgICAgICAgICAgIG50ZXJtcyA9IG51bS5ncm91cFRlcm1zKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZGl2aWRlIG91dCB3aG9sZXMgaWYgdG9wIGlzIGxhcmdlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmKE51bWJlcihfXy5kZWdyZWUobnVtLCB2KSkgPj0gTnVtYmVyKF9fLmRlZ3JlZShkZW4sIHYpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYgPSBfXy5kaXYobnVtLmNsb25lKCksIF8uZXhwYW5kKGRlbi5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBkaXZbMF07IC8vcmVtb3ZlIHRoZSB3aG9sZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gZGl2WzFdOyAvL3dvcmsgd2l0aCB0aGUgcmVtYWluZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG50ZXJtcyA9IG51bS5ncm91cFRlcm1zKHYpOyAvL3JlY2FsY3VsYXRlIHRoZSBudGVybXNcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoTnVtYmVyKF9fLmRlZ3JlZShkZW4sIHYpKSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IF8uZGl2aWRlKG51bSwgZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXNfYXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3IsIHFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQociwgcSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3QgZmFjdG9yIHRoZSBkZW5vbWluYXRvci4gVGhpcyBtZWFucyB0aGF0IHRoZSBzdHJlbmd0aCBvZiB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hbGdvcml0aG0gZGVwZW5kcyBvbiBob3cgd2VsbCB3ZSBjYW4gZmFjdG9yIHRoZSBkZW5vbWluYXRvci4gXHJcbiAgICAgICAgICAgICAgICAgICAgb2ZhY3RvcnMgPSBfXy5GYWN0b3IuZmFjdG9yKGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgdGhlIHRlbXBsYXRlLiBUaGlzIG1ldGhvZCB3aWxsIGNyZWF0ZSB0aGUgdGVtcGxhdGUgZm9yIHNvbHZpbmcgXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgcGFydGlhbCBmcmFjdGlvbnMuIFNvIGdpdmVuIHgvKHgtMSleMiB0aGUgdGVtcGxhdGUgY3JlYXRlcyBBLyh4LTEpK0IvKHgtMSleMlxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gX18uUGFydEZyYWMuY3JlYXRlVGVtcGxhdGUoZGVuLmNsb25lKCksIG9mYWN0b3JzLCBbXSwgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGZhY3RvcnMgPSB0ZW1wbGF0ZVswXTsgLy9ncmFiIHRoZSBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yc192ZWMgPSB0ZW1wbGF0ZVsxXTsgLy9ncmFiIHRoZSBmYWN0b3IgdmVjdG9yc1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZ3JlZXMgPSB0ZW1wbGF0ZVsyXTsgLy9ncmFiIHRoZSBkZWdyZWVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9tYWtlIG5vdGUgb2YgdGhlIHBvd2VycyBvZiBlYWNoIHRlcm1cclxuICAgICAgICAgICAgICAgICAgICBwb3dlcnMgPSBbbnRlcm1zLmxlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgdGhlIGR0ZXJtcyB2ZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICBkdGVybXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3JzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAga3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yLCBkZWc7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yc192ZWMubWFwKGZ1bmN0aW9uICh4LCBpZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gdGZhY3RvcnNbaWR4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVnID0gZGVncmVlc1tpZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGVnOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMucHVzaChmYWN0b3IuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IFN5bWJvbC5jcmVhdGUodiwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8uZXhwYW5kKF8ubXVsdGlwbHkoeCwgay5jbG9uZSgpKSkuZ3JvdXBUZXJtcyh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBhIG5vdGUgb2YgdGhlIHBvd2VyIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXJzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdGVybXMucHVzaCh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtzLnB1c2goay5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBtYXggcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjb3JlLlV0aWxzLmFycmF5TWF4KHBvd2Vycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZmlsbCB0aGUgaG9sZXMgYW5kIGNyZWF0ZSBhIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBuZXcgY29yZS5NYXRyaXgoY29yZS5VdGlscy5maWxsSG9sZXMobnRlcm1zLCBtYXgpKS50cmFuc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZvciBlYWNoIG9mIHRoZSBmYWN0b3JzIHdlIGRvIHRoZSBzYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgTSA9IG5ldyBjb3JlLk1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkdGVybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTS5lbGVtZW50cy5wdXNoKGNvcmUuVXRpbHMuZmlsbEhvbGVzKGR0ZXJtc1tpXSwgbWF4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NvbHZlIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpYWxzID0gXy5tdWx0aXBseShNLnRyYW5zcG9zZSgpLmludmVydCgpLCBjKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3RoZSByZXN1bHRzIGFyZSBiYWNrd2FyZHMgdG8gcmV2ZXJzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vcGFydGlhbHMuZWxlbWVudHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29udmVydCBpdCBhbGwgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBhc19hcnJheSA/IFtyXSA6IHI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbHMuZWFjaChmdW5jdGlvbiAoZSwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVybSA9IF8ubXVsdGlwbHkoa3NbaV0sIF8uZGl2aWRlKGUsIGZhY3RvcnNbaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXNfYXJyYXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwucHVzaCh0ZXJtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCB0ZXJtKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kb25lXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3RyeSB0byBncm91cCBzeW1ib2xzXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ3JvdXAgZGVub21pbmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVub21pbmF0b3JzID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHguZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHguZ2V0TnVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBkZW5vbWluYXRvcnNbZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVub21pbmF0b3JzW2RdID0gZSA/IF8uYWRkKGUsIG4pIDogbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gZGVub21pbmF0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8uYWRkKHQsIF8uZGl2aWRlKGRlbm9taW5hdG9yc1t4XSwgXy5wYXJzZSh4KSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZTIpIHtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gKHN5bWJvbCwgdiwgbykge1xyXG4gICAgICAgICAgICBvID0gbyB8fCB7XHJcbiAgICAgICAgICAgICAgICBuZDogW10sIC8vbnVtZXJpY1xyXG4gICAgICAgICAgICAgICAgc2Q6IFtdLCAvL3N5bWJvbGljXHJcbiAgICAgICAgICAgICAgICBkZXB0aDogMCAvL2NhbGwgZGVwdGhcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmKCF2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFycyA9IHZhcmlhYmxlcyhzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgLy9UaGUgdXNlciBtdXN0IHNwZWNpZnkgdGhlIHZhcmlhYmxlIGZvciBtdWx0aXZhcmlhdGVcclxuICAgICAgICAgICAgICAgIGlmKHZhcnMubGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgdGhlIHZhcmlhYmxlIGZvciBtdWx0aXZhcmlhdGUgcG9seW5vbWlhbHMhJyk7XHJcbiAgICAgICAgICAgICAgICAvL2lmIGl0J3MgZW1wdHkgdGhlbiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBjb25zdGFudFxyXG4gICAgICAgICAgICAgICAgaWYodmFycy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAvL2Fzc3VtZSB0aGUgdmFyaWFibGUgZm9yIHVuaXZhcmlhdGVcclxuICAgICAgICAgICAgICAgIHYgPSBfLnBhcnNlKHZhcnNbMF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3N0b3JlIHRoZSBncm91cFxyXG4gICAgICAgICAgICB2YXIgZyA9IHN5bWJvbC5ncm91cDtcclxuICAgICAgICAgICAgLy93ZSdyZSBnb2luZyB0byB0cnVzdCB0aGUgdXNlciBhbmQgYXNzdW1lIG5vIEVYLiBDYWxsaW5nIGlzUG9seSBcclxuICAgICAgICAgICAgLy93b3VsZCBlbGltaW5hdGUgdGhpcyBidXQgbm8gc2Vuc2UgaW4gY2hlY2tpbmcgdHdpY2UuIFxyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZGlzdHJpYnV0ZUV4cG9uZW50KCk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG8uZGVwdGgrKzsgLy9tYXJrIGEgZGVwdGggaW5jcmVhc2VcclxuICAgICAgICAgICAgICAgICAgICBfXy5kZWdyZWUoeCwgdiwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgby5kZXB0aC0tOyAvL3dlJ3JlIGJhY2tcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBvLmRlcHRoKys7XHJcbiAgICAgICAgICAgICAgICAgICAgX18uZGVncmVlKHgsIHYsIG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIG8uZGVwdGgrKztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gRVggJiYgc3ltYm9sLnZhbHVlID09PSB2LnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBvLnNkLnB1c2goc3ltYm9sLnBvd2VyLmNsb25lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gUyAmJiBzeW1ib2wudmFsdWUgPT09IHYudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIG8ubmQucHVzaChfLnBhcnNlKHN5bWJvbC5wb3dlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG8ubmQucHVzaChuZXcgU3ltYm9sKDApKTtcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IHRoZSBtYXggb3V0IG9mIHRoZSBhcnJheVxyXG4gICAgICAgICAgICB2YXIgZGVnID0gby5uZC5sZW5ndGggPiAwID8gY29yZS5VdGlscy5hcnJheU1heChvLm5kKSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIGlmKG8uZGVwdGggPT09IDAgJiYgby5zZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZihkZWcgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICBvLnNkLnVuc2hpZnQoZGVnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdtYXgnLCBvLnNkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighY29yZS5VdGlscy5pc1N5bWJvbChkZWcpKVxyXG4gICAgICAgICAgICAgICAgZGVnID0gXy5wYXJzZShkZWcpO1xyXG4gICAgICAgICAgICAvL3JldHVybiB0aGUgZGVncmVlXHJcbiAgICAgICAgICAgIHJldHVybiBkZWc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBdHRlbXB0cyB0byBjb21wbGV0ZSB0aGUgc3F1YXJlIG9mIGEgcG9seW5vbWlhbFxyXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSB2XHJcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSByYXdcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdHxTeW1ib2xbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzcUNvbXBsZXRlOiBmdW5jdGlvbiAoc3ltYm9sLCB2LCByYXcpIHtcclxuICAgICAgICAgICAgaWYoIWNvcmUuVXRpbHMuaXNTeW1ib2wodikpXHJcbiAgICAgICAgICAgICAgICB2ID0gXy5wYXJzZSh2KTtcclxuICAgICAgICAgICAgdmFyIHN0b3AgPSBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgPSBtc2cgfHwgJ1N0b3BwaW5nJztcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLmV4Y2VwdGlvbnMuVmFsdWVMaW1pdEV4Y2VlZGVkRXJyb3IobXNnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy9pZiBub3QgQ1AgdGhlbiBub3RoaW5nIHRvIGRvXHJcbiAgICAgICAgICAgIGlmKCFzeW1ib2wuaXNQb2x5KHRydWUpKVxyXG4gICAgICAgICAgICAgICAgc3RvcCgnTXVzdCBiZSBhIHBvbHlub21pYWwhJyk7XHJcblxyXG4gICAgICAgICAgICAvL2RlY2xhcmUgdmFyc1xyXG4gICAgICAgICAgICB2YXIgZGVnLCBhLCBiLCBjLCBkLCBlLCBjb2VmZnMsIHNpZ24sIGJyLCBzeW0sIHNxcnRfYTtcclxuXHJcbiAgICAgICAgICAgIGJyID0gY29yZS5VdGlscy5pbkJyYWNrZXRzO1xyXG4gICAgICAgICAgICAvL21ha2UgYSBjb3B5XHJcbiAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBkZWcgPSBjb3JlLkFsZ2VicmEuZGVncmVlKHN5bWJvbCwgdik7IC8vZ2V0IHRoZSBkZWdyZWUgb2YgcG9seW5vbWlhbFxyXG4gICAgICAgICAgICAvL211c3QgYmUgaW4gZm9ybSBheF4yICsvLSBieCArLy0gY1xyXG4gICAgICAgICAgICBpZighZGVnLmVxdWFscygyKSlcclxuICAgICAgICAgICAgICAgIHN0b3AoJ0Nhbm5vdCBjb21wbGV0ZSBzcXVhcmUgZm9yIGRlZ3JlZSAnICsgZGVnKTtcclxuICAgICAgICAgICAgLy9nZXQgdGhlIGNvZWZmc1xyXG4gICAgICAgICAgICBjb2VmZnMgPSBjb3JlLkFsZ2VicmEuY29lZmZzKHN5bWJvbCwgdik7XHJcbiAgICAgICAgICAgIGEgPSBjb2VmZnNbMl07XHJcbiAgICAgICAgICAgIC8vc3RvcmUgdGhlIHNpZ25cclxuICAgICAgICAgICAgc2lnbiA9IGNvZWZmc1sxXS5zaWduKCk7XHJcbiAgICAgICAgICAgIC8vZGl2aWRlIHRoZSBsaW5lYXIgdGVybSBieSB0d28gYW5kIHNxdWFyZSBpdFxyXG4gICAgICAgICAgICBiID0gXy5kaXZpZGUoY29lZmZzWzFdLCBuZXcgU3ltYm9sKDIpKTtcclxuICAgICAgICAgICAgLy9hZGQgdGhlIGRpZmZlcmVuY2UgdG8gdGhlIGNvbnN0YW50XHJcbiAgICAgICAgICAgIGMgPSBfLnBvdyhiLmNsb25lKCksIG5ldyBTeW1ib2woMikpO1xyXG4gICAgICAgICAgICBpZihyYXcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2EsIGIsIGRdO1xyXG4gICAgICAgICAgICBzcXJ0X2EgPSBtYXRoLnNxcnQoYSk7XHJcbiAgICAgICAgICAgIGUgPSBfLmRpdmlkZShtYXRoLnNxcnQoYyksIHNxcnRfYS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgLy9jYWxjdWxhdGUgZCB3aGljaCBpcyB0aGUgY29uc3RhbnRcclxuICAgICAgICAgICAgZCA9IF8uc3VidHJhY3QoY29lZmZzWzBdLCBfLnBvdyhlLmNsb25lKCksIG5ldyBTeW1ib2woMikpKTtcclxuICAgICAgICAgICAgLy9jb21wdXRlIHRoZSBzcXVhcmUgcGFydFxyXG4gICAgICAgICAgICBzeW0gPSBfLnBhcnNlKGJyKHNxcnRfYS5jbG9uZSgpICsgJyonICsgdiArIChzaWduIDwgMCA/ICctJyA6ICcrJykgKyBlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhOiBzeW0sXHJcbiAgICAgICAgICAgICAgICBjOiBkLFxyXG4gICAgICAgICAgICAgICAgZjogXy5hZGQoXy5wb3coc3ltLmNsb25lKCksIG5ldyBTeW1ib2woMikpLCBkLmNsb25lKCkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBTaW1wbGlmeToge1xyXG4gICAgICAgICAgICBzdHJpcDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IF8ucGFyc2Uoc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjLCBwLCBzeW1ib2xdO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1bnN0cmlwOiBmdW5jdGlvbiAoY3AsIHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjcFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gY3BbMV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShjLCBfLnBvdyhzeW1ib2wsIHApKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29tcGxleFNpbXA6IGZ1bmN0aW9uIChudW0sIGRlbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFjLCBiZCwgYmMsIGFkLCBjZCwgcjEsIHIyLCBpMSwgaTI7XHJcbiAgICAgICAgICAgICAgICByMSA9IG51bS5yZWFscGFydCgpO1xyXG4gICAgICAgICAgICAgICAgaTEgPSBudW0uaW1hZ3BhcnQoKTtcclxuICAgICAgICAgICAgICAgIHIyID0gZGVuLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICBpMiA9IGRlbi5pbWFncGFydCgpO1xyXG4gICAgICAgICAgICAgICAgLy9hcHBseSBjb21wbGV4IGFyaXRobWF0aWMgcnVsZVxyXG4gICAgICAgICAgICAgICAgYWMgPSBfLm11bHRpcGx5KHIxLmNsb25lKCksIHIyLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgYmQgPSBfLm11bHRpcGx5KGkxLmNsb25lKCksIGkyLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgYmMgPSBfLm11bHRpcGx5KHIyLmNsb25lKCksIGkxKTtcclxuICAgICAgICAgICAgICAgIGFkID0gXy5tdWx0aXBseShyMSwgaTIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICBjZCA9IF8uYWRkKF8ucG93KHIyLCBuZXcgU3ltYm9sKDIpKSwgXy5wb3coaTIsIG5ldyBTeW1ib2woMikpKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoXy5hZGQoXy5hZGQoYWMsIGJkKSwgXy5tdWx0aXBseShfLnN1YnRyYWN0KGJjLCBhZCksIFN5bWJvbC5pbWFnaW5hcnkoKSkpLCBjZCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRyaWdTaW1wOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuY29udGFpbnNGdW5jdGlvbihbJ2NvcycsICdzaW4nLCAndGFuJ10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgcG93ZXIgYW5kIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltX2FycmF5ID0gX18uU2ltcGxpZnkuc3RyaXAoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1fYXJyYXkucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgZGVmYXVsdCByZXR1cm4gdmFsdWUgaXMgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBzeW1ib2wuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXdyaXRlIHRoZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXdyaXRlIHRoZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyID0gX18uU2ltcGxpZnkudHJpZ1NpbXAoeC5mblRyYW5zZm9ybSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bSA9IF8uYWRkKHN5bSwgdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgdGhlIHBvd2VyIGFuZCBtdWx0aXBsaWVyIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wb3coXy5tdWx0aXBseShuZXcgU3ltYm9sKHN5bWJvbC5tdWx0aXBsaWVyKSwgc3ltKSwgbmV3IFN5bWJvbChzeW1ib2wucG93ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHN5bWJvbC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBzeW1ib2wuZ2V0RGVub20oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IGZvciB0YW5nZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG4uZm5hbWUgPT09ICdzaW4nICYmIGQuZm5hbWUgPT09ICdjb3MnICYmIG4uYXJnc1swXS5lcXVhbHMoZC5hcmdzWzBdKSAmJiBuLnBvd2VyLmVxdWFscyhkLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShjb3JlLlV0aWxzLmZvcm1hdCgnKHswfSkqKHsxfSkqdGFuKHsyfSleKHszfSknLCBkLm11bHRpcGxpZXIsIG4ubXVsdGlwbGllciwgbi5hcmdzWzBdLCBuLnBvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmV0dmFsLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4LmZuYW1lID09PSAndGFuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gXy5wYXJzZShjb3JlLlV0aWxzLmZvcm1hdCgnKHswfSkqc2luKHsxfSleKHsyfSkvY29zKHsxfSleKHsyfSknLCB4Lm11bHRpcGxpZXIsIF9fLlNpbXBsaWZ5LnNpbXBsaWZ5KHguYXJnc1swXSksIHgucG93ZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkodCwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5TaW1wbGlmeS51bnN0cmlwKHN5bV9hcnJheSwgcmV0dmFsKS5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnJhY1NpbXA6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIC8vdHJ5IGEgcXVpY2sgc2ltcGxpZnkgb2YgaW1hZ2luYXJ5IG51bWJlcnNcclxuICAgICAgICAgICAgICAgIHZhciBkZW4gPSBzeW1ib2wuZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgICAgIHZhciBudW0gPSBzeW1ib2wuZ2V0TnVtKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobnVtLmlzSW1hZ2luYXJ5KCkgJiYgZGVuLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gX18uU2ltcGxpZnkuY29tcGxleFNpbXAobnVtLCBkZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbHMgPSBzeW1ib2wuY29sbGVjdFN5bWJvbHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2Fzc3VtcHRpb24gMS5cclxuICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIGl0J3MgYSBjb21wb3NpdGUsIGl0IGhhcyBhIGxlbmd0aCBvZiBhdCBsZWFzdCAxXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbCwgYSwgYiwgZDEsIGQyLCBuMSwgbjIsIHgsIHksIGMsIGRlbiwgbnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBzeW1ib2xzLnBvcCgpOyAvL2dyYWIgdGhlIGZpcnN0IHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIGVhY2ggdGVybSBhbmQgbWFrZSBkZW5vbWluYXRvciBjb21tb25cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gc3ltYm9scy5wb3AoKTsgLy9ncmFiIHRoZSBzZWNvbmQgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQxID0gXy5wYXJzZShhLmdldERlbm9tKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMiA9IF8ucGFyc2UoYi5nZXREZW5vbSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbjEgPSBhLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuMiA9IGIuZ2V0TnVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBfLm11bHRpcGx5KGQxLmNsb25lKCksIGQyLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gXy5tdWx0aXBseShuMSwgZDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gXy5tdWx0aXBseShuMiwgZDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gXy5kaXZpZGUoXy5hZGQoeCwgeSksIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZW4gPSBfLmV4cGFuZChhLmdldERlbm9tKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IF8uZXhwYW5kKGEuZ2V0TnVtKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NpbXBsaWZ5IGltYWdpbmFyeVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG51bS5pc0ltYWdpbmFyeSgpICYmIGRlbi5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLlNpbXBsaWZ5LmNvbXBsZXhTaW1wKG51bSwgZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKG51bSwgZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vd2UndmUgYWxyZWFkeSBoaXQgdGhlIHNpbXBsZXN0IGZvcm0gc28gcmV0dXJuIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICBpZihyZXR2YWwuZXF1YWxzKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIHNpbXBsaWZ5IGl0IHNvbWUgbW9yZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5TaW1wbGlmeS5zaW1wbGlmeShyZXR2YWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmF0U2ltcDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZW4gPSBzeW1ib2wuZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gc3ltYm9sLmdldE51bSgpLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfXy5TaW1wbGlmeS5mcmFjU2ltcChkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gX18uU2ltcGxpZnkuZnJhY1NpbXAobnVtKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmRpdmlkZShuLCBkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNxcnRTaW1wOiBmdW5jdGlvbiAoc3ltYm9sLCBzeW1fYXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNTUVJUKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yZWQgPSBfXy5GYWN0b3IuZmFjdG9yKHN5bWJvbC5hcmdzWzBdLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gXy5wYXJzZShmYWN0b3JlZC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IG0uc2lnbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gXy5zcXJ0KG0uYWJzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzSW50KHJldHZhbCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZhY3RvcmVkLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbSA9IG5ldyBTeW1ib2woMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yZWQuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gXy5zcXJ0KHguY2xvbmUoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aXBseSBiYWNrIHNxcnQgaWYgaXQncyBhbiBpbnRlZ2VyIG90aGVyd2lzZSBqdXN0IHB1dCBiYWNrIHRoZSBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNJbnQodHJpYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgdHJpYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtID0gXy5tdWx0aXBseShyZW0sIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBfLm11bHRpcGx5KHJlbSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfLm11bHRpcGx5KHJlbSwgXy5wYXJzZShzaWduKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBfLnNxcnQodC5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgaWYgaXQncyBpbWFnaW5hcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFyZy5pc0ltYWdpbmFyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IF8uc3FydChfLmV4cGFuZCh0LmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBfLnNxcnQoZmFjdG9yZWQuY2xvbmUoKS50b1VuaXRNdWx0aXBsaWVyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHJldHZhbCwgYXJnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkgJiYgc3ltYm9sLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX18uU2ltcGxpZnkuc3FydFNpbXAoeCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFB1dCBiYWNrIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaW1wID0gX18uU2ltcGxpZnkuc3FydFNpbXAoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBzaW1wKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGJhY2sgdGhlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wb3cocmV0dmFsLCBfLnBhcnNlKHN5bWJvbC5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWwgPyByZXR2YWwgOiBfLnBhcnNlKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVbnVzZWQuIFRoZSBnb2FsIGlzIHRvIHN1YnN0aXR1dGUgb3V0IHBhdHRlcm5zIGJ1dCBpdCBjdXJyZW50bHkgZG9lc24ndCB3b3JrLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgc3ltYm9sIGFuZCB0aGUgbWF0Y2hlZCBwYXR0ZXJuc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcGF0dGVyblN1YjogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm5zID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGhhc19DUCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih4Lmdyb3VwID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoeC5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGhhc19DUCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0ID0gZnVuY3Rpb24gKHN5bSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGxvb3AgdGhyb3VnaCBlYWNoIHN5bWJvbCBsb29raW5nIGZvciBhbnl0aGluZyBpbiB0aGUgc2ltcGxlc3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3JtIG9mIGF4K2J5eisuLi5cclxuICAgICAgICAgICAgICAgICAgICBzeW0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdGVtcyBvZiBncm91cCBOLFAsUywgbmVlZCB0byBhcHBseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZigheC5zeW1ib2xzICYmIHguZ3JvdXAgIT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiBpdCBoYXMgYW55IHN5bWJvbHMgb2YgZ3JvdXAgQ1BcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwYXR0ZXJucyBpbiB0aGF0IHN5bWJvbCBpbnN0ZWFkIGlmIGl0IGhhcyBhbnl0aGluZyBvZiBncm91cCBDUFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihoYXNfQ1AoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3QoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighcGF0dGVybnNbeC52YWx1ZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGNvcmUuVXRpbHMuZ2V0VShzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIHUgdmFsdWUgYW5kIG1hcmsgaXQgZm9yIHN1YnNpdHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybnNbeC52YWx1ZV0gPSB1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5zdWIoeC52YWx1ZSwgdSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBhIGxpc3Qgb2YgcGF0dGVybnNcclxuICAgICAgICAgICAgICAgIGNvbGxlY3Qoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3N5bWJvbCwgcGF0dGVybnNdO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzaW1wbGlmeTogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhlIG11bHRpcGxpZXIgdG8gbWFrZSBjYWxjdWxhdGlvbiBlYXNpZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ltX2FycmF5ID0gX18uU2ltcGxpZnkuc3RyaXAoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bV9hcnJheS5wb3AoKTtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGdjZCBmcm9tIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfXy5TaW1wbGlmeS5mcmFjU2ltcChzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbm90aGluZyBtb3JlIHRvIGRvXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpIHx8IHN5bWJvbC5ncm91cCA9PT0gY29yZS5ncm91cHMuUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bV9hcnJheS5wdXNoKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IF9fLlNpbXBsaWZ5LnVuc3RyaXAoc3ltX2FycmF5LCBzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy92YXIgcGF0dGVybnM7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNpbXBsaWZpZWQgPSBzeW1ib2wuY2xvbmUoKTsgLy9tYWtlIGEgY29weVxyXG5cclxuICAgICAgICAgICAgICAgIC8vW3NpbXBsaWZpZWQsIHBhdHRlcm5zXSA9IF9fLlNpbXBsaWZ5LnBhdHRlcm5TdWIoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGlmeSBzcXJ0IHdpdGhpbiB0aGUgc3ltYm9sXHJcbi8vICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPSBfXy5TaW1wbGlmeS5zcXJ0U2ltcChzaW1wbGlmaWVkLCBzeW1fYXJyYXkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyeSB0cmlnIHNpbXBsaWZpY2F0b25zIGUuZy4gY29zKHgpXjIrc2luKHgpXjJcclxuICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQgPSBfXy5TaW1wbGlmeS50cmlnU2ltcChzaW1wbGlmaWVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGlmeSBjb21tb24gZGVub21pbmF0b3JzXHJcbiAgICAgICAgICAgICAgICBzaW1wbGlmaWVkID0gX18uU2ltcGxpZnkucmF0U2ltcChzaW1wbGlmaWVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBnbyBmb3IgdGhlIFwiY2hlYXBlc3RcIiBzaW1wbGlmaWNhdGlvbiB3aGljaCBtYXkgZWxpbWluYXRlIFxyXG4gICAgICAgICAgICAgICAgLy8geW91ciBwcm9ibGVtcyByaWdodCBhd2F5LiBmYWN0b3IgLT4gZXZhbHVhdGUuIFJlbWVtYmVyXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZXJlJ3Mgbm8gbmVlZCB0byBleHBhbmQgc2luY2UgZmFjdG9yIGFscmVhZHkgZG9lcyB0aGF0XHJcblxyXG4gICAgICAgICAgICAgICAgc2ltcGxpZmllZCA9IF9fLkZhY3Rvci5mYWN0b3Ioc2ltcGxpZmllZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9JZiB0aGUgc2ltcGxmaWVkIGlzIGEgc3VtIHRoZW4gd2UgY2FuIG1ha2UgYSBmZXcgbW9yZSBzaW1wbGlmaWNhdGlvbnNcclxuICAgICAgICAgICAgICAgIC8vZS5nLiBzaW1wbGlmeSgxLyh4LTEpKzEvKDEteCkpIGFzIHBlciBpc3N1ZSAjNDMxXHJcbiAgICAgICAgICAgICAgICBpZihzaW1wbGlmaWVkLmdyb3VwID09PSBjb3JlLmdyb3Vwcy5DUCAmJiBzaW1wbGlmaWVkLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHNpbXBsaWZpZWQubXVsdGlwbGllci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbXBsaWZpZWQudG9Vbml0TXVsdGlwbGllcigpOyAvL3N0cmlwIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRoZSBzdW0gb2Ygc2ltcGxpZmljYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgc2ltcGxpZmllZC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gX18uU2ltcGxpZnkuc2ltcGxpZnkoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBfLmFkZChyLCBzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBzaW1wbGlmaWVkID0gcjtcclxuICAgICAgICAgICAgICAgICAgICAvL3B1dCBiYWNrIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgci5tdWx0aXBsaWVyID0gci5tdWx0aXBsaWVyLm11bHRpcGx5KG0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcGxhY2UgYmFjayBtdWx0aXBsaWVyIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBfXy5TaW1wbGlmeS51bnN0cmlwKHN5bV9hcnJheSwgc2ltcGxpZmllZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQmFjayBzdWJzdGl0dXRlXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBwYXR0ZXJucykge1xyXG4gICAgICAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbC5zdWIocGF0dGVybnNbeF0sIHgpO1xyXG4gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBDbGFzc2VzOiB7XHJcbiAgICAgICAgICAgIFBvbHlub21pYWw6IFBvbHlub21pYWwsXHJcbiAgICAgICAgICAgIEZhY3RvcnM6IEZhY3RvcnMsXHJcbiAgICAgICAgICAgIE1WVGVybTogTVZUZXJtXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBZGQgYSBsaW5rIHRvIHNpbXBsaWZ5XHJcbiAgICBjb3JlLkV4cHJlc3Npb24ucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfXy5TaW1wbGlmeS5zaW1wbGlmeSh0aGlzLnN5bWJvbCk7XHJcbiAgICB9O1xyXG5cclxuICAgIG5lcmRhbWVyLnVzZUFsZ2VicmFEaXYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRpdmlkZSA9IF9fLmRpdmlkZUZuID0gXy5kaXZpZGU7XHJcbiAgICAgICAgdmFyIGNhbGxzID0gMDsgLy9rZWVwIHRyYWNrIG9mIGhvdyBtYW55IGNhbGxzIHdlcmUgbWFkZVxyXG4gICAgICAgIF8uZGl2aWRlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgY2FsbHMrKztcclxuICAgICAgICAgICAgdmFyIGFucztcclxuICAgICAgICAgICAgaWYoY2FsbHMgPT09IDEpIC8vY2hlY2sgaWYgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbC4gSWYgaXQgaXMgdXNlIGFsZ2VicmEgZGl2aWRlXHJcbiAgICAgICAgICAgICAgICBhbnMgPSBjb3JlLkFsZ2VicmEuZGl2aWRlKGEsIGIpO1xyXG4gICAgICAgICAgICBlbHNlIC8vb3RoZXJ3aXNlIHVzZSBwYXJzZXIgZGl2aWRlXHJcbiAgICAgICAgICAgICAgICBhbnMgPSBkaXZpZGUoYSwgYik7XHJcbiAgICAgICAgICAgIGNhbGxzID0gMDsgLy9yZXNldCB0aGUgbnVtYmVyIG9mIGNhbGxzIGJhY2sgdG8gbm9uZVxyXG4gICAgICAgICAgICByZXR1cm4gYW5zO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIG5lcmRhbWVyLnVzZVBhcnNlckRpdiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZihfXy5kaXZpZGVGbilcclxuICAgICAgICAgICAgXy5kaXZpZGUgPSBfXy5kaXZpZGVGbjtcclxuICAgICAgICBkZWxldGUgX18uZGl2aWRlRm47XHJcbiAgICB9O1xyXG5cclxuICAgIG5lcmRhbWVyLnJlZ2lzdGVyKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdmYWN0b3InLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAxLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLkZhY3Rvci5mYWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3NpbXBsaWZ5JyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogMSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5TaW1wbGlmeS5zaW1wbGlmeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnZ2NkJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogWzEsIF0sXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uZ2NkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdsY20nLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiBbMSwgXSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5sY207XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3Jvb3RzJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogLTEsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18ucm9vdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2RpdmlkZScsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDIsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uZGl2aWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdkaXYnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAyLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLmRpdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAncGFydGZyYWMnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiBbMSwgMl0sXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uUGFydEZyYWMucGFydGZyYWM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2RlZycsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IFsxLCAyXSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5kZWdyZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2NvZWZmcycsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IFsxLCAyXSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2VmZnMgPSBfXy5jb2VmZnMuYXBwbHkoX18sIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLlZlY3Rvcihjb2VmZnMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdsaW5lJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogWzIsIDNdLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLmxpbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3NxY29tcCcsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IFsxLCAyXSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmID0gZnVuY3Rpb24gKHgsIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gdiB8fCB2YXJpYWJsZXMoeClbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcSA9IF9fLnNxQ29tcGxldGUoeC5jbG9uZSgpLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNxLmY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgXSk7XHJcbiAgICBuZXJkYW1lci5hcGkoKTtcclxufSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/nerdamer/Algebra.js\n");

/***/ }),

/***/ "./node_modules/nerdamer/Calculus.js":
/*!*******************************************!*\
  !*** ./node_modules/nerdamer/Calculus.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* global module */\r\n\r\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\nif( true && typeof nerdamer === 'undefined') {\r\n    var nerdamer = __webpack_require__(/*! ./nerdamer.core.js */ \"./node_modules/nerdamer/nerdamer.core.js\");\r\n    __webpack_require__(/*! ./Algebra.js */ \"./node_modules/nerdamer/Algebra.js\");\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Frac = core.Frac,\r\n            Settings = core.Settings,\r\n            isSymbol = core.Utils.isSymbol,\r\n            FN = core.groups.FN,\r\n            Symbol = core.Symbol,\r\n            text = core.Utils.text,\r\n            inBrackets = core.Utils.inBrackets,\r\n            isInt = core.Utils.isInt,\r\n            format = core.Utils.format,\r\n            even = core.Utils.even,\r\n            evaluate = core.Utils.evaluate,\r\n            N = core.groups.N,\r\n            S = core.groups.S,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            EX = core.groups.EX,\r\n            P = core.groups.P,\r\n            LOG = Settings.LOG,\r\n            EXP = 'exp',\r\n            ABS = 'abs',\r\n            SQRT = 'sqrt',\r\n            SIN = 'sin',\r\n            COS = 'cos',\r\n            TAN = 'tan',\r\n            SEC = 'sec',\r\n            CSC = 'csc',\r\n            COT = 'cot',\r\n            ASIN = 'asin',\r\n            ACOS = 'acos',\r\n            ATAN = 'atan',\r\n            ASEC = 'asec',\r\n            ACSC = 'acsc',\r\n            ACOT = 'acot',\r\n            SINH = 'sinh',\r\n            COSH = 'cosh',\r\n            TANH = 'tanh',\r\n            CSCH = 'csch',\r\n            SECH = 'sech',\r\n            COTH = 'coth',\r\n            ASECH = 'asech',\r\n            ACSCH = 'acsch',\r\n            ACOTH = 'acoth';\r\n\r\n    //custom errors\r\n    function NoIntegralFound(msg) {\r\n        this.message = msg || \"\";\r\n    }\r\n    NoIntegralFound.prototype = new Error();\r\n\r\n    //Preparations\r\n    Symbol.prototype.hasIntegral = function () {\r\n        return this.containsFunction('integrate');\r\n    };\r\n    //transforms a function\r\n    Symbol.prototype.fnTransform = function () {\r\n        if(this.group !== FN)\r\n            return this;\r\n        var retval, a = this.args[0];\r\n        var m = new Symbol(this.multiplier);\r\n        var sym = this.clone().toUnitMultiplier();\r\n        if(this.isLinear()) {\r\n            switch(this.fname) {\r\n                case SINH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\r\n                    break;\r\n                case TAN:\r\n                    retval = _.parse(format('sin({0})/cos({0})', a));\r\n                    break;\r\n                case CSC:\r\n                    retval = _.parse(format('1/sin({0})', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('1/cos({0})', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.power.equals(2)) {\r\n            switch(this.fname) {\r\n                case SIN:\r\n                    retval = _.parse(format('1/2-cos(2*({0}))/2', a));\r\n                    break;\r\n                case COS:\r\n                    retval = _.parse(format('1/2+cos(2*({0}))/2', a));\r\n                    break;\r\n                case TAN:\r\n                    //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\r\n                    retval = _.parse(format('sin({0})^2/cos({0})^2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case SINH:\r\n                    retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.fname === SEC) {\r\n            retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === CSC) {\r\n            retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === TAN) {\r\n            if(this.power.lessThan(0)) {\r\n                retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\r\n            }\r\n            else {\r\n                retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\r\n            }\r\n        }\r\n        else if(this.fname === SIN && this.power.lessThan(0)) {\r\n            retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === COS && this.power.lessThan(0)) {\r\n            retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === SIN && this.power.equals(3)) {\r\n            retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\r\n        }\r\n        else if(this.fname === COS && this.power.equals(3)) {\r\n            retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\r\n        }\r\n        //cos(a*x)^(2*n) or sin(a*x)^(2*n)\r\n        else if((this.fname === COS || this.fname === SIN) && even(this.power)) {\r\n            var n = this.power / 2;\r\n            //convert to a double angle\r\n            var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\r\n            //raise to the n and expand\r\n            var transformed = _.expand(_.pow(double_angle, _.parse(n)));\r\n\r\n            retval = new Symbol(0);\r\n\r\n            transformed.each(function (s) {\r\n                var t = s.fnTransform();\r\n                retval = _.add(retval, t);\r\n            }, true);\r\n        }\r\n        else\r\n            retval = sym;\r\n\r\n        return _.multiply(retval, m);\r\n    };\r\n\r\n    Symbol.prototype.hasTrig = function () {\r\n        if(this.isConstant(true) || this.group === S)\r\n            return false;\r\n        if(this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))\r\n            return true;\r\n        if(this.symbols) {\r\n            for(var x in this.symbols)\r\n                if(this.symbols[x].hasTrig())\r\n                    return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    core.Expression.prototype.hasIntegral = function () {\r\n        return this.symbol.hasIntegral();\r\n    };\r\n    /**\r\n     * Attempts to rewrite a symbol under one common denominator\r\n     * @param {Symbol} symbol \r\n     */\r\n    core.Utils.toCommonDenominator = function (symbol) {\r\n        //transform x/a+x -> (ax+x)/a\r\n        if(symbol.isComposite() && symbol.isLinear()) {\r\n            var m = new Symbol(symbol.multiplier);\r\n            var denominator = new Symbol(1);\r\n            var numerator = new Symbol(0);\r\n            symbol.each(function (x) {\r\n                denominator = _.multiply(denominator, x.getDenom());\r\n            }, true);\r\n\r\n            //remove the denomitor in each term\r\n            symbol.each(function (x) {\r\n                var num = x.getNum();\r\n                var den = x.getDenom();\r\n                var factor = _.multiply(num, _.divide(denominator.clone(), den));\r\n                numerator = _.add(numerator, factor);\r\n            });\r\n            var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\r\n            return retval;\r\n        }\r\n        return symbol;\r\n    };\r\n    //A function to check if a function name is an inverse trig function\r\n    core.Utils.in_inverse_trig = function (x) {\r\n        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\r\n        return inv_trig_fns.indexOf(x) !== -1;\r\n    };\r\n    //A function to check if a function name is a trig function\r\n    core.Utils.in_trig = function (x) {\r\n        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    core.Utils.in_htrig = function (x) {\r\n        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    // Matrix functions\r\n    core.Matrix.jacobian = function (eqns, vars) {\r\n        var jacobian = new core.Matrix();\r\n        //get the variables if not supplied\r\n        if(!vars) {\r\n            vars = core.Utils.arrayGetVariables(eqns);\r\n        }\r\n\r\n        vars.forEach(function (v, i) {\r\n            eqns.forEach(function (eq, j) {\r\n                var e = core.Calculus.diff(eq.clone(), v);\r\n                jacobian.set(j, i, e);\r\n            });\r\n        });\r\n\r\n        return jacobian;\r\n    };\r\n\r\n    core.Matrix.prototype.max = function () {\r\n        var max = new Symbol(0);\r\n        this.each(function (x) {\r\n            var e = x.abs();\r\n            if(e.gt(max))\r\n                max = e;\r\n        });\r\n        return max;\r\n    };\r\n\r\n    core.Matrix.cMatrix = function (value, vars) {\r\n        var m = new core.Matrix();\r\n        //make an initial guess\r\n        vars.forEach(function (v, i) {\r\n            m.set(i, 0, _.parse(value));\r\n        });\r\n        return m;\r\n    };\r\n\r\n    var all_functions = core.Utils.all_functions = function (arr) {\r\n        for(var i = 0, l = arr.length; i < l; i++)\r\n            if(arr[i].group !== FN)\r\n                return false;\r\n        return true;\r\n    },\r\n            cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\r\n            },\r\n            cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\r\n                //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\r\n                //we technically know how to do this transform but more is needed for correct output\r\n                if(Number(symbol2.power) !== 1)\r\n                    return _.multiply(symbol1, symbol2);\r\n                var a;\r\n                a = symbol1.args[0];\r\n                return _.parse(format('(sin(2*({0})))/2', a));\r\n            },\r\n            sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\r\n            },\r\n            trigTransform = core.Utils.trigTransform = function (arr) {\r\n                var map = {}, symbol, t,\r\n                        retval = new Symbol(1);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    symbol = arr[i];\r\n\r\n                    if(symbol.group === FN) {\r\n                        var fname = symbol.fname;\r\n\r\n                        if(fname === COS && map[SIN]) {\r\n\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[SIN]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[SIN]);\r\n                            }\r\n                            delete map[SIN];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[COS]) {\r\n                            if(map[COS].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[COS]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[COS]);\r\n                            }\r\n                            delete map[COS];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[SIN]) {\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = sinAsinBtransform(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n                            else {\r\n                                //This should actually be redundant code but let's put just in case\r\n                                t = _.multiply(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n\r\n                            retval = t;\r\n                        }\r\n                        else {\r\n                            map[fname] = symbol;\r\n                        }\r\n                    }\r\n                    else\r\n                        retval = _.multiply(retval, symbol);\r\n                }\r\n\r\n                //put back the remaining functions\r\n                for(var x in map)\r\n                    retval = _.multiply(retval, map[x]);\r\n\r\n                return retval;\r\n\r\n            };\r\n\r\n    core.Settings.integration_depth = 10;\r\n\r\n    core.Settings.max_lim_depth = 10;\r\n\r\n    var __ = core.Calculus = {\r\n\r\n        version: '1.4.6',\r\n\r\n        sum: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                start = Number(start);\r\n                end = Number(end);\r\n                retval = core.Utils.block(modifier, function () {\r\n                    var f = fn.text(),\r\n                            subs = {'~': true}, //lock subs. Is this even being used?\r\n                            retval = new core.Symbol(0);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        var ans = _.parse(f, subs);\r\n                        retval = _.add(retval, ans);\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('sum', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        product: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                retval = core.Utils.block(modifier, function () {\r\n                    start = Number(start);\r\n                    end = Number(end.multiplier);\r\n\r\n                    var f = fn.text(),\r\n                            subs = {},\r\n                            retval = new core.Symbol(1);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        retval = _.multiply(retval, _.parse(f, subs));\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('product', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        diff: function (symbol, wrt, nth) {\r\n            if(core.Utils.isVector(symbol)) {\r\n                var vector = new core.Vector([]);\r\n                symbol.each(function (x) {\r\n                    vector.elements.push(__.diff(x, wrt, nth));\r\n                });\r\n                return vector;\r\n            }\r\n            else if(core.Utils.isMatrix(symbol)) {\r\n                var matrix = new core.Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    matrix.set(i, j, __.diff(x, wrt, nth));\r\n                });\r\n                return matrix;\r\n            }\r\n\r\n            var d = isSymbol(wrt) ? wrt.text() : wrt;\r\n            //the nth derivative\r\n            nth = isSymbol(nth) ? nth.multiplier : nth || 1;\r\n\r\n            if(d === undefined)\r\n                d = core.Utils.variables(symbol)[0];\r\n\r\n            //unwrap sqrt\r\n            if(symbol.group === FN && symbol.fname === SQRT) {\r\n                var s = symbol.args[0],\r\n                        sp = symbol.power.clone();\r\n                //these groups go to zero anyway so why waste time?\r\n                if(s.group !== N || s.group !== P) {\r\n                    s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\r\n                    s.multiplier = s.multiplier.multiply(symbol.multiplier);\r\n                }\r\n\r\n                symbol = s;\r\n            }\r\n\r\n            if(symbol.group === FN && !isSymbol(symbol.power)) {\r\n                var a = derive(_.parse(symbol));\r\n                var b = __.diff(symbol.args[0].clone(), d);\r\n                symbol = _.multiply(a, b);//chain rule\r\n            }\r\n            else {\r\n                symbol = derive(symbol);\r\n            }\r\n\r\n            if(nth > 1) {\r\n                nth--;\r\n                symbol = __.diff(symbol, wrt, nth);\r\n            }\r\n\r\n            return symbol;\r\n\r\n            // Equivalent to \"derivative of the outside\".\r\n            function polydiff(symbol) {\r\n                if(symbol.value === d || symbol.contains(d, true)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(symbol.power);\r\n                    symbol.power = symbol.power.subtract(new Frac(1));\r\n                    if(symbol.power.equals(0)) {\r\n                        symbol = Symbol(symbol.multiplier);\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            }\r\n            \r\n            function derive(symbol) {\r\n                var g = symbol.group, a, b, cp;\r\n\r\n                if(g === N || g === S && symbol.value !== d || g === P) {\r\n                    symbol = Symbol(0);\r\n                }\r\n                else if(g === S) {\r\n                    symbol = polydiff(symbol);\r\n                }\r\n                else if(g === CB) {\r\n                    var m = symbol.multiplier.clone();\r\n                    symbol.toUnitMultiplier();\r\n                    var retval = _.multiply(product_rule(symbol), polydiff(symbol));\r\n                    retval.multiplier = retval.multiplier.multiply(m);\r\n                    return retval;\r\n                }\r\n                else if(g === FN && symbol.power.equals(1)) {\r\n                    // Table of known derivatives\r\n                    switch(symbol.fname) {\r\n                        case LOG:\r\n                            cp = symbol.clone();\r\n                            symbol = symbol.args[0].clone();//get the arguments\r\n                            symbol.power = symbol.power.negate();\r\n                            symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\r\n                            break;\r\n                        case COS:\r\n                            //cos -> -sin\r\n                            symbol.fname = SIN;\r\n                            symbol.multiplier.negate();\r\n                            break;\r\n                        case SIN:\r\n                            //sin -> cos\r\n                            symbol.fname = COS;\r\n                            break;\r\n                        case TAN:\r\n                            //tan -> sec^2\r\n                            symbol.fname = SEC;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SEC:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, TAN);\r\n                            break;\r\n                        case CSC:\r\n                            symbol = qdiff(symbol, '-cot');\r\n                            break;\r\n                        case COT:\r\n                            symbol.fname = CSC;\r\n                            symbol.multiplier.negate();\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case ASIN:\r\n                            symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ACOS:\r\n                            symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ATAN:\r\n                            symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ABS:\r\n                            m = symbol.multiplier.clone();\r\n                            symbol.toUnitMultiplier();\r\n                            //depending on the complexity of the symbol it's easier to just parse it into a new symbol\r\n                            //this should really be readdressed soon\r\n                            b = symbol.args[0].clone();\r\n                            b.toUnitMultiplier();\r\n                            symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\r\n                            symbol.multiplier = m;\r\n                            break;\r\n                        case 'parens':\r\n                            //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\r\n                            //1*g'\r\n                            symbol = Symbol(1);\r\n                            break;\r\n                        case 'cosh':\r\n                            //cosh -> -sinh\r\n                            symbol.fname = 'sinh';\r\n                            break;\r\n                        case 'sinh':\r\n                            //sinh -> cosh\r\n                            symbol.fname = 'cosh';\r\n                            break;\r\n                        case TANH:\r\n                            //tanh -> sech^2\r\n                            symbol.fname = SECH;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SECH:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, '-tanh');\r\n                            break;\r\n                        case CSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\r\n                            break;\r\n                        case COTH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-csch(' + arg + ')^2');\r\n                            break;\r\n                        case 'asinh':\r\n                            symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'acosh':\r\n                            symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'atanh':\r\n                            symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ASECH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOTH:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\r\n                            break;\r\n                        case ACSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ASEC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACSC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOT:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\r\n                            break;\r\n                        case 'S':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'C':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'Si':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Shi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ci':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Chi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ei':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Li':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\r\n                            break;\r\n                        case 'erf':\r\n                            symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\r\n                            break;\r\n                        case 'atan2':\r\n                            var x_ = String(symbol.args[0]),\r\n                                    y_ = String(symbol.args[1]);\r\n                            symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\r\n                            break;\r\n                        case 'sign':\r\n                            symbol = new Symbol(0);\r\n                            break;\r\n                        case 'sinc':\r\n                            symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\r\n                            break;\r\n                        case Settings.LOG10:\r\n                            symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\r\n                            break;\r\n                        default:\r\n                            symbol = _.symfunction('diff', [symbol, wrt]);\r\n                    }\r\n                }\r\n                else if(g === EX || g === FN && isSymbol(symbol.power)) {\r\n                    var value;\r\n                    if(g === EX) {\r\n                        value = symbol.value;\r\n                    }\r\n                    else if(g === FN && symbol.contains(d)) {\r\n                        value = symbol.fname + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    else {\r\n                        value = symbol.value + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\r\n                    b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\r\n                    symbol = _.multiply(symbol, b);\r\n                }\r\n                else if(g === FN && !symbol.power.equals(1)) {\r\n                    b = symbol.clone();\r\n                    b.toLinear();\r\n                    b.toUnitMultiplier();\r\n                    symbol = _.multiply(polydiff(symbol.clone()), derive(b));\r\n                }\r\n                else if(g === CP || g === PL) {\r\n                    // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\r\n                    var c = symbol.clone();\r\n                    var result = new Symbol(0);\r\n                    for(var x in symbol.symbols) {\r\n                        result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\r\n                    }\r\n                    symbol = _.multiply(polydiff(c), result);\r\n                }\r\n\r\n                symbol.updateHash();\r\n\r\n                return symbol;\r\n            }\r\n            ;\r\n\r\n            function qdiff(symbol, val, altVal) {\r\n                return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\r\n            }\r\n            ;\r\n\r\n            function product_rule(symbol) {\r\n                //grab all the symbols within the CB symbol\r\n                var symbols = symbol.collectSymbols(),\r\n                        result = new Symbol(0),\r\n                        l = symbols.length;\r\n                //loop over all the symbols\r\n                for(var i = 0; i < l; i++) {\r\n                    var df = __.diff(symbols[i].clone(), d);\r\n                    for(var j = 0; j < l; j++) {\r\n                        //skip the symbol of which we just pulled the derivative\r\n                        if(i !== j) {\r\n                            //multiply out the remaining symbols\r\n                            df = _.multiply(df, symbols[j].clone());\r\n                        }\r\n                    }\r\n                    //add the derivative to the result\r\n                    result = _.add(result, df);\r\n                }\r\n                return result; //done\r\n            }\r\n            ;\r\n        },\r\n        integration: {\r\n            u_substitution: function (symbols, dx) {\r\n                function try_combo(a, b, f) {\r\n                    var d = __.diff(b, dx);\r\n                    var q = f ? f(a, b) : _.divide(a.clone(), d);\r\n                    if(!q.contains(dx, true))\r\n                        return q;\r\n                    return null;\r\n                }\r\n                function do_fn_sub(fname, arg) {\r\n                    var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\r\n                    subbed = subbed.sub(new Symbol(u), arg);\r\n                    subbed.updateHash();\r\n                    return subbed;\r\n                }\r\n\r\n                var a = symbols[0].clone(),\r\n                        b = symbols[1].clone(),\r\n                        g1 = a.group,\r\n                        g2 = b.group,\r\n                        //may cause problems if person is using this already. Will need\r\n                        //to find algorithm for detecting conflict\r\n                        u = '__u__',\r\n                        Q;\r\n                if(g1 === FN && g2 !== FN) {\r\n                    //e.g. 2*x*cos(x^2)\r\n                    var arg = a.args[0];\r\n                    Q = try_combo(b, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(a.fname, arg));\r\n                    Q = try_combo(b, a);\r\n                    if(Q) {\r\n                        return __.integration.poly_integrate(a);\r\n                    }\r\n                }\r\n                else if(g2 === FN && g1 !== FN) {\r\n                    //e.g. 2*(x+1)*cos((x+1)^2\r\n                    var arg = b.args[0];\r\n                    Q = try_combo(a, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(b.fname, arg));\r\n                }\r\n                else if(g1 === FN && g2 === FN) {\r\n                    Q = try_combo(a.clone(), b.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(b.clone(), a.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                }\r\n                else if(g1 === EX && g2 !== EX) {\r\n                    var p = a.power;\r\n                    Q = try_combo(b, p.clone());\r\n                    if(!Q) {\r\n                        //one more try\r\n                        var dc = __.integration.decompose_arg(p.clone(), dx);\r\n                        //consider the possibility of a^x^(n-1)*x^n dx\r\n                        var xp = __.diff(dc[2].clone(), dx);\r\n                        var dc2 = __.integration.decompose_arg(xp.clone(), dx);\r\n                        //if their powers equal, so if dx*p == b\r\n                        if(_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\r\n                            var m = _.divide(dc[0].clone(), dc2[0].clone());\r\n\r\n                            var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\r\n                            new_val = _.multiply(new_val, new Symbol(u));\r\n                            return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\r\n                        }\r\n\r\n                    }\r\n                    var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\r\n                            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n\r\n\r\n                    return retval;\r\n                }\r\n                else if(g2 === EX && g1 !== EX) {\r\n                    var p = b.power;\r\n                    Q = try_combo(a, p.clone());\r\n                    var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\r\n                    return _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n                }\r\n                else if(a.isComposite() || b.isComposite()) {\r\n                    var f = function (a, b) {\r\n                        var d = __.diff(b, dx);\r\n                        var A = core.Algebra.Factor.factor(a),\r\n                                B = core.Algebra.Factor.factor(d);\r\n                        var q = _.divide(A, B);\r\n                        return q;\r\n                    };\r\n                    var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\r\n                            f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\r\n                    Q = try_combo(f1.clone(), f2.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(f2.clone(), f1.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(a), Q);\r\n                }\r\n            },\r\n            //simple integration of a single polynomial x^(n+1)/(n+1)\r\n            poly_integrate: function (x) {\r\n                var p = x.power.toString(),\r\n                        m = x.multiplier.toDecimal(),\r\n                        s = x.toUnitMultiplier().toLinear();\r\n                if(Number(p) === -1) {\r\n                    return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\r\n                }\r\n                return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\r\n            },\r\n            //If we're just spinning wheels we want to stop. This is why we \r\n            //wrap integration in a try catch block and call this to stop.\r\n            stop: function (msg) {\r\n                msg = msg || 'Unable to compute integral!';\r\n                core.Utils.warn(msg);\r\n                throw new NoIntegralFound(msg);\r\n            },\r\n            partial_fraction: function (input, dx, depth, opt) {\r\n                //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\r\n                if(!isSymbol(dx))\r\n                    dx = _.parse(dx);\r\n\r\n                var result, partial_fractions;\r\n                result = new Symbol(0);\r\n                partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\r\n\r\n                if(partial_fractions.group === CB && partial_fractions.isLinear()) {\r\n                    //perform a quick check to make sure that all partial fractions are linear\r\n                    partial_fractions.each(function (x) {\r\n                        if(!x.isLinear())\r\n                            __.integration.stop();\r\n                    });\r\n                    partial_fractions.each(function (x) {\r\n                        result = _.add(result, __.integrate(x, dx, depth, opt));\r\n                    });\r\n                }\r\n                else {\r\n                    result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\r\n                }\r\n                return result;\r\n            },\r\n            get_udv: function (symbol) {\r\n                var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\r\n                //first we sort them \r\n                var setSymbol = function (x) {\r\n                    var g = x.group;\r\n                    if(g === FN) {\r\n                        var fname = x.fname;\r\n                        if(core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))\r\n                            parts[3].push(x);\r\n                        else if(core.Utils.in_inverse_trig(fname))\r\n                            parts[1].push(x);\r\n                        else if(fname === LOG)\r\n                            parts[0].push(x);\r\n                        else {\r\n                            __.integration.stop();\r\n                        }\r\n                    }\r\n                    else if(g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\r\n                        parts[2].push(x);\r\n                    }\r\n                    else if(g === EX || x.isComposite() && !x.isLinear())\r\n                        parts[4].push(x);\r\n                    else\r\n                        __.integration.stop();\r\n                };\r\n\r\n                if(symbol.group === CB)\r\n                    symbol.each(function (x) {\r\n                        setSymbol(Symbol.unwrapSQRT(x, true));\r\n                    });\r\n                else\r\n                    setSymbol(symbol);\r\n                var u, dv = new Symbol(1);\r\n                //compile u and dv\r\n                for(var i = 0; i < 5; i++) {\r\n                    var part = parts[i], t,\r\n                            l = part.length;\r\n                    if(l > 0) {\r\n                        if(l > 1) {\r\n                            t = new Symbol(1);\r\n                            for(var j = 0; j < l; j++)\r\n                                t = _.multiply(t, part[j].clone());\r\n                        }\r\n                        else\r\n                            t = part[0].clone();\r\n\r\n                        if(!u) {\r\n                            u = t;//the first u encountered gets chosen\r\n                            u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\r\n                        }\r\n                        else\r\n                            dv = _.multiply(dv, t); //everything else belongs to dv\r\n                    }\r\n                }\r\n\r\n                return [u, dv];\r\n            },\r\n\r\n            trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\r\n                parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\r\n                var b = parts[3],\r\n                        ax = parts[2],\r\n                        a = parts[0],\r\n                        x = parts[1];\r\n                if(x.power.equals(2) && a.greaterThan(0)) {\r\n                    //use tan(x)\r\n                    var t = core.Utils.getU(symbol), //get an appropriate u\r\n                            u = _.parse(TAN + inBrackets(t)), //u\r\n                            du = _.parse(SEC + inBrackets(t) + '^2'), //du\r\n                            f = _.multiply(symbol.sub(x, u), du);\r\n                    var integral = __.integrate(f, t, depth, opt).sub(u, x);\r\n                    core.Utils.clearU(u);\r\n                    return integral;\r\n                }\r\n            },\r\n\r\n            by_parts: function (symbol, dx, depth, o) {\r\n                o.previous = o.previous || [];\r\n                var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\r\n                //first LIATE\r\n                udv = __.integration.get_udv(symbol);\r\n                u = udv[0];\r\n                dv = udv[1];\r\n                du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\r\n                c = du.clone().stripVar(dx);\r\n                //strip any coefficients\r\n                du = _.divide(du, c.clone());\r\n                v = __.integrate(dv.clone(), dx, depth || 0);\r\n                vdu = _.multiply(v.clone(), du);\r\n                vdu_s = vdu.toString();\r\n                //currently only supports e^x*(some trig)\r\n                if(o.previous.indexOf(vdu_s) !== -1 && (core.Utils.in_trig(u.fname)) && dv.isE()) {\r\n                    //We're going to exploit the fact that vdu can never be constant\r\n                    //to work out way out of this cycle. We'll return the length of\r\n                    //the this.previous array until we're back at level one\r\n                    o.is_cyclic = true;\r\n                    //return the integral. \r\n                    return new Symbol(1);\r\n                }\r\n                else\r\n                    o.previous.push(vdu_s);\r\n\r\n                uv = _.multiply(u, v);\r\n                //clear the multiplier so we're dealing with a bare integral\r\n                m = vdu.multiplier.clone();\r\n                vdu.toUnitMultiplier();\r\n                integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\r\n                integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\r\n                retval = _.subtract(uv, integral_vdu);\r\n                //we know that there cannot be constants so they're a holdover from a cyclic integral\r\n                if(o.is_cyclic) {\r\n                    //start popping the previous stack so we know how deep in we are\r\n                    o.previous.pop();\r\n                    if(o.previous.length === 0) {\r\n                        retval = _.expand(retval);\r\n                        var rem = new Symbol(0);\r\n                        retval.each(function (x) {\r\n                            if(!x.contains(dx))\r\n                                rem = _.add(rem, x.clone());\r\n                        });\r\n                        //get the actual uv\r\n                        retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\r\n                    }\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            /*\r\n             * dependents: [Solve, integrate]\r\n             */\r\n            decompose_arg: core.Utils.decompose_fn\r\n        },\r\n        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\r\n        integrate: function (original_symbol, dt, depth, opt) {\r\n            //assume integration wrt independent variable if expression only has one variable\r\n            if(!dt) {\r\n                var vars = core.Utils.variables(original_symbol);\r\n                if(vars.length === 1)\r\n                    dt = vars[0];\r\n                //defaults to x\r\n                dt = dt || 'x';\r\n            }\r\n            //add support for integrating vectors\r\n            if(core.Utils.isVector(original_symbol)) {\r\n                var vector = new core.Vector([]);\r\n                original_symbol.each(function (x) {\r\n                    vector.elements.push(__.integrate(x, dt));\r\n                });\r\n                return vector;\r\n            }\r\n            if(!isNaN(dt))\r\n                _.error('variable expected but received ' + dt);\r\n            //get rid of constants right away\r\n            if(original_symbol.isConstant(true))\r\n                return _.multiply(original_symbol.clone(), _.parse(dt));\r\n\r\n            //configurations options for integral. This is needed for tracking extra options\r\n            //e.g. cyclic integrals or additional settings\r\n            opt = opt || {};\r\n            return core.Utils.block('PARSE2NUMBER', function () {\r\n                //make a note of the original symbol. Set only if undefined\r\n                depth = depth || 0;\r\n                var dx = isSymbol(dt) ? dt.toString() : dt,\r\n                        //we don't want the symbol in sqrt form. x^(1/2) is prefererred\r\n                        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\r\n                        g = symbol.group,\r\n                        retval;\r\n\r\n                try {\r\n                    //We stop integration after x amount of recursive calls\r\n                    if(++depth > core.Settings.integration_depth)\r\n                        __.integration.stop('Maximum depth reached. Exiting!');\r\n\r\n                    //constants. We first eliminate anything that doesn't have dx. Everything after this has \r\n                    //to have dx or else it would have been taken care of below\r\n                    if(!symbol.contains(dx, true)) {\r\n                        retval = _.multiply(symbol.clone(), _.parse(dx));\r\n                    }\r\n                    //e.g. 2*x\r\n                    else if(g === S) {\r\n                        retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                    }\r\n                    else if(g === EX) {\r\n                        if(symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS))\r\n                            __.integration.stop();\r\n                        //check the base\r\n                        if(symbol.contains(dx) && symbol.previousGroup !== FN) {\r\n                            //if the symbol also contains dx then we stop since we currently \r\n                            //don't know what to do with it e.g. x^x\r\n                            if(symbol.power.contains(dx))\r\n                                __.integration.stop();\r\n                            else {\r\n                                var t = __.diff(symbol.clone().toLinear(), dx);\r\n                                if(t.contains(dx))\r\n                                    __.integration.stop();\r\n                                //since at this point it's the base only then we do standard single poly integration\r\n                                //e.g. x^y\r\n                                retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                            }\r\n                        }\r\n                        //e.g. a^x or 9^x\r\n                        else {\r\n                            var a = __.diff(symbol.power.clone(), dx);\r\n                            if(a.contains(dx)) {\r\n                                var aa = a.stripVar(dx),\r\n                                        x = _.divide(a.clone(), aa.clone());\r\n                                if(x.group === S && x.isLinear()) {\r\n                                    aa.multiplier = aa.multiplier.divide(new Frac(2));\r\n                                    return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            if(symbol.isE()) {\r\n                                if(a.isLinear())\r\n                                    retval = symbol;\r\n                                else {\r\n                                    if(a.isE() && a.power.group === S && a.power.power.equals(1))\r\n                                        retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\r\n                                retval = _.divide(symbol, d);\r\n                            }\r\n                            retval = _.divide(retval, a);\r\n                        }\r\n                    }\r\n                    else if(symbol.isComposite() && symbol.isLinear()) {\r\n                        var m = _.parse(symbol.multiplier);\r\n                        symbol.toUnitMultiplier();\r\n                        retval = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            retval = _.add(retval, __.integrate(x, dx, depth));\r\n                        });\r\n                        retval = _.multiply(m, retval);\r\n                    }\r\n                    else if(g === CP) {\r\n                        if(symbol.power.greaterThan(1))\r\n                            symbol = _.expand(symbol);\r\n                        if(symbol.power.equals(1)) {\r\n                            retval = new Symbol(0);\r\n                            symbol.each(function (x) {\r\n                                retval = _.add(retval, __.integrate(x, dx, depth));\r\n                            }, true);\r\n                        }\r\n                        else {\r\n                            var p = Number(symbol.power),\r\n                                    m = symbol.multiplier.clone();//temporarily remove the multiplier\r\n                            symbol.toUnitMultiplier();\r\n                            var //below we consider the form ax+b\r\n                                    fn = symbol.clone().toLinear(), //get just the pure function without the power\r\n                                    decomp = __.integration.decompose_arg(fn, dx),\r\n                                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\r\n                                    b = decomp[3],\r\n                                    ax = decomp[2],\r\n                                    a = decomp[0],\r\n                                    x = decomp[1];\r\n                            if(p === -1 && x.group !== PL && x.power.equals(2)) {\r\n                                var b_is_positive = isInt(b) ? b > 0 : true;\r\n                                //we can now check for atan\r\n                                if(x.group === S && x.power.equals(2) && b_is_positive) {\r\n                                    ////then we have atan\r\n                                    //abs is redundants since the sign appears in both denom and num.\r\n                                    var unwrapAbs = function (s) {\r\n                                        var result = new Symbol(1);\r\n                                        s.each(function (x) {\r\n                                            result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\r\n                                        });\r\n                                        return result;\r\n                                    };\r\n                                    var A = a.clone(),\r\n                                            B = b.clone();\r\n                                    A = _.pow(A, new Symbol(1 / 2));\r\n                                    B = _.pow(B, new Symbol(1 / 2));\r\n                                    //unwrap abs\r\n\r\n                                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\r\n                                            f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\r\n                                    retval = _.divide(f, d);\r\n                                }\r\n                                else if(x.group === S && x.isLinear()) {\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                }\r\n                                else {\r\n                                    //1/(x^4+1)\r\n                                    if(x.power.equals(4)) {\r\n                                        //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\r\n                                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\r\n                                        var br = inBrackets;\r\n                                        //apply rule: ax^4+b = (ax^2+2abx+b)(ax^2-2abx+b)\r\n                                        //get quadratic factors\r\n                                        A = _.parse(SQRT + br(a) + '*' + dx + '^2');\r\n                                        B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        C = _.parse(SQRT + br(b));\r\n                                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\r\n                                        f2 = _.add(_.subtract(A, B), C);\r\n                                        //calculate numerators: [D+E, D-E] -> [2*b^(3/4)+bax, 2*b^(3/4)-bax]\r\n                                        D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\r\n                                        E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        //let F = 2b2b\r\n                                        F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4'));\r\n                                        //calculate the factors\r\n                                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\r\n                                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\r\n                                        retval = _.add(\r\n                                                __.integrate(L1, dx, depth, opt),\r\n                                                __.integrate(L2, dx, depth, opt)\r\n                                                );\r\n                                    }\r\n                                    else\r\n                                        //let's try partial fractions\r\n                                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                }\r\n                            }\r\n                            else if(p === -1 / 2) {\r\n                                //detect asin and atan\r\n                                if(x.group === S && x.power.equals(2)) {\r\n                                    if(ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\r\n                                        a.negate();\r\n                                        //it's asin\r\n                                        if(b.isConstant() && a.isConstant()) {\r\n                                            var d = _.symfunction(SQRT, [a.clone()]),\r\n                                                    d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\r\n                                            retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\r\n                                        }\r\n                                        //I'm not sure about this one. I'm trusting Wolfram Alpha here\r\n                                        else {\r\n                                            var sqrt_a = _.symfunction(SQRT, [a]),\r\n                                                    sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\r\n                                            retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\r\n                                        __.integration.stop();\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\r\n                                    __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                if(x.isLinear() && x.group !== PL)\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                else if(x.power.equals(2) && a.greaterThan(0)) {\r\n                                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\r\n                                    //1/(a*x^2+b^2)^n\r\n                                    //strip the value of b so b = 1\r\n                                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\r\n                                    sqb = _.parse(SQRT + inBrackets(b));\r\n                                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\r\n                                    bsqi = _.pow(b, new Symbol(symbol.power));\r\n                                    uv = core.Utils.getU(symbol);\r\n                                    u = _.multiply(aob, x.clone().toLinear());\r\n                                    v = _.parse(ATAN + inBrackets(u));\r\n                                    //the conversion will be 1+tan(x)^2 -> sec(x)^2\r\n                                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \r\n                                    //then the remaining sec will be (n-1)*2;\r\n                                    var n = (Math.abs(symbol.power) - 1) * 2;\r\n                                    //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\r\n                                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\r\n                                    core.Utils.clearU(uv);\r\n                                    return _.multiply(integral.sub(uv, v), bsqi);\r\n                                }\r\n                                else {\r\n                                    if(symbol.group !== CB && !symbol.power.lessThan(0)) {\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n                                    else {\r\n                                        var f = symbol.clone().toLinear();\r\n                                        var factored = core.Algebra.Factor.factor(f);\r\n                                        var was_factored = factored.toString() !== f.toString();\r\n                                        if(core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\r\n                                            try {\r\n                                                var f1, fx, u, sq;\r\n                                                sq = core.Algebra.sqComplete(f, dx);\r\n                                                u = core.Utils.getU(f);\r\n                                                f1 = sq.f.sub(sq.a, u);\r\n                                                fx = _.pow(f1, _.parse(symbol.power));\r\n                                                retval = __.integrate(fx, u).sub(u, sq.a);\r\n                                            }\r\n                                            catch(e) {\r\n                                                __.integration.stop();\r\n                                            }\r\n                                        }\r\n                                        else\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                    }\r\n                                }\r\n                            }\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === FN) {\r\n                        var arg = symbol.args[0],\r\n                                m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        var decomp = __.integration.decompose_arg(arg, dx);\r\n                        //easies way I can think of to get the coefficient and to make sure\r\n                        //that the symbol is linear wrt dx. I'm not actually trying to get the \r\n                        //derivative\r\n                        var a = decomp[0],\r\n                                x = decomp[1],\r\n                                fname = symbol.fname;\r\n                        //log is a special case that can be handled with integration by parts\r\n                        if(fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {\r\n                            /*integration by parts */\r\n                            var p = symbol.power.toString();\r\n                            if(isInt(p))\r\n                                depth = depth - p; //it needs more room to find the integral\r\n\r\n                            if(!arg.isComposite())\r\n                                retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));\r\n                            else {\r\n                                //integral u du\r\n                                var u = core.Utils.getU(symbol);\r\n                                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\r\n                                var du = __.diff(arg, dx);\r\n                                var u_du = _.multiply(f, du);\r\n                                var integral = __.integrate(u_du, u, depth, opt);\r\n                                retval = _.multiply(_.parse(m), integral.sub(u, arg));\r\n                            }\r\n\r\n                        }\r\n                        else if(fname === TAN && symbol.power.lessThan(0)) {\r\n                            //convert to cotangent\r\n                            var sym = symbol.clone();\r\n                            sym.power.negate();\r\n                            sym.fname = COT;\r\n                            return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\r\n                        }\r\n                        else {\r\n                            if(!a.contains(dx, true) && symbol.isLinear()) { //perform a deep search for safety\r\n                                //first handle the special cases \r\n                                if(fname === ABS) {\r\n                                    //REVISIT **TODO**\r\n                                    var x = _.divide(arg.clone(), a.clone());\r\n                                    if(x.group === S && !x.power.lessThan(0)) {\r\n                                        if(core.Utils.even(x.power)) {\r\n                                            retval = __.integrate(arg, dx, depth);\r\n                                        }\r\n                                        else {\r\n                                            var integrated = __.integrate(x, dx, depth);\r\n                                            integrated.power = integrated.power.subtract(new Frac(1));\r\n                                            retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                                else {\r\n                                    var ag = symbol.args[0].group,\r\n                                            decomposed = __.integration.decompose_arg(arg, dx);\r\n\r\n                                    if(!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())\r\n                                        __.integration.stop();\r\n                                    /**TODO**/ //ASIN, ACOS, ATAN\r\n                                    switch(fname) {\r\n                                        case COS:\r\n                                            retval = _.symfunction(SIN, [arg]);\r\n                                            break;\r\n                                        case SIN:\r\n                                            retval = _.symfunction(COS, [arg]);\r\n                                            retval.negate();\r\n                                            break;\r\n                                        case TAN:\r\n                                            retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\r\n                                            break;\r\n                                        case SEC:\r\n                                            retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\r\n                                            break;\r\n                                        case CSC:\r\n                                            retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\r\n                                            break;\r\n                                        case COT:\r\n                                            retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\r\n                                            break;\r\n                                        case SINH:\r\n                                            retval = _.symfunction(COSH, [arg]);\r\n                                            break;\r\n                                        case COSH:\r\n                                            retval = _.symfunction(SINH, [arg]);\r\n                                            break;\r\n                                        case TANH:\r\n                                            retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\r\n                                            break;\r\n                                        case ASEC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOT:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //inverse htrig\r\n                                        case ASECH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSCH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOTH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //end inverse htrig\r\n                                            //htrigh\r\n                                        case SECH:\r\n                                            retval = _.parse(format('atan(sinh({0}))', arg));\r\n                                            break;\r\n                                        case CSCH:\r\n                                            retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\r\n                                            break;\r\n                                        case COTH:\r\n                                            retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\r\n                                            break;\r\n                                            //end htrig\r\n                                        case EXP:\r\n                                            retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\r\n                                            break;\r\n                                        case 'S':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\r\n                                            break;\r\n                                        case 'C':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\r\n                                            break;\r\n                                        case 'erf':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\r\n                                            break;\r\n                                        case 'sign':\r\n                                            retval = _.multiply(symbol.clone(), arg.clone());\r\n                                            break;\r\n                                        default:\r\n                                            __.integration.stop();\r\n                                    }\r\n\r\n                                    retval = _.divide(retval, a);\r\n                                }\r\n                            }\r\n                            else if(x.isLinear()) {\r\n                                if(fname === COS || fname === SIN) {\r\n                                    var p = Number(symbol.power);\r\n                                    //check to see if it's negative and then just transform it to sec or csc\r\n                                    if(p < 0) {\r\n                                        symbol.fname = fname === SIN ? CSC : SEC;\r\n                                        symbol.invert().updateHash();\r\n                                        retval = __.integrate(symbol, dx, depth);\r\n                                    }\r\n                                    else {\r\n                                        var arg = symbol.args[0],\r\n                                                rd = symbol.clone(), //cos^(n-1)\r\n                                                rd2 = symbol.clone(), //cos^(n-2)\r\n                                                q = new Symbol((p - 1) / p), //\r\n                                                na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\r\n                                        rd.power = rd.power.subtract(new Frac(1));\r\n                                        rd2.power = rd2.power.subtract(new Frac(2));\r\n\r\n                                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\r\n                                        if(fname === SIN)\r\n                                            t.negate();\r\n                                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\r\n                                    }\r\n                                }\r\n                                //tan(x)^n or cot(x)^n\r\n                                else if(fname === TAN || fname === COT) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    if(symbol.args[0].isLinear(dx)) {\r\n                                        var n = symbol.power.subtract(new Frac(1)).toString(),\r\n                                                r = symbol.clone().toUnitMultiplier(),\r\n                                                w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\r\n                                        r.power = r.power.subtract(new Frac(2));\r\n                                        if(r.power.equals(0))\r\n                                            r = _.parse(r);\r\n                                        retval = _.subtract(w, __.integrate(r, dx, depth));\r\n                                    }\r\n                                }\r\n                                //sec(x)^n or csc(x)^n\r\n                                else if(fname === SEC || fname === CSC) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    var n1 = symbol.power.subtract(new Frac(1)).toString(),\r\n                                            n2 = symbol.power.subtract(new Frac(2)).toString(),\r\n                                            f2 = fname === SEC ? TAN : COT,\r\n                                            r = symbol.clone().toUnitMultiplier(),\r\n                                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\r\n                                            w = _.parse(parse_str);\r\n                                    r.power = r.power.subtract(new Frac(2));\r\n                                    if(r.power.equals(0))\r\n                                        r = _.parse(r);\r\n                                    retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\r\n                                }\r\n                                else if((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\r\n                                    retval = __.integrate(symbol.fnTransform(), dx, depth);\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            else\r\n                                __.integration.stop();\r\n\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === PL) {\r\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                    }\r\n                    else if(g === CB) {\r\n                        var den = symbol.getDenom();\r\n                        if(den.group === S)\r\n                            symbol = _.expand(symbol);\r\n\r\n                        //separate the coefficient since all we care about are symbols containing dx\r\n                        var coeff = symbol.stripVar(dx);\r\n                        //now get only those that apply\r\n                        var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\r\n                        //peform a correction for stripVar. This is a serious TODO!\r\n                        if(coeff.contains(dx)) {\r\n                            cfsymbol = _.multiply(cfsymbol, coeff);\r\n                            coeff = new Symbol(1);\r\n                        }\r\n\r\n                        //if we only have one symbol left then let's not waste time. Just pull the integral\r\n                        //and let the chips fall where they may\r\n                        if(cfsymbol.group !== CB) {\r\n                            if(cfsymbol.equals(1)) {\r\n                                return __.integrate(_.expand(symbol), dx, depth);\r\n                            }\r\n\r\n                            //only factor for multivariate which are polynomials\r\n                            if(cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\r\n                                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\r\n                            }\r\n\r\n                            retval = __.integrate(cfsymbol, dx, depth);\r\n                        }\r\n                        else {\r\n                            //we collect the symbols and sort them descending group, descending power, descending alpabethically\r\n                            var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\r\n                                if(a.group === b.group) {\r\n                                    if(Number(a.power) === Number(b.power))\r\n                                        if(a < b)\r\n                                            return 1; //I want sin first\r\n                                        else\r\n                                            return -1;\r\n                                    return b.power - a.power; //descending power\r\n                                }\r\n                                return b.group - a.group; //descending groups\r\n                            }).map(function (x) {\r\n                                var unwrapped = Symbol.unwrapSQRT(x, true);\r\n                                if(unwrapped.fname === EXP) {\r\n                                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\r\n                                }\r\n                                return unwrapped;\r\n                            });\r\n                            var l = symbols.length;\r\n                            if(symbol.power < 0) {\r\n                                if(l === 2) {\r\n                                    return __.integrate(_.expand(symbol), dx, depth, opt);\r\n                                }\r\n                            }\r\n                            //otherwise the denominator is one lumped together symbol \r\n                            else {\r\n                                //generate an image for \r\n                                if(l === 2) {\r\n                                    //try u substitution\r\n                                    try {\r\n                                        retval = __.integration.u_substitution(symbols, dx);\r\n                                    }\r\n                                    catch(e) {/* failed :`(*/\r\n                                        ;\r\n                                    }\r\n\r\n                                    if(!retval) {\r\n                                        //no success with u substitution so let's try known combinations\r\n                                        //are they two functions\r\n                                        var g1 = symbols[0].group,\r\n                                                g2 = symbols[1].group,\r\n                                                sym1 = symbols[0],\r\n                                                sym2 = symbols[1],\r\n                                                fn1 = sym1.fname,\r\n                                                fn2 = sym2.fname;\r\n                                        //reset the symbol minus the coeff\r\n                                        symbol = _.multiply(sym1.clone(), sym2.clone());\r\n                                        if(g1 === FN && g2 === FN) {\r\n                                            if(fn1 === LOG || fn2 === LOG) {\r\n                                                retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\r\n                                            }\r\n                                            else {\r\n                                                symbols.sort(function (a, b) {\r\n                                                    return b.fname > a.fname;\r\n                                                });\r\n                                                var arg1 = sym1.args[0];\r\n                                                //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\r\n                                                if(!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))\r\n                                                    __.integration.stop();\r\n\r\n                                                var decomp = __.integration.decompose_arg(arg1, dx);\r\n                                                x = decomp[1],\r\n                                                        a = decomp[0];\r\n                                                if(!x.isLinear()) //again... linear arguments only wrt x\r\n                                                    __.integration.stop();\r\n\r\n                                                //they have to have the same arguments and then we have cleared all the check to \r\n                                                //make sure we can integrate FN & FN\r\n                                                var arg2 = sym2.args[0];\r\n                                                //make sure that their argument matches\r\n                                                if(arg1.equals(arg2)) {\r\n                                                    if(fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\r\n                                                        if(sym1.power.lessThan(0))\r\n                                                            __.integration.stop();//we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\r\n                                                        //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\r\n                                                        if(fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\r\n                                                            sym1.fname = TAN;\r\n                                                            sym1.updateHash();\r\n                                                            retval = __.integrate(sym1, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            if(even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\r\n                                                                //transform sin^(2*n) to (1-cos^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else if(even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\r\n                                                                //transform cos^(2*n) to (1-sin^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else {\r\n                                                                var p1_even = core.Utils.even(sym1.power),\r\n                                                                        p2_even = core.Utils.even(sym2.power);\r\n                                                                retval = new Symbol(0);\r\n                                                                if(!p1_even || !p2_even) {\r\n                                                                    var u, r, trans;\r\n                                                                    //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\r\n                                                                    //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\r\n                                                                    if(!p1_even) {\r\n                                                                        //u = sin(x)\r\n                                                                        u = sym2;\r\n                                                                        r = sym1;\r\n                                                                    }\r\n                                                                    else {\r\n                                                                        u = sym1;\r\n                                                                        r = sym2;\r\n                                                                    }\r\n                                                                    //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\r\n                                                                    var sign = u.fname === COS ? -1 : 1,\r\n                                                                            n = r.power,\r\n                                                                            //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \r\n                                                                            //even powers afterwards which can be transformed\r\n                                                                            k = (n - 1) / 2,\r\n                                                                            //make the transformation cos(x)^2 = 1 - sin(x)^2\r\n                                                                            trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\r\n                                                                            sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\r\n                                                                    //we can now just loop through and integrate each since it's now just a polynomial with functions\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\r\n                                                                    });\r\n                                                                }\r\n                                                                else {\r\n                                                                    //performs double angle transformation\r\n                                                                    var double_angle = function (symbol) {\r\n                                                                        var p = symbol.power,\r\n                                                                                k = p / 2, e;\r\n                                                                        if(symbol.fname === COS)\r\n                                                                            e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n                                                                        else\r\n                                                                            e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n\r\n                                                                        return _.parse(e);\r\n                                                                    };\r\n                                                                    //they're both even so transform both using double angle identities and we'll just\r\n                                                                    //be able to integrate by the sum of integrals\r\n                                                                    var a = double_angle(sym1),\r\n                                                                            b = double_angle(sym2),\r\n                                                                            t = _.multiply(a, b);\r\n                                                                    var sym = _.expand(t);\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                                    });\r\n                                                                    return _.multiply(retval, coeff);\r\n                                                                }\r\n                                                            }\r\n                                                        }\r\n                                                    }\r\n                                                    //tan(x)*sec(x)^n \r\n                                                    else if(fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\r\n                                                        retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\r\n                                                    }\r\n                                                    else if(fn1 === TAN && fn2 === SEC && x.isLinear()) {\r\n                                                        //remaining: tan(x)^3*sec(x)^6\r\n                                                        if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                            retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\r\n                                                        }\r\n                                                        else if(even(sym1.power)) {\r\n                                                            var p = Number(sym1.power) / 2;\r\n                                                            //transform tangent\r\n                                                            var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\r\n                                                            retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\r\n                                                        }\r\n                                                        else\r\n                                                            __.integration.stop();\r\n                                                    }\r\n                                                    else if(fn1 === SEC && fn2 === COS) {\r\n                                                        sym1.fname = COS;\r\n                                                        sym1.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    else if(fn1 === SIN && fn2 === CSC) {\r\n                                                        sym2.fname = SIN;\r\n                                                        sym2.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    //tan/cos\r\n                                                    else if(fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2);\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                    else {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                }\r\n                                                //TODO: In progress\r\n                                                else if((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\r\n\r\n                                                    if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                        //if in the form cos(a*x)*sin(b*x)\r\n                                                        if(sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\r\n                                                            //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\r\n                                                            var ax, bx;\r\n                                                            if(fn2 === SIN) {\r\n                                                                ax = sym1.args[0];\r\n                                                                bx = sym2.args[0];\r\n                                                            }\r\n                                                            else {\r\n                                                                bx = sym1.args[0];\r\n                                                                ax = sym2.args[0];\r\n                                                            }\r\n\r\n                                                            //make the transformation\r\n                                                            f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\r\n\r\n                                                            //integrate it\r\n                                                            retval = __.integrate(f, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            var transformed = trigTransform(symbols);\r\n                                                            retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                    else {\r\n                                                        var transformed = new Symbol(1);\r\n                                                        symbols.map(function (sym) {\r\n                                                            var s = sym.fnTransform();\r\n                                                            transformed = _.multiply(transformed, s);\r\n                                                        });\r\n                                                        var t = _.expand(transformed);\r\n\r\n                                                        retval = __.integrate(t, dx, depth);\r\n\r\n                                                        if(retval.hasIntegral()) {\r\n                                                            retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                else {\r\n                                                    __.integration.stop();\r\n                                                }\r\n\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === FN && g2 === S) {\r\n                                            var sym1_is_linear = sym1.isLinear();\r\n                                            if(sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Ci', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COS && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Chi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COSH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Si', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SIN && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Shi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SINH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === LOG && sym2.power.equals(-1)) {\r\n                                                //log(x)^n/x = log(x)^(n+1)/(n+1)\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === 'erf') {\r\n                                                if(sym2.power.equals(1)) {\r\n                                                    var dc = __.integration.decompose_arg(sym1.args[0], dx),\r\n                                                            a_ = dc[0],\r\n                                                            x_ = dc[1],\r\n                                                            arg = sym1.args[0].toString();\r\n                                                    retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg))\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                //since group S is guaranteed convergence we need not worry about tracking depth of integration\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === EX && g2 === S) {\r\n                                            var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\r\n                                            if(sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\r\n                                                retval = _.symfunction('Ei', [sym1.power.clone()]);\r\n                                            }\r\n                                            else if(fn1 === LOG && x.value === sym2.value) {\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                        else if(g1 === PL && g2 === S) {\r\n                                            //first try to reduce the top\r\n                                            if(sym2.value === sym1.value && sym1.power.equals(-1)) {\r\n                                                //find the lowest power in the denominator\r\n                                                var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\r\n                                                //get the lowest common value between denominator and numerator\r\n                                                var pc = Math.min(pd, sym2.power);\r\n                                                //reduce both denominator and numerator by that factor\r\n                                                var factor = sym2.clone();\r\n                                                factor.power = new Frac(pc);\r\n                                                sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\r\n                                                var t = new Symbol(0);\r\n                                                sym1.each(function (x) {\r\n                                                    t = _.add(t, _.divide(x.clone(), factor.clone()));\r\n                                                });\r\n                                                t.multiplier = sym1.multiplier;\r\n                                                symbol = _.divide(sym2, t);\r\n                                            }\r\n                                            else {\r\n                                                symbol = _.expand(symbol);\r\n                                            }\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                        }\r\n                                        else if(g1 === CP && g2 === S) {\r\n                                            var f = sym1.clone().toLinear(),\r\n                                                    f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\r\n                                            //handle cases x^(2*n)/sqrt(1-x^2)\r\n                                            if(sym1.power.equals(-1 / 2)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\r\n                                                var a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\r\n                                                    //if the substitution \r\n                                                    var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)),\r\n                                                            _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])),\r\n                                                            _.pow(a.clone(), new Symbol(2)));\r\n                                                    c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\r\n                                                    var dummy = _.parse('sin(u)');\r\n                                                    dummy.power = dummy.power.multiply(sym2.power);\r\n                                                    var integral = __.integrate(dummy, 'u', depth);\r\n                                                    var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\r\n                                                    retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\r\n                                                }\r\n                                                else if(p1 === -1 / 2) {\r\n                                                    var u_transform = function (f, u) {\r\n                                                        var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\r\n                                                        if(!integral.hasIntegral())\r\n                                                            return integral;\r\n                                                    }\r\n                                                    if(p2 === -1) {\r\n                                                        retval = u_transform(\r\n                                                                _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                    else if(p2 === -2) {\r\n                                                        //apply transformation to see if it matches asin(x)\r\n                                                        retval = u_transform(\r\n                                                                _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            else if(sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\r\n                                                retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else if(!sym1.power.lessThan(0) && isInt(sym1.power)) {\r\n                                                //sum of integrals\r\n                                                var expanded = _.expand(sym1);\r\n                                                retval = new Symbol(0);\r\n                                                expanded.each(function (x) {\r\n                                                    if(x.group === PL) {\r\n                                                        x.each(function (y) {\r\n                                                            retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\r\n                                                        });\r\n                                                    }\r\n                                                    else\r\n                                                        retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\r\n                                                });\r\n                                            }\r\n                                            else if(sym1.power.lessThan(-2)) {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                            else if(sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                        a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        fn = sym1.clone().toLinear();\r\n\r\n                                                if(x.group !== PL && x.isLinear()) {\r\n                                                    var p = Number(sym2.power),\r\n                                                            du = '_u_',\r\n                                                            u = new Symbol(du),\r\n                                                            //pull the integral with the subsitution\r\n                                                            U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\r\n                                                            scope = {};\r\n\r\n                                                    //generate a scope for resubbing the symbol\r\n                                                    scope[du] = fn;\r\n                                                    var U2 = _.parse(U, scope);\r\n                                                    retval = __.integrate(U2, dx, 0);\r\n                                                }\r\n                                                else if(sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\r\n\r\n                                                    //factor out coefficients\r\n                                                    var factors = new core.Algebra.Classes.Factors();\r\n                                                    sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\r\n                                                    var div = core.Algebra.divide(sym2, sym1);\r\n                                                    //it assumed that the result will be of group CB\r\n                                                    if(div.group !== CB) {\r\n                                                        retval = new Symbol(0);\r\n                                                        div.each(function (t) {\r\n                                                            retval = _.add(retval, __.integrate(t, dx, depth));\r\n                                                        });\r\n                                                        //put back the factors\r\n                                                        factors.each(function (factor) {\r\n                                                            retval = _.divide(retval, factor);\r\n                                                        });\r\n\r\n                                                        retval = _.expand(retval);\r\n                                                    }\r\n                                                    else {\r\n                                                        //try something else\r\n                                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else {\r\n                                                //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \r\n                                                if(sym1.power.den.equals(2)) {\r\n                                                    //assume the function is in the form (a^2-b*x^n)^(m/2)\r\n                                                    var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                            //using the above definition\r\n                                                            a = dc[3], x = dc[1], b = dc[0], bx = dc[2];\r\n                                                    if(x.power.equals(2) && b.lessThan(0)) { //if n is even && b is negative\r\n                                                        //make a equal 1 so we can do a trig sub\r\n                                                        if(!a.equals(1)) { //divide a out of everything\r\n                                                            //move a to the coeff\r\n                                                            coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\r\n                                                        }\r\n                                                        var u = dx;\r\n                                                        var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\r\n                                                                du = _.symfunction(COS, [new Symbol(u)]),\r\n                                                                cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\r\n                                                                X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\r\n                                                                val = _.multiply(_.multiply(cosn, du), X),\r\n                                                                integral = __.integrate(val, u, depth);\r\n                                                        //but remember that u = asin(sqrt(b)*a*x)\r\n                                                        retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\r\n                                                    }\r\n                                                    else {\r\n                                                        retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else if(f_is_linear) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n                                        else if(sym1.isComposite() && sym2.isComposite()) {\r\n                                            //sum of integrals\r\n                                            retval = new Symbol(0);\r\n                                            if(sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\r\n                                                //combine and pull the integral of each\r\n                                                var sym = _.expand(symbol);\r\n                                                sym.each(function (x) {\r\n                                                    retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                }, true);\r\n                                            }\r\n                                            else {\r\n                                                var p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(p1 < 0 && p2 > 0) {\r\n                                                    //swap\r\n                                                    var t = sym1;\r\n                                                    sym1 = sym2;\r\n                                                    sym2 = t;\r\n                                                }\r\n                                                if(p1 === -1 && p2 === -1) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx);\r\n                                                }\r\n                                                else {\r\n                                                    sym1.each(function (x) {\r\n                                                        var k = _.multiply(x, sym2.clone());\r\n                                                        var integral = __.integrate(k, dx, depth);\r\n                                                        retval = _.add(retval, integral);\r\n                                                    });\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === CP && symbols[0].power.greaterThan(0)) {\r\n                                            sym1 = _.expand(sym1);\r\n                                            retval = new Symbol(0);\r\n                                            sym1.each(function (x) {\r\n                                                retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\r\n                                            }, true);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\r\n                                            sym1 = sym1.fnTransform();\r\n                                            retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\r\n                                            if(g2 === FN && g1 === CP) {\r\n                                                var t = sym1;\r\n                                                sym1 = sym2;\r\n                                                sym2 = t; //swap\r\n                                            }\r\n                                            var du, sym2_clone, p, q, sa, sb;\r\n                                            du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\r\n                                            sym2_clone = Symbol.unwrapSQRT(sym2, true);\r\n                                            if(du.power.equals(sym2_clone.power)) {\r\n                                                p = new Symbol(sym2.power);\r\n                                                sa = du.clone().toLinear();\r\n                                                sb = sym2.clone().toLinear();\r\n                                                q = core.Algebra.divide(sa.toLinear(), sb);\r\n                                                if(q.isConstant()) {\r\n                                                    var nq = _.pow(q, p.negate());\r\n                                                    retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            var syma = sym1.clone().toLinear();\r\n                                            var symb = sym2.clone().toLinear();\r\n                                            if(g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx)\r\n                                                    && !syma.contains(dx) && !symb.contains(dx)) {\r\n                                                retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))',\r\n                                                        syma.toString(),\r\n                                                        symb.toString(),\r\n                                                        sym1.power.multiplier.toString(),\r\n                                                        sym2.power.multiplier.toString(),\r\n                                                        dx\r\n                                                        ));\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\r\n                                    var first = symbols[0];\r\n                                    if(first.group === CP) { //TODO {support higher powers of x in the future}\r\n                                        if(first.power.greaterThan(1))\r\n                                            first = _.expand(first);\r\n                                        var r = _.multiply(symbols[1], symbols[2]);\r\n                                        retval = new Symbol(0);\r\n                                        first.each(function (x) {\r\n                                            var t = _.multiply(x, r.clone());\r\n                                            var intg = __.integrate(t, dx, depth);\r\n                                            retval = _.add(retval, intg);\r\n                                        }, true);\r\n                                    }\r\n                                    else {\r\n                                        //try integration by parts although technically it will never work\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n\r\n                                }\r\n                                else if(all_functions(symbols)) {\r\n                                    var t = new Symbol(1);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        t = _.multiply(t, symbols[i].fnTransform());\r\n                                    }\r\n                                    t = _.expand(t);\r\n                                    retval = __.integrate(t, dx, depth);\r\n                                }\r\n                                else {\r\n                                    //one more go\r\n                                    var transformed = trigTransform(symbols);\r\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        retval = _.multiply(retval, coeff);\r\n                    }\r\n                    //if an integral was found then we return it\r\n                    if(retval)\r\n                        return retval;\r\n                }\r\n\r\n                catch(error) {\r\n                    //do nothing if it's a NoIntegralFound error otherwise let it bubble\r\n                    if(!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))\r\n                        throw error;\r\n                }\r\n\r\n                //no symbol found so we return the integral again\r\n                return _.symfunction('integrate', [original_symbol, dt]);\r\n            }, false);\r\n        },\r\n        defint: function (symbol, from, to, dx) {\r\n            dx = dx || 'x'; //make x the default variable of integration\r\n            var get_value = function (integral, vars, point) {\r\n                try {\r\n                    return _.parse(integral, vars);\r\n                }\r\n                catch(e) {\r\n                    //it failed for some reason so return the limit\r\n                    var lim = __.Limit.limit(integral, dx, point);\r\n                    return lim;\r\n                }\r\n            };\r\n\r\n            var vars = core.Utils.variables(symbol),\r\n                    hasTrig = symbol.hasTrig();\r\n            var retval, integral;\r\n\r\n            // Fix #593 - Only assume the first variable if dx is not defined.\r\n            if(vars.length === 1 && !dx)\r\n                dx = vars[0];\r\n\r\n            if(!hasTrig) {\r\n                integral = __.integrate(symbol, dx);\r\n            }\r\n\r\n            if(!hasTrig && !integral.hasIntegral()) {\r\n                var upper = {},\r\n                        lower = {},\r\n                        a, b;\r\n                upper[dx] = to;\r\n                lower[dx] = from;\r\n\r\n                a = get_value(integral, upper, to, dx);\r\n                b = get_value(integral, lower, from, dx);\r\n                retval = _.subtract(a, b);\r\n            }\r\n            else if(vars.length === 1 && from.isConstant() && to.isConstant()) {\r\n\r\n                var f = core.Utils.build(symbol);\r\n                retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\r\n            }\r\n            else\r\n                retval = _.symfunction('defint', [symbol, from, to, dx]);\r\n            return retval;\r\n        },\r\n\r\n        Limit: {\r\n            interval: function (start, end) {\r\n                return _.parse(format('[{0}, {1}]', start, end));\r\n            },\r\n            diverges: function () {\r\n                return __.Limit.interval('-Infinity', 'Infinity');\r\n            },\r\n            divide: function (f, g, x, lim, depth) {\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                var fin = f.clone(), gin = g.clone();\r\n\r\n                //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\r\n                //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\r\n                //the two-sided limit.\r\n                //Known limit\r\n                if(g.fname === ABS) {\r\n                    var sign = f.sign();\r\n                    var lim_sign = lim.sign();\r\n\r\n                    if(lim.isInfinity)\r\n                        return _.multiply(new Symbol(sign), new Symbol(lim_sign));\r\n\r\n                    else if(lim.equals(0)) {\r\n                        var fm = _.parse(f.multiplier);\r\n                        var gm = _.parse(g.multiplier);\r\n                        return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\r\n                    }\r\n                    else {\r\n                        //TODO: Support more limits\r\n                        __.Limit.diverges();\r\n                    }\r\n                }\r\n\r\n                var isInfinity = function (L) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        for(var i = 0; i < L.elements.length; i++)\r\n                            if(!L.elements[i].isInfinity)\r\n                                return false;\r\n                        return true;\r\n                    }\r\n                    return L.isInfinity;\r\n                };\r\n\r\n                var equals = function (L, v) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        return false;\r\n                    }\r\n                    return L.equals(v);\r\n                };\r\n\r\n                var retval;\r\n                do {\r\n                    var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\r\n                    var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\r\n\r\n                    //if it's in indeterminate form apply L'Hospital's rule\r\n                    var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\r\n                    //pull the derivatives\r\n                    if(indeterminate) {\r\n                        var ft = __.diff(f.clone(), x);\r\n                        var gt = __.diff(g.clone(), x);\r\n\r\n                        var t_symbol = _.expand(_.divide(ft, gt));\r\n                        f = t_symbol.getNum();\r\n                        g = t_symbol.getDenom();\r\n\r\n                    }\r\n                }\r\n                while(indeterminate)\r\n\r\n                //REMEMBER: \r\n                //- 1/cos(x)\r\n                //n/0 is still possible since we only checked for 0/0\r\n                var den_is_zero = lim2.equals(0);\r\n                var p = Number(gin.power);\r\n\r\n                if(lim.isConstant(true) && den_is_zero) {\r\n                    retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\r\n                }\r\n                else if(den_is_zero) {\r\n                    retval = __.Limit.diverges();\r\n                }\r\n                else {\r\n                    retval = _.divide(lim1, lim2);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            rewriteToLog: function (symbol) {\r\n                var p = symbol.power.clone();\r\n                symbol.toLinear();\r\n                return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\r\n            },\r\n            getSubbed: function (f, x, lim) {\r\n                var retval;\r\n                //1. rewrite EX with base e\r\n                if(f.group === EX) {\r\n                    f = __.rewriteToLog(f);\r\n                }\r\n                //2. try simple substitution\r\n                try {\r\n                    retval = f.sub(x, lim);\r\n                }\r\n                catch(e) {\r\n                    //Nope. No go, so just return the unsubbed function so we can test the limit instead.\r\n                    retval = f;\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            isInterval: function (limit) {\r\n                return core.Utils.isVector(limit);\r\n            },\r\n            isConvergent: function (limit) {\r\n                //it's not convergent if it lies on the interval -Infinity to Infinity\r\n                if(\r\n                        //It lies on the interval -Infinity to Infinity\r\n                        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\r\n                        //We weren't able to calculate the limit\r\n                        limit.containsFunction('limit')\r\n                        ) {\r\n                    return false; //Then no\r\n                }\r\n                return true; //It is\r\n            },\r\n            limit: function (symbol, x, lim, depth) {\r\n                //Simplify the symbol\r\n                if(symbol.isLinear() && symbol.isComposite()) {\r\n\r\n                    //Apply sum of limits\r\n                    var limit = new Symbol(0);\r\n                    symbol.each(function (s) {\r\n                        limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\r\n                    }, true);\r\n\r\n                    return limit;\r\n                }\r\n                ;\r\n\r\n                symbol = core.Algebra.Simplify.simplify(symbol);\r\n\r\n                depth = depth || 1;\r\n\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                //store the multiplier\r\n                var m = _.parse(symbol.multiplier);\r\n                //strip the multiplier\r\n                symbol.toUnitMultiplier();\r\n                try {\r\n                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                    var retval;\r\n                    //we try the simplest option first where c is some limit\r\n                    //lim a as x->c = a where c \r\n                    if(symbol.isConstant(true)) {\r\n                        retval = symbol;\r\n                    }\r\n                    else {\r\n                        var point = {};\r\n                        point[x] = lim;\r\n                        //lim x as x->c = c where c\r\n\r\n                        try {\r\n\r\n                            //evaluate the function at the given limit\r\n                            var t = _.parse(symbol.sub(x, lim), point);\r\n\r\n                            //a constant or infinity is known so we're done\r\n                            if(t.isConstant(true) || t.isInfinity)\r\n                                retval = t;\r\n\r\n                        }\r\n                        catch(e) { /*Nothing. Maybe we tried to divide by zero.*/\r\n                        }\r\n                        ;\r\n\r\n                        if(!retval) {\r\n                            //split the symbol in the numerator and the denominator\r\n                            var num = symbol.getNum();\r\n                            var den = symbol.getDenom();\r\n\r\n                            if(den.isConstant(true)) {\r\n                                //We still don't have a limit so we generate tests.\r\n                                if(symbol.group === EX) {\r\n                                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                                    //Speed boost for exponentials by detecting patterns\r\n                                    var f = symbol.clone().toLinear();\r\n                                    var p = symbol.power.clone();\r\n                                    var _num = f.getNum();\r\n                                    var _den = f.getDenom();\r\n                                    var fn = core.Utils.decompose_fn(_den, x, true);\r\n                                    //start detection of pattern (x/(x+1))^x\r\n                                    if(_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\r\n                                        retval = _.parse(format('(1/e^({0}))', fn.b));\r\n                                    }\r\n                                    else {\r\n                                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());\r\n                                        //get the base\r\n                                        var pow = symbol_.power.clone();\r\n                                        var base = symbol_.clone().toLinear();\r\n                                        var lim_base = __.Limit.limit(base, x, lim, depth);\r\n                                        var lim_pow = __.Limit.limit(pow, x, lim, depth);\r\n                                        retval = _.pow(lim_base, lim_pow);\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === FN && symbol.args.length === 1) {\r\n                                    var evaluates;\r\n                                    //Squeeze theorem lim f(g(x)) = lim f(lim g))\r\n                                    var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\r\n                                    if(core.Utils.isVector(arg)) {\r\n                                        //get the limit over that interval\r\n                                        retval = arg.map(function (e) {\r\n                                            var clone = symbol.clone();\r\n                                            clone.args[0] = e;\r\n                                            return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\r\n                                        });\r\n\r\n                                        return _.multiply(m, retval);\r\n                                    }\r\n                                    //if the argument is constant then we're done\r\n                                    else if(arg.isConstant(true)) {\r\n\r\n                                        //double check that it evaluates\r\n                                        var trial = _.symfunction(symbol.fname, [arg]);\r\n                                        //trial evaluation\r\n                                        try {\r\n                                            evaluate(trial);\r\n                                            evaluates = true;\r\n                                        }\r\n                                        catch(e) {\r\n\r\n                                            evaluates = false;\r\n                                        }\r\n                                    }\r\n                                    if(evaluates) {\r\n                                        retval = trial;\r\n                                    }\r\n                                    else {\r\n                                        //if the limit converges. We'll deal with non-convergent ones later\r\n                                        if(__.Limit.isConvergent(arg)) {\r\n                                            if(symbol.fname === LOG) {\r\n                                                switch(arg.toString()) {\r\n                                                    //lim -> 0\r\n                                                    case '0':\r\n                                                        retval = Symbol.infinity().negate();\r\n                                                        break;\r\n                                                    case 'Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                    case '-Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else if((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\r\n                                                retval = __.Limit.interval(-1, 1);\r\n                                            }\r\n                                            else if((symbol.fname === TAN)) {\r\n                                                var s_arg = symbol.args[0];\r\n                                                var n = s_arg.getNum();\r\n                                                var d = s_arg.getDenom();\r\n                                                var pi = n.toUnitMultiplier();\r\n                                                if(lim.isInfinity || pi.equals('pi') && d.equals(2)) {\r\n                                                    retval = divergent();\r\n                                                }\r\n                                            }\r\n                                            else if(symbol.fname === Settings.FACTORIAL) {\r\n                                                if(arg.isInfinity)\r\n                                                    return Symbol.infinity();\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === S) {\r\n                                    if(symbol.power > 0)\r\n                                        //these functions always converge to the limit\r\n                                        return _.parse(symbol, point);\r\n                                    else {\r\n                                        //we're dealing with 1/x^n but remember that infinity has already been dealt\r\n                                        //with by substitution\r\n                                        if(core.Utils.even(symbol.power)) {\r\n                                            //even powers converge to infinity\r\n                                            retval = Symbol.infinity();\r\n                                        }\r\n                                        else {\r\n                                            //odd ones don't\r\n                                            retval = __.Limit.diverges();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === CB) {\r\n\r\n                                    var lim1, lim2;\r\n                                    //loop through all the symbols\r\n                                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\r\n                                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return a.group - b.group;\r\n                                    });\r\n\r\n                                    var f = symbols.pop();\r\n                                    //calculate the first limit so we can keep going down the list\r\n                                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\r\n\r\n                                    //reduces all the limits one at a time\r\n                                    while(symbols.length) {\r\n                                        //get the second limit\r\n                                        var g = symbols.pop();\r\n                                        //get the limit of g\r\n                                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\r\n\r\n                                        //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\r\n                                        if((lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2))) {\r\n                                            if(g.containsFunction(LOG)) {\r\n                                                //swap them\r\n                                                g = [f, f = g][0];\r\n                                            }\r\n                                            //invert the symbol\r\n                                            g.invert();\r\n\r\n                                            // Product of infinities\r\n                                            if(lim1.isInfinity && lim2.isInfinity) {\r\n                                                lim1 = Symbol.infinity()\r\n                                            }\r\n                                            else {\r\n                                                lim1 = __.Limit.divide(f, g, x, lim, depth);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            //lim f*g = (lim f)*(lim g)\r\n                                            lim1 = _.multiply(lim1, lim2);\r\n                                            //let f*g equal f and h equal g \r\n                                            f = _.multiply(f, g);\r\n                                        }\r\n                                    }\r\n\r\n                                    //Done, lim1 is the limit we're looking for     \r\n                                    retval = lim1;\r\n                                }\r\n                                else if(symbol.isComposite()) {\r\n                                    var _lim;\r\n                                    if(!symbol.isLinear())\r\n                                        symbol = _.expand(symbol);\r\n                                    //Apply lim f+g = (lim f)+(lim g)\r\n                                    retval = new Symbol(0);\r\n\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return b.group - a.group;\r\n                                    });\r\n\r\n                                    var _symbols = [];\r\n                                    //Analyze the functions first\r\n                                    var fns = new Symbol(0);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i].clone();\r\n                                        if(sym.group === FN || sym.group === CB && sym.hasFunc()) {\r\n                                            fns = _.add(fns, sym);\r\n                                        }\r\n                                        else\r\n                                            _symbols.push(sym);\r\n                                    }\r\n                                    _symbols.unshift(fns);\r\n\r\n                                    //make sure that we didn't just repackage the exact same symbol\r\n                                    if(_symbols.length !== 1) {\r\n                                        symbols = _symbols;\r\n                                    }\r\n\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i];\r\n                                        //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\r\n                                        try {\r\n                                            _lim = __.Limit.limit(sym, x, lim, depth);\r\n                                        }\r\n                                        catch(e) {\r\n                                            _lim = __.Limit.diverges();\r\n                                        }\r\n\r\n                                        try {\r\n                                            retval = _.add(retval, _lim);\r\n                                        }\r\n                                        catch(e) {\r\n                                            if(depth++ > Settings.max_lim_depth) {\r\n                                                return;\r\n                                            }\r\n                                            ;\r\n                                            retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                retval = __.Limit.divide(num, den, x, lim, depth);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //if we still don't have a solution\r\n                    if(!retval)\r\n                        //return it symbolically\r\n                        retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n                catch(e) {\r\n                    //if all else fails return the symbolic function\r\n                    retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n        },\r\n        Fresnel: {\r\n            S: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('S', arguments);\r\n            },\r\n            C: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('C', arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'diff',\r\n            visible: true,\r\n            numargs: [1, 3],\r\n            build: function () {\r\n                return __.diff;\r\n            }\r\n        },\r\n        {\r\n            name: 'sum',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.sum;\r\n            }\r\n        },\r\n        {\r\n            name: 'product',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.product;\r\n            }\r\n        },\r\n        {\r\n            name: 'integrate',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.integrate;\r\n            }\r\n        },\r\n        {\r\n            name: 'defint',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.defint;\r\n            }\r\n        },\r\n        {\r\n            name: 'S',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.S;\r\n            }\r\n        },\r\n        {\r\n            name: 'C',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.C;\r\n            }\r\n        },\r\n        {\r\n            name: 'limit',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.Limit.limit;\r\n            }\r\n        }\r\n    ]);\r\n    //link registered functions externally\r\n    nerdamer.api();\r\n\r\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmVyZGFtZXIvQ2FsY3VsdXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92YW5pbGxhLWludGVncmF0aW9uLTJkLy4vbm9kZV9tb2R1bGVzL25lcmRhbWVyL0NhbGN1bHVzLmpzPzQwMTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIG1vZHVsZSAqL1xyXG5cclxuLypcclxuICogQXV0aG9yIDogTWFydGluIERvbmtcclxuICogV2Vic2l0ZSA6IGh0dHA6Ly93d3cubmVyZGFtZXIuY29tXHJcbiAqIEVtYWlsIDogbWFydGluLnIuZG9ua0BnbWFpbC5jb21cclxuICogU291cmNlIDogaHR0cHM6Ly9naXRodWIuY29tL2ppZ2d6c29uL25lcmRhbWVyXHJcbiAqL1xyXG5cclxuaWYoKHR5cGVvZiBtb2R1bGUpICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmVyZGFtZXIgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB2YXIgbmVyZGFtZXIgPSByZXF1aXJlKCcuL25lcmRhbWVyLmNvcmUuanMnKTtcclxuICAgIHJlcXVpcmUoJy4vQWxnZWJyYS5qcycpO1xyXG59XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIGNvcmUgPSBuZXJkYW1lci5nZXRDb3JlKCksXHJcbiAgICAgICAgICAgIF8gPSBjb3JlLlBBUlNFUixcclxuICAgICAgICAgICAgRnJhYyA9IGNvcmUuRnJhYyxcclxuICAgICAgICAgICAgU2V0dGluZ3MgPSBjb3JlLlNldHRpbmdzLFxyXG4gICAgICAgICAgICBpc1N5bWJvbCA9IGNvcmUuVXRpbHMuaXNTeW1ib2wsXHJcbiAgICAgICAgICAgIEZOID0gY29yZS5ncm91cHMuRk4sXHJcbiAgICAgICAgICAgIFN5bWJvbCA9IGNvcmUuU3ltYm9sLFxyXG4gICAgICAgICAgICB0ZXh0ID0gY29yZS5VdGlscy50ZXh0LFxyXG4gICAgICAgICAgICBpbkJyYWNrZXRzID0gY29yZS5VdGlscy5pbkJyYWNrZXRzLFxyXG4gICAgICAgICAgICBpc0ludCA9IGNvcmUuVXRpbHMuaXNJbnQsXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvcmUuVXRpbHMuZm9ybWF0LFxyXG4gICAgICAgICAgICBldmVuID0gY29yZS5VdGlscy5ldmVuLFxyXG4gICAgICAgICAgICBldmFsdWF0ZSA9IGNvcmUuVXRpbHMuZXZhbHVhdGUsXHJcbiAgICAgICAgICAgIE4gPSBjb3JlLmdyb3Vwcy5OLFxyXG4gICAgICAgICAgICBTID0gY29yZS5ncm91cHMuUyxcclxuICAgICAgICAgICAgRk4gPSBjb3JlLmdyb3Vwcy5GTixcclxuICAgICAgICAgICAgUEwgPSBjb3JlLmdyb3Vwcy5QTCxcclxuICAgICAgICAgICAgQ1AgPSBjb3JlLmdyb3Vwcy5DUCxcclxuICAgICAgICAgICAgQ0IgPSBjb3JlLmdyb3Vwcy5DQixcclxuICAgICAgICAgICAgRVggPSBjb3JlLmdyb3Vwcy5FWCxcclxuICAgICAgICAgICAgUCA9IGNvcmUuZ3JvdXBzLlAsXHJcbiAgICAgICAgICAgIExPRyA9IFNldHRpbmdzLkxPRyxcclxuICAgICAgICAgICAgRVhQID0gJ2V4cCcsXHJcbiAgICAgICAgICAgIEFCUyA9ICdhYnMnLFxyXG4gICAgICAgICAgICBTUVJUID0gJ3NxcnQnLFxyXG4gICAgICAgICAgICBTSU4gPSAnc2luJyxcclxuICAgICAgICAgICAgQ09TID0gJ2NvcycsXHJcbiAgICAgICAgICAgIFRBTiA9ICd0YW4nLFxyXG4gICAgICAgICAgICBTRUMgPSAnc2VjJyxcclxuICAgICAgICAgICAgQ1NDID0gJ2NzYycsXHJcbiAgICAgICAgICAgIENPVCA9ICdjb3QnLFxyXG4gICAgICAgICAgICBBU0lOID0gJ2FzaW4nLFxyXG4gICAgICAgICAgICBBQ09TID0gJ2Fjb3MnLFxyXG4gICAgICAgICAgICBBVEFOID0gJ2F0YW4nLFxyXG4gICAgICAgICAgICBBU0VDID0gJ2FzZWMnLFxyXG4gICAgICAgICAgICBBQ1NDID0gJ2Fjc2MnLFxyXG4gICAgICAgICAgICBBQ09UID0gJ2Fjb3QnLFxyXG4gICAgICAgICAgICBTSU5IID0gJ3NpbmgnLFxyXG4gICAgICAgICAgICBDT1NIID0gJ2Nvc2gnLFxyXG4gICAgICAgICAgICBUQU5IID0gJ3RhbmgnLFxyXG4gICAgICAgICAgICBDU0NIID0gJ2NzY2gnLFxyXG4gICAgICAgICAgICBTRUNIID0gJ3NlY2gnLFxyXG4gICAgICAgICAgICBDT1RIID0gJ2NvdGgnLFxyXG4gICAgICAgICAgICBBU0VDSCA9ICdhc2VjaCcsXHJcbiAgICAgICAgICAgIEFDU0NIID0gJ2Fjc2NoJyxcclxuICAgICAgICAgICAgQUNPVEggPSAnYWNvdGgnO1xyXG5cclxuICAgIC8vY3VzdG9tIGVycm9yc1xyXG4gICAgZnVuY3Rpb24gTm9JbnRlZ3JhbEZvdW5kKG1zZykge1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZyB8fCBcIlwiO1xyXG4gICAgfVxyXG4gICAgTm9JbnRlZ3JhbEZvdW5kLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xyXG5cclxuICAgIC8vUHJlcGFyYXRpb25zXHJcbiAgICBTeW1ib2wucHJvdG90eXBlLmhhc0ludGVncmFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zRnVuY3Rpb24oJ2ludGVncmF0ZScpO1xyXG4gICAgfTtcclxuICAgIC8vdHJhbnNmb3JtcyBhIGZ1bmN0aW9uXHJcbiAgICBTeW1ib2wucHJvdG90eXBlLmZuVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKHRoaXMuZ3JvdXAgIT09IEZOKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB2YXIgcmV0dmFsLCBhID0gdGhpcy5hcmdzWzBdO1xyXG4gICAgICAgIHZhciBtID0gbmV3IFN5bWJvbCh0aGlzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgIHZhciBzeW0gPSB0aGlzLmNsb25lKCkudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgIGlmKHRoaXMuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICBzd2l0Y2godGhpcy5mbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTSU5IOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoZV4oezB9KS1lXigtKHswfSkpKS8yJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDT1NIOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoZV4oezB9KStlXigtKHswfSkpKS8yJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUQU5IOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoZV4oezB9KS1lXigtKHswfSkpKS8oZV4oezB9KStlXigtKHswfSkpKScsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgVEFOOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCdzaW4oezB9KS9jb3MoezB9KScsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ1NDOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcxL3Npbih7MH0pJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTRUM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJzEvY29zKHswfSknLCBhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHN5bTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMucG93ZXIuZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCh0aGlzLmZuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFNJTjpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnMS8yLWNvcygyKih7MH0pKS8yJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDT1M6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJzEvMitjb3MoMiooezB9KSkvMicsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgVEFOOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJygxLWNvcygyKih7MH0pKSkvKDErY29zKDIqKHswfSkpKScsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnc2luKHswfSleMi9jb3MoezB9KV4yJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDT1NIOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcxLzIrY29zaCgyKih7MH0pKS8yJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTSU5IOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCctMS8yK2Nvc2goMiooezB9KSkvMicsIGEpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgVEFOSDpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKDErY29zaCgyKih7MH0pKSkvKC0xK2Nvc2goMiooezB9KSkpJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTRUM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJygxLWNvcygyKih7MH0pKSkvKDErY29zKDIqKHswfSkpKSsxJywgYSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBzeW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmZuYW1lID09PSBTRUMpIHtcclxuICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJzEvY29zKHswfSleKHsxfSknLCB0aGlzLmFyZ3NbMF0sIHRoaXMucG93ZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmZuYW1lID09PSBDU0MpIHtcclxuICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJzEvc2luKHswfSleKHsxfSknLCB0aGlzLmFyZ3NbMF0sIHRoaXMucG93ZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGlzLmZuYW1lID09PSBUQU4pIHtcclxuICAgICAgICAgICAgaWYodGhpcy5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJ2Nvcyh7MH0pXigtKHsxfSkpL3Npbih7MH0pXih7MX0pJywgdGhpcy5hcmdzWzBdLCB0aGlzLnBvd2VyLm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnc2luKHswfSleKHsxfSkvY29zKHswfSleKHsxfSknLCB0aGlzLmFyZ3NbMF0sIHRoaXMucG93ZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMuZm5hbWUgPT09IFNJTiAmJiB0aGlzLnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCdjc2MoezB9KV4oLSh7MX0pKScsIHRoaXMuYXJnc1swXSwgdGhpcy5wb3dlci5uZWdhdGUoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMuZm5hbWUgPT09IENPUyAmJiB0aGlzLnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCdzZWMoezB9KV4oLSh7MX0pKScsIHRoaXMuYXJnc1swXSwgdGhpcy5wb3dlci5uZWdhdGUoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHRoaXMuZm5hbWUgPT09IFNJTiAmJiB0aGlzLnBvd2VyLmVxdWFscygzKSkge1xyXG4gICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKDMqc2luKHswfSktc2luKDMqKHswfSkpKS80JywgdGhpcy5hcmdzWzBdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYodGhpcy5mbmFtZSA9PT0gQ09TICYmIHRoaXMucG93ZXIuZXF1YWxzKDMpKSB7XHJcbiAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoY29zKDMqKHswfSkpKzMqY29zKHswfSkpLzQnLCB0aGlzLmFyZ3NbMF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb3MoYSp4KV4oMipuKSBvciBzaW4oYSp4KV4oMipuKVxyXG4gICAgICAgIGVsc2UgaWYoKHRoaXMuZm5hbWUgPT09IENPUyB8fCB0aGlzLmZuYW1lID09PSBTSU4pICYmIGV2ZW4odGhpcy5wb3dlcikpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnBvd2VyIC8gMjtcclxuICAgICAgICAgICAgLy9jb252ZXJ0IHRvIGEgZG91YmxlIGFuZ2xlXHJcbiAgICAgICAgICAgIHZhciBkb3VibGVfYW5nbGUgPSBfLnBvdyh0aGlzLmNsb25lKCkudG9MaW5lYXIoKSwgXy5wYXJzZSgyKSkuZm5UcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgLy9yYWlzZSB0byB0aGUgbiBhbmQgZXhwYW5kXHJcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IF8uZXhwYW5kKF8ucG93KGRvdWJsZV9hbmdsZSwgXy5wYXJzZShuKSkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkLmVhY2goZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gcy5mblRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCB0KTtcclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dmFsID0gc3ltO1xyXG5cclxuICAgICAgICByZXR1cm4gXy5tdWx0aXBseShyZXR2YWwsIG0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBTeW1ib2wucHJvdG90eXBlLmhhc1RyaWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYodGhpcy5pc0NvbnN0YW50KHRydWUpIHx8IHRoaXMuZ3JvdXAgPT09IFMpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZih0aGlzLmZuYW1lICYmIChjb3JlLlV0aWxzLmluX3RyaWcodGhpcy5mbmFtZSkgfHwgY29yZS5VdGlscy5pbl9pbnZlcnNlX3RyaWcodGhpcy5mbmFtZSkpKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZih0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scylcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sc1t4XS5oYXNUcmlnKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgY29yZS5FeHByZXNzaW9uLnByb3RvdHlwZS5oYXNJbnRlZ3JhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2wuaGFzSW50ZWdyYWwoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIHJld3JpdGUgYSBzeW1ib2wgdW5kZXIgb25lIGNvbW1vbiBkZW5vbWluYXRvclxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbCBcclxuICAgICAqL1xyXG4gICAgY29yZS5VdGlscy50b0NvbW1vbkRlbm9taW5hdG9yID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgIC8vdHJhbnNmb3JtIHgvYSt4IC0+IChheCt4KS9hXHJcbiAgICAgICAgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkgJiYgc3ltYm9sLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgdmFyIG0gPSBuZXcgU3ltYm9sKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgdmFyIG51bWVyYXRvciA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBkZW5vbWluYXRvciA9IF8ubXVsdGlwbHkoZGVub21pbmF0b3IsIHguZ2V0RGVub20oKSk7XHJcbiAgICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy9yZW1vdmUgdGhlIGRlbm9taXRvciBpbiBlYWNoIHRlcm1cclxuICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBudW0gPSB4LmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlbiA9IHguZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBfLm11bHRpcGx5KG51bSwgXy5kaXZpZGUoZGVub21pbmF0b3IuY2xvbmUoKSwgZGVuKSk7XHJcbiAgICAgICAgICAgICAgICBudW1lcmF0b3IgPSBfLmFkZChudW1lcmF0b3IsIGZhY3Rvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gXy5tdWx0aXBseShtLCBjb3JlLkFsZ2VicmEuZGl2aWRlKF8uZXhwYW5kKG51bWVyYXRvciksIF8uZXhwYW5kKGRlbm9taW5hdG9yKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgfTtcclxuICAgIC8vQSBmdW5jdGlvbiB0byBjaGVjayBpZiBhIGZ1bmN0aW9uIG5hbWUgaXMgYW4gaW52ZXJzZSB0cmlnIGZ1bmN0aW9uXHJcbiAgICBjb3JlLlV0aWxzLmluX2ludmVyc2VfdHJpZyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgdmFyIGludl90cmlnX2ZucyA9IFtBU0lOLCBBQ09TLCBBVEFOLCBBQ1NDLCBBU0VDLCBBQ09UXTtcclxuICAgICAgICByZXR1cm4gaW52X3RyaWdfZm5zLmluZGV4T2YoeCkgIT09IC0xO1xyXG4gICAgfTtcclxuICAgIC8vQSBmdW5jdGlvbiB0byBjaGVjayBpZiBhIGZ1bmN0aW9uIG5hbWUgaXMgYSB0cmlnIGZ1bmN0aW9uXHJcbiAgICBjb3JlLlV0aWxzLmluX3RyaWcgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciB0cmlnX2ZucyA9IFtDT1MsIFNJTiwgVEFOLCBTRUMsIENTQywgQ09UXTtcclxuICAgICAgICByZXR1cm4gdHJpZ19mbnMuaW5kZXhPZih4KSAhPT0gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvcmUuVXRpbHMuaW5faHRyaWcgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciB0cmlnX2ZucyA9IFtTSU5ILCBDT1NILCBUQU5ILCBBQ1NDSCwgQVNFQ0gsIEFDT1RIXTtcclxuICAgICAgICByZXR1cm4gdHJpZ19mbnMuaW5kZXhPZih4KSAhPT0gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE1hdHJpeCBmdW5jdGlvbnNcclxuICAgIGNvcmUuTWF0cml4LmphY29iaWFuID0gZnVuY3Rpb24gKGVxbnMsIHZhcnMpIHtcclxuICAgICAgICB2YXIgamFjb2JpYW4gPSBuZXcgY29yZS5NYXRyaXgoKTtcclxuICAgICAgICAvL2dldCB0aGUgdmFyaWFibGVzIGlmIG5vdCBzdXBwbGllZFxyXG4gICAgICAgIGlmKCF2YXJzKSB7XHJcbiAgICAgICAgICAgIHZhcnMgPSBjb3JlLlV0aWxzLmFycmF5R2V0VmFyaWFibGVzKGVxbnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFycy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XHJcbiAgICAgICAgICAgIGVxbnMuZm9yRWFjaChmdW5jdGlvbiAoZXEsIGopIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gY29yZS5DYWxjdWx1cy5kaWZmKGVxLmNsb25lKCksIHYpO1xyXG4gICAgICAgICAgICAgICAgamFjb2JpYW4uc2V0KGosIGksIGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGphY29iaWFuO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb3JlLk1hdHJpeC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXggPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHguYWJzKCk7XHJcbiAgICAgICAgICAgIGlmKGUuZ3QobWF4KSlcclxuICAgICAgICAgICAgICAgIG1heCA9IGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG1heDtcclxuICAgIH07XHJcblxyXG4gICAgY29yZS5NYXRyaXguY01hdHJpeCA9IGZ1bmN0aW9uICh2YWx1ZSwgdmFycykge1xyXG4gICAgICAgIHZhciBtID0gbmV3IGNvcmUuTWF0cml4KCk7XHJcbiAgICAgICAgLy9tYWtlIGFuIGluaXRpYWwgZ3Vlc3NcclxuICAgICAgICB2YXJzLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcclxuICAgICAgICAgICAgbS5zZXQoaSwgMCwgXy5wYXJzZSh2YWx1ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgYWxsX2Z1bmN0aW9ucyA9IGNvcmUuVXRpbHMuYWxsX2Z1bmN0aW9ucyA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgaWYoYXJyW2ldLmdyb3VwICE9PSBGTilcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICAgICAgICAgIGNvc0FzaW5CdHJhbnNmb3JtID0gY29yZS5VdGlscy5jb3NBc2luQnRyYW5mb3JtID0gZnVuY3Rpb24gKHN5bWJvbDEsIHN5bWJvbDIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCBiO1xyXG4gICAgICAgICAgICAgICAgYSA9IHN5bWJvbDEuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIGIgPSBzeW1ib2wyLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJyhzaW4oKHswfSkrKHsxfSkpLXNpbigoezB9KS0oezF9KSkpLzInLCBhLCBiKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvc0FzaW5BdHJhbnNmb3JtID0gY29yZS5VdGlscy5jb3NBc2luQXRyYW5mb3JtID0gZnVuY3Rpb24gKHN5bWJvbDEsIHN5bWJvbDIpIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETzogdGVtcG9yYXJ5IGZpeCBmb3IgaW50ZWdyYXRlKGVeeCpzaW4oeCkqY29zKHgpXjIpLlxyXG4gICAgICAgICAgICAgICAgLy93ZSB0ZWNobmljYWxseSBrbm93IGhvdyB0byBkbyB0aGlzIHRyYW5zZm9ybSBidXQgbW9yZSBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgb3V0cHV0XHJcbiAgICAgICAgICAgICAgICBpZihOdW1iZXIoc3ltYm9sMi5wb3dlcikgIT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoc3ltYm9sMSwgc3ltYm9sMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgYTtcclxuICAgICAgICAgICAgICAgIGEgPSBzeW1ib2wxLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJyhzaW4oMiooezB9KSkpLzInLCBhKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNpbkFzaW5CdHJhbnNmb3JtID0gY29yZS5VdGlscy5jb3NBc2luQnRyYW5mb3JtID0gZnVuY3Rpb24gKHN5bWJvbDEsIHN5bWJvbDIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCBiO1xyXG4gICAgICAgICAgICAgICAgYSA9IHN5bWJvbDEuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIGIgPSBzeW1ib2wyLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJyhjb3MoKHswfSkrKHsxfSkpLWNvcygoezB9KS0oezF9KSkpLzInLCBhLCBiKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRyaWdUcmFuc2Zvcm0gPSBjb3JlLlV0aWxzLnRyaWdUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0ge30sIHN5bWJvbCwgdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gYXJyW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbmFtZSA9IHN5bWJvbC5mbmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZuYW1lID09PSBDT1MgJiYgbWFwW1NJTl0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtYXBbU0lOXS5hcmdzWzBdLnRvU3RyaW5nKCkgIT09IHN5bWJvbC5hcmdzWzBdLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gY29zQXNpbkJ0cmFuc2Zvcm0oc3ltYm9sLCBtYXBbU0lOXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gY29zQXNpbkF0cmFuc2Zvcm0oc3ltYm9sLCBtYXBbU0lOXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWFwW1NJTl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IFNJTiAmJiBtYXBbQ09TXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobWFwW0NPU10uYXJnc1swXS50b1N0cmluZygpICE9PSBzeW1ib2wuYXJnc1swXS50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNvc0FzaW5CdHJhbnNmb3JtKHN5bWJvbCwgbWFwW0NPU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGNvc0FzaW5BdHJhbnNmb3JtKHN5bWJvbCwgbWFwW0NPU10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtDT1NdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSBTSU4gJiYgbWFwW1NJTl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hcFtTSU5dLmFyZ3NbMF0udG9TdHJpbmcoKSAhPT0gc3ltYm9sLmFyZ3NbMF0udG9TdHJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBzaW5Bc2luQnRyYW5zZm9ybShzeW1ib2wsIG1hcFtTSU5dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWFwW1NJTl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RoaXMgc2hvdWxkIGFjdHVhbGx5IGJlIHJlZHVuZGFudCBjb2RlIGJ1dCBsZXQncyBwdXQganVzdCBpbiBjYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkoc3ltYm9sLCBtYXBbU0lOXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1hcFtTSU5dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBbZm5hbWVdID0gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9wdXQgYmFjayB0aGUgcmVtYWluaW5nIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIG1hcClcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgbWFwW3hdKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICBjb3JlLlNldHRpbmdzLmludGVncmF0aW9uX2RlcHRoID0gMTA7XHJcblxyXG4gICAgY29yZS5TZXR0aW5ncy5tYXhfbGltX2RlcHRoID0gMTA7XHJcblxyXG4gICAgdmFyIF9fID0gY29yZS5DYWxjdWx1cyA9IHtcclxuXHJcbiAgICAgICAgdmVyc2lvbjogJzEuNC42JyxcclxuXHJcbiAgICAgICAgc3VtOiBmdW5jdGlvbiAoZm4sIGluZGV4LCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgICAgIGlmKCEoaW5kZXguZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLlMpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5OZXJkYW1lclR5cGVFcnJvcignSW5kZXggbXVzdCBiZSBzeW1ib2wuICcgKyB0ZXh0KGluZGV4KSArICcgcHJvdmlkZWQnKTtcclxuICAgICAgICAgICAgaW5kZXggPSBpbmRleC52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc051bWVyaWNTeW1ib2woc3RhcnQpICYmIGNvcmUuVXRpbHMuaXNOdW1lcmljU3ltYm9sKGVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllciA9IGVuZCAtIHN0YXJ0IDwgMjAwID8gJycgOiAnUEFSU0UyTlVNQkVSJztcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGVuZCA9IE51bWJlcihlbmQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gY29yZS5VdGlscy5ibG9jayhtb2RpZmllciwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gZm4udGV4dCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicyA9IHsnfic6IHRydWV9LCAvL2xvY2sgc3Vicy4gSXMgdGhpcyBldmVuIGJlaW5nIHVzZWQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgY29yZS5TeW1ib2woMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNbaW5kZXhdID0gbmV3IFN5bWJvbChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFucyA9IF8ucGFyc2UoZiwgc3Vicyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgYW5zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignc3VtJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByb2R1Y3Q6IGZ1bmN0aW9uIChmbiwgaW5kZXgsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgaWYoIShpbmRleC5ncm91cCA9PT0gY29yZS5ncm91cHMuUykpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS5leGNlcHRpb25zLk5lcmRhbWVyVHlwZUVycm9yKCdJbmRleCBtdXN0IGJlIHN5bWJvbC4gJyArIHRleHQoaW5kZXgpICsgJyBwcm92aWRlZCcpO1xyXG4gICAgICAgICAgICBpbmRleCA9IGluZGV4LnZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICBpZihjb3JlLlV0aWxzLmlzTnVtZXJpY1N5bWJvbChzdGFydCkgJiYgY29yZS5VdGlscy5pc051bWVyaWNTeW1ib2woZW5kKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmaWVyID0gZW5kIC0gc3RhcnQgPCAyMDAgPyAnJyA6ICdQQVJTRTJOVU1CRVInO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gY29yZS5VdGlscy5ibG9jayhtb2RpZmllciwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBOdW1iZXIoZW5kLm11bHRpcGxpZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZuLnRleHQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnMgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBjb3JlLlN5bWJvbCgxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic1tpbmRleF0gPSBuZXcgU3ltYm9sKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgXy5wYXJzZShmLCBzdWJzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ3Byb2R1Y3QnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlmZjogZnVuY3Rpb24gKHN5bWJvbCwgd3J0LCBudGgpIHtcclxuICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc1ZlY3RvcihzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gbmV3IGNvcmUuVmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLmVsZW1lbnRzLnB1c2goX18uZGlmZih4LCB3cnQsIG50aCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoY29yZS5VdGlscy5pc01hdHJpeChzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0cml4ID0gbmV3IGNvcmUuTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaSwgaiwgX18uZGlmZih4LCB3cnQsIG50aCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZCA9IGlzU3ltYm9sKHdydCkgPyB3cnQudGV4dCgpIDogd3J0O1xyXG4gICAgICAgICAgICAvL3RoZSBudGggZGVyaXZhdGl2ZVxyXG4gICAgICAgICAgICBudGggPSBpc1N5bWJvbChudGgpID8gbnRoLm11bHRpcGxpZXIgOiBudGggfHwgMTtcclxuXHJcbiAgICAgICAgICAgIGlmKGQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGQgPSBjb3JlLlV0aWxzLnZhcmlhYmxlcyhzeW1ib2wpWzBdO1xyXG5cclxuICAgICAgICAgICAgLy91bndyYXAgc3FydFxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEZOICYmIHN5bWJvbC5mbmFtZSA9PT0gU1FSVCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzeW1ib2wuYXJnc1swXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3AgPSBzeW1ib2wucG93ZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIC8vdGhlc2UgZ3JvdXBzIGdvIHRvIHplcm8gYW55d2F5IHNvIHdoeSB3YXN0ZSB0aW1lP1xyXG4gICAgICAgICAgICAgICAgaWYocy5ncm91cCAhPT0gTiB8fCBzLmdyb3VwICE9PSBQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5wb3dlciA9IGlzU3ltYm9sKHMucG93ZXIpID8gXy5tdWx0aXBseShzLnBvd2VyLCBfLm11bHRpcGx5KG5ldyBTeW1ib2woMSAvIDIpKSwgc3ApIDogcy5wb3dlci5tdWx0aXBseShuZXcgRnJhYygwLjUpKS5tdWx0aXBseShzcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5tdWx0aXBsaWVyID0gcy5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEZOICYmICFpc1N5bWJvbChzeW1ib2wucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGRlcml2ZShfLnBhcnNlKHN5bWJvbCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBfXy5kaWZmKHN5bWJvbC5hcmdzWzBdLmNsb25lKCksIGQpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gXy5tdWx0aXBseShhLCBiKTsvL2NoYWluIHJ1bGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGRlcml2ZShzeW1ib2wpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihudGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBudGgtLTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF9fLmRpZmYoc3ltYm9sLCB3cnQsIG50aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcblxyXG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvIFwiZGVyaXZhdGl2ZSBvZiB0aGUgb3V0c2lkZVwiLlxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwb2x5ZGlmZihzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC52YWx1ZSA9PT0gZCB8fCBzeW1ib2wuY29udGFpbnMoZCwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IHN5bWJvbC5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnBvd2VyID0gc3ltYm9sLnBvd2VyLnN1YnRyYWN0KG5ldyBGcmFjKDEpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wucG93ZXIuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IFN5bWJvbChzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlcml2ZShzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gc3ltYm9sLmdyb3VwLCBhLCBiLCBjcDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihnID09PSBOIHx8IGcgPT09IFMgJiYgc3ltYm9sLnZhbHVlICE9PSBkIHx8IGcgPT09IFApIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBwb2x5ZGlmZihzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gc3ltYm9sLm11bHRpcGxpZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBfLm11bHRpcGx5KHByb2R1Y3RfcnVsZShzeW1ib2wpLCBwb2x5ZGlmZihzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwubXVsdGlwbGllciA9IHJldHZhbC5tdWx0aXBsaWVyLm11bHRpcGx5KG0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IEZOICYmIHN5bWJvbC5wb3dlci5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUYWJsZSBvZiBrbm93biBkZXJpdmF0aXZlc1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChzeW1ib2wuZm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBMT0c6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcCA9IHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLmFyZ3NbMF0uY2xvbmUoKTsvL2dldCB0aGUgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wucG93ZXIgPSBzeW1ib2wucG93ZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IGNwLm11bHRpcGxpZXIuZGl2aWRlKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPUzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29zIC0+IC1zaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5mbmFtZSA9IFNJTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU0lOOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zaW4gLT4gY29zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZm5hbWUgPSBDT1M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUQU46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RhbiAtPiBzZWNeMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmZuYW1lID0gU0VDO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnBvd2VyID0gbmV3IEZyYWMoMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTRUM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBjbG9uZSBpZiB0aGlzIGdpdmVzIGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gcWRpZmYoc3ltYm9sLCBUQU4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ1NDOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gcWRpZmYoc3ltYm9sLCAnLWNvdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ09UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmZuYW1lID0gQ1NDO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wucG93ZXIgPSBuZXcgRnJhYygyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFTSU46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCcoc3FydCgxLSgnICsgdGV4dChzeW1ib2wuYXJnc1swXSkgKyAnKV4yKSleKC0xKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQUNPUzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJy0oc3FydCgxLSgnICsgdGV4dChzeW1ib2wuYXJnc1swXSkgKyAnKV4yKSleKC0xKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQVRBTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJygxKygnICsgdGV4dChzeW1ib2wuYXJnc1swXSkgKyAnKV4yKV4oLTEpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBQlM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gc3ltYm9sLm11bHRpcGxpZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2RlcGVuZGluZyBvbiB0aGUgY29tcGxleGl0eSBvZiB0aGUgc3ltYm9sIGl0J3MgZWFzaWVyIHRvIGp1c3QgcGFyc2UgaXQgaW50byBhIG5ldyBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBzaG91bGQgcmVhbGx5IGJlIHJlYWRkcmVzc2VkIHNvb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBzeW1ib2wuYXJnc1swXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKGluQnJhY2tldHModGV4dChzeW1ib2wuYXJnc1swXSkpICsgJy9hYnMnICsgaW5CcmFja2V0cyh0ZXh0KGIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IG07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncGFyZW5zJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VlIHByb2R1Y3QgcnVsZTogZicuZyBnb2VzIHRvIHplcm8gc2luY2UgZicgd2lsbCByZXR1cm4gemVyby4gVGhpcyB3YXkgd2Ugb25seSBnZXQgYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8xKmcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29zaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Nvc2ggLT4gLXNpbmhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5mbmFtZSA9ICdzaW5oJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaW5oJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2luaCAtPiBjb3NoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZm5hbWUgPSAnY29zaCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUQU5IOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90YW5oIC0+IHNlY2heMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmZuYW1lID0gU0VDSDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5wb3dlciA9IG5ldyBGcmFjKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU0VDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIGNsb25lIGlmIHRoaXMgZ2l2ZXMgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBxZGlmZihzeW1ib2wsICctdGFuaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ1NDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBTdHJpbmcoc3ltYm9sLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoJy1jb3RoKCcgKyBhcmcgKyAnKSpjc2NoKCcgKyBhcmcgKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ09USDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBTdHJpbmcoc3ltYm9sLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoJy1jc2NoKCcgKyBhcmcgKyAnKV4yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXNpbmgnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnKHNxcnQoMSsoJyArIHRleHQoc3ltYm9sLmFyZ3NbMF0pICsgJyleMikpXigtMSknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhY29zaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCcoc3FydCgtMSsoJyArIHRleHQoc3ltYm9sLmFyZ3NbMF0pICsgJyleMikpXigtMSknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdGFuaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCcoMS0oJyArIHRleHQoc3ltYm9sLmFyZ3NbMF0pICsgJyleMileKC0xKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQVNFQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gU3RyaW5nKHN5bWJvbC5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJy0xLyhzcXJ0KDEvKCcgKyBhcmcgKyAnKV4yLTEpKignICsgYXJnICsgJyleMiknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFDT1RIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnLTEvKCgnICsgc3ltYm9sLmFyZ3NbMF0gKyAnKV4yLTEpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBQ1NDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBTdHJpbmcoc3ltYm9sLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnLTEvKHNxcnQoMS8oJyArIGFyZyArICcpXjIrMSkqKCcgKyBhcmcgKyAnKV4yKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQVNFQzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBTdHJpbmcoc3ltYm9sLmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnMS8oc3FydCgxLTEvKCcgKyBhcmcgKyAnKV4yKSooJyArIGFyZyArICcpXjIpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBQ1NDOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IFN0cmluZyhzeW1ib2wuYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCctMS8oc3FydCgxLTEvKCcgKyBhcmcgKyAnKV4yKSooJyArIGFyZyArICcpXjIpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBQ09UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnLTEvKCgnICsgc3ltYm9sLmFyZ3NbMF0gKyAnKV4yKzEpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gU3RyaW5nKHN5bWJvbC5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJ3NpbigocGkqKCcgKyBhcmcgKyAnKV4yKS8yKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0MnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IFN0cmluZyhzeW1ib2wuYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCdjb3MoKHBpKignICsgYXJnICsgJyleMikvMiknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdTaSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCdzaW4oJyArIGFyZyArICcpLygnICsgYXJnICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdTaGknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnc2luaCgnICsgYXJnICsgJykvKCcgKyBhcmcgKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NpJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBzeW1ib2wuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJ2NvcygnICsgYXJnICsgJykvKCcgKyBhcmcgKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NoaSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCdjb3NoKCcgKyBhcmcgKyAnKS8oJyArIGFyZyArICcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRWknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZSgnZV4oJyArIGFyZyArICcpLygnICsgYXJnICsgJyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdMaSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCcxLycgKyBTZXR0aW5ncy5MT0cgKyAnKCcgKyBhcmcgKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VyZic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKCcoMiplXigtKCcgKyBzeW1ib2wuYXJnc1swXSArICcpXjIpKS9zcXJ0KHBpKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0YW4yJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4XyA9IFN0cmluZyhzeW1ib2wuYXJnc1swXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlfID0gU3RyaW5nKHN5bWJvbC5hcmdzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJygnICsgeV8gKyAnKS8oKCcgKyB5XyArICcpXjIrKCcgKyB4XyArICcpXjIpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmMnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZShmb3JtYXQoJygoezB9KSpjb3MoezB9KS1zaW4oezB9KSkqKHswfSleKC0yKScsIHN5bWJvbC5hcmdzWzBdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTZXR0aW5ncy5MT0cxMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2UoJzEvKCgnICsgc3ltYm9sLmFyZ3NbMF0gKyAnKSonICsgU2V0dGluZ3MuTE9HICsgJygxMCkpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uc3ltZnVuY3Rpb24oJ2RpZmYnLCBbc3ltYm9sLCB3cnRdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IEVYIHx8IGcgPT09IEZOICYmIGlzU3ltYm9sKHN5bWJvbC5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZyA9PT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzeW1ib2wudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gRk4gJiYgc3ltYm9sLmNvbnRhaW5zKGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc3ltYm9sLmZuYW1lICsgaW5CcmFja2V0cyh0ZXh0KHN5bWJvbC5hcmdzWzBdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN5bWJvbC52YWx1ZSArIGluQnJhY2tldHModGV4dChzeW1ib2wuYXJnc1swXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhID0gXy5tdWx0aXBseShfLnBhcnNlKExPRyArIGluQnJhY2tldHModmFsdWUpKSwgc3ltYm9sLnBvd2VyLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBfXy5kaWZmKF8ubXVsdGlwbHkoXy5wYXJzZShMT0cgKyBpbkJyYWNrZXRzKHZhbHVlKSksIHN5bWJvbC5wb3dlci5jbG9uZSgpKSwgZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5tdWx0aXBseShzeW1ib2wsIGIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBGTiAmJiAhc3ltYm9sLnBvd2VyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBzeW1ib2wuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBiLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5tdWx0aXBseShwb2x5ZGlmZihzeW1ib2wuY2xvbmUoKSksIGRlcml2ZShiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IENQIHx8IGcgPT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogRG8gbm90IHVzZSBgcGFyc2VgIHNpbmNlIHRoaXMgcHV0cyBiYWNrIHRoZSBzcXJ0IGFuZCBjYXVzZXMgYSBidWcgYXMgaW4gIzYxMC4gVXNlIGNsb25lLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHN5bWJvbC5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uYWRkKHJlc3VsdCwgX18uZGlmZihzeW1ib2wuc3ltYm9sc1t4XS5jbG9uZSgpLCBkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ubXVsdGlwbHkocG9seWRpZmYoYyksIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnVwZGF0ZUhhc2goKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHFkaWZmKHN5bWJvbCwgdmFsLCBhbHRWYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHN5bWJvbCwgXy5wYXJzZSh2YWwgKyBpbkJyYWNrZXRzKGFsdFZhbCB8fCB0ZXh0KHN5bWJvbC5hcmdzWzBdKSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9kdWN0X3J1bGUoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAvL2dyYWIgYWxsIHRoZSBzeW1ib2xzIHdpdGhpbiB0aGUgQ0Igc3ltYm9sXHJcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9scyA9IHN5bWJvbC5jb2xsZWN0U3ltYm9scygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgU3ltYm9sKDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gc3ltYm9scy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAvL2xvb3Agb3ZlciBhbGwgdGhlIHN5bWJvbHNcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGYgPSBfXy5kaWZmKHN5bWJvbHNbaV0uY2xvbmUoKSwgZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NraXAgdGhlIHN5bWJvbCBvZiB3aGljaCB3ZSBqdXN0IHB1bGxlZCB0aGUgZGVyaXZhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpICE9PSBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL211bHRpcGx5IG91dCB0aGUgcmVtYWluaW5nIHN5bWJvbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRmID0gXy5tdWx0aXBseShkZiwgc3ltYm9sc1tqXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGUgZGVyaXZhdGl2ZSB0byB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5hZGQocmVzdWx0LCBkZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0OyAvL2RvbmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnRlZ3JhdGlvbjoge1xyXG4gICAgICAgICAgICB1X3N1YnN0aXR1dGlvbjogZnVuY3Rpb24gKHN5bWJvbHMsIGR4KSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0cnlfY29tYm8oYSwgYiwgZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gX18uZGlmZihiLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBmID8gZihhLCBiKSA6IF8uZGl2aWRlKGEuY2xvbmUoKSwgZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXEuY29udGFpbnMoZHgsIHRydWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRvX2ZuX3N1YihmbmFtZSwgYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YmJlZCA9IF9fLmludGVncmF0ZShfLnN5bWZ1bmN0aW9uKGZuYW1lLCBbbmV3IFN5bWJvbCh1KV0pLCB1LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBzdWJiZWQgPSBzdWJiZWQuc3ViKG5ldyBTeW1ib2wodSksIGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViYmVkLnVwZGF0ZUhhc2goKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViYmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhID0gc3ltYm9sc1swXS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gc3ltYm9sc1sxXS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnMSA9IGEuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gYi5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYXkgY2F1c2UgcHJvYmxlbXMgaWYgcGVyc29uIGlzIHVzaW5nIHRoaXMgYWxyZWFkeS4gV2lsbCBuZWVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG8gZmluZCBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjb25mbGljdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1ID0gJ19fdV9fJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUTtcclxuICAgICAgICAgICAgICAgIGlmKGcxID09PSBGTiAmJiBnMiAhPT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2UuZy4gMip4KmNvcyh4XjIpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGEuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBRID0gdHJ5X2NvbWJvKGIsIGFyZy5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihRKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShRLCBkb19mbl9zdWIoYS5mbmFtZSwgYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IHRyeV9jb21ibyhiLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihRKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcyID09PSBGTiAmJiBnMSAhPT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2UuZy4gMiooeCsxKSpjb3MoKHgrMSleMlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBiLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IHRyeV9jb21ibyhhLCBhcmcuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoUSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoUSwgZG9fZm5fc3ViKGIuZm5hbWUsIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnMSA9PT0gRk4gJiYgZzIgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IHRyeV9jb21ibyhhLmNsb25lKCksIGIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoUSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoX18uaW50ZWdyYXRpb24ucG9seV9pbnRlZ3JhdGUoYiksIFEpO1xyXG4gICAgICAgICAgICAgICAgICAgIFEgPSB0cnlfY29tYm8oYi5jbG9uZSgpLCBhLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKGIpLCBRKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZzEgPT09IEVYICYmIGcyICE9PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gYS5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICBRID0gdHJ5X2NvbWJvKGIsIHAuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIVEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmUgbW9yZSB0cnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRjID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhwLmNsb25lKCksIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zaWRlciB0aGUgcG9zc2liaWxpdHkgb2YgYV54XihuLTEpKnhebiBkeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeHAgPSBfXy5kaWZmKGRjWzJdLmNsb25lKCksIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRjMiA9IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcoeHAuY2xvbmUoKSwgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZWlyIHBvd2VycyBlcXVhbCwgc28gaWYgZHgqcCA9PSBiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKF8ubXVsdGlwbHkoZGNbMV0sIGRjMlsxXSkucG93ZXIuZXF1YWxzKGIucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IF8uZGl2aWRlKGRjWzBdLmNsb25lKCksIGRjMlswXS5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X3ZhbCA9IF8ubXVsdGlwbHkobS5jbG9uZSgpLCBfLnBvdyhuZXcgU3ltYm9sKGEudmFsdWUpLCBfLm11bHRpcGx5KGRjWzBdLCBuZXcgU3ltYm9sKHUpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3ZhbCA9IF8ubXVsdGlwbHkobmV3X3ZhbCwgbmV3IFN5bWJvbCh1KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uaW50ZWdyYXRpb24uYnlfcGFydHMobmV3X3ZhbCwgdSwgMCwge30pLnN1Yih1LCBkY1sxXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVncmF0ZWQgPSBfXy5pbnRlZ3JhdGUoYS5zdWIocC5jbG9uZSgpLCBuZXcgU3ltYm9sKHUpKSwgdSwgMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KGludGVncmF0ZWQuc3ViKG5ldyBTeW1ib2wodSksIHApLCBRKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcyID09PSBFWCAmJiBnMSAhPT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IGIucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgUSA9IHRyeV9jb21ibyhhLCBwLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhdGVkID0gX18uaW50ZWdyYXRlKGIuc3ViKHAsIG5ldyBTeW1ib2wodSkpLCB1LCAwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShpbnRlZ3JhdGVkLnN1YihuZXcgU3ltYm9sKHUpLCBwKSwgUSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGEuaXNDb21wb3NpdGUoKSB8fCBiLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gX18uZGlmZihiLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBBID0gY29yZS5BbGdlYnJhLkZhY3Rvci5mYWN0b3IoYSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQiA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IF8uZGl2aWRlKEEsIEIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmMSA9IGEuaXNDb21wb3NpdGUoKSA/IGEuY2xvbmUoKS50b0xpbmVhcigpIDogYS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZjIgPSBiLmlzQ29tcG9zaXRlKCkgPyBiLmNsb25lKCkudG9MaW5lYXIoKSA6IGIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBRID0gdHJ5X2NvbWJvKGYxLmNsb25lKCksIGYyLmNsb25lKCksIGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKGIpLCBRKTtcclxuICAgICAgICAgICAgICAgICAgICBRID0gdHJ5X2NvbWJvKGYyLmNsb25lKCksIGYxLmNsb25lKCksIGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKGEpLCBRKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy9zaW1wbGUgaW50ZWdyYXRpb24gb2YgYSBzaW5nbGUgcG9seW5vbWlhbCB4XihuKzEpLyhuKzEpXHJcbiAgICAgICAgICAgIHBvbHlfaW50ZWdyYXRlOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSB4LnBvd2VyLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB4Lm11bHRpcGxpZXIudG9EZWNpbWFsKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB4LnRvVW5pdE11bHRpcGxpZXIoKS50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgaWYoTnVtYmVyKHApID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KG5ldyBTeW1ib2wobSksIF8uc3ltZnVuY3Rpb24oTE9HLCBbc10pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnKHswfSkqKHsxfSleKCh7Mn0pKzEpLygoezJ9KSsxKScsIG0sIHMsIHApKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBqdXN0IHNwaW5uaW5nIHdoZWVscyB3ZSB3YW50IHRvIHN0b3AuIFRoaXMgaXMgd2h5IHdlIFxyXG4gICAgICAgICAgICAvL3dyYXAgaW50ZWdyYXRpb24gaW4gYSB0cnkgY2F0Y2ggYmxvY2sgYW5kIGNhbGwgdGhpcyB0byBzdG9wLlxyXG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAobXNnKSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgPSBtc2cgfHwgJ1VuYWJsZSB0byBjb21wdXRlIGludGVncmFsISc7XHJcbiAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLndhcm4obXNnKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb0ludGVncmFsRm91bmQobXNnKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFydGlhbF9mcmFjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBkeCwgZGVwdGgsIG9wdCkge1xyXG4gICAgICAgICAgICAgICAgLy9UT0RPOiBUaGlzIHdob2xlIHRoaW5nIG5lZWRzIHRvIGJlIHJvbGxlZCBpbnRvIG9uZSBidXQgZm9yIG5vdyBJJ2xsIGxlYXZlIGl0IGFzIHR3byBzZXBhcmF0ZSBwYXJ0c1xyXG4gICAgICAgICAgICAgICAgaWYoIWlzU3ltYm9sKGR4KSlcclxuICAgICAgICAgICAgICAgICAgICBkeCA9IF8ucGFyc2UoZHgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQsIHBhcnRpYWxfZnJhY3Rpb25zO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgIHBhcnRpYWxfZnJhY3Rpb25zID0gY29yZS5BbGdlYnJhLlBhcnRGcmFjLnBhcnRmcmFjKGlucHV0LCBkeCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYocGFydGlhbF9mcmFjdGlvbnMuZ3JvdXAgPT09IENCICYmIHBhcnRpYWxfZnJhY3Rpb25zLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3BlcmZvcm0gYSBxdWljayBjaGVjayB0byBtYWtlIHN1cmUgdGhhdCBhbGwgcGFydGlhbCBmcmFjdGlvbnMgYXJlIGxpbmVhclxyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxfZnJhY3Rpb25zLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXguaXNMaW5lYXIoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsX2ZyYWN0aW9ucy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uYWRkKHJlc3VsdCwgX18uaW50ZWdyYXRlKHgsIGR4LCBkZXB0aCwgb3B0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLmFkZChyZXN1bHQsIF9fLmludGVncmF0ZShwYXJ0aWFsX2ZyYWN0aW9ucywgZHgsIGRlcHRoLCBvcHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldF91ZHY6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IFtbLypMKi9dLCBbLypJKi9dLCBbLypBKi9dLCBbLypUKi9dLCBbLypFKi9dXTtcclxuICAgICAgICAgICAgICAgIC8vZmlyc3Qgd2Ugc29ydCB0aGVtIFxyXG4gICAgICAgICAgICAgICAgdmFyIHNldFN5bWJvbCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSB4Lmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGcgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbmFtZSA9IHguZm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMuaW5fdHJpZyhmbmFtZSkgfHwgY29yZS5VdGlscy5pbl9odHJpZyhmbmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1szXS5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNvcmUuVXRpbHMuaW5faW52ZXJzZV90cmlnKGZuYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWzFdLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IExPRylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzWzBdLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gUyB8fCB4LmlzQ29tcG9zaXRlKCkgJiYgeC5pc0xpbmVhcigpIHx8IGcgPT09IENCICYmIHguaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1syXS5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IEVYIHx8IHguaXNDb21wb3NpdGUoKSAmJiAheC5pc0xpbmVhcigpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1s0XS5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENCKVxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFN5bWJvbChTeW1ib2wudW53cmFwU1FSVCh4LCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U3ltYm9sKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdSwgZHYgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgLy9jb21waWxlIHUgYW5kIGR2XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXSwgdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBwYXJ0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZihsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihsID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbDsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLm11bHRpcGx5KHQsIHBhcnRbal0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHBhcnRbMF0uY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdDsvL3RoZSBmaXJzdCB1IGVuY291bnRlcmVkIGdldHMgY2hvc2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1Lm11bHRpcGxpZXIgPSB1Lm11bHRpcGxpZXIubXVsdGlwbHkoc3ltYm9sLm11bHRpcGxpZXIpOyAvL3RoZSBmaXJzdCBvbmUgZ2V0cyB0aGUgbXV0bGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR2ID0gXy5tdWx0aXBseShkdiwgdCk7IC8vZXZlcnl0aGluZyBlbHNlIGJlbG9uZ3MgdG8gZHZcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1LCBkdl07XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICB0cmlnX3N1YjogZnVuY3Rpb24gKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQsIHBhcnRzLCBzeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IHBhcnRzIHx8IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcoc3ltYm9sLmNsb25lKCkudG9MaW5lYXIoKSwgZHgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBwYXJ0c1szXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXggPSBwYXJ0c1syXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHBhcnRzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcGFydHNbMV07XHJcbiAgICAgICAgICAgICAgICBpZih4LnBvd2VyLmVxdWFscygyKSAmJiBhLmdyZWF0ZXJUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy91c2UgdGFuKHgpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBjb3JlLlV0aWxzLmdldFUoc3ltYm9sKSwgLy9nZXQgYW4gYXBwcm9wcmlhdGUgdVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IF8ucGFyc2UoVEFOICsgaW5CcmFja2V0cyh0KSksIC8vdVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHUgPSBfLnBhcnNlKFNFQyArIGluQnJhY2tldHModCkgKyAnXjInKSwgLy9kdVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IF8ubXVsdGlwbHkoc3ltYm9sLnN1Yih4LCB1KSwgZHUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhbCA9IF9fLmludGVncmF0ZShmLCB0LCBkZXB0aCwgb3B0KS5zdWIodSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29yZS5VdGlscy5jbGVhclUodSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVncmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgYnlfcGFydHM6IGZ1bmN0aW9uIChzeW1ib2wsIGR4LCBkZXB0aCwgbykge1xyXG4gICAgICAgICAgICAgICAgby5wcmV2aW91cyA9IG8ucHJldmlvdXMgfHwgW107XHJcbiAgICAgICAgICAgICAgICB2YXIgdWR2LCB1LCBkdiwgZHUsIHYsIHZkdSwgdXYsIHJldHZhbCwgaW50ZWdyYWxfdmR1LCBtLCBjLCB2ZHVfcztcclxuICAgICAgICAgICAgICAgIC8vZmlyc3QgTElBVEVcclxuICAgICAgICAgICAgICAgIHVkdiA9IF9fLmludGVncmF0aW9uLmdldF91ZHYoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIHUgPSB1ZHZbMF07XHJcbiAgICAgICAgICAgICAgICBkdiA9IHVkdlsxXTtcclxuICAgICAgICAgICAgICAgIGR1ID0gU3ltYm9sLnVud3JhcFNRUlQoXy5leHBhbmQoX18uZGlmZih1LmNsb25lKCksIGR4KSksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgYyA9IGR1LmNsb25lKCkuc3RyaXBWYXIoZHgpO1xyXG4gICAgICAgICAgICAgICAgLy9zdHJpcCBhbnkgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgICAgICBkdSA9IF8uZGl2aWRlKGR1LCBjLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgdiA9IF9fLmludGVncmF0ZShkdi5jbG9uZSgpLCBkeCwgZGVwdGggfHwgMCk7XHJcbiAgICAgICAgICAgICAgICB2ZHUgPSBfLm11bHRpcGx5KHYuY2xvbmUoKSwgZHUpO1xyXG4gICAgICAgICAgICAgICAgdmR1X3MgPSB2ZHUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgZV54Kihzb21lIHRyaWcpXHJcbiAgICAgICAgICAgICAgICBpZihvLnByZXZpb3VzLmluZGV4T2YodmR1X3MpICE9PSAtMSAmJiAoY29yZS5VdGlscy5pbl90cmlnKHUuZm5hbWUpKSAmJiBkdi5pc0UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vV2UncmUgZ29pbmcgdG8gZXhwbG9pdCB0aGUgZmFjdCB0aGF0IHZkdSBjYW4gbmV2ZXIgYmUgY29uc3RhbnRcclxuICAgICAgICAgICAgICAgICAgICAvL3RvIHdvcmsgb3V0IHdheSBvdXQgb2YgdGhpcyBjeWNsZS4gV2UnbGwgcmV0dXJuIHRoZSBsZW5ndGggb2ZcclxuICAgICAgICAgICAgICAgICAgICAvL3RoZSB0aGlzLnByZXZpb3VzIGFycmF5IHVudGlsIHdlJ3JlIGJhY2sgYXQgbGV2ZWwgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgby5pc19jeWNsaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRoZSBpbnRlZ3JhbC4gXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgby5wcmV2aW91cy5wdXNoKHZkdV9zKTtcclxuXHJcbiAgICAgICAgICAgICAgICB1diA9IF8ubXVsdGlwbHkodSwgdik7XHJcbiAgICAgICAgICAgICAgICAvL2NsZWFyIHRoZSBtdWx0aXBsaWVyIHNvIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGJhcmUgaW50ZWdyYWxcclxuICAgICAgICAgICAgICAgIG0gPSB2ZHUubXVsdGlwbGllci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdmR1LnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIGludGVncmFsX3ZkdSA9IF8ubXVsdGlwbHkoX18uaW50ZWdyYXRlKHZkdS5jbG9uZSgpLCBkeCwgZGVwdGgsIG8pLCBjKTtcclxuICAgICAgICAgICAgICAgIGludGVncmFsX3ZkdS5tdWx0aXBsaWVyID0gaW50ZWdyYWxfdmR1Lm11bHRpcGxpZXIubXVsdGlwbHkobSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN1YnRyYWN0KHV2LCBpbnRlZ3JhbF92ZHUpO1xyXG4gICAgICAgICAgICAgICAgLy93ZSBrbm93IHRoYXQgdGhlcmUgY2Fubm90IGJlIGNvbnN0YW50cyBzbyB0aGV5J3JlIGEgaG9sZG92ZXIgZnJvbSBhIGN5Y2xpYyBpbnRlZ3JhbFxyXG4gICAgICAgICAgICAgICAgaWYoby5pc19jeWNsaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3N0YXJ0IHBvcHBpbmcgdGhlIHByZXZpb3VzIHN0YWNrIHNvIHdlIGtub3cgaG93IGRlZXAgaW4gd2UgYXJlXHJcbiAgICAgICAgICAgICAgICAgICAgby5wcmV2aW91cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihvLnByZXZpb3VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmV4cGFuZChyZXR2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF4LmNvbnRhaW5zKGR4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBfLmFkZChyZW0sIHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgYWN0dWFsIHV2XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKF8uc3VidHJhY3QocmV0dmFsLCByZW0uY2xvbmUoKSksIF8uc3VidHJhY3QobmV3IFN5bWJvbCgxKSwgcmVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIGRlcGVuZGVudHM6IFtTb2x2ZSwgaW50ZWdyYXRlXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZGVjb21wb3NlX2FyZzogY29yZS5VdGlscy5kZWNvbXBvc2VfZm5cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vVE9ETzogbmVyZGFtZXIuaW50ZWdyYXRlKCctZV4oLWEqdCkqc2luKHQpJywgJ3QnKSAtPiBnaXZlcyBpbmNvcnJlY3Qgb3V0cHV0XHJcbiAgICAgICAgaW50ZWdyYXRlOiBmdW5jdGlvbiAob3JpZ2luYWxfc3ltYm9sLCBkdCwgZGVwdGgsIG9wdCkge1xyXG4gICAgICAgICAgICAvL2Fzc3VtZSBpbnRlZ3JhdGlvbiB3cnQgaW5kZXBlbmRlbnQgdmFyaWFibGUgaWYgZXhwcmVzc2lvbiBvbmx5IGhhcyBvbmUgdmFyaWFibGVcclxuICAgICAgICAgICAgaWYoIWR0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFycyA9IGNvcmUuVXRpbHMudmFyaWFibGVzKG9yaWdpbmFsX3N5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICBpZih2YXJzLmxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICBkdCA9IHZhcnNbMF07XHJcbiAgICAgICAgICAgICAgICAvL2RlZmF1bHRzIHRvIHhcclxuICAgICAgICAgICAgICAgIGR0ID0gZHQgfHwgJ3gnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vYWRkIHN1cHBvcnQgZm9yIGludGVncmF0aW5nIHZlY3RvcnNcclxuICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc1ZlY3RvcihvcmlnaW5hbF9zeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gbmV3IGNvcmUuVmVjdG9yKFtdKTtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsX3N5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLmVsZW1lbnRzLnB1c2goX18uaW50ZWdyYXRlKHgsIGR0KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIWlzTmFOKGR0KSlcclxuICAgICAgICAgICAgICAgIF8uZXJyb3IoJ3ZhcmlhYmxlIGV4cGVjdGVkIGJ1dCByZWNlaXZlZCAnICsgZHQpO1xyXG4gICAgICAgICAgICAvL2dldCByaWQgb2YgY29uc3RhbnRzIHJpZ2h0IGF3YXlcclxuICAgICAgICAgICAgaWYob3JpZ2luYWxfc3ltYm9sLmlzQ29uc3RhbnQodHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShvcmlnaW5hbF9zeW1ib2wuY2xvbmUoKSwgXy5wYXJzZShkdCkpO1xyXG5cclxuICAgICAgICAgICAgLy9jb25maWd1cmF0aW9ucyBvcHRpb25zIGZvciBpbnRlZ3JhbC4gVGhpcyBpcyBuZWVkZWQgZm9yIHRyYWNraW5nIGV4dHJhIG9wdGlvbnNcclxuICAgICAgICAgICAgLy9lLmcuIGN5Y2xpYyBpbnRlZ3JhbHMgb3IgYWRkaXRpb25hbCBzZXR0aW5nc1xyXG4gICAgICAgICAgICBvcHQgPSBvcHQgfHwge307XHJcbiAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvL21ha2UgYSBub3RlIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wuIFNldCBvbmx5IGlmIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgZGVwdGggPSBkZXB0aCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gaXNTeW1ib2woZHQpID8gZHQudG9TdHJpbmcoKSA6IGR0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGRvbid0IHdhbnQgdGhlIHN5bWJvbCBpbiBzcXJ0IGZvcm0uIHheKDEvMikgaXMgcHJlZmVyZXJyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gU3ltYm9sLnVud3JhcFNRUlQob3JpZ2luYWxfc3ltYm9sLmNsb25lKCksIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gc3ltYm9sLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWw7XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvL1dlIHN0b3AgaW50ZWdyYXRpb24gYWZ0ZXIgeCBhbW91bnQgb2YgcmVjdXJzaXZlIGNhbGxzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoKytkZXB0aCA+IGNvcmUuU2V0dGluZ3MuaW50ZWdyYXRpb25fZGVwdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoJ01heGltdW0gZGVwdGggcmVhY2hlZC4gRXhpdGluZyEnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdGFudHMuIFdlIGZpcnN0IGVsaW1pbmF0ZSBhbnl0aGluZyB0aGF0IGRvZXNuJ3QgaGF2ZSBkeC4gRXZlcnl0aGluZyBhZnRlciB0aGlzIGhhcyBcclxuICAgICAgICAgICAgICAgICAgICAvL3RvIGhhdmUgZHggb3IgZWxzZSBpdCB3b3VsZCBoYXZlIGJlZW4gdGFrZW4gY2FyZSBvZiBiZWxvd1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzeW1ib2wuY29udGFpbnMoZHgsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoc3ltYm9sLmNsb25lKCksIF8ucGFyc2UoZHgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9lLmcuIDIqeFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShzeW1ib2wsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLnByZXZpb3VzR3JvdXAgPT09IEZOICYmICEoc3ltYm9sLmZuYW1lID09PSAnc3FydCcgfHwgc3ltYm9sLmZuYW1lID09PSBTZXR0aW5ncy5QQVJFTlRIRVNJUykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgdGhlIGJhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmNvbnRhaW5zKGR4KSAmJiBzeW1ib2wucHJldmlvdXNHcm91cCAhPT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIHN5bWJvbCBhbHNvIGNvbnRhaW5zIGR4IHRoZW4gd2Ugc3RvcCBzaW5jZSB3ZSBjdXJyZW50bHkgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Rvbid0IGtub3cgd2hhdCB0byBkbyB3aXRoIGl0IGUuZy4geF54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wucG93ZXIuY29udGFpbnMoZHgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gX18uZGlmZihzeW1ib2wuY2xvbmUoKS50b0xpbmVhcigpLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodC5jb250YWlucyhkeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NpbmNlIGF0IHRoaXMgcG9pbnQgaXQncyB0aGUgYmFzZSBvbmx5IHRoZW4gd2UgZG8gc3RhbmRhcmQgc2luZ2xlIHBvbHkgaW50ZWdyYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2UuZy4geF55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24ucG9seV9pbnRlZ3JhdGUoc3ltYm9sLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZS5nLiBhXnggb3IgOV54XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBfXy5kaWZmKHN5bWJvbC5wb3dlci5jbG9uZSgpLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihhLmNvbnRhaW5zKGR4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYSA9IGEuc3RyaXBWYXIoZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IF8uZGl2aWRlKGEuY2xvbmUoKSwgYWEuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gUyAmJiB4LmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWEubXVsdGlwbGllciA9IGFhLm11bHRpcGxpZXIuZGl2aWRlKG5ldyBGcmFjKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcoezJ9KSooc3FydChwaSkqZXJmKHNxcnQoLXswfSkqezF9KSkvKDIqc3FydCgtezB9KSknLCBhYSwgZHgsIHN5bWJvbC5tdWx0aXBsaWVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzRSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5pc0xpbmVhcigpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEuaXNFKCkgJiYgYS5wb3dlci5ncm91cCA9PT0gUyAmJiBhLnBvd2VyLnBvd2VyLmVxdWFscygxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoXy5zeW1mdW5jdGlvbignRWknLCBbc3ltYm9sLnBvd2VyLmNsb25lKCldKSwgc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gXy5zeW1mdW5jdGlvbihMT0csIFtfLnBhcnNlKHN5bWJvbC52YWx1ZSldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShzeW1ib2wsIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUocmV0dmFsLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpICYmIHN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gXy5wYXJzZShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9fLmludGVncmF0ZSh4LCBkeCwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkobSwgcmV0dmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wucG93ZXIuZ3JlYXRlclRoYW4oMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wucG93ZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9fLmludGVncmF0ZSh4LCBkeCwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOdW1iZXIoc3ltYm9sLnBvd2VyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHN5bWJvbC5tdWx0aXBsaWVyLmNsb25lKCk7Ly90ZW1wb3JhcmlseSByZW1vdmUgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLy9iZWxvdyB3ZSBjb25zaWRlciB0aGUgZm9ybSBheCtiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gc3ltYm9sLmNsb25lKCkudG9MaW5lYXIoKSwgLy9nZXQganVzdCB0aGUgcHVyZSBmdW5jdGlvbiB3aXRob3V0IHRoZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXAgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKGZuLCBkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSSBoYXZlIG5vIGlkZWEgd2h5IEkgdXNlZCBieCthIGFuZCBub3QgYXgrYi4gVE9ETyBjaGFuZ2UgdGhpcyB0byBzb21ldGhpbmcgdGhhdCBtYWtlcyBzZW5zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gZGVjb21wWzNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheCA9IGRlY29tcFsyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGRlY29tcFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRlY29tcFsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHAgPT09IC0xICYmIHguZ3JvdXAgIT09IFBMICYmIHgucG93ZXIuZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJfaXNfcG9zaXRpdmUgPSBpc0ludChiKSA/IGIgPiAwIDogdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGNhbiBub3cgY2hlY2sgZm9yIGF0YW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4Lmdyb3VwID09PSBTICYmIHgucG93ZXIuZXF1YWxzKDIpICYmIGJfaXNfcG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL3RoZW4gd2UgaGF2ZSBhdGFuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWJzIGlzIHJlZHVuZGFudHMgc2luY2UgdGhlIHNpZ24gYXBwZWFycyBpbiBib3RoIGRlbm9tIGFuZCBudW0uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bndyYXBBYnMgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLm11bHRpcGx5KHJlc3VsdCwgeC5mbmFtZSA9PT0gJ2FicycgPyB4LmFyZ3NbMF0gOiB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEEgPSBhLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQiA9IGIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQSA9IF8ucG93KEEsIG5ldyBTeW1ib2woMSAvIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQiA9IF8ucG93KEIsIG5ldyBTeW1ib2woMSAvIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91bndyYXAgYWJzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IF8ubXVsdGlwbHkodW53cmFwQWJzKEIpLCB1bndyYXBBYnMoQSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBfLnN5bWZ1bmN0aW9uKEFUQU4sIFtfLmRpdmlkZShfLm11bHRpcGx5KGEsIHgudG9MaW5lYXIoKSksIGQuY2xvbmUoKSldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUoZiwgZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoeC5ncm91cCA9PT0gUyAmJiB4LmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUoX18uaW50ZWdyYXRpb24ucG9seV9pbnRlZ3JhdGUoc3ltYm9sKSwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLzEvKHheNCsxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4LnBvd2VyLmVxdWFscyg0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL3d3dy5mcmVlbWF0aGhlbHAuY29tL2ZvcnVtL3RocmVhZHMvNTU2NzgtZGlmZmljdWx0LWludGVncmF0aW9uLWludC0xLSgxLXgtNCktZHhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBBLCBCLCBDLCBELCBFLCBGLCBmMSwgZjIsIGYzLCBmNCwgTDEsIEwyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJyID0gaW5CcmFja2V0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgcnVsZTogYXheNCtiID0gKOKImmF4XjIr4oiaMuKInGHiiJxieCviiJpiKSjiiJpheF4yLeKImjLiiJxh4oicYngr4oiaYilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHF1YWRyYXRpYyBmYWN0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBID0gXy5wYXJzZShTUVJUICsgYnIoYSkgKyAnKicgKyBkeCArICdeMicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQiA9IF8ucGFyc2UoU1FSVCArIGJyKDIpICsgJyonICsgYnIoYSkgKyAnXicgKyBicignMS80JykgKyAnKicgKyBicihiKSArICdeJyArIGJyKCcxLzQnKSArICcqJyArIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEMgPSBfLnBhcnNlKFNRUlQgKyBicihiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmMSA9IF8uYWRkKF8uYWRkKEEuY2xvbmUoKSwgQi5jbG9uZSgpKSwgQy5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYyID0gXy5hZGQoXy5zdWJ0cmFjdChBLCBCKSwgQyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSBudW1lcmF0b3JzOiBbRCtFLCBELUVdIC0+IFviiJoyKmJeKDMvNCkr4oiaYuKInGF4LCDiiJoyKmJeKDMvNCkt4oiaYuKInGF4XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRCA9IF8ucGFyc2UoU1FSVCArIGJyKDIpICsgJyonICsgYnIoYikgKyAnXicgKyBicignMy80JykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRSA9IF8ucGFyc2UoU1FSVCArIGJyKGIpICsgJyonICsgYnIoYikgKyAnXicgKyBicignMS80JykgKyAnKicgKyBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xldCBGID0gMmLiiJoy4oicYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRiA9IF8ucGFyc2UoMiArICcqJyArIGJyKGIpICsgJyonICsgU1FSVCArIGJyKDIpICsgJyonICsgYnIoYikgKyAnXicgKyBicignMS80JykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxjdWxhdGUgdGhlIGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwxID0gXy5kaXZpZGUoXy5zdWJ0cmFjdChELmNsb25lKCksIEUuY2xvbmUoKSksIF8ubXVsdGlwbHkoRi5jbG9uZSgpLCBmMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTDIgPSBfLmRpdmlkZShfLmFkZChELCBFKSwgXy5tdWx0aXBseShGLCBmMS5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRlKEwxLCBkeCwgZGVwdGgsIG9wdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0ZShMMiwgZHgsIGRlcHRoLCBvcHQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQncyB0cnkgcGFydGlhbCBmcmFjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBhcnRpYWxfZnJhY3Rpb24oc3ltYm9sLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYocCA9PT0gLTEgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3QgYXNpbiBhbmQgYXRhblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IFMgJiYgeC5wb3dlci5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXgubXVsdGlwbGllci5sZXNzVGhhbigwKSAmJiAhYi5tdWx0aXBsaWVyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pdCdzIGFzaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIuaXNDb25zdGFudCgpICYmIGEuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfLnN5bWZ1bmN0aW9uKFNRUlQsIFthLmNsb25lKCldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gXy5zeW1mdW5jdGlvbihTUVJULCBbXy5tdWx0aXBseShhLmNsb25lKCksIGIpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUoXy5zeW1mdW5jdGlvbihBU0lOLCBbXy5kaXZpZGUoYXgudG9MaW5lYXIoKSwgZDIpXSksIGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JJ20gbm90IHN1cmUgYWJvdXQgdGhpcyBvbmUuIEknbSB0cnVzdGluZyBXb2xmcmFtIEFscGhhIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcXJ0X2EgPSBfLnN5bWZ1bmN0aW9uKFNRUlQsIFthXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcXJ0X2F4ID0gXy5tdWx0aXBseShzcXJ0X2EuY2xvbmUoKSwgeC5jbG9uZSgpLnRvTGluZWFyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKF8uc3ltZnVuY3Rpb24oQVRBTiwgW18uZGl2aWRlKHNxcnRfYXgsIF8uc3ltZnVuY3Rpb24oU1FSVCwgW2ZuLmNsb25lKCldKSldKSwgc3FydF9hKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qV0hBVCBIQVBQRU5TIEhFUkU/Pz8/IGUuZy4gaW50ZWdyYXRlKDMvc3FydCgtYStiKnheMikseCkgb3IgaW50ZWdyYXRlKDMvc3FydChhK2IqeF4yKSx4KSovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhpcyB3b3VsZCBiZSBhIGNhc2UgbGlrZSAxLyhzcXJ0KDEteF4zKSBvciAxLygxLSh4KzEpXjIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4LmlzTGluZWFyKCkgJiYgeC5ncm91cCAhPT0gUEwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKHN5bWJvbCksIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoeC5wb3dlci5lcXVhbHMoMikgJiYgYS5ncmVhdGVyVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3FhLCBzcWIsIGFvYiwgYnNxaSwgbiwgaW50ZWdyYWwsIHUsIHYsIHV2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLzEvKGEqeF4yK2JeMileblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N0cmlwIHRoZSB2YWx1ZSBvZiBiIHNvIGIgPSAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxYSA9IF8ucGFyc2UoU1FSVCArIGluQnJhY2tldHMoYSkpOyAvL3N0cmlwIGEgc28gYiA9IDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3FiID0gXy5wYXJzZShTUVJUICsgaW5CcmFja2V0cyhiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFvYiA9IF8ubXVsdGlwbHkoc3FhLmNsb25lKCksIHNxYi5jbG9uZSgpKS5pbnZlcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnNxaSA9IF8ucG93KGIsIG5ldyBTeW1ib2woc3ltYm9sLnBvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV2ID0gY29yZS5VdGlscy5nZXRVKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBfLm11bHRpcGx5KGFvYiwgeC5jbG9uZSgpLnRvTGluZWFyKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gXy5wYXJzZShBVEFOICsgaW5CcmFja2V0cyh1KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGNvbnZlcnNpb24gd2lsbCBiZSAxK3Rhbih4KV4yIC0+IHNlYyh4KV4yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2luY2UgdGhlIGRlbm9taW5hdG9yIGlzIG5vdyAoc2VjKHgpXjIpXm4gYW5kIHRoZSBudW1lcmF0b3IgaXMgc2VjKHgpXjIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlbiB0aGUgcmVtYWluaW5nIHNlYyB3aWxsIGJlIChuLTEpKjI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gKE1hdGguYWJzKHN5bWJvbC5wb3dlcikgLSAxKSAqIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vMS9zZWMoeClebiBjYW4gbm93IGJlIGNvbnZlcnRlZCB0byBjb3MoeClebiBhbmQgd2UgY2FuIHB1bGwgdGhlIGludGVncmFsIG9mIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVncmFsID0gX18uaW50ZWdyYXRlKF8ucGFyc2UoQ09TICsgaW5CcmFja2V0cyh1dikgKyAnXicgKyBuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuVXRpbHMuY2xlYXJVKHV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoaW50ZWdyYWwuc3ViKHV2LCB2KSwgYnNxaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgIT09IENCICYmICFzeW1ib2wucG93ZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBzeW1ib2wuY2xvbmUoKS50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvcmVkID0gY29yZS5BbGdlYnJhLkZhY3Rvci5mYWN0b3IoZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2FzX2ZhY3RvcmVkID0gZmFjdG9yZWQudG9TdHJpbmcoKSAhPT0gZi50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5BbGdlYnJhLmRlZ3JlZShmLCBfLnBhcnNlKGR4KSkuZXF1YWxzKDIpICYmICF3YXNfZmFjdG9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZjEsIGZ4LCB1LCBzcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3EgPSBjb3JlLkFsZ2VicmEuc3FDb21wbGV0ZShmLCBkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBjb3JlLlV0aWxzLmdldFUoZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYxID0gc3EuZi5zdWIoc3EuYSwgdSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ4ID0gXy5wb3coZjEsIF8ucGFyc2Uoc3ltYm9sLnBvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShmeCwgdSkuc3ViKHUsIHNxLmEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24ucGFydGlhbF9mcmFjdGlvbihzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbC5tdWx0aXBsaWVyID0gcmV0dmFsLm11bHRpcGxpZXIubXVsdGlwbHkobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHN5bWJvbC5tdWx0aXBsaWVyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNvbXAgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKGFyZywgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Vhc2llcyB3YXkgSSBjYW4gdGhpbmsgb2YgdG8gZ2V0IHRoZSBjb2VmZmljaWVudCBhbmQgdG8gbWFrZSBzdXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhhdCB0aGUgc3ltYm9sIGlzIGxpbmVhciB3cnQgZHguIEknbSBub3QgYWN0dWFsbHkgdHJ5aW5nIHRvIGdldCB0aGUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVyaXZhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGRlY29tcFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZGVjb21wWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuYW1lID0gc3ltYm9sLmZuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvZyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IGNhbiBiZSBoYW5kbGVkIHdpdGggaW50ZWdyYXRpb24gYnkgcGFydHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZm5hbWUgPT09IExPRyB8fCAoZm5hbWUgPT09IEFTSU4gfHwgZm5hbWUgPT09IEFDT1MgfHwgZm5hbWUgPT09IEFUQU4gJiYgeC5pc0xpbmVhcigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyppbnRlZ3JhdGlvbiBieSBwYXJ0cyAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBzeW1ib2wucG93ZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzSW50KHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZGVwdGggLSBwOyAvL2l0IG5lZWRzIG1vcmUgcm9vbSB0byBmaW5kIHRoZSBpbnRlZ3JhbFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFhcmcuaXNDb21wb3NpdGUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KF8ucGFyc2UobSksIF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaW50ZWdyYWwgdSBkdVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gY29yZS5VdGlscy5nZXRVKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBfLnBvdyhfLnBhcnNlKExPRyArIGluQnJhY2tldHModSkpLCBuZXcgU3ltYm9sKHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHUgPSBfXy5kaWZmKGFyZywgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1X2R1ID0gXy5tdWx0aXBseShmLCBkdSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVncmFsID0gX18uaW50ZWdyYXRlKHVfZHUsIHUsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoXy5wYXJzZShtKSwgaW50ZWdyYWwuc3ViKHUsIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSBUQU4gJiYgc3ltYm9sLnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnZlcnQgdG8gY290YW5nZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0ucG93ZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0uZm5hbWUgPSBDT1Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShfLnBhcnNlKG0pLCBfXy5pbnRlZ3JhdGUoc3ltLCBkeCwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFhLmNvbnRhaW5zKGR4LCB0cnVlKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSkgeyAvL3BlcmZvcm0gYSBkZWVwIHNlYXJjaCBmb3Igc2FmZXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZXMgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZm5hbWUgPT09IEFCUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1JFVklTSVQgKipUT0RPKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBfLmRpdmlkZShhcmcuY2xvbmUoKSwgYS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gUyAmJiAheC5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5VdGlscy5ldmVuKHgucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKGFyZywgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhdGVkID0gX18uaW50ZWdyYXRlKHgsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRlZC5wb3dlciA9IGludGVncmF0ZWQucG93ZXIuc3VidHJhY3QobmV3IEZyYWMoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoXy5tdWx0aXBseShfLnN5bWZ1bmN0aW9uKEFCUywgW3gudG9MaW5lYXIoKV0pLCBpbnRlZ3JhdGVkKSwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFnID0gc3ltYm9sLmFyZ3NbMF0uZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb21wb3NlZCA9IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcoYXJnLCBkeCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighKGFnID09PSBDUCB8fCBhZyA9PT0gUyB8fCBhZyA9PT0gQ0IpIHx8ICFkZWNvbXBvc2VkWzFdLnBvd2VyLmVxdWFscygxKSB8fCBhcmcuaGFzRnVuYygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipUT0RPKiovIC8vQVNJTiwgQUNPUywgQVRBTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goZm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ09TOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oU0lOLCBbYXJnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNJTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKENPUywgW2FyZ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgVEFOOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KFNldHRpbmdzLkxPRyArICcoc2VjKHswfSkpJywgYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNFQzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChTZXR0aW5ncy5MT0cgKyAnKHRhbih7MH0pK3NlYyh7MH0pKScsIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDU0M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJy0nICsgU2V0dGluZ3MuTE9HICsgJyhjc2MoezB9KStjb3QoezB9KSknLCBhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ09UOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KFNldHRpbmdzLkxPRyArICcoc2luKHswfSkpJywgYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNJTkg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbihDT1NILCBbYXJnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENPU0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbihTSU5ILCBbYXJnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRBTkg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoU2V0dGluZ3MuTE9HICsgJyhjb3NoKHswfSkpJywgYXJnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFTRUM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFDU0M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFDT1Q6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pbnZlcnNlIGh0cmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEFTRUNIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBBQ1NDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQUNPVEg6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9lbmQgaW52ZXJzZSBodHJpZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaHRyaWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFNFQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJ2F0YW4oc2luaCh7MH0pKScsIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDU0NIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KFNldHRpbmdzLkxPRyArICcodGFuaCgoezB9KS8yKSknLCBhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ09USDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChTZXR0aW5ncy5MT0cgKyAnKHNpbmgoezB9KSknLCBhcmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2VuZCBodHJpZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBFWFA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKF8ucGFyc2UoZm9ybWF0KCdlXih7MH0pJywgYXJnKSksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF0uY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRjID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhhcmcsIGR4KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhfID0gZGNbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhXyA9IGRjWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiXyA9IGRjWzNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoY29zKCgxLzIpKnBpKigoezF9KSsoezB9KSooezJ9KSleMikrcGkqKCh7MX0pKyh7MH0pKih7Mn0pKSpTKCh7MX0pKyh7MH0pKih7Mn0pKSkvKCh7MH0pKnBpKScsIGFfLCBiXywgeCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IHN5bWJvbC5hcmdzWzBdLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYyA9IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcoYXJnLCBkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XyA9IGRjWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYV8gPSBkY1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYl8gPSBkY1szXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKHBpKigoezF9KSsoezB9KSooezJ9KSkqQygoezF9KSsoezB9KSooezJ9KSktc2luKCgxLzIpKnBpKigoezF9KSsoezB9KSooezJ9KSleMikpLygoezB9KSpwaSknLCBhXywgYl8sIHhfKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlcmYnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBzeW1ib2wuYXJnc1swXS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGMgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKGFyZywgZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeF8gPSBkY1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFfID0gZGNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJ2VeKC0oKHsyfSkpXjIpLygoezB9KSpzcXJ0KHBpKSkrKDEvKHswfSkrKHsxfSkpKmVyZigoezJ9KSknLCBhXywgeF8sIGFyZykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShzeW1ib2wuY2xvbmUoKSwgYXJnLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKHJldHZhbCwgYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih4LmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmbmFtZSA9PT0gQ09TIHx8IGZuYW1lID09PSBTSU4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOdW1iZXIoc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayB0byBzZWUgaWYgaXQncyBuZWdhdGl2ZSBhbmQgdGhlbiBqdXN0IHRyYW5zZm9ybSBpdCB0byBzZWMgb3IgY3NjXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZm5hbWUgPSBmbmFtZSA9PT0gU0lOID8gQ1NDIDogU0VDO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmludmVydCgpLnVwZGF0ZUhhc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShzeW1ib2wsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJkID0gc3ltYm9sLmNsb25lKCksIC8vY29zXihuLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJkMiA9IHN5bWJvbC5jbG9uZSgpLCAvL2Nvc14obi0yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gbmV3IFN5bWJvbCgocCAtIDEpIC8gcCksIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hID0gXy5tdWx0aXBseShhLmNsb25lKCksIG5ldyBTeW1ib2wocCkpLmludmVydCgpOyAvLzEvKG4qYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJkLnBvd2VyID0gcmQucG93ZXIuc3VidHJhY3QobmV3IEZyYWMoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmQyLnBvd2VyID0gcmQyLnBvd2VyLnN1YnRyYWN0KG5ldyBGcmFjKDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8uc3ltZnVuY3Rpb24oZm5hbWUgPT09IENPUyA/IFNJTiA6IENPUywgW2FyZy5jbG9uZSgpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmbmFtZSA9PT0gU0lOKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChfLm11bHRpcGx5KF8ubXVsdGlwbHkobmEsIHJkKSwgdCksIF8ubXVsdGlwbHkocSwgX18uaW50ZWdyYXRlKF8ucGFyc2UocmQyKSwgZHgsIGRlcHRoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGFuKHgpXm4gb3IgY290KHgpXm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSBUQU4gfHwgZm5hbWUgPT09IENPVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2h0dHA6Ly93d3cuc29zbWF0aC5jb20vY2FsY3VsdXMvaW50ZWdyYXRpb24vbW9yZXRyaWdwb3dlci9tb3JldHJpZ3Bvd2VyLmh0bWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmFyZ3NbMF0uaXNMaW5lYXIoZHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHN5bWJvbC5wb3dlci5zdWJ0cmFjdChuZXcgRnJhYygxKSkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHN5bWJvbC5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9IF8ucGFyc2UoZm9ybWF0KChmbmFtZSA9PT0gQ09UID8gJy0nIDogJycpICsgJzEvKHsyfSp7MH0pKnszfSh7MX0pXih7MH0pJywgbiwgYXJnLCBhLCBmbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5wb3dlciA9IHIucG93ZXIuc3VidHJhY3QobmV3IEZyYWMoMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoci5wb3dlci5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IF8ucGFyc2Uocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN1YnRyYWN0KHcsIF9fLmludGVncmF0ZShyLCBkeCwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NlYyh4KV5uIG9yIGNzYyh4KV5uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gU0VDIHx8IGZuYW1lID09PSBDU0MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9odHRwOi8vd3d3LnNvc21hdGguY29tL2NhbGN1bHVzL2ludGVncmF0aW9uL21vcmV0cmlncG93ZXIvbW9yZXRyaWdwb3dlci5odG1sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuMSA9IHN5bWJvbC5wb3dlci5zdWJ0cmFjdChuZXcgRnJhYygxKSkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuMiA9IHN5bWJvbC5wb3dlci5zdWJ0cmFjdChuZXcgRnJhYygyKSkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmMiA9IGZuYW1lID09PSBTRUMgPyBUQU4gOiBDT1QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHN5bWJvbC5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZV9zdHIgPSBmb3JtYXQoKGZuYW1lID09PSBDU0MgPyAnLScgOiAnJykgKyAnMS8oezB9KnsxfSkqezR9KHszfSleKHsyfSkqezV9KHszfSknLCBhLCBuMSwgbjIsIGFyZywgZm5hbWUsIGYyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ID0gXy5wYXJzZShwYXJzZV9zdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnBvd2VyID0gci5wb3dlci5zdWJ0cmFjdChuZXcgRnJhYygyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHIucG93ZXIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IF8ucGFyc2Uocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHcsIF8ubXVsdGlwbHkobmV3IFN5bWJvbChuMiAvIG4xKSwgX18uaW50ZWdyYXRlKHIsIGR4LCBkZXB0aCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZigoZm5hbWUgPT09IENPU0ggfHwgZm5hbWUgPT09IFNJTkgpICYmIHN5bWJvbC5wb3dlci5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKHN5bWJvbC5mblRyYW5zZm9ybSgpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm11bHRpcGxpZXIgPSByZXR2YWwubXVsdGlwbGllci5tdWx0aXBseShtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBhcnRpYWxfZnJhY3Rpb24oc3ltYm9sLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZW4gPSBzeW1ib2wuZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVuLmdyb3VwID09PSBTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5leHBhbmQoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VwYXJhdGUgdGhlIGNvZWZmaWNpZW50IHNpbmNlIGFsbCB3ZSBjYXJlIGFib3V0IGFyZSBzeW1ib2xzIGNvbnRhaW5pbmcgZHhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmID0gc3ltYm9sLnN0cmlwVmFyKGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3cgZ2V0IG9ubHkgdGhvc2UgdGhhdCBhcHBseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2ZzeW1ib2wgPSBfLmRpdmlkZShzeW1ib2wuY2xvbmUoKSwgY29lZmYuY2xvbmUoKSk7IC8vYSBjb2VmZiBmcmVlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BlZm9ybSBhIGNvcnJlY3Rpb24gZm9yIHN0cmlwVmFyLiBUaGlzIGlzIGEgc2VyaW91cyBUT0RPIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjb2VmZi5jb250YWlucyhkeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNmc3ltYm9sID0gXy5tdWx0aXBseShjZnN5bWJvbCwgY29lZmYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmYgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIG9ubHkgaGF2ZSBvbmUgc3ltYm9sIGxlZnQgdGhlbiBsZXQncyBub3Qgd2FzdGUgdGltZS4gSnVzdCBwdWxsIHRoZSBpbnRlZ3JhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FuZCBsZXQgdGhlIGNoaXBzIGZhbGwgd2hlcmUgdGhleSBtYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2ZzeW1ib2wuZ3JvdXAgIT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZnN5bWJvbC5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uaW50ZWdyYXRlKF8uZXhwYW5kKHN5bWJvbCksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmx5IGZhY3RvciBmb3IgbXVsdGl2YXJpYXRlIHdoaWNoIGFyZSBwb2x5bm9taWFsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2ZzeW1ib2wuY2xvbmUoKS50b0xpbmVhcigpLmlzUG9seSh0cnVlKSAmJiBjb3JlLlV0aWxzLnZhcmlhYmxlcyhjZnN5bWJvbCkubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNmc3ltYm9sID0gY29yZS5BbGdlYnJhLkZhY3Rvci5mYWN0b3IoY2ZzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShjZnN5bWJvbCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgY29sbGVjdCB0aGUgc3ltYm9scyBhbmQgc29ydCB0aGVtIGRlc2NlbmRpbmcgZ3JvdXAsIGRlc2NlbmRpbmcgcG93ZXIsIGRlc2NlbmRpbmcgYWxwYWJldGhpY2FsbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gY2ZzeW1ib2wuY29sbGVjdFN5bWJvbHMoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5ncm91cCA9PT0gYi5ncm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihOdW1iZXIoYS5wb3dlcikgPT09IE51bWJlcihiLnBvd2VyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEgPCBiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxOyAvL0kgd2FudCBzaW4gZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLnBvd2VyIC0gYS5wb3dlcjsgLy9kZXNjZW5kaW5nIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLmdyb3VwIC0gYS5ncm91cDsgLy9kZXNjZW5kaW5nIGdyb3Vwc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVud3JhcHBlZCA9IFN5bWJvbC51bndyYXBTUVJUKHgsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHVud3JhcHBlZC5mbmFtZSA9PT0gRVhQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnKHsxfSkqZV4oezB9KScsIHVud3JhcHBlZC5hcmdzWzBdLCB1bndyYXBwZWQubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW53cmFwcGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHN5bWJvbHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGwgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLmludGVncmF0ZShfLmV4cGFuZChzeW1ib2wpLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgdGhlIGRlbm9taW5hdG9yIGlzIG9uZSBsdW1wZWQgdG9nZXRoZXIgc3ltYm9sIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZW5lcmF0ZSBhbiBpbWFnZSBmb3IgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyeSB1IHN1YnN0aXR1dGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24udV9zdWJzdGl0dXRpb24oc3ltYm9scywgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHsvKiBmYWlsZWQgOmAoKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXJldHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ubyBzdWNjZXNzIHdpdGggdSBzdWJzdGl0dXRpb24gc28gbGV0J3MgdHJ5IGtub3duIGNvbWJpbmF0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hcmUgdGhleSB0d28gZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZzEgPSBzeW1ib2xzWzBdLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnMiA9IHN5bWJvbHNbMV0uZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEgPSBzeW1ib2xzWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0yID0gc3ltYm9sc1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4xID0gc3ltMS5mbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4yID0gc3ltMi5mbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVzZXQgdGhlIHN5bWJvbCBtaW51cyB0aGUgY29lZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ubXVsdGlwbHkoc3ltMS5jbG9uZSgpLCBzeW0yLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZzEgPT09IEZOICYmIGcyID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZuMSA9PT0gTE9HIHx8IGZuMiA9PT0gTE9HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbC5jbG9uZSgpLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiLmZuYW1lID4gYS5mbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmcxID0gc3ltMS5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSB0aGUgYXJndW1lbnRzIGFyZSBzdWl0YWJsZS4gV2UgZG9uJ3Qga25vdyBob3cgdG8gaW50ZWdyYXRlIG5vbi1saW5lYXIgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFhcmcxLmlzTGluZWFyKCkgfHwgIShhcmcxLmdyb3VwID09PSBDUCB8fCBhcmcxLmdyb3VwID09PSBDQiB8fCBhcmcxLmdyb3VwID09PSBTKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNvbXAgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKGFyZzEsIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRlY29tcFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gZGVjb21wWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigheC5pc0xpbmVhcigpKSAvL2FnYWluLi4uIGxpbmVhciBhcmd1bWVudHMgb25seSB3cnQgeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18uaW50ZWdyYXRpb24uc3RvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGV5IGhhdmUgdG8gaGF2ZSB0aGUgc2FtZSBhcmd1bWVudHMgYW5kIHRoZW4gd2UgaGF2ZSBjbGVhcmVkIGFsbCB0aGUgY2hlY2sgdG8gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIHdlIGNhbiBpbnRlZ3JhdGUgRk4gJiBGTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJnMiA9IHN5bTIuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhhdCB0aGVpciBhcmd1bWVudCBtYXRjaGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFyZzEuZXF1YWxzKGFyZzIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmbjEgPT09IFNJTiAmJiBmbjIgPT09IENPUyB8fCBmbjEgPT09IENPUyAmJiBmbjIgPT09IFNJTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTEucG93ZXIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fLmludGVncmF0aW9uLnN0b3AoKTsvL3dlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZSwgc2luKHgpXm4vY29zKHgpXm0gd2hlcmUgbSA+IG4sICB5ZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3MgaW4gdGhlIGZvcm0gc2luKHgpXm4qY29zKHgpXm4gdGhlbiB3ZSBjYW4ganVzdCByZXR1cm4gdGFuKHgpXm4gd2hpY2ggd2Uga25vdyBob3cgdG8gaW50ZWdyYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZm4xID09PSBTSU4gJiYgc3ltMS5wb3dlci5hZGQoc3ltMi5wb3dlcikuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEuZm5hbWUgPSBUQU47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEudXBkYXRlSGFzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoc3ltMSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV2ZW4oc3ltMS5wb3dlcikgJiYgZm4yID09PSBDT1MgJiYgc3ltMi5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cmFuc2Zvcm0gc2luXigyKm4pIHRvICgxLWNvc14yKV5uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IE51bWJlcihzeW0xLnBvd2VyKSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19zeW0gPSBfLnBhcnNlKGZvcm1hdCgnKDEtY29zKHswfSleMileKHsxfSknLCBzeW0xLmFyZ3NbMF0sIG4pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLmV4cGFuZChfLm11bHRpcGx5KG5ld19zeW0sIHN5bTIuY2xvbmUoKSkpLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihldmVuKHN5bTEucG93ZXIpICYmIGZuMiA9PT0gU0lOICYmIHN5bTIucG93ZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJhbnNmb3JtIGNvc14oMipuKSB0byAoMS1zaW5eMileblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBOdW1iZXIoc3ltMS5wb3dlcikgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfc3ltID0gXy5wYXJzZShmb3JtYXQoJygxLXNpbih7MH0pXjIpXih7MX0pJywgc3ltMS5hcmdzWzBdLCBuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5leHBhbmQoXy5tdWx0aXBseShuZXdfc3ltLCBzeW0yLmNsb25lKCkpKSwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAxX2V2ZW4gPSBjb3JlLlV0aWxzLmV2ZW4oc3ltMS5wb3dlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyX2V2ZW4gPSBjb3JlLlV0aWxzLmV2ZW4oc3ltMi5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXAxX2V2ZW4gfHwgIXAyX2V2ZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSwgciwgdHJhbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zaW5jZSBjb3MoeCkgaXMgb2RkIGl0IGNhcnJpZXMgZHUuIElmIHNpbiB3YXMgb2RkIHRoZW4gaXQgd291bGQgYmUgdGhlIG90aGVyIHdheSBhcm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2tub3cgdGhhdCBwMSBzYXRpZmllcyB0aGUgb2RkIHBvcnRpb24gaW4gdGhpcyBjYXNlLiBJZiBwMiBkaWQgdGhhbiBpdCB3b3VsZCBjb250YWluIHJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighcDFfZXZlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3UgPSBzaW4oeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHN5bTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBzeW0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IHN5bTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBzeW0yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgc2lnbiBvZiBkdS4gSW4gdGhpcyBjYXNlIHIgY2FycmllcyBkdSBhcyBzdGF0ZWQgYmVmb3JlIGFuZCBEKGNvcyh4KSx4KSA9IC1zaW4oeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHUuZm5hbWUgPT09IENPUyA/IC0xIDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByLnBvd2VyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhlIGR1IGUuZy4gY29zKHgpXjIqc2luKHgpXjMgZHggLT4gY29zKHgpXjIqc2luKHgpXjIqc2luKHgpLiBXZSdyZSBsZWZ0IHdpdGggdHdvIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ldmVuIHBvd2VycyBhZnRlcndhcmRzIHdoaWNoIGNhbiBiZSB0cmFuc2Zvcm1lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IChuIC0gMSkgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHRoZSB0cmFuc2Zvcm1hdGlvbiBjb3MoeCleMiA9IDEgLSBzaW4oeCleMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMgPSBfLnBhcnNlKCcoMS0nICsgdS5mbmFtZSArIGNvcmUuVXRpbHMuaW5CcmFja2V0cyhhcmcxKSArICdeMileJyArIGspLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltID0gXy5leHBhbmQoXy5tdWx0aXBseShuZXcgU3ltYm9sKHNpZ24pLCBfLm11bHRpcGx5KHUuY2xvbmUoKSwgdHJhbnMpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBjYW4gbm93IGp1c3QgbG9vcCB0aHJvdWdoIGFuZCBpbnRlZ3JhdGUgZWFjaCBzaW5jZSBpdCdzIG5vdyBqdXN0IGEgcG9seW5vbWlhbCB3aXRoIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX18uaW50ZWdyYXRpb24ucG9seV9pbnRlZ3JhdGUoeC5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BlcmZvcm1zIGRvdWJsZSBhbmdsZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3VibGVfYW5nbGUgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gc3ltYm9sLnBvd2VyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBwIC8gMiwgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmZuYW1lID09PSBDT1MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gJygoMS8yKSsoY29zKDIqKCcgKyBzeW1ib2wuYXJnc1swXSArICcpKS8yKSleJyArIGs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSAnKCgxLzIpLShjb3MoMiooJyArIHN5bWJvbC5hcmdzWzBdICsgJykpLzIpKV4nICsgaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGV5J3JlIGJvdGggZXZlbiBzbyB0cmFuc2Zvcm0gYm90aCB1c2luZyBkb3VibGUgYW5nbGUgaWRlbnRpdGllcyBhbmQgd2UnbGwganVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmUgYWJsZSB0byBpbnRlZ3JhdGUgYnkgdGhlIHN1bSBvZiBpbnRlZ3JhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGRvdWJsZV9hbmdsZShzeW0xKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBkb3VibGVfYW5nbGUoc3ltMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5tdWx0aXBseShhLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gXy5leHBhbmQodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfXy5pbnRlZ3JhdGUoeCwgZHgsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkocmV0dmFsLCBjb2VmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rhbih4KSpzZWMoeClebiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm4xID09PSBTRUMgJiYgZm4yID09PSBUQU4gJiYgeC5pc0xpbmVhcigpICYmIHN5bTIuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCdzZWMoezB9KV4oezF9KS8oezF9KScsIHN5bTEuYXJnc1swXSwgc3ltMS5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbjEgPT09IFRBTiAmJiBmbjIgPT09IFNFQyAmJiB4LmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbWFpbmluZzogdGFuKHgpXjMqc2VjKHgpXjZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0xLmlzTGluZWFyKCkgJiYgc3ltMi5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKF8uc3ltZnVuY3Rpb24oU0VDLCBbYXJnMS5jbG9uZSgpXSksIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGV2ZW4oc3ltMS5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBOdW1iZXIoc3ltMS5wb3dlcikgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyYW5zZm9ybSB0YW5nZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXy5wYXJzZShmb3JtYXQoJyhzZWMoezB9KV4yLTEpXih7MX0pJywgc3ltMS5hcmdzWzBdLCBwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLmV4cGFuZChfLm11bHRpcGx5KHQsIHN5bTIpKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuMSA9PT0gU0VDICYmIGZuMiA9PT0gQ09TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMS5mbmFtZSA9IENPUztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0xLmludmVydCgpLnVwZGF0ZUhhc2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5tdWx0aXBseShzeW0xLCBzeW0yKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm4xID09PSBTSU4gJiYgZm4yID09PSBDU0MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0yLmZuYW1lID0gU0lOO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTIuaW52ZXJ0KCkudXBkYXRlSGFzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLm11bHRpcGx5KHN5bTEsIHN5bTIpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90YW4vY29zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZuMSA9PT0gVEFOICYmIChmbjIgPT09IENPUyB8fCBmbjIgPT09IFNJTikgJiYgc3ltMi5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXy5tdWx0aXBseShzeW0xLmZuVHJhbnNmb3JtKCksIHN5bTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLmV4cGFuZCh0KSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXy5tdWx0aXBseShzeW0xLmZuVHJhbnNmb3JtKCksIHN5bTIuZm5UcmFuc2Zvcm0oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKF8uZXhwYW5kKHQpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogSW4gcHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZigoZm4xID09PSBTSU4gfHwgZm4xID09PSBDT1MpICYmIChmbjIgPT09IFNJTiB8fCBmbjIgPT09IENPUykpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0xLmlzTGluZWFyKCkgJiYgc3ltMi5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpbiB0aGUgZm9ybSBjb3MoYSp4KSpzaW4oYip4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTEuYXJnc1swXS5pc0xpbmVhcigpICYmIHN5bTIuYXJnc1swXS5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXNlIGlkZW50aXR5IChzaW4oYip4K2EqeCkrc2luKGIqeC1hKngpKS8yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheCwgYng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZuMiA9PT0gU0lOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheCA9IHN5bTEuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ4ID0gc3ltMi5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnggPSBzeW0xLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheCA9IHN5bTIuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHRoZSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gXy5wYXJzZShmb3JtYXQoJyhzaW4oKHsxfSkrKHswfSkpK3NpbigoezF9KS0oezB9KSkpLzInLCBheC50b1N0cmluZygpLCBieC50b1N0cmluZygpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ludGVncmF0ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoZiwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRyaWdUcmFuc2Zvcm0oc3ltYm9scyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLmV4cGFuZCh0cmFuc2Zvcm1lZCksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzLm1hcChmdW5jdGlvbiAoc3ltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gc3ltLmZuVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gXy5tdWx0aXBseSh0cmFuc2Zvcm1lZCwgcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBfLmV4cGFuZCh0cmFuc2Zvcm1lZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZSh0LCBkeCwgZGVwdGgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXR2YWwuaGFzSW50ZWdyYWwoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUodHJpZ1RyYW5zZm9ybSh0cmFuc2Zvcm1lZC5jb2xsZWN0U3ltYm9scygpKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfXy5pbnRlZ3JhdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnMSA9PT0gRk4gJiYgZzIgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltMV9pc19saW5lYXIgPSBzeW0xLmlzTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltMS5mbmFtZSA9PT0gQ09TICYmIHN5bTFfaXNfbGluZWFyICYmIHN5bTIucG93ZXIuZXF1YWxzKC0xKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignQ2knLCBbc3ltMS5hcmdzWzBdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLmZuYW1lID09PSBDT1MgJiYgc3ltMi5wb3dlci5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLm11bHRpcGx5KHN5bTEuZm5UcmFuc2Zvcm0oKSwgc3ltMi5jbG9uZSgpKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLmZuYW1lID09PSBDT1NIICYmIHN5bTFfaXNfbGluZWFyICYmIHN5bTIucG93ZXIuZXF1YWxzKC0xKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignQ2hpJywgW3N5bTEuYXJnc1swXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltMS5mbmFtZSA9PT0gQ09TSCAmJiBzeW0yLnBvd2VyLmVxdWFscygtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRlKF8ubXVsdGlwbHkoc3ltMS5mblRyYW5zZm9ybSgpLCBzeW0yLmNsb25lKCkpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEuZm5hbWUgPT09IFNJTiAmJiBzeW0xX2lzX2xpbmVhciAmJiBzeW0yLnBvd2VyLmVxdWFscygtMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ1NpJywgW3N5bTEuYXJnc1swXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltMS5mbmFtZSA9PT0gU0lOICYmIHN5bTIucG93ZXIuZXF1YWxzKC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5tdWx0aXBseShzeW0xLmZuVHJhbnNmb3JtKCksIHN5bTIuY2xvbmUoKSksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltMS5mbmFtZSA9PT0gU0lOSCAmJiBzeW0xX2lzX2xpbmVhciAmJiBzeW0yLnBvd2VyLmVxdWFscygtMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ1NoaScsIFtzeW0xLmFyZ3NbMF1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEuZm5hbWUgPT09IFNJTkggJiYgc3ltMi5wb3dlci5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShfLm11bHRpcGx5KHN5bTEuZm5UcmFuc2Zvcm0oKSwgc3ltMi5jbG9uZSgpKSwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW0xLmZuYW1lID09PSBMT0cgJiYgc3ltMi5wb3dlci5lcXVhbHMoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9nKHgpXm4veCA9IGxvZyh4KV4obisxKS8obisxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wb2x5X2ludGVncmF0ZShzeW0xLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEuZm5hbWUgPT09ICdlcmYnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTIucG93ZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGMgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKHN5bTEuYXJnc1swXSwgZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhXyA9IGRjWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XyA9IGRjWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBzeW0xLmFyZ3NbMF0udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoZV4oLSgoezJ9KSleMikqKHNxcnQocGkpKmVeKCgoezJ9KSleMikqKDIqKHswfSleMiooezF9KV4yLTMpKmVyZigoezJ9KSkrMiooezB9KSooezF9KS0yKSkvKDQqc3FydChwaSkqKHswfSleMiknLCBhXywgeF8sIGFyZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2luY2UgZ3JvdXAgUyBpcyBndWFyYW50ZWVkIGNvbnZlcmdlbmNlIHdlIG5lZWQgbm90IHdvcnJ5IGFib3V0IHRyYWNraW5nIGRlcHRoIG9mIGludGVncmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZzEgPT09IEVYICYmIGcyID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBmbjEgPT09IExPRyA/IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcoc3ltMS5hcmdzWzBdLCBkeClbMV0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTEuaXNFKCkgJiYgKHN5bTEucG93ZXIuZ3JvdXAgPT09IFMgfHwgc3ltMS5wb3dlci5ncm91cCA9PT0gQ0IpICYmIHN5bTIucG93ZXIuZXF1YWxzKC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdFaScsIFtzeW0xLnBvd2VyLmNsb25lKCldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbjEgPT09IExPRyAmJiB4LnZhbHVlID09PSBzeW0yLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKHN5bTEsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcxID09PSBQTCAmJiBnMiA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyc3QgdHJ5IHRvIHJlZHVjZSB0aGUgdG9wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltMi52YWx1ZSA9PT0gc3ltMS52YWx1ZSAmJiBzeW0xLnBvd2VyLmVxdWFscygtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBsb3dlc3QgcG93ZXIgaW4gdGhlIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZCA9IE1hdGgubWluLmFwcGx5KG51bGwsIGNvcmUuVXRpbHMua2V5cyhzeW0xLnN5bWJvbHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGxvd2VzdCBjb21tb24gdmFsdWUgYmV0d2VlbiBkZW5vbWluYXRvciBhbmQgbnVtZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYyA9IE1hdGgubWluKHBkLCBzeW0yLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWR1Y2UgYm90aCBkZW5vbWluYXRvciBhbmQgbnVtZXJhdG9yIGJ5IHRoYXQgZmFjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBzeW0yLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3Rvci5wb3dlciA9IG5ldyBGcmFjKHBjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMiA9IF8uZGl2aWRlKHN5bTIsIGZhY3Rvci5jbG9uZSgpKTsgLy9yZWR1Y2UgdGhlIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5hZGQodCwgXy5kaXZpZGUoeC5jbG9uZSgpLCBmYWN0b3IuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5tdWx0aXBsaWVyID0gc3ltMS5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLmRpdmlkZShzeW0yLCB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBhcnRpYWxfZnJhY3Rpb24oc3ltYm9sLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnMSA9PT0gQ1AgJiYgZzIgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHN5bTEuY2xvbmUoKS50b0xpbmVhcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZl9pc19saW5lYXIgPSBjb3JlLkFsZ2VicmEuZGVncmVlKGYsIF8ucGFyc2UoZHgpKS5lcXVhbHMoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGUgY2FzZXMgeF4oMipuKS9zcXJ0KDEteF4yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTEucG93ZXIuZXF1YWxzKC0xIC8gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29tcCA9IF9fLmludGVncmF0aW9uLmRlY29tcG9zZV9hcmcoc3ltMS5jbG9uZSgpLnRvTGluZWFyKCksIGR4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBkZWNvbXBbMF0ubmVnYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRlY29tcFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gZGVjb21wWzNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gTnVtYmVyKHN5bTEucG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gTnVtYmVyKHN5bTIucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc0ludChwMikgJiYgY29yZS5VdGlscy5ldmVuKHAyKSAmJiB4LnBvd2VyLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgc3Vic3RpdHV0aW9uIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBfLmRpdmlkZShfLm11bHRpcGx5KF8ucG93KGIuY2xvbmUoKSwgbmV3IFN5bWJvbCgyKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uc3ltZnVuY3Rpb24oU1FSVCwgW18uZGl2aWRlKGIuY2xvbmUoKSwgYS5jbG9uZSgpKV0pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5wb3coYS5jbG9uZSgpLCBuZXcgU3ltYm9sKDIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gXy5tdWx0aXBseShjLCBfLnN5bWZ1bmN0aW9uKFNRUlQsIFtiXSkuaW52ZXJ0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1bW15ID0gXy5wYXJzZSgnc2luKHUpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdW1teS5wb3dlciA9IGR1bW15LnBvd2VyLm11bHRpcGx5KHN5bTIucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVncmFsID0gX18uaW50ZWdyYXRlKGR1bW15LCAndScsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBia3N1YiA9IF8ucGFyc2UoQVNJTiArICcoJyArIFNRUlQgKyAnKCcgKyBhICsgJy8nICsgYiArICcpKicgKyBkeCArICcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KGMsIGludGVncmFsLnN1YihuZXcgU3ltYm9sKCd1JyksIGJrc3ViKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihwMSA9PT0gLTEgLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdV90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoZiwgdSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhbCA9IF8ucGFyc2UoX18uaW50ZWdyYXRlKGYsIGR4LCBkZXB0aCwgb3B0KS5zdWIoZHgsIGZvcm1hdCh1LCBkeCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighaW50ZWdyYWwuaGFzSW50ZWdyYWwoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVncmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocDIgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gdV90cmFuc2Zvcm0oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmV4cGFuZChfLmV4cGFuZChfLnBvdyhfLm11bHRpcGx5KHN5bTEuaW52ZXJ0KCksIHN5bTIuaW52ZXJ0KCkpLCBuZXcgU3ltYm9sKDIpKSkpLmludmVydCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NxcnQoMS0xLyh7MH0pXjIpJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYocDIgPT09IC0yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSB0cmFuc2Zvcm1hdGlvbiB0byBzZWUgaWYgaXQgbWF0Y2hlcyBhc2luKHgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gdV90cmFuc2Zvcm0oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnNxcnQoXy5leHBhbmQoXy5kaXZpZGUoXy5wb3coc3ltYm9sLCBuZXcgU3ltYm9sKDIpKS5pbnZlcnQoKSwgXy5wb3cobmV3IFN5bWJvbChkeCksIG5ldyBTeW1ib2woMikpKS5uZWdhdGUoKSkpLmludmVydCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NxcnQoMS0xLyh7MH0pXjIpJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEucG93ZXIuZXF1YWxzKC0xKSAmJiBzeW0yLmlzTGluZWFyKCkgJiYgZl9pc19saW5lYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24ucGFydGlhbF9mcmFjdGlvbihzeW1ib2wsIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoIXN5bTEucG93ZXIubGVzc1RoYW4oMCkgJiYgaXNJbnQoc3ltMS5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zdW0gb2YgaW50ZWdyYWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZCA9IF8uZXhwYW5kKHN5bTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4Lmdyb3VwID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZWFjaChmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9fLmludGVncmF0ZShfLm11bHRpcGx5KHN5bTIuY2xvbmUoKSwgeSksIGR4LCBkZXB0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX18uaW50ZWdyYXRlKF8ubXVsdGlwbHkoc3ltMi5jbG9uZSgpLCB4KSwgZHgsIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEucG93ZXIubGVzc1RoYW4oLTIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEucG93ZXIubGVzc1RoYW4oMCkgJiYgc3ltMi5wb3dlci5ncmVhdGVyVGhhbigxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb21wID0gX18uaW50ZWdyYXRpb24uZGVjb21wb3NlX2FyZyhzeW0xLmNsb25lKCkudG9MaW5lYXIoKSwgZHgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBkZWNvbXBbMF0ubmVnYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRlY29tcFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gZGVjb21wWzNdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gc3ltMS5jbG9uZSgpLnRvTGluZWFyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih4Lmdyb3VwICE9PSBQTCAmJiB4LmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKHN5bTIucG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdSA9ICdfdV8nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gbmV3IFN5bWJvbChkdSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHVsbCB0aGUgaW50ZWdyYWwgd2l0aCB0aGUgc3Vic2l0dXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVSA9IF8uZXhwYW5kKF8uZGl2aWRlKF8ucG93KF8uc3VidHJhY3QodS5jbG9uZSgpLCBiLmNsb25lKCkpLCBuZXcgU3ltYm9sKHApKSwgdS5jbG9uZSgpKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZW5lcmF0ZSBhIHNjb3BlIGZvciByZXN1YmJpbmcgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVbZHVdID0gZm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVTIgPSBfLnBhcnNlKFUsIHNjb3BlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZShVMiwgZHgsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltMi5wb3dlci5ncmVhdGVyVGhhbih4LnBvd2VyKSB8fCBzeW0yLnBvd2VyLmVxdWFscyh4LnBvd2VyKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmFjdG9yIG91dCBjb2VmZmljaWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JzID0gbmV3IGNvcmUuQWxnZWJyYS5DbGFzc2VzLkZhY3RvcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTEgPSBjb3JlLkFsZ2VicmEuRmFjdG9yLmNvZWZmRmFjdG9yKHN5bTEuaW52ZXJ0KCksIGZhY3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IGNvcmUuQWxnZWJyYS5kaXZpZGUoc3ltMiwgc3ltMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2l0IGFzc3VtZWQgdGhhdCB0aGUgcmVzdWx0IHdpbGwgYmUgb2YgZ3JvdXAgQ0JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRpdi5ncm91cCAhPT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5lYWNoKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX18uaW50ZWdyYXRlKHQsIGR4LCBkZXB0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgdGhlIGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLmVhY2goZnVuY3Rpb24gKGZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShyZXR2YWwsIGZhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZXhwYW5kKHJldHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyeSBzb21ldGhpbmcgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLmJ5X3BhcnRzKHN5bWJvbCwgZHgsIGRlcHRoLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0aW9uLnBhcnRpYWxfZnJhY3Rpb24oc3ltYm9sLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGUgY2FzZXMgc3VjaCBhcyAoMS14XjIpXihuLzIpKnheKG0pIHdoZXJlIG4gaXMgb2RkIF9fXyBjcmFja2luZyBrbnVja2xlcy4uLiBUaGlzIGNhbiBnZXQgYSBsaXR0bGUgaGFpcnkgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTEucG93ZXIuZGVuLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hc3N1bWUgdGhlIGZ1bmN0aW9uIGlzIGluIHRoZSBmb3JtIChhXjItYip4Xm4pXihtLzIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGMgPSBfXy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnKHN5bTEuY2xvbmUoKS50b0xpbmVhcigpLCBkeCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXNpbmcgdGhlIGFib3ZlIGRlZmluaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGRjWzNdLCB4ID0gZGNbMV0sIGIgPSBkY1swXSwgYnggPSBkY1syXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHgucG93ZXIuZXF1YWxzKDIpICYmIGIubGVzc1RoYW4oMCkpIHsgLy9pZiBuIGlzIGV2ZW4gJiYgYiBpcyBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBhIGVxdWFsIDEgc28gd2UgY2FuIGRvIGEgdHJpZyBzdWJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighYS5lcXVhbHMoMSkpIHsgLy9kaXZpZGUgYSBvdXQgb2YgZXZlcnl0aGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21vdmUgYSB0byB0aGUgY29lZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29lZmYgPSBfLm11bHRpcGx5KGNvZWZmLCBfLnBvdyhhLCBuZXcgU3ltYm9sKDIpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBfLmRpdmlkZShfLnBvdyhiLmNsb25lKCkubmVnYXRlKCksIG5ldyBTeW1ib2woMSAvIDIpKSwgXy5wb3coYSwgbmV3IFN5bWJvbCgxIC8gMikpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1ID0gXy5zeW1mdW5jdGlvbihDT1MsIFtuZXcgU3ltYm9sKHUpXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3NuID0gXy5wb3coXy5zeW1mdW5jdGlvbihDT1MsIFtuZXcgU3ltYm9sKHUpXSksIG5ldyBTeW1ib2woc3ltMS5wb3dlci5udW0pKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFggPSBfLnBvdyhfLnN5bWZ1bmN0aW9uKFNJTiwgW25ldyBTeW1ib2wodSldKSwgbmV3IFN5bWJvbChzeW0yLnBvd2VyKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBfLm11bHRpcGx5KF8ubXVsdGlwbHkoY29zbiwgZHUpLCBYKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmFsID0gX18uaW50ZWdyYXRlKHZhbCwgdSwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYnV0IHJlbWVtYmVyIHRoYXQgdSA9IGFzaW4oc3FydChiKSphKngpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gaW50ZWdyYWwuc3ViKHUsIF8uc3ltZnVuY3Rpb24oQVNJTiwgW18ubXVsdGlwbHkobmV3IFN5bWJvbChkeCksIGMpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24ucGFydGlhbF9mcmFjdGlvbihzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGZfaXNfbGluZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wYXJ0aWFsX2ZyYWN0aW9uKHN5bWJvbCwgZHgsIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bTEuaXNDb21wb3NpdGUoKSAmJiBzeW0yLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N1bSBvZiBpbnRlZ3JhbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTEucG93ZXIuZ3JlYXRlclRoYW4oMCkgJiYgc3ltMi5wb3dlci5ncmVhdGVyVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbWJpbmUgYW5kIHB1bGwgdGhlIGludGVncmFsIG9mIGVhY2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IF8uZXhwYW5kKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIF9fLmludGVncmF0ZSh4LCBkeCwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBOdW1iZXIoc3ltMS5wb3dlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBOdW1iZXIoc3ltMi5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHAxIDwgMCAmJiBwMiA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3dhcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBzeW0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMSA9IHN5bTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0yID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwMSA9PT0gLTEgJiYgcDIgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5wYXJ0aWFsX2ZyYWN0aW9uKHN5bWJvbCwgZHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBfLm11bHRpcGx5KHgsIHN5bTIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVncmFsID0gX18uaW50ZWdyYXRlKGssIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBpbnRlZ3JhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZzEgPT09IENQICYmIHN5bWJvbHNbMF0ucG93ZXIuZ3JlYXRlclRoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0xID0gXy5leHBhbmQoc3ltMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0xLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfXy5pbnRlZ3JhdGUoXy5tdWx0aXBseSh4LCBzeW0yLmNsb25lKCkpLCBkeCwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZzEgPT09IEZOICYmIGcyID09PSBFWCAmJiBjb3JlLlV0aWxzLmluX2h0cmlnKHN5bTEuZm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMSA9IHN5bTEuZm5UcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5leHBhbmQoXy5tdWx0aXBseShzeW0xLCBzeW0yKSksIGR4LCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGcxID09PSBGTiAmJiBnMiA9PT0gQ1AgfHwgZzIgPT09IEZOICYmIGcxID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGcyID09PSBGTiAmJiBnMSA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBzeW0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0xID0gc3ltMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMiA9IHQ7IC8vc3dhcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHUsIHN5bTJfY2xvbmUsIHAsIHEsIHNhLCBzYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdSA9IFN5bWJvbC51bndyYXBTUVJUKF9fLmRpZmYoc3ltMS5jbG9uZSgpLCBkeCksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bTJfY2xvbmUgPSBTeW1ib2wudW53cmFwU1FSVChzeW0yLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkdS5wb3dlci5lcXVhbHMoc3ltMl9jbG9uZS5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG5ldyBTeW1ib2woc3ltMi5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhID0gZHUuY2xvbmUoKS50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYiA9IHN5bTIuY2xvbmUoKS50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gY29yZS5BbGdlYnJhLmRpdmlkZShzYS50b0xpbmVhcigpLCBzYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHEuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnEgPSBfLnBvdyhxLCBwLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkobnEsIF9fLmludGVncmF0aW9uLnBvbHlfaW50ZWdyYXRlKHN5bTEuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYSA9IHN5bTEuY2xvbmUoKS50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1iID0gc3ltMi5jbG9uZSgpLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZzEgPT09IEVYICYmIGcyID09PSBFWCAmJiBzeW0xLnBvd2VyLmNvbnRhaW5zKGR4KSAmJiBzeW0yLnBvd2VyLmNvbnRhaW5zKGR4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIXN5bWEuY29udGFpbnMoZHgpICYmICFzeW1iLmNvbnRhaW5zKGR4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKCh7MH0pXigoezJ9KSooezR9KSkqKHsxfSleKCh7M30pKih7NH0pKSkvKGxvZygoezB9KV4oezJ9KSkrbG9nKCh7MX0pXih7M30pKSknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWEudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1iLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMS5wb3dlci5tdWx0aXBsaWVyLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltMi5wb3dlci5tdWx0aXBsaWVyLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGlvbi5ieV9wYXJ0cyhzeW1ib2wsIGR4LCBkZXB0aCwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGwgPT09IDMgJiYgKHN5bWJvbHNbMl0uZ3JvdXAgPT09IFMgJiYgc3ltYm9sc1syXS5wb3dlci5sZXNzVGhhbigyKSB8fCBzeW1ib2xzWzBdLmdyb3VwID09PSBDUCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gc3ltYm9sc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmlyc3QuZ3JvdXAgPT09IENQKSB7IC8vVE9ETyB7c3VwcG9ydCBoaWdoZXIgcG93ZXJzIG9mIHggaW4gdGhlIGZ1dHVyZX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZpcnN0LnBvd2VyLmdyZWF0ZXJUaGFuKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gXy5leHBhbmQoZmlyc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBfLm11bHRpcGx5KHN5bWJvbHNbMV0sIHN5bWJvbHNbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0LmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8ubXVsdGlwbHkoeCwgci5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZyA9IF9fLmludGVncmF0ZSh0LCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgaW50Zyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IGludGVncmF0aW9uIGJ5IHBhcnRzIGFsdGhvdWdoIHRlY2huaWNhbGx5IGl0IHdpbGwgbmV2ZXIgd29ya1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uaW50ZWdyYXRpb24uYnlfcGFydHMoc3ltYm9sLCBkeCwgZGVwdGgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWxsX2Z1bmN0aW9ucyhzeW1ib2xzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBzeW1ib2xzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkodCwgc3ltYm9sc1tpXS5mblRyYW5zZm9ybSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5leHBhbmQodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLmludGVncmF0ZSh0LCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmUgbW9yZSBnb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWQgPSB0cmlnVHJhbnNmb3JtKHN5bWJvbHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5pbnRlZ3JhdGUoXy5leHBhbmQodHJhbnNmb3JtZWQpLCBkeCwgZGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBjb2VmZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgYW4gaW50ZWdyYWwgd2FzIGZvdW5kIHRoZW4gd2UgcmV0dXJuIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocmV0dmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNhdGNoKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9kbyBub3RoaW5nIGlmIGl0J3MgYSBOb0ludGVncmFsRm91bmQgZXJyb3Igb3RoZXJ3aXNlIGxldCBpdCBidWJibGVcclxuICAgICAgICAgICAgICAgICAgICBpZighKGVycm9yIGluc3RhbmNlb2YgTm9JbnRlZ3JhbEZvdW5kIHx8IGVycm9yIGluc3RhbmNlb2YgY29yZS5leGNlcHRpb25zLkRpdmlzaW9uQnlaZXJvKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ubyBzeW1ib2wgZm91bmQgc28gd2UgcmV0dXJuIHRoZSBpbnRlZ3JhbCBhZ2FpblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2ludGVncmF0ZScsIFtvcmlnaW5hbF9zeW1ib2wsIGR0XSk7XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlZmludDogZnVuY3Rpb24gKHN5bWJvbCwgZnJvbSwgdG8sIGR4KSB7XHJcbiAgICAgICAgICAgIGR4ID0gZHggfHwgJ3gnOyAvL21ha2UgeCB0aGUgZGVmYXVsdCB2YXJpYWJsZSBvZiBpbnRlZ3JhdGlvblxyXG4gICAgICAgICAgICB2YXIgZ2V0X3ZhbHVlID0gZnVuY3Rpb24gKGludGVncmFsLCB2YXJzLCBwb2ludCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShpbnRlZ3JhbCwgdmFycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pdCBmYWlsZWQgZm9yIHNvbWUgcmVhc29uIHNvIHJldHVybiB0aGUgbGltaXRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGltID0gX18uTGltaXQubGltaXQoaW50ZWdyYWwsIGR4LCBwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YXJzID0gY29yZS5VdGlscy52YXJpYWJsZXMoc3ltYm9sKSxcclxuICAgICAgICAgICAgICAgICAgICBoYXNUcmlnID0gc3ltYm9sLmhhc1RyaWcoKTtcclxuICAgICAgICAgICAgdmFyIHJldHZhbCwgaW50ZWdyYWw7XHJcblxyXG4gICAgICAgICAgICAvLyBGaXggIzU5MyAtIE9ubHkgYXNzdW1lIHRoZSBmaXJzdCB2YXJpYWJsZSBpZiBkeCBpcyBub3QgZGVmaW5lZC5cclxuICAgICAgICAgICAgaWYodmFycy5sZW5ndGggPT09IDEgJiYgIWR4KVxyXG4gICAgICAgICAgICAgICAgZHggPSB2YXJzWzBdO1xyXG5cclxuICAgICAgICAgICAgaWYoIWhhc1RyaWcpIHtcclxuICAgICAgICAgICAgICAgIGludGVncmFsID0gX18uaW50ZWdyYXRlKHN5bWJvbCwgZHgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZighaGFzVHJpZyAmJiAhaW50ZWdyYWwuaGFzSW50ZWdyYWwoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwcGVyID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEsIGI7XHJcbiAgICAgICAgICAgICAgICB1cHBlcltkeF0gPSB0bztcclxuICAgICAgICAgICAgICAgIGxvd2VyW2R4XSA9IGZyb207XHJcblxyXG4gICAgICAgICAgICAgICAgYSA9IGdldF92YWx1ZShpbnRlZ3JhbCwgdXBwZXIsIHRvLCBkeCk7XHJcbiAgICAgICAgICAgICAgICBiID0gZ2V0X3ZhbHVlKGludGVncmFsLCBsb3dlciwgZnJvbSwgZHgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zdWJ0cmFjdChhLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHZhcnMubGVuZ3RoID09PSAxICYmIGZyb20uaXNDb25zdGFudCgpICYmIHRvLmlzQ29uc3RhbnQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmID0gY29yZS5VdGlscy5idWlsZChzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbChjb3JlLk1hdGgyLm51bV9pbnRlZ3JhdGUoZiwgTnVtYmVyKGZyb20pLCBOdW1iZXIodG8pKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignZGVmaW50JywgW3N5bWJvbCwgZnJvbSwgdG8sIGR4XSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgTGltaXQ6IHtcclxuICAgICAgICAgICAgaW50ZXJ2YWw6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJ1t7MH0sIHsxfV0nLCBzdGFydCwgZW5kKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpdmVyZ2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uTGltaXQuaW50ZXJ2YWwoJy1JbmZpbml0eScsICdJbmZpbml0eScpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXZpZGU6IGZ1bmN0aW9uIChmLCBnLCB4LCBsaW0sIGRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICBpZihkZXB0aCsrID4gU2V0dGluZ3MubWF4X2xpbV9kZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmluID0gZi5jbG9uZSgpLCBnaW4gPSBnLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9CdXQgZmlyc3QgYSBsaXR0bGUgXCJjaGVhdGluZ1wiLiB4L3x4fCBlbmRzIHVwIGluIGFuIGluZmluaXRlIGxvb3Agc2luY2UgdGhlIGQvZHggfHh8IC0+IHgvfHh8XHJcbiAgICAgICAgICAgICAgICAvL1RvIGJyZWFrIHRoaXMgbG9vcCB3ZSBzaW1wbHkgcHJvdmlkZSB0aGUgYW5zd2VyLiBLZWVwIGluIG1pbmQgdGhhdCBjdXJyZW50bHkgbGltaXQgb25seSBwcm92aWRlc1xyXG4gICAgICAgICAgICAgICAgLy90aGUgdHdvLXNpZGVkIGxpbWl0LlxyXG4gICAgICAgICAgICAgICAgLy9Lbm93biBsaW1pdFxyXG4gICAgICAgICAgICAgICAgaWYoZy5mbmFtZSA9PT0gQUJTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBmLnNpZ24oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGltX3NpZ24gPSBsaW0uc2lnbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihsaW0uaXNJbmZpbml0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkobmV3IFN5bWJvbChzaWduKSwgbmV3IFN5bWJvbChsaW1fc2lnbikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGxpbS5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZtID0gXy5wYXJzZShmLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ20gPSBfLnBhcnNlKGcubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShfLm11bHRpcGx5KGZtLCBfXy5MaW1pdC5pbnRlcnZhbCgnLTEnLCAnMScpKSwgZ20pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBTdXBwb3J0IG1vcmUgbGltaXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fLkxpbWl0LmRpdmVyZ2VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpc0luZmluaXR5ID0gZnVuY3Rpb24gKEwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmlzVmVjdG9yKEwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBMLmVsZW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIUwuZWxlbWVudHNbaV0uaXNJbmZpbml0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTC5pc0luZmluaXR5O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZXF1YWxzID0gZnVuY3Rpb24gKEwsIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmlzVmVjdG9yKEwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEwuZXF1YWxzKHYpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW0xID0gZXZhbHVhdGUoX18uTGltaXQubGltaXQoZi5jbG9uZSgpLCB4LCBsaW0sIGRlcHRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbTIgPSBldmFsdWF0ZShfXy5MaW1pdC5saW1pdChnLmNsb25lKCksIHgsIGxpbSwgZGVwdGgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGluIGluZGV0ZXJtaW5hdGUgZm9ybSBhcHBseSBMJ0hvc3BpdGFsJ3MgcnVsZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRldGVybWluYXRlID0gaXNJbmZpbml0eShsaW0xKSAmJiBpc0luZmluaXR5KGxpbTIpIHx8IGVxdWFscyhsaW0xLCAwKSAmJiBlcXVhbHMobGltMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9wdWxsIHRoZSBkZXJpdmF0aXZlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGluZGV0ZXJtaW5hdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ0ID0gX18uZGlmZihmLmNsb25lKCksIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3QgPSBfXy5kaWZmKGcuY2xvbmUoKSwgeCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdF9zeW1ib2wgPSBfLmV4cGFuZChfLmRpdmlkZShmdCwgZ3QpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHRfc3ltYm9sLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gdF9zeW1ib2wuZ2V0RGVub20oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUoaW5kZXRlcm1pbmF0ZSlcclxuXHJcbiAgICAgICAgICAgICAgICAvL1JFTUVNQkVSOiBcclxuICAgICAgICAgICAgICAgIC8vLSAxL2Nvcyh4KVxyXG4gICAgICAgICAgICAgICAgLy9uLzAgaXMgc3RpbGwgcG9zc2libGUgc2luY2Ugd2Ugb25seSBjaGVja2VkIGZvciAwLzBcclxuICAgICAgICAgICAgICAgIHZhciBkZW5faXNfemVybyA9IGxpbTIuZXF1YWxzKDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBOdW1iZXIoZ2luLnBvd2VyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihsaW0uaXNDb25zdGFudCh0cnVlKSAmJiBkZW5faXNfemVybykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IFN5bWJvbC5pbmZpbml0eShjb3JlLlV0aWxzLmV2ZW4ocCkgJiYgbGltMS5sZXNzVGhhbigwKSA/IC0xIDogdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZGVuX2lzX3plcm8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5MaW1pdC5kaXZlcmdlcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUobGltMSwgbGltMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmV3cml0ZVRvTG9nOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHN5bWJvbC5wb3dlci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wb3cobmV3IFN5bWJvbCgnZScpLCBfLm11bHRpcGx5KHAsIF8uc3ltZnVuY3Rpb24oU2V0dGluZ3MuTE9HICsgJycsIFtzeW1ib2xdKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXRTdWJiZWQ6IGZ1bmN0aW9uIChmLCB4LCBsaW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICAvLzEuIHJld3JpdGUgRVggd2l0aCBiYXNlIGVcclxuICAgICAgICAgICAgICAgIGlmKGYuZ3JvdXAgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IF9fLnJld3JpdGVUb0xvZyhmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vMi4gdHJ5IHNpbXBsZSBzdWJzdGl0dXRpb25cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZi5zdWIoeCwgbGltKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL05vcGUuIE5vIGdvLCBzbyBqdXN0IHJldHVybiB0aGUgdW5zdWJiZWQgZnVuY3Rpb24gc28gd2UgY2FuIHRlc3QgdGhlIGxpbWl0IGluc3RlYWQuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc0ludGVydmFsOiBmdW5jdGlvbiAobGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLmlzVmVjdG9yKGxpbWl0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNDb252ZXJnZW50OiBmdW5jdGlvbiAobGltaXQpIHtcclxuICAgICAgICAgICAgICAgIC8vaXQncyBub3QgY29udmVyZ2VudCBpZiBpdCBsaWVzIG9uIHRoZSBpbnRlcnZhbCAtSW5maW5pdHkgdG8gSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIGlmKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0l0IGxpZXMgb24gdGhlIGludGVydmFsIC1JbmZpbml0eSB0byBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfXy5MaW1pdC5pc0ludGVydmFsKGxpbWl0KSAmJiBsaW1pdC5lbGVtZW50c1swXS5pc0luZmluaXR5ICYmIGxpbWl0LmVsZW1lbnRzWzFdLmlzSW5maW5pdHkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9XZSB3ZXJlbid0IGFibGUgdG8gY2FsY3VsYXRlIHRoZSBsaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC5jb250YWluc0Z1bmN0aW9uKCdsaW1pdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy9UaGVuIG5vXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy9JdCBpc1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsaW1pdDogZnVuY3Rpb24gKHN5bWJvbCwgeCwgbGltLCBkZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgLy9TaW1wbGlmeSB0aGUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNMaW5lYXIoKSAmJiBzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0FwcGx5IHN1bSBvZiBsaW1pdHNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGltaXQgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gXy5hZGQobGltaXQsIF9fLkxpbWl0LmxpbWl0KHMsIHgsIGxpbSwgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGNvcmUuQWxnZWJyYS5TaW1wbGlmeS5zaW1wbGlmeShzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlcHRoID0gZGVwdGggfHwgMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihkZXB0aCsrID4gU2V0dGluZ3MubWF4X2xpbV9kZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3N0b3JlIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgLy9zdHJpcCB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX2xpbWl0c1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy93ZSB0cnkgdGhlIHNpbXBsZXN0IG9wdGlvbiBmaXJzdCB3aGVyZSBjIGlzIHNvbWUgbGltaXRcclxuICAgICAgICAgICAgICAgICAgICAvL2xpbSBhIGFzIHgtPmMgPSBhIHdoZXJlIGMgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50W3hdID0gbGltO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xpbSB4IGFzIHgtPmMgPSBjIHdoZXJlIGNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ldmFsdWF0ZSB0aGUgZnVuY3Rpb24gYXQgdGhlIGdpdmVuIGxpbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IF8ucGFyc2Uoc3ltYm9sLnN1Yih4LCBsaW0pLCBwb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hIGNvbnN0YW50IG9yIGluZmluaXR5IGlzIGtub3duIHNvIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHQuaXNDb25zdGFudCh0cnVlKSB8fCB0LmlzSW5maW5pdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkgeyAvKk5vdGhpbmcuIE1heWJlIHdlIHRyaWVkIHRvIGRpdmlkZSBieSB6ZXJvLiovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXJldHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zcGxpdCB0aGUgc3ltYm9sIGluIHRoZSBudW1lcmF0b3IgYW5kIHRoZSBkZW5vbWluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IHN5bWJvbC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZW4gPSBzeW1ib2wuZ2V0RGVub20oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZW4uaXNDb25zdGFudCh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vV2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhIGxpbWl0IHNvIHdlIGdlbmVyYXRlIHRlc3RzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX2xpbWl0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NwZWVkIGJvb3N0IGZvciBleHBvbmVudGlhbHMgYnkgZGV0ZWN0aW5nIHBhdHRlcm5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gc3ltYm9sLmNsb25lKCkudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBzeW1ib2wucG93ZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9udW0gPSBmLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2RlbiA9IGYuZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gY29yZS5VdGlscy5kZWNvbXBvc2VfZm4oX2RlbiwgeCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RhcnQgZGV0ZWN0aW9uIG9mIHBhdHRlcm4gKHgvKHgrMSkpXnhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoX251bS5ncm91cCA9PT0gUyAmJiBfbnVtLm11bHRpcGxpZXIuaXNPbmUoKSAmJiBmbi5heC5ncm91cCA9PT0gUyAmJiBmbi5iLmlzQ29uc3RhbnQodHJ1ZSkgJiYgZm4uYS5pc09uZSgpICYmIGZuLmIuaXNDb25zdGFudCh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJygxL2VeKHswfSkpJywgZm4uYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbF8gPSBfXy5MaW1pdC5yZXdyaXRlVG9Mb2coc3ltYm9sLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIGJhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3cgPSBzeW1ib2xfLnBvd2VyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IHN5bWJvbF8uY2xvbmUoKS50b0xpbmVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbV9iYXNlID0gX18uTGltaXQubGltaXQoYmFzZSwgeCwgbGltLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGltX3BvdyA9IF9fLkxpbWl0LmxpbWl0KHBvdywgeCwgbGltLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBvdyhsaW1fYmFzZSwgbGltX3Bvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IEZOICYmIHN5bWJvbC5hcmdzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZhbHVhdGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NxdWVlemUgdGhlb3JlbSBsaW0gZihnKHgpKSA9IGxpbSBmKGxpbSBnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IF9fLkxpbWl0LmxpbWl0KHN5bWJvbC5hcmdzWzBdLCB4LCBsaW0sIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY29yZS5VdGlscy5pc1ZlY3RvcihhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgbGltaXQgb3ZlciB0aGF0IGludGVydmFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBhcmcubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUuYXJnc1swXSA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLkxpbWl0LmxpbWl0KF8uc3ltZnVuY3Rpb24oc3ltYm9sLmZuYW1lLCBbZV0pLCB4LCBsaW0sIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KG0sIHJldHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgYXJndW1lbnQgaXMgY29uc3RhbnQgdGhlbiB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYXJnLmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2RvdWJsZSBjaGVjayB0aGF0IGl0IGV2YWx1YXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gXy5zeW1mdW5jdGlvbihzeW1ib2wuZm5hbWUsIFthcmddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJpYWwgZXZhbHVhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZSh0cmlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXZhbHVhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB0cmlhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIGxpbWl0IGNvbnZlcmdlcy4gV2UnbGwgZGVhbCB3aXRoIG5vbi1jb252ZXJnZW50IG9uZXMgbGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF9fLkxpbWl0LmlzQ29udmVyZ2VudChhcmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmZuYW1lID09PSBMT0cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKGFyZy50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xpbSAtPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBTeW1ib2wuaW5maW5pdHkoKS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0luZmluaXR5JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBTeW1ib2wuaW5maW5pdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy1JbmZpbml0eSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gU3ltYm9sLmluZmluaXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZigoc3ltYm9sLmZuYW1lID09PSBDT1MgfHwgc3ltYm9sLmZuYW1lID09PSBTSU4pICYmIGxpbS5pc0luZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLkxpbWl0LmludGVydmFsKC0xLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZigoc3ltYm9sLmZuYW1lID09PSBUQU4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzX2FyZyA9IHN5bWJvbC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHNfYXJnLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHNfYXJnLmdldERlbm9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaSA9IG4udG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsaW0uaXNJbmZpbml0eSB8fCBwaS5lcXVhbHMoJ3BpJykgJiYgZC5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGRpdmVyZ2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmZuYW1lID09PSBTZXR0aW5ncy5GQUNUT1JJQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXJnLmlzSW5maW5pdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sLmluZmluaXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5wb3dlciA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZXNlIGZ1bmN0aW9ucyBhbHdheXMgY29udmVyZ2UgdG8gdGhlIGxpbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShzeW1ib2wsIHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlJ3JlIGRlYWxpbmcgd2l0aCAxL3hebiBidXQgcmVtZW1iZXIgdGhhdCBpbmZpbml0eSBoYXMgYWxyZWFkeSBiZWVuIGRlYWx0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dpdGggYnkgc3Vic3RpdHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmV2ZW4oc3ltYm9sLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXZlbiBwb3dlcnMgY29udmVyZ2UgdG8gaW5maW5pdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBTeW1ib2wuaW5maW5pdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vb2RkIG9uZXMgZG9uJ3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5MaW1pdC5kaXZlcmdlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBDQikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbTEsIGxpbTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9vcCB0aHJvdWdoIGFsbCB0aGUgc3ltYm9sc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RodXMgPT4gbGltIGYqZypoID0gbGltIChmKmcpKmggPSAobGltIGYqZykqKGxpbSBoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N5bWJvbHMgb2YgbG93ZXIgZ3JvdXBzIGFyZSBnZW5lcmFsbHkgZWFzaWVyIHRvIGRpZmZlcmVudGlhdGVlIHNvIGdldCB0aGVtIHRvIHRoZSByaWdodCBieSBmaXJzdCBzb3J0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gc3ltYm9sLmNvbGxlY3RTeW1ib2xzKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZ3JvdXAgLSBiLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gc3ltYm9scy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxjdWxhdGUgdGhlIGZpcnN0IGxpbWl0IHNvIHdlIGNhbiBrZWVwIGdvaW5nIGRvd24gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltMSA9IGV2YWx1YXRlKF9fLkxpbWl0LmxpbWl0KGYsIHgsIGxpbSwgZGVwdGgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVkdWNlcyBhbGwgdGhlIGxpbWl0cyBvbmUgYXQgYSB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgc2Vjb25kIGxpbWl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZyA9IHN5bWJvbHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgbGltaXQgb2YgZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltMiA9IGV2YWx1YXRlKF9fLkxpbWl0LmxpbWl0KGcsIHgsIGxpbSwgZGVwdGgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSBsaW1pdCBpcyBpbiBpbmRldGVybWluYXRlIGZvcm0gYXBsbHkgTCdIb3NwaXRhbCBieSBpbnZlcnRpbmcgZyBhbmQgdGhlbiBmLygxL2cpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigobGltMS5pc0luZmluaXR5IHx8ICFfXy5MaW1pdC5pc0NvbnZlcmdlbnQobGltMSkgJiYgbGltMi5lcXVhbHMoMCkgfHwgbGltMS5lcXVhbHMoMCkgJiYgX18uTGltaXQuaXNDb252ZXJnZW50KGxpbTIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGcuY29udGFpbnNGdW5jdGlvbihMT0cpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3dhcCB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSBbZiwgZiA9IGddWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ludmVydCB0aGUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5pbnZlcnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvZHVjdCBvZiBpbmZpbml0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobGltMS5pc0luZmluaXR5ICYmIGxpbTIuaXNJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW0xID0gU3ltYm9sLmluZmluaXR5KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbTEgPSBfXy5MaW1pdC5kaXZpZGUoZiwgZywgeCwgbGltLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9saW0gZipnID0gKGxpbSBmKSoobGltIGcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltMSA9IF8ubXVsdGlwbHkobGltMSwgbGltMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgZipnIGVxdWFsIGYgYW5kIGggZXF1YWwgZyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gXy5tdWx0aXBseShmLCBnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Eb25lLCBsaW0xIGlzIHRoZSBsaW1pdCB3ZSdyZSBsb29raW5nIGZvciAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGxpbTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9saW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFzeW1ib2wuaXNMaW5lYXIoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQXBwbHkgbGltIGYrZyA9IChsaW0gZikrKGxpbSBnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbHMgPSBzeW1ib2wuY29sbGVjdFN5bWJvbHMoKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5ncm91cCAtIGEuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9zeW1ib2xzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQW5hbHl6ZSB0aGUgZnVuY3Rpb25zIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbnMgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gc3ltYm9scy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBzeW1ib2xzW2ldLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW0uZ3JvdXAgPT09IEZOIHx8IHN5bS5ncm91cCA9PT0gQ0IgJiYgc3ltLmhhc0Z1bmMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZucyA9IF8uYWRkKGZucywgc3ltKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3ltYm9scy5wdXNoKHN5bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N5bWJvbHMudW5zaGlmdChmbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHN1cmUgdGhhdCB3ZSBkaWRuJ3QganVzdCByZXBhY2thZ2UgdGhlIGV4YWN0IHNhbWUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKF9zeW1ib2xzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9scyA9IF9zeW1ib2xzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gc3ltYm9scy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBzeW1ib2xzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgYWRkaXRpb24gb2YgdGhlIGxpbWl0cyBpcyB1bmRlZmluZWQgdGhlbiB0aGUgbGltaXQgZGl2ZXJnZXMgc28gcmV0dXJuIC1pbmZpbml0eSB0byBpbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbGltID0gX18uTGltaXQubGltaXQoc3ltLCB4LCBsaW0sIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbGltID0gX18uTGltaXQuZGl2ZXJnZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX2xpbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVwdGgrKyA+IFNldHRpbmdzLm1heF9saW1fZGVwdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gX18uTGltaXQubGltaXQoX18uZGlmZihzeW1ib2wsIHgpLCB4LCBsaW0sIGRlcHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF9fLkxpbWl0LmRpdmlkZShudW0sIGRlbiwgeCwgbGltLCBkZXB0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgd2Ugc3RpbGwgZG9uJ3QgaGF2ZSBhIHNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXJldHZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gaXQgc3ltYm9saWNhbGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2xpbWl0JywgW3N5bWJvbCwgeCwgbGltXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBhbGwgZWxzZSBmYWlscyByZXR1cm4gdGhlIHN5bWJvbGljIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignbGltaXQnLCBbc3ltYm9sLCB4LCBsaW1dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShtLCByZXR2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBGcmVzbmVsOiB7XHJcbiAgICAgICAgICAgIFM6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBpZih4LmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uZGVmaW50KF8ucGFyc2UoJ3NpbihwaSp4XjIvMiknKSwgU3ltYm9sKDApLCB4LCAneCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ1MnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBDOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgaWYoeC5pc0NvbnN0YW50KHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLmRlZmludChfLnBhcnNlKCdjb3MocGkqeF4yLzIpJyksIFN5bWJvbCgwKSwgeCwgJ3gnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdDJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbmVyZGFtZXIucmVnaXN0ZXIoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2RpZmYnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiBbMSwgM10sXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uZGlmZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnc3VtJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogNCxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5zdW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3Byb2R1Y3QnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiA0LFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLnByb2R1Y3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2ludGVncmF0ZScsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IFsxLCAyXSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5pbnRlZ3JhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2RlZmludCcsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IFszLCA0XSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5kZWZpbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ1MnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAxLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLkZyZXNuZWwuUztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnQycsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDEsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uRnJlc25lbC5DO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IFszLCA0XSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5MaW1pdC5saW1pdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIF0pO1xyXG4gICAgLy9saW5rIHJlZ2lzdGVyZWQgZnVuY3Rpb25zIGV4dGVybmFsbHlcclxuICAgIG5lcmRhbWVyLmFwaSgpO1xyXG5cclxufSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/nerdamer/Calculus.js\n");

/***/ }),

/***/ "./node_modules/nerdamer/Extra.js":
/*!****************************************!*\
  !*** ./node_modules/nerdamer/Extra.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module */\r\n\r\nif(true) {\r\n    var nerdamer = __webpack_require__(/*! ./nerdamer.core.js */ \"./node_modules/nerdamer/nerdamer.core.js\");\r\n    __webpack_require__(/*! ./Calculus */ \"./node_modules/nerdamer/Calculus.js\");\r\n    __webpack_require__(/*! ./Algebra */ \"./node_modules/nerdamer/Algebra.js\");\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Symbol = core.Symbol,\r\n            format = core.Utils.format,\r\n            isVector = core.Utils.isVector,\r\n            isArray = core.Utils.isArray,\r\n            Vector = core.Vector,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            FN = core.groups.FN;\r\n    core.Settings.Laplace_integration_depth = 40;\r\n\r\n\r\n    Symbol.prototype.findFunction = function (fname) {\r\n        //this is what we're looking for\r\n        if(this.group === FN && this.fname === fname)\r\n            return this.clone();\r\n        var found;\r\n        if(this.symbols)\r\n            for(var x in this.symbols) {\r\n                found = this.symbols[x].findFunction(fname);\r\n                if(found)\r\n                    break;\r\n            }\r\n\r\n        return found;\r\n    };\r\n\r\n    var __ = core.Extra = {\r\n        version: '1.4.2',\r\n        //http://integral-table.com/downloads/LaplaceTable.pdf\r\n        //Laplace assumes all coefficients to be positive\r\n        LaPlace: {\r\n            //Using: integral_0^oo f(t)*e^(-s*t) dt\r\n            transform: function (symbol, t, s) {\r\n                symbol = symbol.clone();\r\n\r\n                t = t.toString();\r\n                //First try a lookup for a speed boost\r\n                symbol = Symbol.unwrapSQRT(symbol, true);\r\n                var retval,\r\n                        coeff = symbol.stripVar(t),\r\n                        g = symbol.group;\r\n\r\n                symbol = _.divide(symbol, coeff.clone());\r\n\r\n                if(symbol.isConstant() || !symbol.contains(t, true)) {\r\n                    retval = _.parse(format('({0})/({1})', symbol, s));\r\n                }\r\n                else if(g === S && core.Utils.isInt(symbol.power)) {\r\n                    var n = String(symbol.power);\r\n                    retval = _.parse(format('factorial({0})/({1})^({0}+1)', n, s));\r\n                }\r\n                else if(symbol.group === S && symbol.power.equals(1 / 2)) {\r\n                    retval = _.parse(format('sqrt(pi)/(2*({0})^(3/2))', s));\r\n                }\r\n                else if(symbol.isComposite()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.LaPlace.transform(x, t, s));\r\n                    }, true);\r\n                }\r\n                else if(symbol.isE() && (symbol.power.group === S || symbol.power.group === CB)) {\r\n                    var a = symbol.power.stripVar(t);\r\n                    retval = _.parse(format('1/(({1})-({0}))', a, s));\r\n                }\r\n                else {\r\n                    var fns = ['sin', 'cos', 'sinh', 'cosh'];\r\n                    //support for symbols in fns with arguments in the form a*t or n*t where a = symbolic and n = Number\r\n                    if(symbol.group === FN && fns.indexOf(symbol.fname) !== -1 && (symbol.args[0].group === S || symbol.args[0].group === CB)) {\r\n                        var a = symbol.args[0].stripVar(t);\r\n\r\n                        switch(symbol.fname) {\r\n                            case 'sin':\r\n                                retval = _.parse(format('({0})/(({1})^2+({0})^2)', a, s));\r\n                                break;\r\n                            case 'cos':\r\n                                retval = _.parse(format('({1})/(({1})^2+({0})^2)', a, s));\r\n                                break;\r\n                            case 'sinh':\r\n                                retval = _.parse(format('({0})/(({1})^2-({0})^2)', a, s));\r\n                                break;\r\n                            case 'cosh':\r\n                                retval = _.parse(format('({1})/(({1})^2-({0})^2)', a, s));\r\n                                break;\r\n                        }\r\n\r\n                    }\r\n                    else {\r\n                        //Try to integrate for a solution\r\n                        //we need at least the Laplace integration depth\r\n                        var depth_is_lower = core.Settings.integration_depth < core.Settings.Laplace_integration_depth;\r\n\r\n                        if(depth_is_lower) {\r\n                            var integration_depth = core.Settings.integration_depth; //save the depth\r\n                            core.Settings.integration_depth = core.Settings.Laplace_integration_depth; //transforms need a little more room\r\n                        }\r\n\r\n                        core.Utils.block('PARSE2NUMBER', function () {\r\n                            var u = t;\r\n                            var sym = symbol.sub(t, u);\r\n                            var integration_expr = _.parse('e^(-' + s + '*' + u + ')*' + sym);\r\n                            retval = core.Calculus.integrate(integration_expr, u);\r\n                            if(retval.hasIntegral())\r\n                                return _.symfunction('laplace', arguments);\r\n//                                _.error('Unable to compute transform');\r\n                            retval = retval.sub(t, 0);\r\n                            retval = _.expand(_.multiply(retval, new Symbol(-1)));\r\n                            retval = retval.sub(u, t);\r\n                        }, false);\r\n\r\n                        retval = core.Utils.block('PARSE2NUMBER', function () {\r\n                            return _.parse(retval);\r\n                        }, true);\r\n\r\n                        if(depth_is_lower)//put the integration depth as it was\r\n                            core.Settings.integration_depth = integration_depth;\r\n                    }\r\n\r\n                }\r\n\r\n                return _.multiply(retval, coeff);\r\n            },\r\n            inverse: function (symbol, s_, t) {\r\n                var input_symbol = symbol.clone();\r\n                return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                    //expand and get partial fractions\r\n                    if(symbol.group === CB) {\r\n                        symbol = core.Algebra.PartFrac.partfrac(_.expand(symbol), s_);\r\n                    }\r\n\r\n                    if(symbol.group === S || symbol.group === CB || symbol.isComposite()) {\r\n                        var finalize = function () {\r\n                            //put back the numerator\r\n                            retval = _.multiply(retval, num);\r\n                            retval.multiplier = retval.multiplier.multiply(symbol.multiplier);\r\n                            //put back a\r\n                            retval = _.divide(retval, f.a);\r\n                        };\r\n                        var num, den, s, retval, f, p, m, den_p, fe;\r\n                        //remove the multiplier\r\n                        m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        //get the numerator and denominator\r\n                        num = symbol.getNum();\r\n                        den = symbol.getDenom().toUnitMultiplier();\r\n\r\n                        //TODO: Make it so factor doesn't destroy pi\r\n                        //num = core.Algebra.Factor.factor(symbol.getNum());\r\n                        //den = core.Algebra.Factor.factor(symbol.getDenom().invert(null, true));\r\n\r\n                        if(den.group === CP) {\r\n                            den_p = den.power.clone();\r\n                            den.toLinear();\r\n                        }\r\n                        else {\r\n                            den_p = new core.Frac(1);\r\n                        }\r\n\r\n                        //convert s to a string\r\n                        s = s_.toString();\r\n                        //split up the denominator if in the form ax+b\r\n                        f = core.Utils.decompose_fn(den, s, true);\r\n                        //move the multiplier to the numerator\r\n                        fe = core.Utils.decompose_fn(_.expand(num.clone()), s, true);\r\n                        num.multiplier = num.multiplier.multiply(m);\r\n                        //store the parts in variables for easy recognition \r\n                        //check if in the form t^n where n = integer\r\n                        if((den.group === S || den.group === CB) && f.x.value === s && f.b.equals(0) && core.Utils.isInt(f.x.power)) {\r\n                            var fact, p;\r\n                            p = f.x.power - 1;\r\n                            fact = core.Math2.factorial(p);\r\n                            //  n!/s^(n-1)\r\n                            retval = _.divide(_.pow(t, new Symbol(p)), new Symbol(fact));\r\n                            //wrap it up\r\n                            finalize();\r\n                        }\r\n                        else if(den.group === CP && den_p.equals(1)) {\r\n                            if(f.x.group === core.groups.PL && core.Algebra.degree(den).equals(2)) {\r\n                                // Possibly in the form 1/(s^2+2*s+1)\r\n                                // Try factoring to get it in a more familiar form{\r\n                                // Apply inverse of F(s-a)\r\n                                var completed = core.Algebra.sqComplete(den, s);\r\n                                var u = core.Utils.getU(den);\r\n                                // Get a for the function above\r\n                                var a = core.Utils.decompose_fn(completed.a, s, true).b;\r\n                                var tf = __.LaPlace.inverse(_.parse(`1/((${u})^2+(${completed.c}))`), u, t);\r\n                                retval = _.multiply(tf, _.parse(`(${m})*e^(-(${a})*(${t}))`));\r\n                            }\r\n                            else {\r\n                                // a/(b*s-c) -> ae^(-bt)\r\n                                if(f.x.isLinear() && !num.contains(s)) {\r\n                                    t = _.divide(t, f.a.clone());\r\n\r\n                                    // Don't add factorial of one or zero\r\n                                    var p = den_p - 1;\r\n                                    var fact = p === 0 || p === 1 ? '1' : `(${den_p}-1)!`\r\n                                    retval = _.parse(format('(({0})^({3}-1)*e^(-(({2})*({0}))/({1})))/(({4})*({1})^({3}))', t, f.a, f.b, den_p, fact));\r\n                                    //wrap it up\r\n                                    finalize();\r\n                                }\r\n                                else {\r\n                                    if(f.x.group === S && f.x.power.equals(2)) {\r\n                                        if(!num.contains(s)) {\r\n                                            retval = _.parse(format('(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/sqrt(({2})*({3}))', t, num, f.a, f.b));\r\n                                        }\r\n                                        // a*s/(b*s^2+c^2)\r\n                                        else {\r\n                                            var a = new Symbol(1);\r\n                                            if(num.group === CB) {\r\n                                                var new_num = new Symbol(1);\r\n                                                num.each(function (x) {\r\n                                                    if(x.contains(s))\r\n                                                        new_num = _.multiply(new_num, x);\r\n                                                    else\r\n                                                        a = _.multiply(a, x);\r\n                                                });\r\n                                                num = new_num;\r\n                                            }\r\n\r\n                                            //we need more information about the denominator to decide\r\n                                            var f2 = core.Utils.decompose_fn(num, s, true);\r\n                                            var fn1, fn2, a_has_sin, b_has_cos, a_has_cos, b_has_sin;\r\n                                            fn1 = f2.a;\r\n                                            fn2 = f2.b;\r\n                                            a_has_sin = fn1.containsFunction('sin');\r\n                                            a_has_cos = fn1.containsFunction('cos');\r\n                                            b_has_cos = fn2.containsFunction('cos');\r\n                                            b_has_sin = fn2.containsFunction('sin');\r\n                                            if(f2.x.value === s && f2.x.isLinear() && !((a_has_sin && b_has_cos) || (a_has_cos || b_has_sin))) {\r\n                                                retval = _.parse(format('(({1})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})', t, f2.a, f.a, f.b));\r\n                                            }\r\n                                            else {\r\n                                                if(a_has_sin && b_has_cos) {\r\n                                                    var sin, cos;\r\n                                                    sin = fn1.findFunction('sin');\r\n                                                    cos = fn2.findFunction('cos');\r\n                                                    //who has the s?\r\n                                                    if(sin.args[0].equals(cos.args[0]) && !sin.args[0].contains(s)) {\r\n                                                        var b, c, d, e;\r\n                                                        b = _.divide(fn2, cos.toUnitMultiplier()).toString();\r\n                                                        c = sin.args[0].toString();\r\n                                                        d = f.b;\r\n                                                        e = _.divide(fn1, sin.toUnitMultiplier());\r\n                                                        exp = '(({1})*({2})*cos({3})*sin(sqrt({4})*({0})))/sqrt({4})+({1})*sin({3})*({5})*cos(sqrt({4})*({0}))';\r\n                                                        retval = _.parse(format(exp, t, a, b, c, d, e));\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else if(f.x.power.num && f.x.power.num.equals(3) && f.x.power.den.equals(2) && num.contains('sqrt(pi)') && !num.contains(s) && num.isLinear()) {\r\n                            var b = _.divide(num.clone(), _.parse('sqrt(pi)'));\r\n                            retval = _.parse(format('(2*({2})*sqrt({0}))/({1})', t, f.a, b, num));\r\n                        }\r\n                        else if(den_p.equals(2) && f.x.power.equals(2)) {\r\n                            var a, d, exp;\r\n                            if(!num.contains(s)) {\r\n                                a = _.divide(num, new Symbol(2));\r\n                                exp = '(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({3})*sqrt(({2})*({3})))-(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*({3}))';\r\n                                retval = _.parse(format(exp, t, a, f.a, f.b));\r\n                            }\r\n                            else {\r\n                                // Decompose the numerator to check value of s\r\n                                f2 = core.Utils.decompose_fn(_.expand(num.clone()), s, true);\r\n                                if(f2.x.isComposite()) {\r\n                                    var s_terms = [];\r\n                                    //first collect the factors e.g. (a)(bx)(cx^2+d)\r\n                                    var symbols = num.collectSymbols(function (x) {\r\n                                        x = Symbol.unwrapPARENS(x);\r\n                                        var t = core.Utils.decompose_fn(x, s, true);\r\n                                        t.symbol = x;\r\n                                        return t;\r\n                                    }).\r\n                                            //then sort them by power hightest to lowest\r\n                                            sort(function (a, b) {\r\n                                                var p1, p2;\r\n                                                p1 = a.x.value !== s ? 0 : a.x.power;\r\n                                                p2 = b.x.value !== s ? 0 : b.x.power;\r\n                                                return p2 - p1;\r\n                                            });\r\n                                    a = new Symbol(-1);\r\n                                    // Grab only the ones which have s\r\n                                    for(var i = 0; i < symbols.length; i++) {\r\n                                        var fc = symbols[i];\r\n                                        if(fc.x.value === s)\r\n                                            s_terms.push(fc);\r\n                                        else\r\n                                            a = _.multiply(a, fc.symbol);\r\n                                    }\r\n                                    // The following 2 assumptions are made\r\n                                    // 1. since the numerator was factored above then each s_term has a unique power\r\n                                    // 2. because the terms are sorted by descending powers then the first item \r\n                                    //    has the highest power\r\n                                    // We can now check for the next type s(s^2-a^2)/(s^2+a^2)^2\r\n                                    if(s_terms[0].x.power.equals(2) && s_terms[1].x.power.equals(1) && s_terms[1].b.equals(0) && !s_terms[0].b.equals(0)) {\r\n                                        b = s_terms[0].a.negate();\r\n                                        exp = '-(({1})*({2})*({5})*({0})*sin((sqrt(({4})*({5}))*({0}))/({4})))/' +\r\n                                                '(2*({4})^2*sqrt(({4})*({5})))-(({1})*({3})*({0})*sin((sqrt(({4})*({5}))*({0}))/({4})))' +\r\n                                                '/(2*({4})*sqrt(({4})*({5})))+(({1})*({2})*cos((sqrt(({4})*({5}))*({0}))/({4})))/({4})^2';\r\n                                        retval = _.parse(format(exp, t, a, b, s_terms[0].b, f.a, f.b));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    if(f2.x.isLinear()) {\r\n                                        a = _.divide(f2.a, new Symbol(2));\r\n                                        exp = '(({1})*({0})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*sqrt(({2})*({3})))';\r\n                                        retval = _.parse(format(exp, t, a, f.a, f.b));\r\n                                    }\r\n                                    else if(f2.x.power.equals(2)) {\r\n                                        if(f2.b.equals(0)) {\r\n                                            a = _.divide(f2.a, new Symbol(2));\r\n                                            exp = '(({1})*sin((sqrt(({2})*({3}))*({0}))/({2})))/(({2})*sqrt(({2})*({3})))+(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})^2';\r\n                                            retval = _.parse(format(exp, t, a, f.a, f.b));\r\n                                        }\r\n                                        else {\r\n                                            a = _.divide(f2.a, new Symbol(2));\r\n                                            d = f2.b.negate();\r\n                                            exp = '-((({2})*({4})-2*({1})*({3}))*sin((sqrt(({2})*({3}))*({0}))/({2})))/(2*({2})*({3})*sqrt(({2})*({3})))+' +\r\n                                                    '(({4})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/(2*({2})*({3}))+(({1})*({0})*cos((sqrt(({2})*({3}))*({0}))/({2})))/({2})^2';\r\n                                            retval = _.parse(format(exp, t, a, f.a, f.b, d));\r\n\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else if(symbol.isComposite()) {\r\n                            // 1/(s+1)^2\r\n                            if(den_p.equals(2) && f.x.group === S) {\r\n                                retval = _.parse(`(${m})*(${t})*e^(-(${f.b})*(${t}))`);\r\n                            }\r\n                            else {\r\n                                retval = new Symbol(0);\r\n\r\n                                symbol.each(function (x) {\r\n                                    retval = _.add(retval, __.LaPlace.inverse(x, s_, t));\r\n                                }, true);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!retval) {\r\n                        retval = _.symfunction('ilt', [input_symbol, s_, t]);\r\n                    }\r\n\r\n                    return retval;\r\n                }, true);\r\n            }\r\n        },\r\n        Statistics: {\r\n            frequencyMap: function (arr) {\r\n                var map = {};\r\n                //get the frequency map\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    var e = arr[i],\r\n                            key = e.toString();\r\n                    if(!map[key]) //default it to zero\r\n                        map[key] = 0;\r\n                    map[key]++; //increment\r\n                }\r\n                return map;\r\n            },\r\n            sort: function (arr) {\r\n                return arr.sort(function (a, b) {\r\n                    if(!a.isConstant() || !b.isConstant())\r\n                        _.error('Unable to sort! All values must be numeric');\r\n                    return a.multiplier.subtract(b.multiplier);\r\n                });\r\n            },\r\n            count: function (arr) {\r\n                return new Symbol(arr.length);\r\n            },\r\n            sum: function (arr, x_) {\r\n                var sum = new Symbol(0);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    var xi = arr[i].clone();\r\n                    if(x_) {\r\n                        sum = _.add(_.pow(_.subtract(xi, x_.clone()), new Symbol(2)), sum);\r\n                    }\r\n                    else\r\n                        sum = _.add(xi, sum);\r\n                }\r\n\r\n                return sum;\r\n            },\r\n            mean: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.mean.apply(this, args[0].elements);\r\n                return  _.divide(__.Statistics.sum(args), __.Statistics.count(args));\r\n            },\r\n            median: function () {\r\n                var args = [].slice.call(arguments), retval;\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.median.apply(this, args[0].elements);\r\n                try {\r\n                    var sorted = __.Statistics.sort(args);\r\n                    var l = args.length;\r\n                    if(core.Utils.even(l)) {\r\n                        var mid = l / 2;\r\n                        retval = __.Statistics.mean(sorted[mid - 1], sorted[mid]);\r\n                    }\r\n                    else\r\n                        retval = sorted[Math.floor(l / 2)];\r\n                }\r\n                catch(e) {\r\n                    retval = _.symfunction('median', args);\r\n                }\r\n                return retval;\r\n            },\r\n            mode: function () {\r\n                var args = [].slice.call(arguments),\r\n                        retval;\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.mode.apply(this, args[0].elements);\r\n\r\n                var map = __.Statistics.frequencyMap(args);\r\n\r\n                //the mode of 1 item is that item as per issue #310 (verified by Happypig375). \r\n                if(core.Utils.keys(map).length === 1)\r\n                    retval = args[0];\r\n                else {\r\n                    //invert by arraning them according to their frequency\r\n                    var inverse = {};\r\n                    for(var x in map) {\r\n                        var freq = map[x];\r\n                        //check if it's in the inverse already\r\n                        if(!(freq in inverse))\r\n                            inverse[freq] = x;\r\n                        else {\r\n                            var e = inverse[freq];\r\n                            //if it's already an array then just add it\r\n                            if(isArray(e))\r\n                                e.push(x);\r\n                            //convert it to and array\r\n                            else\r\n                                inverse[freq] = [x, inverse[freq]];\r\n                        }\r\n                    }\r\n                    //the keys now represent the maxes. We want the max of those keys\r\n                    var max = inverse[Math.max.apply(null, core.Utils.keys(inverse))];\r\n                    //check it's an array. If it is then map over the results and convert \r\n                    //them to Symbol\r\n                    if(isArray(max)) {\r\n                        retval = _.symfunction('mode', max.sort());\r\n                    }\r\n                    else\r\n                        retval = _.parse(max);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            gVariance: function (k, args) {\r\n                var x_ = __.Statistics.mean.apply(__.Statistics, args),\r\n                        sum = __.Statistics.sum(args, x_);\r\n                return _.multiply(k, sum);\r\n            },\r\n            variance: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.variance.apply(this, args[0].elements);\r\n                var k = _.divide(new Symbol(1), __.Statistics.count(args));\r\n                return __.Statistics.gVariance(k, args);\r\n            },\r\n            sampleVariance: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.sampleVariance.apply(this, args[0].elements);\r\n\r\n                var k = _.divide(new Symbol(1), _.subtract(__.Statistics.count(args), new Symbol(1)));\r\n                return __.Statistics.gVariance(k, args);\r\n            },\r\n            standardDeviation: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.standardDeviation.apply(this, args[0].elements);\r\n                return _.pow(__.Statistics.variance.apply(__.Statistics, args), new Symbol(1 / 2));\r\n            },\r\n            sampleStandardDeviation: function () {\r\n                var args = [].slice.call(arguments);\r\n                //handle arrays\r\n                if(isVector(args[0]))\r\n                    return __.Statistics.sampleStandardDeviation.apply(this, args[0].elements);\r\n                return _.pow(__.Statistics.sampleVariance.apply(__.Statistics, args), new Symbol(1 / 2));\r\n            },\r\n            zScore: function (x, mean, stdev) {\r\n                return _.divide(_.subtract(x, mean), stdev);\r\n            }\r\n        },\r\n        Units: {\r\n            table: {\r\n                foot: '12 inch',\r\n                meter: '100 cm',\r\n                decimeter: '10 cm',\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'laplace',\r\n            visible: true,\r\n            numargs: 3,\r\n            build: function () {\r\n                return __.LaPlace.transform;\r\n            }\r\n        },\r\n        {\r\n            name: 'ilt',\r\n            visible: true,\r\n            numargs: 3,\r\n            build: function () {\r\n                return __.LaPlace.inverse;\r\n            }\r\n        },\r\n        //statistical\r\n        {\r\n            name: 'mean',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.mean;\r\n            }\r\n        },\r\n        {\r\n            name: 'median',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.median;\r\n            }\r\n        },\r\n        {\r\n            name: 'mode',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.mode;\r\n            }\r\n        },\r\n        {\r\n            name: 'smpvar',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.sampleVariance;\r\n            }\r\n        },\r\n        {\r\n            name: 'variance',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.variance;\r\n            }\r\n        },\r\n        {\r\n            name: 'smpstdev',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.sampleStandardDeviation;\r\n            }\r\n        },\r\n        {\r\n            name: 'stdev',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.Statistics.standardDeviation;\r\n            }\r\n        },\r\n        {\r\n            name: 'zscore',\r\n            visible: true,\r\n            numargs: 3,\r\n            build: function () {\r\n                return __.Statistics.zScore;\r\n            }\r\n        }\r\n    ]);\r\n\r\n    //link registered functions externally\r\n    nerdamer.api();\r\n}());\r\n\r\n// Added for all.min.js\r\nif(true) {\r\n    module.exports = nerdamer;\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmVyZGFtZXIvRXh0cmEuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92YW5pbGxhLWludGVncmF0aW9uLTJkLy4vbm9kZV9tb2R1bGVzL25lcmRhbWVyL0V4dHJhLmpzPzNjYTMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQXV0aG9yIDogTWFydGluIERvbmtcclxuICogV2Vic2l0ZSA6IGh0dHA6Ly93d3cubmVyZGFtZXIuY29tXHJcbiAqIEVtYWlsIDogbWFydGluLnIuZG9ua0BnbWFpbC5jb21cclxuICogTGljZW5zZSA6IE1JVFxyXG4gKiBTb3VyY2UgOiBodHRwczovL2dpdGh1Yi5jb20vamlnZ3pzb24vbmVyZGFtZXJcclxuICovXHJcblxyXG4vKiBnbG9iYWwgbW9kdWxlICovXHJcblxyXG5pZigodHlwZW9mIG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB2YXIgbmVyZGFtZXIgPSByZXF1aXJlKCcuL25lcmRhbWVyLmNvcmUuanMnKTtcclxuICAgIHJlcXVpcmUoJy4vQ2FsY3VsdXMnKTtcclxuICAgIHJlcXVpcmUoJy4vQWxnZWJyYScpO1xyXG59XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIGNvcmUgPSBuZXJkYW1lci5nZXRDb3JlKCksXHJcbiAgICAgICAgICAgIF8gPSBjb3JlLlBBUlNFUixcclxuICAgICAgICAgICAgU3ltYm9sID0gY29yZS5TeW1ib2wsXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvcmUuVXRpbHMuZm9ybWF0LFxyXG4gICAgICAgICAgICBpc1ZlY3RvciA9IGNvcmUuVXRpbHMuaXNWZWN0b3IsXHJcbiAgICAgICAgICAgIGlzQXJyYXkgPSBjb3JlLlV0aWxzLmlzQXJyYXksXHJcbiAgICAgICAgICAgIFZlY3RvciA9IGNvcmUuVmVjdG9yLFxyXG4gICAgICAgICAgICBTID0gY29yZS5ncm91cHMuUyxcclxuICAgICAgICAgICAgRVggPSBjb3JlLmdyb3Vwcy5FWCxcclxuICAgICAgICAgICAgQ1AgPSBjb3JlLmdyb3Vwcy5DUCxcclxuICAgICAgICAgICAgQ0IgPSBjb3JlLmdyb3Vwcy5DQixcclxuICAgICAgICAgICAgRk4gPSBjb3JlLmdyb3Vwcy5GTjtcclxuICAgIGNvcmUuU2V0dGluZ3MuTGFwbGFjZV9pbnRlZ3JhdGlvbl9kZXB0aCA9IDQwO1xyXG5cclxuXHJcbiAgICBTeW1ib2wucHJvdG90eXBlLmZpbmRGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbmFtZSkge1xyXG4gICAgICAgIC8vdGhpcyBpcyB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yXHJcbiAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gRk4gJiYgdGhpcy5mbmFtZSA9PT0gZm5hbWUpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgdmFyIGZvdW5kO1xyXG4gICAgICAgIGlmKHRoaXMuc3ltYm9scylcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLnN5bWJvbHNbeF0uZmluZEZ1bmN0aW9uKGZuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmKGZvdW5kKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9fID0gY29yZS5FeHRyYSA9IHtcclxuICAgICAgICB2ZXJzaW9uOiAnMS40LjInLFxyXG4gICAgICAgIC8vaHR0cDovL2ludGVncmFsLXRhYmxlLmNvbS9kb3dubG9hZHMvTGFwbGFjZVRhYmxlLnBkZlxyXG4gICAgICAgIC8vTGFwbGFjZSBhc3N1bWVzIGFsbCBjb2VmZmljaWVudHMgdG8gYmUgcG9zaXRpdmVcclxuICAgICAgICBMYVBsYWNlOiB7XHJcbiAgICAgICAgICAgIC8vVXNpbmc6IGludGVncmFsXzBeb28gZih0KSplXigtcyp0KSBkdFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChzeW1ib2wsIHQsIHMpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHQgPSB0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAvL0ZpcnN0IHRyeSBhIGxvb2t1cCBmb3IgYSBzcGVlZCBib29zdFxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gU3ltYm9sLnVud3JhcFNRUlQoc3ltYm9sLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmID0gc3ltYm9sLnN0cmlwVmFyKHQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gc3ltYm9sLmdyb3VwO1xyXG5cclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZGl2aWRlKHN5bWJvbCwgY29lZmYuY2xvbmUoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSB8fCAhc3ltYm9sLmNvbnRhaW5zKHQsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJyh7MH0pLyh7MX0pJywgc3ltYm9sLCBzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcgPT09IFMgJiYgY29yZS5VdGlscy5pc0ludChzeW1ib2wucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBTdHJpbmcoc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnZmFjdG9yaWFsKHswfSkvKHsxfSleKHswfSsxKScsIG4sIHMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBTICYmIHN5bWJvbC5wb3dlci5lcXVhbHMoMSAvIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJ3NxcnQocGkpLygyKih7MH0pXigzLzIpKScsIHMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgX18uTGFQbGFjZS50cmFuc2Zvcm0oeCwgdCwgcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNFKCkgJiYgKHN5bWJvbC5wb3dlci5ncm91cCA9PT0gUyB8fCBzeW1ib2wucG93ZXIuZ3JvdXAgPT09IENCKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gc3ltYm9sLnBvd2VyLnN0cmlwVmFyKHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcxLygoezF9KS0oezB9KSknLCBhLCBzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm5zID0gWydzaW4nLCAnY29zJywgJ3NpbmgnLCAnY29zaCddO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc3VwcG9ydCBmb3Igc3ltYm9scyBpbiBmbnMgd2l0aCBhcmd1bWVudHMgaW4gdGhlIGZvcm0gYSp0IG9yIG4qdCB3aGVyZSBhID0gc3ltYm9saWMgYW5kIG4gPSBOdW1iZXJcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEZOICYmIGZucy5pbmRleE9mKHN5bWJvbC5mbmFtZSkgIT09IC0xICYmIChzeW1ib2wuYXJnc1swXS5ncm91cCA9PT0gUyB8fCBzeW1ib2wuYXJnc1swXS5ncm91cCA9PT0gQ0IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gc3ltYm9sLmFyZ3NbMF0uc3RyaXBWYXIodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goc3ltYm9sLmZuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaW4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoezB9KS8oKHsxfSleMisoezB9KV4yKScsIGEsIHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvcyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJyh7MX0pLygoezF9KV4yKyh7MH0pXjIpJywgYSwgcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2luaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJyh7MH0pLygoezF9KV4yLSh7MH0pXjIpJywgYSwgcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29zaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJyh7MX0pLygoezF9KV4yLSh7MH0pXjIpJywgYSwgcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UcnkgdG8gaW50ZWdyYXRlIGZvciBhIHNvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgbmVlZCBhdCBsZWFzdCB0aGUgTGFwbGFjZSBpbnRlZ3JhdGlvbiBkZXB0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwdGhfaXNfbG93ZXIgPSBjb3JlLlNldHRpbmdzLmludGVncmF0aW9uX2RlcHRoIDwgY29yZS5TZXR0aW5ncy5MYXBsYWNlX2ludGVncmF0aW9uX2RlcHRoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVwdGhfaXNfbG93ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhdGlvbl9kZXB0aCA9IGNvcmUuU2V0dGluZ3MuaW50ZWdyYXRpb25fZGVwdGg7IC8vc2F2ZSB0aGUgZGVwdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuU2V0dGluZ3MuaW50ZWdyYXRpb25fZGVwdGggPSBjb3JlLlNldHRpbmdzLkxhcGxhY2VfaW50ZWdyYXRpb25fZGVwdGg7IC8vdHJhbnNmb3JtcyBuZWVkIGEgbGl0dGxlIG1vcmUgcm9vbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLlV0aWxzLmJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gc3ltYm9sLnN1Yih0LCB1KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ3JhdGlvbl9leHByID0gXy5wYXJzZSgnZV4oLScgKyBzICsgJyonICsgdSArICcpKicgKyBzeW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gY29yZS5DYWxjdWx1cy5pbnRlZ3JhdGUoaW50ZWdyYXRpb25fZXhwciwgdSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihyZXR2YWwuaGFzSW50ZWdyYWwoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignbGFwbGFjZScsIGFyZ3VtZW50cyk7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVycm9yKCdVbmFibGUgdG8gY29tcHV0ZSB0cmFuc2Zvcm0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbC5zdWIodCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmV4cGFuZChfLm11bHRpcGx5KHJldHZhbCwgbmV3IFN5bWJvbCgtMSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbC5zdWIodSwgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGNvcmUuVXRpbHMuYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKHJldHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGVwdGhfaXNfbG93ZXIpLy9wdXQgdGhlIGludGVncmF0aW9uIGRlcHRoIGFzIGl0IHdhc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5TZXR0aW5ncy5pbnRlZ3JhdGlvbl9kZXB0aCA9IGludGVncmF0aW9uX2RlcHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkocmV0dmFsLCBjb2VmZik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludmVyc2U6IGZ1bmN0aW9uIChzeW1ib2wsIHNfLCB0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRfc3ltYm9sID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5ibG9jaygnUE9TSVRJVkVfTVVMVElQTElFUlMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9leHBhbmQgYW5kIGdldCBwYXJ0aWFsIGZyYWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gY29yZS5BbGdlYnJhLlBhcnRGcmFjLnBhcnRmcmFjKF8uZXhwYW5kKHN5bWJvbCksIHNfKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gUyB8fCBzeW1ib2wuZ3JvdXAgPT09IENCIHx8IHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgdGhlIG51bWVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIG51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwubXVsdGlwbGllciA9IHJldHZhbC5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHV0IGJhY2sgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5kaXZpZGUocmV0dmFsLCBmLmEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtLCBkZW4sIHMsIHJldHZhbCwgZiwgcCwgbSwgZGVuX3AsIGZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gc3ltYm9sLm11bHRpcGxpZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gc3ltYm9sLmdldE51bSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW4gPSBzeW1ib2wuZ2V0RGVub20oKS50b1VuaXRNdWx0aXBsaWVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IE1ha2UgaXQgc28gZmFjdG9yIGRvZXNuJ3QgZGVzdHJveSBwaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL251bSA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKHN5bWJvbC5nZXROdW0oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVuID0gY29yZS5BbGdlYnJhLkZhY3Rvci5mYWN0b3Ioc3ltYm9sLmdldERlbm9tKCkuaW52ZXJ0KG51bGwsIHRydWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRlbi5ncm91cCA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbl9wID0gZGVuLnBvd2VyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW4udG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbl9wID0gbmV3IGNvcmUuRnJhYygxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IHMgdG8gYSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IHNfLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc3BsaXQgdXAgdGhlIGRlbm9taW5hdG9yIGlmIGluIHRoZSBmb3JtIGF4K2JcclxuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuKGRlbiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbW92ZSB0aGUgbXVsdGlwbGllciB0byB0aGUgbnVtZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlID0gY29yZS5VdGlscy5kZWNvbXBvc2VfZm4oXy5leHBhbmQobnVtLmNsb25lKCkpLCBzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtLm11bHRpcGxpZXIgPSBudW0ubXVsdGlwbGllci5tdWx0aXBseShtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdG9yZSB0aGUgcGFydHMgaW4gdmFyaWFibGVzIGZvciBlYXN5IHJlY29nbml0aW9uIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGluIHRoZSBmb3JtIHRebiB3aGVyZSBuID0gaW50ZWdlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZigoZGVuLmdyb3VwID09PSBTIHx8IGRlbi5ncm91cCA9PT0gQ0IpICYmIGYueC52YWx1ZSA9PT0gcyAmJiBmLmIuZXF1YWxzKDApICYmIGNvcmUuVXRpbHMuaXNJbnQoZi54LnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3QsIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gZi54LnBvd2VyIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY3QgPSBjb3JlLk1hdGgyLmZhY3RvcmlhbChwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBuIS9zXihuLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShfLnBvdyh0LCBuZXcgU3ltYm9sKHApKSwgbmV3IFN5bWJvbChmYWN0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dyYXAgaXQgdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkZW4uZ3JvdXAgPT09IENQICYmIGRlbl9wLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZi54Lmdyb3VwID09PSBjb3JlLmdyb3Vwcy5QTCAmJiBjb3JlLkFsZ2VicmEuZGVncmVlKGRlbikuZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libHkgaW4gdGhlIGZvcm0gMS8oc14yKzIqcysxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBmYWN0b3JpbmcgdG8gZ2V0IGl0IGluIGEgbW9yZSBmYW1pbGlhciBmb3Jte1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGludmVyc2Ugb2YgRihzLWEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IGNvcmUuQWxnZWJyYS5zcUNvbXBsZXRlKGRlbiwgcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHUgPSBjb3JlLlV0aWxzLmdldFUoZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSBmb3IgdGhlIGZ1bmN0aW9uIGFib3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBjb3JlLlV0aWxzLmRlY29tcG9zZV9mbihjb21wbGV0ZWQuYSwgcywgdHJ1ZSkuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGYgPSBfXy5MYVBsYWNlLmludmVyc2UoXy5wYXJzZShgMS8oKCR7dX0pXjIrKCR7Y29tcGxldGVkLmN9KSlgKSwgdSwgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseSh0ZiwgXy5wYXJzZShgKCR7bX0pKmVeKC0oJHthfSkqKCR7dH0pKWApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEvKGIqcy1jKSAtPiBhZV4oLWJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGYueC5pc0xpbmVhcigpICYmICFudW0uY29udGFpbnMocykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8uZGl2aWRlKHQsIGYuYS5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFkZCBmYWN0b3JpYWwgb2Ygb25lIG9yIHplcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBkZW5fcCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0ID0gcCA9PT0gMCB8fCBwID09PSAxID8gJzEnIDogYCgke2Rlbl9wfS0xKSFgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoKHswfSleKHszfS0xKSplXigtKCh7Mn0pKih7MH0pKS8oezF9KSkpLygoezR9KSooezF9KV4oezN9KSknLCB0LCBmLmEsIGYuYiwgZGVuX3AsIGZhY3QpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93cmFwIGl0IHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmLnguZ3JvdXAgPT09IFMgJiYgZi54LnBvd2VyLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW51bS5jb250YWlucyhzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KCcoKHsxfSkqc2luKChzcXJ0KCh7Mn0pKih7M30pKSooezB9KSkvKHsyfSkpKS9zcXJ0KCh7Mn0pKih7M30pKScsIHQsIG51bSwgZi5hLCBmLmIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEqcy8oYipzXjIrY14yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG51bS5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19udW0gPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5jb250YWlucyhzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfbnVtID0gXy5tdWx0aXBseShuZXdfbnVtLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gXy5tdWx0aXBseShhLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IG5ld19udW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlIG5lZWQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZGVub21pbmF0b3IgdG8gZGVjaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYyID0gY29yZS5VdGlscy5kZWNvbXBvc2VfZm4obnVtLCBzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm4xLCBmbjIsIGFfaGFzX3NpbiwgYl9oYXNfY29zLCBhX2hhc19jb3MsIGJfaGFzX3NpbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbjEgPSBmMi5hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuMiA9IGYyLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYV9oYXNfc2luID0gZm4xLmNvbnRhaW5zRnVuY3Rpb24oJ3NpbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFfaGFzX2NvcyA9IGZuMS5jb250YWluc0Z1bmN0aW9uKCdjb3MnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiX2hhc19jb3MgPSBmbjIuY29udGFpbnNGdW5jdGlvbignY29zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYl9oYXNfc2luID0gZm4yLmNvbnRhaW5zRnVuY3Rpb24oJ3NpbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGYyLngudmFsdWUgPT09IHMgJiYgZjIueC5pc0xpbmVhcigpICYmICEoKGFfaGFzX3NpbiAmJiBiX2hhc19jb3MpIHx8IChhX2hhc19jb3MgfHwgYl9oYXNfc2luKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoJygoezF9KSpjb3MoKHNxcnQoKHsyfSkqKHszfSkpKih7MH0pKS8oezJ9KSkpLyh7Mn0pJywgdCwgZjIuYSwgZi5hLCBmLmIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFfaGFzX3NpbiAmJiBiX2hhc19jb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaW4sIGNvcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbiA9IGZuMS5maW5kRnVuY3Rpb24oJ3NpbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29zID0gZm4yLmZpbmRGdW5jdGlvbignY29zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dobyBoYXMgdGhlIHM/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzaW4uYXJnc1swXS5lcXVhbHMoY29zLmFyZ3NbMF0pICYmICFzaW4uYXJnc1swXS5jb250YWlucyhzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiLCBjLCBkLCBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBfLmRpdmlkZShmbjIsIGNvcy50b1VuaXRNdWx0aXBsaWVyKCkpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHNpbi5hcmdzWzBdLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGYuYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gXy5kaXZpZGUoZm4xLCBzaW4udG9Vbml0TXVsdGlwbGllcigpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHAgPSAnKCh7MX0pKih7Mn0pKmNvcyh7M30pKnNpbihzcXJ0KHs0fSkqKHswfSkpKS9zcXJ0KHs0fSkrKHsxfSkqc2luKHszfSkqKHs1fSkqY29zKHNxcnQoezR9KSooezB9KSknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KGV4cCwgdCwgYSwgYiwgYywgZCwgZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZi54LnBvd2VyLm51bSAmJiBmLngucG93ZXIubnVtLmVxdWFscygzKSAmJiBmLngucG93ZXIuZGVuLmVxdWFscygyKSAmJiBudW0uY29udGFpbnMoJ3NxcnQocGkpJykgJiYgIW51bS5jb250YWlucyhzKSAmJiBudW0uaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBfLmRpdmlkZShudW0uY2xvbmUoKSwgXy5wYXJzZSgnc3FydChwaSknKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdCgnKDIqKHsyfSkqc3FydCh7MH0pKS8oezF9KScsIHQsIGYuYSwgYiwgbnVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkZW5fcC5lcXVhbHMoMikgJiYgZi54LnBvd2VyLmVxdWFscygyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEsIGQsIGV4cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFudW0uY29udGFpbnMocykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gXy5kaXZpZGUobnVtLCBuZXcgU3ltYm9sKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHAgPSAnKCh7MX0pKnNpbigoc3FydCgoezJ9KSooezN9KSkqKHswfSkpLyh7Mn0pKSkvKCh7M30pKnNxcnQoKHsyfSkqKHszfSkpKS0oKHsxfSkqKHswfSkqY29zKChzcXJ0KCh7Mn0pKih7M30pKSooezB9KSkvKHsyfSkpKS8oKHsyfSkqKHszfSkpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKGZvcm1hdChleHAsIHQsIGEsIGYuYSwgZi5iKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWNvbXBvc2UgdGhlIG51bWVyYXRvciB0byBjaGVjayB2YWx1ZSBvZiBzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjIgPSBjb3JlLlV0aWxzLmRlY29tcG9zZV9mbihfLmV4cGFuZChudW0uY2xvbmUoKSksIHMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGYyLnguaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc190ZXJtcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IGNvbGxlY3QgdGhlIGZhY3RvcnMgZS5nLiAoYSkoYngpKGN4XjIrZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbHMgPSBudW0uY29sbGVjdFN5bWJvbHMoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBTeW1ib2wudW53cmFwUEFSRU5TKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBjb3JlLlV0aWxzLmRlY29tcG9zZV9mbih4LCBzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuc3ltYm9sID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZW4gc29ydCB0aGVtIGJ5IHBvd2VyIGhpZ2h0ZXN0IHRvIGxvd2VzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAxLCBwMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcDEgPSBhLngudmFsdWUgIT09IHMgPyAwIDogYS54LnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMiA9IGIueC52YWx1ZSAhPT0gcyA/IDAgOiBiLngucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwMiAtIHAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gbmV3IFN5bWJvbCgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdyYWIgb25seSB0aGUgb25lcyB3aGljaCBoYXZlIHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYyA9IHN5bWJvbHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihmYy54LnZhbHVlID09PSBzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNfdGVybXMucHVzaChmYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF8ubXVsdGlwbHkoYSwgZmMuc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIDIgYXNzdW1wdGlvbnMgYXJlIG1hZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS4gc2luY2UgdGhlIG51bWVyYXRvciB3YXMgZmFjdG9yZWQgYWJvdmUgdGhlbiBlYWNoIHNfdGVybSBoYXMgYSB1bmlxdWUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi4gYmVjYXVzZSB0aGUgdGVybXMgYXJlIHNvcnRlZCBieSBkZXNjZW5kaW5nIHBvd2VycyB0aGVuIHRoZSBmaXJzdCBpdGVtIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBoYXMgdGhlIGhpZ2hlc3QgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIG5vdyBjaGVjayBmb3IgdGhlIG5leHQgdHlwZSBzKHNeMi1hXjIpLyhzXjIrYV4yKV4yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNfdGVybXNbMF0ueC5wb3dlci5lcXVhbHMoMikgJiYgc190ZXJtc1sxXS54LnBvd2VyLmVxdWFscygxKSAmJiBzX3Rlcm1zWzFdLmIuZXF1YWxzKDApICYmICFzX3Rlcm1zWzBdLmIuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gc190ZXJtc1swXS5hLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwID0gJy0oKHsxfSkqKHsyfSkqKHs1fSkqKHswfSkqc2luKChzcXJ0KCh7NH0pKih7NX0pKSooezB9KSkvKHs0fSkpKS8nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJygyKih7NH0pXjIqc3FydCgoezR9KSooezV9KSkpLSgoezF9KSooezN9KSooezB9KSpzaW4oKHNxcnQoKHs0fSkqKHs1fSkpKih7MH0pKS8oezR9KSkpJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvKDIqKHs0fSkqc3FydCgoezR9KSooezV9KSkpKygoezF9KSooezJ9KSpjb3MoKHNxcnQoKHs0fSkqKHs1fSkpKih7MH0pKS8oezR9KSkpLyh7NH0pXjInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoZXhwLCB0LCBhLCBiLCBzX3Rlcm1zWzBdLmIsIGYuYSwgZi5iKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGYyLnguaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF8uZGl2aWRlKGYyLmEsIG5ldyBTeW1ib2woMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwID0gJygoezF9KSooezB9KSpzaW4oKHNxcnQoKHsyfSkqKHszfSkpKih7MH0pKS8oezJ9KSkpLygoezJ9KSpzcXJ0KCh7Mn0pKih7M30pKSknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShmb3JtYXQoZXhwLCB0LCBhLCBmLmEsIGYuYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZjIueC5wb3dlci5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGYyLmIuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF8uZGl2aWRlKGYyLmEsIG5ldyBTeW1ib2woMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cCA9ICcoKHsxfSkqc2luKChzcXJ0KCh7Mn0pKih7M30pKSooezB9KSkvKHsyfSkpKS8oKHsyfSkqc3FydCgoezJ9KSooezN9KSkpKygoezF9KSooezB9KSpjb3MoKHNxcnQoKHsyfSkqKHszfSkpKih7MH0pKS8oezJ9KSkpLyh7Mn0pXjInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KGV4cCwgdCwgYSwgZi5hLCBmLmIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfLmRpdmlkZShmMi5hLCBuZXcgU3ltYm9sKDIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gZjIuYi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHAgPSAnLSgoKHsyfSkqKHs0fSktMiooezF9KSooezN9KSkqc2luKChzcXJ0KCh7Mn0pKih7M30pKSooezB9KSkvKHsyfSkpKS8oMiooezJ9KSooezN9KSpzcXJ0KCh7Mn0pKih7M30pKSkrJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKCh7NH0pKih7MH0pKmNvcygoc3FydCgoezJ9KSooezN9KSkqKHswfSkpLyh7Mn0pKSkvKDIqKHsyfSkqKHszfSkpKygoezF9KSooezB9KSpjb3MoKHNxcnQoKHsyfSkqKHszfSkpKih7MH0pKS8oezJ9KSkpLyh7Mn0pXjInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoZm9ybWF0KGV4cCwgdCwgYSwgZi5hLCBmLmIsIGQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMS8ocysxKV4yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZW5fcC5lcXVhbHMoMikgJiYgZi54Lmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShgKCR7bX0pKigke3R9KSplXigtKCR7Zi5ifSkqKCR7dH0pKWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfXy5MYVBsYWNlLmludmVyc2UoeCwgc18sIHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXJldHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdpbHQnLCBbaW5wdXRfc3ltYm9sLCBzXywgdF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBTdGF0aXN0aWNzOiB7XHJcbiAgICAgICAgICAgIGZyZXF1ZW5jeU1hcDogZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIGZyZXF1ZW5jeSBtYXBcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBhcnJbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIW1hcFtrZXldKSAvL2RlZmF1bHQgaXQgdG8gemVyb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBba2V5XSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwW2tleV0rKzsgLy9pbmNyZW1lbnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNvcnQ6IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFhLmlzQ29uc3RhbnQoKSB8fCAhYi5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZXJyb3IoJ1VuYWJsZSB0byBzb3J0ISBBbGwgdmFsdWVzIG11c3QgYmUgbnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm11bHRpcGxpZXIuc3VidHJhY3QoYi5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb3VudDogZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woYXJyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN1bTogZnVuY3Rpb24gKGFyciwgeF8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdW0gPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeGkgPSBhcnJbaV0uY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih4Xykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gPSBfLmFkZChfLnBvdyhfLnN1YnRyYWN0KHhpLCB4Xy5jbG9uZSgpKSwgbmV3IFN5bWJvbCgyKSksIHN1bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gXy5hZGQoeGksIHN1bSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWVhbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKGFyZ3NbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLm1lYW4uYXBwbHkodGhpcywgYXJnc1swXS5lbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIF8uZGl2aWRlKF9fLlN0YXRpc3RpY3Muc3VtKGFyZ3MpLCBfXy5TdGF0aXN0aWNzLmNvdW50KGFyZ3MpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWVkaWFuOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBpZihpc1ZlY3RvcihhcmdzWzBdKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5tZWRpYW4uYXBwbHkodGhpcywgYXJnc1swXS5lbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3J0ZWQgPSBfXy5TdGF0aXN0aWNzLnNvcnQoYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSBhcmdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZihjb3JlLlV0aWxzLmV2ZW4obCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pZCA9IGwgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfXy5TdGF0aXN0aWNzLm1lYW4oc29ydGVkW21pZCAtIDFdLCBzb3J0ZWRbbWlkXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gc29ydGVkW01hdGguZmxvb3IobCAvIDIpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdtZWRpYW4nLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKGFyZ3NbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLm1vZGUuYXBwbHkodGhpcywgYXJnc1swXS5lbGVtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IF9fLlN0YXRpc3RpY3MuZnJlcXVlbmN5TWFwKGFyZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdGhlIG1vZGUgb2YgMSBpdGVtIGlzIHRoYXQgaXRlbSBhcyBwZXIgaXNzdWUgIzMxMCAodmVyaWZpZWQgYnkgSGFwcHlwaWczNzUpLiBcclxuICAgICAgICAgICAgICAgIGlmKGNvcmUuVXRpbHMua2V5cyhtYXApLmxlbmd0aCA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pbnZlcnQgYnkgYXJyYW5pbmcgdGhlbSBhY2NvcmRpbmcgdG8gdGhlaXIgZnJlcXVlbmN5XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludmVyc2UgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gbWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmVxID0gbWFwW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGl0J3MgaW4gdGhlIGludmVyc2UgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighKGZyZXEgaW4gaW52ZXJzZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlW2ZyZXFdID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGludmVyc2VbZnJlcV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3MgYWxyZWFkeSBhbiBhcnJheSB0aGVuIGp1c3QgYWRkIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpc0FycmF5KGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29udmVydCBpdCB0byBhbmQgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlW2ZyZXFdID0gW3gsIGludmVyc2VbZnJlcV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIGtleXMgbm93IHJlcHJlc2VudCB0aGUgbWF4ZXMuIFdlIHdhbnQgdGhlIG1heCBvZiB0aG9zZSBrZXlzXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IGludmVyc2VbTWF0aC5tYXguYXBwbHkobnVsbCwgY29yZS5VdGlscy5rZXlzKGludmVyc2UpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpdCdzIGFuIGFycmF5LiBJZiBpdCBpcyB0aGVuIG1hcCBvdmVyIHRoZSByZXN1bHRzIGFuZCBjb252ZXJ0IFxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlbSB0byBTeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICBpZihpc0FycmF5KG1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignbW9kZScsIG1heC5zb3J0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UobWF4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnVmFyaWFuY2U6IGZ1bmN0aW9uIChrLCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBfXy5TdGF0aXN0aWNzLm1lYW4uYXBwbHkoX18uU3RhdGlzdGljcywgYXJncyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSA9IF9fLlN0YXRpc3RpY3Muc3VtKGFyZ3MsIHhfKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KGssIHN1bSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHZhcmlhbmNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8vaGFuZGxlIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgaWYoaXNWZWN0b3IoYXJnc1swXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3MudmFyaWFuY2UuYXBwbHkodGhpcywgYXJnc1swXS5lbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IF8uZGl2aWRlKG5ldyBTeW1ib2woMSksIF9fLlN0YXRpc3RpY3MuY291bnQoYXJncykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3MuZ1ZhcmlhbmNlKGssIGFyZ3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzYW1wbGVWYXJpYW5jZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKGFyZ3NbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLnNhbXBsZVZhcmlhbmNlLmFwcGx5KHRoaXMsIGFyZ3NbMF0uZWxlbWVudHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBrID0gXy5kaXZpZGUobmV3IFN5bWJvbCgxKSwgXy5zdWJ0cmFjdChfXy5TdGF0aXN0aWNzLmNvdW50KGFyZ3MpLCBuZXcgU3ltYm9sKDEpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5nVmFyaWFuY2UoaywgYXJncyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0YW5kYXJkRGV2aWF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8vaGFuZGxlIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgaWYoaXNWZWN0b3IoYXJnc1swXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3Muc3RhbmRhcmREZXZpYXRpb24uYXBwbHkodGhpcywgYXJnc1swXS5lbGVtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wb3coX18uU3RhdGlzdGljcy52YXJpYW5jZS5hcHBseShfXy5TdGF0aXN0aWNzLCBhcmdzKSwgbmV3IFN5bWJvbCgxIC8gMikpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzYW1wbGVTdGFuZGFyZERldmlhdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSBhcnJheXNcclxuICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKGFyZ3NbMF0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLnNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uLmFwcGx5KHRoaXMsIGFyZ3NbMF0uZWxlbWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucG93KF9fLlN0YXRpc3RpY3Muc2FtcGxlVmFyaWFuY2UuYXBwbHkoX18uU3RhdGlzdGljcywgYXJncyksIG5ldyBTeW1ib2woMSAvIDIpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgelNjb3JlOiBmdW5jdGlvbiAoeCwgbWVhbiwgc3RkZXYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShfLnN1YnRyYWN0KHgsIG1lYW4pLCBzdGRldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFVuaXRzOiB7XHJcbiAgICAgICAgICAgIHRhYmxlOiB7XHJcbiAgICAgICAgICAgICAgICBmb290OiAnMTIgaW5jaCcsXHJcbiAgICAgICAgICAgICAgICBtZXRlcjogJzEwMCBjbScsXHJcbiAgICAgICAgICAgICAgICBkZWNpbWV0ZXI6ICcxMCBjbScsXHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBuZXJkYW1lci5yZWdpc3RlcihbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnbGFwbGFjZScsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDMsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uTGFQbGFjZS50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ2lsdCcsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDMsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uTGFQbGFjZS5pbnZlcnNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL3N0YXRpc3RpY2FsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnbWVhbicsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IC0xLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3MubWVhbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnbWVkaWFuJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogLTEsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy5tZWRpYW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ21vZGUnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAtMSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLm1vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3NtcHZhcicsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IC0xLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3Muc2FtcGxlVmFyaWFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3ZhcmlhbmNlJyxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYXJnczogLTEsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy52YXJpYW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnc21wc3RkZXYnLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBudW1hcmdzOiAtMSxcclxuICAgICAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5TdGF0aXN0aWNzLnNhbXBsZVN0YW5kYXJkRGV2aWF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdzdGRldicsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IC0xLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fLlN0YXRpc3RpY3Muc3RhbmRhcmREZXZpYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbmFtZTogJ3pzY29yZScsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDMsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX18uU3RhdGlzdGljcy56U2NvcmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuXHJcbiAgICAvL2xpbmsgcmVnaXN0ZXJlZCBmdW5jdGlvbnMgZXh0ZXJuYWxseVxyXG4gICAgbmVyZGFtZXIuYXBpKCk7XHJcbn0oKSk7XHJcblxyXG4vLyBBZGRlZCBmb3IgYWxsLm1pbi5qc1xyXG5pZigodHlwZW9mIG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IG5lcmRhbWVyO1xyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nerdamer/Extra.js\n");

/***/ }),

/***/ "./node_modules/nerdamer/Solve.js":
/*!****************************************!*\
  !*** ./node_modules/nerdamer/Solve.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n/* global module */\r\n\r\nif(true) {\r\n    var nerdamer = __webpack_require__(/*! ./nerdamer.core.js */ \"./node_modules/nerdamer/nerdamer.core.js\");\r\n    __webpack_require__(/*! ./Calculus.js */ \"./node_modules/nerdamer/Calculus.js\");\r\n    __webpack_require__(/*! ./Algebra.js */ \"./node_modules/nerdamer/Algebra.js\");\r\n}\r\n\r\n(function () {\r\n    //handle imports\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            _A = core.Algebra,\r\n            _C = core.Calculus,\r\n            explode = _C.integration.decompose_arg,\r\n            evaluate = core.Utils.evaluate,\r\n            remove = core.Utils.remove,\r\n            format = core.Utils.format,\r\n            build = core.Utils.build,\r\n            knownVariable = core.Utils.knownVariable,\r\n            Symbol = core.Symbol,\r\n            isSymbol = core.Utils.isSymbol,\r\n            variables = core.Utils.variables,\r\n            S = core.groups.S,\r\n            PL = core.groups.PL,\r\n            CB = core.groups.CB,\r\n            CP = core.groups.CP,\r\n            FN = core.groups.FN,\r\n            Settings = core.Settings,\r\n            range = core.Utils.range,\r\n            isArray = core.Utils.isArray;\r\n\r\n\r\n    // The search radius for the roots\r\n    core.Settings.SOLVE_RADIUS = 1000;\r\n    // The maximum number to fish for on each side of the zero\r\n    core.Settings.ROOTS_PER_SIDE = 10;\r\n    // Covert the number to multiples of pi if possible\r\n    core.Settings.make_pi_conversions = false;\r\n    // The step size\r\n    core.Settings.STEP_SIZE = 0.1;\r\n    // The epsilon size\r\n    core.Settings.EPSILON = 1e-13;\r\n    //the maximum iterations for Newton's method\r\n    core.Settings.MAX_NEWTON_ITERATIONS = 200;\r\n    //the maximum number of time non-linear solve tries another jump point\r\n    core.Settings.MAX_NON_LINEAR_TRIES = 12;\r\n    //the amount of iterations the function will start to jump at\r\n    core.Settings.NON_LINEAR_JUMP_AT = 50;\r\n    //the size of the jump\r\n    core.Settings.NON_LINEAR_JUMP_SIZE = 100;\r\n    //the original starting point for nonlinear solving\r\n    core.Settings.NON_LINEAR_START = 0.01;\r\n    //When points are generated as starting points for Newton's method, they are sliced into small\r\n    //slices to make sure that we have convergence on the right point. This defines the \r\n    //size of the slice\r\n    core.Settings.NEWTON_SLICES = 200;\r\n    //The epsilon used in Newton's iteration\r\n    core.Settings.NEWTON_EPSILON = Number.EPSILON * 2;\r\n    //The distance in which two solutions are deemed the same\r\n    core.Settings.SOLUTION_PROXIMITY = 1e-14;\r\n    //Indicate wheter to filter the solutions are not\r\n    core.Settings.FILTER_SOLUTIONS = true;\r\n    //the maximum number of recursive calls\r\n    core.Settings.MAX_SOLVE_DEPTH = 10;\r\n    // The tolerance that's considered close enough to zero\r\n    core.Settings.ZERO_EPSILON = 1e-9;\r\n    // The maximum iteration for the bisection method incase of some JS strangeness\r\n    core.Settings.MAX_BISECTION_ITER = 2000;\r\n    // The tolerance for the bisection method\r\n    core.Settings.BI_SECTION_EPSILON = 1e-12;\r\n\r\n\r\n    core.Symbol.prototype.hasTrig = function () {\r\n        return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\r\n    };\r\n\r\n    core.Symbol.prototype.hasNegativeTerms = function () {\r\n        if(this.isComposite()) {\r\n            for(var x in this.symbols) {\r\n                var sym = this.symbols[x];\r\n                if(sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\r\n     * As such we can have this data type be supported completely outside of the core.\r\n     * This is an equation that has a left hand side and a right hand side\r\n     */\r\n    function Equation(lhs, rhs) {\r\n        if(rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) || rhs.equals(core.Settings.IMAGINARY))\r\n            throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\r\n        this.LHS = lhs; //left hand side\r\n        this.RHS = rhs; //right and side\r\n    }\r\n    ;\r\n\r\n    //UTILS ##!!\r\n\r\n    Equation.prototype = {\r\n        toString: function () {\r\n            return this.LHS.toString() + '=' + this.RHS.toString();\r\n        },\r\n        text: function (option) {\r\n            return this.LHS.text(option) + '=' + this.RHS.text(option);\r\n        },\r\n        toLHS: function (expand) {\r\n            expand = typeof expand === 'undefined' ? true : false;\r\n            var eqn;\r\n            if(!expand) {\r\n                eqn = this.clone();\r\n            }\r\n            else {\r\n                eqn = this.removeDenom();\r\n            }\r\n            var a = eqn.LHS;\r\n            var b = eqn.RHS;\r\n            if(a.isConstant(true) && !b.isConstant(true)) {\r\n                // Swap them to avoid confusing parser and cause an infinite loop\r\n                [a, b] = [b, a];\r\n            }\r\n            var _t = _.subtract(a, b);\r\n            var retval = expand ? _.expand(_t) : _t;\r\n            return retval;\r\n        },\r\n        removeDenom: function () {\r\n            var a = this.LHS.clone();\r\n            var b = this.RHS.clone();\r\n            //remove the denominator on both sides\r\n            var den = _.multiply(a.getDenom(), b.getDenom());\r\n            a = _.expand(_.multiply(a, den.clone()));\r\n            b = _.expand(_.multiply(b, den));\r\n            //swap the groups\r\n            if(b.group === CP && b.group !== CP) {\r\n                var t = a;\r\n                a = b;\r\n                b = t; //swap\r\n            }\r\n\r\n            //scan to eliminate denominators\r\n            if(a.group === CB) {\r\n                var t = new Symbol(a.multiplier),\r\n                        newRHS = b.clone();\r\n                a.each(function (y) {\r\n                    if(y.power.lessThan(0))\r\n                        newRHS = _.divide(newRHS, y);\r\n                    else\r\n                        t = _.multiply(t, y);\r\n                });\r\n                a = t;\r\n                b = newRHS;\r\n\r\n            }\r\n            else if(a.group === CP) {\r\n                //the logic: loop through each and if it has a denominator then multiply it out on both ends\r\n                //and then start over\r\n                for(var x in a.symbols) {\r\n                    var sym = a.symbols[x];\r\n                    if(sym.group === CB) {\r\n                        for(var y in sym.symbols) {\r\n                            var sym2 = sym.symbols[y];\r\n                            if(sym2.power.lessThan(0)) {\r\n                                return new Equation(\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), a)),\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), b))\r\n                                        );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return new Equation(a, b);\r\n        },\r\n        clone: function () {\r\n            return new Equation(this.LHS.clone(), this.RHS.clone());\r\n        },\r\n        sub: function (x, y) {\r\n            var clone = this.clone();\r\n            clone.LHS = clone.LHS.sub(x.clone(), y.clone());\r\n            clone.RHS = clone.RHS.sub(x.clone(), y.clone());\r\n            return clone;\r\n        },\r\n        isZero: function () {\r\n            return core.Utils.evaluate(this.toLHS()).equals(0);\r\n        },\r\n        latex: function (option) {\r\n            return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\r\n        }\r\n    };\r\n    //overwrite the equals function\r\n    _.equals = function (a, b) {\r\n        return new Equation(a, b);\r\n    };\r\n\r\n    // Extend simplify\r\n    (function () {\r\n        var simplify = _.functions.simplify[0];\r\n        _.functions.simplify[0] = function (symbol) {\r\n            if(symbol instanceof Equation) {\r\n                symbol.LHS = simplify(symbol.LHS);\r\n                symbol.RHS = simplify(symbol.RHS);\r\n                return symbol;\r\n            }\r\n            // Just call the original simplify\r\n            return simplify(symbol);\r\n        };\r\n    })();\r\n\r\n    /**\r\n     * Sets two expressions equal\r\n     * @param {Symbol} symbol\r\n     * @returns {Expression}\r\n     */\r\n    core.Expression.prototype.equals = function (symbol) {\r\n        if(symbol instanceof core.Expression)\r\n            symbol = symbol.symbol; //grab the symbol if it's an expression\r\n        var eq = new Equation(this.symbol, symbol);\r\n        return eq;\r\n    };\r\n\r\n    core.Expression.prototype.solveFor = function (x) {\r\n        var symbol;\r\n        if(this.symbol instanceof Equation) {\r\n            //exit right away if we already have the answer\r\n            //check the LHS\r\n            if(this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x))\r\n                return new core.Expression(this.symbol.LHS);\r\n\r\n            //check the RHS\r\n            if(this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x))\r\n                return new core.Expression(this.symbol.RHS);\r\n\r\n            //otherwise just bring it to LHS\r\n            symbol = this.symbol.toLHS();\r\n        }\r\n        else {\r\n            symbol = this.symbol;\r\n        }\r\n\r\n        return solve(symbol, x).map(function (x) {\r\n            return new core.Expression(x);\r\n        });\r\n    };\r\n\r\n    core.Expression.prototype.expand = function () {\r\n        if(this.symbol instanceof Equation) {\r\n            var clone = this.symbol.clone();\r\n            clone.RHS = _.expand(clone.RHS);\r\n            clone.LHS = _.expand(clone.LHS);\r\n            return new core.Expression(clone);\r\n        }\r\n        return new core.Expression(_.expand(this.symbol));\r\n    };\r\n\r\n    core.Expression.prototype.variables = function () {\r\n        if(this.symbol instanceof Equation)\r\n            return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\r\n        return variables(this.symbol);\r\n    };\r\n\r\n\r\n\r\n    var setEq = function (a, b) {\r\n        return _.equals(a, b);\r\n    };\r\n\r\n    //link the Equation class back to the core\r\n    core.Equation = Equation;\r\n\r\n    //Loops through an array and attempts to fails a test. Stops if manages to fail.\r\n    var checkAll = core.Utils.checkAll = function (args, test) {\r\n        for(var i = 0; i < args.length; i++)\r\n            if(test(args[i]))\r\n                return false;\r\n        return true;\r\n    };\r\n\r\n    //version solve\r\n    var __ = core.Solve = {\r\n        version: '2.0.3',\r\n        solutions: [],\r\n        solve: function (eq, variable) {\r\n            var solution = solve(eq, String(variable));\r\n            return new core.Vector(solution);\r\n            //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\r\n        },\r\n        /**\r\n         * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\r\n         * @param {Equation|String} eqn\r\n         * @returns {Symbol}\r\n         */\r\n        toLHS: function (eqn, expand) {\r\n            if(isSymbol(eqn))\r\n                return eqn;\r\n            //If it's an equation then call its toLHS function instead\r\n            if(!(eqn instanceof Equation)) {\r\n                var es = eqn.split('=');\r\n                //convert falsey values to zero\r\n                es[1] = es[1] || '0';\r\n                eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\r\n            }\r\n            return eqn.toLHS(expand);\r\n        },\r\n//        getSystemVariables: function(eqns) {\r\n//            vars = variables(eqns[0], null, null, true);\r\n//\r\n//            //get all variables\r\n//            for (var i = 1, l=eqns.length; i < l; i++)\r\n//                vars = vars.concat(variables(eqns[i]));\r\n//            //remove duplicates\r\n//            vars = core.Utils.arrayUnique(vars).sort();\r\n//            \r\n//            //done\r\n//            return vars;\r\n//        },\r\n        /**\r\n         * Solve a set of circle equations. \r\n         * @param {Symbol[]} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveCircle: function (eqns, vars) {\r\n            // Convert the variables to symbols\r\n            var svars = vars.map(function (x) {\r\n                return _.parse(x)\r\n            });\r\n\r\n            var deg = [];\r\n\r\n            var solutions = [];\r\n\r\n            // Get the degree for the equations\r\n            for(var i = 0; i < eqns.length; i++) {\r\n                var d = [];\r\n                for(var j = 0; j < svars.length; j++) {\r\n                    d.push(Number(core.Algebra.degree(eqns[i], svars[j])));\r\n                }\r\n                // Store the total degree\r\n                d.push(core.Utils.arraySum(d, true));\r\n                deg.push(d);\r\n            }\r\n\r\n            var a = eqns[0];\r\n            var b = eqns[1];\r\n\r\n            if(deg[0][2] > deg[1][2]) {\r\n                [b, a] = [a, b];\r\n                [deg[1], deg[0]] = [deg[0], deg[1]];\r\n            }\r\n\r\n            // Only solve it's truly a circle\r\n            if(deg[0][0] === 1 && deg[0][2] === 2 && deg[1][0] === 2 && deg[1][2] === 4) {\r\n                // For clarity we'll refer to the variables as x and y\r\n                var x = vars[0];\r\n                var y = vars[1];\r\n\r\n                // We can now get the two points for y\r\n                var y_points = solve(_.parse(b, knownVariable(x, solve(_.parse(a), x)[0])), y).map(function (x) {\r\n                    return x.toString();\r\n                });\r\n\r\n                // Since we now know y we can get the two x points from the first equation\r\n                var x_points = [\r\n                    solve(_.parse(a, knownVariable(y, y_points[0])))[0].toString()\r\n                ];\r\n\r\n                if(y_points[1]) {\r\n                    x_points.push(solve(_.parse(a, knownVariable(y, y_points[1])))[0].toString());\r\n                }\r\n\r\n                if(Settings.SOLUTIONS_AS_OBJECT) {\r\n                    var solutions = {};\r\n                    solutions[x] = x_points;\r\n                    solutions[y] = y_points;\r\n                }\r\n                else {\r\n                    y_points.unshift(y);\r\n                    x_points.unshift(x);\r\n                    solutions = [x_points, y_points];\r\n                }\r\n            }\r\n\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solve a system of nonlinear equations\r\n         * @param {Symbol[]} eqns The array of equations\r\n         * @param {number} tries The maximum number of tries\r\n         * @param {number} start The starting point where to start looking for solutions\r\n         * @returns {Array}\r\n         */\r\n        solveNonLinearSystem: function (eqns, tries, start) {\r\n            if(tries < 0) {\r\n                return [];//can't find a solution\r\n            }\r\n\r\n            start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start;\r\n\r\n            //the maximum number of times to jump\r\n            var max_tries = core.Settings.MAX_NON_LINEAR_TRIES;\r\n\r\n            //halfway through the tries\r\n            var halfway = Math.floor(max_tries / 2);\r\n\r\n            //initialize the number of tries to 10 if not specified\r\n            tries = typeof tries === 'undefined' ? max_tries : tries;\r\n\r\n            //a point at which we check to see if we're converging. By inspection it seems that we can\r\n            //use around 20 iterations to see if we're converging. If not then we retry a jump of x\r\n            var jump_at = core.Settings.NON_LINEAR_JUMP_AT;\r\n\r\n            //we jump by this many points at each pivot point\r\n            var jump = core.Settings.NON_LINEAR_JUMP_SIZE;\r\n\r\n            //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\r\n            var found = true;\r\n\r\n            var create_subs = function (vars, matrix) {\r\n                return vars.map(function (x, i) {\r\n                    return Number(matrix.get(i, 0));\r\n                });\r\n            };\r\n\r\n            var vars = core.Utils.arrayGetVariables(eqns);\r\n            var jacobian = core.Matrix.jacobian(eqns, vars, function (x) {\r\n                return build(x, vars);\r\n            }, true);\r\n\r\n            var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\r\n            var o, y, iters, xn1, norm, lnorm, xn, d;\r\n\r\n            var f_eqns = eqns.map(function (eq) {\r\n                return build(eq, vars);\r\n            });\r\n\r\n            var J = jacobian.map(function (e) {\r\n                return build(e, vars);\r\n            }, true);\r\n            //initial values\r\n            xn1 = core.Matrix.cMatrix(0, vars);\r\n\r\n            //initialize the c matrix with something close to 0. \r\n            var c = core.Matrix.cMatrix(start, vars);\r\n\r\n            iters = 0;\r\n\r\n            //start of algorithm\r\n            do {\r\n                //if we've reached the max iterations then exit\r\n                if(iters > max_iter) {\r\n                    break;\r\n                    found = false;\r\n                }\r\n\r\n                //set the substitution object\r\n                o = create_subs(vars, c);\r\n\r\n                //set xn\r\n                xn = c.clone();\r\n\r\n                //make all the substitutions for each of the equations\r\n                f_eqns.forEach(function (f, i) {\r\n                    c.set(i, 0, f.apply(null, o));\r\n                });\r\n\r\n                var m = new core.Matrix();\r\n                J.each(function (fn, i, j) {\r\n                    var ans = fn.apply(null, o);\r\n                    m.set(i, j, ans);\r\n                });\r\n\r\n                m = m.invert();\r\n\r\n                //preform the elimination\r\n                y = _.multiply(m, c).negate();\r\n\r\n                //the callback is to avoid overflow in the coeffient denonimator\r\n                //it converts it to a decimal and then back to a fraction. Some precision\r\n                //is lost be it's better than overflow. \r\n                d = y.subtract(xn1, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                xn1 = xn.add(y, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                //move c is now xn1\r\n                c = xn1;\r\n\r\n                //get the norm\r\n\r\n                //the expectation is that we're converging to some answer as this point regardless of where we start\r\n                //this may have to be adjusted at some point because of erroneous assumptions\r\n                if(iters >= jump_at) {\r\n                    //check the norm. If the norm is greater than one then it's time to try another point\r\n                    if(norm > 1) {\r\n                        //reset the start point at halway\r\n                        if(tries === halfway)\r\n                            start = 0;\r\n                        var sign = tries > halfway ? 1 : -1; //which side are we incrementing\r\n                        //we increment +n at one side and -n at the other. \r\n                        n = (tries % Math.floor(halfway)) + 1;\r\n                        //adjust the start point\r\n                        start += (sign * n * jump);\r\n                        //call restart\r\n                        return __.solveNonLinearSystem(eqns, --tries, start);\r\n                    }\r\n                }\r\n                lnorm = norm;\r\n                iters++;\r\n                norm = d.max();\r\n\r\n                //exit early. Revisit if we get bugs\r\n                if(Number(norm) === Number(lnorm)) {\r\n                    break;\r\n                }\r\n            }\r\n            while(Number(norm) >= Number.EPSILON)\r\n\r\n            //return a blank set if nothing was found;\r\n            if(!found)\r\n                return [];\r\n\r\n            //return c since that's the answer\r\n            return __.systemSolutions(c, vars, true, function (x) {\r\n                return core.Utils.round(Number(x), 14);\r\n            });\r\n        },\r\n        systemSolutions: function (result, vars, expand_result, callback) {\r\n            var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\r\n\r\n            result.each(function (e, idx) {\r\n                var solution = (expand_result ? _.expand(e) : e).valueOf();\r\n                if(callback)\r\n                    solution = callback.call(e, solution);\r\n                var variable = vars[idx];\r\n                if(core.Settings.SOLUTIONS_AS_OBJECT) {\r\n                    solutions[variable] = solution;\r\n                }\r\n                else\r\n                    solutions.push([variable, solution]); /*NO*/\r\n            });\r\n            //done\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solves a system of equations by substitution. This is useful when\r\n         * no distinct solution exists. e.g. a line, plane, etc.\r\n         * @param {Array} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveSystemBySubstitution: function (eqns) {\r\n            // Assume at least 2 equations. The function variables will just return an empty array if undefined is provided\r\n            var vars_a = variables(eqns[0]);\r\n            var vars_b = variables(eqns[1]);\r\n            // Check if it's a circle equation\r\n            if(eqns.length === 2 && vars_a.length === 2 && core.Utils.arrayEqual(vars_a, vars_b)) {\r\n                return __.solveCircle(eqns, vars_a);\r\n            }\r\n\r\n            return []; // return an empty set\r\n        },\r\n\r\n        //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\r\n        /**\r\n         * Solves a systems of equations\r\n         * @param {Array} eqns An array of equations\r\n         * @param {Array} var_array An array of variables\r\n         * @returns {Array|object}\r\n         */\r\n        solveSystem: function (eqns, var_array) {\r\n            //check if a var_array was specified\r\n            //nerdamer.clearVars();// this deleted ALL variables: not what we want\r\n            //parse all the equations to LHS. Remember that they come in as strings\r\n            for(var i = 0; i < eqns.length; i++)\r\n                eqns[i] = __.toLHS(eqns[i]);\r\n\r\n            var l = eqns.length,\r\n                    m = new core.Matrix(),\r\n                    c = new core.Matrix(),\r\n                    expand_result = false,\r\n                    vars;\r\n\r\n            if(typeof var_array === 'undefined') {\r\n                //check to make sure that all the equations are linear\r\n                if(!_A.allLinear(eqns)) {\r\n                    try {\r\n                        return __.solveNonLinearSystem(eqns);\r\n                    }\r\n                    catch(e) {\r\n                        if(e instanceof core.exceptions.DivisionByZero) {\r\n                            return __.solveSystemBySubstitution(eqns);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vars = core.Utils.arrayGetVariables(eqns);\r\n\r\n                // Deal with redundant equations as expressed in #562\r\n                // The fix is to remove all but the number of equations equal to the number\r\n                // of variables. We then solve those and then evaluate the remaining equations\r\n                // with those solutions. If the all equal true then those are just redundant\r\n                // equations and we can return the solution set.\r\n                if(vars.length < eqns.length) {\r\n                    var reduced = [];\r\n                    var n = eqns.length;\r\n                    for(var i = 0; i < n - 1; i++) {\r\n                        reduced.push(_.parse(eqns[i]));\r\n                    }\r\n\r\n                    var knowns = {};\r\n                    var solutions = __.solveSystem(reduced, vars);\r\n                    // The solutions may have come back as an array\r\n                    if(Array.isArray(solutions)) {\r\n                        solutions.forEach(function (sol) {\r\n                            knowns[sol[0]] = sol[1];\r\n                        });\r\n                    }\r\n                    else {\r\n                        knowns = solutions;\r\n                    }\r\n\r\n                    // Start by assuming they will all evaluate to zero. If even one fails\r\n                    // then all zero will be false\r\n                    var all_zero = true;\r\n                    // Check if the last solution evalutes to zero given these solutions\r\n                    for(var i = n - 1; i < n; i++) {\r\n                        if(!_.parse(eqns[i], knowns).equals(0)) {\r\n                            all_zero = false;\r\n                        }\r\n                    }\r\n\r\n                    if(all_zero) {\r\n                        return solutions;\r\n                    }\r\n                }\r\n\r\n                // deletes only the variables of the linear equations in the nerdamer namespace\r\n                for(var i = 0; i < vars.length; i++) {\r\n                    nerdamer.setVar(vars[i], \"delete\");\r\n                }\r\n                // TODO: move this to cMatrix or something similar\r\n                // populate the matrix\r\n                for(var i = 0; i < l; i++) {\r\n                    var e = eqns[i]; //store the expression\r\n                    // Iterate over the columns\r\n                    for(var j = 0; j < vars.length; j++) {\r\n                        var v = vars[j];\r\n                        var coeffs = [];\r\n                        e.each(function (x) {\r\n                            if(x.contains(v)) {\r\n                                coeffs = coeffs.concat(x.coeffs());\r\n                            }\r\n                        });\r\n\r\n                        var cf = core.Utils.arraySum(coeffs);\r\n                        m.set(i, j, cf);\r\n                    }\r\n\r\n                    //strip the variables from the symbol so we're left with only the zeroth coefficient\r\n                    //start with the symbol and remove each variable and its coefficient\r\n                    var num = e.clone();\r\n                    vars.map(function (e) {\r\n                        num = num.stripVar(e, true);\r\n                    });\r\n                    c.set(i, 0, num.negate());\r\n                }\r\n            }\r\n            else {\r\n                /**\r\n                 * The idea is that we loop through each equation and then expand it. Afterwards we loop\r\n                 * through each term and see if and check to see if it matches one of the variables.\r\n                 * When a match is found we mark it. No other match should be found for that term. If it\r\n                 * is we stop since it's not linear.\r\n                 */\r\n                vars = var_array;\r\n                expand_result = true;\r\n                for(i = 0; i < l; i++) {\r\n                    //prefill\r\n                    c.set(i, 0, new Symbol(0));\r\n                    var e = _.expand(eqns[i]).collectSymbols(); //expand and store\r\n                    //go trough each of the variables\r\n                    for(var j = 0; j < var_array.length; j++) {\r\n                        m.set(i, j, new Symbol(0));\r\n                        var v = var_array[j];\r\n                        //go through the terms and sort the variables\r\n                        for(var k = 0; k < e.length; k++) {\r\n                            var term = e[k],\r\n                                    check = false;\r\n                            for(var z = 0; z < var_array.length; z++) {\r\n                                //check to see if terms contain multiple variables\r\n                                if(term.contains(var_array[z])) {\r\n                                    if(check)\r\n                                        core.err('Multiple variables found for term ' + term);\r\n                                    check = true;\r\n                                }\r\n                            }\r\n                            //we made sure that every term contains one variable so it's safe to assume that if the\r\n                            //variable is found then the remainder is the coefficient.\r\n                            if(term.contains(v)) {\r\n                                var tparts = explode(remove(e, k), v);\r\n                                m.set(i, j, _.add(m.get(i, j), tparts[0]));\r\n                            }\r\n                        }\r\n                    }\r\n                    //all the remaining terms go to the c matrix\r\n                    for(k = 0; k < e.length; k++) {\r\n                        c.set(i, 0, _.add(c.get(i, 0), e[k]));\r\n                    }\r\n                }\r\n                //consider case (a+b)*I+u\r\n            }\r\n\r\n            //check if the system has a distinct solution\r\n            if(vars.length !== eqns.length || m.determinant().equals(0)) {\r\n                // solve the system by hand\r\n                //return __.solveSystemBySubstitution(eqns, vars, m, c);\r\n                throw new core.exceptions.SolveError('System does not have a distinct solution');\r\n            }\r\n\r\n            // Use M^-1*c to solve system\r\n            m = m.invert();\r\n            var result = m.multiply(c);\r\n            //correct the sign as per issue #410\r\n            if(core.Utils.isArray(var_array))\r\n                result.each(function (x) {\r\n                    return x.negate();\r\n                });\r\n\r\n            return __.systemSolutions(result, vars, expand_result);\r\n        },\r\n        /**\r\n         * The quadratic function but only one side.\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Symbol}\r\n         */\r\n        quad: function (c, b, a) {\r\n            var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))/*b^2 - 4ac*/;\r\n            var det = _.pow(discriminant, Symbol(0.5));\r\n            var den = _.parse(_.multiply(new Symbol(2), a.clone()));\r\n            var retval = [\r\n                _.parse(format('(-({0})+({1}))/({2})', b, det, den)),\r\n                _.parse(format('(-({0})-({1}))/({2})', b, det, den))\r\n            ];\r\n\r\n            return retval;\r\n        },\r\n        /**\r\n         * The cubic equation\r\n         * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\r\n         * @param {Symbol} d_o\r\n         * @param {Symbol} c_o\r\n         * @param {Symbol} b_o\r\n         * @param {Symbol} a_o\r\n         * @returns {Array}\r\n         */\r\n        cubic: function (d_o, c_o, b_o, a_o) {\r\n            //convert everything to text\r\n            var a = a_o.text(), b = b_o.text(), c = c_o.text(), d = d_o.text();\r\n\r\n            var t = `(-(${b})^3/(27*(${a})^3)+(${b})*(${c})/(6*(${a})^2)-(${d})/(2*(${a})))`;\r\n            var u = `((${c})/(3*(${a}))-(${b})^2/(9*(${a})^2))`;\r\n            var v = `(${b})/(3*(${a}))`;\r\n            var x = `((${t})+sqrt((${t})^2+(${u})^3))^(1/3)+((${t})-sqrt((${t})^2+(${u})^3))^(1/3)-(${v})`;\r\n\r\n            // Convert a to one\r\n            var w = '1/2+sqrt(3)/2*i'; // Cube root of unity\r\n\r\n            return [\r\n                _.parse(x),\r\n                _.parse(`(${x})(${w})`),\r\n                _.parse(`(${x})(${w})^2`)\r\n            ];\r\n        },\r\n        /**\r\n         * The quartic equation\r\n         * @param {Symbol} e\r\n         * @param {Symbol} d\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Array}\r\n         */\r\n        quartic: function (e, d, c, b, a) {\r\n            var scope = {};\r\n            core.Utils.arrayUnique(variables(a).concat(variables(b))\r\n                    .concat(variables(c)).concat(variables(d)).concat(variables(e)))\r\n                    .map(function (x) {\r\n                        scope[x] = 1;\r\n                    });\r\n            a = a.toString();\r\n            b = b.toString();\r\n            c = c.toString();\r\n            d = d.toString();\r\n            e = e.toString();\r\n            var p, q, D, D0, D1, Q, x1, x2, x3, x4;\r\n            /*var D = core.Utils.block('PARSE2NUMBER', function() {\r\n             return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\r\n             \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\r\n             \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \r\n             a, b, c, d, e), scope);\r\n             });*/\r\n\r\n            p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\r\n            q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString();//a, b, c, d, e\r\n            D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\r\n            S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\r\n            x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            return [x1, x2, x3, x4];\r\n        },\r\n        /**\r\n         * Breaks the equation up in its factors and tries to solve the smaller parts\r\n         * @param {Symbol} symbol\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        divideAndConquer: function (symbol, solve_for) {\r\n            var sols = [];\r\n            //see if we can solve the factors\r\n            var factors = core.Algebra.Factor.factor(symbol);\r\n            if(factors.group === CB) {\r\n                factors.each(function (x) {\r\n                    x = Symbol.unwrapPARENS(x);\r\n                    sols = sols.concat(solve(x, solve_for));\r\n                });\r\n            }\r\n            return sols;\r\n        },\r\n        /**\r\n         * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\r\n         * @param {Symbol} eq\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        csolve: function (eq, solve_for) {\r\n            return core.Utils.block('IGNORE_E', function () {\r\n                var f, p, pn, n, pf, r, theta, sr, sp, roots;\r\n                roots = [];\r\n                f = core.Utils.decompose_fn(eq, solve_for, true);\r\n                if(f.x.group === S) {\r\n                    p = _.parse(f.x.power);\r\n                    pn = Number(p);\r\n                    n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\r\n                    pf = Symbol.toPolarFormArray(n);\r\n                    r = pf[0];\r\n                    theta = pf[1];\r\n                    sr = r.toString();\r\n                    sp = p.toString();\r\n                    var k, root, str;\r\n                    for(var i = 0; i < pn; i++) {\r\n                        k = i;\r\n                        str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\r\n                        root = _.parse(str);\r\n                        roots.push(root);\r\n                    }\r\n                }\r\n                return roots;\r\n            }, true);\r\n        },\r\n        /**\r\n         * Generates starting points for the Newton solver given an expression at zero.\r\n         * It beings by check if zero is a good point and starts expanding by a provided step size. \r\n         * Builds on the fact that if the sign changes over an interval then a zero\r\n         * must exist on that interval\r\n         * @param {Symbol} symbol\r\n         * @param {Number} step\r\n         * @param {Array} points\r\n         * @returns {Array}\r\n         */\r\n        getPoints: function (symbol, step, points) {\r\n            step = step || 0.01;\r\n            points = points || [];\r\n            var f = build(symbol);\r\n            var x0 = 0;\r\n\r\n            var start = Math.round(x0),\r\n                    last = f(start),\r\n                    last_sign = last / Math.abs(last),\r\n                    rside = core.Settings.ROOTS_PER_SIDE, // the max number of roots on right side\r\n                    lside = rside; // the max number of roots on left side\r\n            // check around the starting point\r\n            points.push(Math.floor(start / 2)); //half way from zero might be a good start\r\n            points.push(Math.abs(start)); //|f(0)| could be a good start\r\n            points.push(start);//|f(0)| could be a good start\r\n            //adjust for log. A good starting point to include for log is 0.1\r\n            symbol.each(function (x) {\r\n                if(x.containsFunction(core.Settings.LOG))\r\n                    points.push(0.1);\r\n            });\r\n\r\n            var left = range(-core.Settings.SOLVE_RADIUS, start, step),\r\n                    right = range(start, core.Settings.SOLVE_RADIUS, step);\r\n\r\n            var test_side = function (side, num_roots) {\r\n                var xi, val, sign;\r\n                var hits = [];\r\n                for(var i = 0, l = side.length; i < l; i++) {\r\n                    xi = side[i]; //the point being evaluated\r\n                    val = f(xi);\r\n                    sign = val / Math.abs(val);\r\n                    //Don't add non-numeric values\r\n                    if(isNaN(val) || !isFinite(val) || hits.length > num_roots) {\r\n                        continue;\r\n                    }\r\n\r\n                    //compare the signs. The have to be different if they cross a zero\r\n                    if(sign !== last_sign) {\r\n                        hits.push(xi); //take note of the possible zero location\r\n                    }\r\n                    last_sign = sign;\r\n                }\r\n\r\n                points = points.concat(hits);\r\n            };\r\n\r\n            test_side(left, lside);\r\n            test_side(right, rside);\r\n\r\n            return points;\r\n        },\r\n        /**\r\n         * Implements the bisection method. Returns undefined in no solution is found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @returns {undefined | number}\r\n         */\r\n        bisection: function (point, f) {\r\n            var left = point - 1;\r\n            var right = point + 1;\r\n            // First test if this point is even worth evaluating. It should\r\n            // be crossing the x axis so the signs should be different\r\n            if(Math.sign(f(left)) !== Math.sign(f(right))) {\r\n                var safety = 0;\r\n\r\n                var epsilon, middle;\r\n\r\n                do {\r\n                    epsilon = Math.abs(right - left);\r\n                    // Safety against an infinite loop\r\n                    if(safety++ > core.Settings.MAX_BISECTION_ITER || isNaN(epsilon)) {\r\n                        return;\r\n                    }\r\n                    // Calculate the middle point\r\n                    middle = (left + right) / 2;\r\n\r\n                    if(f(left) * f(middle) > 0) {\r\n                        left = middle;\r\n                    }\r\n                    else {\r\n                        right = middle;\r\n                    }\r\n                }\r\n                while(epsilon >= Settings.EPSILON);\r\n\r\n                var solution = (left + right) / 2;\r\n\r\n                // Test the solution to make sure that it's within tolerance\r\n                var x_point = f(solution);\r\n\r\n                if(!isNaN(x_point) && Math.abs(x_point) <= core.Settings.BI_SECTION_EPSILON) {\r\n                    // Returns too many junk solutions if not rounded at 13th place.\r\n                    return core.Utils.round(solution, 13);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Implements Newton's iterations. Returns undefined if no solutions if found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @param {function} fp\r\n         * @returns {undefined|number}\r\n         */\r\n        Newton: function (point, f, fp) {\r\n            var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\r\n                    iter = 0;\r\n            //first try the point itself. If it's zero viola. We're done\r\n            var x0 = point, x;\r\n            do {\r\n                var fx0 = f(x0); //store the result of the function\r\n                //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\r\n                if(x0 === 0 && fx0 === 0) {\r\n                    x = 0;\r\n                    break;\r\n                }\r\n\r\n                iter++;\r\n                if(iter > maxiter)\r\n                    return; //naximum iterations reached\r\n\r\n                x = x0 - fx0 / fp(x0);\r\n                var e = Math.abs(x - x0);\r\n                x0 = x;\r\n            }\r\n            while(e > Settings.NEWTON_EPSILON)\r\n\r\n            //check if the number is indeed zero. 1e-13 seems to give the most accurate results\r\n            if(Math.abs(f(x)) <= Settings.EPSILON)\r\n                return x;\r\n        },\r\n        rewrite: function (rhs, lhs, for_variable) {\r\n            lhs = lhs || new Symbol(0);\r\n            if(rhs.isComposite() && rhs.isLinear()) {\r\n                //try to isolate the square root\r\n                //container for the square roots\r\n                var sqrts = [];\r\n                //all else\r\n                var rem = [];\r\n                rhs.each(function (x) {\r\n                    x = x.clone();\r\n                    if(x.fname === 'sqrt' && x.contains(for_variable)) {\r\n                        sqrts.push(x);\r\n                    }\r\n                    else {\r\n                        rem.push(x);\r\n                    }\r\n                }, true);\r\n\r\n                if(sqrts.length === 1) {\r\n                    //move the remainder to the RHS\r\n                    lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2)));\r\n                    //square both sides\r\n                    rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\r\n                }\r\n            }\r\n            else {\r\n                rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\r\n            }\r\n\r\n            var c = 0, //a counter to see if we have all terms with the variable\r\n                    l = rhs.length;\r\n            //try to rewrite the whole thing\r\n            if(rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                rhs.distributeMultiplier();\r\n                var t = new Symbol(0);\r\n                //first bring all the terms containing the variable to the lhs\r\n                rhs.each(function (x) {\r\n                    if(x.contains(for_variable)) {\r\n                        c++;\r\n                        t = _.add(t, x.clone());\r\n                    }\r\n                    else\r\n                        lhs = _.subtract(lhs, x.clone());\r\n                });\r\n                rhs = t;\r\n\r\n                //if not all the terms contain the variable so it's in the form\r\n                //a*x^2+x\r\n                if(c !== l) {\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n                }\r\n                else {\r\n                    return [rhs, lhs];\r\n                }\r\n            }\r\n            else if(rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                if(rhs.multiplier.lessThan(0)) {\r\n                    rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\r\n                    lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\r\n                }\r\n                if(lhs.equals(0))\r\n                    return new Symbol(0);\r\n                else {\r\n                    var t = new Symbol(1);\r\n                    rhs.each(function (x) {\r\n                        if(x.contains(for_variable))\r\n                            t = _.multiply(t, x.clone());\r\n                        else\r\n                            lhs = _.divide(lhs, x.clone());\r\n                    });\r\n                    rhs = t;\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n\r\n                }\r\n            }\r\n            else if(!rhs.isLinear() && rhs.contains(for_variable)) {\r\n                var p = _.parse(rhs.power.clone().invert());\r\n                rhs = _.pow(rhs, p.clone());\r\n                lhs = _.pow(_.expand(lhs), p.clone());\r\n                return __.rewrite(rhs, lhs, for_variable);\r\n            }\r\n            else if(rhs.group === FN || rhs.group === S || rhs.group === PL) {\r\n                return [rhs, lhs];\r\n            }\r\n        },\r\n        sqrtSolve: function (symbol, v) {\r\n            var sqrts = new Symbol(0);\r\n            var rem = new Symbol(0);\r\n            if(symbol.isComposite()) {\r\n                symbol.each(function (x) {\r\n                    if(x.fname === 'sqrt' && x.contains(v)) {\r\n                        sqrts = _.add(sqrts, x.clone());\r\n                    }\r\n                    else {\r\n                        rem = _.add(rem, x.clone());\r\n                    }\r\n                });\r\n                //quick and dirty ATM\r\n                if(!sqrts.equals(0)) {\r\n                    var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2)))));\r\n                    //square both sides\r\n                    var solutions = solve(t, v);\r\n                    //test the points. The dumb way of getting the answers\r\n                    solutions = solutions.filter(function (e) {\r\n                        if(e.isImaginary())\r\n                            return e;\r\n                        var subs = {};\r\n                        subs[v] = e;\r\n                        var point = evaluate(symbol, subs);\r\n                        if(point.equals(0))\r\n                            return e;\r\n                    });\r\n                    return solutions;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     * \r\n     * @param {String[]|String|Equation} eqns\r\n     * @param {String} solve_for\r\n     * @param {Array} solutions\r\n     * @param {Number} depth\r\n     * @param {String|Equation} fn\r\n     * @returns {Array}\r\n     */\r\n    var solve = function (eqns, solve_for, solutions, depth, fn) {\r\n        depth = depth || 0;\r\n\r\n        if(depth++ > Settings.MAX_SOLVE_DEPTH) {\r\n            return solutions;\r\n        }\r\n\r\n        //make preparations if it's an Equation\r\n        if(eqns instanceof Equation) {\r\n            //if it's zero then we're done\r\n            if(eqns.isZero()) {\r\n                return [new Symbol(0)];\r\n            }\r\n            //if the lhs = x then we're done\r\n            if(eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\r\n                return [eqns.RHS];\r\n            }\r\n            //if the rhs = x then we're done\r\n            if(eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\r\n                return [eqns.LHS];\r\n            }\r\n        }\r\n\r\n        //unwrap the vector since what we want are the elements\r\n        if(eqns instanceof core.Vector)\r\n            eqns = eqns.elements;\r\n        solve_for = solve_for || 'x'; //assumes x by default\r\n        //If it's an array then solve it as a system of equations\r\n        if(isArray(eqns)) {\r\n            return __.solveSystem.apply(undefined, arguments);\r\n        }\r\n\r\n        // Parse out functions. Fix for issue #300\r\n        // eqns = core.Utils.evaluate(eqns);\r\n        solutions = solutions || [];\r\n        //mark existing solutions as not to have duplicates\r\n        var existing = {};\r\n\r\n        // Easy fail. If it's a rational function and the denominator is zero\r\n        // the we're done. Issue #555\r\n        var known = {};\r\n        known[solve_for] = 0;\r\n        if(isSymbol(eqns) && evaluate(eqns.getDenom(), known).equals(0) === true) {\r\n            return solutions;\r\n        }\r\n\r\n        // Is usued to add solutions to set. \r\n        // TODO: Set is now implemented and should be utilized\r\n        var add_to_result = function (r, has_trig) {\r\n            var r_is_symbol = isSymbol(r);\r\n            if(r === undefined || typeof r === 'number' && isNaN(r))\r\n                return;\r\n            if(isArray(r)) {\r\n                r.forEach(function (sol) {\r\n                    add_to_result(sol);\r\n                });\r\n            }\r\n            else {\r\n                if(r.valueOf() !== 'null') {\r\n                    // Call the pre-add function if defined. This could be useful for rounding\r\n                    if(typeof core.Settings.PRE_ADD_SOLUTION === 'function') {\r\n                        r = core.Settings.PRE_ADD_SOLUTION(r);\r\n                    }\r\n\r\n                    if(!r_is_symbol) {\r\n                        r = _.parse(r);\r\n                    }\r\n                    // try to convert the number to multiples of pi\r\n                    if(core.Settings.make_pi_conversions && has_trig) {\r\n                        var temp = _.divide(r.clone(), new Symbol(Math.PI)),\r\n                                m = temp.multiplier,\r\n                                a = Math.abs(m.num),\r\n                                b = Math.abs(m.den);\r\n                        if(a < 10 && b < 10)\r\n                            r = _.multiply(temp, new Symbol('pi'));\r\n                    }\r\n\r\n                    // And check if we get a number otherwise we might be throwing out symbolic solutions.\r\n                    var r_str = r.toString();\r\n\r\n                    if(!existing[r_str]) {\r\n                        solutions.push(r);\r\n                    }\r\n                    // Mark the answer as seen\r\n                    existing[r_str] = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        // Maybe we get lucky. Try the point at the function. If it works we have a point\r\n        // If not it failed\r\n        if(eqns.group === S && eqns.contains(solve_for)) {\r\n            try {\r\n                var o = {};\r\n                o[solve_for] = 0;\r\n                evaluate(fn, o, 'numer');\r\n                add_to_result(new Symbol(0));\r\n            }\r\n            catch(e) {\r\n                // Do nothing;\r\n            }\r\n\r\n            return solutions;\r\n        }\r\n        if(eqns.group === CB) {\r\n            // It suffices to solve for the numerator\r\n            var num = eqns.getNum();\r\n\r\n            if(num.group === CB) {\r\n                var sf = String(solve_for); //everything else belongs to the coeff\r\n                //get the denominator and make sure it doesn't have x since we don't know how to solve for those\r\n                num.each(function (x) {\r\n                    if(x.contains(sf))\r\n                        solve(x, solve_for, solutions, depth, eqns);\r\n                });\r\n\r\n                return solutions;\r\n            }\r\n\r\n            return solve(num, solve_for, solutions, depth, fn);\r\n        }\r\n\r\n        if(eqns.group === FN && eqns.fname === 'sqrt') {\r\n            eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\r\n        }\r\n        //pass in false to not expand equations such as (x+y)^5.\r\n        //It suffices to solve for the numerator since there's no value in the denominator which yields a zero for the function\r\n        var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(),\r\n                vars = core.Utils.variables(eq), //get a list of all the variables\r\n                numvars = vars.length;//how many variables are we dealing with\r\n\r\n        //it sufficient to solve (x+y) if eq is (x+y)^n since 0^n\r\n        if(core.Utils.isInt(eq.power) && eq.power > 0) {\r\n            eq = _.parse(eq).toLinear();\r\n        }\r\n\r\n        //if we're dealing with a single variable then we first check if it's a \r\n        //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \r\n        //Don't waste time\r\n        if(eq.group === S || eq.group === CB && eq.contains(solve_for)) {\r\n            return [new Symbol(0)];\r\n        }\r\n        //force to polynomial. We go through each and then we look at what it would \r\n        //take for its power to be an integer\r\n        //if the power is a fractional we divide by the fractional power\r\n        var fractionals = {},\r\n                cfact;\r\n\r\n        var correct_denom = function (symbol) {\r\n            symbol = _.expand(symbol, {\r\n                expand_denominator: true,\r\n                expand_functions: true\r\n            });\r\n            var original = symbol.clone(); //preserve the original\r\n\r\n            if(symbol.symbols) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n\r\n                    //get the denominator of the sub-symbol\r\n                    var den = sym.getDenom();\r\n\r\n                    if(!den.isConstant(true) && symbol.isComposite()) {\r\n                        var t = new Symbol(0);\r\n                        symbol.each(function (e) {\r\n                            t = _.add(t, _.multiply(e, den.clone()));\r\n                        });\r\n\r\n                        return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\r\n                    }\r\n\r\n                    var parts = explode(sym, solve_for);\r\n                    var is_sqrt = parts[1].fname === core.Settings.SQRT;\r\n                    var v = Symbol.unwrapSQRT(parts[1]);\r\n                    var p = v.power.clone();\r\n                    //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\r\n                    //this needs to be terminated if p = 1/2\r\n                    if(!isSymbol(p) && !p.equals(1 / 2)) {\r\n                        if(p.den.gt(1)) {\r\n                            if(is_sqrt) {\r\n                                symbol = _.subtract(symbol, sym.clone());\r\n                                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\r\n                                return correct_denom(symbol);\r\n                            }\r\n                            var c = fractionals[p.den];\r\n                            fractionals[p.den] = c ? c++ : 1;\r\n                        }\r\n                        else if(p.sign() === -1) {\r\n                            var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\r\n                            //unwrap the symbol's denoniator\r\n                            symbol.each(function (y, index) {\r\n                                if(y.contains(solve_for)) {\r\n                                    symbol.symbols[index] = _.multiply(y, factor.clone());\r\n                                }\r\n                            });\r\n                            fractionals = {};\r\n                            return correct_denom(_.parse(symbol));\r\n                        }\r\n                        else if(sym.group === PL) {\r\n                            var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\r\n                            if(min_p < 0) {\r\n                                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\r\n                                var corrected = new Symbol(0);\r\n                                original.each(function (x) {\r\n                                    corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\r\n                                }, true);\r\n                                return corrected;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return symbol;\r\n        };\r\n\r\n        //separate the equation\r\n        var separate = function (eq) {\r\n            var lhs = new Symbol(0),\r\n                    rhs = new Symbol(0);\r\n            eq.each(function (x) {\r\n                if(x.contains(solve_for, true))\r\n                    lhs = _.add(lhs, x.clone());\r\n                else\r\n                    rhs = _.subtract(rhs, x.clone());\r\n            });\r\n            return [lhs, rhs];\r\n        };\r\n\r\n        __.inverseFunctionSolve = function (name, lhs, rhs) {\r\n            //ax+b comes back as [a, x, ax, b];\r\n            var parts = explode(lhs.args[0], solve_for);\r\n            //check if x is by itself\r\n            var x = parts[1];\r\n            if(x.group === S) {\r\n                return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\r\n            }\r\n\r\n        };\r\n\r\n        //first remove any denominators\r\n        eq = correct_denom(eq);\r\n\r\n        if(eq.equals(0))\r\n            return [eq];\r\n        //correct fractionals. I can only handle one type right now\r\n        var fkeys = core.Utils.keys(fractionals);\r\n        if(fkeys.length === 1) {\r\n            //make a note of the factor\r\n            cfact = fkeys[0];\r\n            eq.each(function (x, index) {\r\n                if(x.contains(solve_for)) {\r\n                    var parts = explode(x, solve_for);\r\n                    var v = parts[1];\r\n                    var p = v.power;\r\n                    if(p.den.gt(1)) {\r\n                        v.power = p.multiply(new core.Frac(cfact));\r\n                        eq.symbols[index] = _.multiply(v, parts[0]);\r\n                    }\r\n                }\r\n            });\r\n            eq = _.parse(eq);\r\n        }\r\n\r\n        //try for nested sqrts as per issue #486\r\n        add_to_result(__.sqrtSolve(eq, solve_for));\r\n\r\n        //polynomial single variable\r\n        if(numvars === 1) {\r\n            if(eq.isPoly(true)) {\r\n                //try to factor and solve\r\n                var factors = new core.Algebra.Classes.Factors();\r\n\r\n                core.Algebra.Factor.factor(eq, factors);\r\n                //if the equation has more than one symbolic factor then solve those individually\r\n                if(factors.getNumberSymbolics() > 1) {\r\n                    for(var x in factors.factors) {\r\n                        add_to_result(solve(factors.factors[x], solve_for));\r\n                    }\r\n                }\r\n                else {\r\n                    var coeffs = core.Utils.getCoeffs(eq, solve_for),\r\n                            deg = coeffs.length - 1,\r\n                            was_calculated = false;\r\n                    if(vars[0] === solve_for) {\r\n                        //check to see if all the coefficients are constant\r\n                        if(checkAll(coeffs, function (x) {\r\n                            return x.group !== core.groups.N;\r\n                        })) {\r\n                            var roots = core.Algebra.proots(eq);\r\n                            //if all the roots are integers then return those\r\n                            if(checkAll(roots, function (x) {\r\n                                return !core.Utils.isInt(x);\r\n                            })) {\r\n                                //roots have been calculates\r\n                                was_calculated = true;\r\n                                roots.map(function (x) {\r\n                                    add_to_result(new Symbol(x));\r\n                                });\r\n                            }\r\n                        }\r\n\r\n                        if(!was_calculated) {\r\n                            eqns = _.parse(eqns);\r\n                            if(eqns instanceof core.Equation)\r\n                                eqns = eqns.toLHS();\r\n\r\n                            //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\r\n                            if(deg === 1)\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                            else if(deg === 2) {\r\n                                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\r\n                            }\r\n\r\n                            else if(deg === 3) {\r\n                                var solutions = []; //set to blank\r\n                                //first try to factor and solve\r\n                                var factored = core.Algebra.Factor.factor(eqns);\r\n\r\n                                //if it was successfully factored\r\n                                var solutions = [];\r\n                                if(solutions.length > 0)\r\n                                    add_to_result(solutions);\r\n                                else\r\n                                    add_to_result(__.cubic.apply(undefined, coeffs));\r\n                            }\r\n\r\n                            else {\r\n                                /*\r\n                                 var sym_roots = csolve(eq, solve_for); \r\n                                 if(sym_roots.length === 0)\r\n                                 sym_roots = divnconsolve(eq, solve_for);\r\n                                 if(sym_roots.length > 0) \r\n                                 add_to_result(sym_roots);\r\n                                 else\r\n                                 */\r\n                                _A.proots(eq).map(add_to_result);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    // Attempt Newton\r\n                    // Since it's not a polynomial then we'll try to look for a solution using Newton's method\r\n                    var has_trig = eq.hasTrig();\r\n                    // we get all the points where a possible zero might exist.\r\n                    var points1 = __.getPoints(eq, 0.1);\r\n                    var points2 = __.getPoints(eq, 0.05);\r\n                    var points3 = __.getPoints(eq, 0.01);\r\n                    var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function (a, b) {\r\n                        return a - b;\r\n                    });\r\n                    var i, point, solution;\r\n\r\n                    // Compile the function\r\n                    var f = build(eq.clone());\r\n\r\n                    // First try to eliminate some points using bisection\r\n                    var t_points = [];\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        // See if there's a solution at this point\r\n                        solution = __.bisection(point, f);\r\n\r\n                        // If there's no solution then add it to the array for further investigation\r\n                        if(typeof solution === 'undefined') {\r\n                            t_points.push(point);\r\n                            continue;\r\n                        }\r\n\r\n                        // Add the solution to the solution set\r\n                        add_to_result(solution, has_trig);\r\n                    }\r\n\r\n                    // Reset the points to the remaining points\r\n                    points = t_points;\r\n\r\n                    // Build the derivative and compile a function\r\n                    var d = _C.diff(eq.clone());\r\n                    var fp = build(d);\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        add_to_result(__.Newton(point, f, fp), has_trig);\r\n                    }\r\n                    solutions.sort();\r\n                }\r\n                catch(e) {\r\n                    console.log(e);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            //The idea here is to go through the equation and collect the coefficients\r\n            //place them in an array and call the quad or cubic function to get the results\r\n            if(!eq.hasFunc(solve_for) && eq.isComposite()) {\r\n                try {\r\n                    var factored = core.Algebra.Factor.factor(eq.clone());\r\n\r\n                    if(factored.group === CB) {\r\n                        factored.each(function (x) {\r\n                            add_to_result(solve(x, solve_for));\r\n                        });\r\n                    }\r\n                    else {\r\n                        var coeffs = core.Utils.getCoeffs(eq, solve_for);\r\n\r\n                        var l = coeffs.length,\r\n                                deg = l - 1; //the degree of the polynomial\r\n                        //get the denominator and make sure it doesn't have x\r\n\r\n                        //handle the problem based on the degree\r\n                        switch(deg) {\r\n                            case 0:\r\n                                var separated = separate(eq);\r\n                                var lhs = separated[0],\r\n                                        rhs = separated[1];\r\n                                if(lhs.group === core.groups.EX) {\r\n                                    add_to_result(_.parse(core.Utils.format(core.Settings.LOG + '(({0})/({2}))/' + core.Settings.LOG + '({1})', rhs, lhs.value, lhs.multiplier)));\r\n                                }\r\n                                break;\r\n                            case 1:\r\n                                //nothing to do but to return the quotient of the constant and the LT\r\n                                //e.g. 2*x-1\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                                break;\r\n                            case 2:\r\n                                add_to_result(__.quad.apply(undefined, coeffs));\r\n                                break;\r\n                            case 3:\r\n                                add_to_result(__.cubic.apply(undefined, coeffs));\r\n                                break;\r\n                            case 4:\r\n                                add_to_result(__.quartic.apply(undefined, coeffs));\r\n                                break;\r\n                            default:\r\n                                add_to_result(__.csolve(eq, solve_for));\r\n                                if(solutions.length === 0)\r\n                                    add_to_result(__.divideAndConquer(eq, solve_for));\r\n                        }\r\n\r\n                        if(solutions.length === 0) {\r\n                            //try factoring\r\n                            add_to_result(solve(factored, solve_for, solutions, depth));\r\n                        }\r\n                    }\r\n\r\n                }\r\n                catch(e) { /*something went wrong. EXITING*/\r\n                    ;\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    var rw = __.rewrite(eq, null, solve_for);\r\n                    var lhs = rw[0];\r\n                    var rhs = rw[1];\r\n                    if(lhs.group === FN) {\r\n                        if(lhs.fname === 'abs') {\r\n                            add_to_result([rhs.clone(), rhs.negate()]);\r\n                        }\r\n                        else if(lhs.fname === 'sin') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'cos') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'tan') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === core.Settings.LOG) {\r\n                            //ax+b comes back as [a, x, ax, b];\r\n                            var parts = explode(lhs.args[0], solve_for);\r\n                            //check if x is by itself\r\n                            var x = parts[1];\r\n                            if(x.group === S) {\r\n                                rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\r\n                                var eq = new Equation(x, rhs).toLHS();\r\n                                add_to_result(solve(eq, solve_for));\r\n                            }\r\n                        }\r\n                        else\r\n                            add_to_result(_.subtract(lhs, rhs));\r\n                    }\r\n                    else {\r\n                        var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\r\n\r\n                        if(neq.equals(eq))\r\n                            throw new Error('Stopping. No stop condition exists');\r\n                        add_to_result(solve(neq, solve_for));\r\n                    }\r\n                }\r\n                catch(error) {\r\n                    //Let's try this another way\r\n                    try {\r\n                        //1. if the symbol is in the form a*b*c*... then the solution is zero if \r\n                        //either a or b or c is zero.\r\n                        if(eq.group === CB)\r\n                            add_to_result(0);\r\n                        else if(eq.group === CP) {\r\n                            var separated = separate(eq);\r\n                            var lhs = separated[0],\r\n                                    rhs = separated[1];\r\n\r\n                            //reduce the equation\r\n                            if(lhs.group === core.groups.EX && lhs.value === solve_for) {\r\n                                //change the base of both sides\r\n                                var p = lhs.power.clone().invert();\r\n                                add_to_result(_.pow(rhs, p));\r\n                            }\r\n                        }\r\n                    }\r\n                    catch(error) {\r\n                        ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(cfact) {\r\n            solutions = solutions.map(function (x) {\r\n                return _.pow(x, new Symbol(cfact));\r\n            });\r\n        }\r\n\r\n        // Perform some cleanup but don't do it agains arrays, etc\r\n        // Check it actually evaluates to zero\r\n        if(isSymbol(eqns)) {\r\n            var knowns = {};\r\n            solutions = solutions.filter(function (x) {\r\n                try {\r\n                    knowns[solve_for] = x;\r\n                    var zero = Number(evaluate(eqns, knowns));\r\n\r\n                    // Allow symbolic answers\r\n                    if(isNaN(zero)) {\r\n                        return true;\r\n                    }\r\n                    return true;\r\n                }\r\n                catch(e) {\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n\r\n        return solutions;\r\n    };\r\n\r\n    //Register the functions for external use\r\n    nerdamer.register([\r\n        {\r\n            name: 'solveEquations',\r\n            parent: 'nerdamer',\r\n            numargs: -1,\r\n            visible: true,\r\n            build: function () {\r\n                return solve; //comment out to return a vector\r\n                /*\r\n                 return function() {\r\n                 return core.Utils.convertToVector(solve.apply(null, arguments));\r\n                 };\r\n                 */\r\n            }\r\n        },\r\n        {\r\n            name: 'solve',\r\n            parent: 'Solve',\r\n            numargs: 2,\r\n            visible: true,\r\n            build: function () {\r\n                return core.Solve.solve;\r\n            }\r\n        },\r\n        {\r\n            name: 'setEquation',\r\n            parent: 'Solve',\r\n            visible: true,\r\n            build: function () {\r\n                return setEq;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.api();\r\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmVyZGFtZXIvU29sdmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmFuaWxsYS1pbnRlZ3JhdGlvbi0yZC8uL25vZGVfbW9kdWxlcy9uZXJkYW1lci9Tb2x2ZS5qcz82MDZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEF1dGhvciA6IE1hcnRpbiBEb25rXHJcbiAqIFdlYnNpdGUgOiBodHRwOi8vd3d3Lm5lcmRhbWVyLmNvbVxyXG4gKiBFbWFpbCA6IG1hcnRpbi5yLmRvbmtAZ21haWwuY29tXHJcbiAqIFNvdXJjZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9qaWdnenNvbi9uZXJkYW1lclxyXG4gKi9cclxuLyogZ2xvYmFsIG1vZHVsZSAqL1xyXG5cclxuaWYoKHR5cGVvZiBtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgdmFyIG5lcmRhbWVyID0gcmVxdWlyZSgnLi9uZXJkYW1lci5jb3JlLmpzJyk7XHJcbiAgICByZXF1aXJlKCcuL0NhbGN1bHVzLmpzJyk7XHJcbiAgICByZXF1aXJlKCcuL0FsZ2VicmEuanMnKTtcclxufVxyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vaGFuZGxlIGltcG9ydHNcclxuICAgIHZhciBjb3JlID0gbmVyZGFtZXIuZ2V0Q29yZSgpLFxyXG4gICAgICAgICAgICBfID0gY29yZS5QQVJTRVIsXHJcbiAgICAgICAgICAgIF9BID0gY29yZS5BbGdlYnJhLFxyXG4gICAgICAgICAgICBfQyA9IGNvcmUuQ2FsY3VsdXMsXHJcbiAgICAgICAgICAgIGV4cGxvZGUgPSBfQy5pbnRlZ3JhdGlvbi5kZWNvbXBvc2VfYXJnLFxyXG4gICAgICAgICAgICBldmFsdWF0ZSA9IGNvcmUuVXRpbHMuZXZhbHVhdGUsXHJcbiAgICAgICAgICAgIHJlbW92ZSA9IGNvcmUuVXRpbHMucmVtb3ZlLFxyXG4gICAgICAgICAgICBmb3JtYXQgPSBjb3JlLlV0aWxzLmZvcm1hdCxcclxuICAgICAgICAgICAgYnVpbGQgPSBjb3JlLlV0aWxzLmJ1aWxkLFxyXG4gICAgICAgICAgICBrbm93blZhcmlhYmxlID0gY29yZS5VdGlscy5rbm93blZhcmlhYmxlLFxyXG4gICAgICAgICAgICBTeW1ib2wgPSBjb3JlLlN5bWJvbCxcclxuICAgICAgICAgICAgaXNTeW1ib2wgPSBjb3JlLlV0aWxzLmlzU3ltYm9sLFxyXG4gICAgICAgICAgICB2YXJpYWJsZXMgPSBjb3JlLlV0aWxzLnZhcmlhYmxlcyxcclxuICAgICAgICAgICAgUyA9IGNvcmUuZ3JvdXBzLlMsXHJcbiAgICAgICAgICAgIFBMID0gY29yZS5ncm91cHMuUEwsXHJcbiAgICAgICAgICAgIENCID0gY29yZS5ncm91cHMuQ0IsXHJcbiAgICAgICAgICAgIENQID0gY29yZS5ncm91cHMuQ1AsXHJcbiAgICAgICAgICAgIEZOID0gY29yZS5ncm91cHMuRk4sXHJcbiAgICAgICAgICAgIFNldHRpbmdzID0gY29yZS5TZXR0aW5ncyxcclxuICAgICAgICAgICAgcmFuZ2UgPSBjb3JlLlV0aWxzLnJhbmdlLFxyXG4gICAgICAgICAgICBpc0FycmF5ID0gY29yZS5VdGlscy5pc0FycmF5O1xyXG5cclxuXHJcbiAgICAvLyBUaGUgc2VhcmNoIHJhZGl1cyBmb3IgdGhlIHJvb3RzXHJcbiAgICBjb3JlLlNldHRpbmdzLlNPTFZFX1JBRElVUyA9IDEwMDA7XHJcbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgdG8gZmlzaCBmb3Igb24gZWFjaCBzaWRlIG9mIHRoZSB6ZXJvXHJcbiAgICBjb3JlLlNldHRpbmdzLlJPT1RTX1BFUl9TSURFID0gMTA7XHJcbiAgICAvLyBDb3ZlcnQgdGhlIG51bWJlciB0byBtdWx0aXBsZXMgb2YgcGkgaWYgcG9zc2libGVcclxuICAgIGNvcmUuU2V0dGluZ3MubWFrZV9waV9jb252ZXJzaW9ucyA9IGZhbHNlO1xyXG4gICAgLy8gVGhlIHN0ZXAgc2l6ZVxyXG4gICAgY29yZS5TZXR0aW5ncy5TVEVQX1NJWkUgPSAwLjE7XHJcbiAgICAvLyBUaGUgZXBzaWxvbiBzaXplXHJcbiAgICBjb3JlLlNldHRpbmdzLkVQU0lMT04gPSAxZS0xMztcclxuICAgIC8vdGhlIG1heGltdW0gaXRlcmF0aW9ucyBmb3IgTmV3dG9uJ3MgbWV0aG9kXHJcbiAgICBjb3JlLlNldHRpbmdzLk1BWF9ORVdUT05fSVRFUkFUSU9OUyA9IDIwMDtcclxuICAgIC8vdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWUgbm9uLWxpbmVhciBzb2x2ZSB0cmllcyBhbm90aGVyIGp1bXAgcG9pbnRcclxuICAgIGNvcmUuU2V0dGluZ3MuTUFYX05PTl9MSU5FQVJfVFJJRVMgPSAxMjtcclxuICAgIC8vdGhlIGFtb3VudCBvZiBpdGVyYXRpb25zIHRoZSBmdW5jdGlvbiB3aWxsIHN0YXJ0IHRvIGp1bXAgYXRcclxuICAgIGNvcmUuU2V0dGluZ3MuTk9OX0xJTkVBUl9KVU1QX0FUID0gNTA7XHJcbiAgICAvL3RoZSBzaXplIG9mIHRoZSBqdW1wXHJcbiAgICBjb3JlLlNldHRpbmdzLk5PTl9MSU5FQVJfSlVNUF9TSVpFID0gMTAwO1xyXG4gICAgLy90aGUgb3JpZ2luYWwgc3RhcnRpbmcgcG9pbnQgZm9yIG5vbmxpbmVhciBzb2x2aW5nXHJcbiAgICBjb3JlLlNldHRpbmdzLk5PTl9MSU5FQVJfU1RBUlQgPSAwLjAxO1xyXG4gICAgLy9XaGVuIHBvaW50cyBhcmUgZ2VuZXJhdGVkIGFzIHN0YXJ0aW5nIHBvaW50cyBmb3IgTmV3dG9uJ3MgbWV0aG9kLCB0aGV5IGFyZSBzbGljZWQgaW50byBzbWFsbFxyXG4gICAgLy9zbGljZXMgdG8gbWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBjb252ZXJnZW5jZSBvbiB0aGUgcmlnaHQgcG9pbnQuIFRoaXMgZGVmaW5lcyB0aGUgXHJcbiAgICAvL3NpemUgb2YgdGhlIHNsaWNlXHJcbiAgICBjb3JlLlNldHRpbmdzLk5FV1RPTl9TTElDRVMgPSAyMDA7XHJcbiAgICAvL1RoZSBlcHNpbG9uIHVzZWQgaW4gTmV3dG9uJ3MgaXRlcmF0aW9uXHJcbiAgICBjb3JlLlNldHRpbmdzLk5FV1RPTl9FUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gKiAyO1xyXG4gICAgLy9UaGUgZGlzdGFuY2UgaW4gd2hpY2ggdHdvIHNvbHV0aW9ucyBhcmUgZGVlbWVkIHRoZSBzYW1lXHJcbiAgICBjb3JlLlNldHRpbmdzLlNPTFVUSU9OX1BST1hJTUlUWSA9IDFlLTE0O1xyXG4gICAgLy9JbmRpY2F0ZSB3aGV0ZXIgdG8gZmlsdGVyIHRoZSBzb2x1dGlvbnMgYXJlIG5vdFxyXG4gICAgY29yZS5TZXR0aW5ncy5GSUxURVJfU09MVVRJT05TID0gdHJ1ZTtcclxuICAgIC8vdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY3Vyc2l2ZSBjYWxsc1xyXG4gICAgY29yZS5TZXR0aW5ncy5NQVhfU09MVkVfREVQVEggPSAxMDtcclxuICAgIC8vIFRoZSB0b2xlcmFuY2UgdGhhdCdzIGNvbnNpZGVyZWQgY2xvc2UgZW5vdWdoIHRvIHplcm9cclxuICAgIGNvcmUuU2V0dGluZ3MuWkVST19FUFNJTE9OID0gMWUtOTtcclxuICAgIC8vIFRoZSBtYXhpbXVtIGl0ZXJhdGlvbiBmb3IgdGhlIGJpc2VjdGlvbiBtZXRob2QgaW5jYXNlIG9mIHNvbWUgSlMgc3RyYW5nZW5lc3NcclxuICAgIGNvcmUuU2V0dGluZ3MuTUFYX0JJU0VDVElPTl9JVEVSID0gMjAwMDtcclxuICAgIC8vIFRoZSB0b2xlcmFuY2UgZm9yIHRoZSBiaXNlY3Rpb24gbWV0aG9kXHJcbiAgICBjb3JlLlNldHRpbmdzLkJJX1NFQ1RJT05fRVBTSUxPTiA9IDFlLTEyO1xyXG5cclxuXHJcbiAgICBjb3JlLlN5bWJvbC5wcm90b3R5cGUuaGFzVHJpZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc0Z1bmN0aW9uKFsnY29zJywgJ3NpbicsICd0YW4nLCAnY290JywgJ2NzYycsICdzZWMnXSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvcmUuU3ltYm9sLnByb3RvdHlwZS5oYXNOZWdhdGl2ZVRlcm1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmKHRoaXMuaXNDb21wb3NpdGUoKSkge1xyXG4gICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ltID0gdGhpcy5zeW1ib2xzW3hdO1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltLmdyb3VwID09PSBQTCAmJiBzeW0uaGFzTmVnYXRpdmVUZXJtcygpIHx8IHRoaXMuc3ltYm9sc1t4XS5wb3dlci5sZXNzVGhhbigwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qIG5lcmRhbWVyIHZlcnNpb24gMC43LnggYW5kIHVwIGFsbG93cyB1cyB0byBtYWtlIGJldHRlciB1c2Ugb2Ygb3BlcmF0b3Igb3ZlcmxvYWRpbmdcclxuICAgICAqIEFzIHN1Y2ggd2UgY2FuIGhhdmUgdGhpcyBkYXRhIHR5cGUgYmUgc3VwcG9ydGVkIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgY29yZS5cclxuICAgICAqIFRoaXMgaXMgYW4gZXF1YXRpb24gdGhhdCBoYXMgYSBsZWZ0IGhhbmQgc2lkZSBhbmQgYSByaWdodCBoYW5kIHNpZGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXF1YXRpb24obGhzLCByaHMpIHtcclxuICAgICAgICBpZihyaHMuaXNDb25zdGFudCgpICYmIGxocy5pc0NvbnN0YW50KCkgJiYgIWxocy5lcXVhbHMocmhzKSB8fCBsaHMuZXF1YWxzKGNvcmUuU2V0dGluZ3MuSU1BR0lOQVJZKSB8fCByaHMuZXF1YWxzKGNvcmUuU2V0dGluZ3MuSU1BR0lOQVJZKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuZXhjZXB0aW9ucy5OZXJkYW1lclZhbHVlRXJyb3IobGhzLnRvU3RyaW5nKCkgKyAnIGRvZXMgbm90IGVxdWFsICcgKyByaHMudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgdGhpcy5MSFMgPSBsaHM7IC8vbGVmdCBoYW5kIHNpZGVcclxuICAgICAgICB0aGlzLlJIUyA9IHJoczsgLy9yaWdodCBhbmQgc2lkZVxyXG4gICAgfVxyXG4gICAgO1xyXG5cclxuICAgIC8vVVRJTFMgIyMhIVxyXG5cclxuICAgIEVxdWF0aW9uLnByb3RvdHlwZSA9IHtcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5MSFMudG9TdHJpbmcoKSArICc9JyArIHRoaXMuUkhTLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZXh0OiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkxIUy50ZXh0KG9wdGlvbikgKyAnPScgKyB0aGlzLlJIUy50ZXh0KG9wdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b0xIUzogZnVuY3Rpb24gKGV4cGFuZCkge1xyXG4gICAgICAgICAgICBleHBhbmQgPSB0eXBlb2YgZXhwYW5kID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGVxbjtcclxuICAgICAgICAgICAgaWYoIWV4cGFuZCkge1xyXG4gICAgICAgICAgICAgICAgZXFuID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXFuID0gdGhpcy5yZW1vdmVEZW5vbSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhID0gZXFuLkxIUztcclxuICAgICAgICAgICAgdmFyIGIgPSBlcW4uUkhTO1xyXG4gICAgICAgICAgICBpZihhLmlzQ29uc3RhbnQodHJ1ZSkgJiYgIWIuaXNDb25zdGFudCh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3dhcCB0aGVtIHRvIGF2b2lkIGNvbmZ1c2luZyBwYXJzZXIgYW5kIGNhdXNlIGFuIGluZmluaXRlIGxvb3BcclxuICAgICAgICAgICAgICAgIFthLCBiXSA9IFtiLCBhXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgX3QgPSBfLnN1YnRyYWN0KGEsIGIpO1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gZXhwYW5kID8gXy5leHBhbmQoX3QpIDogX3Q7XHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVEZW5vbTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IHRoaXMuTEhTLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5SSFMuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy9yZW1vdmUgdGhlIGRlbm9taW5hdG9yIG9uIGJvdGggc2lkZXNcclxuICAgICAgICAgICAgdmFyIGRlbiA9IF8ubXVsdGlwbHkoYS5nZXREZW5vbSgpLCBiLmdldERlbm9tKCkpO1xyXG4gICAgICAgICAgICBhID0gXy5leHBhbmQoXy5tdWx0aXBseShhLCBkZW4uY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICBiID0gXy5leHBhbmQoXy5tdWx0aXBseShiLCBkZW4pKTtcclxuICAgICAgICAgICAgLy9zd2FwIHRoZSBncm91cHNcclxuICAgICAgICAgICAgaWYoYi5ncm91cCA9PT0gQ1AgJiYgYi5ncm91cCAhPT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gYTtcclxuICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgYiA9IHQ7IC8vc3dhcFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL3NjYW4gdG8gZWxpbWluYXRlIGRlbm9taW5hdG9yc1xyXG4gICAgICAgICAgICBpZihhLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgU3ltYm9sKGEubXVsdGlwbGllciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JIUyA9IGIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIGEuZWFjaChmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHkucG93ZXIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JIUyA9IF8uZGl2aWRlKG5ld1JIUywgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5tdWx0aXBseSh0LCB5KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYSA9IHQ7XHJcbiAgICAgICAgICAgICAgICBiID0gbmV3UkhTO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGEuZ3JvdXAgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RoZSBsb2dpYzogbG9vcCB0aHJvdWdoIGVhY2ggYW5kIGlmIGl0IGhhcyBhIGRlbm9taW5hdG9yIHRoZW4gbXVsdGlwbHkgaXQgb3V0IG9uIGJvdGggZW5kc1xyXG4gICAgICAgICAgICAgICAgLy9hbmQgdGhlbiBzdGFydCBvdmVyXHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gYS5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IGEuc3ltYm9sc1t4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW0uZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeSBpbiBzeW0uc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN5bTIgPSBzeW0uc3ltYm9sc1t5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bTIucG93ZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVxdWF0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5leHBhbmQoXy5tdWx0aXBseShzeW0yLmNsb25lKCkudG9MaW5lYXIoKSwgYSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5leHBhbmQoXy5tdWx0aXBseShzeW0yLmNsb25lKCkudG9MaW5lYXIoKSwgYikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVxdWF0aW9uKGEsIGIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcXVhdGlvbih0aGlzLkxIUy5jbG9uZSgpLCB0aGlzLlJIUy5jbG9uZSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN1YjogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgdmFyIGNsb25lID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICBjbG9uZS5MSFMgPSBjbG9uZS5MSFMuc3ViKHguY2xvbmUoKSwgeS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgY2xvbmUuUkhTID0gY2xvbmUuUkhTLnN1Yih4LmNsb25lKCksIHkuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzWmVybzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29yZS5VdGlscy5ldmFsdWF0ZSh0aGlzLnRvTEhTKCkpLmVxdWFscygwKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhdGV4OiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5MSFMubGF0ZXgob3B0aW9uKSwgdGhpcy5SSFMubGF0ZXgob3B0aW9uKV0uam9pbignPScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvL292ZXJ3cml0ZSB0aGUgZXF1YWxzIGZ1bmN0aW9uXHJcbiAgICBfLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFcXVhdGlvbihhLCBiKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXh0ZW5kIHNpbXBsaWZ5XHJcbiAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaW1wbGlmeSA9IF8uZnVuY3Rpb25zLnNpbXBsaWZ5WzBdO1xyXG4gICAgICAgIF8uZnVuY3Rpb25zLnNpbXBsaWZ5WzBdID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZihzeW1ib2wgaW5zdGFuY2VvZiBFcXVhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLkxIUyA9IHNpbXBsaWZ5KHN5bWJvbC5MSFMpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLlJIUyA9IHNpbXBsaWZ5KHN5bWJvbC5SSFMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBKdXN0IGNhbGwgdGhlIG9yaWdpbmFsIHNpbXBsaWZ5XHJcbiAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeShzeW1ib2wpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0d28gZXhwcmVzc2lvbnMgZXF1YWxcclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAqIEByZXR1cm5zIHtFeHByZXNzaW9ufVxyXG4gICAgICovXHJcbiAgICBjb3JlLkV4cHJlc3Npb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICBpZihzeW1ib2wgaW5zdGFuY2VvZiBjb3JlLkV4cHJlc3Npb24pXHJcbiAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5zeW1ib2w7IC8vZ3JhYiB0aGUgc3ltYm9sIGlmIGl0J3MgYW4gZXhwcmVzc2lvblxyXG4gICAgICAgIHZhciBlcSA9IG5ldyBFcXVhdGlvbih0aGlzLnN5bWJvbCwgc3ltYm9sKTtcclxuICAgICAgICByZXR1cm4gZXE7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvcmUuRXhwcmVzc2lvbi5wcm90b3R5cGUuc29sdmVGb3IgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciBzeW1ib2w7XHJcbiAgICAgICAgaWYodGhpcy5zeW1ib2wgaW5zdGFuY2VvZiBFcXVhdGlvbikge1xyXG4gICAgICAgICAgICAvL2V4aXQgcmlnaHQgYXdheSBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIGFuc3dlclxyXG4gICAgICAgICAgICAvL2NoZWNrIHRoZSBMSFNcclxuICAgICAgICAgICAgaWYodGhpcy5zeW1ib2wuTEhTLmlzQ29uc3RhbnQoKSAmJiB0aGlzLnN5bWJvbC5SSFMuZXF1YWxzKHgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlLkV4cHJlc3Npb24odGhpcy5zeW1ib2wuTEhTKTtcclxuXHJcbiAgICAgICAgICAgIC8vY2hlY2sgdGhlIFJIU1xyXG4gICAgICAgICAgICBpZih0aGlzLnN5bWJvbC5SSFMuaXNDb25zdGFudCgpICYmIHRoaXMuc3ltYm9sLkxIUy5lcXVhbHMoeCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvcmUuRXhwcmVzc2lvbih0aGlzLnN5bWJvbC5SSFMpO1xyXG5cclxuICAgICAgICAgICAgLy9vdGhlcndpc2UganVzdCBicmluZyBpdCB0byBMSFNcclxuICAgICAgICAgICAgc3ltYm9sID0gdGhpcy5zeW1ib2wudG9MSFMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN5bWJvbCA9IHRoaXMuc3ltYm9sO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNvbHZlKHN5bWJvbCwgeCkubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZS5FeHByZXNzaW9uKHgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb3JlLkV4cHJlc3Npb24ucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZih0aGlzLnN5bWJvbCBpbnN0YW5jZW9mIEVxdWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHRoaXMuc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGNsb25lLlJIUyA9IF8uZXhwYW5kKGNsb25lLlJIUyk7XHJcbiAgICAgICAgICAgIGNsb25lLkxIUyA9IF8uZXhwYW5kKGNsb25lLkxIUyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZS5FeHByZXNzaW9uKGNsb25lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlLkV4cHJlc3Npb24oXy5leHBhbmQodGhpcy5zeW1ib2wpKTtcclxuICAgIH07XHJcblxyXG4gICAgY29yZS5FeHByZXNzaW9uLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYodGhpcy5zeW1ib2wgaW5zdGFuY2VvZiBFcXVhdGlvbilcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuYXJyYXlVbmlxdWUodmFyaWFibGVzKHRoaXMuc3ltYm9sLkxIUykuY29uY2F0KHZhcmlhYmxlcyh0aGlzLnN5bWJvbC5SSFMpKSk7XHJcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlcyh0aGlzLnN5bWJvbCk7XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG4gICAgdmFyIHNldEVxID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gXy5lcXVhbHMoYSwgYik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vbGluayB0aGUgRXF1YXRpb24gY2xhc3MgYmFjayB0byB0aGUgY29yZVxyXG4gICAgY29yZS5FcXVhdGlvbiA9IEVxdWF0aW9uO1xyXG5cclxuICAgIC8vTG9vcHMgdGhyb3VnaCBhbiBhcnJheSBhbmQgYXR0ZW1wdHMgdG8gZmFpbHMgYSB0ZXN0LiBTdG9wcyBpZiBtYW5hZ2VzIHRvIGZhaWwuXHJcbiAgICB2YXIgY2hlY2tBbGwgPSBjb3JlLlV0aWxzLmNoZWNrQWxsID0gZnVuY3Rpb24gKGFyZ3MsIHRlc3QpIHtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgaWYodGVzdChhcmdzW2ldKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLy92ZXJzaW9uIHNvbHZlXHJcbiAgICB2YXIgX18gPSBjb3JlLlNvbHZlID0ge1xyXG4gICAgICAgIHZlcnNpb246ICcyLjAuMycsXHJcbiAgICAgICAgc29sdXRpb25zOiBbXSxcclxuICAgICAgICBzb2x2ZTogZnVuY3Rpb24gKGVxLCB2YXJpYWJsZSkge1xyXG4gICAgICAgICAgICB2YXIgc29sdXRpb24gPSBzb2x2ZShlcSwgU3RyaW5nKHZhcmlhYmxlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZS5WZWN0b3Ioc29sdXRpb24pO1xyXG4gICAgICAgICAgICAvL3JldHVybiBuZXcgY29yZS5WZWN0b3Ioc29sdmUoZXEudG9TdHJpbmcoKSwgdmFyaWFibGUgPyB2YXJpYWJsZS50b1N0cmluZygpIDogdmFyaWFibGUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJyaW5ncyB0aGUgZXF1YXRpb24gdG8gTEhTLiBBIHN0cmluZyBjYW4gYmUgc3VwcGxpZWQgd2hpY2ggd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gRXF1YXRpb25cclxuICAgICAgICAgKiBAcGFyYW0ge0VxdWF0aW9ufFN0cmluZ30gZXFuXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0b0xIUzogZnVuY3Rpb24gKGVxbiwgZXhwYW5kKSB7XHJcbiAgICAgICAgICAgIGlmKGlzU3ltYm9sKGVxbikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXFuO1xyXG4gICAgICAgICAgICAvL0lmIGl0J3MgYW4gZXF1YXRpb24gdGhlbiBjYWxsIGl0cyB0b0xIUyBmdW5jdGlvbiBpbnN0ZWFkXHJcbiAgICAgICAgICAgIGlmKCEoZXFuIGluc3RhbmNlb2YgRXF1YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXMgPSBlcW4uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgICAgIC8vY29udmVydCBmYWxzZXkgdmFsdWVzIHRvIHplcm9cclxuICAgICAgICAgICAgICAgIGVzWzFdID0gZXNbMV0gfHwgJzAnO1xyXG4gICAgICAgICAgICAgICAgZXFuID0gbmV3IEVxdWF0aW9uKF8ucGFyc2UoZXNbMF0pLCBfLnBhcnNlKGVzWzFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVxbi50b0xIUyhleHBhbmQpO1xyXG4gICAgICAgIH0sXHJcbi8vICAgICAgICBnZXRTeXN0ZW1WYXJpYWJsZXM6IGZ1bmN0aW9uKGVxbnMpIHtcclxuLy8gICAgICAgICAgICB2YXJzID0gdmFyaWFibGVzKGVxbnNbMF0sIG51bGwsIG51bGwsIHRydWUpO1xyXG4vL1xyXG4vLyAgICAgICAgICAgIC8vZ2V0IGFsbCB2YXJpYWJsZXNcclxuLy8gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbD1lcW5zLmxlbmd0aDsgaSA8IGw7IGkrKylcclxuLy8gICAgICAgICAgICAgICAgdmFycyA9IHZhcnMuY29uY2F0KHZhcmlhYmxlcyhlcW5zW2ldKSk7XHJcbi8vICAgICAgICAgICAgLy9yZW1vdmUgZHVwbGljYXRlc1xyXG4vLyAgICAgICAgICAgIHZhcnMgPSBjb3JlLlV0aWxzLmFycmF5VW5pcXVlKHZhcnMpLnNvcnQoKTtcclxuLy8gICAgICAgICAgICBcclxuLy8gICAgICAgICAgICAvL2RvbmVcclxuLy8gICAgICAgICAgICByZXR1cm4gdmFycztcclxuLy8gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU29sdmUgYSBzZXQgb2YgY2lyY2xlIGVxdWF0aW9ucy4gXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2xbXX0gZXFuc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzb2x2ZUNpcmNsZTogZnVuY3Rpb24gKGVxbnMsIHZhcnMpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFyaWFibGVzIHRvIHN5bWJvbHNcclxuICAgICAgICAgICAgdmFyIHN2YXJzID0gdmFycy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKHgpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRlZyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBkZWdyZWUgZm9yIHRoZSBlcXVhdGlvbnNcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVxbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgc3ZhcnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBkLnB1c2goTnVtYmVyKGNvcmUuQWxnZWJyYS5kZWdyZWUoZXFuc1tpXSwgc3ZhcnNbal0pKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgdG90YWwgZGVncmVlXHJcbiAgICAgICAgICAgICAgICBkLnB1c2goY29yZS5VdGlscy5hcnJheVN1bShkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICBkZWcucHVzaChkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGEgPSBlcW5zWzBdO1xyXG4gICAgICAgICAgICB2YXIgYiA9IGVxbnNbMV07XHJcblxyXG4gICAgICAgICAgICBpZihkZWdbMF1bMl0gPiBkZWdbMV1bMl0pIHtcclxuICAgICAgICAgICAgICAgIFtiLCBhXSA9IFthLCBiXTtcclxuICAgICAgICAgICAgICAgIFtkZWdbMV0sIGRlZ1swXV0gPSBbZGVnWzBdLCBkZWdbMV1dO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPbmx5IHNvbHZlIGl0J3MgdHJ1bHkgYSBjaXJjbGVcclxuICAgICAgICAgICAgaWYoZGVnWzBdWzBdID09PSAxICYmIGRlZ1swXVsyXSA9PT0gMiAmJiBkZWdbMV1bMF0gPT09IDIgJiYgZGVnWzFdWzJdID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgY2xhcml0eSB3ZSdsbCByZWZlciB0byB0aGUgdmFyaWFibGVzIGFzIHggYW5kIHlcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gdmFyc1swXTtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gdmFyc1sxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gbm93IGdldCB0aGUgdHdvIHBvaW50cyBmb3IgeVxyXG4gICAgICAgICAgICAgICAgdmFyIHlfcG9pbnRzID0gc29sdmUoXy5wYXJzZShiLCBrbm93blZhcmlhYmxlKHgsIHNvbHZlKF8ucGFyc2UoYSksIHgpWzBdKSksIHkpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBub3cga25vdyB5IHdlIGNhbiBnZXQgdGhlIHR3byB4IHBvaW50cyBmcm9tIHRoZSBmaXJzdCBlcXVhdGlvblxyXG4gICAgICAgICAgICAgICAgdmFyIHhfcG9pbnRzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHZlKF8ucGFyc2UoYSwga25vd25WYXJpYWJsZSh5LCB5X3BvaW50c1swXSkpKVswXS50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHlfcG9pbnRzWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeF9wb2ludHMucHVzaChzb2x2ZShfLnBhcnNlKGEsIGtub3duVmFyaWFibGUoeSwgeV9wb2ludHNbMV0pKSlbMF0udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuU09MVVRJT05TX0FTX09CSkVDVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnNbeF0gPSB4X3BvaW50cztcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnNbeV0gPSB5X3BvaW50cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHlfcG9pbnRzLnVuc2hpZnQoeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeF9wb2ludHMudW5zaGlmdCh4KTtcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBbeF9wb2ludHMsIHlfcG9pbnRzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNvbHZlIGEgc3lzdGVtIG9mIG5vbmxpbmVhciBlcXVhdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbFtdfSBlcW5zIFRoZSBhcnJheSBvZiBlcXVhdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdHJpZXMgVGhlIG1heGltdW0gbnVtYmVyIG9mIHRyaWVzXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydGluZyBwb2ludCB3aGVyZSB0byBzdGFydCBsb29raW5nIGZvciBzb2x1dGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc29sdmVOb25MaW5lYXJTeXN0ZW06IGZ1bmN0aW9uIChlcW5zLCB0cmllcywgc3RhcnQpIHtcclxuICAgICAgICAgICAgaWYodHJpZXMgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107Ly9jYW4ndCBmaW5kIGEgc29sdXRpb25cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RhcnQgPSB0eXBlb2Ygc3RhcnQgPT09ICd1bmRlZmluZWQnID8gY29yZS5TZXR0aW5ncy5OT05fTElORUFSX1NUQVJUIDogc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICAvL3RoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0byBqdW1wXHJcbiAgICAgICAgICAgIHZhciBtYXhfdHJpZXMgPSBjb3JlLlNldHRpbmdzLk1BWF9OT05fTElORUFSX1RSSUVTO1xyXG5cclxuICAgICAgICAgICAgLy9oYWxmd2F5IHRocm91Z2ggdGhlIHRyaWVzXHJcbiAgICAgICAgICAgIHZhciBoYWxmd2F5ID0gTWF0aC5mbG9vcihtYXhfdHJpZXMgLyAyKTtcclxuXHJcbiAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSB0aGUgbnVtYmVyIG9mIHRyaWVzIHRvIDEwIGlmIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICAgICAgdHJpZXMgPSB0eXBlb2YgdHJpZXMgPT09ICd1bmRlZmluZWQnID8gbWF4X3RyaWVzIDogdHJpZXM7XHJcblxyXG4gICAgICAgICAgICAvL2EgcG9pbnQgYXQgd2hpY2ggd2UgY2hlY2sgdG8gc2VlIGlmIHdlJ3JlIGNvbnZlcmdpbmcuIEJ5IGluc3BlY3Rpb24gaXQgc2VlbXMgdGhhdCB3ZSBjYW5cclxuICAgICAgICAgICAgLy91c2UgYXJvdW5kIDIwIGl0ZXJhdGlvbnMgdG8gc2VlIGlmIHdlJ3JlIGNvbnZlcmdpbmcuIElmIG5vdCB0aGVuIHdlIHJldHJ5IGEganVtcCBvZiB4XHJcbiAgICAgICAgICAgIHZhciBqdW1wX2F0ID0gY29yZS5TZXR0aW5ncy5OT05fTElORUFSX0pVTVBfQVQ7XHJcblxyXG4gICAgICAgICAgICAvL3dlIGp1bXAgYnkgdGhpcyBtYW55IHBvaW50cyBhdCBlYWNoIHBpdm90IHBvaW50XHJcbiAgICAgICAgICAgIHZhciBqdW1wID0gY29yZS5TZXR0aW5ncy5OT05fTElORUFSX0pVTVBfU0laRTtcclxuXHJcbiAgICAgICAgICAgIC8vdXNlZCB0byBjaGVjayBpZiB3ZSBhY3R1YWxseSBmb3VuZCBhIHNvbHV0aW9uIG9yIGlmIHdlIGdhdmUgdXAuIEFzc3VtZSB3ZSB3aWxsIGZpbmQgYSBzb2x1dGlvbi5cclxuICAgICAgICAgICAgdmFyIGZvdW5kID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBjcmVhdGVfc3VicyA9IGZ1bmN0aW9uICh2YXJzLCBtYXRyaXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJzLm1hcChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIobWF0cml4LmdldChpLCAwKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YXJzID0gY29yZS5VdGlscy5hcnJheUdldFZhcmlhYmxlcyhlcW5zKTtcclxuICAgICAgICAgICAgdmFyIGphY29iaWFuID0gY29yZS5NYXRyaXguamFjb2JpYW4oZXFucywgdmFycywgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZCh4LCB2YXJzKTtcclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF4X2l0ZXIgPSBjb3JlLlNldHRpbmdzLk1BWF9ORVdUT05fSVRFUkFUSU9OUztcclxuICAgICAgICAgICAgdmFyIG8sIHksIGl0ZXJzLCB4bjEsIG5vcm0sIGxub3JtLCB4biwgZDtcclxuXHJcbiAgICAgICAgICAgIHZhciBmX2VxbnMgPSBlcW5zLm1hcChmdW5jdGlvbiAoZXEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZChlcSwgdmFycyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIEogPSBqYWNvYmlhbi5tYXAoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZChlLCB2YXJzKTtcclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vaW5pdGlhbCB2YWx1ZXNcclxuICAgICAgICAgICAgeG4xID0gY29yZS5NYXRyaXguY01hdHJpeCgwLCB2YXJzKTtcclxuXHJcbiAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSB0aGUgYyBtYXRyaXggd2l0aCBzb21ldGhpbmcgY2xvc2UgdG8gMC4gXHJcbiAgICAgICAgICAgIHZhciBjID0gY29yZS5NYXRyaXguY01hdHJpeChzdGFydCwgdmFycyk7XHJcblxyXG4gICAgICAgICAgICBpdGVycyA9IDA7XHJcblxyXG4gICAgICAgICAgICAvL3N0YXJ0IG9mIGFsZ29yaXRobVxyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAvL2lmIHdlJ3ZlIHJlYWNoZWQgdGhlIG1heCBpdGVyYXRpb25zIHRoZW4gZXhpdFxyXG4gICAgICAgICAgICAgICAgaWYoaXRlcnMgPiBtYXhfaXRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zZXQgdGhlIHN1YnN0aXR1dGlvbiBvYmplY3RcclxuICAgICAgICAgICAgICAgIG8gPSBjcmVhdGVfc3Vicyh2YXJzLCBjKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NldCB4blxyXG4gICAgICAgICAgICAgICAgeG4gPSBjLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9tYWtlIGFsbCB0aGUgc3Vic3RpdHV0aW9ucyBmb3IgZWFjaCBvZiB0aGUgZXF1YXRpb25zXHJcbiAgICAgICAgICAgICAgICBmX2VxbnMuZm9yRWFjaChmdW5jdGlvbiAoZiwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMuc2V0KGksIDAsIGYuYXBwbHkobnVsbCwgbykpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG0gPSBuZXcgY29yZS5NYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgIEouZWFjaChmdW5jdGlvbiAoZm4sIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5zID0gZm4uYXBwbHkobnVsbCwgbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbS5zZXQoaSwgaiwgYW5zKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIG0gPSBtLmludmVydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vcHJlZm9ybSB0aGUgZWxpbWluYXRpb25cclxuICAgICAgICAgICAgICAgIHkgPSBfLm11bHRpcGx5KG0sIGMpLm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdGhlIGNhbGxiYWNrIGlzIHRvIGF2b2lkIG92ZXJmbG93IGluIHRoZSBjb2VmZmllbnQgZGVub25pbWF0b3JcclxuICAgICAgICAgICAgICAgIC8vaXQgY29udmVydHMgaXQgdG8gYSBkZWNpbWFsIGFuZCB0aGVuIGJhY2sgdG8gYSBmcmFjdGlvbi4gU29tZSBwcmVjaXNpb25cclxuICAgICAgICAgICAgICAgIC8vaXMgbG9zdCBiZSBpdCdzIGJldHRlciB0aGFuIG92ZXJmbG93LiBcclxuICAgICAgICAgICAgICAgIGQgPSB5LnN1YnRyYWN0KHhuMSwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShOdW1iZXIoeCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgeG4xID0geG4uYWRkKHksIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoTnVtYmVyKHgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vbW92ZSBjIGlzIG5vdyB4bjFcclxuICAgICAgICAgICAgICAgIGMgPSB4bjE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIG5vcm1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3RoZSBleHBlY3RhdGlvbiBpcyB0aGF0IHdlJ3JlIGNvbnZlcmdpbmcgdG8gc29tZSBhbnN3ZXIgYXMgdGhpcyBwb2ludCByZWdhcmRsZXNzIG9mIHdoZXJlIHdlIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAvL3RoaXMgbWF5IGhhdmUgdG8gYmUgYWRqdXN0ZWQgYXQgc29tZSBwb2ludCBiZWNhdXNlIG9mIGVycm9uZW91cyBhc3N1bXB0aW9uc1xyXG4gICAgICAgICAgICAgICAgaWYoaXRlcnMgPj0ganVtcF9hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgdGhlIG5vcm0uIElmIHRoZSBub3JtIGlzIGdyZWF0ZXIgdGhhbiBvbmUgdGhlbiBpdCdzIHRpbWUgdG8gdHJ5IGFub3RoZXIgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICBpZihub3JtID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IHRoZSBzdGFydCBwb2ludCBhdCBoYWx3YXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHJpZXMgPT09IGhhbGZ3YXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gdHJpZXMgPiBoYWxmd2F5ID8gMSA6IC0xOyAvL3doaWNoIHNpZGUgYXJlIHdlIGluY3JlbWVudGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGluY3JlbWVudCArbiBhdCBvbmUgc2lkZSBhbmQgLW4gYXQgdGhlIG90aGVyLiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9ICh0cmllcyAlIE1hdGguZmxvb3IoaGFsZndheSkpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGp1c3QgdGhlIHN0YXJ0IHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IChzaWduICogbiAqIGp1bXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGwgcmVzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18uc29sdmVOb25MaW5lYXJTeXN0ZW0oZXFucywgLS10cmllcywgc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxub3JtID0gbm9ybTtcclxuICAgICAgICAgICAgICAgIGl0ZXJzKys7XHJcbiAgICAgICAgICAgICAgICBub3JtID0gZC5tYXgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2V4aXQgZWFybHkuIFJldmlzaXQgaWYgd2UgZ2V0IGJ1Z3NcclxuICAgICAgICAgICAgICAgIGlmKE51bWJlcihub3JtKSA9PT0gTnVtYmVyKGxub3JtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKE51bWJlcihub3JtKSA+PSBOdW1iZXIuRVBTSUxPTilcclxuXHJcbiAgICAgICAgICAgIC8vcmV0dXJuIGEgYmxhbmsgc2V0IGlmIG5vdGhpbmcgd2FzIGZvdW5kO1xyXG4gICAgICAgICAgICBpZighZm91bmQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcblxyXG4gICAgICAgICAgICAvL3JldHVybiBjIHNpbmNlIHRoYXQncyB0aGUgYW5zd2VyXHJcbiAgICAgICAgICAgIHJldHVybiBfXy5zeXN0ZW1Tb2x1dGlvbnMoYywgdmFycywgdHJ1ZSwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb3JlLlV0aWxzLnJvdW5kKE51bWJlcih4KSwgMTQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN5c3RlbVNvbHV0aW9uczogZnVuY3Rpb24gKHJlc3VsdCwgdmFycywgZXhwYW5kX3Jlc3VsdCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIHNvbHV0aW9ucyA9IGNvcmUuU2V0dGluZ3MuU09MVVRJT05TX0FTX09CSkVDVCA/IHt9IDogW107XHJcblxyXG4gICAgICAgICAgICByZXN1bHQuZWFjaChmdW5jdGlvbiAoZSwgaWR4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc29sdXRpb24gPSAoZXhwYW5kX3Jlc3VsdCA/IF8uZXhwYW5kKGUpIDogZSkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYWxsYmFjay5jYWxsKGUsIHNvbHV0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IHZhcnNbaWR4XTtcclxuICAgICAgICAgICAgICAgIGlmKGNvcmUuU2V0dGluZ3MuU09MVVRJT05TX0FTX09CSkVDVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uc1t2YXJpYWJsZV0gPSBzb2x1dGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChbdmFyaWFibGUsIHNvbHV0aW9uXSk7IC8qTk8qL1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy9kb25lXHJcbiAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTb2x2ZXMgYSBzeXN0ZW0gb2YgZXF1YXRpb25zIGJ5IHN1YnN0aXR1dGlvbi4gVGhpcyBpcyB1c2VmdWwgd2hlblxyXG4gICAgICAgICAqIG5vIGRpc3RpbmN0IHNvbHV0aW9uIGV4aXN0cy4gZS5nLiBhIGxpbmUsIHBsYW5lLCBldGMuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gZXFuc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzb2x2ZVN5c3RlbUJ5U3Vic3RpdHV0aW9uOiBmdW5jdGlvbiAoZXFucykge1xyXG4gICAgICAgICAgICAvLyBBc3N1bWUgYXQgbGVhc3QgMiBlcXVhdGlvbnMuIFRoZSBmdW5jdGlvbiB2YXJpYWJsZXMgd2lsbCBqdXN0IHJldHVybiBhbiBlbXB0eSBhcnJheSBpZiB1bmRlZmluZWQgaXMgcHJvdmlkZWRcclxuICAgICAgICAgICAgdmFyIHZhcnNfYSA9IHZhcmlhYmxlcyhlcW5zWzBdKTtcclxuICAgICAgICAgICAgdmFyIHZhcnNfYiA9IHZhcmlhYmxlcyhlcW5zWzFdKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIGNpcmNsZSBlcXVhdGlvblxyXG4gICAgICAgICAgICBpZihlcW5zLmxlbmd0aCA9PT0gMiAmJiB2YXJzX2EubGVuZ3RoID09PSAyICYmIGNvcmUuVXRpbHMuYXJyYXlFcXVhbCh2YXJzX2EsIHZhcnNfYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5zb2x2ZUNpcmNsZShlcW5zLCB2YXJzX2EpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW107IC8vIHJldHVybiBhbiBlbXB0eSBzZXRcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvL2h0dHBzOi8vd3d3Lmxha2VoZWFkdS5jYS9zaXRlcy9kZWZhdWx0L2ZpbGVzL3VwbG9hZHMvNzcvZG9jcy9SZW1hbmlGaW5hbC5wZGZcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTb2x2ZXMgYSBzeXN0ZW1zIG9mIGVxdWF0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVxbnMgQW4gYXJyYXkgb2YgZXF1YXRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdmFyX2FycmF5IEFuIGFycmF5IG9mIHZhcmlhYmxlc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheXxvYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc29sdmVTeXN0ZW06IGZ1bmN0aW9uIChlcW5zLCB2YXJfYXJyYXkpIHtcclxuICAgICAgICAgICAgLy9jaGVjayBpZiBhIHZhcl9hcnJheSB3YXMgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIC8vbmVyZGFtZXIuY2xlYXJWYXJzKCk7Ly8gdGhpcyBkZWxldGVkIEFMTCB2YXJpYWJsZXM6IG5vdCB3aGF0IHdlIHdhbnRcclxuICAgICAgICAgICAgLy9wYXJzZSBhbGwgdGhlIGVxdWF0aW9ucyB0byBMSFMuIFJlbWVtYmVyIHRoYXQgdGhleSBjb21lIGluIGFzIHN0cmluZ3NcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVxbnMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBlcW5zW2ldID0gX18udG9MSFMoZXFuc1tpXSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbCA9IGVxbnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBuZXcgY29yZS5NYXRyaXgoKSxcclxuICAgICAgICAgICAgICAgICAgICBjID0gbmV3IGNvcmUuTWF0cml4KCksXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kX3Jlc3VsdCA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhcnM7XHJcblxyXG4gICAgICAgICAgICBpZih0eXBlb2YgdmFyX2FycmF5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgLy9jaGVjayB0byBtYWtlIHN1cmUgdGhhdCBhbGwgdGhlIGVxdWF0aW9ucyBhcmUgbGluZWFyXHJcbiAgICAgICAgICAgICAgICBpZighX0EuYWxsTGluZWFyKGVxbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLnNvbHZlTm9uTGluZWFyU3lzdGVtKGVxbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGUgaW5zdGFuY2VvZiBjb3JlLmV4Y2VwdGlvbnMuRGl2aXNpb25CeVplcm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfXy5zb2x2ZVN5c3RlbUJ5U3Vic3RpdHV0aW9uKGVxbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhcnMgPSBjb3JlLlV0aWxzLmFycmF5R2V0VmFyaWFibGVzKGVxbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlYWwgd2l0aCByZWR1bmRhbnQgZXF1YXRpb25zIGFzIGV4cHJlc3NlZCBpbiAjNTYyXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZml4IGlzIHRvIHJlbW92ZSBhbGwgYnV0IHRoZSBudW1iZXIgb2YgZXF1YXRpb25zIGVxdWFsIHRvIHRoZSBudW1iZXJcclxuICAgICAgICAgICAgICAgIC8vIG9mIHZhcmlhYmxlcy4gV2UgdGhlbiBzb2x2ZSB0aG9zZSBhbmQgdGhlbiBldmFsdWF0ZSB0aGUgcmVtYWluaW5nIGVxdWF0aW9uc1xyXG4gICAgICAgICAgICAgICAgLy8gd2l0aCB0aG9zZSBzb2x1dGlvbnMuIElmIHRoZSBhbGwgZXF1YWwgdHJ1ZSB0aGVuIHRob3NlIGFyZSBqdXN0IHJlZHVuZGFudFxyXG4gICAgICAgICAgICAgICAgLy8gZXF1YXRpb25zIGFuZCB3ZSBjYW4gcmV0dXJuIHRoZSBzb2x1dGlvbiBzZXQuXHJcbiAgICAgICAgICAgICAgICBpZih2YXJzLmxlbmd0aCA8IGVxbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZHVjZWQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGVxbnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZHVjZWQucHVzaChfLnBhcnNlKGVxbnNbaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrbm93bnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb25zID0gX18uc29sdmVTeXN0ZW0ocmVkdWNlZCwgdmFycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNvbHV0aW9ucyBtYXkgaGF2ZSBjb21lIGJhY2sgYXMgYW4gYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KHNvbHV0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29sdXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHNvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga25vd25zW3NvbFswXV0gPSBzb2xbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga25vd25zID0gc29sdXRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgYnkgYXNzdW1pbmcgdGhleSB3aWxsIGFsbCBldmFsdWF0ZSB0byB6ZXJvLiBJZiBldmVuIG9uZSBmYWlsc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gYWxsIHplcm8gd2lsbCBiZSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxfemVybyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGxhc3Qgc29sdXRpb24gZXZhbHV0ZXMgdG8gemVybyBnaXZlbiB0aGVzZSBzb2x1dGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSBuIC0gMTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighXy5wYXJzZShlcW5zW2ldLCBrbm93bnMpLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsX3plcm8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYWxsX3plcm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlcyBvbmx5IHRoZSB2YXJpYWJsZXMgb2YgdGhlIGxpbmVhciBlcXVhdGlvbnMgaW4gdGhlIG5lcmRhbWVyIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXJkYW1lci5zZXRWYXIodmFyc1tpXSwgXCJkZWxldGVcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gY01hdHJpeCBvciBzb21ldGhpbmcgc2ltaWxhclxyXG4gICAgICAgICAgICAgICAgLy8gcG9wdWxhdGUgdGhlIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gZXFuc1tpXTsgLy9zdG9yZSB0aGUgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgY29sdW1uc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB2YXJzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdmFyc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHguY29udGFpbnModikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2VmZnMgPSBjb2VmZnMuY29uY2F0KHguY29lZmZzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZiA9IGNvcmUuVXRpbHMuYXJyYXlTdW0oY29lZmZzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zZXQoaSwgaiwgY2YpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdHJpcCB0aGUgdmFyaWFibGVzIGZyb20gdGhlIHN5bWJvbCBzbyB3ZSdyZSBsZWZ0IHdpdGggb25seSB0aGUgemVyb3RoIGNvZWZmaWNpZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zdGFydCB3aXRoIHRoZSBzeW1ib2wgYW5kIHJlbW92ZSBlYWNoIHZhcmlhYmxlIGFuZCBpdHMgY29lZmZpY2llbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcnMubWFwKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bSA9IG51bS5zdHJpcFZhcihlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjLnNldChpLCAwLCBudW0ubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgaWRlYSBpcyB0aGF0IHdlIGxvb3AgdGhyb3VnaCBlYWNoIGVxdWF0aW9uIGFuZCB0aGVuIGV4cGFuZCBpdC4gQWZ0ZXJ3YXJkcyB3ZSBsb29wXHJcbiAgICAgICAgICAgICAgICAgKiB0aHJvdWdoIGVhY2ggdGVybSBhbmQgc2VlIGlmIGFuZCBjaGVjayB0byBzZWUgaWYgaXQgbWF0Y2hlcyBvbmUgb2YgdGhlIHZhcmlhYmxlcy5cclxuICAgICAgICAgICAgICAgICAqIFdoZW4gYSBtYXRjaCBpcyBmb3VuZCB3ZSBtYXJrIGl0LiBObyBvdGhlciBtYXRjaCBzaG91bGQgYmUgZm91bmQgZm9yIHRoYXQgdGVybS4gSWYgaXRcclxuICAgICAgICAgICAgICAgICAqIGlzIHdlIHN0b3Agc2luY2UgaXQncyBub3QgbGluZWFyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXJzID0gdmFyX2FycmF5O1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kX3Jlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3ByZWZpbGxcclxuICAgICAgICAgICAgICAgICAgICBjLnNldChpLCAwLCBuZXcgU3ltYm9sKDApKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IF8uZXhwYW5kKGVxbnNbaV0pLmNvbGxlY3RTeW1ib2xzKCk7IC8vZXhwYW5kIGFuZCBzdG9yZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ28gdHJvdWdoIGVhY2ggb2YgdGhlIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB2YXJfYXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbS5zZXQoaSwgaiwgbmV3IFN5bWJvbCgwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdmFyX2FycmF5W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dvIHRocm91Z2ggdGhlIHRlcm1zIGFuZCBzb3J0IHRoZSB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGUubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtID0gZVtrXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeiA9IDA7IHogPCB2YXJfYXJyYXkubGVuZ3RoOyB6KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIHRvIHNlZSBpZiB0ZXJtcyBjb250YWluIG11bHRpcGxlIHZhcmlhYmxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRlcm0uY29udGFpbnModmFyX2FycmF5W3pdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjaGVjaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuZXJyKCdNdWx0aXBsZSB2YXJpYWJsZXMgZm91bmQgZm9yIHRlcm0gJyArIHRlcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVjayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBtYWRlIHN1cmUgdGhhdCBldmVyeSB0ZXJtIGNvbnRhaW5zIG9uZSB2YXJpYWJsZSBzbyBpdCdzIHNhZmUgdG8gYXNzdW1lIHRoYXQgaWYgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhcmlhYmxlIGlzIGZvdW5kIHRoZW4gdGhlIHJlbWFpbmRlciBpcyB0aGUgY29lZmZpY2llbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0ZXJtLmNvbnRhaW5zKHYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRwYXJ0cyA9IGV4cGxvZGUocmVtb3ZlKGUsIGspLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnNldChpLCBqLCBfLmFkZChtLmdldChpLCBqKSwgdHBhcnRzWzBdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hbGwgdGhlIHJlbWFpbmluZyB0ZXJtcyBnbyB0byB0aGUgYyBtYXRyaXhcclxuICAgICAgICAgICAgICAgICAgICBmb3IoayA9IDA7IGsgPCBlLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuc2V0KGksIDAsIF8uYWRkKGMuZ2V0KGksIDApLCBlW2tdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9jb25zaWRlciBjYXNlIChhK2IpKkkrdVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSBzeXN0ZW0gaGFzIGEgZGlzdGluY3Qgc29sdXRpb25cclxuICAgICAgICAgICAgaWYodmFycy5sZW5ndGggIT09IGVxbnMubGVuZ3RoIHx8IG0uZGV0ZXJtaW5hbnQoKS5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNvbHZlIHRoZSBzeXN0ZW0gYnkgaGFuZFxyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gX18uc29sdmVTeXN0ZW1CeVN1YnN0aXR1dGlvbihlcW5zLCB2YXJzLCBtLCBjKTtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLmV4Y2VwdGlvbnMuU29sdmVFcnJvcignU3lzdGVtIGRvZXMgbm90IGhhdmUgYSBkaXN0aW5jdCBzb2x1dGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgTV4tMSpjIHRvIHNvbHZlIHN5c3RlbVxyXG4gICAgICAgICAgICBtID0gbS5pbnZlcnQoKTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG0ubXVsdGlwbHkoYyk7XHJcbiAgICAgICAgICAgIC8vY29ycmVjdCB0aGUgc2lnbiBhcyBwZXIgaXNzdWUgIzQxMFxyXG4gICAgICAgICAgICBpZihjb3JlLlV0aWxzLmlzQXJyYXkodmFyX2FycmF5KSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfXy5zeXN0ZW1Tb2x1dGlvbnMocmVzdWx0LCB2YXJzLCBleHBhbmRfcmVzdWx0KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBxdWFkcmF0aWMgZnVuY3Rpb24gYnV0IG9ubHkgb25lIHNpZGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBhXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBxdWFkOiBmdW5jdGlvbiAoYywgYiwgYSkge1xyXG4gICAgICAgICAgICB2YXIgZGlzY3JpbWluYW50ID0gXy5zdWJ0cmFjdChfLnBvdyhiLmNsb25lKCksIFN5bWJvbCgyKSksIF8ubXVsdGlwbHkoXy5tdWx0aXBseShhLmNsb25lKCksIGMuY2xvbmUoKSksIFN5bWJvbCg0KSkpLypiXjIgLSA0YWMqLztcclxuICAgICAgICAgICAgdmFyIGRldCA9IF8ucG93KGRpc2NyaW1pbmFudCwgU3ltYm9sKDAuNSkpO1xyXG4gICAgICAgICAgICB2YXIgZGVuID0gXy5wYXJzZShfLm11bHRpcGx5KG5ldyBTeW1ib2woMiksIGEuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gW1xyXG4gICAgICAgICAgICAgICAgXy5wYXJzZShmb3JtYXQoJygtKHswfSkrKHsxfSkpLyh7Mn0pJywgYiwgZGV0LCBkZW4pKSxcclxuICAgICAgICAgICAgICAgIF8ucGFyc2UoZm9ybWF0KCcoLSh7MH0pLSh7MX0pKS8oezJ9KScsIGIsIGRldCwgZGVuKSlcclxuICAgICAgICAgICAgXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3ViaWMgZXF1YXRpb25cclxuICAgICAgICAgKiBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNjE3MjUvaXMtdGhlcmUtYS1zeXN0ZW1hdGljLXdheS1vZi1zb2x2aW5nLWN1YmljLWVxdWF0aW9uc1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBkX29cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gY19vXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJfb1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBhX29cclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY3ViaWM6IGZ1bmN0aW9uIChkX28sIGNfbywgYl9vLCBhX28pIHtcclxuICAgICAgICAgICAgLy9jb252ZXJ0IGV2ZXJ5dGhpbmcgdG8gdGV4dFxyXG4gICAgICAgICAgICB2YXIgYSA9IGFfby50ZXh0KCksIGIgPSBiX28udGV4dCgpLCBjID0gY19vLnRleHQoKSwgZCA9IGRfby50ZXh0KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdCA9IGAoLSgke2J9KV4zLygyNyooJHthfSleMykrKCR7Yn0pKigke2N9KS8oNiooJHthfSleMiktKCR7ZH0pLygyKigke2F9KSkpYDtcclxuICAgICAgICAgICAgdmFyIHUgPSBgKCgke2N9KS8oMyooJHthfSkpLSgke2J9KV4yLyg5Kigke2F9KV4yKSlgO1xyXG4gICAgICAgICAgICB2YXIgdiA9IGAoJHtifSkvKDMqKCR7YX0pKWA7XHJcbiAgICAgICAgICAgIHZhciB4ID0gYCgoJHt0fSkrc3FydCgoJHt0fSleMisoJHt1fSleMykpXigxLzMpKygoJHt0fSktc3FydCgoJHt0fSleMisoJHt1fSleMykpXigxLzMpLSgke3Z9KWA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGEgdG8gb25lXHJcbiAgICAgICAgICAgIHZhciB3ID0gJzEvMitzcXJ0KDMpLzIqaSc7IC8vIEN1YmUgcm9vdCBvZiB1bml0eVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIF8ucGFyc2UoeCksXHJcbiAgICAgICAgICAgICAgICBfLnBhcnNlKGAoJHt4fSkoJHt3fSlgKSxcclxuICAgICAgICAgICAgICAgIF8ucGFyc2UoYCgke3h9KSgke3d9KV4yYClcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBxdWFydGljIGVxdWF0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGVcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gZFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBjXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGJcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBxdWFydGljOiBmdW5jdGlvbiAoZSwgZCwgYywgYiwgYSkge1xyXG4gICAgICAgICAgICB2YXIgc2NvcGUgPSB7fTtcclxuICAgICAgICAgICAgY29yZS5VdGlscy5hcnJheVVuaXF1ZSh2YXJpYWJsZXMoYSkuY29uY2F0KHZhcmlhYmxlcyhiKSlcclxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHZhcmlhYmxlcyhjKSkuY29uY2F0KHZhcmlhYmxlcyhkKSkuY29uY2F0KHZhcmlhYmxlcyhlKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZVt4XSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGEgPSBhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGIgPSBiLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGMgPSBjLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGQgPSBkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGUgPSBlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciBwLCBxLCBELCBEMCwgRDEsIFEsIHgxLCB4MiwgeDMsIHg0O1xyXG4gICAgICAgICAgICAvKnZhciBEID0gY29yZS5VdGlscy5ibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoXCIyNTYqKHswfSleMyooezR9KV4zLTE5MiooezB9KV4yKih7MX0pKih7M30pKih7NH0pXjItMTI4Kih7MH0pXjIqKHsyfSleMiooezR9KV4yKzE0NCooezB9KV4yKih7Mn0pKih7M30pXjIqKHs0fSlcIitcclxuICAgICAgICAgICAgIFwiLTI3Kih7MH0pXjIqKHszfSleNCsxNDQqKHswfSkqKHsxfSleMiooezJ9KSooezR9KV4yLTYqKHswfSkqKHsxfSleMiooezN9KV4yKih7NH0pLTgwKih7MH0pKih7MX0pKih7Mn0pXjIqKHszfSkqKHs0fSkrMTgqKHswfSkqKHsxfSkqKHsyfSkqKHszfSleM1wiK1xyXG4gICAgICAgICAgICAgXCIrMTYqKHswfSkqKHsyfSleNCooezR9KS00Kih7MH0pKih7Mn0pXjMqKHszfSleMi0yNyooezF9KV40Kih7NH0pXjIrMTgqKHsxfSleMyooezJ9KSooezN9KSooezR9KS00Kih7MX0pXjMqKHszfSleMy00Kih7MX0pXjIqKHsyfSleMyooezR9KSsoezF9KV4yKih7Mn0pXjIqKHszfSleMlwiLCBcclxuICAgICAgICAgICAgIGEsIGIsIGMsIGQsIGUpLCBzY29wZSk7XHJcbiAgICAgICAgICAgICB9KTsqL1xyXG5cclxuICAgICAgICAgICAgcCA9IF8ucGFyc2UoZm9ybWF0KFwiKDgqKHswfSkqKHsyfSktMyooezF9KV4yKS8oOCooezB9KV4yKVwiLCBhLCBiLCBjKSkudG9TdHJpbmcoKTsgLy9hLCBiLCBjXHJcbiAgICAgICAgICAgIHEgPSBfLnBhcnNlKGZvcm1hdChcIigoezF9KV4zLTQqKHswfSkqKHsxfSkqKHsyfSkrOCooezB9KV4yKih7M30pKS8oOCooezB9KV4zKVwiLCBhLCBiLCBjLCBkKSkudG9TdHJpbmcoKTsvL2EsIGIsIGMsIGQsIGVcclxuICAgICAgICAgICAgRDAgPSBfLnBhcnNlKGZvcm1hdChcIjEyKih7MH0pKih7NH0pLTMqKHsxfSkqKHszfSkrKHsyfSleMlwiLCBhLCBiLCBjLCBkLCBlKSkudG9TdHJpbmcoKTsgLy9hLCBiLCBjLCBkLCBlXHJcbiAgICAgICAgICAgIEQxID0gXy5wYXJzZShmb3JtYXQoXCIyKih7Mn0pXjMtOSooezF9KSooezJ9KSooezN9KSsyNyooezF9KV4yKih7NH0pKzI3Kih7MH0pKih7M30pXjItNzIqKHswfSkqKHsyfSkqKHs0fSlcIiwgYSwgYiwgYywgZCwgZSkpLnRvU3RyaW5nKCk7IC8vYSwgYiwgYywgZCwgZVxyXG4gICAgICAgICAgICBRID0gXy5wYXJzZShmb3JtYXQoXCIoKCh7MX0pKygoezF9KV4yLTQqKHswfSleMyleKDEvMikpLzIpXigxLzMpXCIsIEQwLCBEMSkpLnRvU3RyaW5nKCk7IC8vRDAsIEQxXHJcbiAgICAgICAgICAgIFMgPSBfLnBhcnNlKGZvcm1hdChcIigxLzIpKigtKDIvMykqKHsxfSkrKDEvKDMqKHswfSkpKigoezJ9KSsoKHszfSkvKHsyfSkpKSkpXigxLzIpXCIsIGEsIHAsIFEsIEQwKSkudG9TdHJpbmcoKTsgLy9hLCBwLCBRLCBEMFxyXG4gICAgICAgICAgICB4MSA9IF8ucGFyc2UoZm9ybWF0KFwiLSgoezF9KS8oNCooezB9KSkpLSh7NH0pKygxLzIpKnNxcnQoLTQqKHs0fSleMi0yKih7Mn0pKygoezN9KS8oezR9KSkpXCIsIGEsIGIsIHAsIHEsIFMpKTsgLy9hLCBiLCBwLCBxLCBTXHJcbiAgICAgICAgICAgIHgyID0gXy5wYXJzZShmb3JtYXQoXCItKCh7MX0pLyg0Kih7MH0pKSktKHs0fSktKDEvMikqc3FydCgtNCooezR9KV4yLTIqKHsyfSkrKCh7M30pLyh7NH0pKSlcIiwgYSwgYiwgcCwgcSwgUykpOyAvL2EsIGIsIHAsIHEsIFNcclxuICAgICAgICAgICAgeDMgPSBfLnBhcnNlKGZvcm1hdChcIi0oKHsxfSkvKDQqKHswfSkpKSsoezR9KSsoMS8yKSpzcXJ0KC00Kih7NH0pXjItMiooezJ9KS0oKHszfSkvKHs0fSkpKVwiLCBhLCBiLCBwLCBxLCBTKSk7IC8vYSwgYiwgcCwgcSwgU1xyXG4gICAgICAgICAgICB4NCA9IF8ucGFyc2UoZm9ybWF0KFwiLSgoezF9KS8oNCooezB9KSkpKyh7NH0pLSgxLzIpKnNxcnQoLTQqKHs0fSleMi0yKih7Mn0pLSgoezN9KS8oezR9KSkpXCIsIGEsIGIsIHAsIHEsIFMpKTsgLy9hLCBiLCBwLCBxLCBTXHJcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHgyLCB4MywgeDRdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJlYWtzIHRoZSBlcXVhdGlvbiB1cCBpbiBpdHMgZmFjdG9ycyBhbmQgdHJpZXMgdG8gc29sdmUgdGhlIHNtYWxsZXIgcGFydHNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNvbHZlX2ZvclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBkaXZpZGVBbmRDb25xdWVyOiBmdW5jdGlvbiAoc3ltYm9sLCBzb2x2ZV9mb3IpIHtcclxuICAgICAgICAgICAgdmFyIHNvbHMgPSBbXTtcclxuICAgICAgICAgICAgLy9zZWUgaWYgd2UgY2FuIHNvbHZlIHRoZSBmYWN0b3JzXHJcbiAgICAgICAgICAgIHZhciBmYWN0b3JzID0gY29yZS5BbGdlYnJhLkZhY3Rvci5mYWN0b3Ioc3ltYm9sKTtcclxuICAgICAgICAgICAgaWYoZmFjdG9ycy5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIGZhY3RvcnMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBTeW1ib2wudW53cmFwUEFSRU5TKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvbHMgPSBzb2xzLmNvbmNhdChzb2x2ZSh4LCBzb2x2ZV9mb3IpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzb2xzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXR0ZW1wdHMgdG8gc29sdmUgdGhlIGVxdWF0aW9uIGFzc3VtaW5nIGl0J3MgYSBwb2x5bm9taWFsIHdpdGggbnVtZXJpYyBjb2VmZmljaWVudHNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gZXFcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc29sdmVfZm9yXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNzb2x2ZTogZnVuY3Rpb24gKGVxLCBzb2x2ZV9mb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuYmxvY2soJ0lHTk9SRV9FJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGYsIHAsIHBuLCBuLCBwZiwgciwgdGhldGEsIHNyLCBzcCwgcm9vdHM7XHJcbiAgICAgICAgICAgICAgICByb290cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZiA9IGNvcmUuVXRpbHMuZGVjb21wb3NlX2ZuKGVxLCBzb2x2ZV9mb3IsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYoZi54Lmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IF8ucGFyc2UoZi54LnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICBwbiA9IE51bWJlcihwKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gXy5wb3coXy5kaXZpZGUoZi5iLm5lZ2F0ZSgpLCBmLmEpLCBwLmludmVydCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBwZiA9IFN5bWJvbC50b1BvbGFyRm9ybUFycmF5KG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBwZlswXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IHBmWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNyID0gci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNwID0gcC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrLCByb290LCBzdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IGZvcm1hdCgnKHswfSkqZV4oMip7MX0qcGkqezJ9KnszfSknLCBzciwgaywgcCwgY29yZS5TZXR0aW5ncy5JTUFHSU5BUlkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290ID0gXy5wYXJzZShzdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290cy5wdXNoKHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByb290cztcclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZXMgc3RhcnRpbmcgcG9pbnRzIGZvciB0aGUgTmV3dG9uIHNvbHZlciBnaXZlbiBhbiBleHByZXNzaW9uIGF0IHplcm8uXHJcbiAgICAgICAgICogSXQgYmVpbmdzIGJ5IGNoZWNrIGlmIHplcm8gaXMgYSBnb29kIHBvaW50IGFuZCBzdGFydHMgZXhwYW5kaW5nIGJ5IGEgcHJvdmlkZWQgc3RlcCBzaXplLiBcclxuICAgICAgICAgKiBCdWlsZHMgb24gdGhlIGZhY3QgdGhhdCBpZiB0aGUgc2lnbiBjaGFuZ2VzIG92ZXIgYW4gaW50ZXJ2YWwgdGhlbiBhIHplcm9cclxuICAgICAgICAgKiBtdXN0IGV4aXN0IG9uIHRoYXQgaW50ZXJ2YWxcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0ZXBcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHNcclxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0UG9pbnRzOiBmdW5jdGlvbiAoc3ltYm9sLCBzdGVwLCBwb2ludHMpIHtcclxuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgfHwgMC4wMTtcclxuICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzIHx8IFtdO1xyXG4gICAgICAgICAgICB2YXIgZiA9IGJ1aWxkKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIHZhciB4MCA9IDA7XHJcblxyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLnJvdW5kKHgwKSxcclxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gZihzdGFydCksXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9zaWduID0gbGFzdCAvIE1hdGguYWJzKGxhc3QpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJzaWRlID0gY29yZS5TZXR0aW5ncy5ST09UU19QRVJfU0lERSwgLy8gdGhlIG1heCBudW1iZXIgb2Ygcm9vdHMgb24gcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgIGxzaWRlID0gcnNpZGU7IC8vIHRoZSBtYXggbnVtYmVyIG9mIHJvb3RzIG9uIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICAvLyBjaGVjayBhcm91bmQgdGhlIHN0YXJ0aW5nIHBvaW50XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKE1hdGguZmxvb3Ioc3RhcnQgLyAyKSk7IC8vaGFsZiB3YXkgZnJvbSB6ZXJvIG1pZ2h0IGJlIGEgZ29vZCBzdGFydFxyXG4gICAgICAgICAgICBwb2ludHMucHVzaChNYXRoLmFicyhzdGFydCkpOyAvL3xmKDApfCBjb3VsZCBiZSBhIGdvb2Qgc3RhcnRcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnQpOy8vfGYoMCl8IGNvdWxkIGJlIGEgZ29vZCBzdGFydFxyXG4gICAgICAgICAgICAvL2FkanVzdCBmb3IgbG9nLiBBIGdvb2Qgc3RhcnRpbmcgcG9pbnQgdG8gaW5jbHVkZSBmb3IgbG9nIGlzIDAuMVxyXG4gICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgaWYoeC5jb250YWluc0Z1bmN0aW9uKGNvcmUuU2V0dGluZ3MuTE9HKSlcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaCgwLjEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcmFuZ2UoLWNvcmUuU2V0dGluZ3MuU09MVkVfUkFESVVTLCBzdGFydCwgc3RlcCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByYW5nZShzdGFydCwgY29yZS5TZXR0aW5ncy5TT0xWRV9SQURJVVMsIHN0ZXApO1xyXG5cclxuICAgICAgICAgICAgdmFyIHRlc3Rfc2lkZSA9IGZ1bmN0aW9uIChzaWRlLCBudW1fcm9vdHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4aSwgdmFsLCBzaWduO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpdHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBzaWRlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHhpID0gc2lkZVtpXTsgLy90aGUgcG9pbnQgYmVpbmcgZXZhbHVhdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZih4aSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9IHZhbCAvIE1hdGguYWJzKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Eb24ndCBhZGQgbm9uLW51bWVyaWMgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNOYU4odmFsKSB8fCAhaXNGaW5pdGUodmFsKSB8fCBoaXRzLmxlbmd0aCA+IG51bV9yb290cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29tcGFyZSB0aGUgc2lnbnMuIFRoZSBoYXZlIHRvIGJlIGRpZmZlcmVudCBpZiB0aGV5IGNyb3NzIGEgemVyb1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNpZ24gIT09IGxhc3Rfc2lnbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXRzLnB1c2goeGkpOyAvL3Rha2Ugbm90ZSBvZiB0aGUgcG9zc2libGUgemVybyBsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsYXN0X3NpZ24gPSBzaWduO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQoaGl0cyk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0ZXN0X3NpZGUobGVmdCwgbHNpZGUpO1xyXG4gICAgICAgICAgICB0ZXN0X3NpZGUocmlnaHQsIHJzaWRlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXBsZW1lbnRzIHRoZSBiaXNlY3Rpb24gbWV0aG9kLiBSZXR1cm5zIHVuZGVmaW5lZCBpbiBubyBzb2x1dGlvbiBpcyBmb3VuZFxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludFxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcclxuICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkIHwgbnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGJpc2VjdGlvbjogZnVuY3Rpb24gKHBvaW50LCBmKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gcG9pbnQgLSAxO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBwb2ludCArIDE7XHJcbiAgICAgICAgICAgIC8vIEZpcnN0IHRlc3QgaWYgdGhpcyBwb2ludCBpcyBldmVuIHdvcnRoIGV2YWx1YXRpbmcuIEl0IHNob3VsZFxyXG4gICAgICAgICAgICAvLyBiZSBjcm9zc2luZyB0aGUgeCBheGlzIHNvIHRoZSBzaWducyBzaG91bGQgYmUgZGlmZmVyZW50XHJcbiAgICAgICAgICAgIGlmKE1hdGguc2lnbihmKGxlZnQpKSAhPT0gTWF0aC5zaWduKGYocmlnaHQpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNhZmV0eSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVwc2lsb24sIG1pZGRsZTtcclxuXHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXBzaWxvbiA9IE1hdGguYWJzKHJpZ2h0IC0gbGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmZXR5IGFnYWluc3QgYW4gaW5maW5pdGUgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHNhZmV0eSsrID4gY29yZS5TZXR0aW5ncy5NQVhfQklTRUNUSU9OX0lURVIgfHwgaXNOYU4oZXBzaWxvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG1pZGRsZSBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIG1pZGRsZSA9IChsZWZ0ICsgcmlnaHQpIC8gMjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZihsZWZ0KSAqIGYobWlkZGxlKSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IG1pZGRsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbWlkZGxlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlKGVwc2lsb24gPj0gU2V0dGluZ3MuRVBTSUxPTik7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gKGxlZnQgKyByaWdodCkgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRlc3QgdGhlIHNvbHV0aW9uIHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3Mgd2l0aGluIHRvbGVyYW5jZVxyXG4gICAgICAgICAgICAgICAgdmFyIHhfcG9pbnQgPSBmKHNvbHV0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZighaXNOYU4oeF9wb2ludCkgJiYgTWF0aC5hYnMoeF9wb2ludCkgPD0gY29yZS5TZXR0aW5ncy5CSV9TRUNUSU9OX0VQU0lMT04pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIHRvbyBtYW55IGp1bmsgc29sdXRpb25zIGlmIG5vdCByb3VuZGVkIGF0IDEzdGggcGxhY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMucm91bmQoc29sdXRpb24sIDEzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW1wbGVtZW50cyBOZXd0b24ncyBpdGVyYXRpb25zLiBSZXR1cm5zIHVuZGVmaW5lZCBpZiBubyBzb2x1dGlvbnMgaWYgZm91bmRcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9pbnRcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXHJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnBcclxuICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfG51bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBOZXd0b246IGZ1bmN0aW9uIChwb2ludCwgZiwgZnApIHtcclxuICAgICAgICAgICAgdmFyIG1heGl0ZXIgPSBjb3JlLlNldHRpbmdzLk1BWF9ORVdUT05fSVRFUkFUSU9OUyxcclxuICAgICAgICAgICAgICAgICAgICBpdGVyID0gMDtcclxuICAgICAgICAgICAgLy9maXJzdCB0cnkgdGhlIHBvaW50IGl0c2VsZi4gSWYgaXQncyB6ZXJvIHZpb2xhLiBXZSdyZSBkb25lXHJcbiAgICAgICAgICAgIHZhciB4MCA9IHBvaW50LCB4O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZngwID0gZih4MCk7IC8vc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlIHZhbHVlIGlzIHplcm8gdGhlbiB3ZSdyZSBkb25lIGJlY2F1c2UgMCAtICgwL2QgZih4MCkpID0gMFxyXG4gICAgICAgICAgICAgICAgaWYoeDAgPT09IDAgJiYgZngwID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaXRlcisrO1xyXG4gICAgICAgICAgICAgICAgaWYoaXRlciA+IG1heGl0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvL25heGltdW0gaXRlcmF0aW9ucyByZWFjaGVkXHJcblxyXG4gICAgICAgICAgICAgICAgeCA9IHgwIC0gZngwIC8gZnAoeDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBNYXRoLmFicyh4IC0geDApO1xyXG4gICAgICAgICAgICAgICAgeDAgPSB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKGUgPiBTZXR0aW5ncy5ORVdUT05fRVBTSUxPTilcclxuXHJcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIG51bWJlciBpcyBpbmRlZWQgemVyby4gMWUtMTMgc2VlbXMgdG8gZ2l2ZSB0aGUgbW9zdCBhY2N1cmF0ZSByZXN1bHRzXHJcbiAgICAgICAgICAgIGlmKE1hdGguYWJzKGYoeCkpIDw9IFNldHRpbmdzLkVQU0lMT04pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJld3JpdGU6IGZ1bmN0aW9uIChyaHMsIGxocywgZm9yX3ZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgIGxocyA9IGxocyB8fCBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICBpZihyaHMuaXNDb21wb3NpdGUoKSAmJiByaHMuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgLy90cnkgdG8gaXNvbGF0ZSB0aGUgc3F1YXJlIHJvb3RcclxuICAgICAgICAgICAgICAgIC8vY29udGFpbmVyIGZvciB0aGUgc3F1YXJlIHJvb3RzXHJcbiAgICAgICAgICAgICAgICB2YXIgc3FydHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vYWxsIGVsc2VcclxuICAgICAgICAgICAgICAgIHZhciByZW0gPSBbXTtcclxuICAgICAgICAgICAgICAgIHJocy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHguY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih4LmZuYW1lID09PSAnc3FydCcgJiYgeC5jb250YWlucyhmb3JfdmFyaWFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNxcnRzLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW0ucHVzaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzcXJ0cy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL21vdmUgdGhlIHJlbWFpbmRlciB0byB0aGUgUkhTXHJcbiAgICAgICAgICAgICAgICAgICAgbGhzID0gXy5leHBhbmQoXy5wb3coXy5zdWJ0cmFjdChsaHMsIGNvcmUuVXRpbHMuYXJyYXlTdW0ocmVtKSksIG5ldyBTeW1ib2woMikpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3NxdWFyZSBib3RoIHNpZGVzXHJcbiAgICAgICAgICAgICAgICAgICAgcmhzID0gXy5leHBhbmQoXy5wb3coU3ltYm9sLnVud3JhcFNRUlQoc3FydHNbMF0pLCBuZXcgU3ltYm9sKDIpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByaHMgPSBTeW1ib2wudW53cmFwU1FSVChfLmV4cGFuZChyaHMpKTsgLy9leHBhbmQgdGhlIHRlcm0gZXhwcmVzc2lvbiBnbyBnZXQgcmlkIG9mIHF1b3RpZW50cyB3aGVuIHBvc3NpYmxlXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBjID0gMCwgLy9hIGNvdW50ZXIgdG8gc2VlIGlmIHdlIGhhdmUgYWxsIHRlcm1zIHdpdGggdGhlIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IHJocy5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vdHJ5IHRvIHJld3JpdGUgdGhlIHdob2xlIHRoaW5nXHJcbiAgICAgICAgICAgIGlmKHJocy5ncm91cCA9PT0gQ1AgJiYgcmhzLmNvbnRhaW5zKGZvcl92YXJpYWJsZSkgJiYgcmhzLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgIHJocy5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgLy9maXJzdCBicmluZyBhbGwgdGhlIHRlcm1zIGNvbnRhaW5pbmcgdGhlIHZhcmlhYmxlIHRvIHRoZSBsaHNcclxuICAgICAgICAgICAgICAgIHJocy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeC5jb250YWlucyhmb3JfdmFyaWFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8uYWRkKHQsIHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGhzID0gXy5zdWJ0cmFjdChsaHMsIHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJocyA9IHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiBub3QgYWxsIHRoZSB0ZXJtcyBjb250YWluIHRoZSB2YXJpYWJsZSBzbyBpdCdzIGluIHRoZSBmb3JtXHJcbiAgICAgICAgICAgICAgICAvL2EqeF4yK3hcclxuICAgICAgICAgICAgICAgIGlmKGMgIT09IGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX18ucmV3cml0ZShyaHMsIGxocywgZm9yX3ZhcmlhYmxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbcmhzLCBsaHNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYocmhzLmdyb3VwID09PSBDQiAmJiByaHMuY29udGFpbnMoZm9yX3ZhcmlhYmxlKSAmJiByaHMuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYocmhzLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByaHMubXVsdGlwbGllciA9IHJocy5tdWx0aXBsaWVyLm11bHRpcGx5KG5ldyBjb3JlLkZyYWMoLTEpKTtcclxuICAgICAgICAgICAgICAgICAgICBsaHMubXVsdGlwbGllciA9IGxocy5tdWx0aXBsaWVyLm11bHRpcGx5KG5ldyBjb3JlLkZyYWMoLTEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGxocy5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmhzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5jb250YWlucyhmb3JfdmFyaWFibGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkodCwgeC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGhzID0gXy5kaXZpZGUobGhzLCB4LmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJocyA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fLnJld3JpdGUocmhzLCBsaHMsIGZvcl92YXJpYWJsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoIXJocy5pc0xpbmVhcigpICYmIHJocy5jb250YWlucyhmb3JfdmFyaWFibGUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IF8ucGFyc2UocmhzLnBvd2VyLmNsb25lKCkuaW52ZXJ0KCkpO1xyXG4gICAgICAgICAgICAgICAgcmhzID0gXy5wb3cocmhzLCBwLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgbGhzID0gXy5wb3coXy5leHBhbmQobGhzKSwgcC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfXy5yZXdyaXRlKHJocywgbGhzLCBmb3JfdmFyaWFibGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYocmhzLmdyb3VwID09PSBGTiB8fCByaHMuZ3JvdXAgPT09IFMgfHwgcmhzLmdyb3VwID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtyaHMsIGxoc107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNxcnRTb2x2ZTogZnVuY3Rpb24gKHN5bWJvbCwgdikge1xyXG4gICAgICAgICAgICB2YXIgc3FydHMgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICB2YXIgcmVtID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeC5mbmFtZSA9PT0gJ3NxcnQnICYmIHguY29udGFpbnModikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3FydHMgPSBfLmFkZChzcXJ0cywgeC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IF8uYWRkKHJlbSwgeC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vcXVpY2sgYW5kIGRpcnR5IEFUTVxyXG4gICAgICAgICAgICAgICAgaWYoIXNxcnRzLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gXy5leHBhbmQoXy5tdWx0aXBseShfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyKSwgXy5zdWJ0cmFjdChfLnBvdyhyZW0sIG5ldyBTeW1ib2woMikpLCBfLnBvdyhzcXJ0cywgbmV3IFN5bWJvbCgyKSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zcXVhcmUgYm90aCBzaWRlc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzb2x1dGlvbnMgPSBzb2x2ZSh0LCB2KTtcclxuICAgICAgICAgICAgICAgICAgICAvL3Rlc3QgdGhlIHBvaW50cy4gVGhlIGR1bWIgd2F5IG9mIGdldHRpbmcgdGhlIGFuc3dlcnNcclxuICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMgPSBzb2x1dGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGUuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VicyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzW3ZdID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gZXZhbHVhdGUoc3ltYm9sLCBzdWJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocG9pbnQuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLypcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd8RXF1YXRpb259IGVxbnNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb2x2ZV9mb3JcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvbHV0aW9uc1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xFcXVhdGlvbn0gZm5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdmFyIHNvbHZlID0gZnVuY3Rpb24gKGVxbnMsIHNvbHZlX2Zvciwgc29sdXRpb25zLCBkZXB0aCwgZm4pIHtcclxuICAgICAgICBkZXB0aCA9IGRlcHRoIHx8IDA7XHJcblxyXG4gICAgICAgIGlmKGRlcHRoKysgPiBTZXR0aW5ncy5NQVhfU09MVkVfREVQVEgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vbWFrZSBwcmVwYXJhdGlvbnMgaWYgaXQncyBhbiBFcXVhdGlvblxyXG4gICAgICAgIGlmKGVxbnMgaW5zdGFuY2VvZiBFcXVhdGlvbikge1xyXG4gICAgICAgICAgICAvL2lmIGl0J3MgemVybyB0aGVuIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgaWYoZXFucy5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgU3ltYm9sKDApXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIHRoZSBsaHMgPSB4IHRoZW4gd2UncmUgZG9uZVxyXG4gICAgICAgICAgICBpZihlcW5zLkxIUy5lcXVhbHMoc29sdmVfZm9yKSAmJiAhZXFucy5SSFMuY29udGFpbnMoc29sdmVfZm9yKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlcW5zLlJIU107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiB0aGUgcmhzID0geCB0aGVuIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgaWYoZXFucy5SSFMuZXF1YWxzKHNvbHZlX2ZvcikgJiYgIWVxbnMuTEhTLmNvbnRhaW5zKHNvbHZlX2ZvcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbZXFucy5MSFNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3Vud3JhcCB0aGUgdmVjdG9yIHNpbmNlIHdoYXQgd2Ugd2FudCBhcmUgdGhlIGVsZW1lbnRzXHJcbiAgICAgICAgaWYoZXFucyBpbnN0YW5jZW9mIGNvcmUuVmVjdG9yKVxyXG4gICAgICAgICAgICBlcW5zID0gZXFucy5lbGVtZW50cztcclxuICAgICAgICBzb2x2ZV9mb3IgPSBzb2x2ZV9mb3IgfHwgJ3gnOyAvL2Fzc3VtZXMgeCBieSBkZWZhdWx0XHJcbiAgICAgICAgLy9JZiBpdCdzIGFuIGFycmF5IHRoZW4gc29sdmUgaXQgYXMgYSBzeXN0ZW0gb2YgZXF1YXRpb25zXHJcbiAgICAgICAgaWYoaXNBcnJheShlcW5zKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX18uc29sdmVTeXN0ZW0uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGFyc2Ugb3V0IGZ1bmN0aW9ucy4gRml4IGZvciBpc3N1ZSAjMzAwXHJcbiAgICAgICAgLy8gZXFucyA9IGNvcmUuVXRpbHMuZXZhbHVhdGUoZXFucyk7XHJcbiAgICAgICAgc29sdXRpb25zID0gc29sdXRpb25zIHx8IFtdO1xyXG4gICAgICAgIC8vbWFyayBleGlzdGluZyBzb2x1dGlvbnMgYXMgbm90IHRvIGhhdmUgZHVwbGljYXRlc1xyXG4gICAgICAgIHZhciBleGlzdGluZyA9IHt9O1xyXG5cclxuICAgICAgICAvLyBFYXN5IGZhaWwuIElmIGl0J3MgYSByYXRpb25hbCBmdW5jdGlvbiBhbmQgdGhlIGRlbm9taW5hdG9yIGlzIHplcm9cclxuICAgICAgICAvLyB0aGUgd2UncmUgZG9uZS4gSXNzdWUgIzU1NVxyXG4gICAgICAgIHZhciBrbm93biA9IHt9O1xyXG4gICAgICAgIGtub3duW3NvbHZlX2Zvcl0gPSAwO1xyXG4gICAgICAgIGlmKGlzU3ltYm9sKGVxbnMpICYmIGV2YWx1YXRlKGVxbnMuZ2V0RGVub20oKSwga25vd24pLmVxdWFscygwKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29sdXRpb25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSXMgdXN1ZWQgdG8gYWRkIHNvbHV0aW9ucyB0byBzZXQuIFxyXG4gICAgICAgIC8vIFRPRE86IFNldCBpcyBub3cgaW1wbGVtZW50ZWQgYW5kIHNob3VsZCBiZSB1dGlsaXplZFxyXG4gICAgICAgIHZhciBhZGRfdG9fcmVzdWx0ID0gZnVuY3Rpb24gKHIsIGhhc190cmlnKSB7XHJcbiAgICAgICAgICAgIHZhciByX2lzX3N5bWJvbCA9IGlzU3ltYm9sKHIpO1xyXG4gICAgICAgICAgICBpZihyID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHIgPT09ICdudW1iZXInICYmIGlzTmFOKHIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZihpc0FycmF5KHIpKSB7XHJcbiAgICAgICAgICAgICAgICByLmZvckVhY2goZnVuY3Rpb24gKHNvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoc29sKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYoci52YWx1ZU9mKCkgIT09ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIHByZS1hZGQgZnVuY3Rpb24gaWYgZGVmaW5lZC4gVGhpcyBjb3VsZCBiZSB1c2VmdWwgZm9yIHJvdW5kaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGNvcmUuU2V0dGluZ3MuUFJFX0FERF9TT0xVVElPTiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gY29yZS5TZXR0aW5ncy5QUkVfQUREX1NPTFVUSU9OKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXJfaXNfc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBfLnBhcnNlKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gY29udmVydCB0aGUgbnVtYmVyIHRvIG11bHRpcGxlcyBvZiBwaVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvcmUuU2V0dGluZ3MubWFrZV9waV9jb252ZXJzaW9ucyAmJiBoYXNfdHJpZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IF8uZGl2aWRlKHIuY2xvbmUoKSwgbmV3IFN5bWJvbChNYXRoLlBJKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHRlbXAubXVsdGlwbGllcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gTWF0aC5hYnMobS5udW0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBNYXRoLmFicyhtLmRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEgPCAxMCAmJiBiIDwgMTApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gXy5tdWx0aXBseSh0ZW1wLCBuZXcgU3ltYm9sKCdwaScpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZCBjaGVjayBpZiB3ZSBnZXQgYSBudW1iZXIgb3RoZXJ3aXNlIHdlIG1pZ2h0IGJlIHRocm93aW5nIG91dCBzeW1ib2xpYyBzb2x1dGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJfc3RyID0gci50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZighZXhpc3Rpbmdbcl9zdHJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5wdXNoKHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSBhbnN3ZXIgYXMgc2VlblxyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nW3Jfc3RyXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBNYXliZSB3ZSBnZXQgbHVja3kuIFRyeSB0aGUgcG9pbnQgYXQgdGhlIGZ1bmN0aW9uLiBJZiBpdCB3b3JrcyB3ZSBoYXZlIGEgcG9pbnRcclxuICAgICAgICAvLyBJZiBub3QgaXQgZmFpbGVkXHJcbiAgICAgICAgaWYoZXFucy5ncm91cCA9PT0gUyAmJiBlcW5zLmNvbnRhaW5zKHNvbHZlX2ZvcikpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBvID0ge307XHJcbiAgICAgICAgICAgICAgICBvW3NvbHZlX2Zvcl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgZXZhbHVhdGUoZm4sIG8sICdudW1lcicpO1xyXG4gICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChuZXcgU3ltYm9sKDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc29sdXRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihlcW5zLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAvLyBJdCBzdWZmaWNlcyB0byBzb2x2ZSBmb3IgdGhlIG51bWVyYXRvclxyXG4gICAgICAgICAgICB2YXIgbnVtID0gZXFucy5nZXROdW0oKTtcclxuXHJcbiAgICAgICAgICAgIGlmKG51bS5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZiA9IFN0cmluZyhzb2x2ZV9mb3IpOyAvL2V2ZXJ5dGhpbmcgZWxzZSBiZWxvbmdzIHRvIHRoZSBjb2VmZlxyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIGRlbm9taW5hdG9yIGFuZCBtYWtlIHN1cmUgaXQgZG9lc24ndCBoYXZlIHggc2luY2Ugd2UgZG9uJ3Qga25vdyBob3cgdG8gc29sdmUgZm9yIHRob3NlXHJcbiAgICAgICAgICAgICAgICBudW0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHguY29udGFpbnMoc2YpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x2ZSh4LCBzb2x2ZV9mb3IsIHNvbHV0aW9ucywgZGVwdGgsIGVxbnMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9ucztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNvbHZlKG51bSwgc29sdmVfZm9yLCBzb2x1dGlvbnMsIGRlcHRoLCBmbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihlcW5zLmdyb3VwID09PSBGTiAmJiBlcW5zLmZuYW1lID09PSAnc3FydCcpIHtcclxuICAgICAgICAgICAgZXFucyA9IF8ucG93KFN5bWJvbC51bndyYXBTUVJUKGVxbnMpLCBuZXcgU3ltYm9sKDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9wYXNzIGluIGZhbHNlIHRvIG5vdCBleHBhbmQgZXF1YXRpb25zIHN1Y2ggYXMgKHgreSleNS5cclxuICAgICAgICAvL0l0IHN1ZmZpY2VzIHRvIHNvbHZlIGZvciB0aGUgbnVtZXJhdG9yIHNpbmNlIHRoZXJlJ3Mgbm8gdmFsdWUgaW4gdGhlIGRlbm9taW5hdG9yIHdoaWNoIHlpZWxkcyBhIHplcm8gZm9yIHRoZSBmdW5jdGlvblxyXG4gICAgICAgIHZhciBlcSA9IChjb3JlLlV0aWxzLmlzU3ltYm9sKGVxbnMpID8gZXFucyA6IF9fLnRvTEhTKGVxbnMsIGZhbHNlKSkuZ2V0TnVtKCksXHJcbiAgICAgICAgICAgICAgICB2YXJzID0gY29yZS5VdGlscy52YXJpYWJsZXMoZXEpLCAvL2dldCBhIGxpc3Qgb2YgYWxsIHRoZSB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgIG51bXZhcnMgPSB2YXJzLmxlbmd0aDsvL2hvdyBtYW55IHZhcmlhYmxlcyBhcmUgd2UgZGVhbGluZyB3aXRoXHJcblxyXG4gICAgICAgIC8vaXQgc3VmZmljaWVudCB0byBzb2x2ZSAoeCt5KSBpZiBlcSBpcyAoeCt5KV5uIHNpbmNlIDBeblxyXG4gICAgICAgIGlmKGNvcmUuVXRpbHMuaXNJbnQoZXEucG93ZXIpICYmIGVxLnBvd2VyID4gMCkge1xyXG4gICAgICAgICAgICBlcSA9IF8ucGFyc2UoZXEpLnRvTGluZWFyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2lmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHNpbmdsZSB2YXJpYWJsZSB0aGVuIHdlIGZpcnN0IGNoZWNrIGlmIGl0J3MgYSBcclxuICAgICAgICAvL3BvbHlub21pYWwgKGluY2x1ZGluZyByYXRpb25hbHMpLklmIGl0IGlzIHRoZW4gd2UgdXNlIHRoZSBKZW5raW5zLVRyYXViYiBhbGdvcml0aG0uICAgICBcclxuICAgICAgICAvL0Rvbid0IHdhc3RlIHRpbWVcclxuICAgICAgICBpZihlcS5ncm91cCA9PT0gUyB8fCBlcS5ncm91cCA9PT0gQ0IgJiYgZXEuY29udGFpbnMoc29sdmVfZm9yKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gW25ldyBTeW1ib2woMCldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2ZvcmNlIHRvIHBvbHlub21pYWwuIFdlIGdvIHRocm91Z2ggZWFjaCBhbmQgdGhlbiB3ZSBsb29rIGF0IHdoYXQgaXQgd291bGQgXHJcbiAgICAgICAgLy90YWtlIGZvciBpdHMgcG93ZXIgdG8gYmUgYW4gaW50ZWdlclxyXG4gICAgICAgIC8vaWYgdGhlIHBvd2VyIGlzIGEgZnJhY3Rpb25hbCB3ZSBkaXZpZGUgYnkgdGhlIGZyYWN0aW9uYWwgcG93ZXJcclxuICAgICAgICB2YXIgZnJhY3Rpb25hbHMgPSB7fSxcclxuICAgICAgICAgICAgICAgIGNmYWN0O1xyXG5cclxuICAgICAgICB2YXIgY29ycmVjdF9kZW5vbSA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgc3ltYm9sID0gXy5leHBhbmQoc3ltYm9sLCB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRfZGVub21pbmF0b3I6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBleHBhbmRfZnVuY3Rpb25zOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBzeW1ib2wuY2xvbmUoKTsgLy9wcmVzZXJ2ZSB0aGUgb3JpZ2luYWxcclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gc3ltYm9sLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gc3ltYm9sLnN5bWJvbHNbeF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBkZW5vbWluYXRvciBvZiB0aGUgc3ViLXN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZW4gPSBzeW0uZ2V0RGVub20oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWRlbi5pc0NvbnN0YW50KHRydWUpICYmIHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBfLmFkZCh0LCBfLm11bHRpcGx5KGUsIGRlbi5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RfZGVub20oXy5tdWx0aXBseShfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyKSwgdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gZXhwbG9kZShzeW0sIHNvbHZlX2Zvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX3NxcnQgPSBwYXJ0c1sxXS5mbmFtZSA9PT0gY29yZS5TZXR0aW5ncy5TUVJUO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gU3ltYm9sLnVud3JhcFNRUlQocGFydHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdi5wb3dlci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY2lyY3VsYXIgbG9naWMgd2l0aCBzcXJ0LiBTaW5jZSBzcXJ0KHgpIGJlY29tZXMgeF4oMS8yKSB3aGljaCB0aGVuIGJlY29tZXMgc3FydCh4KSwgdGhpcyBjb250aW51ZXMgZm9yZXZlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcyBuZWVkcyB0byBiZSB0ZXJtaW5hdGVkIGlmIHAgPSAxLzJcclxuICAgICAgICAgICAgICAgICAgICBpZighaXNTeW1ib2wocCkgJiYgIXAuZXF1YWxzKDEgLyAyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwLmRlbi5ndCgxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNfc3FydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uc3VidHJhY3Qoc3ltYm9sLCBzeW0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5hZGQoc3ltYm9sLCBfLm11bHRpcGx5KHBhcnRzWzBdLmNsb25lKCksIHYpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ycmVjdF9kZW5vbShzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBmcmFjdGlvbmFsc1twLmRlbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFjdGlvbmFsc1twLmRlbl0gPSBjID8gYysrIDogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHAuc2lnbigpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IF8ucGFyc2Uoc29sdmVfZm9yICsgJ14nICsgTWF0aC5hYnMocCkpOyAvL3RoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdW53cmFwIHRoZSBzeW1ib2wncyBkZW5vbmlhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih5LmNvbnRhaW5zKHNvbHZlX2ZvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnN5bWJvbHNbaW5kZXhdID0gXy5tdWx0aXBseSh5LCBmYWN0b3IuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFjdGlvbmFscyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3RfZGVub20oXy5wYXJzZShzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bS5ncm91cCA9PT0gUEwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5fcCA9IGNvcmUuVXRpbHMuYXJyYXlNaW4oY29yZS5VdGlscy5rZXlzKHN5bS5zeW1ib2xzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtaW5fcCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gXy5wYXJzZShzb2x2ZV9mb3IgKyAnXicgKyBNYXRoLmFicyhtaW5fcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWQgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGVkID0gXy5hZGQoY29ycmVjdGVkLCBfLm11bHRpcGx5KHguY2xvbmUoKSwgZmFjdG9yLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ycmVjdGVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vc2VwYXJhdGUgdGhlIGVxdWF0aW9uXHJcbiAgICAgICAgdmFyIHNlcGFyYXRlID0gZnVuY3Rpb24gKGVxKSB7XHJcbiAgICAgICAgICAgIHZhciBsaHMgPSBuZXcgU3ltYm9sKDApLFxyXG4gICAgICAgICAgICAgICAgICAgIHJocyA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgIGVxLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGlmKHguY29udGFpbnMoc29sdmVfZm9yLCB0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICBsaHMgPSBfLmFkZChsaHMsIHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmhzID0gXy5zdWJ0cmFjdChyaHMsIHguY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gW2xocywgcmhzXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBfXy5pbnZlcnNlRnVuY3Rpb25Tb2x2ZSA9IGZ1bmN0aW9uIChuYW1lLCBsaHMsIHJocykge1xyXG4gICAgICAgICAgICAvL2F4K2IgY29tZXMgYmFjayBhcyBbYSwgeCwgYXgsIGJdO1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBleHBsb2RlKGxocy5hcmdzWzBdLCBzb2x2ZV9mb3IpO1xyXG4gICAgICAgICAgICAvL2NoZWNrIGlmIHggaXMgYnkgaXRzZWxmXHJcbiAgICAgICAgICAgIHZhciB4ID0gcGFydHNbMV07XHJcbiAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZShfLnN5bWZ1bmN0aW9uKG5hbWUsIFtfLmRpdmlkZShyaHMsIF8ucGFyc2UobGhzLm11bHRpcGxpZXIpKV0pLCBwYXJ0c1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy9maXJzdCByZW1vdmUgYW55IGRlbm9taW5hdG9yc1xyXG4gICAgICAgIGVxID0gY29ycmVjdF9kZW5vbShlcSk7XHJcblxyXG4gICAgICAgIGlmKGVxLmVxdWFscygwKSlcclxuICAgICAgICAgICAgcmV0dXJuIFtlcV07XHJcbiAgICAgICAgLy9jb3JyZWN0IGZyYWN0aW9uYWxzLiBJIGNhbiBvbmx5IGhhbmRsZSBvbmUgdHlwZSByaWdodCBub3dcclxuICAgICAgICB2YXIgZmtleXMgPSBjb3JlLlV0aWxzLmtleXMoZnJhY3Rpb25hbHMpO1xyXG4gICAgICAgIGlmKGZrZXlzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAvL21ha2UgYSBub3RlIG9mIHRoZSBmYWN0b3JcclxuICAgICAgICAgICAgY2ZhY3QgPSBma2V5c1swXTtcclxuICAgICAgICAgICAgZXEuZWFjaChmdW5jdGlvbiAoeCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGlmKHguY29udGFpbnMoc29sdmVfZm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGV4cGxvZGUoeCwgc29sdmVfZm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHBhcnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdi5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZihwLmRlbi5ndCgxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2LnBvd2VyID0gcC5tdWx0aXBseShuZXcgY29yZS5GcmFjKGNmYWN0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxLnN5bWJvbHNbaW5kZXhdID0gXy5tdWx0aXBseSh2LCBwYXJ0c1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZXEgPSBfLnBhcnNlKGVxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdHJ5IGZvciBuZXN0ZWQgc3FydHMgYXMgcGVyIGlzc3VlICM0ODZcclxuICAgICAgICBhZGRfdG9fcmVzdWx0KF9fLnNxcnRTb2x2ZShlcSwgc29sdmVfZm9yKSk7XHJcblxyXG4gICAgICAgIC8vcG9seW5vbWlhbCBzaW5nbGUgdmFyaWFibGVcclxuICAgICAgICBpZihudW12YXJzID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmKGVxLmlzUG9seSh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgLy90cnkgdG8gZmFjdG9yIGFuZCBzb2x2ZVxyXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvcnMgPSBuZXcgY29yZS5BbGdlYnJhLkNsYXNzZXMuRmFjdG9ycygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKGVxLCBmYWN0b3JzKTtcclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlIGVxdWF0aW9uIGhhcyBtb3JlIHRoYW4gb25lIHN5bWJvbGljIGZhY3RvciB0aGVuIHNvbHZlIHRob3NlIGluZGl2aWR1YWxseVxyXG4gICAgICAgICAgICAgICAgaWYoZmFjdG9ycy5nZXROdW1iZXJTeW1ib2xpY3MoKSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gZmFjdG9ycy5mYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoc29sdmUoZmFjdG9ycy5mYWN0b3JzW3hdLCBzb2x2ZV9mb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29lZmZzID0gY29yZS5VdGlscy5nZXRDb2VmZnMoZXEsIHNvbHZlX2ZvciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWcgPSBjb2VmZnMubGVuZ3RoIC0gMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc19jYWxjdWxhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodmFyc1swXSA9PT0gc29sdmVfZm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgdG8gc2VlIGlmIGFsbCB0aGUgY29lZmZpY2llbnRzIGFyZSBjb25zdGFudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjaGVja0FsbChjb2VmZnMsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5ncm91cCAhPT0gY29yZS5ncm91cHMuTjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290cyA9IGNvcmUuQWxnZWJyYS5wcm9vdHMoZXEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBhbGwgdGhlIHJvb3RzIGFyZSBpbnRlZ2VycyB0aGVuIHJldHVybiB0aG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hlY2tBbGwocm9vdHMsIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjb3JlLlV0aWxzLmlzSW50KHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jvb3RzIGhhdmUgYmVlbiBjYWxjdWxhdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzX2NhbGN1bGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RzLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KG5ldyBTeW1ib2woeCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighd2FzX2NhbGN1bGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxbnMgPSBfLnBhcnNlKGVxbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXFucyBpbnN0YW5jZW9mIGNvcmUuRXF1YXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXFucyA9IGVxbnMudG9MSFMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGNhbiBzb2x2ZSBhbGdlYnJhaWNhbGx5IGZvciBkZWdyZWVzIDEsIDIsIDMuIFRoZSByZW1haW5kZXIgd2Ugc3dpdGNoIHRvIEplbmtpbnMtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihkZWcgPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfLmRpdmlkZShjb2VmZnNbMF0sIGNvZWZmc1sxXS5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkZWcgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KF8uZXhwYW5kKF9fLnF1YWQuYXBwbHkodW5kZWZpbmVkLCBjb2VmZnMpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkZWcgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb25zID0gW107IC8vc2V0IHRvIGJsYW5rXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maXJzdCB0cnkgdG8gZmFjdG9yIGFuZCBzb2x2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JlZCA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKGVxbnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGl0IHdhcyBzdWNjZXNzZnVsbHkgZmFjdG9yZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29sdXRpb25zID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc29sdXRpb25zLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoc29sdXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoX18uY3ViaWMuYXBwbHkodW5kZWZpbmVkLCBjb2VmZnMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltX3Jvb3RzID0gY3NvbHZlKGVxLCBzb2x2ZV9mb3IpOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltX3Jvb3RzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltX3Jvb3RzID0gZGl2bmNvbnNvbHZlKGVxLCBzb2x2ZV9mb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzeW1fcm9vdHMubGVuZ3RoID4gMCkgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoc3ltX3Jvb3RzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9BLnByb290cyhlcSkubWFwKGFkZF90b19yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IE5ld3RvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIGl0J3Mgbm90IGEgcG9seW5vbWlhbCB0aGVuIHdlJ2xsIHRyeSB0byBsb29rIGZvciBhIHNvbHV0aW9uIHVzaW5nIE5ld3RvbidzIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNfdHJpZyA9IGVxLmhhc1RyaWcoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBnZXQgYWxsIHRoZSBwb2ludHMgd2hlcmUgYSBwb3NzaWJsZSB6ZXJvIG1pZ2h0IGV4aXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMxID0gX18uZ2V0UG9pbnRzKGVxLCAwLjEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMyID0gX18uZ2V0UG9pbnRzKGVxLCAwLjA1KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRzMyA9IF9fLmdldFBvaW50cyhlcSwgMC4wMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IGNvcmUuVXRpbHMuYXJyYXlVbmlxdWUocG9pbnRzMS5jb25jYXQocG9pbnRzMikuY29uY2F0KHBvaW50czMpKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgcG9pbnQsIHNvbHV0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21waWxlIHRoZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gYnVpbGQoZXEuY2xvbmUoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRyeSB0byBlbGltaW5hdGUgc29tZSBwb2ludHMgdXNpbmcgYmlzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRfcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGlmIHRoZXJlJ3MgYSBzb2x1dGlvbiBhdCB0aGlzIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uID0gX18uYmlzZWN0aW9uKHBvaW50LCBmKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gc29sdXRpb24gdGhlbiBhZGQgaXQgdG8gdGhlIGFycmF5IGZvciBmdXJ0aGVyIGludmVzdGlnYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHNvbHV0aW9uID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdF9wb2ludHMucHVzaChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzb2x1dGlvbiB0byB0aGUgc29sdXRpb24gc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoc29sdXRpb24sIGhhc190cmlnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBwb2ludHMgdG8gdGhlIHJlbWFpbmluZyBwb2ludHNcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB0X3BvaW50cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIGRlcml2YXRpdmUgYW5kIGNvbXBpbGUgYSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gX0MuZGlmZihlcS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnAgPSBidWlsZChkKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KF9fLk5ld3Rvbihwb2ludCwgZiwgZnApLCBoYXNfdHJpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9ucy5zb3J0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vVGhlIGlkZWEgaGVyZSBpcyB0byBnbyB0aHJvdWdoIHRoZSBlcXVhdGlvbiBhbmQgY29sbGVjdCB0aGUgY29lZmZpY2llbnRzXHJcbiAgICAgICAgICAgIC8vcGxhY2UgdGhlbSBpbiBhbiBhcnJheSBhbmQgY2FsbCB0aGUgcXVhZCBvciBjdWJpYyBmdW5jdGlvbiB0byBnZXQgdGhlIHJlc3VsdHNcclxuICAgICAgICAgICAgaWYoIWVxLmhhc0Z1bmMoc29sdmVfZm9yKSAmJiBlcS5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JlZCA9IGNvcmUuQWxnZWJyYS5GYWN0b3IuZmFjdG9yKGVxLmNsb25lKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihmYWN0b3JlZC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yZWQuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChzb2x2ZSh4LCBzb2x2ZV9mb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29lZmZzID0gY29yZS5VdGlscy5nZXRDb2VmZnMoZXEsIHNvbHZlX2Zvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IGNvZWZmcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVnID0gbCAtIDE7IC8vdGhlIGRlZ3JlZSBvZiB0aGUgcG9seW5vbWlhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgZGVub21pbmF0b3IgYW5kIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IGhhdmUgeFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGUgdGhlIHByb2JsZW0gYmFzZWQgb24gdGhlIGRlZ3JlZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goZGVnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRlZCA9IHNlcGFyYXRlKGVxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGhzID0gc2VwYXJhdGVkWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmhzID0gc2VwYXJhdGVkWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxocy5ncm91cCA9PT0gY29yZS5ncm91cHMuRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfLnBhcnNlKGNvcmUuVXRpbHMuZm9ybWF0KGNvcmUuU2V0dGluZ3MuTE9HICsgJygoezB9KS8oezJ9KSkvJyArIGNvcmUuU2V0dGluZ3MuTE9HICsgJyh7MX0pJywgcmhzLCBsaHMudmFsdWUsIGxocy5tdWx0aXBsaWVyKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25vdGhpbmcgdG8gZG8gYnV0IHRvIHJldHVybiB0aGUgcXVvdGllbnQgb2YgdGhlIGNvbnN0YW50IGFuZCB0aGUgTFRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2UuZy4gMip4LTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KF8uZGl2aWRlKGNvZWZmc1swXSwgY29lZmZzWzFdLm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfXy5xdWFkLmFwcGx5KHVuZGVmaW5lZCwgY29lZmZzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfXy5jdWJpYy5hcHBseSh1bmRlZmluZWQsIGNvZWZmcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoX18ucXVhcnRpYy5hcHBseSh1bmRlZmluZWQsIGNvZWZmcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KF9fLmNzb2x2ZShlcSwgc29sdmVfZm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc29sdXRpb25zLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfXy5kaXZpZGVBbmRDb25xdWVyKGVxLCBzb2x2ZV9mb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc29sdXRpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnkgZmFjdG9yaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KHNvbHZlKGZhY3RvcmVkLCBzb2x2ZV9mb3IsIHNvbHV0aW9ucywgZGVwdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7IC8qc29tZXRoaW5nIHdlbnQgd3JvbmcuIEVYSVRJTkcqL1xyXG4gICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ3ID0gX18ucmV3cml0ZShlcSwgbnVsbCwgc29sdmVfZm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGhzID0gcndbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJocyA9IHJ3WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGxocy5ncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobGhzLmZuYW1lID09PSAnYWJzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChbcmhzLmNsb25lKCksIHJocy5uZWdhdGUoKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYobGhzLmZuYW1lID09PSAnc2luJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hc2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9fcmVzdWx0KF9fLmludmVyc2VGdW5jdGlvblNvbHZlKCdhc2luJywgbGhzLCByaHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGxocy5mbmFtZSA9PT0gJ2NvcycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXNpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfXy5pbnZlcnNlRnVuY3Rpb25Tb2x2ZSgnYWNvcycsIGxocywgcmhzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihsaHMuZm5hbWUgPT09ICd0YW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FzaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b19yZXN1bHQoX18uaW52ZXJzZUZ1bmN0aW9uU29sdmUoJ2F0YW4nLCBsaHMsIHJocykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYobGhzLmZuYW1lID09PSBjb3JlLlNldHRpbmdzLkxPRykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9heCtiIGNvbWVzIGJhY2sgYXMgW2EsIHgsIGF4LCBiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGV4cGxvZGUobGhzLmFyZ3NbMF0sIHNvbHZlX2Zvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHggaXMgYnkgaXRzZWxmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHBhcnRzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoeC5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJocyA9IF8uZGl2aWRlKF8uc3VidHJhY3QoXy5wb3cobGhzLmFyZ3MubGVuZ3RoID4gMSA/IGxocy5hcmdzWzFdIDogbmV3IFN5bWJvbCgnZScpLCBfLmRpdmlkZShyaHMsIF8ucGFyc2UobGhzLm11bHRpcGxpZXIpKSksIHBhcnRzWzNdKSwgcGFydHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcSA9IG5ldyBFcXVhdGlvbih4LCByaHMpLnRvTEhTKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChzb2x2ZShlcSwgc29sdmVfZm9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfLnN1YnRyYWN0KGxocywgcmhzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVxID0gbmV3IEVxdWF0aW9uKGxocywgcmhzKS50b0xIUygpOyAvL2NyZWF0ZSBhIG5ldyBlcXVhdGlvblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobmVxLmVxdWFscyhlcSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0b3BwaW5nLiBObyBzdG9wIGNvbmRpdGlvbiBleGlzdHMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChzb2x2ZShuZXEsIHNvbHZlX2ZvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9MZXQncyB0cnkgdGhpcyBhbm90aGVyIHdheVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vMS4gaWYgdGhlIHN5bWJvbCBpcyBpbiB0aGUgZm9ybSBhKmIqYyouLi4gdGhlbiB0aGUgc29sdXRpb24gaXMgemVybyBpZiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9laXRoZXIgYSBvciBiIG9yIGMgaXMgemVyby5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXEuZ3JvdXAgPT09IENCKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihlcS5ncm91cCA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXBhcmF0ZWQgPSBzZXBhcmF0ZShlcSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGhzID0gc2VwYXJhdGVkWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaHMgPSBzZXBhcmF0ZWRbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWR1Y2UgdGhlIGVxdWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsaHMuZ3JvdXAgPT09IGNvcmUuZ3JvdXBzLkVYICYmIGxocy52YWx1ZSA9PT0gc29sdmVfZm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2UgdGhlIGJhc2Ugb2YgYm90aCBzaWRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gbGhzLnBvd2VyLmNsb25lKCkuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkX3RvX3Jlc3VsdChfLnBvdyhyaHMsIHApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihjZmFjdCkge1xyXG4gICAgICAgICAgICBzb2x1dGlvbnMgPSBzb2x1dGlvbnMubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wb3coeCwgbmV3IFN5bWJvbChjZmFjdCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBlcmZvcm0gc29tZSBjbGVhbnVwIGJ1dCBkb24ndCBkbyBpdCBhZ2FpbnMgYXJyYXlzLCBldGNcclxuICAgICAgICAvLyBDaGVjayBpdCBhY3R1YWxseSBldmFsdWF0ZXMgdG8gemVyb1xyXG4gICAgICAgIGlmKGlzU3ltYm9sKGVxbnMpKSB7XHJcbiAgICAgICAgICAgIHZhciBrbm93bnMgPSB7fTtcclxuICAgICAgICAgICAgc29sdXRpb25zID0gc29sdXRpb25zLmZpbHRlcihmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBrbm93bnNbc29sdmVfZm9yXSA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHplcm8gPSBOdW1iZXIoZXZhbHVhdGUoZXFucywga25vd25zKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHN5bWJvbGljIGFuc3dlcnNcclxuICAgICAgICAgICAgICAgICAgICBpZihpc05hTih6ZXJvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzb2x1dGlvbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vUmVnaXN0ZXIgdGhlIGZ1bmN0aW9ucyBmb3IgZXh0ZXJuYWwgdXNlXHJcbiAgICBuZXJkYW1lci5yZWdpc3RlcihbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnc29sdmVFcXVhdGlvbnMnLFxyXG4gICAgICAgICAgICBwYXJlbnQ6ICduZXJkYW1lcicsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IC0xLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvbHZlOyAvL2NvbW1lbnQgb3V0IHRvIHJldHVybiBhIHZlY3RvclxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUuVXRpbHMuY29udmVydFRvVmVjdG9yKHNvbHZlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnc29sdmUnLFxyXG4gICAgICAgICAgICBwYXJlbnQ6ICdTb2x2ZScsXHJcbiAgICAgICAgICAgIG51bWFyZ3M6IDIsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZS5Tb2x2ZS5zb2x2ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBuYW1lOiAnc2V0RXF1YXRpb24nLFxyXG4gICAgICAgICAgICBwYXJlbnQ6ICdTb2x2ZScsXHJcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXHJcbiAgICAgICAgICAgIGJ1aWxkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0RXE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICBdKTtcclxuICAgIG5lcmRhbWVyLmFwaSgpO1xyXG59KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nerdamer/Solve.js\n");

/***/ }),

/***/ "./node_modules/nerdamer/nerdamer.core.js":
/*!************************************************!*\
  !*** ./node_modules/nerdamer/nerdamer.core.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global trig, trigh, Infinity, define, arguments2Array, NaN */\r\n//externals ====================================================================\r\n/* BigInterger.js v1.6.40 https://github.com/peterolson/BigInteger.js/blob/master/LICENSE */\r\n//var nerdamerBigInt = typeof nerdamerBigInt !== 'undefined' ? nerdamerBigInt : require(\"big-integer\");\r\n/* big.js v5.2.2 https://github.com/MikeMcl/big.js/LICENCE */\r\n//var nerdamerBigDecimal = typeof nerdamerBigDecimal !== 'undefined' ? nerdamerBigDecimal : require('big.js');\r\n\r\nvar nerdamer = (function (imports) {\r\n    \"use strict\";\r\n\r\n//version ======================================================================\r\n    var version = '1.1.12';\r\n\r\n//inits ========================================================================\r\n    var _ = new Parser(); //nerdamer's parser\r\n\r\n    //import bigInt\r\n    var bigInt = imports.bigInt;\r\n    var bigDec = imports.bigDec;\r\n\r\n    //set the precision to js precision\r\n    bigDec.set({\r\n        precision: 250\r\n    });\r\n\r\n    var Groups = {};\r\n\r\n    //container of pregenerated primes\r\n    var PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113\r\n                , 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251,\r\n        257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\r\n        401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557,\r\n        563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\r\n        709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\r\n        877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031,\r\n        1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171,\r\n        1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303,\r\n        1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471,\r\n        1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607,\r\n        1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753,\r\n        1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931,\r\n        1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083];\r\n\r\n//Settings =====================================================================\r\n    var CUSTOM_OPERATORS = {};\r\n\r\n    var Settings = {\r\n        //Enables/Disables call peekers. False means callPeekers are disabled and true means callPeekers are enabled.\r\n        callPeekers: false,\r\n\r\n        //the max number up to which to cache primes. Making this too high causes performance issues\r\n        init_primes: 1000,\r\n\r\n        exclude: [],\r\n        //If you don't care about division by zero for example then this can be set to true.\r\n        //Has some nasty side effects so choose carefully.\r\n        suppress_errors: false,\r\n        //the global used to invoke the libary to parse to a number. Normally cos(9) for example returns\r\n        //cos(9) for convenience but parse to number will always try to return a number if set to true.\r\n        PARSE2NUMBER: false,\r\n        //this flag forces the a clone to be returned when add, subtract, etc... is called\r\n        SAFE: false,\r\n        //the symbol to use for imaginary symbols\r\n        IMAGINARY: 'i',\r\n        //the modules used to link numeric function holders\r\n        FUNCTION_MODULES: [Math],\r\n        //Allow certain characters\r\n        ALLOW_CHARS: [''],\r\n        //Allow nerdamer to convert multi-character variables\r\n        USE_MULTICHARACTER_VARS: true,\r\n        //Allow changing of power operator\r\n        POWER_OPERATOR: '^',\r\n        //The variable validation regex\r\n        //VALIDATION_REGEX: /^[a-z_][a-z\\d\\_]*$/i\r\n        VALIDATION_REGEX: /^[a-z_ABEZHIKMNoOPTX][0-9a-z_ABEZHIKMNoOPTX]*$/i,\r\n        // The regex used to determine which characters should be included in implied multiplication\r\n        IMPLIED_MULTIPLICATION_REGEX: /([\\+\\-\\/\\*]*[0-9]+)([a-z_ABEZHIKMNoOPTX]+[\\+\\-\\/\\*]*)/gi,\r\n        //Aliases\r\n        ALIASES: {\r\n            '': 'pi',\r\n            '': 'Infinity'\r\n        },\r\n        POSITIVE_MULTIPLIERS: false,\r\n        //Cached items\r\n        CACHE: {},\r\n        //Print out warnings or not\r\n        SILENCE_WARNINGS: false,\r\n        //Precision\r\n        PRECISION: 21,\r\n        //function mappings\r\n        VECTOR: 'vector',\r\n        PARENTHESIS: 'parens',\r\n        SQRT: 'sqrt',\r\n        ABS: 'abs',\r\n        FACTORIAL: 'factorial',\r\n        DOUBLEFACTORIAL: 'dfactorial',\r\n        //reference pi and e\r\n        LONG_PI: '3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214' +\r\n                '808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196',\r\n        LONG_E: '2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466' +\r\n                '39193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901',\r\n        PI: Math.PI,\r\n        E: Math.E,\r\n        LOG: 'log',\r\n        LOG10: 'log10',\r\n        LOG10_LATEX: 'log_{10}',\r\n        MAX_EXP: 200000,\r\n        //The number of scientific place to round to\r\n        SCIENTIFIC_MAX_DECIMAL_PLACES: 14,\r\n        //True if ints should not be converted to\r\n        SCIENTIFIC_IGNORE_ZERO_EXPONENTS: true\r\n    };\r\n\r\n    (function () {\r\n        Settings.CACHE.roots = {};\r\n        var x = 40,\r\n                y = 40;\r\n        for(var i = 2; i <= x; i++) {\r\n            for(var j = 2; j <= y; j++) {\r\n                var nthpow = bigInt(i).pow(j);\r\n                Settings.CACHE.roots[nthpow + '-' + j] = i;\r\n            }\r\n        }\r\n    })();\r\n\r\n    //Add the groups. These have been reorganized as of v0.5.1 to make CP the highest group\r\n    //The groups that help with organizing during parsing. Note that for FN is still a function even\r\n    //when it's raised to a symbol, which typically results in an EX\r\n    var N = Groups.N = 1, // A number\r\n            P = Groups.P = 2, // A number with a rational power e.g. 2^(3/5).\r\n            S = Groups.S = 3, // A single variable e.g. x.\r\n            EX = Groups.EX = 4, // An exponential\r\n            FN = Groups.FN = 5, // A function\r\n            PL = Groups.PL = 6, // A symbol/expression having same name with different powers e.g. 1/x + x^2\r\n            CB = Groups.CB = 7, // A symbol/expression composed of one or more variables through multiplication e.g. x*y\r\n            CP = Groups.CP = 8; // A symbol/expression composed of one variable and any other symbol or number x+1 or x+y\r\n\r\n    var CONST_HASH = Settings.CONST_HASH = '#';\r\n\r\n    var PARENTHESIS = Settings.PARENTHESIS;\r\n\r\n    var SQRT = Settings.SQRT;\r\n\r\n    var ABS = Settings.ABS;\r\n\r\n    var FACTORIAL = Settings.FACTORIAL;\r\n\r\n    var DOUBLEFACTORIAL = Settings.DOUBLEFACTORIAL;\r\n\r\n    //the storage container \"memory\" for parsed expressions\r\n    var EXPRESSIONS = [];\r\n\r\n    //variables\r\n    var VARS = {};\r\n\r\n    //the container used to store all the reserved functions\r\n    var RESERVED = [];\r\n\r\n    var WARNINGS = [];\r\n\r\n    /**\r\n     * Use this when errors are suppressible\r\n     * @param {String} msg\r\n     * @param {object} ErrorObj\r\n     */\r\n    var err = function (msg, ErrorObj) {\r\n        if(!Settings.suppress_errors) {\r\n            if(ErrorObj)\r\n                throw new ErrorObj(msg);\r\n            else\r\n                throw new Error(msg);\r\n        }\r\n    };\r\n\r\n//Utils ========================================================================\r\n    var customError = function (name) {\r\n        var E = function (message) {\r\n            this.name = name;\r\n            this.message = message !== undefined ? message : '';\r\n            var error = new Error(this.message);\r\n            error.name = this.name;\r\n            this.stack = error.stack;\r\n        }; //create an empty error\r\n        E.prototype = Object.create(Error.prototype);\r\n        return E;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if value is one of nerdamer's reserved names\r\n     * @param {String} value\r\n     * @return boolean\r\n     */\r\n    var isReserved = function (value) {\r\n        return RESERVED.indexOf(value) !== -1;\r\n    };\r\n\r\n    /**\r\n     * Checks to see that all symbols in array are the same\r\n     * @param {Symbol[]} arr\r\n     * @returns {bool}\r\n     */\r\n    var allSame = function (arr) {\r\n        var last = arr[0];\r\n        for(var i = 1, l = arr.length; i < l; i++)\r\n            if(!arr[i].equals(last))\r\n                return false;\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Used to pass warnings or low severity errors about the library\r\n     * @param msg\r\n     */\r\n    var warn = function (msg) {\r\n        WARNINGS.push(msg);\r\n        if(Settings.SHOW_WARNINGS && console && console.warn) {\r\n            console.warn(msg);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Enforces rule: \"must start with a letter or underscore and\r\n     * can have any number of underscores, letters, and numbers thereafter.\"\r\n     * @param name The name of the symbol being checked\r\n     * @param {String} typ - The type of symbols that's being validated\r\n     * @throws {Exception}  - Throws an exception on fail\r\n     */\r\n    var validateName = function (name, typ) {\r\n        typ = typ || 'variable';\r\n        if(Settings.ALLOW_CHARS.indexOf(name) !== -1)\r\n            return;\r\n        var regex = Settings.VALIDATION_REGEX;\r\n        if(!(regex.test(name))) {\r\n            throw new InvalidVariableNameError(name + ' is not a valid ' + typ + ' name');\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Convert number from scientific format to decimal format\r\n     * @param {Number} num\r\n     */\r\n    var scientificToDecimal = function (num) {\r\n        var nsign = Math.sign(num);\r\n        //remove the sign\r\n        num = Math.abs(num);\r\n        //if the number is in scientific notation remove it\r\n        if(/\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num)) {\r\n            var zero = '0',\r\n                    parts = String(num).toLowerCase().split('e'), //split into coeff and exponent\r\n                    e = parts.pop(), //store the exponential part\r\n                    l = Math.abs(e), //get the number of zeros\r\n                    sign = e / l,\r\n                    coeff_array = parts[0].split('.');\r\n            if(sign === -1) {\r\n                l = l - coeff_array[0].length;\r\n                if(l < 0) {\r\n                    num = coeff_array[0].slice(0, l) + '.' + coeff_array[0].slice(l) + (coeff_array.length === 2 ? coeff_array[1] : '');\r\n                }\r\n                else {\r\n                    num = zero + '.' + new Array(l + 1).join(zero) + coeff_array.join('');\r\n                }\r\n            }\r\n            else {\r\n                var dec = coeff_array[1];\r\n                if(dec)\r\n                    l = l - dec.length;\r\n                if(l < 0) {\r\n                    num = coeff_array[0] + dec.slice(0, l) + '.' + dec.slice(l);\r\n                }\r\n                else {\r\n                    num = coeff_array.join('') + new Array(l + 1).join(zero);\r\n                }\r\n            }\r\n        }\r\n\r\n        return nsign < 0 ? '-' + num : num;\r\n    };\r\n    /**\r\n     * Checks if number is a prime number\r\n     * @param {Number} n - the number to be checked\r\n     */\r\n    var isPrime = function (n) {\r\n        var q = Math.floor(Math.sqrt(n));\r\n        for(var i = 2; i <= q; i++) {\r\n            if(n % i === 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Generates an object with known variable value for evaluation\r\n     * @param {String} variable\r\n     * @param {any} value Any stringifyable object\r\n     * @returns {Object} \r\n     */\r\n    var knownVariable = function (variable, value) {\r\n        var o = {};\r\n        o[variable] = value;\r\n        return o;\r\n    };\r\n\r\n    /**\r\n     * Checks if n is a number\r\n     * @param {any} n\r\n     */\r\n    var isNumber = function (n) {\r\n        return /^\\d+\\.?\\d*$/.test(n);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if an array contains only numeric values\r\n     * @param {Array} arr\r\n     */\r\n    var allNumeric = function (arr) {\r\n        for(var i = 0; i < arr.length; i++)\r\n            if(!isNumber(arr[i]))\r\n                return false;\r\n        return true;\r\n    };\r\n    /**\r\n     * Checks to see if a number or Symbol is a fraction\r\n     * @param {Number|Symbol} num\r\n     * @returns {boolean}\r\n     */\r\n    var isFraction = function (num) {\r\n        if(isSymbol(num))\r\n            return isFraction(num.multiplier.toDecimal());\r\n        return (num % 1 !== 0);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the object provided is a Symbol\r\n     * @param {Object} obj\r\n     */\r\n    var isSymbol = function (obj) {\r\n        return (obj instanceof Symbol);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the object provided is an Expression\r\n     * @param {Object} obj\r\n     */\r\n    var isExpression = function (obj) {\r\n        return (obj instanceof Expression);\r\n    };\r\n\r\n    /**\r\n     * This method traverses the symbol structure and grabs all the variables in a symbol. The variable\r\n     * names are then returned in alphabetical order.\r\n     * @param {Symbol} obj\r\n     * @param {Boolean} poly\r\n     * @param {Object} vars - An object containing the variables. Do not pass this in as it generated\r\n     * automatically. In the future this will be a Collector object.\r\n     * @returns {String[]} - An array containing variable names\r\n     */\r\n    var variables = function (obj, poly, vars) {\r\n        vars = vars || {\r\n            c: [],\r\n            add: function (value) {\r\n                if(this.c.indexOf(value) === -1 && isNaN(value))\r\n                    this.c.push(value);\r\n            }\r\n        };\r\n\r\n        if(isSymbol(obj)) {\r\n            var group = obj.group,\r\n                    prevgroup = obj.previousGroup;\r\n            if(group === EX)\r\n                variables(obj.power, poly, vars);\r\n\r\n            if(group === CP || group === CB || prevgroup === CP || prevgroup === CB) {\r\n                for(var x in obj.symbols) {\r\n                    variables(obj.symbols[x], poly, vars);\r\n                }\r\n            }\r\n            else if(group === S || prevgroup === S) {\r\n                //very crude needs fixing. TODO\r\n                if(!(obj.value === 'e' || obj.value === 'pi' || obj.value === Settings.IMAGINARY))\r\n                    vars.add(obj.value);\r\n            }\r\n            else if(group === PL || prevgroup === PL) {\r\n                variables(firstObject(obj.symbols), poly, vars);\r\n            }\r\n            else if(group === EX) {\r\n                if(!isNaN(obj.value))\r\n                    vars.add(obj.value);\r\n                variables(obj.power, poly, vars);\r\n            }\r\n            else if(group === FN && !poly) {\r\n                for(var i = 0; i < obj.args.length; i++) {\r\n                    variables(obj.args[i], poly, vars);\r\n                }\r\n            }\r\n        }\r\n\r\n        return vars.c.sort();\r\n    };\r\n\r\n    /**\r\n     * Returns the sum of an array\r\n     * @param {Array} arr\r\n     * @param {boolean} toNumber\r\n     * @returns {Symbol}\r\n     */\r\n    var arraySum = function (arr, toNumber) {\r\n        var sum = new Symbol(0);\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var x = arr[i];\r\n            // Convert to symbol if not\r\n            sum = _.add(sum, !isSymbol(x) ? _.parse(x) : x);\r\n        }\r\n\r\n        return toNumber ? Number(sum) : sum;\r\n    };\r\n\r\n    /**\r\n     * Separates out the variables into terms of variabls.\r\n     * e.g. x+y+x*y+sqrt(2)+pi returns\r\n     * {x: x, y: y, x y: x*y, constants: sqrt(2)+pi\r\n     * @param {type} symbol\r\n     * @param {type} o\r\n     * @returns {undefined}\r\n     * @throws {Error} for expontentials\r\n     */\r\n    var separate = function (symbol, o) {\r\n        symbol = _.expand(symbol);\r\n        o = o || {};\r\n        var insert = function (key, sym) {\r\n            if(!o[key])\r\n                o[key] = new Symbol(0);\r\n            o[key] = _.add(o[key], sym.clone());\r\n        };\r\n        symbol.each(function (x) {\r\n            if(x.isConstant('all')) {\r\n                insert('constants', x);\r\n            }\r\n            else if(x.group === S) {\r\n                insert(x.value, x);\r\n            }\r\n            else if(x.group === FN && (x.fname === ABS || x.fname === '')) {\r\n                separate(x.args[0]);\r\n            }\r\n            else if(x.group === EX || x.group === FN) {\r\n                throw new Error('Unable to separate. Term cannot be a function!');\r\n            }\r\n            else {\r\n                insert(variables(x).join(' '), x);\r\n            }\r\n        });\r\n\r\n        return o;\r\n    };\r\n\r\n    /**\r\n     * Fills holes in an array with zero symbol or generates one with n zeroes\r\n     * @param {Array} arr\r\n     * @param {Number} n\r\n     */\r\n    var fillHoles = function (arr, n) {\r\n        n = n || arr.length;\r\n        for(var i = 0; i < n; i++) {\r\n            var sym = arr[i];\r\n            if(!sym)\r\n                arr[i] = new Symbol(0);\r\n        }\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * Checks to see if the object provided is a Vector\r\n     * @param {Object} obj\r\n     */\r\n    var isVector = function (obj) {\r\n        return (obj instanceof Vector);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the object provided is a Matrix\r\n     * @param {Object} obj\r\n     */\r\n    var isMatrix = function (obj) {\r\n        return (obj instanceof Matrix);\r\n    };\r\n\r\n    var isSet = function (obj) {\r\n        return (obj instanceof Set);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a symbol is in group N\r\n     * @param {Symbol} symbol\r\n     */\r\n    var isNumericSymbol = function (symbol) {\r\n        return symbol.group === N || symbol.group === P;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a symbol is a variable with no multiplier nor power\r\n     * @param {Symbol} symbol\r\n     */\r\n    var isVariableSymbol = function (symbol) {\r\n        return symbol.group === S && symbol.multiplier.equals(1) && symbol.power.equals(1);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if the object provided is an Array\r\n     * @param {Object} arr\r\n     */\r\n    var isArray = function (arr) {\r\n        return Array.isArray(arr);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a number is an integer\r\n     * @param {Number} num\r\n     */\r\n    var isInt = function (num) {\r\n        return /^[-+]?\\d+e?\\+?\\d*$/gim.test(num.toString());\r\n    };\r\n\r\n    /**\r\n     * @param {Number|Symbol} obj\r\n     * @returns {boolean}\r\n     */\r\n    var isNegative = function (obj) {\r\n        if(isSymbol(obj)) {\r\n            obj = obj.multiplier;\r\n        }\r\n        return obj.lessThan(0);\r\n    };\r\n    /**\r\n     * Safely stringify object\r\n     * @param o\r\n     */\r\n    var stringify = function (o) {\r\n        if(!o)\r\n            return o;\r\n        return String(o);\r\n    };\r\n\r\n    /**\r\n     * @param {String} str\r\n     * @returns {String} - returns a formatted string surrounded by brackets\r\n     */\r\n    var inBrackets = function (str) {\r\n        return '(' + str + ')';\r\n    };\r\n\r\n    /**\r\n     * A helper function to replace parts of string\r\n     * @param {String} str - The original string\r\n     * @param {Integer} from - The starting index\r\n     * @param {Integer} to - The ending index\r\n     * @param {String} with_str - The replacement string\r\n     * @returns {String} - A formatted string\r\n     */\r\n    var stringReplace = function (str, from, to, with_str) {\r\n        return str.substr(0, from) + with_str + str.substr(to, str.length);\r\n    };\r\n\r\n    /**\r\n     * the Parser uses this to check if it's allowed to convert the obj to type Symbol\r\n     * @param {Object} obj\r\n     * @returns {boolean}\r\n     */\r\n    var customType = function (obj) {\r\n        return obj !== undefined && obj.custom;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if numbers are both negative or are both positive\r\n     * @param {Number} a\r\n     * @param {Number} b\r\n     * @returns {boolean}\r\n     */\r\n    var sameSign = function (a, b) {\r\n        return (a < 0) === (b < 0);\r\n    };\r\n\r\n    /**\r\n     * A helper function to replace multiple occurences in a string. Takes multiple arguments\r\n     * @example format('{0} nice, {0} sweet', 'something')\r\n     * //returns 'something nice, something sweet'\r\n     */\r\n    var format = function () {\r\n        var args = [].slice.call(arguments),\r\n                str = args.shift();\r\n        var new_str = str.replace(/{(\\d+)}/g, function (match, index) {\r\n            var arg = args[index];\r\n            return typeof arg === 'function' ? arg() : arg;\r\n        });\r\n\r\n        return new_str;\r\n    };\r\n\r\n    /**\r\n     * Generates an array with values within a range. Multiplies by a step if provided\r\n     * @param {Number} start\r\n     * @param {Number} end\r\n     * @param {Number} step\r\n     */\r\n    var range = function (start, end, step) {\r\n        var arr = [];\r\n        step = step || 1;\r\n        for(var i = start; i <= end; i++)\r\n            arr.push(i * step);\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * Returns an array of all the keys in an array\r\n     * @param {Object} obj\r\n     * @returns {Array}\r\n     */\r\n    var keys = Object.keys;\r\n\r\n    /**\r\n     * Returns the first encountered item in an object. Items do not have a fixed order in objects\r\n     * so only use if you need any first random or if there's only one item in the object\r\n     * @param {Object} obj\r\n     * @param {String} key Return this key as first object\r\n     * @param {Boolean} both\r\n     * @returns {*}\r\n     */\r\n    var firstObject = function (obj, key, both) {\r\n        for(var x in obj)\r\n            break;\r\n        if(key)\r\n            return x;\r\n        if(both)\r\n            return {\r\n                key: x,\r\n                obj: obj[x]\r\n            };\r\n        return obj[x];\r\n    };\r\n\r\n    /**\r\n     * Substitutes out variables for two symbols, parses them to a number and them compares them numerically\r\n     * @param {Symbol} sym1\r\n     * @param {Symbol} sym2\r\n     * @param {String[]} vars - an optional array of variables to use\r\n     * @returns {bool}\r\n     */\r\n    var compare = function (sym1, sym2, vars) {\r\n        var n = 5; //a random number between 1 and 5 is good enough\r\n        var scope = {}; // scope object with random numbers generated using vars\r\n        var comparison;\r\n        for(var i = 0; i < vars.length; i++)\r\n            scope[vars[i]] = new Symbol(Math.floor(Math.random() * n) + 1);\r\n        block('PARSE2NUMBER', function () {\r\n            comparison = _.parse(sym1, scope).equals(_.parse(sym2, scope));\r\n        });\r\n        return comparison;\r\n    };\r\n\r\n    /**\r\n     * Is used to set a user defined function using the function assign operator\r\n     * @param {String} name\r\n     * @param {String[]} params_array\r\n     * @param {String} body\r\n     * @returns {Boolean}\r\n     */\r\n    var setFunction = function (name, params_array, body) {\r\n        validateName(name);\r\n        if(!isReserved(name)) {\r\n            params_array = params_array || variables(_.parse(body));\r\n            // The function gets set to PARSER.mapped function which is just\r\n            // a generic function call.\r\n            _.functions[name] = [_.mapped_function, params_array.length, {\r\n                    name: name,\r\n                    params: params_array,\r\n                    body: body\r\n                }];\r\n\r\n            return body;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Returns the minimum number in an array\r\n     * @param {Array} arr\r\n     * @returns {Number}\r\n     */\r\n    var arrayMax = function (arr) {\r\n        return Math.max.apply(undefined, arr);\r\n    };\r\n\r\n    /**\r\n     * Returns the maximum number in an array\r\n     * @param {Array} arr\r\n     * @returns {Number}\r\n     */\r\n    var arrayMin = function (arr) {\r\n        return Math.min.apply(undefined, arr);\r\n    };\r\n\r\n    /**\r\n     * Checks to see if two arrays are equal\r\n     * @param {Array} arr1 \r\n     * @param {Array} arr2 \r\n     */\r\n    var arrayEqual = function (arr1, arr2) {\r\n        arr1.sort();\r\n        arr2.sort();\r\n\r\n        // The must be of the same length\r\n        if(arr1.length === arr2.length) {\r\n            for(var i = 0; i < arr1.length; i++) {\r\n                // If any two items don't match we're done\r\n                if(arr1[i] !== arr2[i]) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Otherwise they're equal\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Clones array with clonable items\r\n     * @param {Array} arr\r\n     * @returns {Array}\r\n     */\r\n    var arrayClone = function (arr) {\r\n        var new_array = [], l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            new_array[i] = arr[i].clone();\r\n        return new_array;\r\n    };\r\n\r\n    /**\r\n     * Fills numbers between array values\r\n     * @param {Numbers[]} arr\r\n     * @param {Integer} slices\r\n     */\r\n    var arrayAddSlices = function (arr, slices) {\r\n        slices = slices || 20;\r\n        var retval = [];\r\n        var c, delta, e;\r\n        retval.push(arr[0]); //push the beginning\r\n        for(var i = 0; i < arr.length - 1; i++) {\r\n            c = arr[i];\r\n            delta = arr[i + 1] - c; //get the difference\r\n            e = delta / slices; //chop it up in the desired number of slices\r\n            for(var j = 0; j < slices; j++) {\r\n                c += e; //add the mesh to the last slice\r\n                retval.push(c);\r\n            }\r\n        }\r\n\r\n        return retval;\r\n    };\r\n\r\n    /**\r\n     * Gets nth roots of a number\r\n     * @param {Symbol} symbol\r\n     * @returns {Vector}\r\n     */\r\n    var nroots = function (symbol) {\r\n        var a, b;\r\n\r\n        if(symbol.group === FN && symbol.fname === '') {\r\n            a = Symbol.unwrapPARENS(_.parse(symbol).toLinear());\r\n            b = _.parse(symbol.power);\r\n        }\r\n        else if(symbol.group === P) {\r\n            a = _.parse(symbol.value);\r\n            b = _.parse(symbol.power);\r\n        }\r\n\r\n        if(a && b && (a.group === N) && b.group === N && a.multiplier.isNegative()) {\r\n            var _roots = [];\r\n\r\n            var parts = Symbol.toPolarFormArray(evaluate(symbol));\r\n            var r = parts[0];\r\n\r\n            //var r = _.parse(a).abs().toString();\r\n\r\n            //https://en.wikipedia.org/wiki/De_Moivre%27s_formula\r\n            var x = _.arg(a);\r\n            var n = b.multiplier.den.toString();\r\n            var p = b.multiplier.num.toString();\r\n\r\n            var formula = '(({0})^({1})*(cos({3})+({2})*sin({3})))^({4})';\r\n\r\n            for(var i = 0; i < n; i++) {\r\n                var t = evaluate(_.parse(format(\"(({0})+2*pi*({1}))/({2})\", x, i, n))).multiplier.toDecimal();\r\n                _roots.push(evaluate(_.parse(format(formula, r, n, Settings.IMAGINARY, t, p))));\r\n            }\r\n            return Vector.fromArray(_roots);\r\n        }\r\n        else if(symbol.isConstant(true, true)) {\r\n            var sign = symbol.sign();\r\n            var x = evaluate(symbol.abs());\r\n            var root = _.sqrt(x);\r\n\r\n            var _roots = [root.clone(), root.negate()];\r\n\r\n            if(sign < 0)\r\n                _roots = _roots.map(function (x) {\r\n                    return _.multiply(x, Symbol.imaginary());\r\n                });\r\n\r\n        }\r\n        else {\r\n            _roots = [_.parse(symbol)];\r\n        }\r\n\r\n        return Vector.fromArray(_roots);\r\n    };\r\n\r\n    /**\r\n     * Sorts and array given 2 parameters\r\n     * @param {String} a\r\n     * @param {String} b\r\n     */\r\n    var comboSort = function (a, b) {\r\n        var l = a.length,\r\n                combined = []; //the linker\r\n        for(var i = 0; i < a.length; i++) {\r\n            combined.push([a[i], b[i]]); //create the map\r\n        }\r\n\r\n        combined.sort(function (x, y) {\r\n            return x[0] - y[0];\r\n        });\r\n\r\n        var na = [], nb = [];\r\n\r\n        for(i = 0; i < l; i++) {\r\n            na.push(combined[i][0]);\r\n            nb.push(combined[i][1]);\r\n        }\r\n\r\n        return [na, nb];\r\n    };\r\n    /**\r\n     * TODO: Pick a more descriptive name and better description\r\n     * Breaks a function down into it's parts wrt to a variable, mainly coefficients\r\n     * Example a*x^2+b wrt x\r\n     * @param {Symbol} fn\r\n     * @param {String} wrt\r\n     * @param {bool} as_obj\r\n     */\r\n    var decompose_fn = function (fn, wrt, as_obj) {\r\n        wrt = String(wrt); //convert to string\r\n        var ax, a, x, b;\r\n        if(fn.group === CP) {\r\n            var t = _.expand(fn.clone()).stripVar(wrt);\r\n            ax = _.subtract(fn.clone(), t.clone());\r\n            b = t;\r\n        }\r\n        else\r\n            ax = fn.clone();\r\n        a = ax.stripVar(wrt);\r\n        x = _.divide(ax.clone(), a.clone());\r\n        b = b || new Symbol(0);\r\n        if(as_obj)\r\n            return {\r\n                a: a,\r\n                x: x,\r\n                ax: ax,\r\n                b: b\r\n            };\r\n        return [a, x, ax, b];\r\n    };\r\n    /**\r\n     * Rounds a number up to x decimal places\r\n     * @param {Number} x\r\n     * @param {Number} s\r\n     */\r\n    var nround = function (x, s) {\r\n        if(isInt(x)) {\r\n            if(x >= Number.MAX_VALUE)\r\n                return x.toString();\r\n            return Number(x);\r\n        }\r\n\r\n        s = typeof s === 'undefined' ? 14 : s;\r\n        return Math.round(x * Math.pow(10, s)) / Math.pow(10, s);\r\n    };\r\n\r\n    /**\r\n     * Is used for u-substitution. Gets a suitable u for substitution. If for\r\n     * instance a is used in the symbol then it keeps going down the line until\r\n     * one is found that's not in use. If all letters are taken then it\r\n     * starts appending numbers.\r\n     * IMPORTANT! It assumes that the substitution will be undone\r\n     * beore the user gets to interact with the object again.\r\n     * @param {Symbol} symbol\r\n     */\r\n    var getU = function (symbol) {\r\n        //start with u\r\n        var u = 'u', //start with u\r\n                v = u, //init with u\r\n                c = 0, //postfix number\r\n                vars = variables(symbol);\r\n        //make sure this variable isn't reserved and isn't in the variable list\r\n        while(!(RESERVED.indexOf(v) === - 1 && vars.indexOf(v) === - 1))\r\n            v = u + c++;\r\n        //get an empty slot. It seems easier to just push but the\r\n        //problem is that we may have some which are created by clearU\r\n        for(var i = 0, l = RESERVED.length; i <= l; i++)\r\n            //reserved cannot equals false or 0 so we can safely check for a falsy type\r\n            if(!RESERVED[i]) {\r\n                RESERVED[i] = v; //reserve the variable\r\n                break;\r\n            }\r\n        return v;\r\n    };\r\n\r\n    /**\r\n     * Clears the u variable so it's no longer reserved\r\n     * @param {String} u\r\n     */\r\n    var clearU = function (u) {\r\n        var indx = RESERVED.indexOf(u);\r\n        if(indx !== -1)\r\n            RESERVED[indx] = undefined;\r\n    };\r\n\r\n    /**\r\n     * Loops through each item in object and calls function with item as param\r\n     * @param {Object|Array} obj\r\n     * @param {Function} fn\r\n     */\r\n    var each = function (obj, fn) {\r\n        if(isArray(obj)) {\r\n            var l = obj.length;\r\n            for(var i = 0; i < l; i++)\r\n                fn.call(obj, i);\r\n        }\r\n        else {\r\n            for(var x in obj)\r\n                if(obj.hasOwnProperty(x))\r\n                    fn.call(obj, x);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a number is an even number\r\n     * @param {Number} num\r\n     * @returns {boolean}\r\n     */\r\n    var even = function (num) {\r\n        return num % 2 === 0;\r\n    };\r\n\r\n    /**\r\n     * Checks to see if a fraction is divisible by 2\r\n     * @param {Number} num\r\n     * @returns {boolean}\r\n     */\r\n    var evenFraction = function (num) {\r\n        return 1 / (num % 1) % 2 === 0;\r\n    };\r\n\r\n    /**\r\n     * Strips duplicates out of an array\r\n     * @param {Array} arr\r\n     */\r\n    var arrayUnique = function (arr) {\r\n        var l = arr.length, a = [];\r\n        for(var i = 0; i < l; i++) {\r\n            var item = arr[i];\r\n            if(a.indexOf(item) === -1)\r\n                a.push(item);\r\n        }\r\n        return a;\r\n    };\r\n\r\n    /**\r\n     * Gets all the variables in an array of Symbols\r\n     * @param {Symbol[]} arr \r\n     */\r\n    var arrayGetVariables = function (arr) {\r\n        var vars = variables(arr[0], null, null, true);\r\n\r\n        //get all variables\r\n        for(var i = 1, l = arr.length; i < l; i++)\r\n            vars = vars.concat(variables(arr[i]));\r\n        //remove duplicates\r\n        vars = arrayUnique(vars).sort();\r\n\r\n        //done\r\n        return vars;\r\n    };\r\n\r\n    /**\r\n     * Removes duplicates from an array. Returns a new array\r\n     * @param {Array} arr\r\n     * @param {Function} condition\r\n     */\r\n    var removeDuplicates = function (arr, condition) {\r\n        var conditionType = typeof condition;\r\n\r\n        if(conditionType !== 'function' || conditionType === 'undefined') {\r\n            condition = function (a, b) {\r\n                return a === b;\r\n            };\r\n        }\r\n\r\n        var seen = [];\r\n\r\n        while(arr.length) {\r\n            var a = arr[0];\r\n            //only one element left so we're done\r\n            if(arr.length === 1) {\r\n                seen.push(a);\r\n                break;\r\n            }\r\n            var temp = [];\r\n            seen.push(a); //we already scanned these\r\n            for(var i = 1; i < arr.length; i++) {\r\n                var b = arr[i];\r\n                //if the number is outside the specified tolerance\r\n                if(!condition(a, b))\r\n                    temp.push(b);\r\n            }\r\n            //start over with the remainder\r\n            arr = temp;\r\n        }\r\n\r\n        return seen;\r\n    };\r\n\r\n    /**\r\n     * Reserves the names in an object so they cannot be used as function names\r\n     * @param {Object} obj\r\n     */\r\n    var reserveNames = function (obj) {\r\n        var add = function (item) {\r\n            if(RESERVED.indexOf(item) === -1)\r\n                RESERVED.push(item);\r\n        };\r\n\r\n        if(typeof obj === 'string')\r\n            add(obj);\r\n        else {\r\n            each(obj, function (x) {\r\n                add(x);\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Removes an item from either an array or an object. If the object is an array, the index must be\r\n     * specified after the array. If it's an object then the key must be specified\r\n     * @param {Object|Array} obj\r\n     * @param {Integer} indexOrKey\r\n     */\r\n    var remove = function (obj, indexOrKey) {\r\n        var result;\r\n        if(isArray(obj)) {\r\n            result = obj.splice(indexOrKey, 1)[0];\r\n        }\r\n        else {\r\n            result = obj[indexOrKey];\r\n            delete obj[indexOrKey];\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Creates a temporary block in which one of the global settings is temporarily modified while\r\n     * the function is called. For instance if you want to parse directly to a number rather than have a symbolic\r\n     * answer for a period you would set PARSE2NUMBER to true in the block.\r\n     * @example block('PARSE2NUMBER', function(){//symbol being parsed to number}, true);\r\n     * @param {String} setting - The setting being accessed\r\n     * @param {Function} f\r\n     * @param {boolean} opt - The value of the setting in the block\r\n     * @param {String} obj - The obj of interest. Usually a Symbol but could be any object\r\n     */\r\n    var block = function (setting, f, opt, obj) {\r\n        var current_setting = Settings[setting];\r\n        Settings[setting] = opt === undefined ? true : !!opt;\r\n        var retval = f.call(obj);\r\n        Settings[setting] = current_setting;\r\n        return retval;\r\n    };\r\n\r\n    /**\r\n     * provide a mechanism for accessing functions directly. Not yet complete!!!\r\n     * Some functions will return undefined. This can maybe just remove the\r\n     * function object at some point when all functions are eventually\r\n     * housed in the global function object. Returns ALL parser available\r\n     * functions. Parser.functions may not contain all functions\r\n     */\r\n    var importFunctions = function () {\r\n        var o = {};\r\n        for(var x in _.functions)\r\n            o[x] = _.functions[x][0];\r\n        return o;\r\n    };\r\n\r\n    /**\r\n     * Converts function arguments to an array. Now used by gcd and lcm in Algebra.js :)\r\n     * @param {Array|object} obj\r\n     */\r\n    var arguments2Array = function (obj) {\r\n        return [].slice.call(obj);\r\n    };\r\n\r\n    /**\r\n     * Returns the coefficients of a symbol given a variable. Given ax^2+b^x+c, it divides\r\n     * each nth term by x^n.\r\n     * @param {Symbol} symbol\r\n     * @param {Symbol} wrt\r\n     */\r\n    var getCoeffs = function (symbol, wrt, info) {\r\n        var coeffs = [];\r\n        //we loop through the symbols and stick them in their respective\r\n        //containers e.g. y*x^2 goes to index 2\r\n        symbol.each(function (term) {\r\n            if(term.contains(wrt)) {\r\n                //we want only the coefficient which in this case will be everything but the variable\r\n                //e.g. a*b*x -> a*b if the variable to solve for is x\r\n                var coeff = term.stripVar(wrt),\r\n                        x = _.divide(term.clone(), coeff.clone()),\r\n                        p = x.power.toDecimal();\r\n            }\r\n            else {\r\n                coeff = term;\r\n                p = 0;\r\n            }\r\n            var e = coeffs[p];\r\n            //if it exists just add it to it\r\n            coeffs[p] = e ? _.add(e, coeff) : coeff;\r\n\r\n        }, true);\r\n\r\n        for(var i = 0; i < coeffs.length; i++)\r\n            if(!coeffs[i])\r\n                coeffs[i] = new Symbol(0);\r\n        //fill the holes\r\n        return coeffs;\r\n    };\r\n\r\n    /**\r\n     * As the name states. It forces evaluation of the expression\r\n     * @param {Symbol} symbol\r\n     * @param {Symbol} o\r\n     */\r\n    var evaluate = function (symbol, o) {\r\n        return block('PARSE2NUMBER', function () {\r\n            return _.parse(symbol, o);\r\n        }, true);\r\n    };\r\n\r\n    /**\r\n     * Converts an array to a vector. Consider moving this to Vector.fromArray\r\n     * @param {String[]|String|Symbol|Number|Number[]} x\r\n     */\r\n    var convertToVector = function (x) {\r\n        if(isArray(x)) {\r\n            var vector = new Vector([]);\r\n            for(var i = 0; i < x.length; i++)\r\n                vector.elements.push(convertToVector(x[i]));\r\n            return vector;\r\n        }\r\n        //Ensure that a nerdamer ready object is returned\r\n        if(!isSymbol(x))\r\n            return _.parse(x);\r\n        return x;\r\n    };\r\n\r\n    /**\r\n     * Generates prime numbers up to a specified number\r\n     * @param {Number} upto\r\n     */\r\n    var generatePrimes = function (upto) {\r\n        //get the last prime in the array\r\n        var last_prime = PRIMES[PRIMES.length - 1] || 2;\r\n        //no need to check if we've already encountered the number. Just check the cache.\r\n        for(var i = last_prime; i < upto; i++) {\r\n            if(isPrime(i))\r\n                PRIMES.push(i);\r\n        }\r\n    };\r\n    /**\r\n     * Checks to see if all arguments are numbers\r\n     * @param {object} args\r\n     */\r\n    var allNumbers = function (args) {\r\n        for(var i = 0; i < args.length; i++)\r\n            if(args[i].group !== N)\r\n                return false;\r\n        return true;\r\n    };\r\n    /*\r\n     * Checks if all arguments aren't just all number but if they\r\n     * are constants as well e.g. pi, e.\r\n     * @param {object} args\r\n     */\r\n    var allConstants = function (args) {\r\n        for(var i = 0; i < args.length; i++) {\r\n            if(args[i].isPi() || args[i].isE())\r\n                continue;\r\n            if(!args[i].isConstant(true))\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Used to multiply two expression in expanded form\r\n     * @param {Symbol} a\r\n     * @param {Symbol} b\r\n     */\r\n    var mix = function (a, b, opt) {\r\n        // Flip them if b is a CP or PL and a is not\r\n        if(b.isComposite() && !a.isComposite() || b.isLinear() && !a.isLinear()) {\r\n            [a, b] = [b, a];\r\n        }\r\n        // A temporary variable to hold the expanded terms\r\n        var t = new Symbol(0);\r\n        if(a.isLinear()) {\r\n            a.each(function (x) {\r\n                // If b is not a PL or a CP then simply multiply it\r\n                if(!b.isComposite()) {\r\n                    var term = _.multiply(_.parse(x), _.parse(b));\r\n                    t = _.add(t, _.expand(term, opt));\r\n                }\r\n                // Otherwise multiply out each term.\r\n                else if(b.isLinear()) {\r\n                    b.each(function (y) {\r\n                        var term = _.multiply(_.parse(x), _.parse(y));\r\n                        var expanded = _.expand(_.parse(term), opt);\r\n                        t = _.add(t, expanded);\r\n                    }, true);\r\n                }\r\n                else {\r\n                    t = _.add(t, _.multiply(x, _.parse(b)));\r\n                }\r\n            }, true);\r\n        }\r\n        else {\r\n            // Just multiply them together\r\n            t = _.multiply(a, b);\r\n        }\r\n\r\n        // The expanded function is now t\r\n        return t;\r\n    };\r\n\r\n//Exceptions ===================================================================\r\n    //Is thrown for division by zero\r\n    var DivisionByZero = customError('DivisionByZero');\r\n    // Is throw if an error occured during parsing\r\n    var ParseError = customError('ParseError');\r\n    // Is thrown if the expression results in undefined\r\n    var UndefinedError = customError('UndefinedError');\r\n    // Is throw input is out of the function domain\r\n    var OutOfFunctionDomainError = customError('OutOfFunctionDomainError');\r\n    // Is throw if a function exceeds x amount of iterations\r\n    var MaximumIterationsReached = customError('MaximumIterationsReached');\r\n    // Is thrown if the parser receives an incorrect type\r\n    var NerdamerTypeError = customError('NerdamerTypeError');\r\n    // Is thrown if bracket parity is not correct\r\n    var ParityError = customError('ParityError');\r\n    // Is thrown if an unexpectd or incorrect operator is encountered\r\n    var OperatorError = customError('OperatorError');\r\n    // Is thrown if an index is out of range.\r\n    var OutOfRangeError = customError('OutOfRangeError');\r\n    // Is thrown if dimensions are incorrect. Mostly for matrices\r\n    var DimensionError = customError('DimensionError');\r\n    // Is thrown if variable name violates naming rule\r\n    var InvalidVariableNameError = customError('InvalidVariableNameError');\r\n    // Is thrown if the limits of the library are exceeded for a function\r\n    // This can be that the function become unstable passed a value\r\n    var ValueLimitExceededError = customError('ValueLimitExceededError');\r\n    // Is throw if the value is an incorrect LH or RH value\r\n    var NerdamerValueError = customError('NerdamerValueError');\r\n    // Is thrown if the value is an incorrect LH or RH value\r\n    var SolveError = customError('SolveError');\r\n    // Is thrown for an infinite loop\r\n    var InfiniteLoopError = customError('InfiniteLoopError');\r\n    // Is thrown if an operator is found when there shouldn't be one\r\n    var UnexpectedTokenError = customError('UnexpectedTokenError');\r\n\r\n    var exceptions = {\r\n        DivisionByZero: DivisionByZero,\r\n        ParseError: ParseError,\r\n        OutOfFunctionDomainError: OutOfFunctionDomainError,\r\n        UndefinedError: UndefinedError,\r\n        MaximumIterationsReached: MaximumIterationsReached,\r\n        NerdamerTypeError: NerdamerTypeError,\r\n        ParityError: ParityError,\r\n        OperatorError: OperatorError,\r\n        OutOfRangeError: OutOfRangeError,\r\n        DimensionError: DimensionError,\r\n        InvalidVariableNameError: InvalidVariableNameError,\r\n        ValueLimitExceededError: ValueLimitExceededError,\r\n        NerdamerValueError: NerdamerValueError,\r\n        SolveError: SolveError,\r\n        InfiniteLoopError: InfiniteLoopError,\r\n        UnexpectedTokenError: UnexpectedTokenError\r\n    };\r\n//Math2 ========================================================================\r\n    //This object holds additional functions for nerdamer. Think of it as an extension of the Math object.\r\n    //I really don't like touching objects which aren't mine hence the reason for Math2. The names of the\r\n    //functions within are pretty self-explanatory.\r\n    //NOTE: DO NOT USE INLINE COMMENTS WITH THE MATH2 OBJECT! THIS BREAK DURING COMPILATION OF BUILDFUNCTION.\r\n    var Math2 = {\r\n        csc: function (x) {\r\n            return 1 / Math.sin(x);\r\n        },\r\n        sec: function (x) {\r\n            return 1 / Math.cos(x);\r\n        },\r\n        cot: function (x) {\r\n            return 1 / Math.tan(x);\r\n        },\r\n        acsc: function (x) {\r\n            return Math.asin(1 / x);\r\n        },\r\n        asec: function (x) {\r\n            return Math.acos(1 / x);\r\n        },\r\n        acot: function (x) {\r\n            return (Math.PI / 2) - Math.atan(x);\r\n        },\r\n        // https://gist.github.com/jiggzson/df0e9ae8b3b06ff3d8dc2aa062853bd8\r\n        erf: function (x) {\r\n            var t = 1 / (1 + 0.5 * Math.abs(x));\r\n            var result = 1 - t * Math.exp(-x * x - 1.26551223 +\r\n                    t * (1.00002368 +\r\n                            t * (0.37409196 +\r\n                                    t * (0.09678418 +\r\n                                            t * (-0.18628806 +\r\n                                                    t * (0.27886807 +\r\n                                                            t * (-1.13520398 +\r\n                                                                    t * (1.48851587 +\r\n                                                                            t * (-0.82215223 +\r\n                                                                                    t * (0.17087277)))))))))\r\n                    );\r\n            return x >= 0 ? result : -result;\r\n        },\r\n        diff: function (f) {\r\n            var h = 0.001;\r\n\r\n            var derivative = function (x) {\r\n                return (f(x + h) - f(x - h)) / (2 * h);\r\n            };\r\n\r\n            return derivative;\r\n        },\r\n        median: function (...values) {\r\n            values.sort(function (a, b) {\r\n                return a - b;\r\n            });\r\n\r\n            var half = Math.floor(values.length / 2);\r\n\r\n            if(values.length % 2)\r\n                return values[half];\r\n\r\n            return (values[half - 1] + values[half]) / 2.0;\r\n        },\r\n        /*\r\n         * Reverses continued fraction calculation\r\n         * @param {obj} contd\r\n         * @returns {Number}\r\n         */\r\n        fromContinued: function (contd) {\r\n            var arr = contd.fractions.slice();\r\n            var e = 1 / arr.pop();\r\n            for(var i = 0, l = arr.length; i < l; i++) {\r\n                e = 1 / (arr.pop() + e);\r\n            }\r\n            return contd.sign * (contd.whole + e);\r\n        },\r\n        /*\r\n         * Calculates continued fractions\r\n         * @param {Number} n\r\n         * @param {Number} x The number of places\r\n         * @returns {Number}\r\n         */\r\n        continuedFraction: function (n, x) {\r\n            x = x || 20;\r\n            var sign = Math.sign(n); /*store the sign*/\r\n            var absn = Math.abs(n); /*get the absolute value of the number*/\r\n            var whole = Math.floor(absn); /*get the whole*/\r\n            var ni = absn - whole; /*subtract the whole*/\r\n            var c = 0; /*the counter to keep track of iterations*/\r\n            var done = false;\r\n            var epsilon = 1e-14;\r\n            var max = 1e7;\r\n            var e, w;\r\n            var retval = {\r\n                whole: whole,\r\n                sign: sign,\r\n                fractions: []\r\n            };\r\n            /*start calculating*/\r\n            while(!done && ni !== 0) {\r\n                /*invert and get the whole*/\r\n                e = 1 / ni;\r\n                w = Math.floor(e);\r\n                if(w > max) {\r\n                    /*this signals that we may have already gone too far*/\r\n                    var d = Math2.fromContinued(retval) - n;\r\n                    if(d <= Number.EPSILON)\r\n                        break;\r\n                }\r\n                /*add to result*/\r\n                retval.fractions.push(w);\r\n                /*move the ni to the decimal*/\r\n                ni = e - w;\r\n                /*ni should always be a decimal. If we have a whole number then we're in the rounding errors*/\r\n                if(ni <= epsilon || c >= x - 1)\r\n                    done = true;\r\n                c++;\r\n            }\r\n            /*cleanup 1/(n+1/1) = 1/(n+1) so just move the last digit one over if it's one*/\r\n            var idx = retval.fractions.length - 1;\r\n            if(retval.fractions[idx] === 1) {\r\n                retval.fractions.pop();\r\n                /*increase the last one by one*/\r\n                retval.fractions[--idx]++;\r\n            }\r\n            return retval;\r\n        },\r\n        bigpow: function (n, p) {\r\n            if(!(n instanceof Frac))\r\n                n = Frac.create(n);\r\n            if(!(p instanceof Frac))\r\n                p = Frac.create(p);\r\n            var retval = new Frac(0);\r\n            if(p.isInteger()) {\r\n                retval.num = n.num.pow(p.toString());\r\n                retval.den = n.den.pow(p.toString());\r\n            }\r\n            else {\r\n                var num = Frac.create(Math.pow(n.num, p.num));\r\n                var den = Frac.create(Math.pow(n.den, p.num));\r\n\r\n                retval.num = Math2.nthroot(num, p.den.toString());\r\n                retval.den = Math2.nthroot(den, p.den);\r\n            }\r\n            return retval;\r\n        },\r\n        //http://stackoverflow.com/questions/15454183/how-to-make-a-function-that-computes-the-factorial-for-numbers-with-decimals\r\n        gamma: function (z) {\r\n            var g = 7;\r\n            var C = [\r\n                0.99999999999980993,\r\n                676.5203681218851,\r\n                -1259.1392167224028,\r\n                771.32342877765313,\r\n                -176.61502916214059,\r\n                12.507343278686905,\r\n                -0.13857109526572012,\r\n                9.9843695780195716e-6,\r\n                1.5056327351493116e-7]\r\n                    ;\r\n\r\n            if(z < 0.5)\r\n                return Math.PI / (Math.sin(Math.PI * z) * Math2.gamma(1 - z));\r\n            else {\r\n                z -= 1;\r\n\r\n                var x = C[0];\r\n                for(var i = 1; i < g + 2; i++)\r\n                    x += C[i] / (z + i);\r\n\r\n                var t = z + g + 0.5;\r\n                return Math.sqrt(2 * Math.PI) * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x;\r\n            }\r\n        },\r\n        //factorial\r\n        bigfactorial: function (x) {\r\n            var retval = new bigInt(1);\r\n            for(var i = 2; i <= x; i++)\r\n                retval = retval.times(i);\r\n            return new Frac(retval);\r\n        },\r\n        //https://en.wikipedia.org/wiki/Logarithm#Calculation\r\n        bigLog: function (x) {\r\n            var CACHE = [\"-253631954333118718762629409109262279926288908775918712466601196032/39970093576053625963957478139049824030906352922262642968060706375\", \"0\", \"24553090145869607172412918483124184864289170814122579923404694986469653261608528681589949629750677407356463601998534945057511664951799678336/35422621391945757431676178435630229283255250779216421054188228659061954317501699707236864189383591478024245495110561124597124995986978302375\", \"369017335340917140706044240090243368728616279239227943871048759140274862131699550043150713059889196223917527172547/335894053932612728969975338549993764554481173661218585876475837409922537622385232776657791604345125227005476864000\", \"24606853025626737903121303930100462245506322607985779603220820323211395607931699126390918477501325805513849611930008427268176602460462988972957593458726734897129954728102144/17750092415977639787139561330326170936321452137635322313122938207611787444311735251389066106937796085669460151963285086542745859461943369606018450213014148175716400146484375\", \"399073568781976806715759409052286641738926636328983929439450824555613704676637191564699164303012247386095942144825603522401740680808466858044/247958349743620302021733249049411604982786755454514947379317600613433680222511897950658049325685140346169718465773927872179874971908848116625\", \"1468102989495846944084741146947295378041808701256909016224309866143294556551407470861354311593351276612463858816796714569499021375899793849136855085849133702029337910502448189055357182595424959360/819363879309286303497217527375463120404739098260200279520788950777458900438307356738082930586032462601215802636320993648007907724899611296693997216938989854861043298494990214825163523387600982777\", \"5896704855274661767824574093605344871722790278354431422729640950821239030785642943033153793245906863203822369276271050164634206965056233097479117980782641839669/3030306850569309344013726745100070601277982132543905537366562638553198167007159067544789592089960911065181606283478843359856123992707598685058297067179343872000\", \"76631772943534985713873427262830314617912556928476573358548256872141516989538374761909611879922349479420014771499018155447198112155515453671128814488139633810493264352294560043912066253026059140653027326566801398784/36852092933388988649396042883218509607503204211148493545892849595498822817623842579026942621098851631842754395231561679671400197056377380063233740202370686144673585955581403046886083948450136247134308381940165804875\", \"3159076083816399509754948610929467278257473888282947311280653574634802580912280940686954763313882823327077171624015737719617373932318151594325834524000275847475866299387913048/1437757485694188822758304467756419845842037623148461107362957994816554782989250555362514354661961482939226272309026092009962414616417412938087494467254146002233028411865234375\", \"22266067259907364984531611601870291368272674573653403965630628996687370994139884833897773468149149664829922302484782423514167405397665098388400450149078982462318781750661005833037235183394221496186539779712428265837926417581952/9670030144664428565128962309657100138096047028794689249320859276197340398920725569428532293373676415359965773460364494998334259893079003125373872108770534788283842907318071170285038777091588292539102269617376180390982915567375\", \"14604654564989239958569331443385369522850975185358647132770022716433280072271007767111036877803328768910274400515590151934676819262085211828028638417329558229123989556376108454497813055/6090614019162516693013973409650613208227889078878781039105047015752493519149314227721984436973374032279421344818329285207124280297611253861173835238379831004010748379874393292231671808\", \"1901241885407696031217292877862925220917660047127261026827869027159993239567933534052663335498281439239753018507182016153657409777749792228538380379703411298411623469292891476969894084838876001545818141543890273256985768690847587711270930688/765116019778838839812655402103512685695769161212360553099732689795578904762091216998790589926057819838537805856579109910198553330075924857419395160755642371550113347465300208422126945265887065434116781678702741657275181694851670325469434625\", \"139459806786604751793737926146840623607010208216289543036026206208962059593900745886202214788747453279179283344350478734275973878932538430194363355795823581315329311220701640235653288975569812161436/54371368534412517053056101353618694718215711767266376573138772968257303578467926450212293233332401067673270853953399269852376592855992724934941173346260129257754416412476202526978443681584633116375\", \"1045669091124493070709683241190022970908640501171378776604126771144008324358233819560649021940145166254659028524319517244711645162132513416238958170819347361185944945680269442845829390112062101255500836072082817820950448463314034677353723256969344/396228259004446234921310936915931611736815598535963504660076315228798989932959459406702091180060429080345146735173591749448509810270759531977278642135591672189002006272326131885315743181289970885337574780897529347356567086535505950450897216796875\", \"9912919238915437302006264477931031611447467070103973106567538528951878797932559935860738745374437522819124347510590800370471910492338584284092534264608801221235029062881964101996762011296996851893455828946521/3660537472668264151218961634689665210933936249986285290553357254224360417386515311493310199319523687171757653216994741150377508234317025158302057758196429623723072084157928224798322861732880034847243894784000\", \"9263710175433181746575186369318246002919895649622127410824041370079225200282403368319370743363303164313395723904510539050157032684710468364067204876434546848634842333436957245275217583248805993142227630297924119330553308466662488683624783307023014909360640/3341177182697517248552428837661919299725031035849865632511882688786226888137634168024976033652753689210700218163621739078534353578510364301481093730054725078138658805025014615651043313990684347632166030359086885561104034510990826655289288319840595753002771\", \"5116082230713622171832327542439052727465114322479570603905499496221224653983960598946033081212909066917137546065542953865612718836914393275681318667667521726785633638189373998191090501201427906618075889744489190209584/1805752553736060443820406101277706970767657006346276183748749630179442318063568286372320188433843729960294965366346522303898609655762491623098453269916163621089005711823488749297418113474056676109581110715068124438875\", \"246569125619713282434448566970352231845414317018379160824176638351574938993535464763890962336882760882398479702237564384291290459961036068916857265499633061660562532011248501476114401629839742058389195725393702000011860799793778295606988057303225493814005789533570432/85307063020836305797178273029353623060860009152114361453434032434699636078115114412588719432277441055049132559782203988387794711585368296817222565434951256788867244687081233632650953850383220864394261763844194948389861147622944651546912394593164406926489862036343375\", \"133672026303452911046163998480860917119290576658330909785707604886881155606725822685088929236266583416708668502760907677019598002175122453170574729028452721476464728566191464897928696630979863154661704374206171469014225143/45398130975270785045482567762871405072140548998125471025451666500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"6041693953360002800224091673336562508913199995987479264605216252220579740134601435770085920869376641180763419907442721705887169884230643795126568815123647603047739799302562095542459344811429882053086550900803768964612193941424128649976704727183797495759082741166938351872/2016766992122395667828553277997478570503475626107286343497917705446132017125079612756035254750822860815515899557855166824523851779156336235294914777307802256439645525835223691751931866188957324792276149549076500784191791380803500156776088683900346065830066370370083309875\", \"705868391597244582764749229356331441978820024796066870551110486625729826111158236686696326058778874201639006234449557592353247542995871491078308187261304930042019640830629526023972693107193897009168955674240659026247094657679060/231848642748474339277532000336338632910990823562381469441716922006107433404523316252618490265927265734670539384485699132080062215196462178933963957679882342083893417545858074378754089719547920901917516016346211301054206383643383\", \"101832160604157943093944673541651013907278188571533075311673249923948856034633446617630054761681006062910980371900782781226979391765818325065031889334563981235894369036439929651260587335544056975715076598739977065390678221999918899003881778449092038750712969437519295878491018112/32944277910571666002449086492515464541550138004002141571670657643770713783329063548790202120805341989608877739811787937782240802963962520261844114327432160788193314874913687387269408387417806176202979244637915812905426565263196954203487934225589622864145960079736633434831996625\", \"10655703119271468913597640479490594180964700448340778168715956712130636958373270202484276402718566314881119559090842449610957974112230306343486091910217340665146602598568991520563987490686996746558858366002301982443029430290679385551/3398412687366638541233365137084722368200311117891192348532156645374786104142009695796409107380345795998400850838706661851176885183144928701608654514812261697598380070746520197171576610572921007069104300695592751543563472456384512000\", \"1903039332876763837419920240543738799531131775028971323439870868730321221615515008394327723508670975623498588291298064320786970626232668956372004004897872810230178526101184611242511193415796638694370503100219710864543168952682617801833318493436174387568067811938490953495819438108686336/598806534367503338307287246320963280558134937382149405305466709787179429317914803617527827862441615350396864359976273212272586892074799651088317544101755361439294687323233086696182687664637422796995789967075271448560870681210580691574924544896656175563265378514188341796398162841796875\", \"525573915563826130963525826191411949262846916750432019596028344808298471293378917508549164993368392834023782480702893643486699787870059946429810070222126260200026332874480239090370088123833491499400991181659445914352500247596757005142623368/163278727324937389095822405034435687776345799835442022795533783889356344755225815267819508608559076191292900367982490827396869405536484846115955581043091229202052407483776587687967125885665493681707461345895999542381476164157058393971431375\", \"9263815657177858787273494705338516861045771674838057329170239610953039987023429736752079544014780707408666628475997291124805562998227296677616204140605356257712022384368492575381355563976330347792504605666631512343447560301417325154003481040250148561839861837778597346623630046623751094400/2843321709948499955095590862256744532227698001408929142548057792217790532624003190447363578048562448168721539177458065482170148482375585867230123873178100117094533143052886527452665480614620123764036974180917207421482431983407742154634391264619615289225747664532332469783301704643254076601\", \"407959339726114455622180187758753007349209016396248763075759257357925636039752474207685682218422721827857994768023399625060206708378433960993946156803948655098667156937949174400873748557248801874735834957795040139401560494087476967548060208243867/123780218751812156744401121690996305978134694678934447237402511116731459214498784497436358160964198336874043702652746834763131444030185151143987331404604087778514863973633941401826334750268416015224906056576641018962863645043976537664227639296000\", \"2547676391598917379516698439971914695230548782904479778605691338364453606537643088857116141939170899135026552016969320061900926954008522781162186995856580955090548471448276736878300717869625651893741316530109438876067419826217901657017506157997588944233677467357220316084583383623602865379325184/764562034757392298786420374672266498815021229519853724850874576419885380830752931701831256959159800764672605004880389358601658343203513177084389490286723240185146570925957286083025676875197029662038213216541352875570101363668917766225709569356861275434470568767077844675593176178611021135573625\", \"186545352286463730559933346565311535598243666022232037054735807289501173444103692309735768703898330430135399033529355360391658728987379385732098960609744313878477967971557204207043802935782878745271859468248704012618254203101767841517569443555143252/55399179641621656233589820996143825959365789093262978988289445625153099592463372579496245442338653053662134699646413817866770218574795378644415019944304868289119443774932782235638737888469746745621382139263856603239588594078668393194675445556640625\", \"664884440164786473344854955309049113269357314957985265728106924238588705533437169796551912202931185746193155801905841712503407258166135075966280435780812714252670362202091663287095423712596462690753468682634261029392794173636943978404002804413009590005984736612421172979101972556772005594499779860608/195485517776407145286424460448995460754674039560651791192647586550615878988380153730602665795647187884543361218962125172808792176382956599256188706636727418572541254480798303566840010217729386905041217793614214518363859058348249961790104618910877813067510758225302884815410347238200133693756493703875\", \"2614957283934314904315471338485451166053664494383241929385424599389309215073267052860464009981063483440201193771607520572077231889699858482582363845275452280606276949653970992719332472370351170732899676316967244504534154616036371979031399425846100527685/761493664432749089312665480773496290658029971027686543404885407644062485746072719559288231362060149626237939029641098328278650939665665969011529293869562636656650999759724704272743235210867676873525147820749560155294022488994426729939894753293900972032\", \"124843380518493746761140367283007507854364503961156704095198010255465940085534099747297600085903814014415830785663764373057896014399822131175202342399536439284123918855893825207202244831315575594886675813256448846863723093240955901916229136393454605455444105444987028391748121054399538064686074523506176/36022228212051654395480210378626648518430280334458144892889271272122662467638331091863215146548048144675657239846337165813938424387499358852301016926312083940212100001220180762189978024821166744964908871443681332664798940660421469519997746775275873085770018269706847741064037876137315001228315806659875\", \"827992369063043155578730871896750570951766628472810506926098505028264552046829097082095665194000002802661600196840639204300804225352337632259980703832713031790922485730615305441309917696044954289187837653933158950774246017223571461858939407386087081525130831392/236805932823686534991153393869288530368011574665859226704279685567723830696754821658770176385138917722808377962346690757191122309876922069867472518117628639913077442806147910884267694879089753138429767401700283014143248445966474839193628309668702223994071394625\", \"17347276886878323736540051321582548724378497839789943634071026331001588645519865992773157565595886250230140452154269197770615097377486013097979087647774513500701793885978192218455687078883766086309728287172567466406449372659680040183273634701092561727514713494914793425407149186041796935055187281744386432/4919325621804683623339606849970832094714371903709195539440424738973575902329797546592497378000858196173718145883783709223158260700365224756081275272021856393735663399552166737690038832550853145831185979094979556715294990257315369124065787473707136464772247917156232366320267601622617803514003753662109375\", \"137984231830526866236186357461458917020538108058615632801298091031540729111527734872044790487396302545910108285921421417358113055522725197998483383380192391312304647004240060970929072498293210057120617332323445379424867965764749534125081131327565507524502163460761/38810445792642817561168950890315210470940006613819790543653745327778579787694809782601777514116858514049585074667085399925278459138508514838268321349069481334967221455722811414399738756151414906092225265355449011152267068726417045644222323488445626292574879744000\", \"746567120547823334914136339633766098626636643449144032626270358619125402826113269699709721071135471625588981126637674402048519990010499180844665151971356149292818375448504122545400227696621572263621729512461528550588108384619064912224884465737417596190735966915167530332762203074440688676123756162572829692160/208334337057923929636884170505570363171441147899816815785150954417598643614152856767186132467069365605496210036171429712485182162940460120834349006784956522600679357307849981862006710239311750261522832996877712350330290831638640913932265004107623954913155144975252743257846945609734368518424172846119306643431\", \"64649371728330695076928013661001819989330953381731372450140483779536126948957993261299287753791770622512248630224724990234903928056275080682537641377393210728546364176267034339221558641084730052304770498929958838997239635790469536857863963589118888238069738647239076/17903951498200212327802847425913723358452100686246224008745414214690047078122925247086521362329833307849817944645647750649290248110509395628305970523384831671737569872597295947593410067364379687588919135621621162007748635920864926867870502568935739725312687094047375\", \"2454918942158003099688922026016393688092399295166304634317616773083386087532869193458590448918958337530406410803840837646465522656670050113548208618655070231274778592766244282964463702354872753657766121825196898916725498553882689210280080206627916046484942827487726300822318764058084323314109595329304407466188383616/674880185931325925966586583820010578979699141814417326552629206140252348822939845006845669570885271576698771404162512001549922909048916000017837898649100825976232784446638776021483802989797501705685620612986771521390439936066527738682396560462899753657942715306792783283782238662155922082005591512296007820682995125\", \"74018558041066162916454010680594042518462756234254788158141115244349044958441521749277686851928706433556285971088455226217644009628399441967508838553345152310730562224910795446341601049647392069373970101491741830623078126344928804029524181578945586663110848142571149861/20204153620006780689923328634586091101021423979622170579036140596085566172775051595588438592742563923428900864000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"2127032036758045513335690185608563023954009095206088224487365541995326714285119384743928987635752931664240752323937321097955456543854943206092931247498833001499955456190701695430459583885125382086777607021670447795321669948733328973350279846928613949120929250312666393359442423066212311060931469017737106028339882830848/576612418511902928757340062840968526862381326698309578771238715462180282212422302261044980131594522407066369222998903808960617461164985318633518680304995784614308979881735537678182134128319596636920719106506829571072447362052319438091347699720147003209417806230149598345068078717948025207635448205253184540936478445125\", \"35289653975561083576641954928762116897061274899517309102784750384002335187117263273488751066569234386120759866204372398611196356888479036949053282301027789530999737306501029700128744408015642211359442183943916106790666114870974212159410284751571905275610921784716184508440/9503006066880728386808143045924119024212377150217533250562188228062174064693375135306438120385877320162710918716613546077156389583384656340709638430674364232343609717735574035535102953482366914421205216675248471695111720986346092738728929878538430662191272737183832556131\", \"102633551023964794485575491065909467125458972250222581133681080524371507544152979467328048718122409841060527545925136196267751819689935599599321090571687632103850847605493223603751038996548520557330016046032671961857623066292962260173840972332108111505971231021442896036760967107060309991355545554631003681544611731245475968/27459658121882266328752886605529964804078316737648012166874496015808620265471203512606463219297059547428855195782384236337998738233668399173746663289852416697917397644234441300570212555870401420579737973722145663287124151049692290432756231390864184491891697469874600345958989433125942336757049639797225309327019275689074625\", \"10034393558388390065766795008210457368713365491566387292163814915435906649268119060550511145023450790393353937124495488860451123302412204483570913557762460385297770427946219119911920640306914453207097103853766023934602534502476962159682750262143380527529536498215384467975023/2667919902603322771586358077760621955455470781865624844984169443739075976572061827709528710108877015489050369589117491611045518221354793418884447632063538994046714401229510497599783726376490260140723032102883617341970952663947646017489439179953454964374887388652792446976000\", \"248528145263843375390386172800048509380966183384567983242213959113927668429802237067505890436957693495616107089384741585283620097982859345081736730899912519273262934785992235852866637878831878448348444611412764161078458068549719800733237024285525816723480868704742804077255242682077291713092790250511567621735004237450946304/65676865669148624809340872151906045781446981664561196686217551358486802274698228825404698950974939545099727242259547145392352658637333562345477931951890984276718673618736565926663528625796412420753961231404680876558659735251469326707567479071881966875336951133475135427640218972722939427821842173216282390058040618896484375\", \"7805448718805635696495809414501206964843262114470109146341305656318015059743127114324245035489577134938579856003956861881125856595981500593426840968087618241785931128978516340812066502964561231235073012672356530509663384739132686548934288703179479011016719045530855033205271548/2050525178024039744126592505352202216905491833360272553169520915020715464206141942151086176509423406413311520838568324134077402841030113427309725873344806030836314500267104070131451720947531994814710189000076651895520222646974590481497382830325485174899169093049299764813276375\", \"3355325071293197839434119105039673324264765809771192815982246040415580387729382404624613875653005261578877047405365032178619450963731719777167015959920645055600439987161800547901539269321100559393048973255388860193948274255340335876890491746900991668165565729269698196233805991206691196045182214641935483083662356666996922240/876402579119117579582569839757462461050855174353108858954282915644790659429341853404829661899850841645529640454766173209897510988090318303454542547519850473808789222552969933222203420847859171250332350076509996295844203965564448154484566493395403967626596213792922784509892086361572955175655987334882030766001799867659814117\", \"218871061991045868372866381545267589365410350294028138778572466235486397478028823720846191998825628156716190463263492304639890659254282445466806224943413446008645087186307985343574807361972238230520975439736199291019544576443791916302825193643774360055545186783819367378492631806297/56849560726416896431557940314760680962653658127458002233782028041537121216487790008085876994020812492987733987414743604239935223783349870516284048368761617736127892160849065895223288023531930411718807065209903593668117085505482007061969339237404945180379460053180570404846043136000\", \"5008685108365226931582937964451700746853986170633433728409171904803795018146152804690759530990140552460596075588463394200510044617816085275660078502126507209302951286606953039953843685800941558212440519542602092919776366067720586295390886070120828199562643208637974347390938772070049344991272621102622931576339988103674070876518912/1293888539680354282541277646947380627241979967611883341823378331667976045287311988103163380651334828012840330710760757271860219584371109472132211215957402251594055009937397184768184517621978947384029376766290498101728971145633139541827544539988344772578184316843734267915665730981857376872622787627370859411909330227080697966353375\", \"15388340113525711660227566446101909585796746979396093776960989868457211684028149502578116456785221720682202816140911944661051001675127262774824593420825587319436537346311831003212424497488485098543512314062112948777572038731823948224734505930748371522309451168088057190162878224801232/3954220582960831691377435160890656173654063611768428458807273708040518769541211737927975894584024448193835165167801976423275767590502552964407494549049777006346189436817215329891530811451811864579644894987864267389290848598289794977382504890216219362031324635609053075313568115234375\", \"5099039333987561374222193551155323470675617979816941646196895589439391685938046865391119484510329634015275893520725135141878751153360264368353595348921951280561029028912953500944814771064409611917475818956659775131751121312316084465321917769679881052144364834485866477379437705913911371481828140817759401117780199246301705600020671104/1303503600297679371136943454060319958680553228879031326679449263682048703103464872914972900105569835004878963701599765030590097739639045890060548760692125546754294514068052902543220382104483822438283040090444827980927544440984823535260277595466339403795403200720622852069244768910603820007632395190204569927612348189089161551951106625\", \"4902837141334073026145827027361937996261324349722726869116185158777439337041263482852376194988371853413467559557923410949898048139830183335197992754748294810838187068126867611615800383834975563313220497573778480109264178673389149671194149749735833378557143135481387904961537942569904075/1247045310545991266291285730016853118981099516935251861146038369985109288084420528171217942065832292739130145780833406014673689119563698528225048800794718789218267628507713621235056538202070171596177775095071513194885568843375526804796016261173388452184505503341132236719484809714335744\", \"38114743522716832107917466438257616720476488812538316101658139632867788464381862291240727309611460187159930652186486096300862388591521625093237019662273764387591494074792574929490381910446287947994150655077877204446864004067956087975012773988833339521775463977233068498404144221045837190392670308437391686081418318624745039402145439223552/9647001083383999453668111809775451078976046488746916070976218645431946648087171586252172936600115032316383427265217993193444199863138429602138841976586190525451324093772097241349417938578878934577091671046050326087898259692917931230974174799815198493279413438192301437068820185757869608523761456160341754512329264442115351926967120404125\", \"573695055225225727008803730767518906490704995929177617646275646884555707960986625481944101622708415415988844740028718027554452662358957933526173824325955904005404113684003841990198157072540659184995738719040024647370869010473254071681533880576462368600901824622431045529064651675640055917092/144509482511118816399089096021290587489594541280398871255876563615464628718527634679330291741479135415168539765887291789615790513527330600394937614433502341116068305347468133950204152174094704092402978083370792135432486240914953928188835819767755172666693219213868545854371103120604946200875\", \"23876960329653589647925126180903391687666378233201794403339630995420215267415575142266707357255726330536094448314199602616026935251126469221925945960901748679919435908556550271504767784553484434363646489174587463466333864577705745452492395785557425904735048180164697040313528831173448025400634629163795223739061661461986923675833880378496/5986312408594306954013526197465608559068621248896320652512228238115589875514604632230098997609482248000888567135685167138762172475788060284232459813998201719590208742091697294562538265829954186149162974972471533202880368317237508987477069872431064075005305838801862900501819963793062041081601844759452202282545840716920793056488037109375\", \"58168289917567723171226992383559866214094157894992327555495441698028867727845766488121900626912848698952863438654895252811583144479300382761129433911280049009362667380001406579175563745824368613319103673817094498117944856004415812877213722455299491145649879676787079744410765053845551958756701/14517067289347903655500020160671113450349743650636953726251191692074385521975132268313263723831804150872238173602847065423463131917373356798750100313145228608894881457107689499956903046984443545789053438946050974567665049237414588435796381674590098629779384355275820782532479708807512981504000\", \"728621890568281859295409481422447012528302594365693410763821707074444799793690738137592101239862736313347273167450056625929591960610208335290882047413011571781161008296084630072829079783328937418641417642857196346026366370059522990813537731394823630207433267854616768658990289454635793326766697884798538576055949457122067828153655416688640/181030730759516991863708593747964787874073354051675597050399087612142539517308720603687322924426591889179726492403913356461908748733972707460063017057809060190437917851790767968877215795679844983288935075688219234885360839984681619084834228226744165610073685719017596630302462070188937998558312507638434329299017584329479516410907786681093\", \"86855946923438322218622470067224691860808273886184997065663554841573982963995340977083049132518812923329423480393306918856650577072525633920456721265953575424233701929892019410099166322511413146891121248381648145391642571638857576890568882512129960291171866772665863159474602604647289052079991768/21485753507365901947528588896402264670781310878547726104482740647554738151100954835784115119035980523529677083504495839730499664052882400915208251594384038810917282207449860876251558307288700200910747338758723324686939379138206117634546981163355060740270734146780942696291669461182599512320099625\", \"2158989152301022938148680102142188531448821359505188055264665167313418619665693092337665573150374231484840948447637297247277576415460889296724813940128955070240137590073233263168835678714131062764247434144994737610229909964847568491446606012581370840699582055341626266533733744293929658949697805855362114229666626620766245630122333733703618176/531794915405164005613733454597931482878479882704956110685223892325074211694837836221759995948610212818642789132749082430059593652854659130217225506942675608692701447738732031302987802196501895840510235161825501235133794449421919927396142470196961877376701957829921152848178076410141813926924749057304222282687697297216661687583257901415465125\", \"139432548574396829074586704387656697097760057897628994548358619815052936481650396157428747411173567801047221928593253479330480454469358220685854351236980383914223693722868233819483137401339800304943891968050399345430243790898955416907228948287367356990263740207046902209563417267686591994743547621/34201151688775214071963206765436083445901621442002061707492082843232231754829227303539041286301398668437202547003300396162741375435703188500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"11008517174872833286150985180322584448162884832099344969609291070844193524816852920942383850580217443209402836100467940651581092350600329145627967515818684442171571156446321228596914355704205623857871497315955269266498229823278800717909321269179839084452384509142712677235552103459737790674103994445173074670347080506698168482564009465276165824768/2689223396936080856855299215659204161946704205931885125148201643087176556822542895325191478283706585400237901215485150928036895428721912118467760766508162631903585126377676412573187912443878232521444786090510891599171741773242011017926658231638022943018461086517502584854390836347781674626615709751386455292026775663545470794167629144456268750125\", \"16108638074211260588800537540680707641986073914251424878121255234668558067988171568946079848860335948991834525552515669040163026131919804987340113244760738846884911038097907756220945883750502673899084880578229601870882631165510396775126850307838505063922101682333806284668762825609556049426829531780/3919363961344261777100658318137884299575193089462944554282218278496298610828757650104922583359642384253066896538203596057302203635134833545580869871333892935330950583664400555463557735723364497947986885146043017010159347046389604172186788902608216894094289769850517098027486468084407618748895626853\", \"34420755849180279597302103726180110022640946692592540634353734157479505420320000324260530767186132260970572450489530034440214259559325114511265075416512316229177952140217732655405289808326341696986755141965043719344169685611217958619102774617224847284122901023774956887687026904767714958090256282893003000752947427857703259704682455375442735857024/8342030311716679826889917494957593165464748884572298173556257652389845294530325764837124998293398445804458613956489096007564811101361266196542129764287084823604897187311540561857741285793447174119667215803837719660675298308873496219385226998078648428368061868944322478384684509466965129972030932418920415308276430355882329457342937549162000252625\", \"345888075261020004071220843714060353763382280664960929903544964118831237876694384053904571498830068831026644303797377762345709976595360421502594656308937649239978525713471393570536680412814805076323426256584504251728507416368609420882442293831684681071553766603478479006495757222912500012444787804577811/83505703731469734628961395063481893801938371516752417759131774530720075262459158384433785006689548434701904106312038822969658455364219435022841597243178757423598248565463985786213156556523685666430799283870548238467817226915680747412191245046634279766450629886904716776719219698922088211154187845632000\", \"1061717830619177527082296723099890392273896386613997004874669053445943252046748251883532634529759169500795452576392700472771365240996842610207274128102329096619028487369622001737128463631016494371635687841733644339636164570819431573829173533941056258744442930643735587780907310433371453992062647737259587563398111688659657406089003293576961475848704/255359631537215747979895955806995352799574790340218399351168178555478073997876110889483456972687438702262017800167048243754141722496276537685853311434069991222324039005160057724073156957530106623908696241268268096879569794431919729620178375212905203484165745866913773304319069321426245521467122472046370356725530914587807274074293673038482666015625\", \"274122944106300296738399632684955400761495830361663966466225652918683099779465438024846903286816813856490888796372134557295699980528187779624865098445756013563535339056233912394908544185885547842235097677765325396255649207317018754967666450708249125316192200151505568416495274671679500594656671785202496/65687592621976546250581560102201535533608158256953087745856906437400149205693427285162333502528793675585022025602144243543064185647792948495372442630333800126269123531636800213405254045262127593759539706750242430153456891792533267948231185296091297979933562727112487057234422009426868531651634706262125\", \"7842680480716516803148821198697967237136721860017131244266974996267074742248599085253569637183007740566941125452215834642683053334607896723447140851344501084122965014242091312411884985569341166545074688756440728922408743841592658677792796881188604773469108807869960161395759837407978596679911066586626885830991556090978327508459276025943279064965688960/1872528612245648675720382138045071131304652050696842872529163720558126655075937845539792108048310219395746259570506175902206215101518698490144716531697689534559827422735649881381597761684154409796315455445459537515308174919488497154409643876490472215352056502193150125644288086294418253309947229151074464928874881827227706992859640236086417889990541889\", \"5300824422251242070074569186825929119848111723012841627275830216301188228660779008353049603527567784119877706984722171178137272986345560485784907345500893648715341273841147320288851034078863843374665850852481747000237834238703248634174397792745914847774297223176674917912406659831206869442510948965571661/1261140476013707338477604677428573831791396352814802149994640617701773078174882455512668089072441176857892331468691160991310474734143842336092636848492066592397892638052212250229129355009939118431643425836944282456647571558383755315238500832868535816144280088644939696339160092963629012001958205063168000\", \"2220223718762215584659309059880106334425515875615107369399767892051551634000614327272260081056973863669004224981561870246078120862256383581012183852291444462730018546753183156982897386563561418424093883164027305254176874653780425452987066512563140531367766900610414277825262239199580925879453806414860409441845631158680721091621460775043562065815179617536/526383206607841251253861841374779803798480623722760367843070466043030228662340154304405180907941079883976168609082254331465595267209149963786388600028701073430773581228212441424400748220833542964971495005714483235359479470452593264280645360131482713147116366500300066771223383007216182988263355451923333319170174755334598973202740108032097242475554128875\", \"521891797109626296684891455959263713257353500867652268541535940159815152120871142196535233326890353914761242025931373491906127275561002910157909306979093246574207104081108188995072105948138299097848175016082947174156278439986705241571619793059501724269644447572323501261424770743329858038040685313621446524/123310256826873923765604825413207481739886340225713108649758575106598510022338480189649787216845041382860899099250547657534972156328080736149239332330143771138115695598493059325064119176038137294863053148618656356436332991079150723235214278848602671333076219529535123842212129829931654967367649078369140625\", \"66086044538329677372986118727999622900471937619891337714357792768200341519193500393739322894033303245376225584865369486696276607060432449792893028061817203932068085863800494054274423512956136695211796751845295921015953538329385253280866669403169919614982155350899648626481405781514434761541281229159396787287553493046927448595964103589100429722948913403008/15562137339474350565671240515273666798063901504051979980452491653975250630723677279081058884163396938548780856293034775459223871281049026140999055923743471466471830572672766633086347312178711643724485955576579988182546105048041649947277672869613992334541438784737993706482731696809943027528882927942967419447250586964258807454003775693567366165507144866375\", \"335377615394100148751647837967017467711612297170079949298328061159559939969228226474615711044891085626519877634842694983669611974807129333052471799687426665556738316626171408219730853872410792831871526174987402129691897433888027072807302411474690613948951673562473758814664346259109886876538510453475290967835/78715592752271462306588358880337347638000605031000575876214116610339827495261512281635361568951675037834544811575026718101166562072917855004822606752296233435017284127594847656529606648345533195437635894948829857913798336356647286032372695130461573940500785137424365840081503133157308796505622439791698116608\", \"20090879701618729602554170716780970848925039917987945471322994867171660307998603515745066411687983450400412739285577269751603921163835619296822801840348319742203974023505186187060251544248644338412667631232247108675504629538319425769464277309915502144443973397371136256151336255138506001292355330875114245901820438821732843540725116728866301271466614762497024/4700223519410528857298732096729483544820841497820611795617923063440946097326817340637303431283005509904481323205480729806879570430868897342398783028649633951362398196137429076844504529051072393709154483678349272930361110568616112723747726853614661953537957117231900032044221535502745676310313569997665352252492568100075191900969170979460298189170486601502625\", \"2904778979985524171206573028445379872240558084236464200857594814631031581387804621371822074061289363372523364167184697785570324832815972970658633551879143187709707164796663015180877412717910872234647704536817108676736661804878068078543241390828229923424191204586313620612539678930999769543756218765870513049986792/677408099044823641581658869221044375312077929976719183424865834811543737800956896926637625166844372424044003929341361734886232742770909683021563822987505236295727478159938135467975522336774471915167606673489722102077041330652185811196423400701795791669780695158730756241178262962515917389382302757366325768069625\", \"31270155809329751863885224732454397292230969002004953832354065319735530624996254695453061851449600345977646455072512400760539747054003851289540339425848681804190284451253462663731135337775088379954403740058084949675460445909826322297817535400604180338201322667139062500269285493417563095365899631360901732684124930296643108551710704785906431324876072470231424/7269578038000504017073007978844992319987411732848567116655821196644382777088703228960020894756722675887473977480537577509061256138261063926845643360849217556370868752909531088361229374467207196928745673402380473721018157327193509586295879051411183657185176812738231456253321187419224704301236205478184115996135940848503487199394612616742961108684539794921875\", \"432538822079707760382094121020421735679118830363764570640789368235407853152380328891350816400541189148550353337874309885334920995713154225799660601389784410911658967499100610376065640785585342035058364676314084595283850213942576431310823836792440218271879354669291052589804956435743500204185107215929849054782893113/100246574739326291035824954677502591279343311051719151327066341370995390423713403739043396503785261917771859220535505691760472395306543276314938287868734009582906895763073519374099272340577921671298878837400921045252035507925021904954445172372479744465666760762909731237634082051855588025732494461939980856983552000\", \"1914333673689206389116942789116917579088664511118582610293383428712902211612554212779880638065888518488492298586641997844141510832940409501694726851666478650414191249534733087933879981733561565249818572204932715347752949087800778646065986244657260832234479202201129845117955957242616947361016603702640821256099895469088229339240402478576285854783063612307200/442333801076281757298117784528962837115323835962460661601905131618341609371649347131724700192551574625400701487125984359494804828935577124602622582550626336986871791407398609915208114339012374456785705161994343348351473385887949809051796407340988735853810174589261300681030826392672282630613354461927208579993042968520650313621522933214063366558703422757071\", \"5704691626402072213006354545292364761246893919997531024861408248746241619817955824682639582830486790618668221530365426203424888737658778881721063941495350237419723855000515747725926735319471480027293210991869255971365522170749568996651406002311020883635577590045650037569906001924971041810547543163363976464780729932/1314240362076792592671773873754757443276256223533339004339330559325754574023619698171225777585408160438834449576526997055649849875516310105297894855264038450585295422343454458568152668980131977005808840141079502436391909349182185596381509091427752151860204235071122788499996991078935216686010888734471173124487937875\", \"451219364084386208718456142329444023337343409261545444643031014769484085278440612677813682892926852469540118625738238137458321112005189595703619178533263706811689687213128887082197330137502064260105387500552856851972124172206996205919556553246133218441769325133725631665593372188755090094541462474970525820334385058333756591222492801647110594428922046641945259392/103648250172203340865458115839764297558925693061798169434516001775068769911768281084188883278842546791612199025413573394167639925287068809631958006622842716869211374513136766899877504136929177267362862319748507372147243911522667591375015611312165464514308451222180272935398828092646393830572838772085366567154646425598388620105539619174837489536378605144891769625\", \"1591076564577634575701791393842535460875733974464805197283632670013516183281542903377750304419996681222758401497321278555686661981435637461350320471258386388843198706277657208526372100698700615835733712519332548607115875288787602084336341594576426630670911478276101702119972195558314357975365863803265163991961173/364433108410193393847203348728981296285742202617988970384277162225847256295865554341611171460436362780497179090329831885853324392923449579538286804729856000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"5307507148709435807261229345132535134848030343901300324623409721698217134932866488937772986386501538026693956121121771089740095760486362654754229904633476234090792827930433598453200536551779789049352131005222659995845427680686677324963223653949277037520711609343166926627713758990384011274777087968799793410506391884872456420041494598273703914689586637995139580794368/1212244290381524115082005575105703496583315188540177702780216570265159923654197746388568151706509243638302707511238539845531608313334248788980188054651601536067740709977678222790481348003085034888244447626347312094586389347535167903408519024105748523384932942441843118813819781347089702286481924493361058339731949844620763272778960860509570622673048786968660129650125\", \"3046577098843580578619955603029073328361298436129791931304665777036152915858575282362742008136721284817899542475666054101957899858138590963789072530710775790433466847100422875906866496318804986202089528198912098377828580031852152997907433335176267300286466072997014023120087988748396598176622765923059385876855303940720/693911859077752895978833241338902695755528613729508555938416419864772385336777924892434701804078893822446727762077537955240605927550548046309823051841326355655848406646248595628715185413852040295631448250459076043816328082561248420925930431777502622148019371383254316636979070731427737764160145097293260938978413488819\", \"155310926743873343426312607182060072939030765297630534544899230213054714482456829198485999782086944271490229412707980997432528653509945301574794242118433868747172279224118534460563400440670015323324602117517342201640016853927923976796453577048995243600967202462466681112804476672348206491490513419336308575442086511015101999847896197546900512764233674747415844045184/35278162986589659300679088538176070649273991865663041616088851923111175518405117391134863644540911005782372831496121355954470744169969774540892096320978686548284501139861783292226140413769665461494668479430833892857992401391262903582109993838728281915806394747833588629467613308837196269424421131934859079260185052081536487462257809987002198437182539441349474426375\", \"46729591025621874782758519074451728476386657576036360734358719976400940301493939192083339293779149127132651616972817165172116269307276487158069293114860391502484125554406945249728802484128756924044633825692779783425628292959170597009935305429239702926898931975023598456207165067568919757902764815108751735753431153581849/10585868084079030838651390738371141142245086465033459640458366146849314274285871375459898014414833295804139979016362796357043372316321872357817727821559232353993714062535883074661734509440994664726425399880995133711038483607773782532430879196405793694658185175583691180757783597895616920432527125993118171361116684288000\", \"3736372348124144720852190769710129461145889011598636925228657393934132828633132357232883470466940330848177425542748100211498184494252714616379450272611850068867816250209867530921278645286769418080018709947826876461419654782341309127709703626401211996255743831998918894661053669189312375159058718767082163156988766821194002596331826150321864927832618126580509732359424/844176851007504003627016945212023239308348428094023437269532743221937069345682900884618378849283002998220513307273333096775669556093005637615012750733216460458689282791632437851364674879152695438589692227159038555722539345972833161146108367329370564838671791241431125003401861887477969954740544092178721327724620450947646209914621007186497081420384347438812255859375\", \"1258774755828991281578968023382624723772927642002016270484090409043454336040857926581316994594109169123354553321469500848146015719851609220423736153365139804086413284787598253618361769125996755159571523632747129480387254164008968993734442164892486441152227433281625391753702577143985047832519062595123255569172968685060844/283659859661671181526547833415653453506477950678651675193210969173130116121017723360258249430884213011988678011357458727603413521688184521573094783291496368005697481333739504490647194454695504722542014845706216224432373442438242355188461951883454664693262684873988061018976711201351382163527093784753398257094429403691625\", \"84932063355292829988908961192574710493098897148701473172754949846455626381329456661808566365329266898990829247446356970454502007127269708487563279536825277374133681167235811080298134899629580318813382668399644553111080625918213250223197440426147821225593304993621451053135332451997633132772608233430131400186571793929377129211228689703376067763625568623535588709576320/19089978133324852910950469658566458037096027722326716800113107848115231563787455584278193954518442601810776347091253561956877155673550458955562102935555510392954425196165785410319126098393353878286400877305164869548380670204577544630353859009177051698096136470072137579698473017257397949994722015089768745013713383769765609613514021200888647472804720456494757423299627\", \"802638881530832431828249604040579750916118423833791608589560402449036920165704012070349537114920882938466635598602387718300074733476150548724726460209016834416094317724261857969955414000155807312852092720310159572547644569797512233899495300028159721348599816083166712365215075728968005941610056018023633235372936903015771583/179951197386119079732438617407921535065140503043429174394605652913879982486051627760652197484142547447000508189455126493868229565647284332735552462525598465192073558793335913005459266977086104359621022691931002488052727597513413492393525660272900161375677499228252863529934576881596384036401784035248649026076581302370304000\", \"25208742399375362881099811032135575360109715964024747212026245529087599633280142314962581193303683759605084995818253124445773115574470717199218828756449187055537877478033129862600982068782249943150019637186466260707552416433010545437321814115233841687700051830170191107127799355485920046505591193770164750886037885397478191534797655616745528343172318318678405576430544896/5637713398995569614196397857525646325234056219513202928587580534159596897880731043336790273040813044077153051260989730372846713618900145444802234629922717464041261370803598799826604841654608724727320798324006129524610666235998113655193642594744544226880944882342204407750193512869672849910003246504052298022468012594459974209940607450480609190841893267203392880360823875\", \"732332637178584560220688900268566130246820235956768724845747830959547501950765063982943061181526237061809052444110437930100210105274824607344902764184151030827266142225894655531497849161692760385938786736436977268616029862577293984376170905024712952813234949508186306774257035535805330366742322777611063402455261391021097128/163377988152179636922409938163005948596822656868040662831003991395905185823836089887990201522673196719628247106777881741843786365701135555917263285268753605514812568258179391272113405920369587922702002732667842511108732068683407168090725712401954314293193572654347237716691784386690948494003094992876867763698101043701171875\", \"22391374854299462107923583267570593886002658786775211597896252879708753450794332301142909715845151746786016535157797023153041007263258732991465037648536702217273897876864351559736449481285518249846264600935543582562018874574655740660800634883403597181876364712521253650744197321080655028374602772696770227741610874399454362583980465225235674816785988164157351243193265401728/4983275997188967758382167867656806681565521964135131710678447245984239733544941881418957694612909599261843693554043504855207170782744518943778096768859337980470219783210191765678908537645270392500777411134164918803949155037581108678968701961544979451081836872425574123683574475790997414488641534074873248802450108535183413970057319247033379016606809226547805269752123746375\", \"21252344995592269775107236774689012760750850598567799560343535731251766780016530978663079386453430272698006977668063208502408607227544322945446079708000304179073184745623740466334127867464883762843346619853325415963062181018736410570113171387891518398846617197097407612852037905687899800932343156979591740310928257766081697645/4718515378484509142377558412184183991357747235892194234377932213613746008373918923611236346330189287336493794499188640380975364991548794341177060325509698404571318037298112293926833877103554546466055612498927474225619680186119313129604319096374924037870803554153458104225741255753314955115645304948564151765516183663634546688\", \"76703085666560609319365659209445044957052359500745196718269665234646121134787807938680787341023203786904308047981099228357850016602203539979246579454229078497537148799349353250167621935384193502383187510928609818011142642954550330069991570983902841318203794113898871515702445720207144863877026526025447819537396146822201819435536435835285098485990260677737192230985069824/16989892821104122916312992616665764943723222199277412857053896319814438961475117951904867066845412639236790762432996309717924037467863024360211163971190006272168845197000304328480920483651558672879967350982199768255256753110375467976246339260326422891913564151453729285191351273342206198366624882195135056176502724912849575385576554208844814085228696838834665339811027625\", \"40153831166521391225489894857551838468150576827129133168972859441122728710165233865309084872159583787083130713473702296122465319276461991457173085312407612757280915853584698420083436946976844240063731333638150599017886937783470942007376523947840104246927580254612991191040951001539641947153847776050138532219595746056076776809812/8873576113581065493273519627544307418139908640325227196912114520903505426722086265723900326735989771660987609604507503750212298754414472822477243293638486047313990878348820573874809636084574108909615044524663712495422565151340037564156235745628465172219286664653343193162657374410926171153516871765680561505768223660055617934625\", \"200736374277835272485186523480177159453030082779872429648449412313247640312479214261681899286513818912991945046297334418102711629933437654377760028476767482162031641781499114859553677502002901248124750539270235098492377826240319766677856465093871367817683734079621359186477306173620331748496369122143019303740252461824523590096923561928354020960176605008889579578495073283712/44259440065125442964014453739391594153290923937737136823355312892557975399035370631521014554980129291582486968083228888083079118116286312583989433037097397252506140224404130371160608365777625538148303917306340620019882928744151294738308047800711028158277500317134537540772759486365658024194428796846364486187105343266398338060080611643110071184992193593643605709075927734375\", \"488459049325494693259159444507437983381645757291858092983371672334043029615965882574409808932509285079401239403272414271652617474184321852388397021836909585659327974611273820676128650810907598106588433939541654215766888212287311943387232664417347883717203611092450971786083806323404432266197250919880225892099146722474124874256523/107455855466267410923480140898552598306699341366032095904938430084768624148829473848763761936703072253841751966906142283640379336131083461646777390874405323298406517250231389493084918065243079819898691146841695350589992171102939046740169198394671965069747042621265775948217054519855346617967866614303497258042439052681849864192000\", \"8430374068596413768975326329313648683222744787097373111477788794692418932056901235174019333392845529821722488982447683794746518712070635063397464904489452840169472596494433874412726723065560358405027764015273789053064830528919091414531400589850704395887250756457780868677553068164933299802944396576360356896758745030955907258232257358056931680617626606715393885378887657377280/1850480358582748412767893656294669486390769246349349706200869446679212812264400876685764762211659843658541567071977813110496329850010288179702589501255367345935389050373021591572539260951149696801665953123597521983257852207280970577287472932167362521740230973547070264273850381896786822127290397075758780174083415923482640313277341120938690594859118603017930500014640169211239\", \"58273615882491925540881784328370957720539797010816130007322211512070634295154626813477498607761260613353633996451797686143131893884559909668805628269959901044961666535533876340116728982072626875010391195372759135469446048394835148654407846242721443845351855234347422256700864370273092971804207514736924787577569355949601385705517152/12763172138328432984573837529764902730448666594097466544652830703737195804747682450548488162227364538052585484418491914323658215406327363805353540266048943197822838925184942600367647278764952826664684839953902567694832690683467635727409976388280092262839126779730168889686628630302519063225007497707028600865624133968363921915016625\", \"2685278694947152969468407055109959900160804835228466214479525891103128459065131221736713585038130737099067040196326815283171857977706979990467444622550497565521863441617001097354649972660183038850033950647594754644997436624623325003537308428828750008305464174443210079059253920383411910911594636045517662796811001285984447671371943267419151220518726940455756833040934506414133888/586864816044968996825907488721678304211296267371936463272955488077666796280028127333229453342355554450708284934221461946991556216095213627059047984199091625921432110913096253352065238765240063555347292393427726758010888546427415276046238297382474708612526770055488323003698641493939145624184943388159614111350839555141202024991876221874110644879676602924730506882384603409121625\", \"27700345710264347957758638741952394530538598225904772664391173119594616680996031886665218221392453628824570256438960349220263575741495285780845399187013582169907518462437966962923592601721119258663490655013419675469864809004562272799012227293974254329929404036071055528766397079743200179924243479370594973626764330855493789112414191/6040997839051213541001279276287478343874107660287651711609067205111574718442229224212245187655300348484144001298428958025052162253854676210451657425437588244676589965820312500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"80160269787574270953020489212619791839643207793889009503234879683494928396231769167082355143564723274576166638869430572977442020236299319718643894871736539109822173538266278165276591962215927816541165548699380129014840956895931285215480350321259054359835472320394089646764361802445068798451796525897304221529850133401768027469126408090577121172238802281079916258951770135485696/17444957084936455555074876721808241311651668802091828589911310253709517226715880722948267977560381436307152342821304525073651379763144281678911047276389231713860392794975453518107055568765009486973017341479560154792340888780337029481646046233967923289468141293699236815196553819373828280398488966665994092877680860643266914861837639322607761804740256920429518434353839878280875\", \"2352816897072623416220002134476921108405735955266703519252095150412419264317091785317803024028565851487861978477208755211589867803009700996828082850796103789009194767813611798769297617674631277847910238088040257037678126316866517601388289837575778165301828137259948173292658462765645645868094197736382683775415645307647043205988394700/510973411316690313485681833991645423802776865720580280058344111363363091616558230182669376841383375321912553771027107891991318313938505988903735114191313214327683449514676737796942389784957658395806951715454372568523597420866050825822028817422805046287798054682484158011143949412956697442991898914560191411624040490122951328364833797\", \"6403295584873165688372907494046202150046769667837790834896334486679541887567517050446119511695248926941383207478170182650927368177009669717288184903306689332746127845953193587519575304974203099873732502605739219028995266139383163062837007982999189114810534856227848568800302527760100163350814120545587074865568436789021082619398126713943637898657861949091545516403987546145915409024/1387794272010111535893205703999712437783041553900341112488641528986385462810448493444968969845352401058333929711237978223214186693177251566069419805757440174840170213159651962686467523533938145629444468366235554597245713128812532716616087753947246800626006504878203666972651384731498770435755225220796872155249202960801768048854869001310722927230237083418017482134588865244642658875\", \"82993247683514419570466529457059660634483860665557779709153549045427987672829778520201315148149878525274005978368939092115193636113741972236218502664881450367443614971109677363668874484696543982239492409231870942414193419634675024621942196087473557914167832058111113476295926250739099284241826553737074679953551191767148712684157318697/17950946423927357725787689855263532224005643859095168852729513034456208872420513601894508438640531171097082516559962755244698695622824386001219435651555513795509616906355363573638916895074349491513539093024980575852693293474288638209680085037286354050958859425647536735341886663074581909148323105020337857959651624760873736590065664000\", \"584891611376763781852144397260140844977346305541197362434227194779766612939978629636198589818106137319267243431810481928639442343946346034433828599323416877248326356345631611148749005937144684862502198147087702668524450709118588741606955966569427636630159793409544653944608958808602551061186799401212712216156799273254257486955348236914237644151956226336750212957092204830385441792/126256710861549838395499078249922986417488985866522660521294610280820007499099176190820291214370699289977888813109514854178180265382471972583921477022411657285850911270389720508719377071949050253246021921916685716353393018411683757067093259101151481189635423399611625009617884983318141463140199839724797412514785751549277231259345923662499623640886881048572831787168979644775390625\", \"4743054867460856425399742072925732465660626340183690464743217147109403130730445842673866624947360862438925194786600531200056131309608642363389833474026007798643235346104937733349791667694862514383520689594596660275306247615314272223660862212527346572811422915223417783887717426641317921972456913534338708745549252254865615725859881457906376/1021840037832289788284691535543138164288462770384961802287250236519983887262771944174557087207566030730743075334169628971336358708580124427857321953981475719503574867471090607795242192417162791762511940848493176847925838738242153177311649130718886794249673254183907621449520415060660496225939963471753122766421338241291756892571824984344625\", \"3784664074155769467702999785016514468281913375341134899878893061325465790589101335015569840325786070795267055386681356241209412947116340524588831510768864231937929260236754881829005065056310226407358204278658699999612596866156294195316867934035877283950841910726224355461522065773816109849107487214275801829843762482082803559183694631856772777313673086715631547326400170962722842240/813783281473223559981291694175087508812520505931454895884442580280342455516154674683217348039336712901850738745276445107477919518905155156380620466135946654952837573797479076027688866326359448543065305071605591497778941561986579230698384305536224430794233462949056326864499827444363206162251104552740175503996670997705423888382328014210171324376593090187604268086334796245552762333\", \"1946671258536842642381655747294621776070051525209940130115769153666368932042152311477746728678182920842238801763565726086459485050237860693394471644023999467670017470376746609892484192072297938254898880354014176373253875722410186683852253828299669530022166361304397631667133689128358365296701757782382475692465977794960109690362462330857/417774039698408581013003883929127512062321623871486379101498968145670269174833505080260389860863417408848209525427705249526516766731427603641806256289098209429110794311660844125377702016056984573671024035213045475132134896835814746425864304907974005950155657789157496389234919107772201305672421982198984613601511388413381215220924416000\", \"328578487723377153600821813410631465225159589727320893988991729306688663770697528156625398176929288628930496338036815910669579019719633124832162035588583242320537435554101841406566009219059042888412893352417446437227440076869427577701706713564212185163005644118869496869980925214424591264870388237079776503547314587137721633918824664946974571838634860386893404364499977966899068777016064/70382695927096628347637455030970644630942872888311870124896575877585692281624151103204551947776906510366521972834357031777287506848887607457751667816514216907338309372900327919413372044625602555866294337672022362865161523684052940126509854895320132828009551012639156341878073682501185688461720664801829933689280752623773789373199210473995823367199793407048741191786377993390965297664875\", \"2617201476921368517857942326432090876874414269689140439151907982631768946799200744678055980827789859579196832718849393046147656447672531861353456343821196812881882023188898815179947651274131166835133965629115749368441605680383605331300030886676081418867305170012032824011912531673468215561506423833911621270680104083533917562622600478548/559567121085534865189976875600841717161617153776904752351231210970240323460800785728739412474960421770806162360125774000625035522428160837855944215417821324758873127567654244465281354654299068546570789547691342609793050301258532586131013585959164719533123826201937801986942606844854123769532447570107525081084531848318874835968017578125\", \"636225736038986537559880265988431731529837451289737542395494683393492040808565905376235074534207026537145408562785279823547657299565440309510931336394031904920056464959974743525662459433889398003683078967642651812081450227654478095420306880762753401111260630654049389197602389949892636943971690212484981672010398108426002137114819838399222096538921225458913266993881960732663394566024064/135776510176793971074115131648637508758953050390591773574951317807919051619690313331192027871176160424663811116849856489187562728496099757910540362703888937768555824513740118941387831822900198029266206334350448626733139136083404404120210893986654422850183837974770675600952078956326317698998103770833069712616832650406225828969036781514645731022616236082175582937900731419575337473384125\", \"266695771933124633677367149389643417608461366874310588884377151539325854547826373711099517873721616543570605935954334944030816383858485296542260152894035979141266909050267414072982042090341712035518685997484257326212454742816979806460287972757626105526907510197321350895873473656215941034605746494172316089636216915825022339855304925515685/56811706665210352283362623728191218698295056176625217939528332247537278605113496147630185544004654583441448319260578659922931798845493756189402805173037491645434052737405379674607517658118427614090338938517963215812444779184193933749520313676564187507594274551791388039139409235056119788261689087831209441779870873305232021728002651979776\", \"3511806683161697708497547617957719390189982761002154386881580160856792742952365159764830433511949678304281539875366378131195670004345568047690216126001067194904446295336734931691743477531830892015690816210752795806120303198745685394015161323982229908105397857791180342330098240702332072396030780386362735967021055250450666535422528637737695053315137238368787607412459874094164027214953984/746741569878639983491390741637813989978804202898438708743258000150996080386381281307609038830698579358879333079215327202911977568726258527646560497079622703052765164031089590965199628534477381843079892123440214378949632707668935001371616475282883095939750704292616758568964786737752325652839226013335092148777788733453702438432279149298482004122593243860829060557386699231448957232420125\", \"499543951252504651717279461487337168721376180441322735807713499521878076780205427598086756686061009718016175215146305489885835839673419698751530207404115002383180054704927695269921072232395828258826213554806570423602966743337801741633869267620843626804016742412046844770601322513184123515405692795346790813502805238635003099976693786012816/106032986203682550514602969462803214831559442358811656484036951559991322084935692953211120289352600484987931812632505499612220494311324679562152078883141464406938524087376964935494245010636163705698220308243980789514815579319533341929989455211613890905485981353837321342730307819060825125980500975023479813757024395422041501208805339176375\", \"8540849722242122835873311629952985285477986765819584558233324868363310302206006773828897816547299245727087876984857726652932481899766510637403577175623031467933486823994040576431755172220921921877192006685053572215922347418846423419683723609799729359551828522978186208983138345476801247634773975311405913274552616037005854836040162212761099347518242200807692224460514057530656658616850816/1809694575992816440924165741094996511361288430727981159314194000585536832192004274726651828760263522962868944612215633976203596150606503849595633388319338251977160257979846235995654357082321611719654136058257458753105122024859078420173515189641515736029725847315662215778251370398007468665986604529263071981040014321717598469319370651877296085250322599247141397427185438573360443115234375\", \"51377057693118720457387330519321684810411289582445982078756989158447711080414032055843805733348558621949380554029375294451303430269197115810494758213980833379214402452992657502777067850631862453239349835215260705131864911194740832694498014048717871429797341104227759557199716944554347879767916801106279081864127192611546757627038037780244683/10867246748205139797826516105458406878398263495890048637741584969144406206902037615496936724683237700974333817527350121106320991054058406504571347680049945745432432384570515723033245430148177097144850158758462968940525568041926860856763884474605057056550146491001458649244094211354153171337463406192651150028767064600270112838159624568832000\", \"2517199821548153657910904242290029026229621935918771922146425373057248090467388430999870036608278542449661971830076845113363443421757278612394167195431759807908413353743377586893872930828548256216510734912027450642648789925142482023713336937258932978503310551945630359646777080073329099268529064437120002567758664419443374110941824106727218341795100740316967386497091058915066147604481280/531524260324016969370728057738851340792702640911631807178654723224511108065633433027773388768889035083734041289308124943130099580765995149865288328550751289346866467755881013217287175392101334538392596956248952430438673292186779006015549928829953979591250274457658042926539541422697852390294886719770034058916886894408015624288115732154492554105512936468520265305162358665491880968652687\", \"937159485027553069020805864547349554547661693803137696125140510201297417077233061462068930061915381468160677500445535971818609631674361074587732183297775728389124966713749450996643183965795829780345678634356741756033039293590264355732129789110416943789326482663579413229893878422643110852069225671783017610387570935863228248464396615988222968188/197552642195166614912991396771845374656891854357948006221100585931656016640982345159207601253599235265353060942313995345483862152489766993442419668492877390774016299878943454249209917002169480134131612530977452579520564400124908392339263545911443803619972765231094502745980083350567509014991735227390978850048088378721210219321877150756855372125\", \"5119346675109082499980756672052066247676641510661024682574296075659671743397880591881419516307292610449161239233139088348510165442597278965718490070997173182184417648987611422446347235659085092530927312760229499083348217392125906851921500360553758600756698605047197529446594606336369425040236883171542367713951500007600355406492128741649090501989105696576697387613035366083536629358444229248/1077349190930018641197987339365056771667455373500846354778079878558146320193384166982231171317419356136237346389570422332278447217033773023556383420372685049620361481309067017697564760747047839930422553324681218253359586320952896352245366885171583221864112040038531116947187482413031483309534553461613717398523132176948321964066833901215878133594739833910960843185464241840039390204295097875\", \"58469980853327028628854378052548435225264353747414624620847476036979290604604988637469977624105451959796142112200285366199247075503424204044884512269071061176877225315884188402954249683107639777479663275428465242905314418930053869461904934138752031124685541853599407727446896558064252696813370692668496452783003306386669962110734257851955001481/12284458784412533668960387046583440199646081362484321078872891438551639470826582933879934711861551014258493898870867541349962531447724393381011633785884743889445407749238183080941846528000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"632694338036291086868292541736272151517212971647680989553388199374739841494700315711180961760384484042159533979873604395621016272772109619401112452105475906812313548587880899058905419220497456502543971131226430775692744506047039958551641270070996110661036371362526401525207493270590999387476275629412687473362310414634469788979236895300129227082421021999210841384596617452097273320509348159488/132710874087075221626157136110978536488168313127228703025408943153782802265472978945703742152954881438058373686972477195846162708986982742647038014147903817539418442869011995988024638278746664230046452545499722614320284478925059527086663455478374200352375121910000967044366831275681254530914306064535110528723482282501358749001657608122307686482720926189537227492041135055090784059994118192625\", \"2022422468242151190347511883185841333968390991430363660248687284021524206079162212007263606819387821055183192871951076644707111802972354128011904720586729919826758651167984507804867954970064938022106484656560866447290934136610214175516487579122328055482392137619829739560923807880779865442016530712986750711199998190148885726144596663143651240/423528009127070458603837580844559347493775236970253513203186912091140251858605354218715508091394564000304400858761758838182654201653901408046974668599216804223721114331085507752600832390227068985693006017591304916519540245902645712532993889000048992026931475754508248265356181099817467608863068068953756055334213584649136541490530849577363647\", \"150542201776735231618709653388506394887777837646651406023174643241783006776019388336318216053045300417086929061565868663031237502137150880313922488106751241006715449458736723129545400133450376339156062387859536289694727635468338235084533552501618659272047966040838509286942825414463511175531001410923014751124732748099355476332649458471135027773371541572374016038525336728276024676601778299264/31475618522527975728853391146702172347290819252268551219771201846701658848754300838383637247014705706066050673096278897933831272607774110183488615338021656923433335661890414740664480671162459271850877855521869741833030384682549648626038314686632195158507693321505500888988183270276134667071014075017317692121986144742473139078857816578133693776368882596780120407949076129685719314703426278875\", \"162664351499283182546788129866259011542529017155637405328005084357078048074065548349602626724265307733005745244338982661090506394708170105916177679714664432754153795772811389612700051002336719842784098507498286260450939289109123759859710248621544296008356071415713931721102824434964336667980062728653562369697289761913925215639430496443820411811651/33956433298509232632327667206936379248172049619640091186698677954874297837764235300806836350019565970550533206216590639008637925266405524715041372407701947953283803854153876844320283735281209725651036513491246238622967031979233265136280687995181375582844780830517825595245506321879177965868747546127685256867456319112247572348416655367667187712000\", \"27228583713734183629451808889147559240254570554044667607519238865891084165382075658707675405673276615039702916443152954157535195508033284355580742761569101934821088036084480297442018005972653124248838420021440899368869744141698556359295489470499243402799483082406238128875386939389123336303631993557844565927960009744780823166462314116039469622216263221278402673028225214534859076857413557466368/5675134787340359276387085910732530678163604187009567576895331134521132071092293139167824957253050637085885426100206370974479279292804959049999647539684766632278449357893560561608633329561385765035738071726214510832066885156767060324427330401967034889966727638276371320401053302413136551142103678412692111973028587922399670456670380189570979581674699102934733563330382821732200682163238525390625\", \"1340937726818688387636018677960518622106989311577445614347061615417831160296369500704524022869612973331444242000788110133157689786976834913297544087249593601420972111789552905846168933014570399562460789075871112224533723259660967481288525220689577290386781169316008987012566216235876842757183233207943071523447855623001920854571597886491163165150556/279054368814522483241446594911968519760869180429079780837994812436395792594449929617293503975169489945136244602350941695478861584261665582123038340824700224583170270427163469762789603657025958695551448477050958557681299495041994050951692916032501884523150972841782658389836059236040091605838583126400660344344601879969354053137568588338096589095875\", \"8910951660339249479517731530773509037034977353457185453617569046885132434552771722727442649095007828468878374139001808825741829728375370140505088133244952288239619141544661695065318568074863317054989982620944602245967155400712702259180443238473885690297281525960618905625084639870407113029712510345262279507055197024677292523214467306898573956604928730377318210588837126450942086527893437954864000/1851573255256476362977604759655284263358595254392797078730401113550522214182030016660458780180636930591149034499142464357511158868625309442843792189394292787657774627425816694628839987456477799348874853555586931850788645677998004186437300173080088839930384424797706381282430208961565555953254145002318893188197561315855286173276564036402546798318351229978103276843822345004757661005876638005274037\", \"84997663352987536417038496128111159210386455419431137931308301989414462311135708114322046234708053448098538629166672456703651524480738219822858469100454933583774404032968304328859365484249897913676382909050450855222567147661842184538302991526635974158862033287154321908483007506326807469239745851379559259262425675035790574846229470041596801343087041/17634687575122715507915388096857069366146981156897230620371714518707518105157483283253374797127075689236298114335734874553183291806268149747826050838089931351158483980735336772879045027213982661634865556129548356487722537193914986994283729746578044621115589195066212043187229606921062007047940293972381121200723292297716621231320254309060321476608000\", \"1648849257486312935416274009474520589799750757877252390543329851029437452988499485179026845292068377957697884739052491455807688429630524210823560524122596610276957537756142278585091315141096146341773982302888007751632401090642472506538817998043326415693840862261701364114923327286462650797963969289743571514890723145251583881752876340628073395708716735192690808352188867334842743895738955762067968/341580411902962140529547622267381834425264893226447658723654120920549166416114849731588552578626041597847002946105459812230979900480135423787717825697955152193526724029890829615845314765605770060975538542976523177976182401820926854406945392167140347444433885786340415437006775075196031433365827874254477351374236932624514469241634422312990555534789607377023339236417434574755566856489013828206625\", \"4899626659231633406569362199187192352933567344960498139854460545644210119722856870634652562532083546344965166340063297647520613455037240144734014575196764021102614748218834054157165781057405100578668000290493431869797883155764963238760612333048336953434663867580862692267574574465371615023999531030446250351305046572267686566999209229202587258144318592/1013522377571209303732207048597964555261512342860326827024786500686692475697570284120359840724596444209277948648863014479460188496587721578075151793081823795161404110811480269106846359964436993190293615381593756076515012514100289406862487971220020752628653845345780766244842386136740768474703009091552043945843632199999007070800871588289737701416015625\", \"362903847358088423032098939589019598036593525722040887883164115981767777873860799955715587436566233010543937498922435963385091400670303956612881974450548904906949032005878241638546734597308786514086678561900713741746905742866635779432216761799371793260025549698865319760786921444505323758235164807966277024031605673481480590193724980659448692487108892154809490199414370023696404259691299614147712/74959603173756091922435708504751461448318819548943586676159545028063979695880930926805574951275602951047845904770828900645717477098988124553474616764040938121171776556999069351772286262529729056288451037717198273521810585868307402693261479298923209587143468206907278220909447483738730657438961435587752873879244136801168836767273934997417156543866722171766794171623224855358640156858606843576125\", \"8521348154958613550574095745596657249924328336262127244827955886474742319277424381360677655239017583606851483318951440691757875270001283229585075137091617073509041644097526047127618954293881264113694362598157456878784814696577083997902588926421675843291157049153701100218784481406086810264243143337016042301806376864424632290226377881206765051896745/1757584673254145109614914862134217345456065873908262753169404848658913774363650863904627183104777337461445063704655164325930891269843669860409763569362863600932267319335889540453302785099532688264425988677082044905948179153286276609910158854349711054144968131934713419772852663860893241364433872853338630216232313607969790083448433666334742108176384\", \"1802461420562646993856730082999823508145602238125054717836501201545920604020389361370931345491160549787411668288359013059160331370751496329806488246135100776263777863399096485894306306621852596694700845918608199329091852956315870664531614358379176680326508877329862713333336188556181470928613423972314983964578645688876556351433429494008513812136152576866650152623510296911708111085518974142728903424/371238439252064016214448115231139360835481920731625321084601566992497057371416121407293286027832357816257507287295719261141426130159269433199862002841433235955835172774430690352481806933860390015899973299268361513643524088242973968537595085600335021120523852420135081643310663869327371821064862449426404044951571585406092523478861879148545678639697679215289523234342337347529225543852787599016265125\", \"88795280670112240977945082069219541902481768504536167808816453021962616596410396813316064685579412429940019071114917828928080181638058444302439626425155946562362550070187433083541414569447612195370911498321149367969974762244140788494955146280201020345849385865084095189982291190135293114489407801749533448443222584092575861096946605418438181411489276/18262596223069549313969288693970246663726147886364354584825624311486557881239003216971630599389642752648815377795018130449384513824927138566203714891090017787258920529990523519479383032564209629983810866231367438270859421572641494420831435563580050954867101292568399107965982704216434467243223964964535464624988344342084084237484262612100980519602625\", \"752911409358158070688133336918078236438086521781731735123294741731669530734909563155732092406099003582749182967246236657021875488130304108082404134004381196925042617909108654109138702993903561036987511410396567636331465803949049946947888490287210013788802287247422993384874670368649616782837096233384279817294778916419067404863458318451722971117669642134894906235066332205740872938406767767019265664/154635332883086377656813458754577288834216641577439356891585125701020579768315520324293435008561626926046988056302745604248220408154454267643222328696606367409715369481567213640103076112146615938180089303294709009813772509602954514391675152597458428326644988225555987883250642389550531163153338541870029415077982539614784206119074702022117790679351778993541426110436276530890609137713909149169921875\", \"15286089077439918584953144558775765002061832952090847117286473868694909713791678395221438112006475047633028543501632631679316850512797978594476229228325228403849089079675681042224057234415951253954044235099139983386056610384489202589484570852048157272551098909455253037561994944665563291526597323199530997923272894119350512727802414680772513760081360291/3135161418037836259442831302977219750614726139657718770206960776514822107155928800694375522572523712277389679035632531727155957120566617736817225541673148354829212969778664144907503411589126111888917929495106029890532891919001138770210977012708107496187227751496980000137223047079127096028939624830654227758737339725345681745847598157538483308068864000\", \"17723482381737693269787076798246423310802126092500438681864673375704464394105734049099094818738115345706100191580982712146882034618103161268453808819471603805345990162762722549964406042295355916458624836894291267553138041035528315839108252422478610879301656207772491548742981990469454529537049123948604931661837539943536878260665617524824604291547373872716194154198824107266275716083848262625068958720/3630091565725887087605600771358216927099748013831912080380983545872077197366172619225751217619097657405660172801849926220948413919823038425519006413005998509677472226729295278652284861834178791332630676772284971762683579047508016687969040658592436230062049051143001484384767836353233324570686249824980508520186643477313941054900197268584495128610811273834192099099592687485176400539748616360799518357\", \"39160514032490258389003214587901781721548011632821053230881239001436341012396166857515197251499460842954863342641015306304854226194551189224721257664420778416733889030680295206179109679627522113592373938602737416822981698362363553492610842201005420727750505681358595340127099855823746410663750133019743170700888375554918213182862789028531284364877435896/8009919337434786244380818390213546866794958389603666737562053423775386173149395943310276429895991903753441584557917565343673605019989336264748588735390182130334278887642569515202100870042209261561001627386525182096090194076839370589780431326097965428311786635366819094633651297179987340498215947144870164066409654464551017761658775207392803825996394875\", \"18188388167811476762477659006849121912679763597132233588170406666718758511478154418948855160838212151370453213943784067796172102916618102024199200086478021533171984254799008541948973652219533819511807681148179806051835318645591102296256347927018942348574774821478499092054497390790734798143983945096982240517058861467440217558586822663985584775920517755909444876443211404222400335500608733284461685888/3715278241795087610941547133490827711133909145414878217965273061493740719983191775105550559905283733134189195190321643965858771461560130864714477448011225816210219450040558581571206711791272284197614810026220745160693898421068168630870850392739817340370146186703867097982858560347971281142766235850971837330222970900661653800041795020382847588362774677568059355238174402415384788280852059532958121625\", \"46353430636874284402376008361176880938798775506236714098123916668545331718677407145199311191108199195405139575147933283523305343027297808443653460575141799729554209181454676876263582758919969948546918471128299522715691694855904535448703118221685887195383025133924852224568922999317583667985459047407473419196367812949579858081181660610155317911318937349/9455890179897829052705408931064120820559254220394152447502395298827357144081378513080398823188243663943177539817982481713456798757563952162598464929784370305696420245648035222083207596797327498500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"13607414211126412689435920170832779523235279308039712294681570127241403406455725064605210473923965685858012114332021572088551127762628892611459785625407107300355287623761046438724706918300976102581928643740596336865698485838431972050267114940079353996100620311097561405192365496385584164725035842307146351211183443267583872067352881387294766804298681841402861626441205037637282007810811602289501477350144/2772205947240095684743358245950494400934136973845543049938212403703005150954425087866758842625041409060217562878157900197951382737615822655863548356735553650755342108183641353142157728364469706919993519071329069805875834057743793434164720370026073143626055293058601124362130539040404491770346043977106988100969901297669523170508321703496903672333781306743488573086901583022550356345156457496396749797875\", \"23264350093315690507131500726914401771633259602904894387312742275462601574788485574913195967854009886824436237740789910851843045306673524324611130536719802717912615609109285261163220007241492964833933975789257681755002054890453747803418465119567389315754801791950553304034666399677630030683759466627797123971742061866928213780452325847848901682792886840980/4733430508316851445525799359992627142007028326865116523033957869609125212251136452396410236930025876982265915963089597825393317909648054808274488356887197933393799241941120691826916741647173843634076299630884655997401370400734954098249519111198509015387869462198674657171808841005212058822254513429836457539629035675822719720295352508916898476137111981397\", \"538960934807826161927564251064896730663918579817797131801326848839524373936888402762331254883505157846659830555799909822861853145306547699817986010353774500545305596630924815657016569444824389893996399550343022444937690798126189162954188680257730893424775303801562327757655350002001080811866451425665301674688928515041429654624970707803336800125648742168380676815769457467038849213225206824671025803392/109517448833211208909213522579666376007937648875042608355810687327424621469323788799169718267715808580775296460944943658428295481347915131091297305260674731651980547668762317138753250458639043477453950774629862540017034566407286963562574188172753764978963685535201028286359818524519980885827473904574840285411260037264057197155527809916623487144493019982419606308144576939532055057697567269576800542875\", \"24451481554350251656598350124163983489544445991992661049829014268366250968046589127810466483349378560701491445658725080497078590986743512397927747885285095846398852574219367580068049729894667374214861939897557930527646930793431512683750733092448862551580494245486308114129295467976874843852138144539250235632985676953662288536669286915983261820949386845806781/4962240683851186225340479316959605207278948397833849899236383273145853045488131674290332609876751222112917095096150531825255611911377071887145019702433883343849119017643117746273523770961304609989779231048095665388209125939879595509516490230961558353074751312876252070889983946768175488341370453053495319823381943793679003096504200440997908071027962806272000\", \"166591964685609920525429719961758335887941461052357297159523350448241484106515158310298216150030768812873781356326923214637847449893575074813991141092681107583183275003570804134461187213143832123628701876041315736048451374824101256980832991214945762266748755723551899001458245164317581617731332466039757786839492869211248064662857987111284518155462148044812626055842061283907063784492325693994911811072/33765943466859756347231737285768516240749714264564410814839966011490233598006227246396923594069488496368994857718734549787000213944990695920130591750377483911116845697231074543526982580529937081378303555262933800375576494067959129682770065443667091668104132884375840812635624862495548888467575848428463895756394050252457592540570490061561616914443009224917652440212112452400106121785938739776611328125\", \"142464729519206642943985715465196065680101634264787375740459792619754842396453535646509170066091478069799080172299369994438836484938378991283020978342879057271045033903518255546705211647900945143546293360496661466657600494787228476009216508124736254967761901224547269496682078470378676865981855568197705507111970901389105723589666709580851611656838285777566736/28839643075889294346635430272525349651555039807615358795334663734940126053968249608601725991946342449660829847322517564370606746964714098508298705743689729306507554363954348780144675937510900983622836770223945538844314468550644543502501484521561567788992156632892028591678742014134130878101553633195551605796158103033794695984958987367799607407626319024034625\", \"380457154857422076784416625436182734840012277442496600178664323821064977485271288502806124740204295811759917468598315932331219906040253463960961995849761235911145436552991677050565022181516596464968316292789048809559129516930574340710998611088996508613850407294743457197519091160170604426002924022923388338999324182261954685794522778833029950214443271526469607532589775916381786492089432407550224137344640/76922142291839859196033215395526448408989799722090330866256930898223012427332209054699494033511478050536463051459450844520020426942553107946282832072826069342120835351421637970462054707566481086202287686453371483126873188020538661871147778312986131920021929455276187425940666580158173676284545586944833678819622895550345083175685846944633982680908505900099388037050135210936852210263717185637166725605577\", \"79999800708369666670693340813609265988600461251844239982904928629083975986385235816587497657678297663151298709076884516168798694292862559083730259839524968813932151813233366175091317046758260934357096757322369138747731224414176608247605314668045838769433811781490030635374856042786947109101585097035794969502111354126773165391577217071956928171336060247633607/16154850265413610119312596299635391433380319311682208755390341659152160578366244774029302281068833963848811596545791104919556346810193385001196395489740571188884873246131813864782581356887110499639544662322008824704830818136660544673293865921754569356583698951612797219776290835161780326945625621758204931298948625885081325268123344406261740843197232316416000\", \"26517014004241498798848003208133111307300592620947908933072661812816683085261359696887064436611747292468717739609776825664344064024535028242737616786238200200498291226984541942836459188328346609549239724653950302145388877472274074665166631509490297630344351573245265440164082334092997307729007429218385933622623935704482371360985836659823269511115937443161532987660855490906546130131716829909388620539153152/5348257529530073524280989257577050878033239486885664777340947102417077875628238501791711336803418503616042922880218860266611595594400020206192599559925169589023339295256084579966533260861249529670141854632965231468533448709363477120437277477668173149958267956654411822360053335695956270719680086524322530514249891157439878407417971839744392044064720476417844056346174795601710447583861127956455406902139625\", \"71197348290771978405602732839537012310626009318133570890482364371056186523989330157966045289127980687764218363064941391483781008265266963537623770685390148810455244349859354857421474277963009857011653865476081389968122418691934354122230780300833008753686234433642072919923583176333668289998661499146617277981691372057042930131717336250309680764289256080895092/14342680993892886303954853579883363225921109635079605392320944523109187641283117181461662846411912306480691901515655220490850586434947504504317080144378185989596578890875561336496479576651516902048606328604696610314441229321219627021610788398730173161473456954861916116391687748151443335513249810808309201830214153565966339609616397865465842187404632568359375\", \"342401018754023891059352629509715357053454506037284788725127073168445189422181540408896452651232759821766616850264122591225331120588918865882061344322996688880669665450231982002597398732201789017495427566260651180470635467002453249479483900268320570004293679361696197905823690145326531180324429318916092471863347575533714871355651558610515931373080997536792242278529575700808878786732127630024064418468916608/68894647682461956089382461406499759613691148650738957016015844830333168307020284281532026442272618372290646283794122772122665531108484704223311663270836645399554940741928358317884620420886609705267248656765357348477857852684140561714900614303731786621656041881975328169543884661780531057279582784036689401206706069028229798913082362331334839997133771880514515972024899408556517159759907883793675672065360125\", \"190286571838805495686895463752492174798162827967490343625540320679760700551286395956241059969689020885714190883323266375067607282890063444652926151862650426323339187596278760962390404656342309737428214493422028545912504503974763216230927196187743439226243880933947417760147785405444976177822143722569696182520826218120595298059020305548681823408268556482981325/38242608291912408815838081993045123864617058390583394828737640036167893859507494091864963383596867701436244007905770284939991912884465101575490548813894148831966132970730263562113961685364216989999844961688441914455435934703797359360780356482629495214859917249465567846934284121032247250332634283689409883499295469118485912489058982596725212975311140618764288\", \"15345379701153714436938289567639102307887273898834051456693981514956329731572600026866162286097662958712922836383881840211072389867463987895894067288699955858337488812343674818565432780224654423872618380928462939482247900055572079914753652915184313685270722583926261499687728814560680092231526501970431280783177357735398580700300402036873780385926225005561766822479878280891130232036389707452005183370152749056/3080426623087819678602049171756961824196425548529619576972793653585089380165862889092832375934535464160425580449193072125955685099151500755278763306599307218302635233595329082702148677300945556130106197481236122437978375963261172524503625593066102601042060541617791008722569799735202779005407381267021641545644264334109052258081225159748043792288699674153722046659880085850980843460715080965607434114275256125\", \"36443601662144279337033484452272105547257065463167427418525882851507989449375452076227652634440476502702584889057376829320548464677623038648843251719168810701744338735202853412651160681259533015293997501525430222870696235141468274274064390273214484922080219643095978640300874086585386991338440415203863901714217818222666715642467237183267303214471854472286478344/7307237990148312451155090506264642657872224684879860008436735430879314349554023096366846856470375025555139219961666754780864835035902856314981482268319886395881809659368275720375576152008289949085453326722156553603358879420820012964006978808113307340321824660484441618487292138631579616351777191144073820686595597986548374588839763719082323114663844043046087375\", \"1575294930860663922843149113097927168024893739962464327016763741314068438447271326302129681931564068796631337571133444163024224071270063174829664848259482066723104251718808936762938249028582992557822551950212098797718627418782376027133576209718376784834456568694813577764300716139817031545408608110880973380162736536313173329973171844528083756524804574267826691156368696436273087171467254161930265910972517504/315498546654512047637461608750018349421492986465373840347519942494904200733840189483934245529561231604050629653992944140351106887747105945984325466452136415067807666316202346895657914393512001212656936450425268507235863153258769360296536050028695266363553141327896064944506216017933135251875087069031098099192325817395958019524956320840925176589616439477134480262100237057953933117460110224783420562744140625\", \"7692057599553133417225997786980128299372439542315125030077404519679450372805989755158000864378924877036225189784045171045139667691524763609840822628706422918926410377185494048355128046783294954373197082851501927410350313585640237550107070936498164597231431242858771457898152684298047446530220873884022213114819556822050178579707210264243087257050468000092842761/1538814487241112760739561704846381585063002784795057066438330325566843108114787083741788078680861495340026117682606689156065008672344707615420501964123121620401073675430690541617930520947170306763541251152854304975131871537939618684186766168376514664494488691311397307418298556185724993104760692216619178358268934740746932420562664234738576394742559349407744000\", \"15190836470550557926140012263310230378455340797095100474720776113765300081463960235506950799869073894127884189857505951314428810423734978025409205413789025720642609035117121385453856877706229778165533034683130064865256448444765902482146676668197546098809055341050873494446231793312407516463576380102073171090898973046611572020564659042146465345334273595086941562425006763960197801018796906114925005810069684480/3035556598829526968124942916297025416522606357010637652635799096498208643970273828496655227572100159414352020909846298817521082538898702393916708804775798552206401718323929157863173504795127180177622667376867235806208021329981136637175570409791442328468473111768140746895005561471574356889047981458002257872092408771959478275534098789982899056118498417649167444480913552548249005268380838457505944462494874581\", \"2923754549090941424546974281011770689534961442264350984393235983189168024079617848190236639328676436485460311093391982825027512234467853098757486086492333410753919927528867817406389678461354257841007722472106464785557179844602277350411593959136520732862935740433163383885526249897183805981219416420390137516812715245569037561966929572448247077578419534651990827044/583599691615378545100950777601104007812792435102945248411439102112424251478512952087517463400054567832353967731887062349496616445419782499817548928078665212077449420216892583997505908858360011413290038645573504472422610780073975450391707084016931661068694024023083417126286468909117254531307085545768412513447197205482285022417611018126886491416133665625891075125\", \"441922815213568908489589193556560586318864326425397702047965372289295962228254658331201274291697626694859414786292266008476137667843874780506886929181835469302142365772763129838217316953835831059616268288399119642314758261677639945004547833810080700127847214666763863338091523753898362699222880772298183760217731228628442782431573977490761665091005756534420789258276075174436091798475838370152192077494553263232/88113527373573049332749294663402406454524640221866407165839162576979477138694653404281889227416977618913249275712917582743426231744980461918772793673202077716234026090308791893409200158969108910565467273725064769890443408324386897017825489615600787634985397885230455168591240328585041836771921929567914891379235573982442311269392541694564675053636078990836491104116280492254795616055818375774141667319774630875\", \"91197133767962483852278456285591810579974783077874307589555559715577599604626819245000672929518645004771085106770784762994476973842713035791487204122653245797126906189270204029735872508462106527240320932458036231707311992868347221176460407003487373754014365881209649632547685657666691589606571865740595829983849941049450471212387808617247938941417000965198123059467/18163679611214677813643455199979098261849405189805364986036911945012016248297645596270602508015864371788974684317239728239847888960155365342460843559658233069613218442910226128113196984801126248862273503232000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"733396724434554481470656964167233690851279923085197144879644750437402627936723531635898542414136943003236478432848965516925891956615111678444586384493883113385335463639674699443808084827715994137410743992130712903997815471369201406683862985677774155704267039224546352414417632475628136460919900347977754644214725932476856018335195927604771408949980634142255497812566866795799230501026066145434755838336990365184/145912495644159810313026420025053989609942265686388630266226856650796088768164358961644113076809511566125145395699271530802891523741636707532676065833327082092521989958971154798465784847092870457944857590623097781956884297103961713362268264159015928554707158239398721416218953003215109202771651993622244788505649098445109438104466256408060944298437033058380804126574878377874459371251056800895394904459469832875\", \"167606423853658713615749101123336326908381619586838606922565378505211386185130407423587264776519589295420758009764678759213587906216543160801059029133457062067529468464636376639307690657945597847080706144898920305379653754920571797771178341550808041652360635584401789901525709166172283390177673009483341826911179861584213314395893323035527116283758445038413646757280/33310364848744488727470761889861069993071965180756187311178124887286133554324042422503263994717993129539448310743598138364172889305532401505890384806078790034557049074169245078416704866867380089103064821732673967120808611636618526737138435792818828990403374766228037003927569643972203993263329403469747342204808360947840103843317533210523853631711601450617095736473\", \"22466735478643771803624909352181817912387732117378538284107485621001246177152644141853604633676939694208131243081227668237716194316732125445041260568403752325416203858329469477774720998849334961751541191761521224644520742691981372782009394826739249604257098248751626957528543558542443122470657230835176462612530464044652140581367666271771882198747182114685116336512604038833327707163107207664705120728068987996560512/4460342260599110071819142535903990817893424192972341872394014748315090430999224107274777695306032783105944721337053156074851240201179902835353097683269298594190456286888326067932777720561181760369783486872666974623910515795208353605697065447942804414120030678603538761538385793829787734830129764152263691296719726909633580318897787729004972323599773548689272008712427926734258913271101899780538635213826239542884125\", \"1972862002066252798837977155272535342727415329632252213508267781390870646909686724955861608046325765650407340102472833428905279473185818898693854344138403744757857928883601637909604082588338869612221777263582365745419719805587946558326048087138197694016224613118304623864709183681172362693106460535117459192992832969130895829916210933710820035479169562970982784580861/391262854245936198649509275719624152305206807261382621390946060636032376057385723427601113233050260359684153963520782285097664628279596618521963444574543409076428660874564026651742234728997339844161514273669735686516761239076529088145208958938384732800586298943281728435207452253170935715239392534815683367114290676180839217919539381651841151674859715992309727232000\", \"25408691426286653276004556426513401767718328640048945917745783225459709487487356095164164652218100925888847689099153320777389381851598236046402124684511968385325107497047025485302333503075085562533472482645023963717347867696861885363417595298751490212495932766872748125111115039311507374363000062513977436921772096443948159289707996749061007112458126301618769295162649600673247799961118662602756889448152517364992/5033870770817104909025512331238419776407331281944565644457345507262881100618908405924951559853352841154730802006750688581603270849880756026262217651685813584900300357685874044482329601894134443542753690048962260914642678445058891387041919581376195543193199307524572671344323361282633828144708683536721118910549933336800461248338059209853766305058943888965279863852107507075916981165164543199352920055389404296875\", \"616565940481577765011174617619124841631603944267256178093555235591208387588894068005162766513720546626399308168923904625210748051788652328072241494243040185611373035059619136712559505023703153194815611268503291295059648269772663939137446253437248541496631852986499688052678961495116210133458596866684413931188348798244969797973846568160999564540652111599082181871436/122025682149627484528651507368051367620578469392233875493556828623437869650284356703295836998178256875766319508797903923638967073687991229708051285605187358616531926112736402511567721889845693991963610192161413692928378708223712791930113386840109729368772998347036090902364801014045328348830748307179590755723160142468563977011700764517880467116766150322736003147125\", \"979882056834583241477188686550561625289337025747787132773853690143359657519481397575561812727394470125172272246774578404543257210124412718725081536309818383310896102958167337333430555168671327992395916735022711297435263157670501117734412587691271084981140167017421900852550822579410636184333142944411060788723653596377015359036101170054828623669169047118551010102258802465554033173968468183492058271365801755986560/193732066620504775981759812703028757608600125742477178751189607602983198559778039141192492589734277739017909889924488699372940787977794555519474807920198944109549023547259912324279741006975129518191081373554817584214941629021088206977532599055014150433581544599721903881284581257812850697423350805715586436114842183295730680490110793225514602133304729484547181740290534056445482186430729398701311563285494964645419\", \"1138059441890428903336718712159907364975959482163004276901676063186939296217569849990951930955270849692775077813359573394435924934540269310629731801376134549169322946310756738187834128956671195358413024062230774111935109203207768898525882417078119314003162592087920755572050993355843681931139257303484526223461840939880759908449181135029327442039666513325916729112853/224777393704985303260433439401503507705148576727364388720387174977154204629336985298082893443205223017966145098064861566754244624732671470935725326043491911142467178027013112527668183783450932992534517827863293825061296257420183669383719043873666284378647952385401303733274771042385666436214517205678674213118374889121542369996042313879258622144464565403138392064000\", \"614262617634904509410555695398092190166323289787703954329113412647342230855826568873946233136303566178604275296873234926652080462259552775254755109931312516616838091852915397846984381183732773411263828600108443070778861986849272794442105107285234729077818614332155890946804257724112143631642663084660012362691100872465148864413343598067567142977134846266425075195546265101720326272502009234689388355365794889444257557504/121200854655310345878069155190734381476914416893031941761756379148622591310152793328910334357724762079139509813381997287954319983165971628429295803162563856219211627796200599196263868781937234015821367575512548522790158101892507996780675863234181700253545912643548466256938936835469646114659598727592390628209362096738343417775009361678599075671154405137663077798419897932404104579113056038271753988669813988076515476125\", \"106893445531995430131837569895703697604978445859412739331042151546083234373443601923983714252801103551874986033841637079479794895452077803182698291822629713500021995241940133037200268381793282318691568234728329378829301282121562652452936297422136961147432559766896143081059518238234777055931999714973999553456547746825617168005650221542417216291412324174772893635832/21070287546583154895102927029203125577385528350171457634203261197137238923923245382493868134869009844094435068284335909266152042903157700510534904847257436666980671067329084409346149729385625108233234542133838924281113454526471855573271066865534480974484196644173270141056470857666632902827625475719738076524047736123182255306429677688129231682978570461273193359375\", \"1112742798776748551928744983308584493817112400536084744850969025063360679785378789764875076529575583792571198510306186417773101346425704969671256564494135750783642910394213727189639661184379341961737135764570942961692159177189753139209638929302928699705042832922774012622017270172331722295881412111812933593370743210214549038212395941675257558442878012136484052827439007483777859391215222647499741572327725689840850048/219121905514652575155579185322367175400669386131891843382447432851122462422992147756333729893028362013318264155489537138133372703295804002840920402482110260590055749843170064921843460498824128274420925357547023876488939786863662801268798987685503391058250902634999352652063668663245829496836853509616873246554292796823779397317819134891873583857621623143253788854530146303641400986028503534408870194989478421253057625\", \"983995170259637497940121707857673268620603982844439610076334749792119502557380361624096960070148627663305171311646851566811683351232268240169848810658089698606409195744471343416197434926513684882439596141368794175162315633192028977211909698595778839497844847281262559899914504080092844816319298286511436690429175757804604673752838786852277255064434365401871903307643705/193579499709739777577893639665643417521924510242119561765932078835121983190401762561436208758210519231103767232899529457440602166918701550386152070813526760823513884391055054076485295945972185402977095815609448651316824455250005505410192101148149284756928250258632031981439345164037318129987999546683113483700660879431801728391911161900686707231543216283304182063038464\", \"30691013076836380319652884848585431917439358375118437035944950498156836885409110087616602043242747413728866747975631727566613593257623099549583001362246649928075859944695060947434885707102684568632559339383409378997568182445019183928058902445738702610436187907199482604867148445903921474846103586253320950728989228898324829144701782792767763794895137313050381112872972806712570559942583906619373159053654481250809168128/6031936190594376585238407905469035598668211679521553144958053099463931217856780171872253258738635531385711702176347575597387389685526098889278278029314982721284691198967204664771178761416891317672705719303088746953644978471289001577698554025410820041497108311270431130911021653860874238212040640737171103823631718483572464361276703378587106311153455557896527384426327053165214814954154328483257657424873929502112904625\", \"33633002641218571027682690377239300567277297301791434890431645909447040830457253186262970747405514897340315490970846553666201190386457221846694126637998462873786334837901001833771510353365825087187582807843940479192544772559118293851131234910638705258664901225494129023244916125545283621607920983287799648992632814461828998517949449887522866259724675318233522060729654796/6603800575190864815125307817934327053530311915572323544225173935830559756077637251538096164499112411672913910767032482188570876526606118068929913515497400397562722669603861813453418621246538114872330536044519242663538662076583511078523573320035084744399535581216815034837553165853576616422592790103728141443697362408727056813977234078214386771115586436985105038873998875\", \"9090550743395453237608373761422705922989356346696677314277463900103283296889488490217663400349361962695279888433677856471792856853109469433355422802663947305503479561493033851081993247556828544308258821557994512133708656174864544457143793106703578476914924328960109390350040954158797845288786321215010324565010420734044059968931558099077932776525974187717655105951506223649947806568984848883258144616897526257038550656/1783219994432430133950472014582130883873515063182143523712063859964133099770763874744121895885645346884371273930727450069430704145915261127061538288702855011220545530326588799412076879985026006593893648911637986337776174555198865379578424838210466703683642106934154603710587408512357351455891557594977191641529451749437270208258072920514602243985184744955476557012910446023911358037761232253615162335336208343505859375\", \"396226087129511787616470716244996965529391571019620342657409150252952330537366537352182763477820160355931003174946109480036915624974500187179367618457008802667089004678925595775249725629495848146669773574395699032785024522882892752987825063933573399691764866816284097232869198405981830106568826923407996367321353003569052419999880089180418759265274331299787468134974811/77651132902382550540201641628906752945078964002822585000619340261128555048628863996784740469908853602590877726845475670110127527874088625214912598995012971630852593597027649154487264595100300180591016581254965295280089902497540043916128232871685159131211213497239568483141031137909208031392464815187505714066235868748950184065923236670418822911614780061752905170944000\", \"1288523130900767412477856952035690867153496584747510253984686336382980221603917538996138294311274357713893956725672062832264871415025750136690143411884111580335458539824573239771267043414225271729141508235839982033182605445173050590151912297720800168687369852280323356691345317649445843078291369394324862039143247087442309135074453265658730028145500871559458519282433012494054724678302957276371418936282902434203225600/252284450515080370603949213084529993395050575951188044032908270470514999880554862449223347761507020354321422785760279154913310488296485989979706208254206974075438570521939826124860483842758137231373182496438568202110337751291106165654945352183167578675508602832478752400011567482434301614269579368882858973850914513870297071866544875650189106576672289734326492492059816669288907018095832842249738081022227281715919357\", \"559506782175368748187145067236900803925823792088293851453005882621173124590368101213652371965740365119375069053747415415684193092607523211636912074219215053809881814859129515591479780669511533619258835199715146655774919418434080807837587396115955105126806762961292429904380132116986984435528307613054828929294602185927322238461491059740342387266084431988727321711184308176/109446188216864405154936682374609448082436347600301765944233278303643744736544109262794383069197271409398615846380701459882784547857821831816863216080069944818453908760476475874319791512782445408136169878207358663250499628002971644430164185578966399908622640732411885568638054229180673755690889471388585521113862492432946110902070139679164884208988489955874131206343597375\", \"365842109776085256207829452385781129402656684569922320812625438296958174120084800064669048017227033185969596458778213306152397766619692644694641677223213185977626940193107608138827771259334379895020377700759789774994800008933137569543592829220611543060189849601828342989023692876182148818363689293009174358168826340010491728715549904988196347316703985894355217235339548078187164176255405596310602921647203428200269666176/71497266937783826306774367225149833789788300609530680399994804704196212252148324552193149332755057982662844988588678159610516634667597707204818296457616315484973288944637139939912166034691155272078609876888919170894915224022982785138928008133003473320018151370486895637936102520353951511525996197267572355782608352075229547764732602557133494648237258900273354364050662921889937355682486287799239363976556848320046933875\", \"59378684894605773397070783936113244261297966863668546282887298999811950599772732377979382620766180662159460666220894896896564357533604962977968843474062092083279165837424210591042655271577974272394203253875965589611493384384257117088518521598379301169916060951350650621757237206805037261878212424267780312614942173870651684587166691539909068452932891649554575072205080763/11593916877920131260484148322810317629326850763057953025674154928920977965095141485536566217873796019006709247938019404840440511433467040918770165456925609124166970862430104329357419669175323763143377917913760028500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"440706629842402075137926797732405268015915199334341565218443748798479563505125605478061664327658137598204192554352688830679475840386882350034150077506804799859586772904929402683276898098601814091430598259347980573084686932949502809068565420937301632494387691284902026088950093888426872222813857928092871267130505744095697172494119689779474840037266295586359244899477781345249657455186847452249040895151288114085352974933708544/85971876318334010542313048056773419567285701852816309711738644074302467763075671531248793080425349570584102078764464196653843973936119037322000695949209283327606280423406302517302874806092835694196353778161663338667091195199032831587897410329509487165187753418615356836636352319310103639079123698118997500068644500893282438137614420288839230827096109835206605385673197123994357393257304049093683934224826006704198171592304125\", \"13220371178312284248107863849287558696210741535280184003301555188086761767176560823174196915070378763091889333203635784037294769747641959860810039816533609140662043493962707445564057197150603226797446933532133956054671103942520142568674339411250001585991743608723150284270101326419464088290151483823061613403673956918458456165552482913079283537536214967294211244361353060/2576683013797055224377707713704899315377379548630511095136568220145808780162671473907260623503552385384482723173913562423316997528913651044277418227616447815609873991028073011738113927961824632868956802271260292075825561646156680740323686126811928372672670917332613490241615850953660246271541592056143611581223295045062157404996958100136358649109693659623847024011265147\", \"1538372578072246705266078247950089219881197139399081643650271348770110178217959856819170325400476655944115553238940541695152110949081675985299189913515975242840473616169775880272489805123124548256666658584129873597192213080038937409046114908719298170078476325423466734429870048697383304265342125425087105698152643145531760853127801123272389134514333752173173161562273487752064850461823726948588221913540799816489566883798912/299566102446745552813544808169323270315327122249327394279467999308669285416179486075255023523726449428151807672528368606071047812907935426406886253284580296349349558797128593446316786243666290649442956134448480598303527795996222703837663605600624271807461605295956674925277658331760000117761013381199880905748188151556184620779667670278558839116983636972680749836497346863752662521197700717702790359162307617024566689271625\", \"281696937222363685333688097915539146272117417024070728031063821781398985795813333650547982965341298894634762289669256129805545549280355643122501181852136332529515756074502902204877664395456278205770206019663082511098956468724829475220996427130295010430751942126263620206886404244432409164651524408198286831329682605959881993845189585640874220032515465014097345759490750307207/54806274927935495596891312029173862473687610099325998583092091915101265393157631244775387832621032230434007486602816972765210205596482942091518459849775458089575743699797096697542306049628939919466378189656065461708686421130956996965004776108499273871055615413566043083634090083096967567965373203683231171594922347812966905149873265654962896456451681332216735396249206784000\", \"228506238533410805238253122961471637501498406104430046727793420497895852412513560203475440156216063574654372726194215013407325207763369075250819386897086702757125418327084312933061738392406321003231853349865003322697360659712771167066453430309997639548320673279964210730701373707765051246595806673865646607841876463608039111252607452843372970797479959213447237540830563469297144446069689149549515457318899981763489792/44418759813188470246596822974281932219088697005123285598909329328419879212164564561558656547678211265529803086702843380128457744445765859393426675396393053094588240457569380155526179040891009717323059641035189017918495485630657360525410506453554255734005459614858972904374739673834145083512160883402151636664208253116362089211658645312778404886460203600762546810897889629330022309705583438699250109493732452392578125\", \"2396110297187570506257836426251930521245117960980667897194680897478996322590925380310917400763581787981992131769075961259393685331523600287377841990678117113566991100720996059187144934569703045966210306282348527729533806882408323961336166190162075154579344185244957673138372347997134388801085788353482276257401005734929059700346687783400772331280644647089520646562669857652648/465370154262863030800729180763091967573522779260407615567563274096037297593764955820626213827962697601334935773802201919483657310282236100250543992334865461800976838791035335861420892967699843608855185710753433852279737724446294443337363478679601049432404435672469098850676302728116369979460222148206944323730586138087862719386327396334468302608499235112520318322763857676375\", \"1188272888075247520453568790651819187486389546755745961952033150576243575862120569399808467067800830890874391487822723879717525264875722720416173276963170672622214121308038530968291758445510982186014289745026439477197148445087614813262170975056866881909056450023324743409114115141145340480846088869807540798073417035168139476153897066325127540609756310068558610112731607522096096821938163134080426356894899245575410494080/230586762395914863625709048789913840511134004337945700368117795195769576856434588144361459740833007125516905017415184787078710001969815416281381427387949263792200577791644278234661952852149216540491852757174842146376788280677956350901082838474705227642420261641783722891948710833898248566893322144435457967452449965772543077421407816225704952270697016152452032506898311260979594550143344971416786595888053149375287120733\", \"1072184299258468249004114536023934869518152618369895613271618698908405514630154819453979477077738526673716264830106745031385951736108376866253955319711026042389282009348594845497252059906901748860111986811345742998968284077119165082435598381810306691078037018432766116865792677955520465319184311529667642995217214507658693259694586107847099911341219913576038605872218680562047/207882129535607118520818565811162643811811563516006836924341123976848022970024793004700710992938987476728640943834012473687892481059618823520721737479364352887178017866425027953255856440099446112508663603319745066750522936408781591578321031173620445865113295407603090322283539974563690157418931060565698315406021569491751612761888641141446406531645379264720684248398299136000\", \"158094023904374464057702010126993231151433474361820266584020400101533651587072432728050776506672527718975042616651177034635188178967462982926261516748842073587981953038445977514446838733557926696939591069712397947055261777416704028506441173540338327591514650398349069348381309688677335132100441905603664282735310299686268721634369502296867409514777359935022301425165750780988231639828675424239931533849896744198012747670272/30626384366513923671063955469537776291182594080083494737341604579575446319190916924682809546024369330706012653799783122328775875399363759308193432327358837772825609356553955350401725689682838701996446404559005896479618311357573203081153855961484398360670837599853294627153740224543175497655414585918231215639906924313779933211774291565425360415684556655021031131349317390382320286092667852173815259422737956767922154798375\", \"12216278924286401897470540169822542417611356797676160128176706721343511598951866107858729405615631246003458062949723290192242594609994613705183460814797527214549142043573863947658832694800184691222426521703728394203722420336773310908687071670107794543022567943478843065246011544888390757810534211554666736239506503613750756246364621509359804902243487113673014588325806249988332/2364584127734680580481708368927921125934330000162935118371174269642831409084634375654239735054363928748162229294829526339927907778510530444646754603322373712788147193691037688552857183116332292048731726305451516954679277320777955342295564000586923227775208580772868590742136150431152495718132142742153643081187691849828217592954519485869135930755646768375299870967864990234375\", \"578939195017447864385837341975558679292903716580114421030538728778491606282153588930983966100514147976321305616196463174070345884292672842497715966933722088536619333912687108737657068701352918582656105418491672377271304970407730786932913490869797471081081431072836814581099271832696990064828717287258860166842791984158634684078346453202928137987930328826212011774670396356151265781053547412633310327737900786639842674288716416/111966291649651600701875186827360807558960817589719096407887999108024557254221008849510152469119211567152616745769256123968832250104006560061907741567034087109512483357851919402017950812795426393415409198268246337542639470834168040295134130657073201020340432236723824670803498949071870597039309004562024033656488150406105175401372709011082725359382691270659245312133919518760328422827067578306005644825927050994860723405473375\", \"8041514821545833865350873212853873042112343327573364523948780030849543753072688526717886590013028227714585965095216381829914996539132359247488639692828639170075726301411777307168737667077730792892326979446426349813642680537699905651125068091362135055902152994216233622733424128982011248923051410141033146604688083721413402395290842738021365861670415833356403364696759583009635/1553937833499559104910551811592138833189892464446761247731330672284191313590708439680460540329836344767557599746234213006493842842879398684745864919973051635127080738612248150108793397855113122368507483429209127035263504194847798809612278864438287815470711036548695032421148125849669175729331459149833945183228413961985381338162155596008680906676498435954178226973272371625984\", \"12059659399309169167301353842123191409306995788633965680414620302285606896146667751472818541537183787935352700725982053536032930866708413010971856856768384974849695774437178790890015242323873769697407411558706626105140596160049735605389301414460825674631122462760014451298494875244754354054447697502521388381253293175367558014453865905104467382184997528879171136492277222127399012368677604910497789360212571238146627048080568400384/2328494054002703067219004484782931471919751585969487160602269605916676223315055450845942763690581877771159615428854802721943114463834992106300185328876910271612375509166975628540839858771078495267566008071532876816826751069408153323840515037497664871689085370699991860738368371510578076683395101062439493831773194498579620513073693022191702398601471237166387045790480861932005012807234071429628725981935147069738988682858417182625\", \"683009426705008850682549700382901603742691705123356866338951397347368059105140826655486518416578697931244347554322654428162554903861783227680935341690740579867651545205562690172425016836559678937794312287639193745517811234257062356826622207475918293015140472942579713388671782202262396642735640315948612572908444501108579457520714632371056288874351015666995549139003946314085696/131769214246522869780429817236150406548549044658474416909806179734873399109656411633488099249198882165279745627038984487365589625562901914030850178330133080409420340227179447548044572594184601425691821617928130423410997853384425373999967759499571890326740433081063424903098252502791477854302204200941376983295622430177445507316706609802292121282957519571162158620971952084486375\", \"1418116259749091420309271913909337143756589314597557128553117870573928055109322864794169592355058370891251425125187770724828108988587888087023982451205475980371440423992838481547236638456717520835668859093413956339261802305597694403381021863258753441889536361061407579332570493634254542013337999844407181346815549594836374497512447969751514466481466717590255369810506813543577735080228718660747940956248427356785784199073569408/273368882980516556922532339653303822104510203916024760371844491705599093435133738774975538364241630079468712981056336655766117378160822393876348755370711942273876284944422610974149712212944211513462921649872232656449940987552227525504529710373144228818606127541937831103642415534318303187393593236209298242574677293352798419428712873685798636474667204083938875672934235816396371477146089168375198141802684403955936431884765625\", \"546411077581845999248238069684194831621691193366466972898628141511422317954477211865167402284211971296286346492698354214043840080181702652132835681239302798339667835439189275457116051279366194551632712819028177402221815140045210690908631767786711675029194359998826252332434573121740830827417293557234891406021102083555472155479148332697839972702631641910213821827820374586459319/105246945889799140338072754365901705544530661781295362563214285953881890233987516230568663143342952799036341701952267011236663118111226623815975847494372076420199418712941018288738590264475520229651370015377608638075866459684692488079223686296541020897904588347083045723167762682959422858996673894180805702299907478685374065593161226849447131100462022089783265346597553176576000\", \"2398330640958841474772606439916070050977544535580605737383995160447105736276950196885906408317628083110923322157113892928963237845914017845444295040924101784423382681801754191301860383927129006953354739240926643562987838836997453985855576402628166875869041032631651591871962852884189548538272285387092843044669499688035134181859376665409767886188304314888753894905317929877238322615838524354191263502347881033855441181420399360/461588070868590122892265681879734295007029130965626060552783760068897000195207878227714842617470320231527222074701444349530952699708435668339712860464533455345665068841333232359698449088497137068713309811942968433868609329301082001752617420002377892756821532220676085014874112083615054550278903960627185675459015343606391094523511117705747842645927349130302549554534056269331809016770715819934970200483161548527932617036185253\", \"6041015879424725383006424536130409209607854044642113747266098198777011981328765528361630516108680392500990580908509403483891763219659726090675140672989657743882183951954294745396417829943469201306594018454995862321821016087416840247422350906412007336103086620396467456181771583200365740253389107968122850063607085957109965406634738740996318415514360956028575560979203447735121436/1161752799109428422288020947061281540989708937450568100764830251908850596717606701047413407636907934320789870175907792017513896999208892282137299070761467096211814586909598705615312819596495636017728313513520193786266452836805291464826226833593878504804389728477191170027729963773716267868284479768397603444919008915279522376004326398403851684761808785381609370767169521034383625\", \"13240077436443988749179508462267267187169441948722358165090554769250505713747934643200804819418670147225695324432684266924694524337920816452346599774452681831320005286326986675907899608537972384924882996757503264622991355949039882526389342174307168805166215838138277557052303430492669193939212362638263582899713198716541723383138016564027766560215944409353427176135895982596327685665844815618402881202645610620284792793420780517248/2544223084468158291883698813309541801455311468982232546872485444308211415529998472787377800559884210837213042932180479090277285630234238711851480232520137856848809986631784843528381778520727465146661792797924458540957133423665746229799675650290296217658444899605236550972043549278128087645211909479009099766619355677984218929672461506691980442071860591767266913041147587815452007726513853820116629482732060593116624596368806566625\", \"1953999166296955830935495158735359200362904181792947794529339487489730042568305997099959302322956898299616194932283060554261566410988618045107398092345476532371402134206635235570281738377188438407703089325315446371127042537576093536896282955524842632708645655481028161471313608974238110718242273935956977555610147714316158486553633871312187084618154014921190595222799283957140353/375191165084882521037046014569185165885459082629136124177286500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"];\r\n            if(CACHE[x]) {\r\n                return Frac.quick.apply(null, CACHE[x].split('/'));\r\n            }\r\n            x = new Frac(x);\r\n            var n = 80;\r\n            var retval = new Frac(0);\r\n            var a = x.subtract(new Frac(1));\r\n            var b = x.add(new Frac(1));\r\n            for(var i = 0; i < n; i++) {\r\n                var t = new Frac(2 * i + 1);\r\n                var k = Math2.bigpow(a.divide(b), t);\r\n                var r = t.clone().invert().multiply(k);\r\n                retval = retval.add(r);\r\n\r\n            }\r\n            return retval.multiply(new Frac(2));\r\n        },\r\n        //the factorial function but using the big library instead\r\n        factorial: function (x) {\r\n            var is_int = x % 1 === 0;\r\n\r\n            /*factorial for negative integers is complex infinity according to Wolfram Alpha*/\r\n            if(is_int && x < 0)\r\n                return NaN;\r\n\r\n            if(!is_int)\r\n                return Math2.gamma(x + 1);\r\n\r\n            var retval = 1;\r\n            for(var i = 2; i <= x; i++)\r\n                retval = retval * i;\r\n            return retval;\r\n        },\r\n        //double factorial\r\n        //http://mathworld.wolfram.com/DoubleFactorial.html\r\n        dfactorial: function (x) {\r\n            if(isInt(x)) {\r\n                var even = x % 2 === 0;\r\n                /* If x = even then n = x/2 else n = (x-1)/2*/\r\n                var n = even ? x / 2 : (x + 1) / 2;\r\n                /*the return value*/\r\n                var r = new Frac(1);\r\n                /*start the loop*/\r\n                if(even)\r\n                    for(var i = 1; i <= n; i++)\r\n                        r = r.multiply(new Frac(2).multiply(new Frac(i)));\r\n                else\r\n                    for(var i = 1; i <= n; i++)\r\n                        r = r.multiply(new Frac(2).multiply(new Frac(i)).subtract(new Frac(1)));\r\n            }\r\n            else {\r\n                /*Not yet extended to bigNum*/\r\n                r = Math.pow(2, (1 + 2 * x - Math.cos(Math.PI * x)) / 4) * Math.pow(Math.PI, (Math.cos(Math.PI * x) - 1) / 4) * Math2.gamma(1 + x / 2);\r\n            }\r\n\r\n            /*done*/\r\n            return r;\r\n        },\r\n        GCD: function () {\r\n            var args = arrayUnique([].slice.call(arguments)\r\n                    .map(function (x) {\r\n                        return Math.abs(x);\r\n                    })).sort(),\r\n                    a = Math.abs(args.shift()),\r\n                    n = args.length;\r\n\r\n            while(n-- > 0) {\r\n                var b = Math.abs(args.shift());\r\n                while(true) {\r\n                    a %= b;\r\n                    if(a === 0) {\r\n                        a = b;\r\n                        break;\r\n                    }\r\n                    b %= a;\r\n                    if(b === 0)\r\n                        break;\r\n                    ;\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        QGCD: function () {\r\n            var args = [].slice.call(arguments);\r\n            var a = args[0];\r\n            for(var i = 1; i < args.length; i++) {\r\n                var b = args[i];\r\n                var sign = a.isNegative() && b.isNegative() ? -1 : 1;\r\n                a = b.gcd(a);\r\n                if(sign < 0)\r\n                    a.negate();\r\n            }\r\n            return a;\r\n        },\r\n        LCM: function (a, b) {\r\n            return (a * b) / Math2.GCD(a, b);\r\n        },\r\n        //pow but with the handling of negative numbers\r\n        //http://stackoverflow.com/questions/12810765/calculating-cubic-root-for-negative-number\r\n        pow: function (b, e) {\r\n            if(b < 0) {\r\n                if(Math.abs(e) < 1) {\r\n                    /*nth root of a negative number is imaginary when n is even*/\r\n                    if(1 / e % 2 === 0)\r\n                        return NaN;\r\n                    return -Math.pow(Math.abs(b), e);\r\n                }\r\n            }\r\n            return Math.pow(b, e);\r\n        },\r\n        factor: function (n) {\r\n            n = Number(n);\r\n            var sign = Math.sign(n); /*store the sign*/\r\n            /*move the number to absolute value*/\r\n            n = Math.abs(n);\r\n            var ifactors = Math2.ifactor(n);\r\n            var factors = new Symbol();\r\n            factors.symbols = {};\r\n            factors.group = CB;\r\n            for(var x in ifactors) {\r\n                var factor = new Symbol(1);\r\n                factor.group = P; /*cheat a little*/\r\n                factor.value = x;\r\n                factor.power = new Symbol(ifactors[x]);\r\n                factors.symbols[x] = factor;\r\n            }\r\n            factors.updateHash();\r\n\r\n            if(n === 1) {\r\n                factors = new Symbol(n);\r\n            }\r\n\r\n            /*put back the sign*/\r\n            if(sign < 0)\r\n                factors.negate();\r\n\r\n            return factors;\r\n        },\r\n        /**\r\n         * Uses trial division\r\n         * @param {Integer} n - the number being factored\r\n         * @param {object} factors -  the factors object\r\n         * @returns {object}\r\n         */\r\n        sfactor: function (n, factors) {\r\n            factors = factors || {};\r\n            var r = Math.floor(Math.sqrt(n));\r\n            var lcprime = PRIMES[PRIMES.length - 1];\r\n            /*a one-time cost... Hopefully ... And don't bother for more than a million*/\r\n            /*takes too long*/\r\n            if(r > lcprime && n < 1e6)\r\n                generatePrimes(r);\r\n            var l = PRIMES.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var prime = PRIMES[i];\r\n                /*trial division*/\r\n                while(n % prime === 0) {\r\n                    n = n / prime;\r\n                    factors[prime] = (factors[prime] || 0) + 1;\r\n                }\r\n            }\r\n            if(n > 1)\r\n                factors[n] = 1;\r\n            return factors;\r\n        },\r\n        /**\r\n         * Pollard's rho\r\n         * @param {Integer} n\r\n         * @returns {object}\r\n         */\r\n        ifactor: function (n) {\r\n            var input = new bigInt(n);\r\n\r\n            n = String(n);\r\n\r\n            if(n === '0')\r\n                return {'0': 1};\r\n            n = new bigInt(n); /*convert to bigInt for safety*/\r\n            var sign = n.sign ? -1 : 1;\r\n            n = n.abs();\r\n            var factors = {}; /*factor object being returned.*/\r\n            if(n.lt('65536')) { /*less than 2^16 just use trial division*/\r\n                factors = Math2.sfactor(n, factors);\r\n            }\r\n            else {\r\n                var add = function (e) {\r\n                    if(!e.isPrime()) {\r\n                        factors = Math2.sfactor(e, factors);\r\n                    }\r\n                    else\r\n                        factors[e] = (factors[e] || 0) + 1;\r\n                };\r\n\r\n                try {\r\n                    //set a safety\r\n                    var max = 1e3;\r\n                    var safety = 0;\r\n\r\n                    while(!n.abs().equals(1)) {\r\n                        if(n.isPrime()) {\r\n                            add(n);\r\n                            break;\r\n                        }\r\n                        else {\r\n                            function rho(c) {\r\n                                var xf = new bigInt(c),\r\n                                        cz = 2,\r\n                                        x = new bigInt(c),\r\n                                        factor = new bigInt(1);\r\n\r\n                                while(factor.equals(1)) {\r\n                                    for(var i = 0; i <= cz && factor.equals(1); i++) {\r\n                                        //trigger the safety\r\n                                        if(safety++ > max)\r\n                                            throw new Error('stopping');\r\n\r\n                                        x = x.pow(2).add(1).mod(n);\r\n                                        factor = bigInt.gcd(x.minus(xf).abs(), n);\r\n                                    }\r\n\r\n                                    cz = cz * 2;\r\n                                    xf = x;\r\n                                }\r\n                                if(factor.equals(n)) {\r\n                                    return rho(c + 1);\r\n                                }\r\n                                return factor;\r\n                            }\r\n                            var factor = rho(2);\r\n                            add(factor);\r\n                            /*divide out the factor*/\r\n                            n = n.divide(factor);\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    //reset factors\r\n                    factors = {};\r\n                    add(input);\r\n                }\r\n\r\n            }\r\n\r\n            /*put the sign back*/\r\n            if(sign === -1) {\r\n                var sm = arrayMin(keys(factors)); /*/get the smallest number*/\r\n                factors['-' + sm] = factors[sm];\r\n                delete factors[sm];\r\n            }\r\n\r\n            return factors;\r\n        },\r\n        //factors a number into rectangular box. If sides are primes that this will be\r\n        //their prime factors. e.g. 21 -> (7)(3), 133 -> (7)(19)\r\n        boxfactor: function (n, max) {\r\n            max = max || 200; //stop after this number of iterations\r\n            var c, r,\r\n                    d = Math.floor((5 / 12) * n), //the divisor\r\n                    i = 0, //number of iterations\r\n                    safety = false;\r\n            while(true) {\r\n                c = Math.floor(n / d);\r\n                r = n % d;\r\n                if(r === 0)\r\n                    break; //we're done\r\n                if(safety)\r\n                    return [n, 1];\r\n                d = Math.max(r, d - r);\r\n                i++;\r\n                safety = i > max;\r\n            }\r\n            return [c, d, i];\r\n        },\r\n        fib: function (n) {\r\n            var sign = Math.sign(n);\r\n            n = Math.abs(n);\r\n            sign = even(n) ? sign : Math.abs(sign);\r\n            var a = 0, b = 1, f = 1;\r\n            for(var i = 2; i <= n; i++) {\r\n                f = a + b;\r\n                a = b;\r\n                b = f;\r\n            }\r\n            return f * sign;\r\n        },\r\n        mod: function (x, y) {\r\n            return x % y;\r\n        },\r\n        //http://mathworld.wolfram.com/IntegerPart.html\r\n        integer_part: function (x) {\r\n            var sign = Math.sign(x);\r\n            return sign * Math.floor(Math.abs(x));\r\n        },\r\n        simpson: function (f, a, b, step) {\r\n            var get_value = function (f, x, side) {\r\n                var v = f(x);\r\n                var d = 0.000000000001;\r\n                if(isNaN(v)) {\r\n                    v = f(side === 1 ? x + d : x - d);\r\n                }\r\n                return v;\r\n            };\r\n\r\n            step = step || 0.0001;\r\n            //calculate the number of intervals\r\n            var n = Math.abs(Math.floor((b - a) / step));\r\n            //simpson's rule requires an even number of intervals. If it's not then add 1\r\n            if(n % 2 !== 0)\r\n                n++;\r\n            //get the interval size\r\n            var dx = (b - a) / n;\r\n            //get x0\r\n            var retval = get_value(f, a, 1);\r\n\r\n            //get the middle part 4x1+2x2+4x3 ...\r\n            //but first set a flag to see if it's even or odd.\r\n            //The first one is odd so we start there\r\n            var even = false;\r\n            //get x1\r\n            var xi = a + dx;\r\n            //the coefficient\r\n            var c, k;\r\n            //https://en.wikipedia.org/wiki/Simpson%27s_rule\r\n            for(var i = 1; i < n; i++) {\r\n                c = even ? 2 : 4;\r\n                k = c * get_value(f, xi, 1);\r\n                retval += k;\r\n                //flip the even flag\r\n                even = !even;\r\n                //increment xi\r\n                xi += dx;\r\n            }\r\n\r\n            //add xn\r\n            return (retval + get_value(f, xi, 2)) * (dx / 3);\r\n\r\n        },\r\n        /**\r\n         * https://github.com/scijs/integrate-adaptive-simpson\r\n         * @param {Function} f - the function being integrated\r\n         * @param {Number} a - lower bound\r\n         * @param {Number} b - upper bound\r\n         * @param {Number} tol - step width\r\n         * @param {Number} maxdepth\r\n         * @returns {Number}\r\n         */\r\n        num_integrate: function (f, a, b, tol, maxdepth) {\r\n            if(maxdepth < 0)\r\n                throw new Error('max depth cannot be negative');\r\n\r\n            /* This algorithm adapted from pseudocode in:*/\r\n            /* http://www.math.utk.edu/~ccollins/refs/Handouts/rich.pdf*/\r\n            function adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, depth, state) {\r\n                if(state.nanEncountered) {\r\n                    return NaN;\r\n                }\r\n                var h, f1, f2, sl, sr, s2, m, V1, V2, err;\r\n                h = b - a;\r\n                f1 = f(a + h * 0.25);\r\n                f2 = f(b - h * 0.25);\r\n                /* Simple check for NaN:*/\r\n                if(isNaN(f1)) {\r\n                    state.nanEncountered = true;\r\n                    return;\r\n                }\r\n                /* Simple check for NaN:*/\r\n                if(isNaN(f2)) {\r\n                    state.nanEncountered = true;\r\n                    return;\r\n                }\r\n\r\n                sl = h * (fa + 4 * f1 + fm) / 12;\r\n                sr = h * (fm + 4 * f2 + fb) / 12;\r\n                s2 = sl + sr;\r\n                err = (s2 - V0) / 15;\r\n\r\n                if(state.maxDepthCount > 1000 * maxdepth) {\r\n                    return;\r\n                }\r\n\r\n\r\n                if(depth > maxdepth) {\r\n                    state.maxDepthCount++;\r\n                    return s2 + err;\r\n                }\r\n                else if(Math.abs(err) < tol) {\r\n                    return s2 + err;\r\n                }\r\n                else {\r\n                    m = a + h * 0.5;\r\n                    V1 = adsimp(f, a, m, fa, f1, fm, sl, tol * 0.5, maxdepth, depth + 1, state);\r\n                    if(isNaN(V1)) {\r\n                        state.nanEncountered = true;\r\n                        return NaN;\r\n                    }\r\n                    V2 = adsimp(f, m, b, fm, f2, fb, sr, tol * 0.5, maxdepth, depth + 1, state);\r\n\r\n                    if(isNaN(V2)) {\r\n                        state.nanEncountered = true;\r\n                        return NaN;\r\n                    }\r\n\r\n                    return V1 + V2;\r\n                }\r\n            }\r\n\r\n            function integrate(f, a, b, tol, maxdepth) {\r\n                var state = {\r\n                    maxDepthCount: 0,\r\n                    nanEncountered: false\r\n                };\r\n\r\n                if(tol === undefined) {\r\n                    tol = 1e-9;\r\n                }\r\n                if(maxdepth === undefined) {\r\n                    /*Issue #458 - This was lowered because of performance issues. */\r\n                    /*This was suspected from before but is now confirmed with this issue*/\r\n                    maxdepth = 45;\r\n                }\r\n\r\n                var fa = f(a);\r\n                var fm = f(0.5 * (a + b));\r\n                var fb = f(b);\r\n\r\n                var V0 = (fa + 4 * fm + fb) * (b - a) / 6;\r\n\r\n                var result = adsimp(f, a, b, fa, fm, fb, V0, tol, maxdepth, 1, state);\r\n\r\n                if(state.maxDepthCount > 0) {\r\n                    warn('integrate-adaptive-simpson: Warning: maximum recursion depth (' + maxdepth + ') reached ' + state.maxDepthCount + ' times');\r\n                }\r\n\r\n                if(state.nanEncountered) {\r\n                    throw new Error('Function does not converge over interval!');\r\n                }\r\n\r\n                return result;\r\n            }\r\n            var retval;\r\n\r\n            try {\r\n                retval = integrate(f, a, b, tol, maxdepth);\r\n            }\r\n            catch(e) {\r\n                /*fallback to non-adaptive*/\r\n                return Math2.simpson(f, a, b);\r\n            }\r\n            return nround(retval, 12);\r\n        },\r\n        //https://en.wikipedia.org/wiki/Trigonometric_integral\r\n        //CosineIntegral\r\n        Ci: function (x) {\r\n            var n = 20,\r\n                    /*roughly EulerMascheroni*/\r\n                    g = 0.5772156649015329,\r\n                    sum = 0;\r\n            for(var i = 1; i < n; i++) {\r\n                /*cache 2n*/\r\n                var n2 = 2 * i;\r\n                sum += (Math.pow(-1, i) * Math.pow(x, n2)) / (n2 * Math2.factorial(n2));\r\n            }\r\n            return Math.log(x) + g + sum;\r\n        },\r\n        /*SineIntegral*/\r\n        Si: function (x) {\r\n            var n = 20,\r\n                    sum = 0;\r\n            for(var i = 0; i < n; i++) {\r\n                var n2 = 2 * i;\r\n                sum += (Math.pow(-1, i) * Math.pow(x, n2 + 1)) / ((n2 + 1) * Math2.factorial(n2 + 1));\r\n            }\r\n            return sum;\r\n        },\r\n        /*ExponentialIntegral*/\r\n        Ei: function (x) {\r\n            if(Number(x) === 0)\r\n                return -Infinity;\r\n            var n = 30,\r\n                    g = 0.5772156649015328606, /*roughly EulerMascheroni*/\r\n                    sum = 0;\r\n            for(var i = 1; i < n; i++) {\r\n                sum += Math.pow(x, i) / (i * Math2.factorial(i));\r\n            }\r\n            return g + Math.abs(Math.log(x)) + sum;\r\n        },\r\n        /*Hyperbolic Sine Integral*/\r\n        /*http://mathworld.wolfram.com/Shi.html*/\r\n        Shi: function (x) {\r\n            var n = 30,\r\n                    sum = 0,\r\n                    k, t;\r\n            for(var i = 0; i < n; i++) {\r\n                k = 2 * i;\r\n                t = k + 1;\r\n                sum += Math.pow(x, t) / (t * t * Math2.factorial(k));\r\n            }\r\n            return sum;\r\n        },\r\n        /*the cosine integral function*/\r\n        Chi: function (x) {\r\n            var dx, g, f;\r\n            dx = 0.001;\r\n            g = 0.5772156649015328606;\r\n            f = function (t) {\r\n                return (Math.cosh(t) - 1) / t;\r\n            };\r\n            return Math.log(x) + g + Math2.num_integrate(f, 0.002, x, dx);\r\n        },\r\n        /*the log integral*/\r\n        Li: function (x) {\r\n            return Math2.Ei(Math2.bigLog(x));\r\n        },\r\n        /*the gamma incomplete function*/\r\n        gamma_incomplete: function (n, x) {\r\n            var t = n - 1,\r\n                    sum = 0,\r\n                    x = x || 0;\r\n            for(var i = 0; i < t; i++) {\r\n                sum += Math.pow(x, i) / Math2.factorial(i);\r\n            }\r\n            return Math2.factorial(t) * Math.exp(-x) * sum;\r\n        },\r\n        /*\r\n         * Heaviside step function - Moved from Special.js (originally contributed by Brosnan Yuen)\r\n         * Specification : http://mathworld.wolfram.com/HeavisideStepFunction.html\r\n         * if x > 0 then 1\r\n         * if x == 0 then 1/2\r\n         * if x < 0 then 0\r\n         */\r\n        step: function (x) {\r\n            if(x > 0)\r\n                return 1;\r\n            if(x < 0)\r\n                return 0;\r\n            return 0.5;\r\n        },\r\n        /*\r\n         * Rectangle function - Moved from Special.js (originally contributed by Brosnan Yuen)\r\n         * Specification : http://mathworld.wolfram.com/RectangleFunction.html\r\n         * if |x| > 1/2 then 0\r\n         * if |x| == 1/2 then 1/2\r\n         * if |x| < 1/2 then 1\r\n         */\r\n        rect: function (x) {\r\n            var x = Math.abs(x);\r\n            if(x === 0.5)\r\n                return x;\r\n            if(x > 0.5)\r\n                return 0;\r\n            return 1;\r\n        },\r\n        /*\r\n         * Sinc function - Moved from Special.js (originally contributed by Brosnan Yuen)\r\n         * Specification : http://mathworld.wolfram.com/SincFunction.html\r\n         * if x == 0 then 1\r\n         * otherwise sin(x)/x\r\n         */\r\n        sinc: function (x) {\r\n            if(x.equals(0))\r\n                return 1;\r\n            return Math.sin(x) / x;\r\n        },\r\n        /*\r\n         * Triangle function - Moved from Special.js (originally contributed by Brosnan Yuen)\r\n         * Specification : http://mathworld.wolfram.com/TriangleFunction.html\r\n         * if |x| >= 1 then 0\r\n         * if |x| < then 1-|x|\r\n         */\r\n        tri: function (x) {\r\n            x = Math.abs(x);\r\n            if(x >= 1)\r\n                return 0;\r\n            return 1 - x;\r\n        },\r\n        //https://en.wikipedia.org/wiki/Nth_root_algorithm\r\n        nthroot: function (A, n) {\r\n            /*make sure the input is of type Frac*/\r\n            if(!(A instanceof Frac))\r\n                A = new Frac(A.toString());\r\n            if(!(n instanceof Frac))\r\n                n = new Frac(n.toString());\r\n            if(n.equals(1))\r\n                return A;\r\n            /*begin algorithm*/\r\n            var xk = A.divide(new Frac(2)); /*x0*/\r\n            var e = new Frac(1e-15);\r\n            var dk, dk0, d0;\r\n            var a = n.clone().invert(),\r\n                    b = n.subtract(new Frac(1));\r\n            do {\r\n                var powb = Math2.bigpow(xk, b);\r\n                var dk_dec = a.multiply(A.divide(powb).subtract(xk)).toDecimal(25);\r\n                dk = Frac.create(dk_dec);\r\n                if(d0)\r\n                    break;\r\n\r\n                xk = xk.add(dk);\r\n                /*check to see if there's no change from the last xk*/\r\n                var dk_dec = dk.toDecimal();\r\n                d0 = dk0 ? dk0 === dk_dec : false;\r\n                dk0 = dk_dec;\r\n            }\r\n            while(dk.abs().gte(e))\r\n\r\n            return xk;\r\n        },\r\n        /*https://gist.github.com/jiggzson/0c5b33cbcd7b52b36132b1e96573285f*/\r\n        /*Just the square root function but big :)*/\r\n        sqrt: function (n) {\r\n            if(!(n instanceof Frac))\r\n                n = new Frac(n);\r\n            var xn, d, ld, same_delta;\r\n            var c = 0; /*counter*/\r\n            var done = false;\r\n            var delta = new Frac(1e-20);\r\n            xn = n.divide(new Frac(2));\r\n            var safety = 1000;\r\n            do {\r\n                /*break if we're not converging*/\r\n                if(c > safety)\r\n                    throw new Error('Unable to calculate square root for ' + n);\r\n                xn = xn.add(n.divide(xn)).divide(new Frac(2));\r\n                xn = new Frac(xn.decimal(30));\r\n                /*get the difference from the true square*/\r\n                d = n.subtract(xn.multiply(xn));\r\n                /*if the square of the calculated number is close enough to the number*/\r\n                /*we're getting the square root or the last delta was the same as the new delta*/\r\n                /*then we're done*/\r\n                same_delta = ld ? ld.equals(d) : false;\r\n                if(d.clone().abs().lessThan(delta) || same_delta)\r\n                    done = true;\r\n                /*store the calculated delta*/\r\n                ld = d;\r\n                c++; /*increase the counter*/\r\n            }\r\n            while(!done)\r\n\r\n            return xn;\r\n        }\r\n    };\r\n    //link the Math2 object to Settings.FUNCTION_MODULES\r\n    Settings.FUNCTION_MODULES.push(Math2);\r\n    reserveNames(Math2); //reserve the names in Math2\r\n\r\n\r\n//Polyfills ====================================================================\r\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/\r\n    Math.sign = Math.sign || function (x) {\r\n        x = +x; // convert to a number\r\n        if(x === 0 || isNaN(x)) {\r\n            return x;\r\n        }\r\n        return x > 0 ? 1 : -1;\r\n    };\r\n\r\n    Math.cosh = Math.cosh || function (x) {\r\n        var y = Math.exp(x);\r\n        return (y + 1 / y) / 2;\r\n    };\r\n\r\n    Math.sech = Math.sech || function (x) {\r\n        return 1 / Math.cosh(x);\r\n    };\r\n\r\n    Math.csch = Math.csch || function (x) {\r\n        return 1 / Math.sinh(x);\r\n    };\r\n\r\n    Math.coth = Math.coth || function (x) {\r\n        return 1 / Math.tanh(x);\r\n    };\r\n\r\n    Math.sinh = Math.sinh || function (x) {\r\n        var y = Math.exp(x);\r\n        return (y - 1 / y) / 2;\r\n    };\r\n\r\n    Math.tanh = Math.tanh || function (x) {\r\n        if(x === Infinity) {\r\n            return 1;\r\n        }\r\n        else if(x === -Infinity) {\r\n            return -1;\r\n        }\r\n        else {\r\n            var y = Math.exp(2 * x);\r\n            return (y - 1) / (y + 1);\r\n        }\r\n    };\r\n\r\n    Math.asinh = Math.asinh || function (x) {\r\n        if(x === -Infinity) {\r\n            return x;\r\n        }\r\n        else {\r\n            return Math.log(x + Math.sqrt(x * x + 1));\r\n        }\r\n    };\r\n\r\n    Math.acosh = Math.acosh || function (x) {\r\n        return Math.log(x + Math.sqrt(x * x - 1));\r\n    };\r\n\r\n    Math.atanh = Math.atanh || function (x) {\r\n        return Math.log((1 + x) / (1 - x)) / 2;\r\n    };\r\n\r\n    Math.log10 = Math.log10 || function (x) {\r\n        return Math.log(x) * Math.LOG10E;\r\n    };\r\n\r\n    Math.trunc = Math.trunc || function (x) {\r\n        if(isNaN(x)) {\r\n            return NaN;\r\n        }\r\n        if(x > 0) {\r\n            return Math.floor(x);\r\n        }\r\n        return Math.ceil(x);\r\n    };\r\n\r\n//Global functions =============================================================\r\n    /**\r\n     * This method will return a hash or a text representation of a Symbol, Matrix, or Vector.\r\n     * If all else fails it *assumes* the object has a toString method and will call that.\r\n     *\r\n     * @param {Object} obj\r\n     * @param {String} option get is as a hash\r\n     * @param {int} useGroup\r\n     * @returns {String}\r\n     */\r\n    function text(obj, option, useGroup, decp) {\r\n        var asHash = option === 'hash',\r\n                //whether to wrap numbers in brackets\r\n                wrapCondition = undefined,\r\n                opt = asHash ? undefined : option,\r\n                asDecimal = opt === 'decimal' || opt === 'decimals';\r\n\r\n        if(asDecimal && typeof decp === 'undefined')\r\n            decp = 16;\r\n\r\n        function toString(obj) {\r\n            switch(option)\r\n            {\r\n                case 'decimals':\r\n                case 'decimal':\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return false;\r\n                    };\r\n                    return obj.valueOf();\r\n                case 'recurring':\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return str.indexOf(\"'\") !== -1;\r\n                    };\r\n\r\n                    var str = obj.toString();\r\n                    //verify that the string is actually a fraction\r\n                    var frac = /^-?\\d+(?:\\/\\d+)?$/.exec(str);\r\n                    if(frac.length === 0)\r\n                        return str;\r\n\r\n                    //split the fraction into the numerator and denominator\r\n                    var parts = frac[0].split('/');\r\n                    var negative = false;\r\n                    var m = Number(parts[0]);\r\n                    if(m < 0) {\r\n                        m = -m;\r\n                        negative = true;\r\n                    }\r\n                    var n = Number(parts[1]);\r\n                    if(!n)\r\n                        n = 1;\r\n\r\n                    //https://softwareengineering.stackexchange.com/questions/192070/what-is-a-efficient-way-to-find-repeating-decimal#comment743574_192081\r\n                    var quotient = Math.floor(m / n), c = 10 * (m - quotient * n);\r\n                    quotient = quotient.toString() + \".\";\r\n                    while(c && c < n) {\r\n                        c *= 10;\r\n                        quotient += \"0\";\r\n                    }\r\n                    var digits = \"\", passed = [], i = 0;\r\n                    while(true) {\r\n                        if(typeof passed[c] !== 'undefined') {\r\n                            var prefix = digits.slice(0, passed[c]),\r\n                                    cycle = digits.slice(passed[c]),\r\n                                    result = quotient + prefix + \"'\" + cycle + \"'\";\r\n                            return (negative ? \"-\" : \"\") + result.replace(\"'0'\", \"\").replace(/\\.$/, \"\");\r\n                        }\r\n                        var q = Math.floor(c / n), r = c - q * n;\r\n                        passed[c] = i;\r\n                        digits += q.toString();\r\n                        i += 1;\r\n                        c = 10 * r;\r\n                    }\r\n                case 'mixed':\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return str.indexOf('/') !== -1;\r\n                    };\r\n\r\n                    var str = obj.toString();\r\n                    //verify that the string is actually a fraction\r\n                    var frac = /^-?\\d+(?:\\/\\d+)?$/.exec(str);\r\n                    if(frac.length === 0)\r\n                        return str;\r\n\r\n                    //split the fraction into the numerator and denominator\r\n                    var parts = frac[0].split('/');\r\n                    var numer = new bigInt(parts[0]);\r\n                    var denom = new bigInt(parts[1]);\r\n                    if(denom.equals(0))\r\n                        denom = new bigInt(1);\r\n\r\n                    //return the quotient plus the remainder\r\n                    var divmod = numer.divmod(denom);\r\n                    var quotient = divmod.quotient;\r\n                    var remainder = divmod.remainder;\r\n                    var operator = parts[0][0] === '-' || quotient.equals(0) || remainder.equals(0) ? '' : '+';\r\n                    return (quotient.equals(0) ? '' : quotient.toString()) + operator + (remainder.equals(0) ? '' : (remainder.toString() + '/' + parts[1]));\r\n                case 'scientific':\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return false;\r\n                    }\r\n                    return new Scientific(obj.valueOf()).toString(Settings.SCIENTIFIC_MAX_DECIMAL_PLACES);\r\n                default:\r\n                    wrapCondition = wrapCondition || function (str) {\r\n                        return str.indexOf('/') !== -1;\r\n                    };\r\n\r\n                    return obj.toString();\r\n            }\r\n        }\r\n\r\n        //if the object is a symbol\r\n        if(isSymbol(obj)) {\r\n            var multiplier = '',\r\n                    power = '',\r\n                    sign = '',\r\n                    group = obj.group || useGroup,\r\n                    value = obj.value;\r\n\r\n            //if the value is to be used as a hash then the power and multiplier need to be suppressed\r\n            if(!asHash) {\r\n                //use asDecimal to get the object back as a decimal\r\n                var om = toString(obj.multiplier);\r\n                if(om == '-1' && String(obj.multiplier) === '-1') {\r\n                    sign = '-';\r\n                    om = '1';\r\n                }\r\n                //only add the multiplier if it's not 1\r\n                if(om != '1')\r\n                    multiplier = om;\r\n                //use asDecimal to get the object back as a decimal\r\n                var p = obj.power ? toString(obj.power) : '';\r\n                //only add the multiplier\r\n                if(p != '1') {\r\n                    //is it a symbol\r\n                    if(isSymbol(p)) {\r\n                        power = text(p, opt);\r\n                    }\r\n                    else {\r\n                        power = p;\r\n                    }\r\n                }\r\n            }\r\n\r\n            switch(group) {\r\n                case N:\r\n                    multiplier = '';\r\n                    //round if requested\r\n                    var m = decp && asDecimal ? obj.multiplier.toDecimal(decp) : toString(obj.multiplier);\r\n                    //if it's numerical then all we need is the multiplier\r\n                    value = String(obj.multiplier) == '-1' ? '1' : m;\r\n                    power = '';\r\n                    break;\r\n                case PL:\r\n                    value = obj.collectSymbols().map(function (x) {\r\n                        var txt = text(x, opt, useGroup, decp);\r\n                        if(txt == '0')\r\n                            txt = '';\r\n                        return txt;\r\n                    }).sort().join('+').replace(/\\+\\-/g, '-');\r\n                    break;\r\n                case CP:\r\n                    value = obj.collectSymbols().map(function (x) {\r\n                        var txt = text(x, opt, useGroup, decp);\r\n                        if(txt == '0')\r\n                            txt = '';\r\n                        return txt;\r\n                    }).sort().join('+').replace(/\\+\\-/g, '-');\r\n                    break;\r\n                case CB:\r\n                    value = obj.collectSymbols(function (symbol) {\r\n                        var g = symbol.group;\r\n                        //both groups will already be in brackets if their power is greater than 1\r\n                        //so skip it.\r\n                        if((g === PL || g === CP) && (symbol.power.equals(1) && symbol.multiplier.equals(1))) {\r\n                            return inBrackets(text(symbol, opt));\r\n                        }\r\n                        return text(symbol, opt);\r\n                    }).join('*');\r\n                    break;\r\n                case EX:\r\n                    var pg = obj.previousGroup,\r\n                            pwg = obj.power.group;\r\n\r\n                    //PL are the exception. It's simpler to just collect and set the value\r\n                    if(pg === PL)\r\n                        value = obj.collectSymbols(text, opt).join('+').replace('+-', '-');\r\n                    if(!(pg === N || pg === S || pg === FN) && !asHash) {\r\n                        value = inBrackets(value);\r\n                    }\r\n\r\n                    if((pwg === CP || pwg === CB || pwg === PL || obj.power.multiplier.toString() != '1') && power) {\r\n                        power = inBrackets(power);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            if(group === FN) {\r\n                value = obj.fname + inBrackets(obj.args.map(function (symbol) {\r\n                    return text(symbol, opt);\r\n                }).join(','));\r\n            }\r\n            //TODO: Needs to be more efficient. Maybe.\r\n            if(group === FN && obj.fname in CUSTOM_OPERATORS) {\r\n                var a = text(obj.args[0]);\r\n                var b = text(obj.args[1]);\r\n                if(obj.args[0].isComposite()) //preserve the brackets\r\n                    a = inBrackets(a);\r\n                if(obj.args[1].isComposite()) //preserve the brackets\r\n                    b = inBrackets(b);\r\n                value = a + CUSTOM_OPERATORS[obj.fname] + b;\r\n            }\r\n            //wrap the power since / is less than ^\r\n            //TODO: introduce method call isSimple\r\n            if(power && group !== EX && wrapCondition(power)) {\r\n                power = inBrackets(power);\r\n            }\r\n\r\n            //the following groups are held together by plus or minus. They can be raised to a power or multiplied\r\n            //by a multiplier and have to be in brackets to preserve the order of precedence\r\n            if(((group === CP || group === PL) && (multiplier && multiplier != '1' || sign === '-'))\r\n                    || ((group === CB || group === CP || group === PL) && (power && power != '1'))\r\n                    || !asHash && group === P && value == -1\r\n                    || obj.fname === PARENTHESIS) {\r\n\r\n                value = inBrackets(value);\r\n            }\r\n\r\n            if(decp && (option === 'decimal' || option === 'decimals' && multiplier)) {\r\n                multiplier = nround(multiplier, decp);\r\n            }\r\n\r\n\r\n            //add the sign back\r\n            var c = sign + multiplier;\r\n\r\n            if(multiplier && wrapCondition(multiplier))\r\n                c = inBrackets(c);\r\n\r\n            if(power < 0)\r\n                power = inBrackets(power);\r\n\r\n            //add the multiplication back\r\n            if(multiplier)\r\n                c = c + '*';\r\n\r\n            if(power) {\r\n                if(value === 'e' && Settings.E_TO_EXP) {\r\n                    return c + 'exp' + inBrackets(power);\r\n                }\r\n                power = Settings.POWER_OPERATOR + power;\r\n            }\r\n\r\n            //this needs serious rethinking. Must fix\r\n            if(group === EX && value.charAt(0) === '-') {\r\n                value = inBrackets(value);\r\n            }\r\n\r\n            var cv = c + value;\r\n\r\n            if(obj.parens) {\r\n                cv = inBrackets(cv);\r\n            }\r\n\r\n            return cv + power;\r\n        }\r\n        else if(isVector(obj)) {\r\n            var l = obj.elements.length,\r\n                    c = [];\r\n            for(var i = 0; i < l; i++)\r\n                c.push(obj.elements[i].text(option));\r\n            return '[' + c.join(',') + ']';\r\n        }\r\n        else {\r\n            try {\r\n                return obj.toString();\r\n            }\r\n            catch(e) {\r\n                return '';\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Calculates prime factors for a number. It first checks if the number\r\n     * is a prime number. If it's not then it will calculate all the primes \r\n     * for that number.\r\n     * @param {int} num\r\n     * @returns {Array}\r\n     */\r\n\r\n    function primeFactors(num) {\r\n        if(isPrime(num)) {\r\n            return [num];\r\n        }\r\n\r\n        var l = num, i = 1, factors = [],\r\n                epsilon = 2.2204460492503130808472633361816E-16;\r\n        while(i < l) {\r\n            var quotient = num / i;\r\n            var whole = Math.floor(quotient);\r\n            var remainder = quotient - whole;\r\n\r\n            if(remainder <= epsilon && i > 1) {\r\n                // If the prime wasn't found but calculated then save it and\r\n                // add it as a factor.\r\n                if(isPrime(i)) {\r\n                    if(PRIMES.indexOf(i) === -1) {\r\n                        PRIMES.push(i);\r\n                    }\r\n                    factors.push(i);\r\n                }\r\n\r\n                // Check if the remainder is a prime\r\n                if(isPrime(whole)) {\r\n                    factors.push(whole);\r\n                    break;\r\n                }\r\n\r\n                l = whole;\r\n            }\r\n            i++;\r\n        }\r\n\r\n        return factors.sort(function (a, b) {\r\n            return a - b;\r\n        });\r\n    }\r\n    ;\r\n    primeFactors(314146179365)\r\n//Expression ===================================================================\r\n    /**\r\n     * This is what nerdamer returns. It's sort of a wrapper around the symbol class and\r\n     * provides the user with some useful functions. If you want to provide the user with extra\r\n     * library functions then add them to this class's prototype.\r\n     * @param {Symbol} symbol\r\n     * @returns {Expression} wraps around the Symbol class\r\n     */\r\n    function Expression(symbol) {\r\n        //we don't want arrays wrapped\r\n        this.symbol = symbol;\r\n    }\r\n    /**\r\n     * Returns stored expression at index. For first index use 1 not 0.\r\n     * @param {bool} asType\r\n     * @param {Integer} expression_number\r\n     */\r\n    Expression.getExpression = function (expression_number, asType) {\r\n        if(expression_number === 'last' || !expression_number)\r\n            expression_number = EXPRESSIONS.length;\r\n        if(expression_number === 'first')\r\n            expression_number = 1;\r\n        var index = expression_number - 1,\r\n                expression = EXPRESSIONS[index],\r\n                retval = expression ? new Expression(expression) : expression;\r\n        return retval;\r\n    };\r\n    Expression.prototype = {\r\n        /**\r\n         * Returns the text representation of the expression\r\n         * @param {String} opt - option of formatting numbers\r\n         * @param {Number} n The number of significant figures\r\n         * @returns {String}\r\n         */\r\n        text: function (opt, n) {\r\n            n = n || 19;\r\n            opt = opt || 'decimals';\r\n            if(this.symbol.text_)\r\n                return this.symbol.text_(opt);\r\n\r\n            return text(this.symbol, opt, undefined, n);\r\n        },\r\n        /**\r\n         * Returns the latex representation of the expression\r\n         * @param {String} option - option for formatting numbers\r\n         * @returns {String}\r\n         */\r\n        latex: function (option) {\r\n            if(this.symbol.latex)\r\n                return this.symbol.latex(option);\r\n            return LaTeX.latex(this.symbol, option);\r\n        },\r\n        valueOf: function () {\r\n            return this.symbol.valueOf();\r\n        },\r\n\r\n        /**\r\n         * Evaluates the expression and tries to reduce it to a number if possible.\r\n         * If an argument is given in the form of %{integer} it will evaluate that expression.\r\n         * Other than that it will just use it's own text and reparse\r\n         * @returns {Expression}\r\n         */\r\n        evaluate: function () {\r\n\r\n            // Don't evaluate an empty vector\r\n            if(isVector(this.symbol) && this.symbol.dimensions() === 0) {\r\n                return this;\r\n            }\r\n\r\n            var first_arg = arguments[0], expression, idx = 1;\r\n\r\n            //Enable getting of expressions using the % so for example %1 should get the first expression\r\n            if(typeof first_arg === 'string') {\r\n                expression = (first_arg.charAt(0) === '%') ? Expression.getExpression(first_arg.substr(1)).text() : first_arg;\r\n            }\r\n            else if(first_arg instanceof Expression || isSymbol(first_arg)) {\r\n                expression = first_arg.text();\r\n            }\r\n            else {\r\n                expression = this.symbol.text();\r\n                idx--;\r\n            }\r\n\r\n            var subs = arguments[idx] || {};\r\n\r\n            var retval = new Expression(block('PARSE2NUMBER', function () {\r\n                return _.parse(expression, subs);\r\n            }, true));\r\n\r\n            return retval;\r\n        },\r\n        /**\r\n         * Converts a symbol to a JS function. Pass in an array of variables to use that order instead of\r\n         * the default alphabetical order\r\n         * @param vars {Array}\r\n         */\r\n        buildFunction: function (vars) {\r\n            return Build.build(this.symbol, vars);\r\n        },\r\n        /**\r\n         * Checks to see if the expression is just a plain old number\r\n         * @returns {boolean}\r\n         */\r\n        isNumber: function () {\r\n            return isNumericSymbol(this.symbol);\r\n        },\r\n        /**\r\n         * Checks to see if the expression is infinity\r\n         * @returns {boolean}\r\n         */\r\n        isInfinity: function () {\r\n            return Math.abs(this.symbol.multiplier) === Infinity;\r\n        },\r\n        /**\r\n         * Checks to see if the expression contains imaginary numbers\r\n         * @returns {boolean}\r\n         */\r\n        isImaginary: function () {\r\n            return evaluate(_.parse(this.symbol)).isImaginary();\r\n        },\r\n        /**\r\n         * Returns all the variables in the expression\r\n         * @returns {Array}\r\n         */\r\n        variables: function () {\r\n            return variables(this.symbol);\r\n        },\r\n\r\n        toString: function () {\r\n            try {\r\n                if(isArray(this.symbol))\r\n                    return '[' + this.symbol.toString() + ']';\r\n                return this.symbol.toString();\r\n            }\r\n            catch(e) {\r\n                return '';\r\n            }\r\n        },\r\n        //forces the symbol to be returned as a decimal\r\n        toDecimal: function (prec) {\r\n            Settings.precision = prec;\r\n            var dec = text(this.symbol, 'decimals');\r\n            Settings.precision = undefined;\r\n            return dec;\r\n        },\r\n        //checks to see if the expression is a fraction\r\n        isFraction: function () {\r\n            return isFraction(this.symbol);\r\n        },\r\n        //checks to see if the symbol is a multivariate polynomial\r\n        isPolynomial: function () {\r\n            return this.symbol.isPoly();\r\n        },\r\n        //performs a substitution\r\n        sub: function (symbol, for_symbol) {\r\n            return new Expression(this.symbol.sub(_.parse(symbol), _.parse(for_symbol)));\r\n        },\r\n        operation: function (otype, symbol) {\r\n            if(isExpression(symbol))\r\n                symbol = symbol.symbol;\r\n            else if(!isSymbol(symbol))\r\n                symbol = _.parse(symbol);\r\n            return new Expression(_[otype](this.symbol.clone(), symbol.clone()));\r\n        },\r\n        add: function (symbol) {\r\n            return this.operation('add', symbol);\r\n        },\r\n        subtract: function (symbol) {\r\n            return this.operation('subtract', symbol);\r\n        },\r\n        multiply: function (symbol) {\r\n            return this.operation('multiply', symbol);\r\n        },\r\n        divide: function (symbol) {\r\n            return this.operation('divide', symbol);\r\n        },\r\n        pow: function (symbol) {\r\n            return this.operation('pow', symbol);\r\n        },\r\n        expand: function () {\r\n            return new Expression(_.expand(this.symbol));\r\n        },\r\n        each: function (callback, i) {\r\n            if(this.symbol.each)\r\n                this.symbol.each(callback, i);\r\n            else if(isArray(this.symbol)) {\r\n                for(var i = 0; i < this.symbol.length; i++)\r\n                    callback.call(this.symbol, this.symbol[i], i);\r\n            }\r\n            else\r\n                callback.call(this.symbol);\r\n        },\r\n        eq: function (value) {\r\n            if(!isSymbol(value))\r\n                value = _.parse(value);\r\n            try {\r\n                var d = _.subtract(this.symbol.clone(), value);\r\n                return d.equals(0);\r\n            }\r\n            catch(e) {\r\n                return false;\r\n            }\r\n            ;\r\n        },\r\n        lt: function (value) {\r\n            if(!isSymbol(value))\r\n                value = _.parse(value);\r\n            try {\r\n                var d = evaluate(_.subtract(this.symbol.clone(), value));\r\n                return d.lessThan(0);\r\n            }\r\n            catch(e) {\r\n                return false;\r\n            }\r\n            ;\r\n        },\r\n        gt: function (value) {\r\n            if(!isSymbol(value))\r\n                value = _.parse(value);\r\n            try {\r\n                var d = evaluate(_.subtract(this.symbol.clone(), value));\r\n                return d.greaterThan(0);\r\n            }\r\n            catch(e) {\r\n                return false;\r\n            }\r\n        },\r\n        gte: function (value) {\r\n            return this.gt(value) || this.eq(value);\r\n        },\r\n        lte: function (value) {\r\n            return this.lt(value) || this.eq(value);\r\n        },\r\n\r\n        numerator: function () {\r\n            return new Expression(this.symbol.getNum());\r\n        },\r\n        denominator: function () {\r\n            return new Expression(this.symbol.getDenom());\r\n        },\r\n        hasFunction: function (f) {\r\n            return this.symbol.containsFunction(f);\r\n        },\r\n        contains: function (variable) {\r\n            return this.symbol.contains(variable);\r\n        }\r\n    };\r\n    //Aliases\r\n    Expression.prototype.toTeX = Expression.prototype.latex;\r\n\r\n//Scientific ===================================================================\r\n    function Scientific(num) {\r\n        if(!(this instanceof Scientific))\r\n            return new Scientific(num);\r\n\r\n        num = String(typeof num === 'undefined' ? 0 : num); //convert to a string\r\n\r\n        //remove the sign\r\n        if(num.startsWith('-')) {\r\n            this.sign = -1;\r\n            //remove the sign\r\n            num = num.substr(1, num.length);\r\n        }\r\n        else {\r\n            this.sign = 1;\r\n        }\r\n\r\n        if(Scientific.isScientific(num)) {\r\n            this.fromScientific(num);\r\n        }\r\n        else {\r\n            this.convert(num);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    Scientific.prototype = {\r\n        fromScientific: function (num) {\r\n            var parts = String(num).toLowerCase().split('e');\r\n            this.coeff = parts[0];\r\n            this.exponent = parts[1];\r\n\r\n            return this;\r\n        },\r\n        convert: function (num) {\r\n            //get wholes and decimals\r\n            var parts = num.split('.');\r\n            //make zero go away\r\n            var w = parts[0] || '';\r\n            var d = parts[1] || '';\r\n            //convert zero to blank strings\r\n            w = Scientific.removeLeadingZeroes(w);\r\n            d = Scientific.removeTrailingZeroes(d);\r\n            //find the location of the decimal place which is right after the wholes\r\n            var dot_location = w.length;\r\n            //add them together so we can move the dot\r\n            var n = w + d;\r\n            //find the next number\r\n            var zeroes = Scientific.leadingZeroes(n).length;\r\n            //set the exponent\r\n            this.exponent = dot_location - (zeroes + 1);\r\n            //set the coeff but first remove leading zeroes\r\n            var coeff = Scientific.removeLeadingZeroes(n);\r\n            this.coeff = coeff.charAt(0) + '.' + (coeff.substr(1, coeff.length) || '0');\r\n\r\n            return this;\r\n        },\r\n        round: function (num) {\r\n            var n = this.copy();\r\n\r\n            num = Number(num); //cast to number for safety\r\n            //since we know it guaranteed to be in the format {digit}{optional dot}{optional digits}\r\n            //we can round based on this\r\n            if(num === 0)\r\n                n.coeff = n.coeff.charAt(0);\r\n            else {\r\n                //get up to n-1 digits\r\n                var rounded = this.coeff.substring(0, num + 1);\r\n                //get the next two\r\n                var next_two = this.coeff.substring(num + 1, num + 3);\r\n                //the extra digit\r\n                var ed = next_two.charAt(0);\r\n\r\n                if(next_two.charAt(1) > 4)\r\n                    ed++;\r\n\r\n                n.coeff = rounded + ed;\r\n            }\r\n\r\n            return n;\r\n        },\r\n        copy: function () {\r\n            var n = new Scientific(0);\r\n            n.coeff = this.coeff;\r\n            n.exponent = this.exponent;\r\n            n.sign = this.sign;\r\n            return n;\r\n        },\r\n        toString: function (n) {\r\n            var coeff = typeof n === 'undefined' ? this.coeff : Scientific.round(this.coeff, n);\r\n\r\n            var c;\r\n            if(this.exponent === 0 && Settings.SCIENTIFIC_IGNORE_INTS) {\r\n                c = this.coeff;\r\n            }\r\n            else {\r\n                c = coeff + 'e' + this.exponent;\r\n            }\r\n            return (this.sign === -1 ? '-' : '') + c;\r\n        }\r\n    };\r\n\r\n    Scientific.isScientific = function (num) {\r\n        return /\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num);\r\n    };\r\n    Scientific.leadingZeroes = function (num) {\r\n        var match = num.match(/^(0*).*$/);\r\n        return match ? match[1] : '';\r\n    };\r\n    Scientific.removeLeadingZeroes = function (num) {\r\n        var match = num.match(/^0*(.*)$/);\r\n        return match ? match[1] : '';\r\n    };\r\n\r\n    Scientific.removeTrailingZeroes = function (num) {\r\n        var match = num.match(/0*$/);\r\n        return match ? num.substring(0, num.length - match[0].length) : '';\r\n    };\r\n    Scientific.round = function (c, n) {\r\n        var coeff = nround(c, n);\r\n        var m = String(coeff).split('.').pop();\r\n        var d = n - m.length;\r\n        //if we're asking for more significant figures\r\n        if(d > 0) {\r\n            coeff = coeff + (new Array(d + 1).join(0));\r\n        }\r\n        return coeff;\r\n    };\r\n\r\n//Scientific ===================================================================\r\n    /*\r\n     * Javascript has the toExponential method but this allows you to work with string and therefore any number of digits of your choosing\r\n     * For example Scientific('464589498449496467924197545625247695464569568959124568489548454');\r\n     */\r\n\r\n    function Scientific(num) {\r\n        if(!(this instanceof Scientific))\r\n            return new Scientific(num);\r\n\r\n        num = String(typeof num === 'undefined' ? 0 : num); //convert to a string\r\n\r\n        //remove the sign\r\n        if(num.startsWith('-')) {\r\n            this.sign = -1;\r\n            //remove the sign\r\n            num = num.substr(1, num.length);\r\n        }\r\n        else {\r\n            this.sign = 1;\r\n        }\r\n\r\n        if(Scientific.isScientific(num)) {\r\n            this.fromScientific(num);\r\n        }\r\n        else {\r\n            this.convert(num);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    Scientific.prototype = {\r\n        fromScientific: function (num) {\r\n            var parts = String(num).toLowerCase().split('e');\r\n            this.coeff = parts[0];\r\n            this.exponent = parts[1];\r\n\r\n            return this;\r\n        },\r\n        convert: function (num) {\r\n            //get wholes and decimals\r\n            var parts = num.split('.');\r\n            //make zero go away\r\n            var w = parts[0] || '';\r\n            var d = parts[1] || '';\r\n            //convert zero to blank strings\r\n            w = Scientific.removeLeadingZeroes(w);\r\n            d = Scientific.removeTrailingZeroes(d);\r\n            //find the location of the decimal place which is right after the wholes\r\n            var dot_location = w.length;\r\n            //add them together so we can move the dot\r\n            var n = w + d;\r\n            //find the next number\r\n            var zeroes = Scientific.leadingZeroes(n).length;\r\n            //set the exponent\r\n            this.exponent = dot_location - (zeroes + 1);\r\n            //set the coeff but first remove leading zeroes\r\n            var coeff = Scientific.removeLeadingZeroes(n);\r\n            this.coeff = coeff.charAt(0) + '.' + (coeff.substr(1, coeff.length) || '0');\r\n\r\n            //the coeff decimal places\r\n            var dec = this.coeff.split('.')[1] || ''; //if it's undefined or zero it's going to blank\r\n\r\n            this.decp = dec === '0' ? 0 : dec.length;\r\n            //decimals\r\n            this.dec = d;\r\n            //wholes\r\n            this.wholes = w;\r\n\r\n            return this;\r\n        },\r\n        round: function (num) {\r\n            var n = this.copy();\r\n\r\n            num = Number(num); //cast to number for safety\r\n            //since we know it guaranteed to be in the format {digit}{optional dot}{optional digits}\r\n            //we can round based on this\r\n            if(num === 0)\r\n                n.coeff = n.coeff.charAt(0);\r\n            else {\r\n                //get up to n-1 digits\r\n                var rounded = this.coeff.substring(0, num + 1);\r\n                //get the next two\r\n                var next_two = this.coeff.substring(num + 1, num + 3);\r\n                //the extra digit\r\n                var ed = next_two.charAt(0);\r\n\r\n                if(next_two.charAt(1) > 4)\r\n                    ed++;\r\n\r\n                n.coeff = rounded + ed;\r\n            }\r\n\r\n            return n;\r\n        },\r\n        copy: function () {\r\n            var n = new Scientific(0);\r\n            n.coeff = this.coeff;\r\n            n.exponent = this.exponent;\r\n            n.sign = this.sign;\r\n            return n;\r\n        },\r\n        toString: function (n) {\r\n            var retval;\r\n\r\n            if(Settings.SCIENTIFIC_IGNORE_ZERO_EXPONENTS && this.exponent === 0 && this.decp < n) {\r\n                if(this.decp === 0)\r\n                    retval = this.wholes;\r\n                else\r\n                    retval = this.coeff;\r\n            }\r\n            else {\r\n                var coeff = typeof n === 'undefined' ? this.coeff : Scientific.round(this.coeff, Math.min(n, this.decp || 1));\r\n                retval = this.exponent === 0 ? coeff : coeff + 'e' + this.exponent;\r\n            }\r\n\r\n            return (this.sign === -1 ? '-' : '') + retval;\r\n        }\r\n    };\r\n\r\n    Scientific.isScientific = function (num) {\r\n        return /\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(num);\r\n    };\r\n    Scientific.leadingZeroes = function (num) {\r\n        var match = num.match(/^(0*).*$/);\r\n        return match ? match[1] : '';\r\n    };\r\n    Scientific.removeLeadingZeroes = function (num) {\r\n        var match = num.match(/^0*(.*)$/);\r\n        return match ? match[1] : '';\r\n    };\r\n\r\n    Scientific.removeTrailingZeroes = function (num) {\r\n        var match = num.match(/0*$/);\r\n        return match ? num.substring(0, num.length - match[0].length) : '';\r\n    };\r\n\r\n\r\n//Frac =========================================================================\r\n    function Frac(n) {\r\n        if(n instanceof Frac)\r\n            return n;\r\n        if(n === undefined)\r\n            return this;\r\n        try {\r\n            if(isInt(n)) {\r\n                try {\r\n                    this.num = bigInt(n);\r\n                    this.den = bigInt(1);\r\n                }\r\n                catch(e) {\r\n                    return Frac.simple(n);\r\n                }\r\n            }\r\n            else {\r\n                var frac = n instanceof bigDec ? Fraction.quickConversion(n) : Fraction.convert(n);\r\n                this.num = new bigInt(frac[0]);\r\n                this.den = new bigInt(frac[1]);\r\n            }\r\n        }\r\n        catch(e) {\r\n            return Frac.simple(n);\r\n        }\r\n\r\n    }\r\n    //safe to use with negative numbers or other types\r\n    Frac.create = function (n) {\r\n        if(n instanceof Frac)\r\n            return n;\r\n        n = n.toString();\r\n        var is_neg = n.charAt(0) === '-'; //check if it's negative\r\n        if(is_neg)\r\n            n = n.substr(1, n.length - 1); //remove the sign\r\n        var frac = new Frac(n);\r\n        //put the sign back\r\n        if(is_neg)\r\n            frac.negate();\r\n        return frac;\r\n    };\r\n    Frac.isFrac = function (o) {\r\n        return (o instanceof Frac);\r\n    };\r\n    Frac.quick = function (n, d) {\r\n        var frac = new Frac();\r\n        frac.num = new bigInt(n);\r\n        frac.den = new bigInt(d);\r\n        return frac;\r\n    };\r\n    Frac.simple = function (n) {\r\n        var nstr = String(scientificToDecimal(n)),\r\n                m_dc = nstr.split('.'),\r\n                num = m_dc.join(''),\r\n                den = 1,\r\n                l = (m_dc[1] || '').length;\r\n        for(var i = 0; i < l; i++)\r\n            den += '0';\r\n        var frac = Frac.quick(num, den);\r\n        return frac.simplify();\r\n    };\r\n    Frac.prototype = {\r\n        multiply: function (m) {\r\n            if(this.isOne()) {\r\n                return m.clone();\r\n            }\r\n            if(m.isOne()) {\r\n                return this.clone();\r\n            }\r\n\r\n            var c = this.clone();\r\n            c.num = c.num.multiply(m.num);\r\n            c.den = c.den.multiply(m.den);\r\n\r\n            return c.simplify();\r\n        },\r\n        divide: function (m) {\r\n            if(m.equals(0))\r\n                throw new DivisionByZero('Division by zero not allowed!');\r\n            return this.clone().multiply(m.clone().invert()).simplify();\r\n        },\r\n        subtract: function (m) {\r\n            return this.clone().add(m.clone().neg());\r\n        },\r\n        neg: function () {\r\n            this.num = this.num.multiply(-1);\r\n            return this;\r\n        },\r\n        add: function (m) {\r\n            var n1 = this.den, n2 = m.den, c = this.clone();\r\n            var a = c.num, b = m.num;\r\n            if(n1.equals(n2)) {\r\n                c.num = a.add(b);\r\n            }\r\n            else {\r\n                c.num = a.multiply(n2).add(b.multiply(n1));\r\n                c.den = n1.multiply(n2);\r\n            }\r\n\r\n            return c.simplify();\r\n        },\r\n        mod: function (m) {\r\n            var a = this.clone(),\r\n                    b = m.clone();\r\n            //make their denominators even and return the mod of their numerators\r\n            a.num = a.num.multiply(b.den);\r\n            a.den = a.den.multiply(b.den);\r\n            b.num = b.num.multiply(this.den);\r\n            b.den = b.den.multiply(this.den);\r\n            a.num = a.num.mod(b.num);\r\n            return a.simplify();\r\n        },\r\n        simplify: function () {\r\n            var gcd = bigInt.gcd(this.num, this.den);\r\n\r\n            this.num = this.num.divide(gcd);\r\n            this.den = this.den.divide(gcd);\r\n            return this;\r\n        },\r\n        clone: function () {\r\n            var m = new Frac();\r\n            m.num = new bigInt(this.num);\r\n            m.den = new bigInt(this.den);\r\n            return m;\r\n        },\r\n        decimal: function (prec) {\r\n            var sign = this.num.isNegative() ? '-' : '';\r\n            if(this.num.equals(this.den)) {\r\n                return '1';\r\n            }\r\n            //go plus one for rounding\r\n            prec = prec || Settings.PRECISION;\r\n            prec++;\r\n            var narr = [],\r\n                    n = this.num.abs(),\r\n                    d = this.den;\r\n            for(var i = 0; i < prec; i++) {\r\n                var w = n.divide(d), //divide out whole\r\n                        r = n.subtract(w.multiply(d)); //get remainder\r\n\r\n                narr.push(w);\r\n                if(r.equals(0))\r\n                    break;\r\n                n = r.times(10); //shift one dec place\r\n            }\r\n            var whole = narr.shift();\r\n            if(narr.length === 0) {\r\n                return sign + whole.toString();\r\n            }\r\n\r\n            if(i === prec) {\r\n                var lt = [];\r\n                //get the last two so we can round it\r\n                for(var i = 0; i < 2; i++)\r\n                    lt.unshift(narr.pop());\r\n                //put the last digit back by rounding the last two\r\n                narr.push(Math.round(lt.join('.')));\r\n            }\r\n\r\n            var dec = whole.toString() + '.' + narr.join('');\r\n            return sign + dec;\r\n        },\r\n        toDecimal: function (prec) {\r\n            prec = prec || Settings.PRECISION;\r\n            if(prec) {\r\n                return this.decimal(prec);\r\n            }\r\n            else\r\n                return this.num / this.den;\r\n        },\r\n        qcompare: function (n) {\r\n            return [this.num.multiply(n.den), n.num.multiply(this.den)];\r\n        },\r\n        equals: function (n) {\r\n            if(!isNaN(n))\r\n                n = new Frac(n);\r\n            var q = this.qcompare(n);\r\n\r\n            return q[0].equals(q[1]);\r\n        },\r\n        absEquals: function (n) {\r\n            if(!isNaN(n))\r\n                n = new Frac(n);\r\n            var q = this.qcompare(n);\r\n\r\n            return q[0].abs().equals(q[1]);\r\n        },\r\n        //lazy check to be fixed. Sufficient for now but will cause future problems\r\n        greaterThan: function (n) {\r\n            if(!isNaN(n))\r\n                n = new Frac(n);\r\n            var q = this.qcompare(n);\r\n\r\n            return q[0].gt(q[1]);\r\n        },\r\n        gte: function (n) {\r\n            return this.greaterThan(n) || this.equals(n);\r\n        },\r\n        lte: function (n) {\r\n            return this.lessThan(n) || this.equals(n);\r\n        },\r\n        lessThan: function (n) {\r\n            if(!isNaN(n))\r\n                n = new Frac(n);\r\n            var q = this.qcompare(n);\r\n\r\n            return q[0].lt(q[1]);\r\n        },\r\n        isInteger: function () {\r\n            return this.den.equals(1);\r\n        },\r\n        negate: function () {\r\n            this.num = this.num.multiply(-1);\r\n            return this;\r\n        },\r\n        invert: function () {\r\n            var t = this.den;\r\n            //why invert 0/1? It'll become 1/0 and that's a lie.\r\n            if(!this.num.equals(0)) {\r\n                var isnegative = this.num.isNegative();\r\n                this.den = this.num.abs();\r\n                this.num = t;\r\n                if(isnegative)\r\n                    this.num = this.num.multiply(-1);\r\n            }\r\n\r\n            return this;\r\n        },\r\n        isOne: function () {\r\n            return this.num.equals(1) && this.den.equals(1);\r\n        },\r\n        sign: function () {\r\n            return this.num.isNegative() ? -1 : 1;\r\n        },\r\n        abs: function () {\r\n            this.num = this.num.abs();\r\n            return this;\r\n        },\r\n        gcd: function (f) {\r\n            return Frac.quick(bigInt.gcd(f.num, this.num), bigInt.lcm(f.den, this.den));\r\n        },\r\n        toString: function () {\r\n            return !this.den.equals(1) ? this.num.toString() + '/' + this.den.toString() : this.num.toString();\r\n        },\r\n        valueOf: function () {\r\n//            if(this.num == 24) throw new Error(999)\r\n            if(Settings.USE_BIG)\r\n                return new bigDec(this.num.toString()).div(new bigDec(this.den.toString()));\r\n            return this.num / this.den;\r\n        },\r\n        isNegative: function () {\r\n            return this.toDecimal() < 0;\r\n        }\r\n    };\r\n\r\n//Symbol =======================================================================\r\n    /**\r\n     * All symbols e.g. x, y, z, etc or functions are wrapped in this class. All symbols have a multiplier and a group.\r\n     * All symbols except for \"numbers (group N)\" have a power.\r\n     * @class Primary data type for the Parser.\r\n     * @param {String} obj\r\n     * @returns {Symbol}\r\n     */\r\n    function Symbol(obj) {\r\n        var isInfinity = obj === 'Infinity';\r\n        // This enables the class to be instantiated without the new operator\r\n        if(!(this instanceof Symbol)) {\r\n            return new Symbol(obj);\r\n        }\r\n        // Convert big numbers to a string\r\n        if(obj instanceof bigDec) {\r\n            obj = obj.toString();\r\n        }\r\n        //define numeric symbols\r\n        if(/^(\\-?\\+?\\d+)\\.?\\d*e?\\-?\\+?\\d*/i.test(obj) || obj instanceof bigDec) {\r\n            this.group = N;\r\n            this.value = CONST_HASH;\r\n            this.multiplier = new Frac(obj);\r\n        }\r\n        //define symbolic symbols\r\n        else {\r\n            this.group = S;\r\n            validateName(obj);\r\n            this.value = obj;\r\n            this.multiplier = new Frac(1);\r\n            this.imaginary = obj === Settings.IMAGINARY;\r\n            this.isInfinity = isInfinity;\r\n        }\r\n\r\n        //As of 6.0.0 we switched to infinite precision so all objects have a power\r\n        //Although this is still redundant in constants, it simplifies the logic in\r\n        //other parts so we'll keep it\r\n        this.power = new Frac(1);\r\n\r\n        // Added to silence the strict warning.\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns vanilla imaginary symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Symbol.imaginary = function () {\r\n        var s = new Symbol(Settings.IMAGINARY);\r\n        s.imaginary = true;\r\n        return s;\r\n    };\r\n    /**\r\n     * Return nerdamer's representation of Infinity\r\n     * @param {int} negative -1 to return negative infinity\r\n     * @returns {Symbol}\r\n     */\r\n    Symbol.infinity = function (negative) {\r\n        var v = new Symbol('Infinity');\r\n        if(negative === -1)\r\n            v.negate();\r\n        return v;\r\n    };\r\n    Symbol.shell = function (group, value) {\r\n        var symbol = new Symbol(value);\r\n        symbol.group = group;\r\n        symbol.symbols = {};\r\n        symbol.length = 0;\r\n        return symbol;\r\n    };\r\n    //sqrt(x) -> x^(1/2)\r\n    Symbol.unwrapSQRT = function (symbol, all) {\r\n        var p = symbol.power;\r\n        if(symbol.fname === SQRT && (symbol.isLinear() || all)) {\r\n            var t = symbol.args[0].clone();\r\n            t.power = t.power.multiply(new Frac(1 / 2));\r\n            t.multiplier = t.multiplier.multiply(symbol.multiplier);\r\n            symbol = t;\r\n            if(all)\r\n                symbol.power = p.multiply(new Frac(1 / 2));\r\n        }\r\n\r\n        return symbol;\r\n    };\r\n    Symbol.hyp = function (a, b) {\r\n        a = a || new Symbol(0);\r\n        b = b || new Symbol(0);\r\n        return _.sqrt(_.add(_.pow(a.clone(), new Symbol(2)), _.pow(b.clone(), new Symbol(2))));\r\n    };\r\n    //converts to polar form array\r\n    Symbol.toPolarFormArray = function (symbol) {\r\n        var re, im, r, theta;\r\n        re = symbol.realpart();\r\n        im = symbol.imagpart();\r\n        r = Symbol.hyp(re, im);\r\n        theta = re.equals(0) ? _.parse('pi/2') : _.trig.atan(_.divide(im, re));\r\n        return [r, theta];\r\n    };\r\n    //removes parentheses\r\n    Symbol.unwrapPARENS = function (symbol) {\r\n        if(symbol.fname === '') {\r\n            var r = symbol.args[0];\r\n            r.power = r.power.multiply(symbol.power);\r\n            r.multiplier = r.multiplier.multiply(symbol.multiplier);\r\n            if(symbol.fname === '')\r\n                return Symbol.unwrapPARENS(r);\r\n            return r;\r\n        }\r\n        return symbol;\r\n    };\r\n    //quickly creates a Symbol\r\n    Symbol.create = function (value, power) {\r\n        power = power === undefined ? 1 : power;\r\n        return _.parse('(' + value + ')^(' + power + ')');\r\n    };\r\n    Symbol.prototype = {\r\n        /**\r\n         * Gets nth root accounting for rounding errors\r\n         * @param {Number} n\r\n         * @return {Number}\r\n         */\r\n        getNth: function (n) {\r\n            // First calculate the root\r\n            var root = evaluate(_.pow(_.parse(this.multiplier), _.parse(n).invert()));\r\n            // Round of any errors\r\n            var rounded = _.parse(nround(root));\r\n            // Reverse the root\r\n            var e = evaluate(_.pow(rounded, _.parse(n)));\r\n            // If the rounded root equals the original number then we're good \r\n            if(e.equals(_.parse(this.multiplier))) {\r\n                return rounded;\r\n            }\r\n            // Otherwise return the unrounded version\r\n            return root;\r\n        },\r\n        /**\r\n         * Checks if symbol is to the nth power\r\n         * @returns {Boolean}\r\n         */\r\n        isToNth: function (n) {\r\n            // Start by check in the multiplier for squareness\r\n            // First get the root but round it because currently we still depend \r\n            var root = this.getNth(n);\r\n            var nthMultiplier = isInt(root);\r\n            var nthPower;\r\n\r\n            if(this.group === CB) {\r\n                // Start by assuming that all will be square.\r\n                nthPower = true;\r\n                // All it takes is for one of the symbols to not have an even power\r\n                // e.g. x^n1*y^n2 requires that both n1 and n2 are even\r\n                this.each(function (x) {\r\n                    var isNth = x.isToNth(n);\r\n\r\n                    if(!isNth) {\r\n                        nthPower = false;\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                // Check if the power is divisible by n if it's not a number.\r\n                nthPower = this.group === N ? true : isInt(_.divide(_.parse(this.power), _.parse(n)));\r\n            }\r\n\r\n            return nthMultiplier && nthPower;\r\n        },\r\n        /**\r\n         * Checks if a symbol is square\r\n         * @return {Boolean}\r\n         */\r\n        isSquare: function () {\r\n            return this.isToNth(2);\r\n        },\r\n        /**\r\n         * Checks if a symbol is cube\r\n         * @return {Boolean}\r\n         */\r\n        isCube: function () {\r\n            return this.isToNth(3);\r\n        },\r\n        /**\r\n         * Checks if a symbol is a bare variable\r\n         * @return {Boolean}\r\n         */\r\n        isSimple: function () {\r\n            return this.power.equals(1) && this.multiplier.equals(1);\r\n        },\r\n        /**\r\n         * Simplifies the power of the symbol\r\n         * @returns {Symbol} a clone of the symbol\r\n         */\r\n        powSimp: function () {\r\n            if(this.group === CB) {\r\n                var powers = [],\r\n                        sign = this.multiplier.sign();\r\n                this.each(function (x) {\r\n                    var p = x.power;\r\n                    //why waste time if I can't do anything anyway\r\n                    if(isSymbol(p) || p.equals(1))\r\n                        return this.clone();\r\n                    powers.push(p);\r\n                });\r\n                var min = new Frac(arrayMin(powers));\r\n\r\n                //handle the coefficient\r\n                //handle the multiplier\r\n                var sign = this.multiplier.sign(),\r\n                        m = this.multiplier.clone().abs(),\r\n                        mfactors = Math2.ifactor(m);\r\n                //if we have a multiplier of 6750 and a min of 2 then the factors are 5^3*5^3*2\r\n                //we can then reduce it to 2*3*5*(15)^2\r\n                var out_ = new Frac(1);\r\n                var in_ = new Frac(1);\r\n\r\n                for(var x in mfactors) {\r\n                    var n = new Frac(mfactors[x]);\r\n                    if(!n.lessThan(min)) {\r\n                        n = n.divide(min).subtract(new Frac(1));\r\n                        in_ = in_.multiply(new Frac(x)); //move the factor inside the bracket\r\n                    }\r\n\r\n                    out_ = out_.multiply(_.parse(inBrackets(x) + '^' + inBrackets(n)).multiplier);\r\n                }\r\n                var t = new Symbol(in_);\r\n                this.each(function (x) {\r\n                    x = x.clone();\r\n                    x.power = x.power.divide(min);\r\n                    t = _.multiply(t, x);\r\n                });\r\n\r\n                var xt = _.symfunction(PARENTHESIS, [t]);\r\n                xt.power = min;\r\n                xt.multiplier = sign < 0 ? out_.negate() : out_;\r\n\r\n                return xt;\r\n            }\r\n            return this.clone();\r\n        },\r\n        /**\r\n         * Checks to see if two functions are of equal value\r\n         * @param {Symbol} symbol\r\n         */\r\n        equals: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.value === symbol.value && this.power.equals(symbol.power)\r\n                    && this.multiplier.equals(symbol.multiplier)\r\n                    && this.group === symbol.group;\r\n        },\r\n        abs: function () {\r\n            var e = this.clone();\r\n            e.multiplier.abs();\r\n            return e;\r\n        },\r\n        // Greater than\r\n        gt: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.isConstant() && symbol.isConstant() && this.multiplier.greaterThan(symbol.multiplier);\r\n        },\r\n        // Greater than\r\n        gte: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.equals(symbol) ||\r\n                    this.isConstant() && symbol.isConstant() && this.multiplier.greaterThan(symbol.multiplier);\r\n        },\r\n        // Less than\r\n        lt: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.isConstant() && symbol.isConstant() && this.multiplier.lessThan(symbol.multiplier);\r\n        },\r\n        // Less than\r\n        lte: function (symbol) {\r\n            if(!isSymbol(symbol))\r\n                symbol = new Symbol(symbol);\r\n            return this.equals(symbol) ||\r\n                    this.isConstant() && symbol.isConstant() && this.multiplier.lessThan(symbol.multiplier);\r\n        },\r\n        /**\r\n         * Because nerdamer doesn't group symbols by polynomials but\r\n         * rather a custom grouping method, this has to be\r\n         * reinserted in order to make use of most algorithms. This function\r\n         * checks if the symbol meets the criteria of a polynomial.\r\n         * @param {bool} multivariate\r\n         * @returns {boolean}\r\n         */\r\n        isPoly: function (multivariate) {\r\n            var g = this.group,\r\n                    p = this.power;\r\n            //the power must be a integer so fail if it's not\r\n            if(!isInt(p) || p < 0)\r\n                return false;\r\n            //constants and first orders\r\n            if(g === N || g === S || this.isConstant(true))\r\n                return true;\r\n            var vars = variables(this);\r\n            if(g === CB && vars.length === 1) {\r\n                //the variable is assumed the only one that was found\r\n                var v = vars[0];\r\n                //if no variable then guess what!?!? We're done!!! We have a polynomial.\r\n                if(!v)\r\n                    return true;\r\n                for(var x in this.symbols) {\r\n                    var sym = this.symbols[x];\r\n                    //sqrt(x)\r\n                    if(sym.group === FN && !sym.args[0].isConstant())\r\n                        return false;\r\n                    if(!sym.contains(v) && !sym.isConstant(true))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n            //PL groups. These only fail if a power is not an int\r\n            //this should handle cases such as x^2*t\r\n            if(this.isComposite() || g === CB && multivariate) {\r\n                //fail if we're not checking for multivariate polynomials\r\n                if(!multivariate && vars.length > 1)\r\n                    return false;\r\n                //loop though the symbols and check if they qualify\r\n                for(var x in this.symbols) {\r\n                    //we've already the symbols if we're not checking for multivariates at this point\r\n                    //so we check the sub-symbols\r\n                    if(!this.symbols[x].isPoly(multivariate))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n            else\r\n                return false;\r\n\r\n            /*\r\n             //all tests must have passed so we must be dealing with a polynomial\r\n             return true;\r\n             */\r\n        },\r\n        //removes the requested variable from the symbol and returns the remainder\r\n        stripVar: function (x, exclude_x) {\r\n            var retval;\r\n            if((this.group === PL || this.group === S) && this.value === x)\r\n                retval = new Symbol(exclude_x ? 0 : this.multiplier);\r\n            else if(this.group === CB && this.isLinear()) {\r\n                retval = new Symbol(1);\r\n                this.each(function (s) {\r\n                    if(!s.contains(x, true))\r\n                        retval = _.multiply(retval, s.clone());\r\n                });\r\n                retval.multiplier = retval.multiplier.multiply(this.multiplier);\r\n            }\r\n            else if(this.group === CP && !this.isLinear()) {\r\n                retval = new Symbol(this.multiplier);\r\n            }\r\n            else if(this.group === CP && this.isLinear()) {\r\n                retval = new Symbol(0);\r\n                this.each(function (s) {\r\n                    if(!s.contains(x)) {\r\n                        var t = s.clone();\r\n                        t.multiplier = t.multiplier.multiply(this.multiplier);\r\n                        retval = _.add(retval, t);\r\n                    }\r\n                });\r\n                //BIG TODO!!! It doesn't make much sense\r\n                if(retval.equals(0))\r\n                    retval = new Symbol(this.multiplier);\r\n            }\r\n            else if(this.group === EX && this.power.contains(x, true)) {\r\n                retval = new Symbol(this.multiplier);\r\n            }\r\n            else if(this.group === FN && this.contains(x)) {\r\n                retval = new Symbol(this.multiplier);\r\n            }\r\n            else\r\n                //wth? This should technically be the multiplier.\r\n                //Unfortunately this method wasn't very well thought out :`(.\r\n                //should be: retval = new Symbol(this.multiplier);\r\n                //use: ((1+x^2)*sqrt(-1+x^2))^(-1) for correction.\r\n                //this will break a bunch of unit tests so be ready to for the long haul\r\n                retval = this.clone();\r\n\r\n\r\n            return retval;\r\n        },\r\n        //returns symbol in array form with x as base e.g. a*x^2+b*x+c = [c, b, a].\r\n        toArray: function (v, arr) {\r\n            arr = arr || {\r\n                arr: [],\r\n                add: function (x, idx) {\r\n                    var e = this.arr[idx];\r\n                    this.arr[idx] = e ? _.add(e, x) : x;\r\n                }\r\n            };\r\n            var g = this.group;\r\n\r\n            if(g === S && this.contains(v)) {\r\n                arr.add(new Symbol(this.multiplier), this.power);\r\n            }\r\n            else if(g === CB) {\r\n                var a = this.stripVar(v),\r\n                        x = _.divide(this.clone(), a.clone());\r\n                var p = x.isConstant() ? 0 : x.power;\r\n                arr.add(a, p);\r\n            }\r\n            else if(g === PL && this.value === v) {\r\n                this.each(function (x, p) {\r\n                    arr.add(x.stripVar(v), p);\r\n                });\r\n            }\r\n            else if(g === CP) {\r\n                //the logic: they'll be broken into symbols so e.g. (x^2+x)+1 or (a*x^2+b*x+c)\r\n                //each case is handled above\r\n                this.each(function (x) {\r\n                    x.toArray(v, arr);\r\n                });\r\n            }\r\n            else if(this.contains(v)) {\r\n                throw new NerdamerTypeError('Cannot convert to array! Exiting');\r\n            }\r\n            else {\r\n                arr.add(this.clone(), 0); //it's just a constant wrt to v\r\n            }\r\n            //fill the holes\r\n            arr = arr.arr; //keep only the array since we don't need the object anymore\r\n            for(var i = 0; i < arr.length; i++)\r\n                if(!arr[i])\r\n                    arr[i] = new Symbol(0);\r\n            return arr;\r\n        },\r\n        //checks to see if a symbol contans a function\r\n        hasFunc: function (v) {\r\n            var fn_group = this.group === FN || this.group === EX;\r\n            if(fn_group && !v || fn_group && this.contains(v))\r\n                return true;\r\n            if(this.symbols) {\r\n                for(var x in this.symbols) {\r\n                    if(this.symbols[x].hasFunc(v))\r\n                        return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n        sub: function (a, b) {\r\n            a = !isSymbol(a) ? _.parse(a) : a.clone();\r\n            b = !isSymbol(b) ? _.parse(b) : b.clone();\r\n            if(a.group === N || a.group === P)\r\n                err('Cannot substitute a number. Must be a variable');\r\n            var same_pow = false,\r\n                    a_is_unit_multiplier = a.multiplier.equals(1),\r\n                    m = this.multiplier.clone(),\r\n                    retval;\r\n            /*\r\n             * In order to make the substitution the bases have to first match take\r\n             * (x+1)^x -> (x+1)=y || x^2 -> x=y^6\r\n             * In both cases the first condition is that the bases match so we begin there\r\n             * Either both are PL or both are not PL but we cannot have PL and a non-PL group match\r\n             */\r\n            if(this.value === a.value && (this.group !== PL && a.group !== PL || this.group === PL && a.group === PL)) {\r\n                //we cleared the first hurdle but a subsitution may not be possible just yet\r\n                if(a_is_unit_multiplier || a.multiplier.equals(this.multiplier)) {\r\n                    if(a.isLinear()) {\r\n                        retval = b;\r\n                    }\r\n                    else if(a.power.equals(this.power)) {\r\n                        retval = b;\r\n                        same_pow = true;\r\n                    }\r\n                    if(a.multiplier.equals(this.multiplier))\r\n                        m = new Frac(1);\r\n                }\r\n            }\r\n            //the next thing is to handle CB\r\n            else if(this.group === CB || this.previousGroup === CB) {\r\n                retval = new Symbol(1);\r\n                this.each(function (x) {\r\n                    var subbed = _.parse(x.sub(a, b)); //parse it again for safety\r\n                    retval = _.multiply(retval, subbed);\r\n\r\n                });\r\n            }\r\n            else if(this.isComposite()) {\r\n                var symbol = this.clone();\r\n\r\n                if(a.isComposite() && symbol.isComposite() && symbol.isLinear() && a.isLinear()) {\r\n                    var find = function (stack, needle) {\r\n                        for(var x in stack.symbols) {\r\n                            var sym = stack.symbols[x];\r\n                            //if the symbol equals the needle or it's within the sub-symbols we're done\r\n                            if(sym.isComposite() && find(sym, needle) || sym.equals(needle))\r\n                                return true;\r\n                        }\r\n                        return false;\r\n                    };\r\n                    //go fish\r\n                    for(var x in a.symbols) {\r\n                        if(!find(symbol, a.symbols[x]))\r\n                            return symbol.clone();\r\n                    }\r\n                    retval = _.add(_.subtract(symbol.clone(), a), b);\r\n                }\r\n                else {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, x.sub(a, b));\r\n                    });\r\n                }\r\n            }\r\n            else if(this.group === EX) {\r\n                // the parsed value could be a function so parse and sub\r\n                retval = _.parse(this.value).sub(a, b);\r\n            }\r\n            else if(this.group === FN) {\r\n                var nargs = [];\r\n                for(var i = 0; i < this.args.length; i++) {\r\n                    var arg = this.args[i];\r\n                    if(!isSymbol(arg))\r\n                        arg = _.parse(arg);\r\n                    nargs.push(arg.sub(a, b));\r\n                }\r\n                retval = _.symfunction(this.fname, nargs);\r\n            }\r\n            //if we did manage a substitution\r\n            if(retval) {\r\n                if(!same_pow) {\r\n                    //substitute the power\r\n                    var p = this.group === EX ? this.power.sub(a, b) : _.parse(this.power);\r\n                    //now raise the symbol to that power\r\n                    retval = _.pow(retval, p);\r\n                }\r\n\r\n                //transfer the multiplier\r\n                retval.multiplier = retval.multiplier.multiply(m);\r\n\r\n                //done\r\n                return retval;\r\n            }\r\n            //if all else fails\r\n            return this.clone();\r\n        },\r\n        isMonomial: function () {\r\n            if(this.group === S)\r\n                return true;\r\n            if(this.group === CB) {\r\n                for(var x in this.symbols)\r\n                    if(this.symbols[x].group !== S)\r\n                        return false;\r\n            }\r\n            else\r\n                return false;\r\n            return true;\r\n        },\r\n        isPi: function () {\r\n            return this.group === S && this.value === 'pi';\r\n        },\r\n        sign: function () {\r\n            return this.multiplier.sign();\r\n        },\r\n        isE: function () {\r\n            return this.value === 'e';\r\n        },\r\n        isSQRT: function () {\r\n            return this.fname === SQRT;\r\n        },\r\n        isConstant: function (check_all, check_symbols) {\r\n            if(check_symbols && this.group === CB) {\r\n                for(var x in this.symbols) {\r\n                    if(this.symbols[x].isConstant(true))\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            if(check_all === 'functions' && this.isComposite()) {\r\n                var isConstant = true;\r\n\r\n                this.each(function (x) {\r\n                    if(!x.isConstant(check_all, check_symbols)) {\r\n                        isConstant = false;\r\n                    }\r\n                }, true);\r\n\r\n                return isConstant;\r\n            }\r\n\r\n            if(check_all === 'all' && (this.isPi() || this.isE())) {\r\n                return true;\r\n            }\r\n\r\n            if(check_all && this.group === FN) {\r\n                for(var i = 0; i < this.args.length; i++) {\r\n                    if(!this.args[i].isConstant(check_all))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n\r\n            if(check_all)\r\n                return isNumericSymbol(this);\r\n            return this.value === CONST_HASH;\r\n        },\r\n        //the symbols is imaginary if\r\n        //1. n*i\r\n        //2. a+b*i\r\n        //3. a*i\r\n        isImaginary: function () {\r\n            if(this.imaginary)\r\n                return true;\r\n            else if(this.symbols) {\r\n                for(var x in this.symbols)\r\n                    if(this.symbols[x].isImaginary())\r\n                        return true;\r\n            }\r\n            return false;\r\n        },\r\n        /**\r\n         * Returns the real part of a symbol\r\n         * @returns {Symbol}\r\n         */\r\n        realpart: function () {\r\n            if(this.isConstant()) {\r\n                return this.clone();\r\n            }\r\n            else if(this.imaginary)\r\n                return new Symbol(0);\r\n            else if(this.isComposite()) {\r\n                var retval = new Symbol(0);\r\n                this.each(function (x) {\r\n                    retval = _.add(retval, x.realpart());\r\n                });\r\n                return retval;\r\n            }\r\n            else if(this.isImaginary())\r\n                return new Symbol(0);\r\n            return this.clone();\r\n        },\r\n        /*\r\n         * Return imaginary part of a symbol\r\n         * @returns {Symbol}\r\n         */\r\n        imagpart: function () {\r\n            if(this.group === S && this.isImaginary())\r\n                return new Symbol(this.multiplier);\r\n            if(this.isComposite()) {\r\n                var retval = new Symbol(0);\r\n                this.each(function (x) {\r\n                    retval = _.add(retval, x.imagpart());\r\n                });\r\n                return retval;\r\n            }\r\n            if(this.group === CB)\r\n                return this.stripVar(Settings.IMAGINARY);\r\n            return new Symbol(0);\r\n        },\r\n        isInteger: function () {\r\n            return this.isConstant() && this.multiplier.isInteger();\r\n        },\r\n        isLinear: function (wrt) {\r\n            if(wrt) {\r\n                if(this.isConstant())\r\n                    return true;\r\n                if(this.group === S) {\r\n                    if(this.value === wrt)\r\n                        return this.power.equals(1);\r\n                    else\r\n                        return true;\r\n                }\r\n\r\n                if(this.isComposite() && this.power.equals(1)) {\r\n                    for(var x in this.symbols) {\r\n                        if(!this.symbols[x].isLinear(wrt))\r\n                            return false;\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                if(this.group === CB && this.symbols[wrt])\r\n                    return this.symbols[wrt].isLinear(wrt);\r\n                return false;\r\n            }\r\n            else\r\n                return this.power.equals(1);\r\n        },\r\n        /**\r\n         * Checks to see if a symbol has a function by a specified name or within a specified list\r\n         * @param {String|String[]} names\r\n         * @returns {Boolean}\r\n         */\r\n        containsFunction: function (names) {\r\n            if(typeof names === 'string')\r\n                names = [names];\r\n            if(this.group === FN && names.indexOf(this.fname) !== -1)\r\n                return true;\r\n            if(this.symbols) {\r\n                for(var x in this.symbols) {\r\n                    if(this.symbols[x].containsFunction(names))\r\n                        return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n        multiplyPower: function (p2) {\r\n            //leave out 1\r\n            if(this.group === N && this.multiplier.equals(1))\r\n                return this;\r\n\r\n            var p1 = this.power;\r\n\r\n            if(this.group !== EX && p2.group === N) {\r\n                var p = p2.multiplier;\r\n                if(this.group === N && !p.isInteger()) {\r\n                    this.convert(P);\r\n                }\r\n\r\n                this.power = p1.equals(1) ? p.clone() : p1.multiply(p);\r\n\r\n                if(this.group === P && isInt(this.power)) {\r\n                    //bring it back to an N\r\n                    this.value = Math.pow(this.value, this.power);\r\n                    this.toLinear();\r\n                    this.convert(N);\r\n                }\r\n            }\r\n            else {\r\n                if(this.group !== EX) {\r\n                    p1 = new Symbol(p1);\r\n                    this.convert(EX);\r\n                }\r\n                this.power = _.multiply(p1, p2);\r\n            }\r\n\r\n            return this;\r\n        },\r\n        setPower: function (p, retainSign) {\r\n            //leave out 1\r\n            if(this.group === N && this.multiplier.equals(1)) {\r\n                return this;\r\n            }\r\n            if(this.group === EX && !isSymbol(p)) {\r\n                this.group = this.previousGroup;\r\n                delete this.previousGroup;\r\n                if(this.group === N) {\r\n                    this.multiplier = new Frac(this.value);\r\n                    this.value = CONST_HASH;\r\n                }\r\n                else\r\n                    this.power = p;\r\n            }\r\n            else {\r\n                var isSymbolic = false;\r\n                if(isSymbol(p)) {\r\n                    if(p.group === N) {\r\n                        //p should be the multiplier instead\r\n                        p = p.multiplier;\r\n\r\n                    }\r\n                    else {\r\n                        isSymbolic = true;\r\n                    }\r\n                }\r\n                var group = isSymbolic ? EX : P;\r\n                this.power = p;\r\n                if(this.group === N && group)\r\n                    this.convert(group, retainSign);\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks to see if symbol is located in the denominator\r\n         * @returns {boolean}\r\n         */\r\n        isInverse: function () {\r\n            if(this.group === EX)\r\n                return (this.power.multiplier.lessThan(0));\r\n            return this.power < 0;\r\n        },\r\n        /**\r\n         * Make a duplicate of a symbol by copying a predefined list of items.\r\n         * The name 'copy' would probably be a more appropriate name.\r\n         * to a new symbol\r\n         * @param {Symbol} c\r\n         * @returns {Symbol}\r\n         */\r\n        clone: function (c) {\r\n            var clone = c || new Symbol(0),\r\n                    //list of properties excluding power as this may be a symbol and would also need to be a clone.\r\n                    properties = [\r\n                        'value', 'group', 'length', 'previousGroup', 'imaginary', 'fname', 'args', 'isInfinity', 'scientific'],\r\n                    l = properties.length, i;\r\n            if(this.symbols) {\r\n                clone.symbols = {};\r\n                for(var x in this.symbols) {\r\n                    clone.symbols[x] = this.symbols[x].clone();\r\n                }\r\n            }\r\n\r\n            for(i = 0; i < l; i++) {\r\n                if(this[properties[i]] !== undefined) {\r\n                    clone[properties[i]] = this[properties[i]];\r\n                }\r\n            }\r\n\r\n            clone.power = this.power.clone();\r\n            clone.multiplier = this.multiplier.clone();\r\n            //add back the flag to track if this symbol is a conversion symbol\r\n            if(this.isConversion)\r\n                clone.isConversion = this.isConversion;\r\n\r\n            if(this.isUnit)\r\n                clone.isUnit = this.isUnit;\r\n\r\n            return clone;\r\n        },\r\n        /**\r\n         * Converts a symbol multiplier to one.\r\n         * @param {Boolean} keepSign Keep the multiplier as negative if the multiplier is negative and keepSign is true\r\n         * @returns {Symbol}\r\n         */\r\n        toUnitMultiplier: function (keepSign) {\r\n            this.multiplier.num = new bigInt(this.multiplier.num.isNegative() && keepSign ? -1 : 1);\r\n            this.multiplier.den = new bigInt(1);\r\n            return this;\r\n        },\r\n        /**\r\n         * Converts a Symbol's power to one.\r\n         * @returns {Symbol}\r\n         */\r\n        toLinear: function () {\r\n            // Do nothing if it's already linear\r\n            if(this.power.equals(1)) {\r\n                return this;\r\n            }\r\n            this.setPower(new Frac(1));\r\n            return this;\r\n        },\r\n        /**\r\n         * Iterates over all the sub-symbols. If no sub-symbols exist then it's called on itself\r\n         * @param {Function} fn\r\n         * @@param {Boolean} deep If true it will itterate over the sub-symbols their symbols as well\r\n         */\r\n        each: function (fn, deep) {\r\n            if(!this.symbols) {\r\n                fn.call(this, this, this.value);\r\n            }\r\n            else {\r\n                for(var x in this.symbols) {\r\n                    var sym = this.symbols[x];\r\n                    if(sym.group === PL && deep) {\r\n                        for(var y in sym.symbols) {\r\n                            fn.call(x, sym.symbols[y], y);\r\n                        }\r\n                    }\r\n                    else\r\n                        fn.call(this, sym, x);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * A numeric value to be returned for Javascript. It will try to\r\n         * return a number as far a possible but in case of a pure symbolic\r\n         * symbol it will just return its text representation\r\n         * @returns {String|Number}\r\n         */\r\n        valueOf: function () {\r\n            if(this.group === N)\r\n                return this.multiplier.valueOf();\r\n            else if(this.power === 0) {\r\n                return 1;\r\n            }\r\n            else if(this.multiplier === 0) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return text(this, 'decimals');\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a symbols has a particular variable within it.\r\n         * Pass in true as second argument to include the power of exponentials\r\n         * which aren't check by default.\r\n         * @example var s = _.parse('x+y+z'); s.contains('y');\r\n         * //returns true\r\n         * @param {any} variable\r\n         * @param {boolean} all\r\n         * @returns {boolean}\r\n         */\r\n        contains: function (variable, all) {\r\n            //contains expects a string\r\n            variable = String(variable);\r\n            var g = this.group;\r\n            if(this.value === variable)\r\n                return true;\r\n            if(this.symbols) {\r\n                for(var x in this.symbols) {\r\n                    if(this.symbols[x].contains(variable, all))\r\n                        return true;\r\n                }\r\n            }\r\n            if(g === FN || this.previousGroup === FN) {\r\n                for(var i = 0; i < this.args.length; i++) {\r\n                    if(this.args[i].contains(variable, all))\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            if(g === EX) {\r\n                //exit only if it does\r\n                if(all && this.power.contains(variable, all)) {\r\n                    return true;\r\n                }\r\n                if(this.value === variable)\r\n                    return true;\r\n\r\n            }\r\n\r\n            return this.value === variable;\r\n        },\r\n        /**\r\n         * Negates a symbols\r\n         * @returns {boolean}\r\n         */\r\n        negate: function () {\r\n            this.multiplier.negate();\r\n            if(this.group === CP || this.group === PL)\r\n                this.distributeMultiplier();\r\n            return this;\r\n        },\r\n        /**\r\n         * Inverts a symbol\r\n         * @param {boolean} power_only\r\n         * @param {boolean} all\r\n         * @returns {boolean}\r\n         */\r\n        invert: function (power_only, all) {\r\n            //invert the multiplier\r\n            if(!power_only)\r\n                this.multiplier = this.multiplier.invert();\r\n            //invert the rest\r\n            if(isSymbol(this.power)) {\r\n                this.power.negate();\r\n            }\r\n            else if(this.group === CB && all) {\r\n                this.each(function (x) {\r\n                    return x.invert();\r\n                });\r\n            }\r\n            else {\r\n                if(this.power && this.group !== N)\r\n                    this.power.negate();\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Symbols of group CP or PL may have the multiplier being carried by\r\n         * the top level symbol at any given time e.g. 2*(x+y+z). This is\r\n         * convenient in many cases, however in some cases the multiplier needs\r\n         * to be carried individually e.g. 2*x+2*y+2*z.\r\n         * This method distributes the multiplier over the entire symbol\r\n         * @param {boolean} all\r\n         * @returns {Symbol}\r\n         */\r\n        distributeMultiplier: function (all) {\r\n            var is_one = all ? this.power.absEquals(1) : this.power.equals(1);\r\n            if(this.symbols && is_one && this.group !== CB && !this.multiplier.equals(1)) {\r\n                for(var x in this.symbols) {\r\n                    var s = this.symbols[x];\r\n                    s.multiplier = s.multiplier.multiply(this.multiplier);\r\n                    s.distributeMultiplier();\r\n                }\r\n                this.toUnitMultiplier();\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * This method expands the exponent over the entire symbol just like\r\n         * distributeMultiplier\r\n         * @returns {Symbol}\r\n         */\r\n        distributeExponent: function () {\r\n            if(!this.power.equals(1)) {\r\n                var p = this.power;\r\n                for(var x in this.symbols) {\r\n                    var s = this.symbols[x];\r\n                    if(s.group === EX) {\r\n                        s.power = _.multiply(s.power, new Symbol(p));\r\n                    }\r\n                    else {\r\n                        this.symbols[x].power = this.symbols[x].power.multiply(p);\r\n                    }\r\n                }\r\n                this.toLinear();\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * This method will attempt to up-convert or down-convert one symbol\r\n         * from one group to another. Not all symbols are convertible from one\r\n         * group to another however. In that case the symbol will remain\r\n         * unchanged.\r\n         * @param {int} group\r\n         * @param {string} imaginary\r\n         */\r\n        convert: function (group, imaginary) {\r\n            if(group > FN) {\r\n                //make a clone of this symbol;\r\n                var cp = this.clone();\r\n\r\n                //attach a symbols object and upgrade the group\r\n                this.symbols = {};\r\n\r\n                if(group === CB) {\r\n                    //symbol of group CB hold symbols bound together through multiplication\r\n                    //because of commutativity this multiplier can technically be anywhere within the group\r\n                    //to keep track of it however it's easier to always have the top level carry it\r\n                    cp.toUnitMultiplier();\r\n                }\r\n                else {\r\n                    //reset the symbol\r\n                    this.toUnitMultiplier();\r\n                }\r\n\r\n                if(this.group === FN) {\r\n                    cp.args = this.args;\r\n                    delete this.args;\r\n                    delete this.fname;\r\n                }\r\n\r\n                //the symbol may originate from the symbol i but this property no longer holds true\r\n                //after copying\r\n                if(this.isImgSymbol)\r\n                    delete this.isImgSymbol;\r\n\r\n                this.toLinear();\r\n                //attach a clone of this symbol to the symbols object using its proper key\r\n                this.symbols[cp.keyForGroup(group)] = cp;\r\n                this.group = group;\r\n                //objects by default don't have a length property. However, in order to keep track of the number\r\n                //of sub-symbols we have to impliment our own.\r\n                this.length = 1;\r\n            }\r\n            else if(group === EX) {\r\n                //1^x is just one so check and make sure\r\n                if(!(this.group === N && this.multiplier.equals(1))) {\r\n                    if(this.group !== EX)\r\n                        this.previousGroup = this.group;\r\n                    if(this.group === N) {\r\n                        this.value = this.multiplier.num.toString();\r\n                        this.toUnitMultiplier();\r\n                    }\r\n                    //update the hash to reflect the accurate hash\r\n                    else\r\n                        this.value = text(this, 'hash');\r\n\r\n                    this.group = EX;\r\n                }\r\n            }\r\n            else if(group === N) {\r\n                var m = this.multiplier.toDecimal();\r\n                if(this.symbols)\r\n                    this.symbols = undefined;\r\n                new Symbol(this.group === P ? m * Math.pow(this.value, this.power) : m).clone(this);\r\n            }\r\n            else if(group === P && this.group === N) {\r\n                this.value = imaginary ? this.multiplier.num.toString() : Math.abs(this.multiplier.num.toString());\r\n                this.toUnitMultiplier(!imaginary);\r\n                this.group = P;\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * This method is one of the principal methods to make it all possible.\r\n         * It performs cleanup and prep operations whenever a symbols is\r\n         * inserted. If the symbols results in a 1 in a CB (multiplication)\r\n         * group for instance it will remove the redundant symbol. Similarly\r\n         * in a symbol of group PL or CP (symbols glued by multiplication) it\r\n         * will remove any dangling zeroes from the symbol. It will also\r\n         * up-convert or down-convert a symbol if it detects that it's\r\n         * incorrectly grouped. It should be noted that this method is not\r\n         * called directly but rather by the 'attach' method for addition groups\r\n         * and the 'combine' method for multiplication groups.\r\n         * @param {Symbol} symbol\r\n         * @param {String} action\r\n         */\r\n        insert: function (symbol, action) {\r\n            //this check can be removed but saves a lot of aggravation when trying to hunt down\r\n            //a bug. If left, you will instantly know that the error can only be between 2 symbols.\r\n            if(!isSymbol(symbol))\r\n                err('Object ' + symbol + ' is not of type Symbol!');\r\n            if(this.symbols) {\r\n                var group = this.group;\r\n                if(group > FN) {\r\n                    var key = symbol.keyForGroup(group);\r\n                    var existing = key in this.symbols ? this.symbols[key] : false; //check if there's already a symbol there\r\n                    if(action === 'add') {\r\n                        var hash = key;\r\n                        if(existing) {\r\n                            //add them together using the parser\r\n                            this.symbols[hash] = _.add(existing, symbol);\r\n                            //if the addition resulted in a zero multiplier remove it\r\n                            if(this.symbols[hash].multiplier.equals(0)) {\r\n                                delete this.symbols[hash];\r\n                                this.length--;\r\n\r\n                                if(this.length === 0) {\r\n                                    this.convert(N);\r\n                                    this.multiplier = new Frac(0);\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            this.symbols[key] = symbol;\r\n                            this.length++;\r\n                        }\r\n                    }\r\n                    else {\r\n                        //check if this is of group P and unwrap before inserting\r\n                        if(symbol.group === P && isInt(symbol.power)) {\r\n                            symbol.convert(N);\r\n                        }\r\n\r\n                        //transfer the multiplier to the upper symbol but only if the symbol numeric\r\n                        if(symbol.group !== EX) {\r\n                            this.multiplier = this.multiplier.multiply(symbol.multiplier);\r\n                            symbol.toUnitMultiplier();\r\n                        }\r\n                        else {\r\n                            symbol.parens = symbol.multiplier.lessThan(0);\r\n                            this.multiplier = this.multiplier.multiply(symbol.multiplier.clone().abs());\r\n                            symbol.toUnitMultiplier(true);\r\n                        }\r\n\r\n                        if(existing) {\r\n                            //remove because the symbol may have changed\r\n                            symbol = _.multiply(remove(this.symbols, key), symbol);\r\n                            if(symbol.isConstant()) {\r\n                                this.multiplier = this.multiplier.multiply(symbol.multiplier);\r\n                                symbol = new Symbol(1); //the dirty work gets done down the line when it detects 1\r\n                            }\r\n\r\n                            this.length--;\r\n                            //clean up\r\n                        }\r\n\r\n                        //don't insert the symbol if it's 1\r\n                        if(!symbol.isOne(true)) {\r\n                            this.symbols[key] = symbol;\r\n                            this.length++;\r\n                        }\r\n                        else if(symbol.multiplier.lessThan(0)) {\r\n                            this.negate(); //put back the sign\r\n                        }\r\n                    }\r\n\r\n                    //clean up\r\n                    if(this.length === 0)\r\n                        this.convert(N);\r\n                    //update the hash\r\n                    if(this.group === CP || this.group === CB) {\r\n                        this.updateHash();\r\n                    }\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        //the insert method for addition\r\n        attach: function (symbol) {\r\n            if(isArray(symbol)) {\r\n                for(var i = 0; i < symbol.length; i++)\r\n                    this.insert(symbol[i], 'add');\r\n                return this;\r\n            }\r\n            return this.insert(symbol, 'add');\r\n        },\r\n        //the insert method for multiplication\r\n        combine: function (symbol) {\r\n            if(isArray(symbol)) {\r\n                for(var i = 0; i < symbol.length; i++)\r\n                    this.insert(symbol[i], 'multiply');\r\n                return this;\r\n            }\r\n            return this.insert(symbol, 'multiply');\r\n        },\r\n        /**\r\n         * This method should be called after any major \"surgery\" on a symbol.\r\n         * It updates the hash of the symbol for example if the fname of a\r\n         * function has changed it will update the hash of the symbol.\r\n         */\r\n        updateHash: function () {\r\n            if(this.group === N)\r\n                return;\r\n\r\n            if(this.group === FN) {\r\n                var contents = '',\r\n                        args = this.args,\r\n                        is_parens = this.fname === PARENTHESIS;\r\n                for(var i = 0; i < args.length; i++)\r\n                    contents += (i === 0 ? '' : ',') + text(args[i]);\r\n                var fn_name = is_parens ? '' : this.fname;\r\n                this.value = fn_name + (is_parens ? contents : inBrackets(contents));\r\n            }\r\n            else if(!(this.group === S || this.group === PL)) {\r\n                this.value = text(this, 'hash');\r\n            }\r\n        },\r\n        /**\r\n         * this function defines how every group in stored within a group of\r\n         * higher order think of it as the switchboard for the library. It\r\n         * defines the hashes for symbols.\r\n         * @param {int} group\r\n         */\r\n        keyForGroup: function (group) {\r\n            var g = this.group;\r\n            var key;\r\n\r\n            if(g === N) {\r\n                key = this.value;\r\n            }\r\n            else if(g === S || g === P) {\r\n                if(group === PL)\r\n                    key = this.power.toDecimal();\r\n                else\r\n                    key = this.value;\r\n            }\r\n            else if(g === FN) {\r\n                if(group === PL)\r\n                    key = this.power.toDecimal();\r\n                else\r\n                    key = text(this, 'hash');\r\n            }\r\n            else if(g === PL) {\r\n                //if the order is reversed then we'll assume multiplication\r\n                //TODO: possible future dilemma\r\n                if(group === CB)\r\n                    key = text(this, 'hash');\r\n                else if(group === CP) {\r\n                    if(this.power.equals(1))\r\n                        key = this.value;\r\n                    else\r\n                        key = inBrackets(text(this, 'hash')) + Settings.POWER_OPERATOR + this.power.toDecimal();\r\n                }\r\n                else if(group === PL)\r\n                    key = this.power.toString();\r\n                else\r\n                    key = this.value;\r\n                return key;\r\n            }\r\n            else if(g === CP) {\r\n                if(group === CP) {\r\n                    key = text(this, 'hash');\r\n                }\r\n                if(group === PL)\r\n                    key = this.power.toDecimal();\r\n                else\r\n                    key = this.value;\r\n            }\r\n            else if(g === CB) {\r\n                if(group === PL)\r\n                    key = this.power.toDecimal();\r\n                else\r\n                    key = text(this, 'hash');\r\n            }\r\n            else if(g === EX) {\r\n                if(group === PL)\r\n                    key = text(this.power);\r\n                else\r\n                    key = text(this, 'hash');\r\n            }\r\n\r\n            return key;\r\n        },\r\n        /**\r\n         * Symbols are typically stored in an object which works fine for most\r\n         * cases but presents a problem when the order of the symbols makes\r\n         * a difference. This function simply collects all the symbols and\r\n         * returns them as an array. If a function is supplied then that\r\n         * function is called on every symbol contained within the object.\r\n         * @param {Function} fn\r\n         * @param {Object} opt\r\n         * @param {Function} sort_fn\r\n         * @@param {Boolean} expand_symbol\r\n         * @returns {Array}\r\n         */\r\n        collectSymbols: function (fn, opt, sort_fn, expand_symbol) {\r\n            var collected = [];\r\n            if(!this.symbols)\r\n                collected.push(this);\r\n            else {\r\n                for(var x in this.symbols) {\r\n                    var symbol = this.symbols[x];\r\n                    if(expand_symbol && (symbol.group === PL || symbol.group === CP)) {\r\n                        collected = collected.concat(symbol.collectSymbols());\r\n                    }\r\n                    else\r\n                        collected.push(fn ? fn(symbol, opt) : symbol);\r\n                }\r\n            }\r\n            if(sort_fn === null)\r\n                sort_fn = undefined; //WTF Firefox? Seriously?\r\n\r\n            return collected.sort(sort_fn);//sort hopefully gives us some sort of consistency\r\n        },\r\n        /**\r\n         * Returns the latex representation of the symbol\r\n         * @param {String} option\r\n         * @returns {String}\r\n         */\r\n        latex: function (option) {\r\n            return LaTeX.latex(this, option);\r\n        },\r\n        /**\r\n         * Returns the text representation of a symbol\r\n         * @param {String} option\r\n         * @returns {String}\r\n         */\r\n        text: function (option) {\r\n            return text(this, option);\r\n        },\r\n        /**\r\n         * Checks if the function evaluates to 1. e.g. x^0 or 1 :)\r\n         * @@param {bool} abs Compares the absolute value\r\n         */\r\n        isOne: function (abs) {\r\n            var f = abs ? 'absEquals' : 'equals';\r\n            if(this.group === N)\r\n                return this.multiplier[f](1);\r\n            else\r\n                return this.power.equals(0);\r\n        },\r\n        isComposite: function () {\r\n            var g = this.group,\r\n                    pg = this.previousGroup;\r\n            return g === CP || g === PL || pg === PL || pg === CP;\r\n        },\r\n        isCombination: function () {\r\n            var g = this.group,\r\n                    pg = this.previousGroup;\r\n            return g === CB || pg === CB;\r\n        },\r\n        lessThan: function (n) {\r\n            return this.multiplier.lessThan(n);\r\n        },\r\n        greaterThan: function (n) {\r\n            if(!isSymbol(n)) {\r\n                n = new Symbol(n);\r\n            }\r\n\r\n            // We can't tell for sure if a is greater than be if they're not both numbers\r\n            if(!this.isConstant(true) || !n.isConstant(true)) {\r\n                return false;\r\n            }\r\n\r\n            return this.multiplier.greaterThan(n.multiplier);\r\n        },\r\n        /**\r\n         * Get's the denominator of the symbol if the symbol is of class CB (multiplication)\r\n         * with other classes the symbol is either the denominator or not.\r\n         * Take x^-1+x^-2. If the symbol was to be mixed such as x+x^-2 then the symbol doesn't have have an exclusive\r\n         * denominator and has to be found by looking at the actual symbols themselves.\r\n         */\r\n        getDenom: function () {\r\n            var retval, symbol;\r\n            symbol = this.clone();\r\n            //e.g. 1/(x*(x+1))\r\n            if(this.group === CB && this.power.lessThan(0))\r\n                symbol = _.expand(symbol);\r\n\r\n            //if the symbol already is the denominator... DONE!!!\r\n            if(symbol.power.lessThan(0)) {\r\n                var d = _.parse(symbol.multiplier.den);\r\n                retval = symbol.toUnitMultiplier();\r\n                retval.power.negate();\r\n                retval = _.multiply(d, retval); //put back the coeff\r\n            }\r\n            else if(symbol.group === CB) {\r\n                retval = _.parse(symbol.multiplier.den);\r\n                for(var x in symbol.symbols)\r\n                    if(symbol.symbols[x].power < 0)\r\n                        retval = _.multiply(retval, symbol.symbols[x].clone().invert());\r\n            }\r\n            else\r\n                retval = _.parse(symbol.multiplier.den);\r\n            return retval;\r\n        },\r\n        getNum: function () {\r\n            var retval, symbol;\r\n            symbol = this.clone();\r\n            //e.g. 1/(x*(x+1))\r\n            if(symbol.group === CB && symbol.power.lessThan(0))\r\n                symbol = _.expand(symbol);\r\n            //if the symbol already is the denominator... DONE!!!\r\n            if(symbol.power.greaterThan(0) && symbol.group !== CB) {\r\n                retval = _.multiply(_.parse(symbol.multiplier.num), symbol.toUnitMultiplier());\r\n            }\r\n            else if(symbol.group === CB) {\r\n                retval = _.parse(symbol.multiplier.num);\r\n                symbol.each(function (x) {\r\n                    if(x.power > 0 || x.group === EX && x.power.multiplier > 0) {\r\n                        retval = _.multiply(retval, x.clone());\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                retval = _.parse(symbol.multiplier.num);\r\n            }\r\n            return retval;\r\n        },\r\n        toString: function () {\r\n            return this.text();\r\n        }\r\n    };\r\n\r\n//Parser =======================================================================\r\n    //Uses modified Shunting-yard algorithm. http://en.wikipedia.org/wiki/Shunting-yard_algorithm\r\n    function Parser() {\r\n        //Point to the local parser instead of the global one\r\n        var _ = this;\r\n        var bin = {};\r\n        var preprocessors = {names: [], actions: []};\r\n\r\n//Parser.classes ===============================================================\r\n        function Slice(upper, lower) {\r\n            this.start = upper;\r\n            this.end = lower;\r\n        }\r\n        ;\r\n        Slice.prototype.isConstant = function () {\r\n            return this.start.isConstant() && this.end.isConstant();\r\n        };\r\n        Slice.prototype.text = function () {\r\n            return text(this.start) + ':' + text(this.end);\r\n        };\r\n\r\n        /**\r\n         * Class used to collect arguments for functions\r\n         * @returns {Parser.Collection}\r\n         */\r\n        function Collection() {\r\n            this.elements = [];\r\n        }\r\n        Collection.prototype.append = function (e) {\r\n            this.elements.push(e);\r\n        };\r\n        Collection.prototype.getItems = function () {\r\n            return this.elements;\r\n        };\r\n        Collection.prototype.toString = function () {\r\n            return _.pretty_print(this.elements);\r\n        };\r\n        Collection.create = function (e) {\r\n            var collection = new Collection();\r\n            if(e)\r\n                collection.append(e);\r\n            return collection;\r\n        };\r\n\r\n        function Token(node, node_type, column) {\r\n            this.type = node_type;\r\n            this.value = node;\r\n            if(column !== undefined)\r\n                this.column = column + 1;\r\n            if(node_type === Token.OPERATOR) {\r\n                //copy everything over from the operator\r\n                var operator = operators[node];\r\n                for(var x in operator)\r\n                    this[x] = operator[x];\r\n\r\n            }\r\n            else if(node_type === Token.FUNCTION) {\r\n                this.precedence = Token.MAX_PRECEDENCE; //leave enough roon\r\n                this.leftAssoc = false;\r\n            }\r\n        }\r\n        Token.prototype.toString = function () {\r\n            return this.value;\r\n        };\r\n        Token.prototype.toString = function () {\r\n            if(this.is_prefix)\r\n                return '`' + this.value;\r\n            return this.value;\r\n        };\r\n        //some constants\r\n        Token.OPERATOR = 'OPERATOR';\r\n        Token.VARIABLE_OR_LITERAL = 'VARIABLE_OR_LITERAL';\r\n        Token.FUNCTION = 'FUNCTION';\r\n        Token.UNIT = 'UNIT';\r\n        Token.KEYWORD = 'KEYWORD';\r\n        Token.MAX_PRECEDENCE = 999;\r\n        //create link to classes\r\n        this.classes = {\r\n            Collection: Collection,\r\n            Slice: Slice,\r\n            Token: Token\r\n        };\r\n//Parser.modules ===============================================================\r\n        //object for functions which handle complex number\r\n        var complex = {\r\n            prec: undefined,\r\n            cos: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.cos(r) * Math.cosh(i));\r\n                im = _.parse(Math.sin(r) * Math.sinh(i));\r\n                return _.subtract(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            sin: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.sin(r) * Math.cosh(i));\r\n                im = _.parse(Math.cos(r) * Math.sinh(i));\r\n                return _.subtract(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            tan: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.sin(2 * r) / (Math.cos(2 * r) + Math.cosh(2 * i)));\r\n                im = _.parse(Math.sinh(2 * i) / (Math.cos(2 * r) + Math.cosh(2 * i)));\r\n                return _.add(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            sec: function (r, i) {\r\n                var t = this.removeDen(this.cos(r, i));\r\n                return _.subtract(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            csc: function (r, i) {\r\n                var t = this.removeDen(this.sin(r, i));\r\n                return _.add(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            cot: function (r, i) {\r\n                var t = this.removeDen(this.tan(r, i));\r\n                return _.subtract(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            acos: function (r, i) {\r\n                var symbol, sq, a, b, c, squared;\r\n                symbol = this.fromArray([r, i]);\r\n                squared = _.pow(symbol.clone(), new Symbol(2));\r\n                sq = _.expand(squared); //z*z\r\n                a = _.multiply(sqrt(_.subtract(new Symbol(1), sq)), Symbol.imaginary());\r\n                b = _.expand(_.add(symbol.clone(), a));\r\n                c = log(b);\r\n                return _.expand(_.multiply(Symbol.imaginary().negate(), c));\r\n            },\r\n            asin: function (r, i) {\r\n                return _.subtract(_.parse('pi/2'), this.acos(r, i));\r\n            },\r\n            atan: function (r, i) {\r\n                // Handle i and -i\r\n                if(r.equals(0) && (i.equals(1) || i.equals(-1))) {\r\n                    // Just copy Wolfram Alpha for now. The parenthesis \r\n                    return _.parse(`${Symbol.infinity()}*${Settings.IMAGINARY}*${i}`);\r\n                }\r\n                var a, b, c, symbol;\r\n                symbol = complex.fromArray([r, i]);\r\n                a = _.expand(_.multiply(Symbol.imaginary(), symbol.clone()));\r\n                b = log(_.expand(_.subtract(new Symbol(1), a.clone())));\r\n                c = log(_.expand(_.add(new Symbol(1), a.clone())));\r\n                return _.expand(_.multiply(_.divide(Symbol.imaginary(), new Symbol(2)), _.subtract(b, c)));\r\n            },\r\n            asec: function (r, i) {\r\n                var d = this.removeDen([r, i]);\r\n                d[1].negate();\r\n                return this.acos.apply(this, d);\r\n            },\r\n            acsc: function (r, i) {\r\n                var d = this.removeDen([r, i]);\r\n                d[1].negate();\r\n                return this.asin.apply(this, d);\r\n            },\r\n            acot: function (r, i) {\r\n                var d = this.removeDen([r, i]);\r\n                d[1].negate();\r\n                return this.atan.apply(this, d);\r\n            },\r\n            //Hyperbolic trig\r\n            cosh: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.cosh(r) * Math.cos(i));\r\n                im = _.parse(Math.sinh(r) * Math.sin(i));\r\n                return _.add(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            sinh: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.sinh(r) * Math.cos(i));\r\n                im = _.parse(Math.cosh(r) * Math.sin(i));\r\n                return _.add(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            tanh: function (r, i) {\r\n                var re, im;\r\n                re = _.parse(Math.sinh(2 * r) / (Math.cos(2 * i) + Math.cosh(2 * r)));\r\n                im = _.parse(Math.sin(2 * i) / (Math.cos(2 * i) + Math.cosh(2 * r)));\r\n                return _.subtract(re, _.multiply(im, Symbol.imaginary()));\r\n            },\r\n            sech: function (r, i) {\r\n                var t = this.removeDen(this.cosh(r, i));\r\n                return _.subtract(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            csch: function (r, i) {\r\n                var t = this.removeDen(this.sinh(r, i));\r\n                return _.subtract(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            coth: function (r, i) {\r\n                var t = this.removeDen(this.tanh(r, i));\r\n                return _.add(t[0], _.multiply(t[1], Symbol.imaginary()));\r\n            },\r\n            acosh: function (r, i) {\r\n                var a, b, z;\r\n                z = this.fromArray([r, i]);\r\n                a = sqrt(_.add(z.clone(), new Symbol(1)));\r\n                b = sqrt(_.subtract(z.clone(), new Symbol(1)));\r\n                return _.expand(log(_.add(z, _.expand(_.multiply(a, b)))));\r\n            },\r\n            asinh: function (r, i) {\r\n                var a, z;\r\n                z = this.fromArray([r, i]);\r\n                a = sqrt(_.add(new Symbol(1), _.expand(_.pow(z.clone(), new Symbol(2)))));\r\n                return _.expand(log(_.add(z, a)));\r\n            },\r\n            atanh: function (r, i) {\r\n                var a, b, z;\r\n                z = this.fromArray([r, i]);\r\n                a = log(_.add(z.clone(), new Symbol(1)));\r\n                b = log(_.subtract(new Symbol(1), z));\r\n                return _.expand(_.divide(_.subtract(a, b), new Symbol(2)));\r\n            },\r\n            asech: function (r, i) {\r\n                var t = this.removeDen([r, i]);\r\n                t[1].negate();\r\n                return this.acosh.apply(this, t);\r\n            },\r\n            acsch: function (r, i) {\r\n                var t = this.removeDen([r, i]);\r\n                t[1].negate();\r\n                return this.asinh.apply(this, t);\r\n            },\r\n            acoth: function (r, i) {\r\n                var t = this.removeDen([r, i]);\r\n                t[1].negate();\r\n                return this.atanh.apply(this, t);\r\n            },\r\n            sqrt: function (symbol) {\r\n                var re, im, h, a, d;\r\n                re = symbol.realpart();\r\n                im = symbol.imagpart();\r\n                h = Symbol.hyp(re, im);\r\n                a = _.add(re.clone(), h);\r\n                d = sqrt(_.multiply(new Symbol(2), a.clone()));\r\n                return _.add(_.divide(a.clone(), d.clone()), _.multiply(_.divide(im, d), Symbol.imaginary()));\r\n            },\r\n            log: function (r, i) {\r\n                var re, im, phi;\r\n                re = log(Symbol.hyp(r, i));\r\n                phi = Settings.USE_BIG ? Symbol(bigDec.atan2(i.multiplier.toDecimal(), r.multiplier.toDecimal())) : Math.atan2(i, r);\r\n                im = _.parse(phi);\r\n                return _.add(re, _.multiply(Symbol.imaginary(), im));\r\n            },\r\n            erf(symbol, n) {\r\n                //Do nothing for now. Revisit this in the future.\r\n                return _.symfunction('erf', [symbol]);\r\n\r\n                n = n || 30;\r\n\r\n                var f = function (R, I) {\r\n                    return block('PARSE2NUMBER', function () {\r\n                        var retval = new Symbol(0);\r\n                        for(var i = 0; i < n; i++) {\r\n                            var a, b;\r\n                            a = _.parse(bigDec.exp(bigDec(i).toPower(2).neg().dividedBy(bigDec(n).pow(2).plus(bigDec(R).toPower(2).times(4)))));\r\n                            b = _.parse(format('2*({1})-e^(-(2*{0}*{1}*{2}))*(2*{1}*cosh({2}*{3})-{0}*{3}*sinh({3}*{2}))', Settings.IMAGINARY, R, I, i));\r\n                            retval = _.add(retval, _.multiply(a, b));\r\n                        }\r\n                        return _.multiply(retval, new Symbol(2));\r\n                    }, true);\r\n                };\r\n                var re, im, a, b, c, k;\r\n                re = symbol.realpart();\r\n                im = symbol.imagpart();\r\n\r\n                k = _.parse(format('(e^(-{0}^2))/pi', re));\r\n                a = _.parse(format('(1-e^(-(2*{0}*{1}*{2})))/(2*{1})', Settings.IMAGINARY, re, im));\r\n                b = f(re.toString(), im.toString());\r\n\r\n                return _.add(_.parse(Math2.erf(re.toString())), _.multiply(k, _.add(a, b)));\r\n            },\r\n            removeDen: function (symbol) {\r\n                var den, r, i, re, im;\r\n                if(isArray(symbol)) {\r\n                    r = symbol[0];\r\n                    i = symbol[1];\r\n                }\r\n                else {\r\n                    r = symbol.realpart();\r\n                    i = symbol.imagpart();\r\n                }\r\n\r\n                den = Math.pow(r, 2) + Math.pow(i, 2);\r\n                re = _.parse(r / den);\r\n                im = _.parse(i / den);\r\n                return [re, im];\r\n            },\r\n            fromArray: function (arr) {\r\n                return _.add(arr[0], _.multiply(Symbol.imaginary(), arr[1]));\r\n            },\r\n            evaluate: function (symbol, f) {\r\n                var re, im, sign;\r\n\r\n                sign = symbol.power.sign();\r\n                //remove it from under the denominator\r\n                symbol.power = symbol.power.abs();\r\n                //expand\r\n                if(symbol.power.greaterThan(1))\r\n                    symbol = _.expand(symbol);\r\n                //remove the denominator\r\n                if(sign < 0) {\r\n                    var d = this.removeDen(symbol);\r\n                    re = d[0];\r\n                    im = d[1];\r\n                }\r\n                else {\r\n                    re = symbol.realpart();\r\n                    im = symbol.imagpart();\r\n                }\r\n\r\n                if(re.isConstant('all') && im.isConstant('all'))\r\n                    return this[f].call(this, re, im);\r\n\r\n                return _.symfunction(f, [symbol]);\r\n            }\r\n        };\r\n        //object for functions which handle trig\r\n        var trig = this.trig = {\r\n            //container for trigonometric function\r\n            cos: function (symbol) {\r\n                if(symbol.equals('pi') && symbol.multiplier.den.equals(2))\r\n                    return new Symbol(0);\r\n\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.equals(new Symbol(Settings.PI / 2)))\r\n                        return new Symbol(0);\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.cos(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.cos(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'cos');\r\n                    }\r\n                }\r\n                if(symbol.equals(0))\r\n                    return new Symbol(1);\r\n\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        m = symbol.multiplier.abs();\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return for 1 or -1 for multiples of pi\r\n                    if(isInt(m)) {\r\n                        retval = new Symbol(even(m) ? 1 : -1);\r\n                    }\r\n                    else {\r\n                        var n = Number(m.num), d = Number(m.den);\r\n                        if(d === 2)\r\n                            retval = new Symbol(0);\r\n                        else if(d === 3) {\r\n                            retval = _.parse('1/2');\r\n                            c = true;\r\n                        }\r\n                        else if(d === 4) {\r\n                            retval = _.parse('1/sqrt(2)');\r\n                            c = true;\r\n                        }\r\n                        else if(d === 6) {\r\n                            retval = _.parse('sqrt(3)/2');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.symfunction('cos', [symbol]);\r\n                    }\r\n                }\r\n\r\n                if(c && (q === 2 || q === 3))\r\n                    retval.negate();\r\n\r\n                if(!retval)\r\n                    retval = _.symfunction('cos', [symbol]);\r\n\r\n                return retval;\r\n            },\r\n            sin: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol % Math.PI === 0) {\r\n                            return new Symbol(0);\r\n                        }\r\n\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.sin(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.sin(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'sin');\r\n                }\r\n\r\n                if(symbol.equals(0))\r\n                    return new Symbol(0);\r\n\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        sign = symbol.multiplier.sign(),\r\n                        m = symbol.multiplier.abs();\r\n                symbol.multiplier = m;\r\n                if(symbol.equals('pi'))\r\n                    retval = new Symbol(0);\r\n                else if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return for 0 for multiples of pi\r\n                    if(isInt(m)) {\r\n                        retval = new Symbol(0);\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2) {\r\n                            retval = new Symbol(1);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 3) {\r\n                            retval = _.parse('sqrt(3)/2');\r\n                            c = true\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = _.parse('1/sqrt(2)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = _.parse('1/2');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.multiply(new Symbol(sign), _.symfunction('sin', [symbol]));\r\n                    }\r\n                }\r\n\r\n                if(!retval)\r\n                    retval = _.multiply(new Symbol(sign), _.symfunction('sin', [symbol]));\r\n\r\n                if(c && (q === 3 || q === 4))\r\n                    retval.negate();\r\n\r\n                return retval;\r\n            },\r\n            tan: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol % Math.PI === 0 && symbol.isLinear()) {\r\n                        return new Symbol(0);\r\n                    }\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.tan(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.tan(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'tan');\r\n                }\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        m = symbol.multiplier;\r\n\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return 0 for all multiples of pi\r\n                    if(isInt(m)) {\r\n                        retval = new Symbol(0);\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2)\r\n                            throw new UndefinedError('tan is undefined for ' + symbol.toString());\r\n                        else if(d == 3) {\r\n                            retval = _.parse('sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = new Symbol(1);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = _.parse('1/sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.symfunction('tan', [symbol]);\r\n                    }\r\n                }\r\n\r\n                if(!retval)\r\n                    retval = _.symfunction('tan', [symbol]);\r\n\r\n                if(c && (q === 2 || q === 4))\r\n                    retval.negate();\r\n\r\n                return retval;\r\n            },\r\n            sec: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(new bigDec(1).dividedBy(bigDec.cos(symbol.multiplier.toDecimal())));\r\n                        }\r\n\r\n                        return new Symbol(Math2.sec(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'sec');\r\n                    return _.parse(format('1/cos({0})', symbol));\r\n                }\r\n\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        m = symbol.multiplier.abs();\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return for 1 or -1 for multiples of pi\r\n                    if(isInt(m)) {\r\n                        retval = new Symbol(even(m) ? 1 : -1);\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2)\r\n                            throw new UndefinedError('sec is undefined for ' + symbol.toString());\r\n                        else if(d == 3) {\r\n                            retval = new Symbol(2);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = _.parse('sqrt(2)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = _.parse('2/sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.symfunction('sec', [symbol]);\r\n                    }\r\n                }\r\n\r\n                if(c && (q === 2 || q === 3))\r\n                    retval.negate();\r\n\r\n                if(!retval)\r\n                    retval = _.symfunction('sec', [symbol]);\r\n\r\n                return retval;\r\n            },\r\n            csc: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(new bigDec(1).dividedBy(bigDec.sin(symbol.multiplier.toDecimal())));\r\n                        }\r\n\r\n                        return new Symbol(Math2.csc(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'csc');\r\n                    return _.parse(format('1/sin({0})', symbol));\r\n                }\r\n\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        sign = symbol.multiplier.sign(),\r\n                        m = symbol.multiplier.abs();\r\n\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return for 0 for multiples of pi\r\n                    if(isInt(m)) {\r\n                        throw new UndefinedError('csc is undefined for ' + symbol.toString());\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2) {\r\n                            retval = new Symbol(1);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 3) {\r\n                            retval = _.parse('2/sqrt(3)');\r\n                            c = true\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = _.parse('sqrt(2)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = new Symbol(2);\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.multiply(new Symbol(sign), _.symfunction('csc', [symbol]));\r\n                    }\r\n                }\r\n\r\n                if(!retval)\r\n                    retval = _.multiply(new Symbol(sign), _.symfunction('csc', [symbol]));\r\n\r\n                if(c && (q === 3 || q === 4))\r\n                    retval.negate();\r\n\r\n                return retval;\r\n            },\r\n            cot: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol % (Math.PI/2) === 0) {\r\n                        return new Symbol(0);\r\n                    }\r\n                    if(symbol.isConstant()) {\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(new bigDec(1).dividedBy(bigDec.tan(symbol.multiplier.toDecimal())));\r\n                        }\r\n\r\n                        return new Symbol(Math2.cot(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'cot');\r\n                    return _.parse(format('1/tan({0})', symbol));\r\n                }\r\n                var retval,\r\n                        c = false,\r\n                        q = getQuadrant(symbol.multiplier.toDecimal()),\r\n                        m = symbol.multiplier;\r\n\r\n                symbol.multiplier = m;\r\n\r\n                if(symbol.isPi() && symbol.isLinear()) {\r\n                    //return 0 for all multiples of pi\r\n                    if(isInt(m)) {\r\n                        throw new UndefinedError('cot is undefined for ' + symbol.toString());\r\n                    }\r\n                    else {\r\n                        var n = m.num, d = m.den;\r\n                        if(d == 2)\r\n                            retval = new Symbol(0);\r\n                        else if(d == 3) {\r\n                            retval = _.parse('1/sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else if(d == 4) {\r\n                            retval = new Symbol(1);\r\n                            c = true;\r\n                        }\r\n                        else if(d == 6) {\r\n                            retval = _.parse('sqrt(3)');\r\n                            c = true;\r\n                        }\r\n                        else\r\n                            retval = _.symfunction('cot', [symbol]);\r\n                    }\r\n                }\r\n\r\n                if(!retval)\r\n                    retval = _.symfunction('cot', [symbol]);\r\n\r\n                if(c && (q === 2 || q === 4))\r\n                    retval.negate();\r\n\r\n                return retval;\r\n            },\r\n            acos: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        // Handle values in the complex domain\r\n                        if(symbol.gt(1) || symbol.lt(-1)) {\r\n                            var x = symbol.toString();\r\n                            return expand(evaluate(`pi/2-asin(${x})`));\r\n                        }\r\n                        // Handle big numbers\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.acos(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.acos(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'acos');\r\n                }\r\n                return _.symfunction('acos', arguments);\r\n            },\r\n            asin: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        // Handle values in the complex domain\r\n                        if(symbol.gt(1) || symbol.lt(-1)) {\r\n                            var i = Settings.IMAGINARY;\r\n                            var x = symbol.multiplier.toDecimal();\r\n                            return expand(evaluate(`${i}*log(sqrt(1-${x}^2)-${i}*${x})`));\r\n                        }\r\n                        // Handle big numbers\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.asin(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.asin(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'asin');\r\n                }\r\n                return _.symfunction('asin', arguments);\r\n            },\r\n            atan: function (symbol) {\r\n                var retval;\r\n                if(symbol.equals(0))\r\n                    retval = new Symbol(0);\r\n                else if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        // Handle big numbers\r\n                        if(Settings.USE_BIG) {\r\n                            return new Symbol(bigDec.atan(symbol.multiplier.toDecimal()));\r\n                        }\r\n\r\n                        return new Symbol(Math.atan(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'atan');\r\n                    return _.symfunction('atan', arguments);\r\n                }\r\n                else if(symbol.equals(-1))\r\n                    retval = _.parse('-pi/4');\r\n                else\r\n                    retval = _.symfunction('atan', arguments);\r\n                return retval;\r\n            },\r\n            asec: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.equals(0)) {\r\n                        throw new OutOfFunctionDomainError('Input is out of the domain of sec!');\r\n                    }\r\n                    if(symbol.isConstant()) {\r\n                        return trig.acos(symbol.invert());\r\n                    }\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'asec');\r\n                    }\r\n                }\r\n                return _.symfunction('asec', arguments);\r\n            },\r\n            acsc: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        return trig.asin(symbol.invert());\r\n                    }\r\n\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'acsc');\r\n                }\r\n                return _.symfunction('acsc', arguments);\r\n            },\r\n            acot: function (symbol) {\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        return new _.add(_.parse('pi/2'), trig.atan(symbol).negate());\r\n                    }\r\n\r\n                    if(symbol.isImaginary())\r\n                        return complex.evaluate(symbol, 'acot');\r\n                }\r\n                return _.symfunction('acot', arguments);\r\n            },\r\n            atan2: function (a, b) {\r\n                if(a.equals(0) && b.equals(0))\r\n                    throw new UndefinedError('atan2 is undefined for 0, 0');\r\n\r\n                if(Settings.PARSE2NUMBER && a.isConstant() && b.isConstant()) {\r\n                    return new Symbol(Math.atan2(a, b));\r\n                }\r\n                return _.symfunction('atan2', arguments);\r\n            }\r\n        };\r\n        //object for functions which handle hyperbolic trig\r\n        var trigh = this.trigh = {\r\n            //container for hyperbolic trig function\r\n            cosh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.cosh(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'cosh');\r\n                    }\r\n                }\r\n\r\n                return retval = _.symfunction('cosh', arguments);\r\n            },\r\n            sinh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.sinh(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'sinh');\r\n                    }\r\n                }\r\n\r\n                return retval = _.symfunction('sinh', arguments);\r\n            },\r\n            tanh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.tanh(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'tanh');\r\n                    }\r\n                }\r\n\r\n                return retval = _.symfunction('tanh', arguments);\r\n            },\r\n            sech: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant()) {\r\n                        return new Symbol(Math.sech(symbol.valueOf()));\r\n                    }\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'sech');\r\n                    }\r\n                    return _.parse(format('1/cosh({0})', symbol));\r\n                }\r\n\r\n                return retval = _.symfunction('sech', arguments);\r\n            },\r\n            csch: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.csch(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'csch');\r\n                    }\r\n                    return _.parse(format('1/sinh({0})', symbol));\r\n                }\r\n\r\n                return retval = _.symfunction('csch', arguments);\r\n            },\r\n            coth: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.isConstant())\r\n                        return new Symbol(Math.coth(symbol.valueOf()));\r\n                    if(symbol.isImaginary()) {\r\n                        return complex.evaluate(symbol, 'coth');\r\n                    }\r\n                    return _.parse(format('1/tanh({0})', symbol));\r\n                }\r\n\r\n                return retval = _.symfunction('coth', arguments);\r\n            },\r\n            acosh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'acosh');\r\n                else if(Settings.PARSE2NUMBER)\r\n                    retval = evaluate(_.parse(format(Settings.LOG + '(({0})+sqrt(({0})^2-1))', symbol.toString())));\r\n                else\r\n                    retval = _.symfunction('acosh', arguments);\r\n                return retval;\r\n            },\r\n            asinh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'asinh');\r\n                else if(Settings.PARSE2NUMBER)\r\n                    retval = evaluate(_.parse(format(Settings.LOG + '(({0})+sqrt(({0})^2+1))', symbol.toString())));\r\n                else\r\n                    retval = _.symfunction('asinh', arguments);\r\n                return retval;\r\n            },\r\n            atanh: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'atanh');\r\n                else if(Settings.PARSE2NUMBER) {\r\n                    retval = evaluate(_.parse(format('(1/2)*' + Settings.LOG + '((1+({0}))/(1-({0})))', symbol.toString())));\r\n                }\r\n                else\r\n                    retval = _.symfunction('atanh', arguments);\r\n                return retval;\r\n            },\r\n            asech: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'asech');\r\n                else if(Settings.PARSE2NUMBER)\r\n                    retval = evaluate(log(_.add(symbol.clone().invert(), sqrt(_.subtract(_.pow(symbol, new Symbol(-2)), new Symbol(1))))));\r\n                else\r\n                    retval = _.symfunction('asech', arguments);\r\n                return retval;\r\n            },\r\n            acsch: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'acsch');\r\n                else if(Settings.PARSE2NUMBER)\r\n                    retval = evaluate(_.parse(format(Settings.LOG + '((1+sqrt(1+({0})^2))/({0}))', symbol.toString())));\r\n                else\r\n                    retval = _.symfunction('acsch', arguments);\r\n                return retval;\r\n            },\r\n            acoth: function (symbol) {\r\n                var retval;\r\n                if(Settings.PARSE2NUMBER && symbol.isImaginary())\r\n                    retval = complex.evaluate(symbol, 'acoth');\r\n                else if(Settings.PARSE2NUMBER) {\r\n                    if(symbol.equals(1))\r\n                        retval = Symbol.infinity();\r\n                    else\r\n                        retval = evaluate(\r\n                                _.divide(\r\n                                        log(_.divide(_.add(symbol.clone(), new Symbol(1)), _.subtract(symbol.clone(), new Symbol(1)))),\r\n                                        new Symbol(2)));\r\n                }\r\n                else\r\n                    retval = _.symfunction('acoth', arguments);\r\n                return retval;\r\n            }\r\n        };\r\n        //list of supported units\r\n        this.units = {};\r\n        //list all the supported operators\r\n        var operators = {\r\n            '\\\\': {\r\n                precedence: 8,\r\n                operator: '\\\\',\r\n                action: 'slash',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return e; //bypass the slash\r\n                }\r\n            },\r\n            '!!': {\r\n                precedence: 7,\r\n                operator: '!!',\r\n                action: 'dfactorial',\r\n                prefix: false,\r\n                postfix: true,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return _.symfunction(Settings.DOUBLEFACTORIAL, [e]); //wrap it in a factorial function\r\n                }\r\n            },\r\n            '!': {\r\n                precedence: 7,\r\n                operator: '!',\r\n                action: 'factorial',\r\n                prefix: false,\r\n                postfix: true,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return factorial(e); //wrap it in a factorial function\r\n                }\r\n            },\r\n            '^': {\r\n                precedence: 6,\r\n                operator: '^',\r\n                action: 'pow',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: true\r\n            },\r\n            '**': {\r\n                precedence: 6,\r\n                operator: '**',\r\n                action: 'pow',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: true\r\n            },\r\n            '%': {\r\n                precedence: 4,\r\n                operator: '%',\r\n                action: 'percent',\r\n                prefix: false,\r\n                postfix: true,\r\n                leftAssoc: true,\r\n                overloaded: true,\r\n                overloadAction: 'mod',\r\n                overloadLeftAssoc: false,\r\n                operation: function (x) {\r\n                    return _.divide(x, new Symbol(100));\r\n                }\r\n            },\r\n            '*': {\r\n                precedence: 4,\r\n                operator: '*',\r\n                action: 'multiply',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '/': {\r\n                precedence: 4,\r\n                operator: '/',\r\n                action: 'divide',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '+': {\r\n                precedence: 3,\r\n                operator: '+',\r\n                action: 'add',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: false,\r\n                operation: function (x) {\r\n                    return x;\r\n                }\r\n            },\r\n            'plus': {\r\n                precedence: 3,\r\n                operator: 'plus',\r\n                action: 'add',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: false,\r\n                operation: function (x) {\r\n                    return x;\r\n                }\r\n            },\r\n            '-': {\r\n                precedence: 3,\r\n                operator: '-',\r\n                action: 'subtract',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: false,\r\n                operation: function (x) {\r\n                    return x.negate();\r\n                }\r\n            },\r\n            '=': {\r\n                precedence: 2,\r\n                operator: '=',\r\n                action: 'equals',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '==': {\r\n                precedence: 1,\r\n                operator: '==',\r\n                action: 'eq',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '<': {\r\n                precedence: 1,\r\n                operator: '<',\r\n                action: 'lt',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '<=': {\r\n                precedence: 1,\r\n                operator: '<=',\r\n                action: 'lte',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '>': {\r\n                precedence: 1,\r\n                operator: '>',\r\n                action: 'gt',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            '=>': {\r\n                precedence: 1,\r\n                operator: '=>',\r\n                action: 'gte',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            ',': {\r\n                precedence: 0,\r\n                operator: ',',\r\n                action: 'comma',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false\r\n            },\r\n            ':': {\r\n                precedence: 0,\r\n                operator: ',',\r\n                action: 'assign',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: false,\r\n                vectorFn: 'slice'\r\n            },\r\n            ':=': {\r\n                precedence: 0,\r\n                operator: ',',\r\n                action: 'function_assign',\r\n                prefix: false,\r\n                postfix: false,\r\n                leftAssoc: true\r\n            }\r\n        };\r\n        //brackets\r\n        var brackets = {\r\n            '(': {\r\n                type: 'round',\r\n                id: 1,\r\n                is_open: true,\r\n                is_close: false\r\n            },\r\n            ')': {\r\n                type: 'round',\r\n                id: 2,\r\n                is_open: false,\r\n                is_close: true\r\n            },\r\n            '[': {\r\n                type: 'square',\r\n                id: 3,\r\n                is_open: true,\r\n                is_close: false,\r\n                maps_to: 'vector'\r\n            },\r\n            ']': {\r\n                type: 'square',\r\n                id: 4,\r\n                is_open: false,\r\n                is_close: true\r\n            },\r\n            '{': {\r\n                type: 'curly',\r\n                id: 5,\r\n                is_open: true,\r\n                is_close: false,\r\n                maps_to: 'Set'\r\n            },\r\n            '}': {\r\n                type: 'curly',\r\n                id: 6,\r\n                is_open: false,\r\n                is_close: true\r\n            }\r\n        };\r\n        // Supported functions.\r\n        // Format: function_name: [mapped_function, number_of_parameters]\r\n        var functions = this.functions = {\r\n            'cos': [trig.cos, 1],\r\n            'sin': [trig.sin, 1],\r\n            'tan': [trig.tan, 1],\r\n            'sec': [trig.sec, 1],\r\n            'csc': [trig.csc, 1],\r\n            'cot': [trig.cot, 1],\r\n            'acos': [trig.acos, 1],\r\n            'asin': [trig.asin, 1],\r\n            'atan': [trig.atan, 1],\r\n            'arccos': [trig.acos, 1],\r\n            'arcsin': [trig.asin, 1],\r\n            'arctan': [trig.atan, 1],\r\n            'asec': [trig.asec, 1],\r\n            'acsc': [trig.acsc, 1],\r\n            'acot': [trig.acot, 1],\r\n            'atan2': [trig.atan2, 2],\r\n            'acoth': [trigh.acoth, 1],\r\n            'asech': [trigh.asech, 1],\r\n            'acsch': [trigh.acsch, 1],\r\n            'sinh': [trigh.sinh, 1],\r\n            'cosh': [trigh.cosh, 1],\r\n            'tanh': [trigh.tanh, 1],\r\n            'asinh': [trigh.asinh, 1],\r\n            'sech': [trigh.sech, 1],\r\n            'csch': [trigh.csch, 1],\r\n            'coth': [trigh.coth, 1],\r\n            'acosh': [trigh.acosh, 1],\r\n            'atanh': [trigh.atanh, 1],\r\n            'log10': [, 1],\r\n            'exp': [exp, 1],\r\n            'radians': [radians, 1],\r\n            'degrees': [degrees, 1],\r\n            'min': [min, -1],\r\n            'max': [max, -1],\r\n            'erf': [, 1],\r\n            'floor': [, 1],\r\n            'ceil': [, 1],\r\n            'trunc': [, 1],\r\n            'Si': [, 1],\r\n            'step': [, 1],\r\n            'rect': [, 1],\r\n            'sinc': [sinc, 1],\r\n            'tri': [, 1],\r\n            'sign': [sign, 1],\r\n            'Ci': [, 1],\r\n            'Ei': [, 1],\r\n            'Shi': [, 1],\r\n            'Chi': [, 1],\r\n            'Li': [, 1],\r\n            'fib': [, 1],\r\n            'fact': [factorial, 1],\r\n            'factorial': [factorial, 1],\r\n            'continued_fraction': [continued_fraction, [1, 2]],\r\n            'dfactorial': [, 1],\r\n            'gamma_incomplete': [, [1, 2]],\r\n            'round': [round, [1, 2]],\r\n            'scientific': [scientific, [1, 2]],\r\n            'mod': [mod, 2],\r\n            'pfactor': [pfactor, 1],\r\n            'vector': [vector, -1],\r\n            'matrix': [matrix, -1],\r\n            'Set': [set, -1],\r\n            'imatrix': [imatrix, -1],\r\n            'parens': [parens, -1],\r\n            'sqrt': [sqrt, 1],\r\n            'cbrt': [cbrt, 1],\r\n            'nthroot': [nthroot, 2],\r\n            'log': [log, [1, 2]],\r\n            'expand': [expandall, 1],\r\n            'abs': [abs, 1],\r\n            'invert': [invert, 1],\r\n            'determinant': [determinant, 1],\r\n            'size': [size, 1],\r\n            'transpose': [transpose, 1],\r\n            'dot': [dot, 2],\r\n            'cross': [cross, 2],\r\n            'vecget': [vecget, 2],\r\n            'vecset': [vecset, 3],\r\n            'vectrim': [vectrim, [1, 2]],\r\n            'matget': [matget, 3],\r\n            'matset': [matset, 4],\r\n            'matgetrow': [matgetrow, 2],\r\n            'matsetrow': [matsetrow, 3],\r\n            'matgetcol': [matgetcol, 2],\r\n            'matsetcol': [matsetcol, 3],\r\n            'rationalize': [rationalize, 1],\r\n            'IF': [IF, 3],\r\n            'is_in': [is_in, 2],\r\n            //imaginary support\r\n            'realpart': [realpart, 1],\r\n            'imagpart': [imagpart, 1],\r\n            'conjugate': [conjugate, 1],\r\n            'arg': [arg, 1],\r\n            'polarform': [polarform, 1],\r\n            'rectform': [rectform, 1],\r\n            'sort': [sort, [1, 2]],\r\n            'integer_part': [, 1],\r\n            'union': [union, 2],\r\n            'contains': [contains, 2],\r\n            'intersection': [intersection, 2],\r\n            'difference': [difference, 2],\r\n            'intersects': [intersects, 2],\r\n            'is_subset': [is_subset, 2],\r\n            //system support\r\n            'print': [print, -1]\r\n        };\r\n\r\n        //error handler\r\n        this.error = err;\r\n        //this function is used to comb through the function modules and find a function given its name\r\n        var findFunction = function (fname) {\r\n            var fmodules = Settings.FUNCTION_MODULES,\r\n                    l = fmodules.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var fmodule = fmodules[i];\r\n                if(fname in fmodule)\r\n                    return fmodule[fname];\r\n            }\r\n            err('The function ' + fname + ' is undefined!');\r\n        };\r\n\r\n        /**\r\n         * This method gives the ability to override operators with new methods.\r\n         * @param {String} which\r\n         * @param {Function} with_what\r\n         */\r\n        this.override = function (which, with_what) {\r\n            if(!bin[which])\r\n                bin[which] = [];\r\n            bin[which].push(this[which]);\r\n            this[which] = with_what;\r\n        };\r\n\r\n        /**\r\n         * Restores a previously overridden operator\r\n         * @param {String} what\r\n         */\r\n        this.restore = function (what) {\r\n            if(this[what])\r\n                this[what] = bin[what].pop();\r\n        };\r\n\r\n        /**\r\n         * This method is supposed to behave similarly to the override method but it does not override\r\n         * the existing function rather it only extends it\r\n         * @param {String} what\r\n         * @param {Function} with_what\r\n         * @param {boolean} force_call\r\n         */\r\n        this.extend = function (what, with_what, force_call) {\r\n            var _ = this,\r\n                    extended = this[what];\r\n            if(typeof extended === 'function' && typeof with_what === 'function') {\r\n                var f = this[what];\r\n                this[what] = function (a, b) {\r\n                    if(isSymbol(a) && isSymbol(b) && !force_call)\r\n                        return f.call(_, a, b);\r\n                    else\r\n                        return with_what.call(_, a, b, f);\r\n                };\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Generates library's representation of a function. It's a fancy way of saying a symbol with\r\n         * a few extras. The most important thing is that that it gives a fname and\r\n         * an args property to the symbols in addition to changing its group to FN\r\n         * @param {String} fn_name\r\n         * @param {Array} params\r\n         * @returns {Symbol}\r\n         */\r\n        this.symfunction = function (fn_name, params) {\r\n            //call the proper function and return the result;\r\n            var f = new Symbol(fn_name);\r\n            f.group = FN;\r\n            if(typeof params === 'object')\r\n                params = [].slice.call(params);//ensure an array\r\n            f.args = params;\r\n            f.fname = fn_name === PARENTHESIS ? '' : fn_name;\r\n            f.updateHash();\r\n            return f;\r\n        };\r\n\r\n        /**\r\n         * An internal function call for the Parser. This will either trigger a real\r\n         * function call if it can do so or just return a symbolic representation of the\r\n         * function using symfunction.\r\n         * @param {String} fn_name\r\n         * @param {Array} args\r\n         * @param {int} allowed_args\r\n         * @returns {Symbol}\r\n         */\r\n        this.callfunction = function (fn_name, args, allowed_args) {\r\n            var fn_settings = functions[fn_name];\r\n\r\n            if(!fn_settings)\r\n                err('Nerdamer currently does not support the function ' + fn_name);\r\n\r\n            var num_allowed_args = fn_settings[1] || allowed_args, //get the number of allowed arguments\r\n                    fn = fn_settings[0], //get the mapped function\r\n                    retval;\r\n            //We want to be able to call apply on the arguments or create a symfunction. Both require\r\n            //an array so make sure to wrap the argument in an array.\r\n            if(!(args instanceof Array))\r\n                args = args !== undefined ? [args] : [];\r\n\r\n            if(num_allowed_args !== -1) {\r\n                var is_array = isArray(num_allowed_args),\r\n                        min_args = is_array ? num_allowed_args[0] : num_allowed_args,\r\n                        max_args = is_array ? num_allowed_args[1] : num_allowed_args,\r\n                        num_args = args.length;\r\n\r\n                var error_msg = fn_name + ' requires a {0} of {1} arguments. {2} provided!';\r\n\r\n                if(num_args < min_args)\r\n                    err(format(error_msg, 'minimum', min_args, num_args));\r\n                if(num_args > max_args)\r\n                    err(format(error_msg, 'maximum', max_args, num_args));\r\n            }\r\n\r\n            /*\r\n             * The following are very important to the how nerdamer constructs functions!\r\n             * Assumption 1 - if fn is undefined then handling of the function is purely numeric. This\r\n             *     enables us to reuse Math, Math2, ..., any function from Settings.FUNCTIONS_MODULES entry\r\n             * Assumption 2 - if fn is defined then that function takes care of EVERYTHING including symbolics\r\n             * Assumption 3 - if the user calls symbolics on a function that returns a numeric value then\r\n             *     they are expecting a symbolic output.\r\n             */\r\n            //check if arguments are all numers\r\n            var numericArgs = allNumbers(args);\r\n            //Big number support. Check if Big number is requested and the arguments are all numeric and, not imaginary\r\n//            if (Settings.USE_BIG && numericArgs) {\r\n//                retval = Big[fn_name].apply(undefined, args);\r\n//            }\r\n//            else {\r\n            if(!fn) {\r\n                //Remember assumption 1. No function defined so it MUST be numeric in nature\r\n                fn = findFunction(fn_name);\r\n                if(Settings.PARSE2NUMBER && numericArgs)\r\n                    retval = bigConvert(fn.apply(fn, args));\r\n                else\r\n                    retval = _.symfunction(fn_name, args);\r\n            }\r\n            else {\r\n                //Remember assumption 2. The function is defined so it MUST handle all aspects including numeric values\r\n                retval = fn.apply(fn_settings[2], args);\r\n            }\r\n//            }\r\n\r\n            return retval;\r\n        };\r\n        /**\r\n         * Build a regex based on the operators currently loaded. These operators are to be ignored when\r\n         * substituting spaces for multiplication\r\n         */\r\n        this.operator_filter_regex = (function () {\r\n            //we only want the operators which are singular since those are the ones\r\n            //that nerdamer uses anyway\r\n            var ostr = '^\\\\' + Object.keys(operators).filter(function (x) {\r\n                if(x.length === 1)\r\n                    return x;\r\n            }).join('\\\\');\r\n            //create a regex which captures all spaces between characters except those\r\n            //have an operator on one end\r\n            return new RegExp('([' + ostr + '])\\\\s+([' + ostr + '])');\r\n        })();\r\n\r\n        /**\r\n         * Replaces nerdamer.setOperator\r\n         * @param {object} operator\r\n         * @param {boolean} shift\r\n         */\r\n        this.setOperator = function (operator, action, shift) {\r\n            var name = operator.operator; //take the name to be the symbol\r\n            operators[name] = operator;\r\n            if(action)\r\n                this[operator.action] = action;\r\n            //make the parser aware of the operator\r\n            _[name] = operator.operation;\r\n            //make the action available to the parser if infix\r\n            if(!operator.action && !(operator.prefix || operator.postif)) {\r\n                operator.action = name;\r\n            }\r\n            //if this operator is exclusive then all successive operators should be shifted\r\n            if(shift === 'over' || shift === 'under') {\r\n                var precedence = operator.precedence;\r\n\r\n                for(var x in operators) {\r\n                    var o = operators[x];\r\n                    var condition = shift === 'over' ? o.precedence >= precedence : o.precedence > precedence;\r\n                    if(condition)\r\n                        o.precedence++;\r\n                }\r\n                ;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Gets an opererator by its symbol\r\n         * @param {String} operator\r\n         * @returns {Object}\r\n         */\r\n        this.getOperator = function (operator) {\r\n            return operators[operator];\r\n        };\r\n\r\n        this.aliasOperator = function (o, n) {\r\n            var t = {};\r\n            var operator = operators[o];\r\n            //copy everything over to the new operator\r\n            for(var x in operator) {\r\n                t[x] = operator[x];\r\n            }\r\n            //update the symbol\r\n            t.operator = n;\r\n\r\n            this.setOperator(t);\r\n        };\r\n\r\n        /**\r\n         * Returns the list of operators. Caution! Can break parser!\r\n         * @returns {object}\r\n         */\r\n        this.getOperators = function () {\r\n            //will replace this with some cloning action in the future\r\n            return operators;\r\n        };\r\n\r\n        this.getBrackets = function () {\r\n            return brackets;\r\n        };\r\n        /*\r\n         * Preforms preprocessing on the string. Useful for making early modification before\r\n         * sending to the parser\r\n         * @param {String} e\r\n         */\r\n        var prepare_expression = function (e) {\r\n            /*\r\n             * Since variables cannot start with a number, the assumption is made that when this occurs the\r\n             * user intents for this to be a coefficient. The multiplication symbol in then added. The same goes for\r\n             * a side-by-side close and open parenthesis\r\n             */\r\n            e = String(e);\r\n            //apply preprocessors\r\n            for(var i = 0; i < preprocessors.actions.length; i++)\r\n                e = preprocessors.actions[i].call(this, e);\r\n\r\n            //e = e.split(' ').join('');//strip empty spaces\r\n            //replace multiple spaces with one space\r\n            e = e.replace(/\\s+/g, ' ');\r\n\r\n            //only even bother to check if the string contains e. This regex is painfully slow and might need a better solution. e.g. hangs on (0.06/3650))^(365)\r\n            if(/e/gi.test(e)) {\r\n                e = e.replace(/\\-*\\d+\\.*\\d*e\\+?\\-?\\d+/gi, function (x) {\r\n                    return scientificToDecimal(x);\r\n                });\r\n            }\r\n            //replace scientific numbers\r\n\r\n            //allow omission of multiplication after coefficients\r\n            e = e.replace(Settings.IMPLIED_MULTIPLICATION_REGEX, function () {\r\n                var str = arguments[4],\r\n                        group1 = arguments[1],\r\n                        group2 = arguments[2],\r\n                        start = arguments[3],\r\n                        first = str.charAt(start),\r\n                        before = '',\r\n                        d = '*';\r\n                if(!first.match(/[\\+\\-\\/\\*]/))\r\n                    before = str.charAt(start - 1);\r\n                if(before.match(/[a-z]/i))\r\n                    d = '';\r\n                return group1 + d + group2;\r\n            })\r\n                    .replace(/([a-z0-9_]+)/gi, function (match, a) {\r\n                        if(Settings.USE_MULTICHARACTER_VARS === false && !(a in functions)) {\r\n                            if(!isNaN(a))\r\n                                return a;\r\n                            return a.split('').join('*');\r\n                        }\r\n                        return a;\r\n                    })\r\n                    //allow omission of multiplication sign between brackets\r\n                    .replace(/\\)\\(/g, ')*(') || '0';\r\n            //replace x(x+a) with x*(x+a)\r\n            while(true) {\r\n                var e_org = e; //store the original\r\n                e = e.replace(/([a-z0-9_]+)(\\()|(\\))([a-z0-9]+)/gi, function (match, a, b, c, d) {\r\n                    var g1 = a || c,\r\n                            g2 = b || d;\r\n                    if(g1 in functions) //create a passthrough for functions\r\n                        return g1 + g2;\r\n                    return g1 + '*' + g2;\r\n                });\r\n                //if the original equals the replace we're done\r\n                if(e_org === e)\r\n                    break;\r\n            }\r\n            return e;\r\n        };\r\n        //delay setting of constants until Settings is ready\r\n        this.initConstants = function () {\r\n            this.CONSTANTS = {\r\n                E: new Symbol(Settings.E),\r\n                PI: new Symbol(Settings.PI)\r\n            };\r\n        };\r\n        /*\r\n         * Debugging method used to better visualize vector and arrays\r\n         * @param {object} o\r\n         * @returns {String}\r\n         */\r\n        this.pretty_print = function (o) {\r\n            if(Array.isArray(o)) {\r\n                var s = o.map(x => _.pretty_print(x)).join(', ');\r\n                if(o.type === 'vector')\r\n                    return 'vector<' + s + '>';\r\n                return '(' + s + ')';\r\n            }\r\n            return o.toString();\r\n        };\r\n        this.peekers = {\r\n            pre_operator: [],\r\n            post_operator: [],\r\n            pre_function: [],\r\n            post_function: []\r\n        };\r\n\r\n        this.callPeekers = function (name) {\r\n            if(Settings.callPeekers) {\r\n                var peekers = this.peekers[name];\r\n                //remove the first items and stringify\r\n                var args = arguments2Array(arguments).slice(1).map(stringify);\r\n                //call each one of the peekers\r\n                for(var i = 0; i < peekers.length; i++) {\r\n                    peekers[i].apply(null, args);\r\n                }\r\n            }\r\n        };\r\n        /*\r\n         * Tokenizes the string\r\n         * @param {String} e\r\n         * @returns {Token[]}\r\n         */\r\n        this.tokenize = function (e) {\r\n            //cast to String\r\n            e = String(e);\r\n            //remove multiple white spaces and spaces at beginning and end of string\r\n            e = e.trim().replace(/\\s+/g, ' ');\r\n            //remove spaces before and after brackets\r\n            for(var x in brackets) {\r\n                var regex = new RegExp(brackets[x].is_close ? '\\\\s+\\\\' + x : '\\\\' + x + '\\\\s+', 'g');\r\n                e = e.replace(regex, x);\r\n            }\r\n\r\n            var col = 0; //the column position\r\n            var L = e.length; //expression length\r\n            var lpos = 0; //marks beginning of next token\r\n            var tokens = []; //the tokens container\r\n            var scopes = [tokens]; //initiate with the tokens as the highest scope\r\n            var target = scopes[0]; //the target to which the tokens are added. This can swing up or down\r\n            var depth = 0;\r\n            var open_brackets = [];\r\n            var has_space = false; //marks if an open space character was found\r\n            var SPACE = ' ';\r\n            var EMPTY_STRING = '';\r\n            var COMMA = ',';\r\n            var MINUS = '-';\r\n            var MULT = '*';\r\n            //Possible source of bug. Review\r\n            /*\r\n             //gets the next space\r\n             var next_space = function(from) {\r\n             for(var i=from; i<L; i++) {\r\n             if(e.charAt(i) === ' ')\r\n             return i;\r\n             }\r\n             \r\n             return L; //assume the end of the string instead\r\n             };\r\n             */\r\n            /**\r\n             * Adds a scope to tokens\r\n             * @param {String} scope_type\r\n             * @param {int} column\r\n             * @returns {undefined}\r\n             */\r\n            var addScope = function (scope_type, column) {\r\n                var new_scope = []; //create a new scope\r\n                if(scope_type !== undefined) {\r\n                    new_scope.type = scope_type;\r\n                }\r\n                new_scope.column = column; //mark the column of the scope\r\n                scopes.push(new_scope); //add it to the list of scopes\r\n                target.push(new_scope); //add it to the tokens list since now it's a scope\r\n                target = new_scope; //point to it\r\n                depth++; //go down one in scope\r\n            };\r\n            /**\r\n             * Goes up in scope by one\r\n             * @returns {undefined}\r\n             */\r\n            var goUp = function () {\r\n                scopes.pop(); //remove the scope from the scopes stack\r\n                target = scopes[--depth]; //point the above scope\r\n            };\r\n            /**\r\n             * Extracts all the operators from the expression string starting at postion start_at\r\n             * @param {int} start_at\r\n             * @returns {String}\r\n             */\r\n            var get_operator_str = function (start_at) {\r\n                start_at = start_at !== undefined ? start_at : col;\r\n                //mark the end of the operator as the start since we're just going\r\n                //to be walking along the string\r\n                var end = start_at + 1;\r\n                //just keep moving along\r\n                while(e.charAt(end++) in operators) {\r\n                }\r\n                //remember that we started at one position ahead. The beginning operator is what triggered\r\n                //this function to be called in the first place. String.CharAt is zero based so we now\r\n                //have to correct two places. The initial increment + the extra++ at the end of end during\r\n                //the last iteration.\r\n                return e.substring(start_at, end - 1);\r\n            };\r\n            /**\r\n             * Breaks operator up in to several different operators as defined in operators\r\n             * @param {String} operator_str\r\n             * @returns {String[]}\r\n             */\r\n            var chunkify = function (operator_str) {\r\n                var start = col - operator_str.length; //start of operator\r\n                var _operators = [];\r\n                var operator = operator_str.charAt(0);\r\n                //grab the largest possible chunks but start at 2 since we already know\r\n                //that the first character is an operator\r\n\r\n                for(var i = 1, L = operator_str.length; i < L; i++) {\r\n                    var ch = operator_str.charAt(i);\r\n                    var o = operator + ch;\r\n                    //since the operator now is undefined then the last operator\r\n                    //was the largest possible combination.\r\n                    if(!(o in operators)) {\r\n                        _operators.push(new Token(operator, Token.OPERATOR, start + i));\r\n                        operator = ch;\r\n                    }\r\n                    else\r\n                        operator = o;//now the operator is the larger chunk\r\n                }\r\n                //add the last operator\r\n                _operators.push(new Token(operator, Token.OPERATOR, start + i));\r\n                return _operators;\r\n            };\r\n\r\n            /**\r\n             * Is used to add a token to the tokens array. Makes sure that no empty token is added\r\n             * @param {int} at\r\n             * @param {String} token\r\n             * @returns {undefined}\r\n             */\r\n            var add_token = function (at, token) {\r\n                //grab the token if we're not supplied one\r\n                if(token === undefined)\r\n                    token = e.substring(lpos, at);\r\n                //only add it if it's not an empty string\r\n                if(token in _.units)\r\n                    target.push(new Token(token, Token.UNIT, lpos));\r\n                else if(token !== '')\r\n                    target.push(new Token(token, Token.VARIABLE_OR_LITERAL, lpos));\r\n            };\r\n            /**\r\n             * Adds a function to the output\r\n             * @param {String} f\r\n             * @returns {undefined}\r\n             */\r\n            var add_function = function (f) {\r\n                target.push(new Token(f, Token.FUNCTION, lpos));\r\n            };\r\n            /**\r\n             * Tokens are found between operators so this marks the location of where the last token was found\r\n             * @param {int} position\r\n             * @returns {undefined}\r\n             */\r\n            var set_last_position = function (position) {\r\n                lpos = position + 1;\r\n            };\r\n            /**\r\n             * When a operator is found and added, especially a combo operator, then the column location\r\n             * has to be adjusted to the end of the operator\r\n             * @returns {undefined}\r\n             */\r\n            var adjust_column_position = function () {\r\n                lpos = lpos + operator_str.length - 2;\r\n                col = lpos - 1;\r\n            };\r\n            for(; col < L; col++) {\r\n                var ch = e.charAt(col);\r\n                if(ch in operators) {\r\n                    add_token(col);\r\n                    //is the last token numeric?\r\n                    var last_token_is_numeric = target[0] && isNumber(target[0]);\r\n                    //is this character multiplication?\r\n                    var is_multiplication = last_token_is_numeric && ch === MULT;\r\n                    //if we're in a new scope then go up by one but if the space\r\n                    //is right befor an operator then it makes no sense to go up in scope\r\n                    //consider sin -x. The last position = current position at the minus sign\r\n                    //this means that we're going for sin(x) -x which is wrong\r\n                    //Ignore comma since comma is still part of the existing scope.\r\n                    if(has_space && lpos < col && !(ch === COMMA || is_multiplication)) {\r\n                        has_space = false;\r\n                        goUp();\r\n                    }\r\n                    //mark the last position that a\r\n                    set_last_position(col + 1);\r\n                    var operator_str = get_operator_str(col);\r\n\r\n                    adjust_column_position();\r\n                    target.push.apply(target, chunkify(operator_str));\r\n                }\r\n                else if(ch in brackets) {\r\n                    var bracket = brackets[ch];\r\n\r\n                    if(bracket.is_open) {\r\n                        //mark the bracket\r\n                        open_brackets.push([bracket, lpos]);\r\n                        var f = e.substring(lpos, col);\r\n                        if(f in functions) {\r\n                            add_function(f);\r\n                        }\r\n                        else if(f !== '') {\r\n                            //assume multiplication\r\n                            //TODO: Add the multiplication to stack\r\n                            target.push(new Token(f, Token.VARIABLE_OR_LITERAL, lpos));\r\n                        }\r\n                        //go down one in scope\r\n                        addScope(bracket.maps_to, col);\r\n                    }\r\n                    else if(bracket.is_close) {\r\n                        //get the matching bracket\r\n                        var pair = open_brackets.pop();\r\n                        //throw errors accordingly\r\n                        //missing open bracket\r\n                        if(!pair)\r\n                            throw new ParityError('Missing open bracket for bracket at: ' + (col + 1));\r\n                        //incorrect pair\r\n                        else if(pair[0].id !== bracket.id - 1)\r\n                            throw new ParityError('Parity error');\r\n\r\n                        add_token(col);\r\n                        goUp();\r\n                    }\r\n                    set_last_position(col);\r\n                }\r\n                else if(ch === SPACE) {\r\n                    var prev = e.substring(lpos, col); //look back\r\n                    var nxt = e.charAt(col + 1); //look forward\r\n                    if(has_space) {\r\n\r\n                        if(prev in operators) {\r\n                            target.push(new Token(prev, Token.OPERATOR, col));\r\n                        }\r\n                        else {\r\n                            add_token(undefined, prev);\r\n                            //we're at the closing space\r\n                            goUp(); //go up in scope if we're at a space\r\n\r\n                            //assume multiplication if it's not an operator except for minus\r\n                            var is_operator = nxt in operators;\r\n\r\n                            if((is_operator && operators[nxt].value === MINUS) || !is_operator) {\r\n                                target.push(new Token(MULT, Token.OPERATOR, col));\r\n                            }\r\n                        }\r\n                        has_space = false; //remove the space\r\n                    }\r\n                    else {\r\n                        //we're at the closing space\r\n                        //check if it's a function\r\n                        var f = e.substring(lpos, col);\r\n\r\n                        if(f in functions) {\r\n                            //there's no need to go up in scope if the next character is an operator\r\n                            has_space = true; //mark that a space was found\r\n                            add_function(f);\r\n                            addScope();\r\n                        }\r\n                        else if(f in operators) {\r\n                            target.push(new Token(f, Token.OPERATOR, col));\r\n                        }\r\n                        else {\r\n                            add_token(undefined, f);\r\n                            //peek ahead to the next character\r\n                            var nxt = e.charAt(col + 1);\r\n\r\n                            //If it's a number then add the multiplication operator to the stack but make sure that the next character\r\n                            //is not an operator\r\n\r\n                            if(prev !== EMPTY_STRING && nxt !== EMPTY_STRING && !(prev in operators) && !(nxt in operators))\r\n                                target.push(new Token(MULT, Token.OPERATOR, col));\r\n                        }\r\n                        //Possible source of bug. Review\r\n                        /*\r\n                         //space can mean multiplication so add the symbol if the is encountered\r\n                         if(/\\d+|\\d+\\.?\\d*e[\\+\\-]*\\d+/i.test(f)) {\r\n                         var next = e.charAt(col+1);\r\n                         var next_is_operator = next in operators;\r\n                         var ns = next_space(col+1);\r\n                         var next_word = e.substring(col+1, ns);\r\n                         //the next can either be a prefix operator or no operator\r\n                         if((next_is_operator && operators[next].prefix) || !(next_is_operator || next_word in operators))\r\n                         target.push(new Token('*', Token.OPERATOR, col));\r\n                         }\r\n                         */\r\n                    }\r\n                    set_last_position(col); //mark this location\r\n                }\r\n            }\r\n            //check that all brackets were closed\r\n            if(open_brackets.length) {\r\n                var b = open_brackets.pop();\r\n                throw new ParityError('Missing closed bracket for bracket at ' + (b[1] + 1));\r\n            }\r\n            //add the last token\r\n            add_token(col);\r\n\r\n            return tokens;\r\n        };\r\n        /*\r\n         * Puts token array in Reverse Polish Notation\r\n         * @param {Token[]} tokens\r\n         * @returns {Token[]}\r\n         */\r\n        this.toRPN = function (tokens) {\r\n            var fn = tokens.type;\r\n            var l = tokens.length, i;\r\n            var output = [];\r\n            var stack = [];\r\n            var prefixes = [];\r\n            var collapse = function (target, destination) {\r\n                while(target.length)\r\n                    destination.push(target.pop());\r\n            };\r\n            //mark all the prefixes and add them to the stack\r\n            for(i = 0; i < l; i++) {\r\n                var token = tokens[i];\r\n                if(token.type !== Token.OPERATOR)\r\n                    break;\r\n                if(!token.prefix)\r\n                    throw new OperatorError('Not a prefix operator');\r\n                token.is_prefix = true;\r\n                stack.push(token);\r\n            }\r\n            //begin with remaining tokens\r\n            for(; i < l; i++) {\r\n                var e = tokens[i];\r\n                if(e.type === Token.OPERATOR) {\r\n                    var operator = e;\r\n\r\n                    //create the option for the operator being overloaded\r\n                    if(operator.overloaded) {\r\n                        var next = tokens[i + 1];\r\n                        //if it's followed by a number or variable then we assume it's not a postfix operator\r\n                        if(next && next.type === Token.VARIABLE_OR_LITERAL) {\r\n                            operator.postfix = false;\r\n                            //override the original function with the overload function\r\n                            operator.action = operator.overloadAction;\r\n                            operator.leftAssoc = operator.overloadLeftAssoc;\r\n                        }\r\n                    }\r\n\r\n                    //if the stack is not empty\r\n                    while(stack.length) {\r\n                        var last = stack[stack.length - 1];\r\n                        //if (there is an operator at the top of the operator stack with greater precedence)\r\n                        //or (the operator at the top of the operator stack has equal precedence and is left associative)) ~ wikipedia\r\n                        //the !prefixes.length makes sure that the operator on stack isn't prematurely taken fromt he stack.\r\n                        if(!(last.precedence > operator.precedence || !operator.leftAssoc && last.precedence === operator.precedence))\r\n                            break;\r\n                        output.push(stack.pop());\r\n                    }\r\n\r\n                    //change the behavior of the operator if it's a vector and we've been asked to do so\r\n                    if((fn === 'vector' || fn === 'set') && 'vectorFn' in operator)\r\n                        operator.action = operator.vectorFn;\r\n\r\n\r\n                    //if the operator is a postfix operator then we're ready to go since it belongs\r\n                    //to the preceding token. However the output cannot be empty. It must have either\r\n                    //an operator or a variable/literal\r\n                    if(operator.postfix) {\r\n                        var previous = tokens[i - 1];\r\n                        if(!previous)\r\n                            throw new OperatorError(\"Unexpected prefix operator '\" + e.value + \"'! at \" + e.column);\r\n                        else if(previous.type === Token.OPERATOR) {\r\n                            //a postfix can only be followed by a postfix\r\n                            if(!previous.postfix)\r\n                                throw new OperatorError(\"Unexpected prefix operator '\" + previous.value + \"'! at \" + previous.column);\r\n                        }\r\n                    }\r\n                    else {\r\n                        //we must be at an infix so point the operator this\r\n                        do {\r\n                            //the first one is an infix operator all others have to be prefix operators so jump to the end\r\n                            var next = tokens[i + 1]; //take a look ahead\r\n                            var next_is_operator = next ? next.type === Token.OPERATOR : false; //check if it's an operator\r\n                            if(next_is_operator) {\r\n                                //if it's not a prefix operator then it not in the right place\r\n                                if(!next.prefix) {\r\n                                    throw new OperatorError('A prefix operator was expected at ' + next.column);\r\n                                }\r\n                                //mark it as a confirmed prefix\r\n                                next.is_prefix = true;\r\n                                //add it to the prefixes\r\n                                prefixes.push(next);\r\n                                i++;\r\n                            }\r\n                        }\r\n                        while(next_is_operator)\r\n                    }\r\n\r\n                    //if it's a prefix it should be on a special stack called prefixes\r\n                    //we do this to hold on to prefixes because of left associative operators.\r\n                    //they belong to the variable/literal but if placed on either the stack\r\n                    //or output there's no way of knowing this. I might be wrong so I welcome\r\n                    //any discussion about this.\r\n\r\n                    if(operator.is_prefix) //ADD ALL EXCEPTIONS FOR ADDING TO PREFIX STACK HERE. !!!\r\n                        prefixes.push(operator);\r\n                    else\r\n                        stack.push(operator);\r\n                    //move the prefixes to the stack\r\n                    while(prefixes.length) {\r\n                        if(operator.leftAssoc || !operator.leftAssoc && prefixes[prefixes.length - 1].precedence >= operator.precedence) //revisit for commas\r\n                            stack.push(prefixes.pop());\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                else if(e.type === Token.VARIABLE_OR_LITERAL) {\r\n                    //move prefixes to stack at beginning of scope\r\n                    if(output.length === 0)\r\n                        collapse(prefixes, stack);\r\n                    //done with token\r\n                    output.push(e);\r\n                    var last_on_stack = stack[stack.length - 1];\r\n                    //then move all the prefixes to the output\r\n                    if(!last_on_stack || !last_on_stack.leftAssoc)\r\n                        collapse(prefixes, output);\r\n                }\r\n                else if(e.type === Token.FUNCTION) {\r\n                    stack.push(e);\r\n                }\r\n                else if(e.type === Token.UNIT) {\r\n                    //if it's a unit it belongs on the stack since it's tied to the previous token\r\n                    output.push(e);\r\n                }\r\n                //if it's an additonal scope then put that into RPN form\r\n                if(Array.isArray(e)) {\r\n                    output.push(this.toRPN(e));\r\n                    if(e.type)\r\n                        output.push(new Token(e.type, Token.FUNCTION, e.column)); //since it's hidden it needs no column\r\n\r\n                }\r\n            }\r\n            //collapse the remainder of the stack and prefixes to output\r\n            collapse(stack, output);\r\n            collapse(prefixes, output);\r\n\r\n            return output;\r\n        };\r\n        /*\r\n         * Parses the tokens\r\n         * @param {Tokens[]} rpn\r\n         * @param {object} substitutions\r\n         * @returns {Symbol}\r\n         */\r\n        this.parseRPN = function (rpn, substitutions) {\r\n            try {\r\n                //default substitutions\r\n                substitutions = substitutions || {};\r\n                //prepare the substitutions.\r\n                //we first parse them out as-is\r\n                for(var x in substitutions)\r\n                    substitutions[x] = _.parse(substitutions[x], {});\r\n\r\n                //Although technically constants,\r\n                //pi and e are only available when evaluating the expression so add to the subs.\r\n                //Doing this avoids rounding errors\r\n                //link e and pi\r\n                if(Settings.PARSE2NUMBER) {\r\n                    //use the value provided if the individual for some strange reason prefers this.\r\n                    //one reason could be to sub e but not pi or vice versa\r\n                    if(!('e' in substitutions))\r\n                        substitutions.e = new Symbol(Settings.E);\r\n                    if((!('pi' in substitutions)))\r\n                        substitutions.pi = new Symbol(Settings.PI);\r\n                }\r\n\r\n                var Q = [];\r\n                for(var i = 0, l = rpn.length; i < l; i++) {\r\n                    var e = rpn[i];\r\n\r\n                    //Arrays indicate a new scope so parse that out\r\n                    if(Array.isArray(e)) {\r\n                        e = this.parseRPN(e, substitutions);\r\n                    }\r\n\r\n                    if(e) {\r\n                        if(e.type === Token.OPERATOR) {\r\n                            if(e.is_prefix || e.postfix)\r\n                                //resolve the operation assocated with the prefix\r\n                                Q.push(e.operation(Q.pop()));\r\n                            else {\r\n                                var b = Q.pop();\r\n                                var a = Q.pop();\r\n                                //Throw an error if the RH value is empty. This cannot be a postfix since we already checked\r\n                                if(typeof a === 'undefined')\r\n                                    throw new OperatorError(e + ' is not a valid postfix operator at ' + e.column);\r\n\r\n                                var is_comma = e.action === 'comma';\r\n                                //convert Sets to Vectors on all operations at this point. Sets are only recognized functions or individually\r\n                                if(a instanceof Set && !is_comma)\r\n                                    a = Vector.fromSet(a);\r\n\r\n                                if(b instanceof Set && !is_comma)\r\n                                    b = Vector.fromSet(b);\r\n\r\n                                //call all the pre-operators\r\n                                this.callPeekers('pre_operator', a, b, e);\r\n\r\n                                var ans = _[e.action](a, b);\r\n\r\n                                //call all the pre-operators\r\n                                this.callPeekers('post_operator', ans, a, b, e);\r\n\r\n                                Q.push(ans);\r\n                            }\r\n                        }\r\n                        else if(e.type === Token.FUNCTION) {\r\n                            var args = Q.pop();\r\n                            var parent = args.parent; //make a note of the parent\r\n                            if(!(args instanceof Collection))\r\n                                args = Collection.create(args);\r\n                            //the return value may be a vector. If it is then we check\r\n                            //Q to see if there's another vector on the stack. If it is then\r\n                            //we check if has elements. If it does then we know that we're dealing\r\n                            //with an \"getter\" object and return the requested values\r\n\r\n                            //call the function. This is the _.callfunction method in nerdamer\r\n                            //call the function. This is the _.callfunction method in nerdamer\r\n                            var fn_name = e.value;\r\n                            var fn_args = args.getItems();\r\n\r\n                            //call the pre-function peekers\r\n                            this.callPeekers('pre_function', fn_name, fn_args);\r\n\r\n                            var ret = _.callfunction(fn_name, fn_args);\r\n\r\n                            //call the post-function peekers\r\n                            this.callPeekers('post_function', ret, fn_name, fn_args);\r\n\r\n                            var last = Q[Q.length - 1];\r\n                            var next = rpn[i + 1];\r\n                            var next_is_comma = next && next.type === Token.OPERATOR && next.value === ',';\r\n\r\n                            if(!next_is_comma && ret instanceof Vector && last && last.elements && !(last instanceof Collection)) {\r\n                                //remove the item from the queue\r\n                                var item = Q.pop();\r\n\r\n                                var getter = ret.elements[0];\r\n                                //check if it's symbolic. If so put it back and add the item to the stack\r\n                                if(!getter.isConstant()) {\r\n                                    item.getter = getter;\r\n                                    Q.push(item);\r\n                                    Q.push(ret);\r\n                                }\r\n                                else if(getter instanceof Slice) {\r\n                                    //if it's a Slice return the slice\r\n                                    Q.push(Vector.fromArray(item.elements.slice(getter.start, getter.end)));\r\n                                }\r\n                                else {\r\n                                    var index = Number(getter);\r\n                                    var il = item.elements.length;\r\n                                    //support for negative indices\r\n                                    if(index < 0)\r\n                                        index = il + index;\r\n                                    //it it's still out of bounds\r\n                                    if(index < 0 || index >= il) //index should no longer be negative since it's been reset above\r\n                                        //range error\r\n                                        throw new OutOfRangeError('Index out of range ' + (e.column + 1));\r\n\r\n                                    var element = item.elements[index];\r\n                                    //cyclic but we need to mark this for future reference\r\n                                    item.getter = index;\r\n                                    element.parent = item;\r\n\r\n                                    Q.push(element);\r\n                                }\r\n                            }\r\n                            else {\r\n                                //extend the parent reference\r\n                                if(parent)\r\n                                    ret.parent = parent;\r\n                                Q.push(ret);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            var subbed;\r\n                            var v = e.value;\r\n\r\n                            if(v in Settings.ALIASES)\r\n                                e = _.parse(Settings.ALIASES[e]);\r\n                            //wrap it in a symbol if need be\r\n                            else if(e.type === Token.VARIABLE_OR_LITERAL)\r\n                                e = new Symbol(v);\r\n                            else if(e.type === Token.UNIT) {\r\n                                e = new Symbol(v);\r\n                                e.isUnit = true;\r\n                            }\r\n\r\n                            //make substitutions\r\n                            //Always constants first. This avoids the being overridden\r\n                            if(v in _.CONSTANTS) {\r\n                                subbed = e;\r\n                                e = new Symbol(_.CONSTANTS[v]);\r\n                            }\r\n                            //next substitutions. This allows declared variable to be overridden\r\n                            //check if the values match to avoid erasing the multiplier.\r\n                            //Example:/e = 3*a. substutiting a for a will wipe out the multiplier.\r\n                            else if(v in substitutions && v !== substitutions[v].toString()) {\r\n                                subbed = e;\r\n                                e = substitutions[v].clone();\r\n                            }\r\n                            //next declare variables\r\n                            else if(v in VARS) {\r\n                                subbed = e;\r\n                                e = VARS[v].clone();\r\n                            }\r\n                            //make notation of what it was before\r\n                            if(subbed)\r\n                                e.subbed = subbed;\r\n\r\n                            Q.push(e);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var retval = Q[0];\r\n\r\n                if(['undefined', 'string', 'number'].indexOf(typeof retval) !== -1) {\r\n                    throw new UnexpectedTokenError('Unexpected token!');\r\n                }\r\n\r\n                return retval;\r\n            }\r\n            catch(error) {\r\n                var rethrowErrors = [OutOfFunctionDomainError];\r\n                // Rethrow certain errors in the same class to preserve them\r\n                rethrowErrors.forEach(function (E) {\r\n                    if(error instanceof E) {\r\n                        throw new E(error.message + ': ' + e.column);\r\n                    }\r\n                });\r\n\r\n                throw new ParseError(error.message + ': ' + e.column);\r\n            }\r\n        };\r\n        /**\r\n         * This is the method that triggers the parsing of the string. It generates a parse tree but processes\r\n         * it right away. The operator functions are called when their respective operators are reached. For instance\r\n         * + with cause this.add to be called with the left and right hand values. It works by walking along each\r\n         * character of the string and placing the operators on the stack and values on the output. When an operator\r\n         * having a lower order than the last is reached then the stack is processed from the last operator on the\r\n         * stack.\r\n         * @param {String} token\r\n         */\r\n\r\n        function Node(token) {\r\n            this.type = token.type;\r\n            this.value = token.value;\r\n            //the incoming token may already be a Node type\r\n            this.left = token.left;\r\n            this.right = token.right;\r\n        }\r\n\r\n        Node.prototype.toString = function () {\r\n            var left = this.left ? this.left.toString() + '---' : '';\r\n            var right = this.right ? '---' + this.right.toString() : '';\r\n            return left + '(' + this.value + ')' + right;\r\n        };\r\n\r\n        Node.prototype.toHTML = function (depth, indent) {\r\n            depth = depth || 0;\r\n            indent = typeof indent === 'undefined' ? 4 : indent;\r\n            var tab = function (n) {\r\n                return ' '.repeat(indent * n);\r\n            };\r\n            var html = '';\r\n            var left = this.left ? tab(depth + 1) + '<li>\\n' + this.left.toHTML(depth + 2, indent) + tab(depth + 1) + '</li> \\n' : '';\r\n            var right = this.right ? tab(depth + 1) + '<li>\\n' + this.right.toHTML(depth + 2, indent) + tab(depth + 1) + '</li>\\n' : '';\r\n            var html = tab(depth) + '<div class=\"' + this.type.toLowerCase() + '\"><span>' + this.value + '</span></div>' + tab(depth) + '\\n';\r\n            if(left || right) {\r\n                html += tab(depth) + '<ul>\\n' + left + right + tab(depth) + '</ul>\\n';\r\n            }\r\n            html += '';\r\n            return html;\r\n        };\r\n\r\n        this.tree = function (tokens) {\r\n            var Q = [];\r\n            for(var i = 0; i < tokens.length; i++) {\r\n                var e = tokens[i];\r\n                //Arrays indicate a new scope so parse that out\r\n                if(Array.isArray(e)) {\r\n                    e = this.tree(e);\r\n                    //if it's a comma then it's just arguments\r\n                    Q.push(e);\r\n                    continue;\r\n                }\r\n                if(e.type === Token.OPERATOR) {\r\n                    if(e.is_prefix || e.postfix) {\r\n                        //prefixes go to the left, postfix to the right\r\n                        var location = e.is_prefix ? 'left' : 'right';\r\n                        var last = Q.pop();\r\n                        e = new Node(e);\r\n                        e[location] = last;\r\n                        Q.push(e);\r\n                    }\r\n                    else {\r\n                        e = new Node(e);\r\n                        e.right = Q.pop();\r\n                        e.left = Q.pop();\r\n                        Q.push(e);\r\n                    }\r\n                }\r\n                else if(e.type === Token.FUNCTION) {\r\n                    e = new Node(e);\r\n                    var args = Q.pop();\r\n                    e.right = args;\r\n                    if(e.value === 'object') {\r\n                        //check if Q has a value\r\n                        var last = Q[Q.length - 1];\r\n                        if(last) {\r\n                            while(last.right) {\r\n                                last = last.right;\r\n                            }\r\n                            last.right = e;\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    Q.push(e);\r\n                }\r\n                else {\r\n                    Q.push(new Node(e));\r\n                }\r\n            }\r\n\r\n            return Q[0];\r\n        };\r\n        this.parse = function (e, substitutions) {\r\n            e = prepare_expression(e);\r\n            substitutions = substitutions || {};\r\n            //three passes but easier to debug\r\n            var tokens = this.tokenize(e);\r\n            var rpn = this.toRPN(tokens);\r\n            return this.parseRPN(rpn, substitutions);\r\n        };\r\n        /**\r\n         * TODO: Switch to Parser.tokenize for this method\r\n         * Reads a string into an array of Symbols and operators\r\n         * @param {String} expression_string\r\n         * @returns {Array}\r\n         */\r\n        this.toObject = function (expression_string) {\r\n            var objectify = function (tokens) {\r\n                var output = [];\r\n                for(var i = 0, l = tokens.length; i < l; i++) {\r\n                    var token = tokens[i];\r\n                    var v = token.value;\r\n                    if(token.type === Token.VARIABLE_OR_LITERAL) {\r\n                        output.push(new Symbol(v));\r\n                    }\r\n                    else if(token.type === Token.FUNCTION) {\r\n                        //jump ahead since the next object are the arguments\r\n                        i++;\r\n                        //create a symbolic function and stick it on output\r\n                        var f = _.symfunction(v, objectify(tokens[i]));\r\n                        f.isConversion = true;\r\n                        output.push(f);\r\n                    }\r\n                    else if(token.type === Token.OPERATOR) {\r\n                        output.push(v);\r\n                    }\r\n                    else {\r\n                        output.push(objectify(token));\r\n                    }\r\n                }\r\n\r\n                return output;\r\n            };\r\n            return objectify(_.tokenize(expression_string));\r\n        };\r\n\r\n        // A helper method for toTeX\r\n        var chunkAtCommas = function (arr) {\r\n            var j, k = 0, chunks = [[]];\r\n            for(var j = 0, l = arr.length; j < l; j++) {\r\n                if(arr[j] === ',') {\r\n                    k++;\r\n                    chunks[k] = [];\r\n                }\r\n                else {\r\n                    chunks[k].push(arr[j]);\r\n                }\r\n            }\r\n            return chunks;\r\n        };\r\n\r\n        // Helper method for toTeX\r\n        var rem_brackets = function (str) {\r\n            return str.replace(/^\\\\left\\((.+)\\\\right\\)$/g, function (str, a) {\r\n                if(a)\r\n                    return a;\r\n                return str;\r\n            });\r\n        };\r\n\r\n        var remove_redundant_powers = function (arr) {\r\n            // The filtered array\r\n            var narr = [];\r\n\r\n            while(arr.length) {\r\n                // Remove the element from the front\r\n                var e = arr.shift();\r\n                var next = arr[0];\r\n                var next_is_array = isArray(next);\r\n                var next_is_minus = next === '-';\r\n\r\n                // Remove redundant plusses \r\n                if(e === '^') {\r\n                    if(next === '+') {\r\n                        arr.shift();\r\n                    }\r\n                    else if(next_is_array && next[0] === '+') {\r\n                        next.shift();\r\n                    }\r\n\r\n                    // Remove redundant parentheses\r\n                    if(next_is_array && next.length === 1) {\r\n                        arr.unshift(arr.shift()[0]);\r\n                    }\r\n                }\r\n\r\n                // Check if it's a negative power\r\n                if(e === '^' && (next_is_array && next[0] === '-' || next_is_minus)) {\r\n                    // If so:\r\n                    // - Remove it from the new array, place a one and a division sign in that array and put it back\r\n                    var last = narr.pop();\r\n                    // Check if it's something multiplied by\r\n                    var before = narr[narr.length - 1];\r\n                    var before_last = '1';\r\n\r\n                    if(before === '*') {\r\n                        narr.pop();\r\n                        // For simplicity we just pop it. \r\n                        before_last = narr.pop();\r\n                    }\r\n                    // Implied multiplication\r\n                    else if(isArray(before)) {\r\n                        before_last = narr.pop();\r\n                    }\r\n\r\n                    narr.push(before_last, '/', last, e);\r\n\r\n                    // Remove the negative sign from the power \r\n                    if(next_is_array) {\r\n                        next.shift();\r\n                    }\r\n                    else {\r\n                        arr.shift();\r\n                    }\r\n\r\n                    // Remove it from the array so we don't end up with redundant parentheses if we can\r\n                    if(next_is_array && next.length === 1) {\r\n                        narr.push(arr.shift()[0]);\r\n                    }\r\n                }\r\n                else {\r\n                    narr.push(e);\r\n                }\r\n            }\r\n\r\n            return narr;\r\n        };\r\n        /*\r\n         * Convert expression or object to LaTeX\r\n         * @param {String} expression_or_obj\r\n         * @param {object} opt\r\n         * @returns {String}\r\n         */\r\n        this.toTeX = function (expression_or_obj, opt) {\r\n            opt = opt || {};\r\n            // Add decimal option as per issue #579. Consider passing an object to Latex.latex as option instead of string\r\n            var decimals = opt.decimals === true ? 'decimals' : undefined;\r\n\r\n            var obj = typeof expression_or_obj === 'string' ? this.toObject(expression_or_obj) : expression_or_obj,\r\n                    TeX = [],\r\n                    cdot = typeof opt.cdot === 'undefined' ? '\\\\cdot' : opt.cdot; //set omit cdot to true by default\r\n\r\n            // Remove negative powers as per issue #570\r\n            obj = remove_redundant_powers(obj);\r\n\r\n            if(isArray(obj)) {\r\n                var nobj = [], a, b;\r\n                //first handle ^\r\n                for(var i = 0; i < obj.length; i++) {\r\n                    a = obj[i];\r\n\r\n                    if(obj[i + 1] === '^') {\r\n                        b = obj[i + 2];\r\n                        nobj.push(LaTeX.braces(this.toTeX([a])) + '^' + LaTeX.braces(this.toTeX([b])));\r\n                        i += 2;\r\n                    }\r\n                    else {\r\n                        nobj.push(a);\r\n                    }\r\n                }\r\n                obj = nobj;\r\n            }\r\n\r\n            for(var i = 0, l = obj.length; i < l; i++) {\r\n                var e = obj[i];\r\n\r\n                // Convert * to cdot\r\n                if(e === '*') {\r\n                    e = cdot;\r\n                }\r\n\r\n                if(isSymbol(e)) {\r\n                    if(e.group === FN) {\r\n                        var fname = e.fname, f;\r\n\r\n                        if(fname === SQRT)\r\n                            f = '\\\\sqrt' + LaTeX.braces(this.toTeX(e.args));\r\n                        else if(fname === ABS)\r\n                            f = LaTeX.brackets(this.toTeX(e.args), 'abs');\r\n                        else if(fname === PARENTHESIS)\r\n                            f = LaTeX.brackets(this.toTeX(e.args), 'parens');\r\n                        else if(fname === Settings.LOG10) {\r\n                            f = '\\\\' + Settings.LOG10_LATEX + '\\\\left( ' + this.toTeX(e.args) + '\\\\right)';\r\n                        }\r\n                        else if(fname === 'integrate') {\r\n                            /* Retrive [Expression, x] */\r\n                            var chunks = chunkAtCommas(e.args);\r\n                            /* Build TeX */\r\n                            var expr = LaTeX.braces(this.toTeX(chunks[0])),\r\n                                    dx = this.toTeX(chunks[1]);\r\n                            f = '\\\\int ' + expr + '\\\\, d' + dx;\r\n                        }\r\n                        else if(fname === 'defint') {\r\n                            var chunks = chunkAtCommas(e.args),\r\n                                    expr = LaTeX.braces(this.toTeX(chunks[0])),\r\n                                    dx = this.toTeX(chunks[3]),\r\n                                    lb = this.toTeX(chunks[1]),\r\n                                    ub = this.toTeX(chunks[2]);\r\n                            f = '\\\\int\\\\limits_{' + lb + '}^{' + ub + '} ' + expr + '\\\\, d' + dx;\r\n\r\n                        }\r\n                        else if(fname === 'diff') {\r\n                            var chunks = chunkAtCommas(e.args);\r\n                            var dx = '', expr = LaTeX.braces(this.toTeX(chunks[0]));\r\n                            /* Handle cases: one argument provided, we need to guess the variable, and assume n = 1 */\r\n                            if(chunks.length === 1) {\r\n                                var vars = [];\r\n                                for(j = 0; j < chunks[0].length; j++) {\r\n                                    if(chunks[0][j].group === 3) {\r\n                                        vars.push(chunks[0][j].value);\r\n                                    }\r\n                                }\r\n                                vars.sort();\r\n                                dx = vars.length > 0 ? ('\\\\frac{d}{d ' + vars[0] + '}') : '\\\\frac{d}{d x}';\r\n                            }\r\n                            /* If two arguments, we have expression and variable, we assume n = 1 */\r\n                            else if(chunks.length === 2) {\r\n                                dx = '\\\\frac{d}{d ' + chunks[1] + '}';\r\n                            }\r\n                            /* If we have more than 2 arguments, we assume we've got everything */\r\n                            else {\r\n                                dx = '\\\\frac{d^{' + chunks[2] + '}}{d ' + this.toTeX(chunks[1]) + '^{' + chunks[2] + '}}';\r\n                            }\r\n\r\n                            f = dx + '\\\\left(' + expr + '\\\\right)';\r\n\r\n                        }\r\n                        else if(fname === 'sum' || fname === 'product') {\r\n                            // Split e.args into 4 parts based on locations of , symbols.\r\n                            var argSplit = [[], [], [], []], j = 0, i;\r\n                            for(i = 0; i < e.args.length; i++) {\r\n                                if(e.args[i] === ',') {\r\n                                    j++;\r\n                                    continue;\r\n                                }\r\n                                argSplit[j].push(e.args[i]);\r\n                            }\r\n                            // Then build TeX string.\r\n                            f = (fname === 'sum' ? '\\\\sum_' : '\\\\prod_') + LaTeX.braces(this.toTeX(argSplit[1]) + ' = ' + this.toTeX(argSplit[2]));\r\n                            f += '^' + LaTeX.braces(this.toTeX(argSplit[3])) + LaTeX.braces(this.toTeX(argSplit[0]));\r\n                        }\r\n                        else if(fname === 'limit') {\r\n                            var args = chunkAtCommas(e.args).map(function (x) {\r\n                                if(Array.isArray(x))\r\n                                    return _.toTeX(x.join(''));\r\n                                return _.toTeX(String(x));\r\n                            });\r\n                            f = '\\\\lim_' + LaTeX.braces(args[1] + '\\\\to ' + args[2]) + ' ' + LaTeX.braces(args[0]);\r\n                        }\r\n                        else if(fname === FACTORIAL || fname === DOUBLEFACTORIAL)\r\n                            f = this.toTeX(e.args) + (fname === FACTORIAL ? '!' : '!!');\r\n                        else {\r\n\r\n                            f = LaTeX.latex(e, decimals);\r\n                            //f = '\\\\mathrm'+LaTeX.braces(fname.replace(/_/g, '\\\\_')) + LaTeX.brackets(this.toTeX(e.args), 'parens');\r\n                        }\r\n\r\n                        TeX.push(f);\r\n                    }\r\n                    else {\r\n                        TeX.push(LaTeX.latex(e, decimals));\r\n                    }\r\n                }\r\n                else if(isArray(e)) {\r\n                    TeX.push(LaTeX.brackets(this.toTeX(e)));\r\n                }\r\n                else {\r\n                    if(e === '/')\r\n                        TeX.push(LaTeX.frac(rem_brackets(TeX.pop()), rem_brackets(this.toTeX([obj[++i]]))));\r\n                    else\r\n                        TeX.push(e);\r\n                }\r\n            }\r\n\r\n            return TeX.join(' ');\r\n        };\r\n\r\n//Parser.functions ==============================================================\r\n        /* Although parens is not a \"real\" function it is important in some cases when the\r\n         * symbol must carry parenthesis. Once set you don't have to worry about it anymore\r\n         * as the parser will get rid of it at the first opportunity\r\n         */\r\n        function parens(symbol) {\r\n            if(Settings.PARSE2NUMBER) {\r\n                return symbol;\r\n            }\r\n            return _.symfunction('parens', [symbol]);\r\n        }\r\n\r\n        function abs(symbol) {\r\n\r\n            //|-| = \r\n            if(symbol.isInfinity) {\r\n                return Symbol.infinity();\r\n            }\r\n            if(symbol.multiplier.lessThan(0))\r\n                symbol.multiplier.negate();\r\n\r\n            if(symbol.isImaginary()) {\r\n                var re = symbol.realpart();\r\n                var im = symbol.imagpart();\r\n                if(re.isConstant() && im.isConstant())\r\n                    return sqrt(_.add(_.pow(re, new Symbol(2)), _.pow(im, new Symbol(2))));\r\n            }\r\n            else if(isNumericSymbol(symbol) || even(symbol.power)) {\r\n                return symbol;\r\n            }\r\n\r\n            if(symbol.isComposite()) {\r\n                var ms = [];\r\n                symbol.each(function (x) {\r\n                    ms.push(x.multiplier);\r\n                });\r\n                var gcd = Math2.QGCD.apply(null, ms);\r\n                if(gcd.lessThan(0)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(new Frac(-1));\r\n                    symbol.distributeMultiplier();\r\n                }\r\n            }\r\n\r\n            //convert |n*x| to n*|x|\r\n            var m = _.parse(symbol.multiplier);\r\n            symbol.toUnitMultiplier();\r\n\r\n            return _.multiply(m, _.symfunction(ABS, [symbol]));\r\n        }\r\n        /**\r\n         * The factorial function\r\n         * @param {Symbol} symbol\r\n         * @return {Symbol}\r\n         */\r\n        function factorial(symbol) {\r\n            var retval;\r\n            if(isVector(symbol)) {\r\n                var V = new Vector();\r\n                symbol.each(function (x, i) {\r\n                    //i start at one.\r\n                    V.set(i - 1, factorial(x));\r\n                });\r\n                return V;\r\n            }\r\n            if(isMatrix(symbol)) {\r\n                var M = new Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    //i start at one.\r\n                    M.set(i, j, factorial(x));\r\n                });\r\n                return M;\r\n            }\r\n            if(Settings.PARSE2NUMBER && symbol.isConstant()) {\r\n                if(isInt(symbol)) {\r\n                    retval = Math2.bigfactorial(symbol);\r\n                }\r\n                else {\r\n                    retval = Math2.gamma(symbol.multiplier.add(new Frac(1)).toDecimal());\r\n                }\r\n\r\n                retval = bigConvert(retval);\r\n                return retval;\r\n            }\r\n            else if(symbol.isConstant()) {\r\n                var den = symbol.getDenom();\r\n                if(den.equals(2)) {\r\n                    var num = symbol.getNum();\r\n                    var a, b, c, n;\r\n\r\n                    if(!symbol.multiplier.isNegative()) {\r\n                        n = _.add(num, new Symbol(1)).multiplier.divide(new Frac(2));\r\n                        a = Math2.bigfactorial(new Frac(2).multiply(n));\r\n                        b = _.pow(new Symbol(4), new Symbol(n)).multiplier.multiply(Math2.bigfactorial(n));\r\n                    }\r\n                    else {\r\n                        n = _.subtract(num.negate(), new Symbol(1)).multiplier.divide(new Frac(2));\r\n                        a = _.pow(new Symbol(-4), new Symbol(n)).multiplier.multiply(Math2.bigfactorial(n));\r\n                        b = Math2.bigfactorial(new Frac(2).multiply(n));\r\n                    }\r\n                    c = a.divide(b);\r\n                    return _.multiply(_.parse('sqrt(pi)'), new Symbol(c));\r\n                }\r\n            }\r\n            return _.symfunction(FACTORIAL, [symbol]);\r\n        }\r\n        ;\r\n        /**\r\n         * Returns the continued fraction of a number\r\n         * @param {Symbol} symbol\r\n         * @param {Symbol} n\r\n         * @returns {Symbol}\r\n         */\r\n        function continued_fraction(symbol, n) {\r\n            var _symbol = evaluate(symbol);\r\n            if(_symbol.isConstant()) {\r\n                var cf = Math2.continuedFraction(_symbol, n);\r\n                //convert the fractions array to a new Vector\r\n                var fractions = Vector.fromArray(cf.fractions.map(function (x) {\r\n                    return new Symbol(x);\r\n                }));\r\n                return Vector.fromArray([new Symbol(cf.sign), new Symbol(cf.whole), fractions]);\r\n            }\r\n            return _.symfunction('continued_fraction', arguments);\r\n        }\r\n        /**\r\n         * Returns the error function\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function erf(symbol) {\r\n            var _symbol = evaluate(symbol);\r\n\r\n            if(_symbol.isConstant()) {\r\n                return Math2.erf(_symbol);\r\n            }\r\n            else if(_symbol.isImaginary()) {\r\n                return complex.erf(symbol);\r\n            }\r\n            return _.symfunction('erf', arguments);\r\n        }\r\n        ;\r\n        /**\r\n         * The mod function\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Symbol}\r\n         */\r\n        function mod(symbol1, symbol2) {\r\n            if(symbol1.isConstant() && symbol2.isConstant()) {\r\n                var retval = new Symbol(1);\r\n                retval.multiplier = retval.multiplier.multiply(symbol1.multiplier.mod(symbol2.multiplier));\r\n                return retval;\r\n            }\r\n            //try to see if division has remainder of zero\r\n            var r = _.divide(symbol1.clone(), symbol2.clone());\r\n            if(isInt(r))\r\n                return new Symbol(0);\r\n            return _.symfunction('mod', [symbol1, symbol2]);\r\n        }\r\n        /**\r\n         * A branghing function\r\n         * @param {Boolean} condition\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        function IF(condition, a, b) {\r\n            if(typeof condition !== 'boolean')\r\n                if(isNumericSymbol(condition))\r\n                    condition = !!Number(condition);\r\n            if(condition)\r\n                return a;\r\n            return b;\r\n        }\r\n        /**\r\n         *\r\n         * @param {Matrix|Vector|Set|Collection} obj\r\n         * @param {Symbol} item\r\n         * @returns {Boolean}\r\n         */\r\n        function is_in(obj, item) {\r\n            if(isMatrix(obj)) {\r\n                for(var i = 0, l = obj.rows(); i < l; i++) {\r\n                    for(var j = 0, l2 = obj.cols(); j < l2; j++) {\r\n                        var element = obj.elements[i][j];\r\n                        if(element.equals(item))\r\n                            return new Symbol(1);\r\n                    }\r\n                }\r\n            }\r\n            else if(obj.elements) {\r\n                for(var i = 0, l = obj.elements.length; i < l; i++) {\r\n                    if(obj.elements[i].equals(item))\r\n                        return new Symbol(1);\r\n                }\r\n            }\r\n\r\n            return new Symbol(0);\r\n        }\r\n\r\n        /**\r\n         * A symbolic extension for sinc\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function sinc(symbol) {\r\n            if(Settings.PARSE2NUMBER) {\r\n                if(symbol.isConstant()) {\r\n                    return new Symbol(Math2.sinc(symbol));\r\n                }\r\n                return _.parse(format('sin({0})/({0})', symbol));\r\n            }\r\n            return _.symfunction('sinc', [symbol]);\r\n        }\r\n\r\n        /**\r\n         * A symbolic extension for exp. This will auto-convert all instances of exp(x) to e^x.\r\n         * Thanks @ Happypig375\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function exp(symbol) {\r\n            if(symbol.fname === Settings.LOG && symbol.isLinear()) {\r\n                return _.pow(symbol.args[0], Symbol.create(symbol.multiplier));\r\n            }\r\n            return _.parse(format('e^({0})', symbol));\r\n        }\r\n\r\n        /**\r\n         * Converts value degrees to radians\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function radians(symbol) {\r\n            return _.parse(format('({0})*pi/180', symbol));\r\n        }\r\n\r\n        /**\r\n         * Converts value from radians to degrees\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function degrees(symbol) {\r\n            return _.parse(format('({0})*180/pi', symbol));\r\n        }\r\n\r\n        function nroots(symbol) {\r\n            var a, b;\r\n            if(symbol.group === FN && symbol.fname === '') {\r\n                a = Symbol.unwrapPARENS(_.parse(symbol).toLinear());\r\n                b = _.parse(symbol.power);\r\n            }\r\n            else if(symbol.group === P) {\r\n                a = _.parse(symbol.value);\r\n                b = _.parse(symbol.power);\r\n            }\r\n\r\n            if(a && b && a.group === N && b.group === N) {\r\n                var _roots = [];\r\n                var parts = Symbol.toPolarFormArray(symbol);\r\n                var r = _.parse(a).abs().toString();\r\n                //https://en.wikipedia.org/wiki/De_Moivre%27s_formula\r\n                var x = arg(a).toString();\r\n                var n = b.multiplier.den.toString();\r\n                var p = b.multiplier.num.toString();\r\n\r\n                var formula = \"(({0})^({1})*(cos({3})+({2})*sin({3})))^({4})\";\r\n                for(var i = 0; i < n; i++) {\r\n                    var t = evaluate(_.parse(format(\"(({0})+2*pi*({1}))/({2})\", x, i, n))).multiplier.toDecimal();\r\n                    _roots.push(evaluate(_.parse(format(formula, r, n, Settings.IMAGINARY, t, p))));\r\n                }\r\n                return Vector.fromArray(_roots);\r\n            }\r\n            else if(symbol.isConstant(true)) {\r\n                var sign = symbol.sign();\r\n                var x = evaluate(symbol.abs());\r\n                var root = _.sqrt(x);\r\n\r\n                var _roots = [root.clone(), root.negate()];\r\n\r\n                if(sign < 0)\r\n                    _roots = _roots.map(function (x) {\r\n                        return _.multiply(x, Symbol.imaginary());\r\n                    });\r\n            }\r\n            else {\r\n                _roots = [_.parse(symbol)];\r\n            }\r\n\r\n            return Vector.fromArray(_roots);\r\n        }\r\n\r\n        /**\r\n         * Rationalizes a symbol\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function rationalize(symbol) {\r\n            if(symbol.isComposite()) {\r\n                var retval = new Symbol(0);\r\n                var num, den, retnum, retden, a, b, n, d;\r\n                symbol.each(function (x) {\r\n                    num = x.getNum();\r\n                    den = x.getDenom();\r\n                    retnum = retval.getNum();\r\n                    retden = retval.getDenom();\r\n                    a = _.multiply(den, retnum);\r\n                    b = _.multiply(num, retden);\r\n                    n = _.expand(_.add(a, b));\r\n                    d = _.multiply(retden, den);\r\n                    retval = _.divide(n, d);\r\n                }, true);\r\n\r\n                return retval;\r\n            }\r\n            return symbol;\r\n        }\r\n\r\n        /**\r\n         * The square root function\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function sqrt(symbol) {\r\n            if(!isSymbol(symbol)) {\r\n                symbol = _.parse(symbol);\r\n            }\r\n            \r\n            // Exit early for EX\r\n            if(symbol.group === EX) {\r\n                return _.symfunction(SQRT, [symbol]);\r\n            }\r\n\r\n            if(symbol.fname === '' && symbol.power.equals(1))\r\n                symbol = symbol.args[0];\r\n\r\n            var is_negative = symbol.multiplier.sign() < 0;\r\n\r\n            if(Settings.PARSE2NUMBER) {\r\n                if(symbol.isConstant() && !is_negative) {\r\n                    return new Symbol(bigDec.sqrt(symbol.multiplier.toDecimal()));\r\n                }\r\n                else if(symbol.isImaginary()) {\r\n                    return complex.sqrt(symbol);\r\n                }\r\n                else if(symbol.group === S) {\r\n                    return _.symfunction('sqrt', [symbol]);\r\n                }\r\n            }\r\n\r\n            var img, retval,\r\n                    isConstant = symbol.isConstant();\r\n\r\n            if(symbol.group === CB && symbol.isLinear()) {\r\n                var m = sqrt(Symbol(symbol.multiplier));\r\n                for(var s in symbol.symbols) {\r\n                    var x = symbol.symbols[s];\r\n                    m = _.multiply(m, sqrt(x));\r\n                }\r\n\r\n                retval = m;\r\n            }\r\n            //if the symbol is already sqrt then it's that symbol^(1/4) and we can unwrap it\r\n            else if(symbol.fname === SQRT) {\r\n                var s = symbol.args[0];\r\n                var ms = symbol.multiplier;\r\n                s.setPower(symbol.power.multiply(new Frac(0.25)));\r\n                retval = s;\r\n                //grab the multiplier\r\n                if(!ms.equals(1))\r\n                    retval = _.multiply(sqrt(_.parse(ms)), retval);\r\n            }\r\n            //if the symbol is a fraction then we don't keep can unwrap it. For instance\r\n            //no need to keep sqrt(x^(1/3))\r\n            else if(!symbol.power.isInteger()) {\r\n                symbol.setPower(symbol.power.multiply(new Frac(0.5)));\r\n                retval = symbol;\r\n            }\r\n            else if(symbol.multiplier < 0 && symbol.group === S) {\r\n                var a = _.parse(symbol.multiplier).negate();\r\n                var b = _.parse(symbol).toUnitMultiplier().negate();\r\n                retval = _.multiply(_.symfunction(Settings.SQRT, [b]), sqrt(a));\r\n            }\r\n            else {\r\n\r\n                //Related to issue #401. Since sqrt(a)*sqrt(b^-1) relates in issues, we'll change the form\r\n                //to sqrt(a)*sqrt(b)^1 for better simplification\r\n                //the sign of the power\r\n                var sign = symbol.power.sign();\r\n                //remove the sign\r\n                symbol.power = symbol.power.abs();\r\n\r\n                //if the symbols is imagary then we place in the imaginary part. We'll return it\r\n                //as a product\r\n                if(isConstant && symbol.multiplier.lessThan(0)) {\r\n                    img = Symbol.imaginary();\r\n                    symbol.multiplier = symbol.multiplier.abs();\r\n                }\r\n\r\n                var q = symbol.multiplier.toDecimal(),\r\n                        qa = Math.abs(q),\r\n                        t = Math.sqrt(qa);\r\n\r\n                var m;\r\n                //it's a perfect square so take the square\r\n                if(isInt(t)) {\r\n                    m = new Symbol(t);\r\n                }\r\n                else if(isInt(q)) {\r\n                    var factors = Math2.ifactor(q);\r\n                    var tw = 1;\r\n                    for(var x in factors) {\r\n                        var n = factors[x],\r\n                                nn = (n - (n % 2)); //get out the whole numbers\r\n                        if(nn) { //if there is a whole number ...\r\n                            var w = Math.pow(x, nn);\r\n                            tw *= Math.pow(x, nn / 2); //add to total wholes\r\n                            q /= w; //reduce the number by the wholes\r\n                        }\r\n                    }\r\n                    m = _.multiply(_.symfunction(SQRT, [new Symbol(q)]), new Symbol(tw));\r\n                }\r\n                else {\r\n                    //reduce the numerator and denominator using prime factorization\r\n                    var c = [new Symbol(symbol.multiplier.num), new Symbol(symbol.multiplier.den)];\r\n                    var r = [new Symbol(1), new Symbol(1)];\r\n                    var sq = [new Symbol(1), new Symbol(1)];\r\n                    for(var i = 0; i < 2; i++) {\r\n                        var n = c[i];\r\n                        //get the prime factors and loop through each.\r\n                        pfactor(n).each(function (x) {\r\n                            x = Symbol.unwrapPARENS(x);\r\n                            var b = x.clone().toLinear();\r\n                            var p = Number(x.power);\r\n                            //We'll consider it safe to use the native Number since 2^1000 is already a pretty huge number\r\n                            var rem = p % 2; //get the remainder. This will be 1 if 3 since sqrt(n^2) = n where n is positive\r\n                            var w = (p - rem) / 2; //get the whole numbers of n/2\r\n                            r[i] = _.multiply(r[i], _.pow(b, new Symbol(w)));\r\n                            sq[i] = _.multiply(sq[i], sqrt(_.pow(b, new Symbol(rem))));\r\n                        });\r\n                    }\r\n                    m = _.divide(_.multiply(r[0], sq[0]), _.multiply(r[1], sq[1]));\r\n                }\r\n\r\n\r\n                //strip the multiplier since we already took the sqrt\r\n                symbol = symbol.toUnitMultiplier(true);\r\n                //if the symbol is one just return one and not the sqrt function\r\n                if(symbol.isOne()) {\r\n                    retval = symbol;\r\n                }\r\n                else if(even(symbol.power.toString())) {\r\n                    //just raise it to the 1/2\r\n                    retval = _.pow(symbol.clone(), new Symbol(0.5));\r\n                }\r\n                else {\r\n                    retval = _.symfunction(SQRT, [symbol]);\r\n                }\r\n\r\n                //put back the sign that was removed earlier\r\n                if(sign < 0)\r\n                    retval.power.negate();\r\n\r\n                if(m)\r\n                    retval = _.multiply(m, retval);\r\n\r\n                if(img)\r\n                    retval = _.multiply(img, retval);\r\n            }\r\n\r\n            if(is_negative && Settings.PARSE2NUMBER)\r\n                return _.parse(retval);\r\n\r\n            return retval;\r\n        }\r\n\r\n        /**\r\n         * The cube root function\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function cbrt(symbol) {\r\n            if(!symbol.isConstant(true)) {\r\n                var retval;\r\n\r\n                var n = symbol.power / 3;\r\n                //take the cube root of the multplier\r\n                var m = _.pow(_.parse(symbol.multiplier), new Symbol(1 / 3));\r\n                //strip the multiplier\r\n                var sym = symbol.toUnitMultiplier();\r\n\r\n                //simplify the power\r\n                if(isInt(n)) {\r\n                    retval = _.pow(sym.toLinear(), _.parse(n));\r\n                }\r\n                else {\r\n                    if(sym.group === CB) {\r\n                        retval = new Symbol(1);\r\n                        sym.each(function (x) {\r\n                            retval = _.multiply(retval, cbrt(x));\r\n                        });\r\n                    }\r\n                    else {\r\n                        retval = _.symfunction('cbrt', [sym]);\r\n                    }\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n            return nthroot(symbol, new Symbol(3));\r\n        }\r\n\r\n        function scientific(symbol, sigfigs) {\r\n            //Just set the flag and keep it moving. Symbol.toString will deal with how to\r\n            //display this\r\n            symbol.scientific = sigfigs || 10;\r\n            return symbol;\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {Symbol} num - the number being raised\r\n         * @param {Symbol} p - the exponent\r\n         * @param {type} prec - the precision wanted\r\n         * @param {bool} asbig - true if a bigDecimal is wanted\r\n         * @returns {Symbol}\r\n         */\r\n        function nthroot(num, p, prec, asbig) {\r\n            //clone p and convert to a number if possible\r\n            p = evaluate(_.parse(p));\r\n\r\n            //cannot calculate if p = 0. nthroot(0, 0) => 0^(1/0) => undefined\r\n            if(p.equals(0)) {\r\n                throw new UndefinedError('Unable to calculate nthroots of zero');\r\n            }\r\n\r\n            //Stop computation if it negative and even since we have an imaginary result\r\n            if(num < 0 && even(p))\r\n                throw new Error('Cannot calculate nthroot of negative number for even powers');\r\n\r\n            //return non numeric values unevaluated\r\n            if(!num.isConstant(true)) {\r\n                return _.symfunction('nthroot', arguments);\r\n            }\r\n\r\n            //evaluate numeric values\r\n            if(num.group !== N) {\r\n                num = evaluate(num);\r\n            }\r\n\r\n            //default is to return a big value\r\n            if(typeof asbig === 'undefined')\r\n                asbig = true;\r\n\r\n            prec = prec || 25;\r\n\r\n            var sign = num.sign();\r\n            var retval;\r\n            var ans;\r\n\r\n            if(sign < 0) {\r\n                num = abs(num); //remove the sign\r\n            }\r\n\r\n            if(isInt(num) && p.isConstant()) {\r\n\r\n                if(num < 18446744073709551616) {\r\n                    //2^64\r\n                    ans = Frac.create(Math.pow(num, 1 / p));\r\n                }\r\n                else {\r\n                    ans = Math2.nthroot(num, p);\r\n                }\r\n\r\n                var retval;\r\n                if(asbig) {\r\n                    retval = new Symbol(ans);\r\n                }\r\n                retval = new Symbol(ans.toDecimal(prec));\r\n\r\n                return _.multiply(new Symbol(sign), retval);\r\n            }\r\n        }\r\n\r\n        function pfactor(symbol) {\r\n            //Fix issue #458 | nerdamer(\"sqrt(1-(3.3333333550520926e-7)^2)\").evaluate().text()\r\n            //More Big Number issues >:(\r\n            if(symbol.greaterThan(9.999999999998891e+41) || symbol.equals(-1))\r\n                return symbol;\r\n            //Fix issue #298\r\n            if(symbol.equals(Math.PI))\r\n                return new Symbol(Math.PI);\r\n            //evaluate the symbol to merge constants\r\n            symbol = evaluate(symbol.clone());\r\n\r\n            if(symbol.isConstant()) {\r\n                var retval = new Symbol(1);\r\n                var m = symbol.toString();\r\n                if(isInt(m)) {\r\n                    var factors = Math2.ifactor(m);\r\n                    for(var factor in factors) {\r\n                        var p = factors[factor];\r\n                        retval = _.multiply(retval, _.symfunction('parens', [new Symbol(factor).setPower(new Frac(p))]));\r\n                    }\r\n                }\r\n                else {\r\n                    var n = pfactor(new Symbol(symbol.multiplier.num));\r\n                    var d = pfactor(new Symbol(symbol.multiplier.den));\r\n                    retval = _.multiply(_.symfunction('parens', [n]), _.symfunction('parens', [d]).invert());\r\n                }\r\n            }\r\n            else\r\n                retval = _.symfunction('pfactor', arguments);\r\n            return retval;\r\n        }\r\n\r\n        /**\r\n         * Get's the real part of a complex number. Return number if real\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function realpart(symbol) {\r\n            return symbol.realpart();\r\n        }\r\n\r\n        /**\r\n         * Get's the imaginary part of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function imagpart(symbol) {\r\n            return symbol.imagpart();\r\n        }\r\n\r\n        /**\r\n         * Computes the conjugate of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function conjugate(symbol) {\r\n            var re = symbol.realpart();\r\n            var im = symbol.imagpart();\r\n            return _.add(re, _.multiply(im.negate(), Symbol.imaginary()));\r\n        }\r\n\r\n        /**\r\n         * Returns the arugment of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function arg(symbol) {\r\n            var re = symbol.realpart();\r\n            var im = symbol.imagpart();\r\n            if(re.isConstant() && im.isConstant())\r\n                return new Symbol(Math.atan2(im, re));\r\n            return _.symfunction('atan2', [im, re]);\r\n        }\r\n\r\n        /**\r\n         * Returns the arugment of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function arg(symbol) {\r\n            var re = symbol.realpart();\r\n            var im = symbol.imagpart();\r\n            if(re.isConstant() && im.isConstant()) {\r\n                if(im.equals(0) && re.equals(-1)) {\r\n                    return _.parse('pi');\r\n                }\r\n                else if(im.equals(1) && re.equals(0)) {\r\n                    return _.parse('pi/2');\r\n                }\r\n                else if(im.equals(1) && re.equals(1)) {\r\n                    return _.parse('pi/4');\r\n                }\r\n                return new Symbol(Math.atan2(im, re));\r\n            }\r\n            return _.symfunction('atan2', [im, re]);\r\n        }\r\n\r\n        /**\r\n         * Returns the polarform of a complex number\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function polarform(symbol) {\r\n            var p, r, e, theta;\r\n            p = Symbol.toPolarFormArray(symbol);\r\n            theta = p[1];\r\n            r = p[0];\r\n            e = _.parse(format('e^({0}*({1}))', Settings.IMAGINARY, theta));\r\n            return _.multiply(r, e);\r\n        }\r\n\r\n        /**\r\n         * Returns the rectangular form of a complex number. Does not work for symbolic coefficients\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function rectform(symbol) {\r\n            //TODO: e^((i*pi)/4)\r\n            var original = symbol.clone();\r\n            try {\r\n                var f, p, q, s, h, d, n;\r\n                f = decompose_fn(symbol, 'e', true);\r\n                p = _.divide(f.x.power, Symbol.imaginary());\r\n                q = evaluate(trig.tan(p));\r\n                s = _.pow(f.a, new Symbol(2));\r\n                d = q.getDenom(true);\r\n                n = q.getNum();\r\n                h = Symbol.hyp(n, d);\r\n                //check\r\n                if(h.equals(f.a)) {\r\n                    return _.add(d, _.multiply(Symbol.imaginary(), n));\r\n                }\r\n                else {\r\n                    return original;\r\n                }\r\n            }\r\n            catch(e) {\r\n                return original;\r\n            }\r\n        }\r\n\r\n        function symMinMax(f, args) {\r\n            args.map(function (x) {\r\n                x.numVal = evaluate(x).multiplier;\r\n            });\r\n            var l, a, b, a_val, b_val;\r\n            while(true) {\r\n                l = args.length;\r\n                if(l < 2)\r\n                    return args[0];\r\n                a = args.pop();\r\n                b = args[l - 2];\r\n                if(f === 'min' ? a.numVal < b.numVal : a.numVal > b.numVal) {\r\n                    args.pop();\r\n                    args.push(a);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns maximum of a set of numbers\r\n         * @returns {Symbol}\r\n         */\r\n        function max() {\r\n            var args = [].slice.call(arguments);\r\n            if(allSame(args))\r\n                return args[0];\r\n            if(allNumbers(args))\r\n                return new Symbol(Math.max.apply(null, args));\r\n            if(Settings.SYMBOLIC_MIN_MAX && allConstants(args))\r\n                return symMinMax('max', args);\r\n            return _.symfunction('max', args);\r\n        }\r\n\r\n        /**\r\n         * Returns minimum of a set of numbers\r\n         * @returns {Symbol}\r\n         */\r\n        function min() {\r\n            var args = [].slice.call(arguments);\r\n            if(allSame(args))\r\n                return args[0];\r\n            if(allNumbers(args))\r\n                return new Symbol(Math.min.apply(null, args));\r\n            if(Settings.SYMBOLIC_MIN_MAX && allConstants(args))\r\n                return symMinMax('min', args);\r\n            return _.symfunction('min', args);\r\n        }\r\n\r\n        /**\r\n         * Returns the sign of a number\r\n         * @param {Symbol} x\r\n         * @returns {Symbol}\r\n         */\r\n        function sign(x) {\r\n            if(x.isConstant(true))\r\n                return new Symbol(Math.sign(evaluate(x)));\r\n            return _.symfunction('sign', arguments);\r\n        }\r\n\r\n        function sort(symbol, opt) {\r\n            opt = opt ? opt.toString() : 'asc';\r\n            var getval = function (e) {\r\n                if(e.group === N)\r\n                    return e.multiplier;\r\n                if(e.group === FN) {\r\n                    if(e.fname === '')\r\n                        return getval(e.args[0]);\r\n                    return e.fname;\r\n                }\r\n                if(e.group === S)\r\n                    return e.power;\r\n\r\n                return e.value;\r\n            };\r\n            var symbols = isVector(symbol) ? symbol.elements : symbol.collectSymbols();\r\n            return new Vector(symbols.sort(function (a, b) {\r\n                var aval = getval(a),\r\n                        bval = getval(b);\r\n                if(opt === 'desc')\r\n                    return bval - aval;\r\n                return aval - bval;\r\n            }));\r\n        }\r\n\r\n        /**\r\n         * The log function\r\n         * @param {Symbol} symbol\r\n         * @param {Symbol} base\r\n         * @returns {Symbol}\r\n         */\r\n        function log(symbol, base) {\r\n\r\n            if(symbol.equals(1)) {\r\n                return new Symbol(0);\r\n            }\r\n\r\n            var retval;\r\n\r\n            if(symbol.fname === SQRT && symbol.multiplier.equals(1)) {\r\n                retval = _.divide(log(symbol.args[0]), new Symbol(2));\r\n\r\n                if(symbol.power.sign() < 0) {\r\n                    retval.negate();\r\n                }\r\n\r\n                // Exit early\r\n                return retval;\r\n            }\r\n\r\n            //log(0) is undefined so complain\r\n            if(symbol.equals(0)) {\r\n                throw new UndefinedError(Settings.LOG + '(0) is undefined!');\r\n            }\r\n\r\n            //deal with imaginary values\r\n            if(symbol.isImaginary()) {\r\n                return complex.evaluate(symbol, Settings.LOG);\r\n            }\r\n\r\n            if(symbol.isConstant() && typeof base !== 'undefined' && base.isConstant()) {\r\n                var log_sym = Math.log(symbol);\r\n                var log_base = Math.log(base);\r\n                retval = new Symbol(log_sym / log_base);\r\n            }\r\n            else if(symbol.group === EX && symbol.power.multiplier.lessThan(0) || symbol.power.toString() === '-1') {\r\n                symbol.power.negate();\r\n                //move the negative outside but keep the positive inside :)\r\n                retval = log(symbol).negate();\r\n            }\r\n            else if(symbol.value === 'e' && symbol.multiplier.equals(1)) {\r\n                var p = symbol.power;\r\n                retval = isSymbol(p) ? p : new Symbol(p);\r\n            }\r\n            else if(symbol.group === FN && symbol.fname === 'exp') {\r\n                var s = symbol.args[0];\r\n                if(symbol.multiplier.equals(1))\r\n                    retval = _.multiply(s, new Symbol(symbol.power));\r\n                else\r\n                    retval = _.symfunction(Settings.LOG, [symbol]);\r\n            }\r\n            else if(Settings.PARSE2NUMBER && isNumericSymbol(symbol)) {\r\n                // Parse for safety.\r\n                symbol = _.parse(symbol);\r\n\r\n                var img_part;\r\n                if(symbol.multiplier.lessThan(0)) {\r\n                    symbol.negate();\r\n                    img_part = _.multiply(new Symbol(Math.PI), new Symbol('i'));\r\n                }\r\n\r\n                retval = new Symbol(Math.log(symbol.multiplier.toDecimal()));\r\n\r\n                if(img_part) {\r\n                    retval = _.add(retval, img_part);\r\n                }\r\n\r\n            }\r\n            else {\r\n                var s;\r\n                if(!symbol.power.equals(1) && !symbol.contains('e')) {\r\n                    s = symbol.group === EX ? symbol.power : new Symbol(symbol.power);\r\n                    symbol.toLinear();\r\n                }\r\n                //log(a,a) = 1 since the base is allowed to be changed.\r\n                //This was pointed out by Happypig375 in issue #280\r\n                if(arguments.length > 1 && allSame(arguments)) {\r\n                    retval = new Symbol(1);\r\n                }\r\n                else {\r\n                    retval = _.symfunction(Settings.LOG, arguments);\r\n                }\r\n\r\n                if(s)\r\n                    retval = _.multiply(s, retval);\r\n            }\r\n\r\n            return retval;\r\n        }\r\n\r\n        /**\r\n         * Round a number up to s decimal places\r\n         * @param {Number} x\r\n         * @param {int} s - the number of decimal places\r\n         * @returns {undefined}\r\n         */\r\n        function round(x, s) {\r\n            var sIsConstant = s && s.isConstant() || typeof s === 'undefined';\r\n            if(x.isConstant() && sIsConstant) {\r\n                var v, e, exp, retval;\r\n                v = x;\r\n                //round the coefficient of then number but not the actual decimal value\r\n                //we know this because a negative number was passed\r\n                if(s && s.lessThan(0)) {\r\n                    s = abs(s);\r\n                    //convert the number to exponential form\r\n                    e = Number(x).toExponential().toString().split('e');\r\n                    //point v to the coefficient of then number\r\n                    v = e[0];\r\n                    //set the expontent\r\n                    exp = e[1];\r\n                }\r\n                //round the number to the requested precision\r\n                retval = new Symbol(nround(v, Number(s || 0)));\r\n                //if there's a exponent then put it back\r\n                return _.multiply(retval, _.pow(new Symbol(10), new Symbol(exp || 0)))\r\n            }\r\n\r\n\r\n            return _.symfunction('round', arguments);\r\n        }\r\n\r\n        /**\r\n         * Gets the quadrant of the trig function\r\n         * @param {Frac} m\r\n         * @returns {Int}\r\n         */\r\n        function getQuadrant(m) {\r\n            var v = m % 2, quadrant;\r\n\r\n            if(v < 0)\r\n                v = 2 + v; //put it in terms of pi\r\n\r\n            if(v >= 0 && v <= 0.5)\r\n                quadrant = 1;\r\n            else if(v > 0.5 && v <= 1)\r\n                quadrant = 2;\r\n            else if(v > 1 && v <= 1.5)\r\n                quadrant = 3;\r\n            else\r\n                quadrant = 4;\r\n            return quadrant;\r\n        }\r\n\r\n        /*\r\n         * Serves as a bridge between numbers and bigNumbers\r\n         * @param {Frac|Number} n\r\n         * @returns {Symbol}\r\n         */\r\n        function bigConvert(n) {\r\n            if(!isFinite(n)) {\r\n                var sign = Math.sign(n);\r\n                var r = new Symbol(String(Math.abs(n)));\r\n                r.multiplier = r.multiplier.multiply(new Frac(sign));\r\n                return r;\r\n            }\r\n            if(isSymbol(n))\r\n                return n;\r\n            if(typeof n === 'number') {\r\n                try {\r\n                    n = Frac.simple(n);\r\n                }\r\n                catch(e) {\r\n                    n = new Frac(n);\r\n                }\r\n            }\r\n\r\n            var symbol = new Symbol(0);\r\n            symbol.multiplier = n;\r\n            return symbol;\r\n        }\r\n        ;\r\n\r\n        function clean(symbol) {\r\n            // handle functions with numeric values\r\n            // handle denominator within denominator\r\n            // handle trig simplifications\r\n            var g = symbol.group, retval;\r\n            //Now let's get to work\r\n            if(g === CP) {\r\n                var num = symbol.getNum(),\r\n                        den = symbol.getDenom() || new Symbol(1),\r\n                        p = Number(symbol.power),\r\n                        factor = new Symbol(1);\r\n                if(Math.abs(p) === 1) {\r\n                    den.each(function (x) {\r\n                        if(x.group === CB) {\r\n                            factor = _.multiply(factor, clean(x.getDenom()));\r\n                        }\r\n                        else if(x.power.lessThan(0)) {\r\n                            factor = _.multiply(factor, clean(x.clone().toUnitMultiplier()));\r\n                        }\r\n                    });\r\n\r\n                    var new_den = new Symbol(0);\r\n                    //now divide out the factor and add to new den\r\n                    den.each(function (x) {\r\n                        new_den = _.add(_.divide(x, factor.clone()), new_den);\r\n                    });\r\n\r\n                    factor.invert(); //invert so it can be added to the top\r\n                    var new_num;\r\n                    if(num.isComposite()) {\r\n                        new_num = new Symbol(0);\r\n                        num.each(function (x) {\r\n                            new_num = _.add(_.multiply(clean(x), factor.clone()), new_num);\r\n                        });\r\n                    }\r\n                    else\r\n                        new_num = _.multiply(factor, num);\r\n\r\n                    retval = _.divide(new_num, new_den);\r\n                }\r\n            }\r\n            else if(g === CB) {\r\n                retval = new Symbol(1);\r\n                symbol.each(function (x) {\r\n                    retval = _.multiply(retval, _.clean(x));\r\n                });\r\n            }\r\n            else if(g === FN) {\r\n                if(symbol.args.length === 1 && symbol.args[0].isConstant())\r\n                    retval = block('PARSE2NUMBER', function () {\r\n                        return _.parse(symbol);\r\n                    }, true);\r\n            }\r\n\r\n            if(!retval)\r\n                retval = symbol;\r\n\r\n            return retval;\r\n        }\r\n\r\n        /**\r\n         * A wrapper for the expand function\r\n         * @param {Symbol} symbol\r\n         * @returns {Symbol}\r\n         */\r\n        function expandall(symbol, opt) {\r\n            opt = opt || {\r\n                expand_denominator: true,\r\n                expand_functions: true\r\n            };\r\n            return expand(symbol, opt);\r\n        }\r\n        /**\r\n         * Expands a symbol\r\n         * @param symbol\r\n         */\r\n        // Old expand\r\n        function expand(symbol, opt) {\r\n            if(Array.isArray(symbol)) {\r\n                return symbol.map(function (x) {\r\n                    return expand(x, opt);\r\n                });\r\n            }\r\n            opt = opt || {};\r\n            //deal with parenthesis\r\n            if(symbol.group === FN && symbol.fname === '') {\r\n                var f = expand(symbol.args[0], opt);\r\n                var x = expand(_.pow(f, _.parse(symbol.power)), opt);\r\n                return _.multiply(_.parse(symbol.multiplier), x).distributeMultiplier();\r\n            }\r\n            // We can expand these groups so no need to waste time. Just return and be done.\r\n            if([N, P, S].indexOf(symbol.group) !== -1) {\r\n                return symbol; //nothing to do\r\n            }\r\n\r\n            var original = symbol.clone();\r\n\r\n            // Set up a try-catch block. If anything goes wrong then we simply return the original symbol\r\n            try {\r\n                // Store the power and multiplier\r\n                var m = symbol.multiplier.toString();\r\n                var p = Number(symbol.power);\r\n                var retval = symbol;\r\n\r\n                // Handle (a+b)^2 | (x+x^2)^2\r\n                if(symbol.isComposite() && isInt(symbol.power) && symbol.power > 0) {\r\n                    var n = p - 1;\r\n                    // Strip the expression of it's multiplier and power. We'll call it f. The power will be p and the multiplier m.\r\n                    var f = new Symbol(0);\r\n\r\n                    symbol.each(function (x) {\r\n                        f = _.add(f, expand(_.parse(x), opt));\r\n                    });\r\n\r\n                    var expanded = _.parse(f);\r\n\r\n                    for(var i = 0; i < n; i++) {\r\n                        expanded = mix(expanded, f, opt);\r\n                    }\r\n\r\n                    retval = _.multiply(_.parse(m), expanded).distributeMultiplier();\r\n                }\r\n                else if(symbol.group === FN && opt.expand_functions === true) {\r\n                    var args = [];\r\n                    // Expand function the arguments\r\n                    symbol.args.forEach(function (x) {\r\n                        args.push(expand(x, opt));\r\n                    });\r\n                    // Put back the power and multiplier\r\n                    retval = _.pow(_.symfunction(symbol.fname, args), _.parse(symbol.power));\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.isComposite() && isInt(symbol.power) && symbol.power < 0 && opt.expand_denominator === true) {\r\n                    // Invert it. Expand it and then re-invert it.\r\n                    symbol = symbol.invert();\r\n                    retval = expand(symbol, opt);\r\n                    retval.invert();\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    var rank = function (s) {\r\n                        switch(s.group) {\r\n                            case CP:\r\n                                return 0;\r\n                            case PL:\r\n                                return 1;\r\n                            case CB:\r\n                                return 2;\r\n                            case FN:\r\n                                return 3;\r\n                            default:\r\n                                return 4;\r\n                        }\r\n                    };\r\n                    // Consider (a+b)(c+d). The result will be (a*c+a*d)+(b*c+b*d).\r\n                    // We start by moving collecting the symbols. We want others>FN>CB>PL>CP\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return rank(b) - rank(a);\r\n                    })\r\n                            // Distribute the power to each symbol and expand\r\n                            .map(function (s) {\r\n                                var x = _.pow(s, _.parse(p));\r\n                                var e = expand(x, opt);\r\n                                return e;\r\n                            });\r\n\r\n                    var f = symbols.pop();\r\n\r\n                    // If the first symbols isn't a composite then we're done\r\n                    if(f.isComposite() && f.isLinear()) {\r\n                        symbols.forEach(function (s) {\r\n                            f = mix(f, s, opt);\r\n                        });\r\n\r\n                        // If f is of group PL or CP then we can expand some more\r\n                        if(f.isComposite()) {\r\n                            if(f.power > 1) {\r\n                                f = expand(_.pow(f, _.parse(f.power)), opt);\r\n                            }\r\n                            // Put back the multiplier\r\n                            retval = _.multiply(_.parse(m), f).distributeMultiplier();\r\n                            ;\r\n                        }\r\n                        else {\r\n                            // Everything is expanded at this point so if it's still a CB\r\n                            // then just return the symbol\r\n                            retval = f;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Just multiply back in the expanded form of each\r\n                        retval = f;\r\n                        symbols.forEach(function (s) {\r\n                            retval = _.multiply(retval, s);\r\n                        });\r\n                        // Put back the multiplier\r\n                        retval = _.multiply(retval, _.parse(m)).distributeMultiplier();\r\n                    }\r\n\r\n                    // TODO: This exists solely as a quick fix for sqrt(11)*sqrt(33) not simplifying.\r\n                    if(retval.group === CB) {\r\n                        retval = _.parse(retval);\r\n                    }\r\n                }\r\n                else {\r\n                    // Otherwise just return the expression\r\n                    retval = symbol;\r\n                }\r\n                // Final cleanup and return\r\n                return retval;\r\n            }\r\n            catch(e) {\r\n                return original;\r\n            }\r\n\r\n            return original;\r\n        }\r\n\r\n        /**\r\n         * Returns an identity matrix of nxn\r\n         * @param {Number} n\r\n         * @returns {Matrix}\r\n         */\r\n        function imatrix(n) {\r\n            return Matrix.identity(n);\r\n        }\r\n\r\n        /**\r\n         * Retrieves and item from a vector\r\n         * @param {Vector} vector\r\n         * @param {Number} index\r\n         * @returns {Vector|Symbol}\r\n         */\r\n        function vecget(vector, index) {\r\n            if(index.isConstant() && isInt(index))\r\n                return vector.elements[index];\r\n            return _.symfunction('vecget', arguments);\r\n        }\r\n\r\n        /**\r\n         * Removes duplicates from a vector\r\n         * @param {Vector} vector\r\n         * @param {Number} tolerance\r\n         * @returns {Vector}\r\n         */\r\n        function vectrim(vector, tolerance) {\r\n            tolerance = typeof tolerance === 'undefined' ? 1e-14 : tolerance;\r\n\r\n            vector = vector.clone();\r\n\r\n            tolerance = Number(tolerance);\r\n            //place algebraic solutions first\r\n            vector.elements.sort(function (a, b) {\r\n                return b.group - a.group;\r\n            });\r\n            //depending on the start point we may have duplicates so we need to clean those up a bit.\r\n            //start by creating an object with the solution and the numeric value. This way we don't destroy algebraic values\r\n            vector.elements = removeDuplicates(vector.elements, function (a, b) {\r\n                var diff = Number(_.subtract(evaluate(a), evaluate(b)).abs());\r\n                return diff <= tolerance;\r\n            });\r\n\r\n            return vector;\r\n        }\r\n\r\n        /**\r\n         * Set a value for a vector at a given index\r\n         * @param {Vector} vector\r\n         * @param {Number} index\r\n         * @param {Symbol} value\r\n         * @returns {Vector}\r\n         */\r\n        function vecset(vector, index, value) {\r\n            if(!index.isConstant)\r\n                return _.symfunction('vecset', arguments);\r\n            vector.elements[index] = value;\r\n            return vector;\r\n        }\r\n\r\n        function matget(matrix, i, j) {\r\n            if(i.isConstant() && j.isConstant())\r\n                return matrix.elements[i][j];\r\n            return _.symfunction('matget', arguments);\r\n        }\r\n\r\n        function matgetrow(matrix, i) {\r\n            if(i.isConstant())\r\n                return new Matrix(matrix.elements[i]);\r\n            return _.symfunction('matgetrow', arguments);\r\n        }\r\n\r\n        function matsetrow(matrix, i, x) {\r\n            //handle symbolics\r\n            if(!i.isConstant())\r\n                return _.symfunction('matsetrow', arguments);\r\n            if(matrix.elements[i].length !== x.elements.length)\r\n                throw new DimensionError('Matrix row must match row dimensions!');\r\n            var M = matrix.clone();\r\n            M.elements[i] = x.clone().elements;\r\n            return M;\r\n        }\r\n\r\n        function matgetcol(matrix, col_index) {\r\n            //handle symbolics\r\n            if(!col_index.isConstant())\r\n                return _.symfunction('matgetcol', arguments);\r\n            col_index = Number(col_index);\r\n            var M = Matrix.fromArray([]);\r\n            matrix.each(function (x, i, j) {\r\n                if(j === col_index) {\r\n                    M.elements.push([x.clone()]);\r\n                }\r\n            });\r\n            return M;\r\n        }\r\n\r\n        function matsetcol(matrix, j, col) {\r\n            //handle symbolics\r\n            if(!j.isConstant())\r\n                return _.symfunction('matsetcol', arguments);\r\n            j = Number(j);\r\n            if(matrix.rows() !== col.elements.length)\r\n                throw new DimensionError('Matrix columns must match number of columns!');\r\n            col.each(function (x, i) {\r\n                matrix.set(i - 1, j, x.elements[0].clone());\r\n            });\r\n            return matrix;\r\n        }\r\n\r\n\r\n        function matset(matrix, i, j, value) {\r\n            matrix.elements[i][j] = value;\r\n            return matrix;\r\n        }\r\n\r\n        //the constructor for vectors\r\n        function vector() {\r\n            return new Vector([].slice.call(arguments));\r\n        }\r\n\r\n        //the constructor for matrices\r\n        function matrix() {\r\n            return Matrix.fromArray(arguments);\r\n        }\r\n\r\n        //the constructor for sets\r\n        function set() {\r\n            return Set.fromArray(arguments);\r\n        }\r\n\r\n        function determinant(symbol) {\r\n            if(isMatrix(symbol)) {\r\n                return symbol.determinant();\r\n            }\r\n            return symbol;\r\n        }\r\n\r\n        function size(symbol) {\r\n            var retval;\r\n            if(isMatrix(symbol))\r\n                retval = [new Symbol(symbol.cols()), new Symbol(symbol.rows())];\r\n            else if(isVector(symbol) || isSet(symbol))\r\n                retval = new Symbol(symbol.elements.length);\r\n            else\r\n                err('size expects a matrix or a vector');\r\n            return retval;\r\n        }\r\n\r\n        function dot(vec1, vec2) {\r\n            if(isVector(vec1) && isVector(vec2))\r\n                return vec1.dot(vec2);\r\n            err('function dot expects 2 vectors');\r\n        }\r\n\r\n        function cross(vec1, vec2) {\r\n            if(isVector(vec1) && isVector(vec2))\r\n                return vec1.cross(vec2);\r\n            err('function cross expects 2 vectors');\r\n        }\r\n\r\n        function transpose(mat) {\r\n            if(isMatrix(mat))\r\n                return mat.transpose();\r\n            err('function transpose expects a matrix');\r\n        }\r\n\r\n        function invert(mat) {\r\n            if(isMatrix(mat))\r\n                return mat.invert();\r\n            err('invert expects a matrix');\r\n        }\r\n\r\n        //basic set functions\r\n        function union(set1, set2) {\r\n            return set1.union(set2);\r\n        }\r\n\r\n        function intersection(set1, set2) {\r\n            return set1.intersection(set2);\r\n        }\r\n\r\n        function contains(set1, e) {\r\n            return set1.contains(e);\r\n        }\r\n\r\n        function difference(set1, set2) {\r\n            return set1.difference(set2);\r\n        }\r\n\r\n        function intersects(set1, set2) {\r\n            return new Symbol(Number(set1.intersects(set2)));\r\n        }\r\n\r\n        function is_subset(set1, set2) {\r\n            return new Symbol(Number(set1.is_subset(set2)));\r\n        }\r\n\r\n        function print() {\r\n            arguments2Array(arguments).map(function (x) {\r\n                console.log(x.toString());\r\n            });\r\n        }\r\n\r\n        function testSQRT(symbol) {\r\n            //wrap the symbol in sqrt. This eliminates one more check down the line.\r\n            if(!isSymbol(symbol.power) && symbol.power.absEquals(0.5)) {\r\n                var sign = symbol.power.sign();\r\n                //don't devide the power directly. Notice the use of toString. This makes it possible\r\n                //to use a bigNumber library in the future\r\n                var retval = sqrt(symbol.group === P ? new Symbol(symbol.value) : symbol.toLinear());\r\n                //place back the sign of the power\r\n                if(sign < 0)\r\n                    retval.invert();\r\n                return retval;\r\n            }\r\n            return symbol;\r\n        }\r\n\r\n        //try to reduce a symbol by pulling its power\r\n        function testPow(symbol) {\r\n            if(symbol.group === P) {\r\n                var v = symbol.value;\r\n\r\n                var fct = primeFactors(v)[0];\r\n\r\n                //safety\r\n                if(!fct) {\r\n                    warn('Unable to compute prime factors. This should not happen. Please review and report.');\r\n                    return symbol;\r\n                }\r\n\r\n                var n = new Frac(Math.log(v) / Math.log(fct)),\r\n                        p = n.multiply(symbol.power);\r\n\r\n                //we don't want a more complex number than before\r\n                if(p.den > symbol.power.den)\r\n                    return symbol;\r\n\r\n                if(isInt(p))\r\n                    symbol = Symbol(Math.pow(fct, p));\r\n                else\r\n                    symbol = new Symbol(fct).setPower(p);\r\n            }\r\n\r\n            return symbol;\r\n        }\r\n\r\n        //Link the functions to the parse so they're available outside of the library.\r\n        //This is strictly for convenience and may be deprecated.\r\n        this.expand = expand;\r\n        this.round = round;\r\n        this.clean = clean;\r\n        this.sqrt = sqrt;\r\n        this.cbrt = cbrt;\r\n        this.abs = abs;\r\n        this.log = log;\r\n        this.rationalize = rationalize;\r\n        this.nthroot = nthroot;\r\n        this.arg = arg;\r\n        this.conjugate = conjugate;\r\n        this.imagpart = imagpart;\r\n        this.realpart = realpart;\r\n\r\n        //TODO:\r\n        //Utilize the function below instead of the linked function\r\n        this.getFunction = function (name) {\r\n            return functions[name][0];\r\n        };\r\n\r\n//Parser.methods ===============================================================\r\n        this.addPreprocessor = function (name, action, order, shift_cells) {\r\n            var names = preprocessors.names;\r\n            var actions = preprocessors.actions;\r\n            if((typeof action !== 'function')) //the person probably forgot to specify a name\r\n                throw new PreprocessorError('Incorrect parameters. Function expected!');\r\n            if(!order) {\r\n                names.push(name);\r\n                actions.push(action);\r\n            }\r\n            else {\r\n                if(shift_cells) {\r\n                    names.splice(order, 0, name);\r\n                    actions.splice(order, 0, action);\r\n                }\r\n                else {\r\n                    names[order] = name;\r\n                    actions[order] = action;\r\n                }\r\n            }\r\n        };\r\n\r\n        this.getPreprocessors = function () {\r\n            var preprocessors = {};\r\n            for(var i = 0, l = preprocessors.names.length; i < l; i++) {\r\n                var name = preprocessors.names[i];\r\n                preprocessors[name] = {\r\n                    order: i,\r\n                    action: preprocessors.actions[i]\r\n                };\r\n            }\r\n            return preprocessors;\r\n        };\r\n\r\n        this.removePreprocessor = function (name, shift_cells) {\r\n            var i = preprocessors.names.indexOf(name);\r\n            if(shift_cells) {\r\n                remove(preprocessors.names, i);\r\n                remove(preprocessors.actions, i);\r\n            }\r\n            else {\r\n                preprocessors.names[i] = undefined;\r\n                preprocessors.actions[i] = undefined;\r\n            }\r\n        };\r\n\r\n        //The loader for functions which are not part of Math2\r\n        this.mapped_function = function () {\r\n            var subs = {},\r\n                    params = this.params;\r\n\r\n            for(var i = 0; i < params.length; i++) {\r\n                subs[params[i]] = String(arguments[i]);\r\n            }\r\n\r\n            return _.parse(this.body, subs);\r\n        };\r\n        /**\r\n         * Adds two symbols\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.add = function (a, b) {\r\n            var aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b);\r\n            //we're dealing with two symbols\r\n            if(aIsSymbol && bIsSymbol) {\r\n                //forward the adding of symbols with units to the Unit module\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.add(a, b);\r\n                }\r\n                //handle Infinity\r\n                //https://www.encyclopediaofmath.org/index.php/Infinity\r\n                if(a.isInfinity || b.isInfinity) {\r\n                    var aneg = a.multiplier.lessThan(0),\r\n                            bneg = b.multiplier.lessThan(0);\r\n\r\n                    if(a.isInfinity && b.isInfinity && aneg !== bneg) {\r\n                        throw new UndefinedError('(' + a + ')+(' + b + ') is not defined!');\r\n                    }\r\n\r\n                    var inf = Symbol.infinity();\r\n                    if(bneg)\r\n                        inf.negate();\r\n                    return inf;\r\n                }\r\n\r\n                if(a.isComposite() && a.isLinear() && b.isComposite() && b.isLinear()) {\r\n                    a.distributeMultiplier();\r\n                    b.distributeMultiplier();\r\n                    // Fix for issue #606\r\n                    if(b.length > a.length && a.group === b.group) {\r\n                        [a, b] = [b, a];\r\n                    }\r\n                }\r\n                \r\n                //no need to waste time on zeroes\r\n                if(a.multiplier.equals(0))\r\n                    return b;\r\n                if(b.multiplier.equals(0))\r\n                    return a;\r\n\r\n                if(a.isConstant() && b.isConstant() && Settings.PARSE2NUMBER) {\r\n                    var result = new Symbol(a.multiplier.add(b.multiplier).toDecimal(Settings.PRECISION));\r\n                    return result;\r\n                }\r\n\r\n                var g1 = a.group,\r\n                        g2 = b.group,\r\n                        ap = a.power.toString(),\r\n                        bp = b.power.toString();\r\n\r\n                //always keep the greater group on the left.\r\n                if(g1 < g2 || (g1 === g2 && ap > bp && bp > 0)) {\r\n                    return this.add(b, a);\r\n                }\r\n\r\n                /*note to self: Please don't forget about this dilemma ever again. In this model PL and CB goes crazy\r\n                 * because it doesn't know which one to prioritize. */\r\n                //correction to PL dilemma\r\n                if(g1 === CB && g2 === PL && a.value === b.value) {\r\n                    //swap\r\n                    var t = a;\r\n                    a = b;\r\n                    b = t;\r\n                    g1 = a.group;\r\n                    g2 = b.group;\r\n                    ap = a.power.toString();\r\n                    bp = b.power.toString();\r\n                }\r\n\r\n                var powEQ = ap === bp,\r\n                        v1 = a.value,\r\n                        v2 = b.value,\r\n                        aIsComposite = a.isComposite(),\r\n                        bIsComposite = b.isComposite(),\r\n                        h1, h2, result;\r\n\r\n                if(aIsComposite)\r\n                    h1 = text(a, 'hash');\r\n                if(bIsComposite)\r\n                    h2 = text(b, 'hash');\r\n\r\n                if(g1 === CP && g2 === CP && b.isLinear() && !a.isLinear() && h1 !== h2) {\r\n                    return this.add(b, a);\r\n                }\r\n\r\n                //PL & PL should compare hashes and not values e.g. compare x+x^2 with x+x^3 and not x with x\r\n                if(g1 === PL && g2 === PL) {\r\n                    v1 = h1;\r\n                    v2 = h2;\r\n                }\r\n\r\n                var PN = g1 === P && g2 === N,\r\n                        PNEQ = a.value === b.multiplier.toString(),\r\n                        valEQ = (v1 === v2 || h1 === h2 && h1 !== undefined || (PN && PNEQ));\r\n\r\n                //equal values, equal powers\r\n                if(valEQ && powEQ && g1 === g2) {\r\n                    //make sure to convert N to something P can work with\r\n                    if(PN)\r\n                        b = b.convert(P);//CL\r\n\r\n                    //handle PL\r\n                    if(g1 === PL && (g2 === S || g2 === P)) {\r\n                        a.distributeMultiplier();\r\n                        result = a.attach(b);\r\n                    }\r\n                    else {\r\n                        result = a;//CL\r\n                        if(a.multiplier.isOne() && b.multiplier.isOne() && g1 === CP && a.isLinear() && b.isLinear()) {\r\n                            for(var s in b.symbols) {\r\n                                var x = b.symbols[s];\r\n                                result.attach(x);\r\n                            }\r\n                        }\r\n                        else\r\n                            result.multiplier = result.multiplier.add(b.multiplier);\r\n                    }\r\n                }\r\n                //equal values uneven powers\r\n                else if(valEQ && g1 !== PL) {\r\n                    //break the tie for e.g. (x+1)+((x+1)^2+(x+1)^3)\r\n                    if(g1 === CP && g2 === PL) {\r\n                        b.insert(a, 'add');\r\n                        result = b;\r\n                    }\r\n                    else {\r\n                        result = Symbol.shell(PL).attach([a, b]);\r\n                        //update the hash\r\n                        result.value = g1 === PL ? h1 : v1;\r\n                    }\r\n                }\r\n                else if(aIsComposite && a.isLinear()) {\r\n                    var canIterate = g1 === g2,\r\n                            bothPL = g1 === PL && g2 === PL;\r\n\r\n                    //we can only iterate group PL if they values match\r\n                    if(bothPL)\r\n                        canIterate = a.value === b.value;\r\n                    //distribute the multiplier over the entire symbol\r\n                    a.distributeMultiplier();\r\n\r\n                    if(b.isComposite() && b.isLinear() && canIterate) {\r\n                        b.distributeMultiplier();\r\n                        //CL\r\n                        for(var s in b.symbols) {\r\n                            var x = b.symbols[s];\r\n                            a.attach(x);\r\n                        }\r\n                        result = a;\r\n                    }\r\n                    //handle cases like 2*(x+x^2)^2+2*(x+x^2)^3+4*(x+x^2)^2\r\n                    else if(bothPL && a.value !== h2 || g1 === PL && !valEQ) {\r\n                        result = Symbol.shell(CP).attach([a, b]);\r\n                        result.updateHash();\r\n\r\n                    }\r\n                    else {\r\n                        result = a.attach(b);\r\n                    }\r\n                }\r\n                else {\r\n                    if(g1 === FN && a.fname === SQRT && g2 !== EX && b.power.equals(0.5)) {\r\n                        var m = b.multiplier.clone();\r\n                        b = sqrt(b.toUnitMultiplier().toLinear());\r\n                        b.multiplier = m;\r\n                    }\r\n                    //fix for issue #3 and #159\r\n                    if(a.length === 2 && b.length === 2 && even(a.power) && even(b.power)) {\r\n                        result = _.add(expand(a), expand(b));\r\n                    }\r\n                    else {\r\n                        result = Symbol.shell(CP).attach([a, b]);\r\n                        result.updateHash();\r\n                    }\r\n                }\r\n\r\n                if(result.multiplier.equals(0))\r\n                    result = new Symbol(0);\r\n\r\n                //make sure to remove unnecessary wraps\r\n                if(result.length === 1) {\r\n                    var m = result.multiplier;\r\n                    result = firstObject(result.symbols);\r\n                    result.multiplier = result.multiplier.multiply(m);\r\n                }\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                //keep symbols to the right\r\n                if(bIsSymbol && !aIsSymbol) {\r\n                    var t = a;\r\n                    a = b;\r\n                    b = t; //swap\r\n                    t = bIsSymbol;\r\n                    bIsSymbol = aIsSymbol;\r\n                    aIsSymbol = t;\r\n                }\r\n\r\n                var bIsMatrix = isMatrix(b);\r\n\r\n                if(aIsSymbol && bIsMatrix) {\r\n                    var M = new Matrix();\r\n                    b.eachElement(function (e, i, j) {\r\n                        M.set(i, j, _.add(a.clone(), e));\r\n                    });\r\n\r\n                    b = M\r\n                }\r\n                else {\r\n                    if(isMatrix(a) && bIsMatrix) {\r\n                        b = a.add(b);\r\n                    }\r\n                    else if(aIsSymbol && isVector(b)) {\r\n                        b.each(function (x, i) {\r\n                            i--;\r\n                            b.elements[i] = _.add(a.clone(), b.elements[i]);\r\n                        });\r\n                    }\r\n                    else {\r\n                        if(isVector(a) && isVector(b)) {\r\n                            b.each(function (x, i) {\r\n                                i--;\r\n                                b.elements[i] = _.add(a.elements[i], b.elements[i]);\r\n                            });\r\n                        }\r\n                        else if(isVector(a) && isMatrix(b)) {\r\n                            //try to convert a to a matrix\r\n                            return _.add(b, a);\r\n                        }\r\n                        else if(isMatrix(a) && isVector(b)) {\r\n                            if(b.elements.length === a.rows()) {\r\n                                var M = new Matrix(), l = a.cols();\r\n                                b.each(function (e, i) {\r\n                                    var row = [];\r\n                                    for(var j = 0; j < l; j++) {\r\n                                        row.push(_.add(a.elements[i - 1][j].clone(), e.clone()));\r\n                                    }\r\n                                    M.elements.push(row);\r\n                                });\r\n                                return M;\r\n                            }\r\n                            else\r\n                                err('Dimensions must match!');\r\n                        }\r\n                    }\r\n                }\r\n                return b;\r\n            }\r\n\r\n        };\r\n        /**\r\n         * Gets called when the parser finds the - operator. Not the prefix operator. See this.add\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.subtract = function (a, b) {\r\n            var aIsSymbol = aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b), t;\r\n\r\n            if(aIsSymbol && bIsSymbol) {\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.subtract(a, b);\r\n                }\r\n                return this.add(a, b.negate());\r\n            }\r\n            else {\r\n                if(bIsSymbol && isVector(a)) {\r\n                    b = a.map(function (x) {\r\n                        return _.subtract(x, b.clone());\r\n                    });\r\n                }\r\n                else if(aIsSymbol && isVector(b)) {\r\n                    b = b.map(function (x) {\r\n                        return _.subtract(a.clone(), x);\r\n                    });\r\n                }\r\n                else if(isVector(a) && isVector(b)) {\r\n                    if(a.dimensions() === b.dimensions())\r\n                        b = a.subtract(b);\r\n                    else\r\n                        _.error('Unable to subtract vectors. Dimensions do not match.');\r\n                }\r\n                else if(isMatrix(a) && isVector(b)) {\r\n                    if(b.elements.length === a.rows()) {\r\n                        var M = new Matrix(), l = a.cols();\r\n                        b.each(function (e, i) {\r\n                            var row = [];\r\n                            for(var j = 0; j < l; j++) {\r\n                                row.push(_.subtract(a.elements[i - 1][j].clone(), e.clone()));\r\n                            }\r\n                            M.elements.push(row);\r\n                        });\r\n                        return M;\r\n                    }\r\n                    else\r\n                        err('Dimensions must match!');\r\n                }\r\n                else if(isVector(a) && isMatrix(b)) {\r\n                    var M = b.clone().negate();\r\n                    return _.add(M, a);\r\n                }\r\n                else if(isMatrix(a) && isMatrix(b)) {\r\n                    b = a.subtract(b);\r\n                }\r\n                else if(isMatrix(a) && bIsSymbol) {\r\n                    var M = new Matrix();\r\n                    a.each(function (x, i, j) {\r\n                        M.set(i, j, _.subtract(x, b.clone()));\r\n                    });\r\n                    b = M;\r\n                }\r\n                else if(aIsSymbol && isMatrix(b)) {\r\n                    var M = new Matrix();\r\n                    b.each(function (x, i, j) {\r\n                        M.set(i, j, _.subtract(a.clone(), x));\r\n                    });\r\n                    b = M;\r\n                }\r\n                return b;\r\n            }\r\n        };\r\n        /**\r\n         * Gets called when the parser finds the * operator. See this.add\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.multiply = function (a, b) {\r\n            var aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b);\r\n            //we're dealing with function assignment here\r\n            if(aIsSymbol && b instanceof Collection) {\r\n                b.elements.push(a);\r\n                return b;\r\n            }\r\n            if(aIsSymbol && bIsSymbol) {\r\n                //if it has a unit then add it and return it right away.\r\n                if(b.isUnit) {\r\n                    var result = a.clone();\r\n                    a.unit = b;\r\n                    return result;\r\n                }\r\n                \r\n                //if it has units then just forward that problem to the unit module\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.multiply(a, b);\r\n                }\r\n\r\n                //handle Infinty\r\n                if(a.isInfinity || b.isInfinity) {\r\n                    if(a.equals(0) || b.equals(0))\r\n                        throw new UndefinedError(a + '*' + b + ' is undefined!');\r\n                    //x/infinity\r\n                    if(b.power.lessThan(0)) {\r\n                        if(!a.isInfinity) {\r\n                            return new Symbol(0);\r\n                        }\r\n                        else {\r\n                            throw new UndefinedError('Infinity/Infinity is not defined!');\r\n                        }\r\n                    }\r\n\r\n                    var sign = a.multiplier.multiply(b.multiplier).sign(),\r\n                            inf = Symbol.infinity();\r\n                    if(a.isConstant() || b.isConstant() || (a.isInfinity && b.isInfinity)) {\r\n                        if(sign < 0)\r\n                            inf.negate();\r\n\r\n                        return inf;\r\n                    }\r\n                }\r\n                //the quickies\r\n                if(a.isConstant() && b.isConstant() && Settings.PARSE2NUMBER) {\r\n                    var t = new bigDec(a.multiplier.toDecimal()).times(new bigDec(b.multiplier.toDecimal())).toFixed();\r\n                    var retval = new Symbol(t);\r\n                    return retval;\r\n                }\r\n\r\n                //don't waste time\r\n                if(a.isOne()) {\r\n                    return b.clone();\r\n                }\r\n                if(b.isOne()) {\r\n                    return a.clone();\r\n                }\r\n\r\n                if(a.multiplier.equals(0) || b.multiplier.equals(0))\r\n                    return new Symbol(0);\r\n\r\n                if(b.group > a.group && !(b.group === CP))\r\n                    return this.multiply(b, a);\r\n                //correction for PL/CB dilemma\r\n                if(a.group === CB && b.group === PL && a.value === b.value) {\r\n                    var t = a;\r\n                    a = b;\r\n                    b = t;//swap\r\n                }\r\n\r\n                var g1 = a.group,\r\n                        g2 = b.group,\r\n                        bnum = b.multiplier.num,\r\n                        bden = b.multiplier.den;\r\n\r\n                if(g1 === FN && a.fname === SQRT && !b.isConstant() && a.args[0].value === b.value && !a.args[0].multiplier.lessThan(0)) {\r\n                    //unwrap sqrt\r\n                    var a_pow = a.power;\r\n                    var a_multiplier = _.parse(a.multiplier);\r\n                    a = _.multiply(a_multiplier, a.args[0].clone());\r\n                    a.setPower(new Frac(0.5).multiply(a_pow));\r\n                    g1 = a.group;\r\n                }\r\n                //simplify n/sqrt(n). Being very specific\r\n                else if(g1 === FN && a.fname === SQRT && a.multiplier.equals(1) && a.power.equals(-1) && b.isConstant() && a.args[0].equals(b)) {\r\n                    a = _.symfunction(SQRT, [b.clone()]);\r\n                    b = new Symbol(1);\r\n                }\r\n                ;\r\n\r\n                var v1 = a.value,\r\n                        v2 = b.value,\r\n                        sign = new Frac(a.sign()),\r\n                        //since P is just a morphed version of N we need to see if they relate\r\n                        ONN = (g1 === P && g2 === N && b.multiplier.equals(a.value)),\r\n                        //don't multiply the multiplier of b since that's equal to the value of a\r\n                        m = ONN ? new Frac(1).multiply(a.multiplier).abs() : a.multiplier.multiply(b.multiplier).abs(),\r\n                        result = a.clone().toUnitMultiplier();\r\n                b = b.clone().toUnitMultiplier(true);\r\n\r\n                //further simplification of sqrt\r\n                if(g1 === FN && g2 === FN) {\r\n                    var u = a.args[0].clone();\r\n                    var v = b.args[0].clone();\r\n                    if(a.fname === SQRT && b.fname === SQRT && a.isLinear() && b.isLinear()) {\r\n\r\n                        var q = _.divide(u, v).invert();\r\n                        if(q.gt(1) && isInt(q)) {\r\n                            //b contains a factor a which can be moved to a\r\n                            result = _.multiply(a.args[0].clone(), sqrt(q.clone()));\r\n                            b = new Symbol(1);\r\n                        }\r\n                    }\r\n                    //simplify factorial but only if\r\n                    //1 - It's division so b will have a negative power\r\n                    //2 - We're not dealing with factorials of numbers\r\n                    else if(a.fname === FACTORIAL && b.fname === FACTORIAL && !u.isConstant() && !v.isConstant() && b.power < 0) {\r\n                        //assume that n = positive\r\n                        var d = _.subtract(u.clone(), v.clone());\r\n\r\n                        //if it's not numeric then we don't know if we can simplify so just return\r\n                        if(d.isConstant()) {\r\n\r\n                            //there will never be a case where d == 0 since this will already have\r\n                            //been handled at the beginning of this function\r\n                            t = new Symbol(1);\r\n                            if(d < 0) {\r\n                                //If d is negative then the numerator is larger so expand that\r\n                                for(var i = 0, n = Math.abs(d); i <= n; i++) {\r\n                                    var s = _.add(u.clone(), new Symbol(i));\r\n                                    t = _.multiply(t, s);\r\n                                }\r\n\r\n                                result = _.multiply(_.pow(u, new Symbol(a.power)), _.pow(t, new Symbol(b.power)));\r\n\r\n                                b = new Symbol(1);\r\n                            }\r\n                            else {\r\n                                //Otherwise the denominator is larger so expand that\r\n                                for(var i = 0, n = Math.abs(d); i <= n; i++) {\r\n                                    var s = _.add(v.clone(), new Symbol(i));\r\n                                    t = _.multiply(t, s);\r\n                                }\r\n\r\n                                result = _.multiply(_.pow(t, new Symbol(a.power)), _.pow(v, new Symbol(b.power)));\r\n\r\n                                b = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                //if both are PL then their hashes have to match\r\n                if(v1 === v2 && g1 === PL && g1 === g2) {\r\n                    v1 = a.text('hash');\r\n                    v2 = b.text('hash');\r\n                }\r\n\r\n                //same issue with (x^2+1)^x*(x^2+1)\r\n                //EX needs an exception when multiplying because it needs to recognize\r\n                //that (x+x^2)^x has the same hash as (x+x^2). The latter is kept as x\r\n                if(g2 === EX && b.previousGroup === PL && g1 === PL) {\r\n                    v1 = text(a, 'hash', EX);\r\n                }\r\n\r\n                if((v1 === v2 || ONN) && !(g1 === PL && (g2 === S || g2 === P || g2 === FN)) && !(g1 === PL && g2 === CB)) {\r\n                    var p1 = a.power,\r\n                            p2 = b.power,\r\n                            isSymbolP1 = isSymbol(p1),\r\n                            isSymbolP2 = isSymbol(p2),\r\n                            toEX = (isSymbolP1 || isSymbolP2);\r\n                    //TODO: this needs cleaning up\r\n                    if(g1 === PL && g2 !== PL && b.previousGroup !== PL && p1.equals(1)) {\r\n                        result = new Symbol(0);\r\n                        a.each(function (x) {\r\n                            result = _.add(result, _.multiply(x, b.clone()));\r\n                        }, true);\r\n                    }\r\n                    else {\r\n                        //add the powers\r\n                        result.power = toEX ? _.add(\r\n                                !(isSymbol(p1)) ? new Symbol(p1) : p1,\r\n                                !(isSymbol(p2)) ? new Symbol(p2) : p2\r\n                                ) : (g1 === N /*don't add powers for N*/ ? p1 : p1.add(p2));\r\n\r\n                        //eliminate zero power values and convert them to numbers\r\n                        if(result.power.equals(0))\r\n                            result = result.convert(N);\r\n\r\n                        //properly convert to EX\r\n                        if(toEX)\r\n                            result.convert(EX);\r\n\r\n                        //take care of imaginaries\r\n                        if(a.imaginary && b.imaginary) {\r\n                            var isEven = even(result.power % 2);\r\n                            if(isEven) {\r\n                                result = new Symbol(1);\r\n                                m.negate();\r\n                            }\r\n                        }\r\n\r\n                        //cleanup: this causes the LaTeX generator to get confused as to how to render the symbol\r\n                        if(result.group !== EX && result.previousGroup)\r\n                            result.previousGroup = undefined;\r\n                        //the sign for b is floating around. Remember we are assuming that the odd variable will carry\r\n                        //the sign but this isn't true if they're equals symbols\r\n                        result.multiplier = result.multiplier.multiply(b.multiplier);\r\n                    }\r\n                }\r\n                else if(g1 === CB && a.isLinear()) {\r\n                    if(g2 === CB)\r\n                        b.distributeExponent();\r\n                    if(g2 === CB && b.isLinear()) {\r\n                        for(var s in b.symbols) {\r\n                            var x = b.symbols[s];\r\n                            result = result.combine(x);\r\n                        }\r\n                        result.multiplier = result.multiplier.multiply(b.multiplier);\r\n                    }\r\n                    else {\r\n                        result.combine(b);\r\n                    }\r\n                }\r\n                else {\r\n                    //the multiplier was already handled so nothing left to do\r\n                    if(g1 !== N) {\r\n                        if(g1 === CB) {\r\n                            result.distributeExponent();\r\n                            result.combine(b);\r\n                        }\r\n                        else if(!b.isOne()) {\r\n                            var bm = b.multiplier.clone();\r\n                            b.toUnitMultiplier();\r\n                            result = Symbol.shell(CB).combine([result, b]);\r\n                            //transfer the multiplier to the outside\r\n                            result.multiplier = result.multiplier.multiply(bm);\r\n                        }\r\n                    }\r\n                    else {\r\n                        result = b.clone().toUnitMultiplier();\r\n                    }\r\n                }\r\n\r\n                if(result.group === P) {\r\n                    var logV = Math.log(result.value),\r\n                            n1 = Math.log(bnum) / logV,\r\n                            n2 = Math.log(bden) / logV,\r\n                            ndiv = m.num / bnum,\r\n                            ddiv = m.den / bden;\r\n                    //we don't want to divide by zero no do we? Strange things happen.\r\n                    if(n1 !== 0 && isInt(n1) && isInt(ndiv)) {\r\n                        result.power = result.power.add(new Frac(n1));\r\n                        m.num /= bnum; //BigInt? Keep that in mind for the future.\r\n                    }\r\n                    if(n2 !== 0 && isInt(n2) && isInt(ddiv)) {\r\n                        result.power = result.power.subtract(new Frac(n2));\r\n                        m.den /= bden; //BigInt? Keep that in mind for the future.\r\n                    }\r\n                }\r\n\r\n                //unpack CB if length is only one\r\n                if(result.length === 1) {\r\n                    var t = result.multiplier;\r\n                    //transfer the multiplier\r\n                    result = firstObject(result.symbols);\r\n                    result.multiplier = result.multiplier.multiply(t);\r\n                }\r\n\r\n                //reduce square root\r\n                var ps = result.power.toString();\r\n                if(even(ps) && result.fname === SQRT) {\r\n                    //grab the sign of the symbol\r\n                    sign = sign * result.sign();\r\n                    var p = result.power;\r\n                    result = result.args[0];\r\n                    result = _.multiply(new Symbol(m), _.pow(result, new Symbol(p.divide(new Frac(2)))));\r\n                    //flip it back to the correct sign\r\n                    if(sign < 0)\r\n                        result.negate()\r\n                }\r\n                else {\r\n                    result.multiplier = result.multiplier.multiply(m).multiply(sign);\r\n                    if(result.group === CP && result.isImaginary())\r\n                        result.distributeMultiplier();\r\n                }\r\n\r\n                //back convert group P to a simpler group N if possible\r\n                if(result.group === P && isInt(result.power.toDecimal()))\r\n                    result = result.convert(N);\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                //****** Matrices & Vector *****//\r\n                if(bIsSymbol && !aIsSymbol) { //keep symbols to the right\r\n                    t = a;\r\n                    a = b;\r\n                    b = t; //swap\r\n                    t = bIsSymbol;\r\n                    bIsSymbol = aIsSymbol;\r\n                    aIsSymbol = t;\r\n                }\r\n\r\n                var isMatrixB = isMatrix(b), isMatrixA = isMatrix(a);\r\n                if(aIsSymbol && isMatrixB) {\r\n                    var M = new Matrix();\r\n                    b.eachElement(function (e, i, j) {\r\n                        M.set(i, j, _.multiply(a.clone(), e));\r\n                    });\r\n\r\n                    b = M;\r\n                }\r\n                else {\r\n                    if(isMatrixA && isMatrixB) {\r\n                        b = a.multiply(b);\r\n                    }\r\n                    else if(aIsSymbol && isVector(b)) {\r\n                        b.each(function (x, i) {\r\n                            i--;\r\n                            b.elements[i] = _.multiply(a.clone(), b.elements[i]);\r\n                        });\r\n                    }\r\n                    else {\r\n                        if(isVector(a) && isVector(b)) {\r\n                            b.each(function (x, i) {\r\n                                i--;\r\n                                b.elements[i] = _.multiply(a.elements[i], b.elements[i]);\r\n                            });\r\n                        }\r\n                        else if(isVector(a) && isMatrix(b)) {\r\n                            //try to convert a to a matrix\r\n                            return this.multiply(b, a);\r\n                        }\r\n                        else if(isMatrix(a) && isVector(b)) {\r\n                            if(b.elements.length === a.rows()) {\r\n                                var M = new Matrix(), l = a.cols();\r\n                                b.each(function (e, i) {\r\n                                    var row = [];\r\n                                    for(var j = 0; j < l; j++) {\r\n                                        row.push(_.multiply(a.elements[i - 1][j].clone(), e.clone()));\r\n                                    }\r\n                                    M.elements.push(row);\r\n                                });\r\n                                return M;\r\n                            }\r\n                            else\r\n                                err('Dimensions must match!');\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return b;\r\n            }\r\n        };\r\n        /**\r\n         * Gets called when the parser finds the / operator. See this.add\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.divide = function (a, b) {\r\n            var aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b);\r\n\r\n            if(aIsSymbol && bIsSymbol) {\r\n                //forward to Unit division\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.divide(a, b);\r\n                }\r\n                var result;\r\n                if(b.equals(0))\r\n                    throw new DivisionByZero('Division by zero not allowed!');\r\n\r\n                if(a.isConstant() && b.isConstant()) {\r\n                    result = a.clone();\r\n                    result.multiplier = result.multiplier.divide(b.multiplier);\r\n                }\r\n                else {\r\n                    b.invert();\r\n                    result = _.multiply(a, b);\r\n                }\r\n                return result;\r\n            }\r\n            else {\r\n                //******* Vectors & Matrices *********//\r\n                var isVectorA = isVector(a), isVectorB = isVector(b);\r\n                if(aIsSymbol && isVectorB) {\r\n                    b = b.map(function (x) {\r\n                        return _.divide(a.clone(), x);\r\n                    });\r\n                }\r\n                else if(isVectorA && bIsSymbol) {\r\n                    b = a.map(function (x) {\r\n                        return _.divide(x, b.clone());\r\n                    });\r\n                }\r\n                else if(isVectorA && isVectorB) {\r\n                    if(a.dimensions() === b.dimensions()) {\r\n                        b = b.map(function (x, i) {\r\n                            return _.divide(a.elements[--i], x);\r\n                        });\r\n                    }\r\n                    else\r\n                        _.error('Cannot divide vectors. Dimensions do not match!');\r\n                }\r\n                else {\r\n                    var isMatrixA = isMatrix(a), isMatrixB = isMatrix(b);\r\n                    if(isMatrixA && bIsSymbol) {\r\n                        var M = new Matrix();\r\n                        a.eachElement(function (x, i, j) {\r\n                            M.set(i, j, _.divide(x, b.clone()));\r\n                        });\r\n                        b = M;\r\n                    }\r\n                    else if(aIsSymbol && isMatrixB) {\r\n                        var M = new Matrix();\r\n                        b.eachElement(function (x, i, j) {\r\n                            M.set(i, j, _.divide(a.clone(), x));\r\n                        });\r\n                        b = M;\r\n                    }\r\n                    else if(isMatrixA && isMatrixB) {\r\n                        var M = new Matrix();\r\n                        if(a.rows() === b.rows() && a.cols() === b.cols()) {\r\n                            a.eachElement(function (x, i, j) {\r\n                                M.set(i, j, _.divide(x, b.elements[i][j]));\r\n                            });\r\n                            b = M;\r\n                        }\r\n                        else {\r\n                            _.error('Dimensions do not match!');\r\n                        }\r\n                    }\r\n                    else if(isMatrixA && isVectorB) {\r\n                        if(a.cols() === b.dimensions()) {\r\n                            var M = new Matrix();\r\n                            a.eachElement(function (x, i, j) {\r\n                                M.set(i, j, _.divide(x, b.elements[i].clone()));\r\n                            });\r\n                            b = M;\r\n                        }\r\n                        else {\r\n                            _.error('Unable to divide matrix by vector.');\r\n                        }\r\n                    }\r\n                }\r\n                return b;\r\n            }\r\n        };\r\n        /**\r\n         * Gets called when the parser finds the ^ operator. See this.add\r\n         * @param {Symbol} a\r\n         * @param {Symbol} b\r\n         * @returns {Symbol}\r\n         */\r\n        this.pow = function (a, b) {\r\n            var aIsSymbol = isSymbol(a),\r\n                    bIsSymbol = isSymbol(b);\r\n            if(aIsSymbol && bIsSymbol) {\r\n                //it has units then it's the Unit module's problem\r\n                if(a.unit || b.unit) {\r\n                    return _.Unit.pow(a, b);\r\n                }\r\n                \r\n                // Handle abs\r\n                if(a.group === FN && a.fname === ABS && even(b)) {\r\n                    var m = a.multiplier.clone();\r\n                    var raised = _.pow(a.args[0], b);\r\n                    raised.multiplier = m;\r\n                    return raised;\r\n                }\r\n                \r\n                // Handle infinity\r\n                if(a.isInfinity || b.isInfinity) {\r\n                    if(a.isInfinity && b.isInfinity)\r\n                        throw new UndefinedError('(' + a + ')^(' + b + ') is undefined!');\r\n\r\n                    if(a.isConstant() && b.isInfinity) {\r\n                        if(a.equals(0)) {\r\n                            if(b.lessThan(0))\r\n                                throw new UndefinedError('0^Infinity is undefined!');\r\n                            return new Symbol(0);\r\n                        }\r\n                        if(a.equals(1))\r\n                            throw new UndefinedError('1^' + b.toString() + ' is undefined!');\r\n                        //a^-oo\r\n                        if(b.lessThan(0))\r\n                            return new Symbol(0);\r\n                        //a^oo\r\n                        if(!a.lessThan(0))\r\n                            return Symbol.infinity();\r\n                    }\r\n\r\n                    if(a.isInfinity && b.isConstant()) {\r\n                        if(b.equals(0))\r\n                            throw new UndefinedError(a + '^0 is undefined!');\r\n                        if(b.lessThan(0))\r\n                            return new Symbol(0);\r\n                        return _.multiply(Symbol.infinity(), _.pow(new Symbol(a.sign()), b.clone()));\r\n                    }\r\n                }\r\n\r\n                var aIsZero = a.equals(0);\r\n                var bIsZero = b.equals(0);\r\n                if(aIsZero && bIsZero)\r\n                    throw new UndefinedError('0^0 is undefined!');\r\n\r\n                // Return 0 right away if possible\r\n                if(aIsZero && b.isConstant() && b.multiplier.greaterThan(0))\r\n                    return new Symbol(0);\r\n\r\n                if(bIsZero)\r\n                    return new Symbol(1);\r\n\r\n                var bIsConstant = b.isConstant(),\r\n                        aIsConstant = a.isConstant(),\r\n                        bIsInt = b.isInteger(),\r\n                        m = a.multiplier,\r\n                        result = a.clone();\r\n\r\n                // 0^0, 1/0, etc. Complain.\r\n                if(aIsConstant && bIsConstant && a.equals(0) && b.lessThan(0))\r\n                    throw new UndefinedError('Division by zero is not allowed!');\r\n\r\n                // Compute imaginary numbers right away\r\n                if(Settings.PARSE2NUMBER && aIsConstant && bIsConstant && a.sign() < 0 && evenFraction(b)) {\r\n                    var k, re, im;\r\n                    k = Math.PI * b;\r\n                    re = new Symbol(Math.cos(k));\r\n                    im = _.multiply(Symbol.imaginary(), new Symbol(Math.sin(k)));\r\n                    return _.add(re, im);\r\n                }\r\n\r\n                // Imaginary number under negative nthroot or to the n\r\n                if(Settings.PARSE2NUMBER && a.isImaginary() && bIsConstant && isInt(b) && !b.lessThan(0)) {\r\n                    var re, im, r, theta, nre, nim, phi;\r\n                    re = a.realpart();\r\n                    im = a.imagpart();\r\n                    if(re.isConstant('all') && im.isConstant('all')) {\r\n                        phi = Settings.USE_BIG ? Symbol(bigDec.atan2(i.multiplier.toDecimal(), r.multiplier.toDecimal()).times(b.toString())) : Math.atan2(im, re) * b;\r\n                        theta = new Symbol(phi);\r\n                        r = _.pow(Symbol.hyp(re, im), b);\r\n                        nre = _.multiply(r.clone(), _.trig.cos(theta.clone()));\r\n                        nim = _.multiply(r, _.trig.sin(theta));\r\n                        return _.add(nre, _.multiply(Symbol.imaginary(), nim));\r\n                    }\r\n                }\r\n\r\n                // Take care of the symbolic part\r\n                result.toUnitMultiplier();\r\n                //simpifly sqrt\r\n                if(result.group === FN && result.fname === SQRT && !bIsConstant) {\r\n                    var s = result.args[0];\r\n                    s.multiplyPower(new Symbol(0.5));\r\n                    s.multiplier.multiply(result.multiplier);\r\n                    s.multiplyPower(b);\r\n                    result = s;\r\n                }\r\n                else {\r\n                    var sign = m.sign();\r\n                    //handle cases such as (-a^3)^(1/4)\r\n                    if(evenFraction(b) && sign < 0) {\r\n                        // Swaperoo\r\n                        // First put the sign back on the symbol\r\n                        result.negate();\r\n                        // Wrap it in brackets\r\n                        result = _.symfunction(PARENTHESIS, [result]);\r\n                        // Move the sign back the exterior and let nerdamer handle the rest\r\n                        result.negate();\r\n                    }\r\n\r\n                    result.multiplyPower(b);\r\n                }\r\n\r\n                if(aIsConstant && bIsConstant && Settings.PARSE2NUMBER) {\r\n                    var c;\r\n                    //remove the sign\r\n                    if(sign < 0) {\r\n                        a.negate();\r\n                        if(b.multiplier.den.equals(2))\r\n                            //we know that the numerator has to be odd and therefore it's i\r\n                            c = new Symbol(Settings.IMAGINARY);\r\n                        else if(isInt(b.multiplier)) {\r\n                            if(even(b.multiplier))\r\n                                c = new Symbol(1);\r\n                            else\r\n                                c = new Symbol(-1);\r\n                        }\r\n                        else if(!even(b.multiplier.den)) {\r\n                            c = new Symbol(Math.pow(sign, b.multiplier.num));\r\n                        }\r\n                        else {\r\n                            c = _.pow(_.symfunction(PARENTHESIS, [new Symbol(sign)]), b.clone());\r\n                        }\r\n                    }\r\n\r\n                    result = new Symbol(Math.pow(a.multiplier.toDecimal(), b.multiplier.toDecimal()));\r\n\r\n                    //result = new Symbol(Math2.bigpow(a.multiplier, b.multiplier));\r\n                    //put the back sign\r\n                    if(c)\r\n                        result = _.multiply(result, c);\r\n                }\r\n                else if(bIsInt && !m.equals(1)) {\r\n                    var abs_b = b.abs();\r\n                    // Provide fall back to JS until big number implementation is improved\r\n                    if(abs_b.gt(Settings.MAX_EXP)) {\r\n                        if(b.sign() < 0)\r\n                            return new Symbol(0);\r\n                        return Symbol.infinity();\r\n                    }\r\n                    else {\r\n                        var p = b.multiplier.toDecimal();\r\n                        var sgn = Math.sign(p);\r\n                        p = Math.abs(p);\r\n                        var multiplier = new Frac(1);\r\n                        multiplier.num = m.num.pow(p);\r\n                        multiplier.den = m.den.pow(p);\r\n                        if(sgn < 0)\r\n                            multiplier.invert();\r\n                        //multiplying is justified since after mulltiplyPower if it was of group P it will now be of group N\r\n                        result.multiplier = result.multiplier.multiply(multiplier);\r\n                    }\r\n                }\r\n                else {\r\n                    var sign = a.sign();\r\n                    if(b.isConstant() && a.isConstant() && !b.multiplier.den.equals(1) && sign < 0) {\r\n                        //we know the sign is negative so if the denominator for b == 2 then it's i\r\n                        if(b.multiplier.den.equals(2)) {\r\n                            var i = new Symbol(Settings.IMAGINARY);\r\n                            a.negate();//remove the sign\r\n                            //if the power is negative then i is negative\r\n                            if(b.lessThan(0)) {\r\n                                i.negate();\r\n                                b.negate();//remove the sign from the power\r\n                            }\r\n                            //pull the power normally and put back the imaginary\r\n                            result = _.multiply(_.pow(a, b), i);\r\n                        }\r\n                        else {\r\n                            var aa = a.clone();\r\n                            aa.multiplier.negate();\r\n                            result = _.pow(_.symfunction(PARENTHESIS, [new Symbol(sign)]), b.clone());\r\n                            var _a = _.pow(new Symbol(aa.multiplier.num), b.clone());\r\n                            var _b = _.pow(new Symbol(aa.multiplier.den), b.clone());\r\n                            var r = _.divide(_a, _b);\r\n                            result = _.multiply(result, r);\r\n                        }\r\n                    }\r\n                    else if(Settings.PARSE2NUMBER && b.isImaginary()) {\r\n                        //4^(i + 2) = e^(- (2 - 4 i)  n + (2 + i) log(4))\r\n\r\n                        var re = b.realpart();\r\n                        var im = b.imagpart();\r\n                        /*\r\n                         if(b.group === CP && false) {\r\n                         var ex = _.pow(a.clone(), re);\r\n                         var xi = _.multiply(_.multiply(ex.clone(), trig.sin(im.clone())), Symbol.imaginary());\r\n                         var xa = _.multiply(trig.cos(im), ex);\r\n                         result = _.add(xi, xa);\r\n                         }\r\n                         else {\r\n                         */\r\n                        var aa = a.clone().toLinear();\r\n                        var a1 = _.pow(aa.clone(), re);\r\n                        var log_a = log(aa.clone());\r\n                        var b1 = trig.cos(_.multiply(im.clone(), log_a));\r\n                        var c1 = _.multiply(trig.sin(_.multiply(im, log(aa))), Symbol.imaginary());\r\n                        result = _.multiply(a1, _.add(b1, c1));\r\n                        result = _.expand(_.parse(result));\r\n                        /*\r\n                         }   \r\n                         */\r\n                    }\r\n                    else {\r\n                        //b is a symbol\r\n                        var neg_num = a.group === N && sign < 0,\r\n                            num = testSQRT(new Symbol(neg_num ? m.num : Math.abs(m.num)).setPower(b.clone())),\r\n                            den = testSQRT(new Symbol(m.den).setPower(b.clone()).invert());\r\n\r\n                        //eliminate imaginary if possible\r\n                        if(a.imaginary) {\r\n                            if(bIsInt) {\r\n                                var s, p, n;\r\n                                s = Math.sign(b);\r\n                                p = abs(b);\r\n                                n = p % 4;\r\n                                result = new Symbol(even(n) ? -1 : Settings.IMAGINARY);\r\n                                if(n === 0 || s < 0 && (n === 1) || s > 0 && (n === 3)) {\r\n                                    result.negate();\r\n                                }\r\n                            }\r\n                            else {\r\n                                //assume i = sqrt(-1) -> (-1)^(1/2)\r\n                                var nr = b.multiplier.multiply(Frac.quick(1, 2)),\r\n                                        //the denominator denotes the power so raise to it. It will turn positive it round\r\n                                        tn = Math.pow(-1, nr.num);\r\n                                result = even(nr.den) ? new Symbol(-1).setPower(nr, true) : new Symbol(tn);\r\n                            }\r\n                        }\r\n                        //ensure that the sign is carried by the symbol and not the multiplier\r\n                        //this enables us to check down the line if the multiplier can indeed be transferred\r\n                        if(sign < 0 && !neg_num)\r\n                            result.negate();\r\n\r\n                        //retain the absolute value\r\n                        if(bIsConstant && a.group !== EX) {\r\n                            var evenr = even(b.multiplier.den),\r\n                                    evenp = even(a.power),\r\n                                    n = result.power.toDecimal(),\r\n                                    evennp = even(n);\r\n                            if(evenr && evenp && !evennp) {\r\n                                if(n === 1)\r\n                                    result = _.symfunction(ABS, [result]);\r\n                                else if(!isInt(n)) {\r\n                                    var p = result.power;\r\n                                    result = _.symfunction(ABS, [result.toLinear()]).setPower(p);\r\n                                }\r\n                                else {\r\n                                    result = _.multiply(_.symfunction(ABS, [result.clone().toLinear()]),\r\n                                            result.clone().setPower(new Frac(n - 1)));\r\n                                }\r\n                                //quick workaround. Revisit\r\n                                if(Settings.POSITIVE_MULTIPLIERS && result.fname === ABS)\r\n                                    result = result.args[0];\r\n                            }\r\n                        }\r\n                        //multiply out sqrt\r\n                        if(b.equals(2) && result.group === CB) {\r\n                            var _result = new Symbol(1);\r\n                            result.each(function (sym) {\r\n                                _result = _.multiply(_result, _.pow(sym, b));\r\n                            });\r\n                            result = _result;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                result = testSQRT(result);\r\n\r\n                // Don't multiply until we've tested the remaining symbol\r\n                if(num && den) {\r\n                    result = _.multiply(result, testPow(_.multiply(num, den)));\r\n                }\r\n\r\n                // Reduce square root\r\n                if(result.fname === SQRT) {\r\n                    var isEX = result.group === EX;\r\n                    var t = isEX ? result.power.multiplier.toString() : result.power.toString();\r\n                    if(even(t)) {\r\n                        var pt = isEX ? _.divide(result.power, new Symbol(2)) : new Symbol(result.power.divide(new Frac(2))),\r\n                                m = result.multiplier;\r\n                        result = _.pow(result.args[0], pt);\r\n                        result.multiplier = result.multiplier.multiply(m);\r\n                    }\r\n                }\r\n                // Detect Euler's identity\r\n                else if(!Settings.IGNORE_E && result.isE() && result.group === EX && result.power.contains('pi')\r\n                        && result.power.contains(Settings.IMAGINARY) && b.group === CB) {\r\n                    var theta = b.stripVar(Settings.IMAGINARY);\r\n                    result = _.add(trig.cos(theta), _.multiply(Symbol.imaginary(), trig.sin(theta)));\r\n                }\r\n\r\n                return result;\r\n            }\r\n            else {\r\n                if(isVector(a) && bIsSymbol) {\r\n                    a = a.map(function (x) {\r\n                        return _.pow(x, b.clone());\r\n                    });\r\n                }\r\n                else if(isMatrix(a) && bIsSymbol) {\r\n                    var M = new Matrix();\r\n                    a.eachElement(function (x, i, j) {\r\n                        M.set(i, j, _.pow(x, b.clone()));\r\n                    });\r\n                    a = M;\r\n                }\r\n                else if(aIsSymbol && isMatrix(b)) {\r\n                    var M = new Matrix();\r\n                    b.eachElement(function (x, i, j) {\r\n                        M.set(i, j, _.pow(a.clone(), x));\r\n                    });\r\n                    a = M;\r\n                }\r\n                return a;\r\n            }\r\n        };\r\n        // Gets called when the parser finds the , operator.\r\n        // Commas return a Collector object which is roughly an array\r\n        this.comma = function (a, b) {\r\n            if(!(a instanceof Collection))\r\n                a = Collection.create(a);\r\n            a.append(b);\r\n            return a;\r\n        };\r\n        // Link to modulus\r\n        this.mod = function (a, b) {\r\n            return mod(a, b);\r\n        };\r\n        // Used to slice elements from arrays\r\n        this.slice = function (a, b) {\r\n            return new Slice(a, b);\r\n        };\r\n        // The equality setter\r\n        this.equals = function (a, b) {\r\n            // Equality can only be set for group S so complain it's not\r\n            if(a.group !== S && !a.isLinear())\r\n                err('Cannot set equality for ' + a.toString());\r\n            VARS[a.value] = b.clone();\r\n            return b;\r\n        };\r\n        // Percent\r\n        this.percent = function (a) {\r\n            return _.divide(a, new Symbol(100));\r\n        };\r\n        // Set variable\r\n        this.assign = function (a, b) {\r\n            if(a instanceof Collection && b instanceof Collection) {\r\n                a.elements.map(function (x, i) {\r\n                    return _.assign(x, b.elements[i]);\r\n                });\r\n                return Vector.fromArray(b.elements);\r\n            }\r\n            if(a.parent) {\r\n                // It's referring to the parent instead. The current item can be discarded\r\n                var e = a.parent;\r\n                e.elements[e.getter] = b;\r\n                delete e.getter;\r\n                return e;\r\n            }\r\n\r\n            if(a.group !== S)\r\n                throw new NerdamerValueError('Cannot complete operation. Incorrect LH value for ' + a);\r\n            VARS[a.value] = b;\r\n            return b;\r\n        };\r\n        this.function_assign = function (a, b) {\r\n            var f = a.elements.pop();\r\n            return setFunction(f, a.elements, b);\r\n        };\r\n        // Function to quickly convert bools to Symbols\r\n        var bool2Symbol = function (x) {\r\n            return new Symbol(x === true ? 1 : 0);\r\n        };\r\n        //check for equality\r\n        this.eq = function (a, b) {\r\n            return bool2Symbol(a.equals(b));\r\n        };\r\n        //checks for greater than\r\n        this.gt = function (a, b) {\r\n            return bool2Symbol(a.gt(b));\r\n        };\r\n        //checks for greater than equal\r\n        this.gte = function (a, b) {\r\n            return bool2Symbol(a.gte(b));\r\n        };\r\n        //checks for less than\r\n        this.lt = function (a, b) {\r\n            return bool2Symbol(a.lt(b));\r\n        };\r\n        //checks for less than equal\r\n        this.lte = function (a, b) {\r\n            return bool2Symbol(a.lte(b));\r\n        };\r\n        // wraps the factorial\r\n        this.factorial = function (a) {\r\n            return this.symfunction(FACTORIAL, [a]);\r\n        };\r\n        // wraps the double factorial\r\n        this.dfactorial = function (a) {\r\n            return this.symfunction(DOUBLEFACTORIAL, [a]);\r\n        };\r\n    }\r\n    ;\r\n\r\n    /* \"STATIC\" */\r\n    // converts a number to a fraction.\r\n    var Fraction = {\r\n        /**\r\n         * Converts a decimal to a fraction\r\n         * @param {number} value\r\n         * @param {object} opts\r\n         * @returns {Array} - an array containing the denominator and the numerator\r\n         */\r\n        convert: function (value, opts) {\r\n            var frac;\r\n            if(value === 0) {\r\n                frac = [0, 1];\r\n            }\r\n            else {\r\n                if(value < 1e-6 || value > 1e20) {\r\n                    var qc = this.quickConversion(Number(value));\r\n                    if(qc[1] <= 1e20) {\r\n                        var abs = Math.abs(value);\r\n                        var sign = value / abs;\r\n                        frac = this.fullConversion(abs.toFixed((qc[1] + '').length - 1));\r\n                        frac[0] = frac[0] * sign;\r\n                    }\r\n                    else {\r\n                        frac = qc;\r\n                    }\r\n                }\r\n                else {\r\n                    frac = this.fullConversion(value);\r\n                }\r\n            }\r\n            return frac;\r\n        },\r\n        /**\r\n         * If the fraction is too small or too large this gets called instead of fullConversion method\r\n         * @param {number} dec\r\n         * @returns {Array} - an array containing the denominator and the numerator\r\n         */\r\n        quickConversion: function (value) {\r\n            var stripSign = function (s) {\r\n                // Explicitely convert to a string\r\n                if(typeof s !== 'string') {\r\n                    s = s.toString();\r\n                }\r\n\r\n                var sign = '';\r\n\r\n                // Remove and store the sign\r\n                var start = s.charAt(0);\r\n                if(start === '-') {\r\n                    s = s.substr(1, s.length);\r\n                    sign = '-';\r\n                }\r\n                else if(start === '+') {\r\n                    // Just remove the plus sign\r\n                    s = s.substr(1, s.length);\r\n                }\r\n\r\n                return {\r\n                    sign: sign,\r\n                    value: s\r\n                };\r\n            };\r\n\r\n\r\n            function convert(value) {\r\n                // Explicitely convert to a decimal\r\n                if(Scientific.isScientific(value)) {\r\n                    value = scientificToDecimal(value);\r\n                }\r\n\r\n                // Split the value into the sign and the value\r\n                var nparts = stripSign(value);\r\n\r\n                // Split it at the decimal. We'll refer to it as the coeffient parts\r\n                var cparts = nparts.value.split('.');\r\n\r\n                // Combine the entire number by removing leading zero and adding the decimal part\r\n                // This would be teh same as moving the decimal point to the end\r\n                var num;\r\n                // We're dealing with integers\r\n                if(cparts.length === 1) {\r\n                    num = cparts[0];\r\n                }\r\n                else {\r\n                    num = cparts[0] + cparts[1];\r\n                }\r\n                var n = cparts[1] ? cparts[1].length : 0;\r\n                // Generate the padding for the zeros\r\n                var den = `1${'0'.repeat(n)}`;\r\n\r\n                if(num !== '0') {\r\n                    num = num.replace(/^0+/, '');\r\n                }\r\n                return [nparts.sign + num, den];\r\n            }\r\n\r\n            return convert(value);\r\n        },\r\n        /**\r\n         * Returns a good approximation of a fraction. This method gets called by convert\r\n         * http://mathforum.org/library/drmath/view/61772.html\r\n         * Decimal To Fraction Conversion - A Simpler Version\r\n         * Dr Peterson\r\n         * @param {number} dec\r\n         * @returns {Array} - an array containing the denominator and the numerator\r\n         */\r\n        fullConversion: function (dec) {\r\n            var done = false;\r\n            // you can adjust the epsilon to a larger number if you don't need very high precision\r\n            var n1 = 0, d1 = 1, n2 = 1, d2 = 0, n = 0, q = dec, epsilon = 1e-16;\r\n            while(!done) {\r\n                n++;\r\n                if(n > 10000) {\r\n                    done = true;\r\n                }\r\n                var a = Math.floor(q);\r\n                var num = n1 + a * n2;\r\n                var den = d1 + a * d2;\r\n                var e = (q - a);\r\n                if(e < epsilon) {\r\n                    done = true;\r\n                }\r\n                q = 1 / e;\r\n                n1 = n2;\r\n                d1 = d2;\r\n                n2 = num;\r\n                d2 = den;\r\n                if(Math.abs(num / den - dec) < epsilon || n > 30) {\r\n                    done = true;\r\n                }\r\n            }\r\n            return [num, den];\r\n        }\r\n    };\r\n    //Depends on Fraction\r\n\r\n    //The latex generator\r\n    var LaTeX = {\r\n        parser: (function () {\r\n            // create a parser and strip it from everything except the items that you need\r\n            var keep = ['classes', 'setOperator', 'getOperators', 'getBrackets', 'tokenize', 'toRPN', 'tree', 'units'];\r\n            var parser = new Parser();\r\n            for(var x in parser) {\r\n                if(keep.indexOf(x) === -1)\r\n                    delete parser[x];\r\n            }\r\n            // declare the operators\r\n            parser.setOperator({\r\n                precedence: 8,\r\n                operator: '\\\\',\r\n                action: 'slash',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return e; // bypass the slash\r\n                }\r\n            });\r\n            parser.setOperator({\r\n                precedence: 8,\r\n                operator: '\\\\,',\r\n                action: 'slash_comma',\r\n                prefix: true,\r\n                postfix: false,\r\n                leftAssoc: true,\r\n                operation: function (e) {\r\n                    return e; // bypass the slash\r\n                }\r\n            });\r\n            // have braces not map to anything. We want them to be return as-is\r\n            var brackets = parser.getBrackets();\r\n            brackets['{'].maps_to = undefined;\r\n            return parser;\r\n        })(),\r\n        space: '~',\r\n        dot: ' \\\\cdot ',\r\n        // grab a list of supported functions but remove the excluded ones found in exclFN\r\n\r\n        latex: function (symbol, option) {\r\n            // it might be an array\r\n            if(symbol.clone) {\r\n                symbol = symbol.clone(); // leave original as-is\r\n            }\r\n            if(symbol instanceof _.classes.Collection)\r\n                symbol = symbol.elements;\r\n\r\n            if(isArray(symbol)) {\r\n                var LaTeXArray = [];\r\n                for(var i = 0; i < symbol.length; i++) {\r\n                    var sym = symbol[i];\r\n                    //This way I can generate LaTeX on an array of strings.\r\n                    if(!isSymbol(sym))\r\n                        sym = _.parse(sym);\r\n                    LaTeXArray.push(this.latex(sym, option));\r\n                }\r\n                return this.brackets(LaTeXArray.join(', '), 'square');\r\n            }\r\n\r\n            else if(isMatrix(symbol)) {\r\n                var TeX = '\\\\begin{pmatrix}\\n';\r\n                for(var i = 0; i < symbol.elements.length; i++) {\r\n                    var rowTeX = [],\r\n                            e = symbol.elements[i];\r\n                    for(var j = 0; j < e.length; j++) {\r\n                        rowTeX.push(this.latex(e[j], option));\r\n                    }\r\n                    TeX += rowTeX.join(' & ');\r\n                    if(i < symbol.elements.length - 1) {\r\n                        TeX += '\\\\\\\\\\n';\r\n                    }\r\n                }\r\n                TeX += '\\\\end{pmatrix}';\r\n                return TeX;\r\n            }\r\n\r\n            else if(isVector(symbol)) {\r\n                var TeX = '\\\\left[';\r\n                for(var i = 0; i < symbol.elements.length; i++) {\r\n                    TeX += this.latex(symbol.elements[i], option) + ' ' + (i !== symbol.elements.length - 1 ? ',\\\\,' : '');\r\n                }\r\n                TeX += '\\\\right]';\r\n                return TeX;\r\n            }\r\n\r\n            else if(isSet(symbol)) {\r\n                var TeX = '\\\\{';\r\n                for(var i = 0; i < symbol.elements.length; i++) {\r\n                    TeX += this.latex(symbol.elements[i], option) + ' ' + (i !== symbol.elements.length - 1 ? ',\\\\,' : '');\r\n                }\r\n                TeX += '\\\\}';\r\n                return TeX;\r\n            }\r\n\r\n            symbol = symbol.clone();\r\n\r\n            var decimal = (option === 'decimal' || option === 'decimals'),\r\n                    power = symbol.power,\r\n                    invert = isNegative(power),\r\n                    negative = symbol.multiplier.lessThan(0);\r\n\r\n            if(symbol.group === P && decimal) {\r\n                return String(symbol.multiplier.toDecimal() * Math.pow(symbol.value, symbol.power.toDecimal()));\r\n            }\r\n            else {\r\n                symbol.multiplier = symbol.multiplier.abs();\r\n\r\n                // if the user wants the result in decimal format then return it as such by placing it at the top part\r\n                var m_array;\r\n\r\n                if(decimal) {\r\n                    var m = String(symbol.multiplier.toDecimal());\r\n                    // if(String(m) === '1' && !decimal) m = '';\r\n                    m_array = [m, ''];\r\n                }\r\n                else {\r\n                    m_array = [symbol.multiplier.num, symbol.multiplier.den];\r\n                }\r\n                // get the value as a two part array\r\n                var v_array = this.value(symbol, invert, option, negative),\r\n                        p;\r\n                // make it all positive since we know whether to push the power to the numerator or denominator already.\r\n                if(invert)\r\n                    power.negate();\r\n                // the power is simple since it requires no additional formatting. We can get it to a\r\n                // string right away. pass in true to neglect unit powers\r\n                if(decimal) {\r\n                    p = isSymbol(power) ? LaTeX.latex(power, option) : String(power.toDecimal());\r\n                    if(String(p) === '1')\r\n                        p = '';\r\n                }\r\n                // get the latex representation\r\n                else if(isSymbol(power))\r\n                    p = this.latex(power, option);\r\n                // get it as a fraction\r\n                else\r\n                    p = this.formatFrac(power, true);\r\n                // use this array to specify if the power is getting attached to the top or the bottom\r\n                var p_array = ['', ''],\r\n                        // stick it to the top or the bottom. If it's negative then the power gets placed on the bottom\r\n                        index = invert ? 1 : 0;\r\n                p_array[index] = p;\r\n\r\n                // special case group P and decimal\r\n                var retval = (negative ? '-' : '') + this.set(m_array, v_array, p_array, symbol.group === CB);\r\n\r\n                return retval.replace(/\\+\\-/gi, '-');\r\n            }\r\n\r\n        },\r\n        // greek mapping\r\n        greek: {\r\n            alpha: '\\\\alpha',\r\n            beta: '\\\\beta',\r\n            gamma: '\\\\gamma',\r\n            delta: '\\\\delta',\r\n            epsilon: '\\\\epsilon',\r\n            zeta: '\\\\zeta',\r\n            eta: '\\\\eta',\r\n            theta: '\\\\theta',\r\n            iota: '\\\\iota',\r\n            kappa: '\\\\kappa',\r\n            lambda: '\\\\lambda',\r\n            mu: '\\\\mu',\r\n            nu: '\\\\nu',\r\n            xi: '\\\\xi',\r\n            omnikron: '\\\\omnikron',\r\n            pi: '\\\\pi',\r\n            rho: '\\\\rho',\r\n            sigma: '\\\\sigma',\r\n            tau: '\\\\tau',\r\n            upsilon: '\\\\upsilon',\r\n            phi: '\\\\phi',\r\n            chi: '\\\\chi',\r\n            psi: '\\\\psi',\r\n            omega: '\\\\omega',\r\n            Gamma: '\\\\Gamma',\r\n            Delta: '\\\\Delta',\r\n            Epsilon: '\\\\Epsilon',\r\n            Theta: '\\\\Theta',\r\n            Lambda: '\\\\Lambda',\r\n            Xi: '\\\\Xi',\r\n            Pi: '\\\\Pi',\r\n            Sigma: '\\\\Sigma',\r\n            Phi: '\\\\Phi',\r\n            Psi: '\\\\Psi',\r\n            Omega: '\\\\Omega'\r\n        },\r\n        symbols: {\r\n            arccos: '\\\\arccos',\r\n            cos: '\\\\cos',\r\n            csc: '\\\\csc',\r\n            exp: '\\\\exp',\r\n            ker: '\\\\ker',\r\n            limsup: '\\\\limsup',\r\n            min: '\\\\min',\r\n            sinh: '\\\\sinh',\r\n            arcsin: '\\\\arcsin',\r\n            cosh: '\\\\cosh',\r\n            deg: '\\\\deg',\r\n            gcd: '\\\\gcd',\r\n            lg: '\\\\lg',\r\n            ln: '\\\\ln',\r\n            Pr: '\\\\Pr',\r\n            sqrt: '\\\\sqrt',\r\n            sup: '\\\\sup',\r\n            arctan: '\\\\arctan',\r\n            cot: '\\\\cot',\r\n            det: '\\\\det',\r\n            hom: '\\\\hom',\r\n            lim: '\\\\lim',\r\n            log: '\\\\log',\r\n            LN: '\\\\LN',\r\n            sec: '\\\\sec',\r\n            tan: '\\\\tan',\r\n            arg: '\\\\arg',\r\n            coth: '\\\\coth',\r\n            dim: '\\\\dim',\r\n            inf: '\\\\inf',\r\n            liminf: '\\\\liminf',\r\n            max: '\\\\max',\r\n            sin: '\\\\sin',\r\n            tanh: '\\\\tanh'\r\n        },\r\n        // get the raw value of the symbol as an array\r\n        value: function (symbol, inverted, option, negative) {\r\n            var group = symbol.group,\r\n                    previousGroup = symbol.previousGroup,\r\n                    v = ['', ''],\r\n                    index = inverted ? 1 : 0;\r\n            /*if(group === N) // do nothing since we want to return top & bottom blank; */\r\n            if(symbol.isInfinity) {\r\n                v[index] = '\\\\infty';\r\n            }\r\n            else if(group === S || group === P || previousGroup === S || previousGroup === P || previousGroup === N) {\r\n                var value = this.formatSubscripts(symbol.value);\r\n                if(value.replace)\r\n                    value = value.replace(/(.+)_$/, '$1\\\\_');\r\n                // split it so we can check for instances of alpha as well as alpha_b\r\n                var t_varray = String(value).split('_');\r\n                var greek = this.greek[t_varray[0]];\r\n                if(greek) {\r\n                    t_varray[0] = greek;\r\n                    value = t_varray.join('_');\r\n                }\r\n                var symbol = this.symbols[t_varray[0]];\r\n                if(symbol) {\r\n                    t_varray[0] = symbol;\r\n                    value = t_varray.join('_');\r\n                }\r\n                v[index] = value;\r\n            }\r\n            else if(group === FN || previousGroup === FN) {\r\n                var name,\r\n                        input = [],\r\n                        fname = symbol.fname;\r\n                // collect the arguments\r\n                for(var i = 0; i < symbol.args.length; i++) {\r\n                    var arg = symbol.args[i], item;\r\n                    if(typeof arg === 'string')\r\n                        item = arg;\r\n                    else {\r\n                        item = this.latex(arg, option);\r\n                    }\r\n                    input.push(item);\r\n                }\r\n\r\n                if(fname === SQRT) {\r\n                    v[index] = '\\\\sqrt' + this.braces(input.join(','));\r\n                }\r\n                else if(fname === ABS) {\r\n                    v[index] = this.brackets(input.join(','), 'abs');\r\n                }\r\n                else if(fname === PARENTHESIS) {\r\n                    v[index] = this.brackets(input.join(','), 'parens');\r\n                }\r\n                else if(fname === 'limit') {\r\n                    v[index] = ' \\\\lim\\\\limits_{' + input[1] + ' \\\\to ' + input[2] + '} ' + input[0];\r\n                }\r\n                else if(fname === 'integrate') {\r\n                    v[index] = '\\\\int' + this.braces(input[0]) + this.braces('d' + input[1]);\r\n                }\r\n                else if(fname === 'defint') {\r\n                    v[index] = '\\\\int\\\\limits_' + this.braces(input[1]) + '^' + this.braces(input[2]) + ' ' + input[0] + ' d' + input[3];\r\n                }\r\n                else if(fname === FACTORIAL || fname === DOUBLEFACTORIAL) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.power.equals(1) && (arg.isComposite() || arg.isCombination())) {\r\n                        input[0] = this.brackets(input[0]);\r\n                    }\r\n                    v[index] = input[0] + (fname === FACTORIAL ? '!' : '!!');\r\n                }\r\n                else if(fname === 'floor') {\r\n                    v[index] = '\\\\left \\\\lfloor' + this.braces(input[0]) + '\\\\right \\\\rfloor';\r\n                }\r\n                else if(fname === 'ceil') {\r\n                    v[index] = '\\\\left \\\\lceil' + this.braces(input[0]) + '\\\\right \\\\rceil';\r\n                }\r\n                // capture log(a, b)\r\n                else if(fname === Settings.LOG && input.length > 1) {\r\n                    v[index] = '\\\\mathrm' + this.braces(Settings.LOG) + '_' + this.braces(input[1]) + this.brackets(input[0]);\r\n                }\r\n                // capture log(a, b)\r\n                else if(fname === Settings.LOG10) {\r\n                    v[index] = '\\\\mathrm' + this.braces(Settings.LOG) + '_' + this.braces(10) + this.brackets(input[0]);\r\n                }\r\n                else if(fname === 'sum') {\r\n                    var a = input[0],\r\n                            b = input[1],\r\n                            c = input[2],\r\n                            d = input[3];\r\n                    v[index] = '\\\\sum\\\\limits_{' + this.braces(b) + '=' + this.braces(c) + '}^' + this.braces(d) + ' ' + this.braces(a) + '';\r\n                }\r\n                else if(fname === 'product') {\r\n                    var a = input[0],\r\n                            b = input[1],\r\n                            c = input[2],\r\n                            d = input[3];\r\n                    v[index] = '\\\\prod\\\\limits_{' + this.braces(b) + '=' + this.braces(c) + '}^' + this.braces(d) + ' ' + this.braces(a) + '';\r\n                }\r\n                else if(fname === 'nthroot') {\r\n                    v[index] = '\\\\sqrt[' + input[1] + ']' + this.braces(input[0]);\r\n                }\r\n                else if(fname === 'mod') {\r\n                    v[index] = input[0] + ' \\\\bmod ' + input[1];\r\n                }\r\n                else if(fname === 'realpart') {\r\n                    v[index] = '\\\\operatorname{Re}' + this.brackets(input[0]);\r\n                }\r\n                else if(fname === 'imagpart') {\r\n                    v[index] = '\\\\operatorname{Im}' + this.brackets(input[0]);\r\n                }\r\n                else {\r\n                    var name = fname !== '' ? '\\\\mathrm' + this.braces(fname.replace(/_/g, '\\\\_')) : '';\r\n                    if(symbol.isConversion)\r\n                        v[index] = name + this.brackets(input.join(''), 'parens');\r\n                    else\r\n                        v[index] = name + this.brackets(input.join(','), 'parens');\r\n                }\r\n            }\r\n            else if(symbol.isComposite()) {\r\n                var collected = symbol.collectSymbols().sort(\r\n                        group === CP || previousGroup === CP ?\r\n                        function (a, b) {\r\n                            return b.group - a.group;\r\n                        } :\r\n                        function (a, b) {\r\n                            var x = isSymbol(a.power) ? -1 : a.power;\r\n                            var y = isSymbol(b.power) ? -1 : b.power;\r\n                            return y - x;\r\n                        }\r\n                ),\r\n                        symbols = [],\r\n                        l = collected.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    symbols.push(LaTeX.latex(collected[i], option));\r\n                }\r\n                var value = symbols.join('+');\r\n\r\n                v[index] = !(symbol.isLinear() && symbol.multiplier.equals(1)) || negative ? this.brackets(value, 'parens') : value;\r\n            }\r\n            else if(group === CB || previousGroup === EX || previousGroup === CB) {\r\n                if(group === CB)\r\n                    symbol.distributeExponent();\r\n                // This almost feels a little like cheating but I need to know if I should be wrapping the symbol\r\n                // in brackets or not. We'll do this by checking the value of the numerator and then comparing it\r\n                // to whether the symbol value is \"simple\" or not.\r\n                var denominator = [],\r\n                        numerator = [];\r\n                // Generate a profile\r\n                var den_map = [], num_map = [], num_c = 0, den_c = 0;\r\n                var setBrackets = function (container, map, counter) {\r\n                    if(counter > 1 && map.length > 0) {\r\n                        var l = map.length;\r\n                        for(var i = 0; i < l; i++) {\r\n                            var idx = map[i], item = container[idx];\r\n                            if(!(/^\\\\left\\(.+\\\\right\\)\\^\\{.+\\}$/g.test(item) || /^\\\\left\\(.+\\\\right\\)$/g.test(item))) {\r\n                                container[idx] = LaTeX.brackets(item, 'parens');\r\n                            }\r\n                        }\r\n                    }\r\n                    return container;\r\n                };\r\n\r\n                // Generate latex for each of them\r\n                symbol.each(function (x) {\r\n                    var isDenom = isNegative(x.power),\r\n                            laTex;\r\n\r\n                    if(isDenom) {\r\n                        laTex = LaTeX.latex(x.invert(), option);\r\n                        den_c++;\r\n                        if(x.isComposite()) {\r\n                            if(symbol.multiplier.den != 1 && Math.abs(x.power) == 1)\r\n                                laTex = LaTeX.brackets(laTex, 'parens');\r\n                            den_map.push(denominator.length); // make a note of where the composite was found\r\n                        }\r\n\r\n                        denominator.push(laTex);\r\n                    }\r\n                    else {\r\n                        laTex = LaTeX.latex(x, option);\r\n                        num_c++;\r\n                        if(x.isComposite()) {\r\n                            if(symbol.multiplier.num != 1 && Math.abs(x.power) == 1)\r\n                                laTex = LaTeX.brackets(laTex, 'parens');\r\n                            num_map.push(numerator.length);   // make a note of where the composite was found\r\n                        }\r\n                        numerator.push(laTex);\r\n                    }\r\n                });\r\n\r\n                // Apply brackets\r\n                setBrackets(numerator, num_map, num_c);\r\n                v[0] = numerator.join(this.dot); // collapse the numerator into one string\r\n\r\n                setBrackets(denominator, den_map, den_c);\r\n                v[1] = denominator.join(this.dot);\r\n            }\r\n\r\n            return v;\r\n        },\r\n        set: function (m, v, p, combine_power) {\r\n            var isBracketed = function (v) {\r\n                return /^\\\\left\\(.+\\\\right\\)$/.test(v);\r\n            };\r\n            // format the power if it exists\r\n            if(p)\r\n                p = this.formatP(p);\r\n            // group CB will have to be wrapped since the power applies to both it's numerator and denominator\r\n            if(combine_power) {\r\n                // POSSIBLE BUG: If powers for group CB format wrong, investigate this since I might have overlooked something\r\n                // the assumption is that in every case the denonimator should be empty when dealing with CB. I can't think\r\n                // of a case where this isn't true\r\n                var tp = p[0];\r\n                p[0] = ''; // temporarily make p blank\r\n            }\r\n\r\n            // merge v and p. Not that v MUST be first since the order matters\r\n            v = this.merge(v, p);\r\n            var mn = m[0], md = m[1], vn = v[0], vd = v[1];\r\n            // filters\r\n            // if the top has a variable but the numerator is one drop it\r\n            if(vn && Number(mn) === 1)\r\n                mn = '';\r\n            // if denominator is 1 drop it always\r\n            if(Number(md) === 1)\r\n                md = '';\r\n            // prepare the top portion but check that it's not already bracketed. If it is then leave out the cdot\r\n            var top = this.join(mn, vn, !isBracketed(vn) ? this.dot : '');\r\n\r\n            // prepare the bottom portion but check that it's not already bracketed. If it is then leave out the cdot\r\n            var bottom = this.join(md, vd, !isBracketed(vd) ? this.dot : '');\r\n            // format the power if it exists\r\n            // make it a fraction if both top and bottom exists\r\n            if(top && bottom) {\r\n                var frac = this.frac(top, bottom);\r\n                if(combine_power && tp)\r\n                    frac = this.brackets(frac) + tp;\r\n                return frac;\r\n            }\r\n            // otherwise only the top exists so return that\r\n            else\r\n                return top;\r\n        },\r\n        merge: function (a, b) {\r\n            var r = [];\r\n            for(var i = 0; i < 2; i++)\r\n                r[i] = a[i] + b[i];\r\n            return r;\r\n        },\r\n        // joins together two strings if both exist\r\n        join: function (n, d, glue) {\r\n            if(!n && !d)\r\n                return '';\r\n            if(n && !d)\r\n                return n;\r\n            if(d && !n)\r\n                return d;\r\n            return n + glue + d;\r\n        },\r\n        /**\r\n         * Places subscripts in braces for proper formatting\r\n         * @param {String} v\r\n         * @returns {String}\r\n         */\r\n        formatSubscripts: function (v) {\r\n            // Split it at the underscore\r\n            var arr = v.toString().split('_');\r\n\r\n            var name = '';\r\n\r\n            // Loop over all entries except the first one\r\n            while(arr.length > 1) {\r\n                // Wrap all in braces except for the last one\r\n                if(arr.length > 0) {\r\n                    name = '_' + this.braces(arr.pop() + name);\r\n                }\r\n            }\r\n\r\n            return arr[0] + name;\r\n        },\r\n        formatP: function (p_array) {\r\n            for(var i = 0; i < 2; i++) {\r\n                var p = p_array[i];\r\n                if(p)\r\n                    p_array[i] = '^' + this.braces(p);\r\n            }\r\n            return p_array;\r\n        },\r\n        /**\r\n         * formats the fractions accordingly.\r\n         * @param {Frac} f\r\n         * @param {bool} is_pow\r\n         */\r\n        formatFrac: function (f, is_pow) {\r\n            var n = f.num.toString(),\r\n                    d = f.den.toString();\r\n            // no need to have x^1\r\n            if(is_pow && n === '1' && d === '1')\r\n                return '';\r\n            // no need to have x/1\r\n            if(d === '1')\r\n                return n;\r\n            return this.frac(n, d);\r\n        },\r\n        frac: function (n, d) {\r\n            return '\\\\frac' + this.braces(n) + this.braces(d);\r\n        },\r\n        braces: function (e) {\r\n            return '{' + e + '}';\r\n        },\r\n        brackets: function (e, typ) {\r\n            typ = typ || 'parens';\r\n            var bracketTypes = {\r\n                parens: ['(', ')'],\r\n                square: ['[', ']'],\r\n                brace: ['{', '}'],\r\n                abs: ['|', '|'],\r\n                angle: ['\\\\langle', '\\\\rangle']\r\n            };\r\n            var bracket = bracketTypes[typ];\r\n            return '\\\\left' + bracket[0] + e + '\\\\right' + bracket[1];\r\n        },\r\n        /**\r\n         * Removes extreneous tokens\r\n         * @param {Tokens[]} tokens\r\n         * @returns {Tokens[]}\r\n         */\r\n        filterTokens: function (tokens) {\r\n            var filtered = [];\r\n\r\n            // Copy over the type of the scope\r\n            if(isArray(tokens)) {\r\n                filtered.type = tokens.type;\r\n            }\r\n\r\n            // the items that need to be disposed\r\n            var d = ['\\\\', 'left', 'right', 'big', 'Big', 'large', 'Large'];\r\n            for(var i = 0, l = tokens.length; i < l; i++) {\r\n                var token = tokens[i];\r\n                var next_token = tokens[i + 1];\r\n                if(token.value === '\\\\' && next_token.value === '\\\\') {\r\n                    filtered.push(token);\r\n                }\r\n                else if(isArray(token)) {\r\n                    filtered.push(LaTeX.filterTokens(token));\r\n                }\r\n                else if(d.indexOf(token.value) === -1) {\r\n                    filtered.push(token);\r\n                }\r\n            }\r\n            return filtered;\r\n        },\r\n        /*\r\n         * Parses tokens from LaTeX string. Does not do any error checking\r\n         * @param {Tokens[]} rpn\r\n         * @returns {String}\r\n         */\r\n        parse: function (raw_tokens) {\r\n            var i, l;\r\n            var retval = '';\r\n            var tokens = this.filterTokens(raw_tokens);\r\n            var replace = {\r\n                'cdot': '',\r\n                'times': '',\r\n                'infty': 'Infinity'\r\n            };\r\n            // get the next token\r\n            var next = function (n) {\r\n                return tokens[(typeof n === 'undefined' ? ++i : i += n)];\r\n            };\r\n            var parse_next = function () {\r\n                return LaTeX.parse(next());\r\n            };\r\n            var get = function (token) {\r\n                if(token in replace) {\r\n                    return replace[token];\r\n                }\r\n                // A quirk with implicit multiplication forces us to check for *\r\n                if(token === '*' && tokens[i + 1].value === '&') {\r\n                    next(2); // skip this and the &\r\n                    return ',';\r\n                }\r\n\r\n                if(token === '&') {\r\n                    next();\r\n                    return ','; // Skip the *\r\n                }\r\n                // If it's the end of a row, return the row separator\r\n                if(token === '\\\\') {\r\n                    return '],[';\r\n                }\r\n                return token;\r\n            };\r\n\r\n            // start parsing the tokens\r\n            for(i = 0, l = tokens.length; i < l; i++) {\r\n                var token = tokens[i];\r\n                // fractions\r\n                if(token.value === 'frac') {\r\n                    // parse and wrap it in brackets\r\n                    var n = parse_next();\r\n                    var d = parse_next();\r\n                    retval += n + '/' + d;\r\n                }\r\n                else if(token.value in LaTeX.symbols) {\r\n                    if(token.value === SQRT && tokens[i + 1].type === 'vector' && tokens[i + 2].type === 'Set') {\r\n                        var base = parse_next();\r\n                        var expr = parse_next();\r\n                        retval += (expr + '^' + inBrackets('1/' + base));\r\n                    }\r\n                    else {\r\n                        retval += token.value + parse_next();\r\n                    }\r\n                }\r\n                else if(token.value === 'int') {\r\n                    var f = parse_next();\r\n                    // skip the comma\r\n                    i++;\r\n                    // get the variable of integration\r\n                    var dx = next().value;\r\n                    dx = get(dx.substring(1, dx.length));\r\n                    retval += 'integrate' + inBrackets(f + ',' + dx);\r\n                }\r\n                else if(token.value === 'int_') {\r\n                    var l = parse_next(); // lower\r\n                    i++; // skip the ^\r\n                    var u = next().value; // upper\r\n                    // if it is in brackets\r\n                    if (u === undefined) {\r\n                        i--;\r\n                        var u = parse_next();\r\n                    }\r\n                    var f = parse_next(); // function\r\n                    \r\n                    // get the variable of integration\r\n                    var dx = next().value;\r\n                    // skip the comma\r\n                    if (dx === ',') {\r\n                        var dx = next().value;\r\n                    }\r\n                    // if 'd', skip\r\n                    if (dx === 'differentialD') {\r\n                        // skip the *\r\n                        i++;\r\n                        var dx = next().value;\r\n                    }\r\n                    if (dx === 'mathrm') {\r\n                        // skip the mathrm{d}\r\n                        i++;\r\n                        var dx = next().value;\r\n                    }\r\n                    retval += 'defint' + inBrackets(f + ',' + l + ',' + u + ',' + dx);\r\n                }\r\n                else if(token.value && token.value.startsWith('int_')) {\r\n                    // var l = parse_next(); // lower\r\n                    var l = token.value.replace('int_', '')\r\n                    console.log('uppernow')\r\n                    i++; // skip the ^\r\n                    var u = next().value; // upper\r\n                    // if it is in brackets\r\n                    if (u === undefined) {\r\n                        i--;\r\n                        var u = parse_next();\r\n                    }\r\n                    var f = parse_next(); // function\r\n                    \r\n                    // get the variable of integration\r\n                    var dx = next().value;\r\n                    // skip the comma\r\n                    if (dx === ',') {\r\n                        var dx = next().value;\r\n                    }\r\n                    // if 'd', skip\r\n                    if (dx === 'differentialD') {\r\n                        // skip the *\r\n                        i++;\r\n                        var dx = next().value;\r\n                    }\r\n                    if (dx === 'mathrm') {\r\n                        // skip the mathrm{d}\r\n                        i++;\r\n                        var dx = next().value;\r\n                    }\r\n                    retval += 'defint' + inBrackets(f + ',' + l + ',' + u + ',' + dx);\r\n                }\r\n                else if(token.value === 'mathrm') {\r\n                    var f = tokens[++i][0].value;\r\n                    retval += f + parse_next();\r\n                }\r\n                // sum and product\r\n                else if(token.value === 'sum_' || token.value === 'prod_') {\r\n                    var fn = token.value === 'sum_' ? 'sum' : 'product';\r\n                    var nxt = next();\r\n                    i++; // skip the caret\r\n                    var end = parse_next();\r\n                    var f = parse_next();\r\n                    retval += fn + inBrackets([f, get(nxt[0]), get(nxt[2]), get(end)].join(','));\r\n                }\r\n                else if(token.value === 'lim_') {\r\n                    var nxt = next();\r\n                    retval += 'limit' + inBrackets([parse_next(), get(nxt[0]), get(nxt[2])].join(','));\r\n                }\r\n                else if(token.value === 'begin') {\r\n                    var nxt = next();\r\n                    if(Array.isArray(nxt)) {\r\n                        var v = nxt[0].value;\r\n                        if(v === 'matrix') {\r\n                            // Start a matrix\r\n                            retval += 'matrix([';\r\n                        }\r\n                    }\r\n                }\r\n                else if(token.value === 'end') {\r\n                    var nxt = next();\r\n                    if(Array.isArray(nxt)) {\r\n                        var v = nxt[0].value;\r\n                        if(v === 'matrix') {\r\n                            // End a matrix\r\n                            retval += '])';\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if(Array.isArray(token)) {\r\n                        retval += get(LaTeX.parse(token));\r\n                    }\r\n                    else {\r\n                        retval += get(token.value.toString());\r\n                    }\r\n                }\r\n            }\r\n\r\n            return inBrackets(retval);\r\n        }\r\n    };\r\n//Vector =======================================================================\r\n    function Vector(v) {\r\n        if(isVector(v))\r\n            this.elements = v.items.slice(0);\r\n        else if(isArray(v))\r\n            this.elements = v.slice(0);\r\n        else\r\n            this.elements = [].slice.call(arguments);\r\n    }\r\n    /*\r\n     * Generates a pre-filled array\r\n     * @param {type} n\r\n     * @param {type} val\r\n     * @returns {unresolved}\r\n     */\r\n    Vector.arrayPrefill = function (n, val) {\r\n        var a = [];\r\n        val = val || 0;\r\n        for(var i = 0; i < n; i++)\r\n            a[i] = val;\r\n        return a;\r\n    };\r\n    /**\r\n     * Generate a vector from and array\r\n     * @param {type} a\r\n     * @returns {unresolved}\r\n     */\r\n    Vector.fromArray = function (a) {\r\n        var v = new Vector();\r\n        v.elements = a;\r\n        return v;\r\n    };\r\n\r\n    /**\r\n     * Convert a Set to a Vector\r\n     * @param {Set} set\r\n     * @returns {Vector}\r\n     */\r\n    Vector.fromSet = function (set) {\r\n        return Vector.fromArray(set.elements);\r\n    };\r\n\r\n    //Ported from Sylvester.js\r\n    Vector.prototype = {\r\n        custom: true,\r\n        // Returns element i of the vector\r\n        e: function (i) {\r\n            return (i < 1 || i > this.elements.length) ? null : this.elements[i - 1];\r\n        },\r\n\r\n        set: function (i, val) {\r\n            if(!isSymbol(val))\r\n                val = new Symbol(val);\r\n            this.elements[i] = val;\r\n        },\r\n\r\n        // Returns the number of elements the vector has\r\n        dimensions: function () {\r\n            return this.elements.length;\r\n        },\r\n\r\n        // Returns the modulus ('length') of the vector\r\n        modulus: function () {\r\n            return block('SAFE', function () {\r\n                return _.pow((this.dot(this.clone())), new Symbol(0.5));\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns true iff the vector is equal to the argument\r\n        eql: function (vector) {\r\n            var n = this.elements.length;\r\n            var V = vector.elements || vector;\r\n            if(n !== V.length) {\r\n                return false;\r\n            }\r\n            do {\r\n                if(Math.abs(_.subtract(this.elements[n - 1], V[n - 1]).valueOf()) > PRECISION) {\r\n                    return false;\r\n                }\r\n            }\r\n            while(--n);\r\n            return true;\r\n        },\r\n\r\n        // Returns a clone of the vector\r\n        clone: function () {\r\n            var V = new Vector(),\r\n                    l = this.elements.length;\r\n            for(var i = 0; i < l; i++) {\r\n                //Rule: all items within the vector must have a clone method.\r\n                V.elements.push(this.elements[i].clone());\r\n            }\r\n            if(this.getter) {\r\n                V.getter = this.getter.clone();\r\n            }\r\n            return V;\r\n        },\r\n\r\n        // Maps the vector to another vector according to the given function\r\n        map: function (fn) {\r\n            var elements = [];\r\n            this.each(function (x, i) {\r\n                elements.push(fn(x, i));\r\n            });\r\n\r\n            return new Vector(elements);\r\n        },\r\n\r\n        // Calls the iterator for each element of the vector in turn\r\n        each: function (fn) {\r\n            var n = this.elements.length, k = n, i;\r\n            do {\r\n                i = k - n;\r\n                fn(this.elements[i], i + 1);\r\n            }\r\n            while(--n);\r\n        },\r\n\r\n        // Returns a new vector created by normalizing the receiver\r\n        toUnitVector: function () {\r\n            return block('SAFE', function () {\r\n                var r = this.modulus();\r\n                if(r.valueOf() === 0) {\r\n                    return this.clone();\r\n                }\r\n                return this.map(function (x) {\r\n                    return _.divide(x, r);\r\n                });\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the angle between the vector and the argument (also a vector)\r\n        angleFrom: function (vector) {\r\n            return block('SAFE', function () {\r\n                var V = vector.elements || vector;\r\n                var n = this.elements.length;\r\n                if(n !== V.length) {\r\n                    return null;\r\n                }\r\n                var dot = new Symbol(0), mod1 = new Symbol(0), mod2 = new Symbol(0);\r\n                // Work things out in parallel to save time\r\n                this.each(function (x, i) {\r\n                    dot = _.add(dot, _.multiply(x, V[i - 1]));\r\n                    mod1 = _.add(mod1, _.multiply(x, x));// will not conflict in safe block\r\n                    mod2 = _.add(mod2, _.multiply(V[i - 1], V[i - 1]));// will not conflict in safe block\r\n                });\r\n                mod1 = _.pow(mod1, new Symbol(0.5));\r\n                mod2 = _.pow(mod2, new Symbol(0.5));\r\n                var product = _.multiply(mod1, mod2);\r\n                if(product.valueOf() === 0) {\r\n                    return null;\r\n                }\r\n                var theta = _.divide(dot, product);\r\n                var theta_val = theta.valueOf();\r\n                if(theta_val < -1) {\r\n                    theta = -1;\r\n                }\r\n                if(theta_val > 1) {\r\n                    theta = 1;\r\n                }\r\n                return new Symbol(Math.acos(theta));\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns true iff the vector is parallel to the argument\r\n        isParallelTo: function (vector) {\r\n            var angle = this.angleFrom(vector).valueOf();\r\n            return (angle === null) ? null : (angle <= PRECISION);\r\n        },\r\n\r\n        // Returns true iff the vector is antiparallel to the argument\r\n        isAntiparallelTo: function (vector) {\r\n            var angle = this.angleFrom(vector).valueOf();\r\n            return (angle === null) ? null : (Math.abs(angle - Math.PI) <= PRECISION);\r\n        },\r\n\r\n        // Returns true iff the vector is perpendicular to the argument\r\n        isPerpendicularTo: function (vector) {\r\n            var dot = this.dot(vector);\r\n            return (dot === null) ? null : (Math.abs(dot) <= PRECISION);\r\n        },\r\n\r\n        // Returns the result of adding the argument to the vector\r\n        add: function (vector) {\r\n            return block('SAFE', function () {\r\n                var V = vector.elements || vector;\r\n                if(this.elements.length !== V.length) {\r\n                    return null;\r\n                }\r\n                return this.map(function (x, i) {\r\n                    return _.add(x, V[i - 1]);\r\n                });\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the result of subtracting the argument from the vector\r\n        subtract: function (vector) {\r\n            return block('SAFE', function () {\r\n                var V = vector.elements || vector;\r\n                if(this.elements.length !== V.length) {\r\n                    return null;\r\n                }\r\n                return this.map(function (x, i) {\r\n                    return _.subtract(x, V[i - 1]);\r\n                });\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the result of multiplying the elements of the vector by the argument\r\n        multiply: function (k) {\r\n            return this.map(function (x) {\r\n                return x.clone() * k.clone();\r\n            });\r\n        },\r\n\r\n        x: function (k) {\r\n            return this.multiply(k);\r\n        },\r\n\r\n        // Returns the scalar product of the vector with the argument\r\n        // Both vectors must have equal dimensionality\r\n        dot: function (vector) {\r\n            return block('SAFE', function () {\r\n                var V = vector.elements || vector;\r\n                var product = new Symbol(0), n = this.elements.length;\r\n                if(n !== V.length) {\r\n                    return null;\r\n                }\r\n                do {\r\n                    product = _.add(product, _.multiply(this.elements[n - 1], V[n - 1]));\r\n                }\r\n                while(--n);\r\n                return product;\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the vector product of the vector with the argument\r\n        // Both vectors must have dimensionality 3\r\n        cross: function (vector) {\r\n            var B = vector.elements || vector;\r\n            if(this.elements.length !== 3 || B.length !== 3) {\r\n                return null;\r\n            }\r\n            var A = this.elements;\r\n            return block('SAFE', function () {\r\n                return new Vector([\r\n                    _.subtract(_.multiply(A[1], B[2]), _.multiply(A[2], B[1])),\r\n                    _.subtract(_.multiply(A[2], B[0]), _.multiply(A[0], B[2])),\r\n                    _.subtract(_.multiply(A[0], B[1]), _.multiply(A[1], B[0]))\r\n                ]);\r\n            }, undefined, this);\r\n        },\r\n\r\n        // Returns the (absolute) largest element of the vector\r\n        max: function () {\r\n            var m = 0, n = this.elements.length, k = n, i;\r\n            do {\r\n                i = k - n;\r\n                if(Math.abs(this.elements[i].valueOf()) > Math.abs(m.valueOf())) {\r\n                    m = this.elements[i];\r\n                }\r\n            }\r\n            while(--n);\r\n            return m;\r\n        },\r\n        magnitude: function () {\r\n            var magnitude = new Symbol(0);\r\n            this.each(function (e) {\r\n                magnitude = _.add(magnitude, _.pow(e, new Symbol(2)));\r\n            });\r\n            return _.sqrt(magnitude);\r\n        },\r\n        // Returns the index of the first match found\r\n        indexOf: function (x) {\r\n            var index = null, n = this.elements.length, k = n, i;\r\n            do {\r\n                i = k - n;\r\n                if(index === null && this.elements[i].valueOf() === x.valueOf()) {\r\n                    index = i + 1;\r\n                }\r\n            }\r\n            while(--n);\r\n            return index;\r\n        },\r\n        text: function (x) {\r\n            return text(this);\r\n        },\r\n        toString: function () {\r\n            return this.text();\r\n        },\r\n        latex: function (option) {\r\n            var tex = [];\r\n            for(var i = 0; i < this.elements.length; i++) {\r\n                tex.push(LaTeX.latex.call(LaTeX, this.elements[i], option));\r\n            }\r\n            return '[' + tex.join(', ') + ']';\r\n        }\r\n    };\r\n\r\n//Matrix =======================================================================\r\n    function Matrix() {\r\n        var m = arguments,\r\n                l = m.length, i, el = [];\r\n        if(isMatrix(m)) { // if it's a matrix then make a clone\r\n            for(i = 0; i < l; i++) {\r\n                el.push(m[i].slice(0));\r\n            }\r\n        }\r\n        else {\r\n            var row, lw, rl;\r\n            for(i = 0; i < l; i++) {\r\n                row = m[i];\r\n                if(isVector(row))\r\n                    row = row.elements;\r\n                if(!isArray(row))\r\n                    row = [row];\r\n                rl = row.length;\r\n                if(lw && lw !== rl)\r\n                    err('Unable to create Matrix. Row dimensions do not match!');\r\n                el.push(row);\r\n                lw = rl;\r\n            }\r\n        }\r\n        this.elements = el;\r\n    }\r\n    Matrix.identity = function (n) {\r\n        var m = new Matrix();\r\n        for(var i = 0; i < n; i++) {\r\n            m.elements.push([]);\r\n            for(var j = 0; j < n; j++) {\r\n                m.set(i, j, i === j ? new Symbol(1) : new Symbol(0));\r\n            }\r\n        }\r\n        return m;\r\n    };\r\n    Matrix.fromArray = function (arr) {\r\n        function F(args) {\r\n            return Matrix.apply(this, args);\r\n        }\r\n        F.prototype = Matrix.prototype;\r\n\r\n        return new F(arr);\r\n    };\r\n    Matrix.zeroMatrix = function (rows, cols) {\r\n        var m = new Matrix();\r\n        for(var i = 0; i < rows; i++) {\r\n            m.elements.push(Vector.arrayPrefill(cols, new Symbol(0)));\r\n        }\r\n        return m;\r\n    };\r\n    Matrix.prototype = {\r\n        // needs be true to let the parser know not to try to cast it to a symbol\r\n        custom: true,\r\n        get: function (row, column) {\r\n            if(!this.elements[row])\r\n                return undefined;\r\n            return this.elements[row][column];\r\n        },\r\n        map: function (f, raw_values) {\r\n            var M = new Matrix();\r\n            this.each(function (e, i, j) {\r\n                M.set(i, j, f.call(M, e), raw_values);\r\n            });\r\n            return M;\r\n        },\r\n        set: function (row, column, value, raw) {\r\n            if(!this.elements[row])\r\n                this.elements[row] = [];\r\n            this.elements[row][column] = raw ? value : (isSymbol(value) ? value : new Symbol(value));\r\n        },\r\n        cols: function () {\r\n            return this.elements[0].length;\r\n        },\r\n        rows: function () {\r\n            return this.elements.length;\r\n        },\r\n        row: function (n) {\r\n            if(!n || n > this.cols())\r\n                return [];\r\n            return this.elements[n - 1];\r\n        },\r\n        col: function (n) {\r\n            var nr = this.rows(),\r\n                    col = [];\r\n            if(n > this.cols() || !n)\r\n                return col;\r\n            for(var i = 0; i < nr; i++) {\r\n                col.push(this.elements[i][n - 1]);\r\n            }\r\n            return col;\r\n        },\r\n        eachElement: function (fn) {\r\n            var nr = this.rows(),\r\n                    nc = this.cols(), i, j;\r\n            for(i = 0; i < nr; i++) {\r\n                for(j = 0; j < nc; j++) {\r\n                    fn.call(this, this.elements[i][j], i, j);\r\n                }\r\n            }\r\n        },\r\n        // ported from Sylvester.js\r\n        determinant: function () {\r\n            if(!this.isSquare()) {\r\n                return null;\r\n            }\r\n            var M = this.toRightTriangular();\r\n            var det = M.elements[0][0], n = M.elements.length - 1, k = n, i;\r\n            do {\r\n                i = k - n + 1;\r\n                det = _.multiply(det, M.elements[i][i]);\r\n            }\r\n            while(--n);\r\n            return det;\r\n        },\r\n        isSquare: function () {\r\n            return this.elements.length === this.elements[0].length;\r\n        },\r\n        isSingular: function () {\r\n            return this.isSquare() && this.determinant() === 0;\r\n        },\r\n        augment: function (m) {\r\n            var r = this.rows(), rr = m.rows();\r\n            if(r !== rr)\r\n                err(\"Cannot augment matrix. Rows don't match.\");\r\n            for(var i = 0; i < r; i++) {\r\n                this.elements[i] = this.elements[i].concat(m.elements[i]);\r\n            }\r\n\r\n            return this;\r\n        },\r\n        clone: function () {\r\n            var r = this.rows(), c = this.cols(),\r\n                    m = new Matrix();\r\n            for(var i = 0; i < r; i++) {\r\n                m.elements[i] = [];\r\n                for(var j = 0; j < c; j++) {\r\n                    var symbol = this.elements[i][j];\r\n                    m.elements[i][j] = isSymbol(symbol) ? symbol.clone() : symbol;\r\n                }\r\n            }\r\n            return m;\r\n        },\r\n        // ported from Sylvester.js\r\n        invert: function () {\r\n            if(!this.isSquare())\r\n                err('Matrix is not square!');\r\n            return block('SAFE', function () {\r\n                var ni = this.elements.length, ki = ni, i, j;\r\n                var imatrix = Matrix.identity(ni);\r\n                var M = this.augment(imatrix).toRightTriangular();\r\n                var np, kp = M.elements[0].length, p, els, divisor;\r\n                var inverse_elements = [], new_element;\r\n                // Matrix is non-singular so there will be no zeros on the diagonal\r\n                // Cycle through rows from last to first\r\n                do {\r\n                    i = ni - 1;\r\n                    // First, normalise diagonal elements to 1\r\n                    els = [];\r\n                    np = kp;\r\n                    inverse_elements[i] = [];\r\n                    divisor = M.elements[i][i];\r\n                    do {\r\n                        p = kp - np;\r\n                        new_element = _.divide(M.elements[i][p], divisor.clone());\r\n                        els.push(new_element);\r\n                        // Shuffle of the current row of the right hand side into the results\r\n                        // array as it will not be modified by later runs through this loop\r\n                        if(p >= ki) {\r\n                            inverse_elements[i].push(new_element);\r\n                        }\r\n                    }\r\n                    while(--np);\r\n                    M.elements[i] = els;\r\n                    // Then, subtract this row from those above it to\r\n                    // give the identity matrix on the left hand side\r\n                    for(j = 0; j < i; j++) {\r\n                        els = [];\r\n                        np = kp;\r\n                        do {\r\n                            p = kp - np;\r\n                            els.push(_.subtract(M.elements[j][p].clone(), _.multiply(M.elements[i][p].clone(), M.elements[j][i].clone())));\r\n                        }\r\n                        while(--np);\r\n                        M.elements[j] = els;\r\n                    }\r\n                }\r\n                while(--ni);\r\n                return Matrix.fromArray(inverse_elements);\r\n            }, undefined, this);\r\n        },\r\n        // ported from Sylvester.js\r\n        toRightTriangular: function () {\r\n            return block('SAFE', function () {\r\n                var M = this.clone(), els, fel, nel,\r\n                        n = this.elements.length, k = n, i, np, kp = this.elements[0].length, p;\r\n                do {\r\n                    i = k - n;\r\n                    fel = M.elements[i][i];\r\n                    if(fel.valueOf() === 0) {\r\n                        for(var j = i + 1; j < k; j++) {\r\n                            nel = M.elements[j][i];\r\n                            if(nel && nel.valueOf() !== 0) {\r\n                                els = [];\r\n                                np = kp;\r\n                                do {\r\n                                    p = kp - np;\r\n                                    els.push(_.add(M.elements[i][p].clone(), M.elements[j][p].clone()));\r\n                                }\r\n                                while(--np);\r\n                                M.elements[i] = els;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    var fel = M.elements[i][i];\r\n                    if(fel.valueOf() !== 0) {\r\n                        for(j = i + 1; j < k; j++) {\r\n                            var multiplier = _.divide(M.elements[j][i].clone(), M.elements[i][i].clone());\r\n                            els = [];\r\n                            np = kp;\r\n                            do {\r\n                                p = kp - np;\r\n                                // Elements with column numbers up to an including the number\r\n                                // of the row that we're subtracting can safely be set straight to\r\n                                // zero, since that's the point of this routine and it avoids having\r\n                                // to loop over and correct rounding errors later\r\n                                els.push(p <= i ? new Symbol(0) :\r\n                                        _.subtract(M.elements[j][p].clone(), _.multiply(M.elements[i][p].clone(), multiplier.clone())));\r\n                            }\r\n                            while(--np);\r\n                            M.elements[j] = els;\r\n                        }\r\n                    }\r\n                }\r\n                while(--n);\r\n\r\n                return M;\r\n            }, undefined, this);\r\n        },\r\n        transpose: function () {\r\n            var rows = this.elements.length, cols = this.elements[0].length;\r\n            var M = new Matrix(), ni = cols, i, nj, j;\r\n\r\n            do {\r\n                i = cols - ni;\r\n                M.elements[i] = [];\r\n                nj = rows;\r\n                do {\r\n                    j = rows - nj;\r\n                    M.elements[i][j] = this.elements[j][i].clone();\r\n                }\r\n                while(--nj);\r\n            }\r\n            while(--ni);\r\n            return M;\r\n        },\r\n        // Returns true if the matrix can multiply the argument from the left\r\n        canMultiplyFromLeft: function (matrix) {\r\n            var l = isMatrix(matrix) ? matrix.elements.length : matrix.length;\r\n            // this.columns should equal matrix.rows\r\n            return (this.elements[0].length === l);\r\n        },\r\n        sameSize: function (matrix) {\r\n            return this.rows() === matrix.rows() && this.cols() === matrix.cols();\r\n        },\r\n        multiply: function (matrix) {\r\n            return block('SAFE', function () {\r\n                var M = matrix.elements || matrix;\r\n                if(!this.canMultiplyFromLeft(M)) {\r\n                    if(this.sameSize(matrix)) {\r\n                        var MM = new Matrix();\r\n                        var rows = this.rows();\r\n                        for(var i = 0; i < rows; i++) {\r\n                            var e = _.multiply(new Vector(this.elements[i]), new Vector(matrix.elements[i]));\r\n                            MM.elements[i] = e.elements;\r\n                        }\r\n                        return MM;\r\n                    }\r\n                    return null;\r\n                }\r\n                var ni = this.elements.length, ki = ni, i, nj, kj = M[0].length, j;\r\n                var cols = this.elements[0].length, elements = [], sum, nc, c;\r\n                do {\r\n                    i = ki - ni;\r\n                    elements[i] = [];\r\n                    nj = kj;\r\n                    do {\r\n                        j = kj - nj;\r\n                        sum = new Symbol(0);\r\n                        nc = cols;\r\n                        do {\r\n                            c = cols - nc;\r\n                            sum = _.add(sum, _.multiply(this.elements[i][c], M[c][j]));\r\n                        }\r\n                        while(--nc);\r\n                        elements[i][j] = sum;\r\n                    }\r\n                    while(--nj);\r\n                }\r\n                while(--ni);\r\n                return Matrix.fromArray(elements);\r\n            }, undefined, this);\r\n        },\r\n        add: function (matrix, callback) {\r\n            var M = new Matrix();\r\n            if(this.sameSize(matrix)) {\r\n                this.eachElement(function (e, i, j) {\r\n                    var result = _.add(e.clone(), matrix.elements[i][j].clone());\r\n                    if(callback) {\r\n                        result = callback.call(M, result, e, matrix.elements[i][j]);\r\n                    }\r\n                    M.set(i, j, result);\r\n                });\r\n            }\r\n            return M;\r\n        },\r\n        subtract: function (matrix, callback) {\r\n            var M = new Matrix();\r\n            if(this.sameSize(matrix)) {\r\n                this.eachElement(function (e, i, j) {\r\n                    var result = _.subtract(e.clone(), matrix.elements[i][j].clone());\r\n                    if(callback) {\r\n                        result = callback.call(M, result, e, matrix.elements[i][j]);\r\n                    }\r\n                    M.set(i, j, result);\r\n                });\r\n            }\r\n            return M;\r\n        },\r\n        negate: function () {\r\n            this.each(function (e) {\r\n                return e.negate();\r\n            });\r\n            return this;\r\n        },\r\n        toVector: function () {\r\n            if(this.rows() === 1 || this.cols() === 1) {\r\n                var v = new Vector();\r\n                v.elements = this.elements;\r\n                return v;\r\n            }\r\n            return this;\r\n        },\r\n        toString: function (newline, to_decimal) {\r\n            var l = this.rows(),\r\n                    s = [];\r\n            newline = newline === undefined ? '\\n' : newline;\r\n            for(var i = 0; i < l; i++) {\r\n                s.push('[' + this.elements[i].map(function (x) {\r\n                    var v = to_decimal ? x.multiplier.toDecimal() : x.toString();\r\n                    return x !== undefined ? v : '';\r\n                }).join(',') + ']');\r\n            }\r\n            return 'matrix' + inBrackets(s.join(','));\r\n        },\r\n        text: function () {\r\n            return 'matrix(' + this.elements.toString('') + ')';\r\n        },\r\n        latex: function (option) {\r\n            var cols = this.cols(), elements = this.elements;\r\n            return format('\\\\begin{vmatrix}{0}\\\\end{vmatrix}', function () {\r\n                var tex = [];\r\n                for(var row in elements) {\r\n                    var row_tex = [];\r\n                    for(var i = 0; i < cols; i++) {\r\n                        row_tex.push(LaTeX.latex.call(LaTeX, elements[row][i], option));\r\n                    }\r\n                    tex.push(row_tex.join(' & '));\r\n                }\r\n                return tex.join(' \\\\cr ');\r\n            });\r\n        }\r\n    };\r\n    // aliases\r\n    Matrix.prototype.each = Matrix.prototype.eachElement;\r\n\r\n\r\n    function Set(set) {\r\n        this.elements = [];\r\n        // if the first object isn't an array, convert it to one.\r\n        if(!isVector(set))\r\n            set = Vector.fromArray(arguments);\r\n\r\n        if(set) {\r\n            var elements = set.elements;\r\n            for(var i = 0, l = elements.length; i < l; i++) {\r\n                this.add(elements[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    Set.fromArray = function (arr) {\r\n        function F(args) {\r\n            return Set.apply(this, args);\r\n        }\r\n        F.prototype = Set.prototype;\r\n\r\n        return new F(arr);\r\n    };\r\n\r\n    Set.prototype = {\r\n        add: function (x) {\r\n            if(!this.contains(x))\r\n                this.elements.push(x.clone());\r\n        },\r\n        contains: function (x) {\r\n            for(var i = 0; i < this.elements.length; i++) {\r\n                var e = this.elements[i];\r\n                if(x.equals(e))\r\n                    return true;\r\n            }\r\n            return false;\r\n        },\r\n        each: function (f) {\r\n            var elements = this.elements;\r\n            var set = new Set();\r\n            for(var i = 0, l = elements.length; i < l; i++) {\r\n                var e = elements[i];\r\n                f.call(this, e, set, i);\r\n            }\r\n            return set;\r\n        },\r\n        clone: function () {\r\n            var set = new Set();\r\n            this.each(function (e) {\r\n                set.add(e.clone());\r\n            });\r\n            return set;\r\n        },\r\n        union: function (set) {\r\n            var _union = this.clone();\r\n            set.each(function (e) {\r\n                _union.add(e);\r\n            });\r\n\r\n            return _union;\r\n        },\r\n        difference: function (set) {\r\n            var diff = this.clone();\r\n            set.each(function (e) {\r\n                diff.remove(e);\r\n            });\r\n            return diff;\r\n        },\r\n        remove: function (element) {\r\n            for(var i = 0, l = this.elements.length; i < l; i++) {\r\n                var e = this.elements[i];\r\n                if(e.equals(element)) {\r\n                    remove(this.elements, i);\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        },\r\n        intersection: function (set) {\r\n            var _intersection = new Set();\r\n            var A = this;\r\n            set.each(function (e) {\r\n                if(A.contains(e)) {\r\n                    _intersection.add(e);\r\n                }\r\n                ;\r\n            });\r\n\r\n            return _intersection;\r\n        },\r\n        intersects: function (set) {\r\n            return this.intersection(set).elements.length > 0;\r\n        },\r\n        is_subset: function (set) {\r\n            var elements = set.elements;\r\n            for(var i = 0, l = elements.length; i < l; i++) {\r\n                if(!this.contains(elements[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n        toString: function () {\r\n            return '{' + this.elements.join(',') + '}';\r\n        }\r\n    };\r\n\r\n//build ========================================================================\r\n    var Build = {\r\n        dependencies: {\r\n            _rename: {\r\n                'Math2.factorial': 'factorial'\r\n            },\r\n            factorial: {\r\n                'Math2.gamma': Math2.gamma\r\n            },\r\n            gamma_incomplete: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Li: {\r\n                'Math2.Ei': Math2.Ei,\r\n                'Math2.bigLog': Math2.bigLog,\r\n                'Frac': Frac\r\n            },\r\n            Ci: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Ei: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Si: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Shi: {\r\n                'Math2.factorial': Math2.factorial\r\n            },\r\n            Chi: {\r\n                'isInt': isInt,\r\n                'nround': nround,\r\n                'Math2.num_integrate': Math2.num_integrate\r\n            },\r\n            factor: {\r\n                'Math2.ifactor': Math2.ifactor,\r\n                'Symbol': Symbol\r\n            },\r\n            num_integrate: {\r\n                'Math2.simpson': Math2.simpson,\r\n                'nround': nround\r\n            },\r\n            fib: {\r\n                'even': even\r\n            }\r\n        },\r\n        /* Some functions need to be made numeric safe. Build checks if there's a\r\n         * reformat option and calls that instead when compiling the function string.\r\n         */\r\n        reformat: {\r\n            // this simply extends the build function\r\n            diff: function (symbol, deps) {\r\n                var v = symbol.args[1].toString();\r\n                var f = 'var f = ' + Build.build(symbol.args[0].toString(), [v]) + ';';\r\n                deps[1] += 'var diff = ' + Math2.diff.toString() + ';';\r\n                deps[1] += f;\r\n\r\n                return ['diff(f)(' + v + ')', deps];\r\n            }\r\n        },\r\n        getProperName: function (f) {\r\n            var map = {\r\n                continued_fraction: 'continuedFraction'\r\n            };\r\n            return map[f] || f;\r\n        },\r\n        // assumes that dependences are at max 2 levels\r\n        compileDependencies: function (f, deps) {\r\n            // grab the predefined dependiences\r\n            var dependencies = Build.dependencies[f];\r\n\r\n            // the dependency string\r\n            var dep_string = deps && deps[1] ? deps[1] : '';\r\n\r\n            // the functions to be replaced\r\n            var replacements = deps && deps[0] ? deps[0] : {};\r\n\r\n            // loop through them and add them to the list\r\n            for(var x in dependencies) {\r\n                if(typeof dependencies[x] === 'object')\r\n                    continue; // skip object\r\n                var components = x.split('.'); //Math.f becomes f\r\n                // if the function isn't part of an object then reference the function itself\r\n                dep_string += 'var ' + (components.length > 1 ? components[1] : components[0]) + '=' + dependencies[x] + ';';\r\n                replacements[x] = components.pop();\r\n            }\r\n\r\n            return [replacements, dep_string];\r\n        },\r\n        getArgsDeps: function (symbol, dependencies) {\r\n            var args = symbol.args;\r\n            for(var i = 0; i < args.length; i++) {\r\n                symbol.args[i].each(function (x) {\r\n                    if(x.group === FN)\r\n                        dependencies = Build.compileDependencies(x.fname, dependencies);\r\n                });\r\n            }\r\n            return dependencies;\r\n        },\r\n        build: function (symbol, arg_array) {\r\n            symbol = block('PARSE2NUMBER', function () {\r\n                return _.parse(symbol);\r\n            }, true);\r\n            var args = variables(symbol);\r\n            var supplements = [];\r\n            var dependencies = [];\r\n            var ftext = function (symbol, xports) {\r\n                //Fix for #545 - Parentheses confuse build.\r\n                if(symbol.fname === '') {\r\n                    symbol = Symbol.unwrapPARENS(symbol);\r\n                }\r\n                xports = xports || [];\r\n                var c = [],\r\n                        group = symbol.group,\r\n                        prefix = '';\r\n\r\n                var ftext_complex = function (group) {\r\n                    var d = group === CB ? '*' : '+',\r\n                            cc = [];\r\n\r\n                    for(var x in symbol.symbols) {\r\n                        var sym = symbol.symbols[x],\r\n                                ft = ftext(sym, xports)[0];\r\n                        // wrap it in brackets if it's group PL or CP\r\n                        if(sym.isComposite())\r\n                            ft = inBrackets(ft);\r\n                        cc.push(ft);\r\n                    }\r\n                    var retval = cc.join(d);\r\n                    retval = retval && !symbol.multiplier.equals(1) ? inBrackets(retval) : retval;\r\n                    return retval;\r\n                },\r\n                        ftext_function = function (bn) {\r\n                            var retval;\r\n                            if(bn in Math)\r\n                                retval = 'Math.' + bn;\r\n                            else {\r\n                                bn = Build.getProperName(bn);\r\n                                if(supplements.indexOf(bn) === -1) { // make sure you're not adding the function twice\r\n                                    //Math2 functions aren't part of the standard javascript\r\n                                    //Math library and must be exported.\r\n                                    xports.push('var ' + bn + ' = ' + Math2[bn].toString() + '; ');\r\n                                    supplements.push(bn);\r\n                                }\r\n                                retval = bn;\r\n                            }\r\n                            retval = retval + inBrackets(symbol.args.map(function (x) {\r\n                                return ftext(x, xports)[0];\r\n                            }).join(','));\r\n\r\n                            return retval;\r\n                        };\r\n\r\n                // the multiplier\r\n                if(group === N)\r\n                    c.push(symbol.multiplier.toDecimal());\r\n                else if(symbol.multiplier.equals(-1))\r\n                    prefix = '-';\r\n                else if(!symbol.multiplier.equals(1))\r\n                    c.push(symbol.multiplier.toDecimal());\r\n                // the value\r\n                var value;\r\n\r\n                if(group === S || group === P)\r\n                    value = symbol.value;\r\n                else if(group === FN) {\r\n                    dependencies = Build.compileDependencies(symbol.fname, dependencies);\r\n                    dependencies = Build.getArgsDeps(symbol, dependencies);\r\n                    if(Build.reformat[symbol.fname]) {\r\n                        var components = Build.reformat[symbol.fname](symbol, dependencies);\r\n                        dependencies = components[1];\r\n                        value = components[0];\r\n                    }\r\n                    else {\r\n                        value = ftext_function(symbol.fname);\r\n                    }\r\n\r\n                }\r\n                else if(group === EX) {\r\n                    var pg = symbol.previousGroup;\r\n                    if(pg === N || pg === S)\r\n                        value = symbol.value;\r\n                    else if(pg === FN) {\r\n                        value = ftext_function(symbol.fname);\r\n                        dependencies = Build.compileDependencies(symbol.fname, dependencies);\r\n                        dependencies = Build.getArgsDeps(symbol, dependencies);\r\n                    }\r\n                    else\r\n                        value = ftext_complex(symbol.previousGroup);\r\n                }\r\n                else {\r\n                    value = ftext_complex(symbol.group);\r\n                }\r\n\r\n                if(symbol.group !== N && !symbol.power.equals(1)) {\r\n                    var pow = ftext(_.parse(symbol.power));\r\n                    xports.push(pow[1]);\r\n                    value = 'Math.pow' + inBrackets(value + ',' + pow[0]);\r\n                }\r\n\r\n                if(value)\r\n                    c.push(prefix + value);\r\n\r\n                return [c.join('*'), xports.join('').replace(/\\n+\\s+/g, ' ')];\r\n            };\r\n            if(arg_array) {\r\n                // Fix for issue #546\r\n                // Disable argument checking since it's a bit presumptuous.\r\n                // Consider f(x) = 5; If I explicitely pass in an argument array contain x \r\n                // this check will fail and complain since the function doesn't contain x.\r\n                /*\r\n                 for (var i = 0; i < args.length; i++) {\r\n                 var arg = args[i];\r\n                 if (arg_array.indexOf(arg) === -1)\r\n                 err(arg + ' not found in argument array');\r\n                 }\r\n                 */\r\n                args = arg_array;\r\n            }\r\n\r\n            var f_array = ftext(symbol);\r\n\r\n            // make all the substitutions;\r\n            for(var x in dependencies[0]) {\r\n                var alias = dependencies[0][x];\r\n                f_array[1] = f_array[1].replace(x, alias);\r\n                dependencies[1] = dependencies[1].replace(x, alias);\r\n            }\r\n\r\n            var f = new Function(args, (dependencies[1] || '') + f_array[1] + ' return ' + f_array[0] + ';');\r\n\r\n            return f;\r\n        }\r\n    };\r\n\r\n\r\n//finalize =====================================================================\r\n    /* FINALIZE */\r\n    (function () {\r\n        reserveNames(_.CONSTANTS);\r\n        reserveNames(_.functions);\r\n        _.initConstants();\r\n        //bug fix for error but needs to be revisited\r\n        if(!_.error)\r\n            _.error = err;\r\n\r\n        //Store the log and log10 functions\r\n        Settings.LOG_FNS = {\r\n            log: _.functions['log'],\r\n            log10: _.functions['log10']\r\n        };\r\n\r\n    })();\r\n\r\n    /* END FINALIZE */\r\n\r\n//Core =========================================================================\r\n    var Utils = {\r\n        allSame: allSame,\r\n        allNumeric: allNumeric,\r\n        arguments2Array: arguments2Array,\r\n        arrayAddSlices: arrayAddSlices,\r\n        arrayClone: arrayClone,\r\n        arrayMax: arrayMax,\r\n        arrayMin: arrayMin,\r\n        arrayEqual: arrayEqual,\r\n        arrayUnique: arrayUnique,\r\n        arrayGetVariables: arrayGetVariables,\r\n        arraySum: arraySum,\r\n        block: block,\r\n        build: Build.build,\r\n        clearU: clearU,\r\n        comboSort: comboSort,\r\n        compare: compare,\r\n        convertToVector: convertToVector,\r\n        customError: customError,\r\n        customType: customType,\r\n        decompose_fn: decompose_fn,\r\n        each: each,\r\n        evaluate: evaluate,\r\n        even: even,\r\n        evenFraction: evenFraction,\r\n        fillHoles: fillHoles,\r\n        firstObject: firstObject,\r\n        format: format,\r\n        generatePrimes: generatePrimes,\r\n        getCoeffs: getCoeffs,\r\n        getU: getU,\r\n        importFunctions: importFunctions,\r\n        inBrackets: inBrackets,\r\n        isArray: isArray,\r\n        isExpression: isExpression,\r\n        isFraction: isFraction,\r\n        isInt: isInt,\r\n        isMatrix: isMatrix,\r\n        isNegative: isNegative,\r\n        isNumericSymbol: isNumericSymbol,\r\n        isPrime: isPrime,\r\n        isReserved: isReserved,\r\n        isSymbol: isSymbol,\r\n        isVariableSymbol: isVariableSymbol,\r\n        isVector: isVector,\r\n        keys: keys,\r\n        knownVariable: knownVariable,\r\n        nroots: nroots,\r\n        remove: remove,\r\n        reserveNames: reserveNames,\r\n        range: range,\r\n        round: nround,\r\n        sameSign: sameSign,\r\n        scientificToDecimal: scientificToDecimal,\r\n        separate: separate,\r\n        stringReplace: stringReplace,\r\n        text: text,\r\n        validateName: validateName,\r\n        variables: variables,\r\n        warn: warn\r\n    };\r\n\r\n    //This contains all the parts of nerdamer and enables nerdamer's internal functions\r\n    //to be used.\r\n    var C = {\r\n        groups: Groups,\r\n        Symbol: Symbol,\r\n        Expression: Expression,\r\n        Frac: Frac,\r\n        Vector: Vector,\r\n        Matrix: Matrix,\r\n        Parser: Parser,\r\n        Scientific: Scientific,\r\n        Fraction: Fraction,\r\n        Math2: Math2,\r\n        LaTeX: LaTeX,\r\n        Utils: Utils,\r\n        PARSER: _,\r\n        PARENTHESIS: PARENTHESIS,\r\n        Settings: Settings,\r\n        err: err,\r\n        bigInt: bigInt,\r\n        bigDec: bigDec,\r\n        exceptions: exceptions\r\n    };\r\n\r\n//libExports ===================================================================\r\n    /**\r\n     *\r\n     * @param {String} expression the expression to be evaluated\r\n     * @param {Object} subs the object containing the variable values\r\n     * @param {Integer} location a specific location in the equation list to\r\n     * insert the evaluated expression\r\n     * @param {String} option additional options\r\n     * @returns {Expression}\r\n     */\r\n    var libExports = function (expression, subs, option, location) {\r\n        // Initiate the numer flag\r\n        var numer = false;\r\n\r\n        // Is the user declaring a function?\r\n        var fndec = /^([a-z_][a-z\\d\\_]*)\\(([a-z_,\\s]*)\\):=(.+)$/gi.exec(expression);\r\n        if(fndec)\r\n            return nerdamer.setFunction(fndec[1], fndec[2].split(','), fndec[3]);\r\n\r\n        // var variable, fn, args;\r\n        // Convert any expression passed in to a string\r\n        if(expression instanceof Expression)\r\n            expression = expression.toString();\r\n\r\n        // Convert it to an array for simplicity\r\n        if(!isArray(option)) {\r\n            option = typeof option === 'undefined' ? [] : [option];\r\n        }\r\n\r\n        option.forEach(function (o) {\r\n            // Turn on the numer flag if requested\r\n            if(o === 'numer') {\r\n                numer = true;\r\n                return;\r\n            }\r\n            // Wrap it in a function if requested. This only holds true for\r\n            // functions that take a single argument which is the expression\r\n            var f = _.functions[option];\r\n            // If there's a function and it takes a single argument, then wrap\r\n            // the expression in it\r\n            if(f && f[1] === 1) {\r\n                expression = `${o}(${expression})`;\r\n            }\r\n        });\r\n\r\n        var e = block('PARSE2NUMBER', function () {\r\n            return _.parse(expression, subs);\r\n        }, numer || Settings.PARSE2NUMBER);\r\n\r\n        if(location) {\r\n            EXPRESSIONS[location - 1] = e;\r\n        }\r\n        else {\r\n            EXPRESSIONS.push(e);\r\n        }\r\n\r\n        return new Expression(e);\r\n    };\r\n    /**\r\n     * Converts expression into rpn form\r\n     * @param {String} expression\r\n     * @returns {Token[]}\r\n     */\r\n    libExports.rpn = function (expression) {\r\n        return _.tokenize(_.toRPN(expression));\r\n    };\r\n\r\n    /**\r\n     * Generates LaTeX from expression string\r\n     * @param {String} e\r\n     * @param {object} opt\r\n     * @returns {String}\r\n     */\r\n    libExports.convertToLaTeX = function (e, opt) {\r\n        return _.toTeX(e, opt);\r\n    };\r\n\r\n    /**\r\n     * Converts latex to text - Very very very basic at the moment\r\n     * @param {String} e\r\n     * @returns {String}\r\n     */\r\n    libExports.convertFromLaTeX = function (e) {\r\n        var txt = LaTeX.parse(_.tokenize(e));\r\n        return new Expression(_.parse(txt));\r\n    };\r\n\r\n    /**\r\n     * Get the version of nerdamer or a loaded add-on\r\n     * @param {String} add_on - The add-on being checked\r\n     * @returns {String} returns the version of nerdamer\r\n     */\r\n    libExports.version = function (add_on) {\r\n        if(add_on) {\r\n            try {\r\n                return C[add_on].version;\r\n            }\r\n            catch(e) {\r\n                return \"No module named \" + add_on + \" found!\";\r\n            }\r\n        }\r\n        return version;\r\n    };\r\n\r\n    /**\r\n     * Get nerdamer generated warnings\r\n     * @returns {String[]}\r\n     */\r\n    libExports.getWarnings = function () {\r\n        return WARNINGS;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {String} constant The name of the constant to be set\r\n     * @param {mixed} value The value of the constant\r\n     * @returns {Object} Returns the nerdamer object\r\n     */\r\n    libExports.setConstant = function (constant, value) {\r\n        validateName(constant);\r\n        if(!isReserved(constant)) {\r\n            //fix for issue #127\r\n            if(value === 'delete' || value === '') {\r\n                delete _.CONSTANTS[constant];\r\n            }\r\n            else {\r\n                if(isNaN(value))\r\n                    throw new NerdamerTypeError('Constant must be a number!');\r\n                _.CONSTANTS[constant] = value;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Returns the value of a previously set constant\r\n     * @param {type} constant\r\n     * @returns {String}\r\n     */\r\n    libExports.getConstant = function (constant) {\r\n        return String(_.constant[constant]);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {String} name The name of the function\r\n     * @param {Array} params_array A list containing the parameter name of the functions\r\n     * @param {String} body The body of the function\r\n     * @returns {Boolean} returns true if succeeded and falls on fail\r\n     * @example nerdamer.setFunction('f',['x'], 'x^2+2');\r\n     */\r\n    libExports.setFunction = setFunction;\r\n\r\n    /**\r\n     *\r\n     * @returns {C} Exports the nerdamer core functions and objects\r\n     */\r\n    libExports.getCore = function () {\r\n        return C;\r\n    };\r\n\r\n    libExports.getExpression = libExports.getEquation = Expression.getExpression;\r\n\r\n    /**\r\n     *\r\n     * @param {Boolean} asArray The returned names are returned as an array if this is set to true;\r\n     * @returns {String|Array}\r\n     */\r\n    libExports.reserved = function (asArray) {\r\n        if(asArray) {\r\n            return RESERVED;\r\n        }\r\n        return RESERVED.join(', ');\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {Integer} equation_number the number of the equation to clear.\r\n     * If 'all' is supplied then all equations are cleared\r\n     * @param {Boolean} keep_EXPRESSIONS_fixed use true if you don't want to keep EXPRESSIONS length fixed\r\n     * @returns {Object} Returns the nerdamer object\r\n     */\r\n    libExports.clear = function (equation_number, keep_EXPRESSIONS_fixed) {\r\n        if(equation_number === 'all') {\r\n            EXPRESSIONS = [];\r\n        }\r\n        else if(equation_number === 'last') {\r\n            EXPRESSIONS.pop();\r\n        }\r\n        else if(equation_number === 'first') {\r\n            EXPRESSIONS.shift();\r\n        }\r\n        else {\r\n            var index = !equation_number ? EXPRESSIONS.length : equation_number - 1;\r\n            keep_EXPRESSIONS_fixed === true ? EXPRESSIONS[index] = undefined : remove(EXPRESSIONS, index);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Alias for nerdamer.clear('all')\r\n     */\r\n    libExports.flush = function () {\r\n        this.clear('all');\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {Boolean} asObject\r\n     * @param {Boolean} asLaTeX\r\n     * @param {String|String[]} option\r\n     * @returns {Array}\r\n     */\r\n    libExports.expressions = function (asObject, asLaTeX, option) {\r\n        var result = asObject ? {} : [];\r\n        for(var i = 0; i < EXPRESSIONS.length; i++) {\r\n            var eq = asLaTeX ? LaTeX.latex(EXPRESSIONS[i], option) : text(EXPRESSIONS[i], option);\r\n            asObject ? result[i + 1] = eq : result.push(eq);\r\n        }\r\n        return result;\r\n    };\r\n\r\n    //the method for registering modules\r\n    libExports.register = function (obj) {\r\n        var core = this.getCore();\r\n\r\n        if(isArray(obj)) {\r\n            for(var i = 0; i < obj.length; i++) {\r\n                if(obj)\r\n                    this.register(obj[i]);\r\n            }\r\n        }\r\n        else if(obj && Settings.exclude.indexOf(obj.name) === -1) {\r\n            //make sure all the dependencies are available\r\n            if(obj.dependencies) {\r\n                for(var i = 0; i < obj.dependencies.length; i++)\r\n                    if(!core[obj.dependencies[i]])\r\n                        throw new Error(format('{0} requires {1} to be loaded!', obj.name, obj.dependencies[i]));\r\n            }\r\n            //if no parent object is provided then the function does not have an address and cannot be called directly\r\n            var parent_obj = obj.parent,\r\n                    fn = obj.build.call(core); //call constructor to get function\r\n            if(parent_obj) {\r\n                if(!core[parent_obj])\r\n                    core[obj.parent] = {};\r\n\r\n                var ref_obj = parent_obj === 'nerdamer' ? this : core[parent_obj];\r\n                //attach the function to the core\r\n                ref_obj[obj.name] = fn;\r\n            }\r\n            if(obj.visible)\r\n                _.functions[obj.name] = [fn, obj.numargs]; //make the function available\r\n\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {String} name variable name\r\n     * @returns {boolean} validates if the profided string is a valid variable name\r\n     */\r\n    libExports.validateName = validateName;\r\n\r\n    /**\r\n     * @param {String} varname variable name\r\n     * @returns {boolean} validates if the profided string is a valid variable name\r\n     */\r\n    libExports.validVarName = function (varname) {\r\n        try {\r\n            validateName(varname);\r\n            return RESERVED.indexOf(varname) === -1;\r\n        }\r\n        catch(e) {\r\n            return false;\r\n        }\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @returns {Array} Array of functions currently supported by nerdamer\r\n     */\r\n    libExports.supported = function () {\r\n        return keys(_.functions);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @returns {Number} The number equations/expressions currently loaded\r\n     */\r\n    libExports.numEquations = libExports.numExpressions = function () {\r\n        return EXPRESSIONS.length;\r\n    };\r\n    /* END EXPORTS */\r\n\r\n    /**\r\n     *\r\n     * @param {String} v variable to be set\r\n     * @param {String} val value of variable. This can be a variable expression or number\r\n     * @returns {Object} Returns the nerdamer object\r\n     */\r\n    libExports.setVar = function (v, val) {\r\n        validateName(v);\r\n        //check if it's not already a constant\r\n        if(v in _.CONSTANTS)\r\n            err('Cannot set value for constant ' + v);\r\n        if(val === 'delete' || val === '')\r\n            delete VARS[v];\r\n        else {\r\n            VARS[v] = isSymbol(val) ? val : _.parse(val);\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Returns the value of a set variable\r\n     * @param {type} v\r\n     * @returns {varies}\r\n     */\r\n    libExports.getVar = function (v) {\r\n        return VARS[v];\r\n    };\r\n    /**\r\n     * Clear the variables from the VARS object\r\n     * @returns {Object} Returns the nerdamer object\r\n     */\r\n    libExports.clearVars = function () {\r\n        VARS = {};\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {Function} loader\r\n     * @returns {nerdamer}\r\n     */\r\n    libExports.load = function (loader) {\r\n        loader.call(this);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * @param {String} output - output format. Can be 'object' (just returns the VARS object), 'text' or 'latex'. Default: 'text'\r\n     * @param {String|String[]} option\r\n     * @returns {Object} Returns an object with the variables\r\n     */\r\n    libExports.getVars = function (output, option) {\r\n        output = output || 'text';\r\n        var variables = {};\r\n        if(output === 'object')\r\n            variables = VARS;\r\n        else {\r\n            for(var v in VARS) {\r\n                if(output === 'latex') {\r\n                    variables[v] = VARS[v].latex(option);\r\n                }\r\n                else if(output === 'text') {\r\n                    variables[v] = VARS[v].text(option);\r\n                }\r\n            }\r\n        }\r\n        return variables;\r\n    };\r\n\r\n    /**\r\n     * Set the value of a setting\r\n     * @param {String} setting The setting to be changed\r\n     * @param {boolean} value\r\n     */\r\n    libExports.set = function (setting, value) {\r\n        //current options:\r\n        //PARSE2NUMBER, suppress_errors\r\n        if(typeof setting === 'object')\r\n            for(var x in setting) {\r\n                libExports.set(x, setting[x]);\r\n            }\r\n\r\n        var disallowed = ['SAFE'];\r\n        if(disallowed.indexOf(setting) !== -1)\r\n            err('Cannot modify setting: ' + setting);\r\n\r\n        if(setting === 'PRECISION') {\r\n            bigDec.set({precision: value});\r\n            Settings.PRECISION = value;\r\n\r\n            // Avoid that nerdamer puts out garbage after 21 decimal place\r\n            if(value > 21) {\r\n                this.set('USE_BIG', true);\r\n            }\r\n        }\r\n        else if(setting === 'USE_LN' && value === true) {\r\n            //set log as LN\r\n            Settings.LOG = 'LN';\r\n            //set log10 as log\r\n            Settings.LOG10 = 'log';\r\n            //point the functions in the right direction\r\n            _.functions['log'] = Settings.LOG_FNS.log10; //log is now log10\r\n            //the log10 function must be explicitly set\r\n            _.functions['log'][0] = function (x) {\r\n                if(x.isConstant())\r\n                    return new Symbol(Math.log10(x));\r\n                return _.symfunction(Settings.LOG10, [x]);\r\n            };\r\n            _.functions['LN'] = Settings.LOG_FNS.log; //LN is now log\r\n\r\n            //remove log10\r\n            delete _.functions['log10'];\r\n        }\r\n        else\r\n            Settings[setting] = value;\r\n    };\r\n\r\n    /**\r\n     * Get the value of a setting\r\n     * @param {type} setting\r\n     * @returns {undefined}\r\n     */\r\n    libExports.get = function (setting) {\r\n        return Settings[setting];\r\n    };\r\n\r\n    /**\r\n     * This functions makes internal functions available externally\r\n     * @param {bool} override Override the functions when calling api if it exists\r\n     */\r\n    libExports.api = function (override) {\r\n        //Map internal functions to external ones\r\n        var linker = function (fname) {\r\n            return function () {\r\n                var args = [].slice.call(arguments);\r\n                for(var i = 0; i < args.length; i++)\r\n                    args[i] = _.parse(args[i]);\r\n                return new Expression(block('PARSE2NUMBER', function () {\r\n                    return _.callfunction(fname, args);\r\n                }));\r\n            };\r\n        };\r\n        //perform the mapping\r\n        for(var x in _.functions)\r\n            if(!(x in libExports) || override)\r\n                libExports[x] = linker(x);\r\n    };\r\n\r\n    libExports.replaceFunction = function (name, fn, num_args) {\r\n        var existing = _.functions[name];\r\n        var new_num_args = typeof num_args === 'undefined' ? existing[1] : num_args;\r\n        _.functions[name] = [fn.call(undefined, existing[0], C), new_num_args];\r\n    };\r\n\r\n    libExports.setOperator = function (operator, shift) {\r\n        _.setOperator(operator, shift);\r\n    };\r\n\r\n    libExports.getOperator = function (operator) {\r\n        return _.getOperator(operator);\r\n    };\r\n\r\n    libExports.aliasOperator = function (operator, withOperator) {\r\n        _.aliasOperator(operator, withOperator);\r\n    };\r\n\r\n    libExports.tree = function (expression) {\r\n        return _.tree(_.toRPN(_.tokenize(expression)));\r\n    };\r\n\r\n    libExports.htmlTree = function (expression, indent) {\r\n        var tree = this.tree(expression);\r\n\r\n        return '<div class=\"tree\">\\n' +\r\n                '    <ul>\\n' +\r\n                '        <li>\\n' +\r\n                tree.toHTML(3, indent) + '\\n' +\r\n                '        </li>\\n' +\r\n                '    </ul>\\n' +\r\n                '</div>';\r\n    };\r\n\r\n    libExports.addPeeker = function (name, f) {\r\n        if(_.peekers[name])\r\n            _.peekers[name].push(f);\r\n    };\r\n\r\n    libExports.removePeeker = function (name, f) {\r\n        remove(_.peekers[name], f);\r\n    };\r\n\r\n    libExports.parse = function (e) {\r\n        return String(e).split(';').map(function (x) {\r\n            return _.parse(x);\r\n        });\r\n    };\r\n\r\n    libExports.api();\r\n\r\n    return libExports; //Done\r\n//imports ======================================================================\r\n})({\r\n    //https://github.com/peterolson/BigInteger.js\r\n    bigInt: (function(){\r\n        var bigInt=function(undefined){\"use strict\";var BASE=1e7,LOG_BASE=7,MAX_INT=9007199254740992,MAX_INT_ARR=smallToArray(MAX_INT),LOG_MAX_INT=Math.log(MAX_INT);function Integer(v,radix){if(typeof v===\"undefined\")return Integer[0];if(typeof radix!==\"undefined\")return+radix===10?parseValue(v):parseBase(v,radix);return parseValue(v)}function BigInteger(value,sign){this.value=value;this.sign=sign;this.isSmall=false}BigInteger.prototype=Object.create(Integer.prototype);function SmallInteger(value){this.value=value;this.sign=value<0;this.isSmall=true}SmallInteger.prototype=Object.create(Integer.prototype);function isPrecise(n){return-MAX_INT<n&&n<MAX_INT}function smallToArray(n){if(n<1e7)return[n];if(n<1e14)return[n%1e7,Math.floor(n/1e7)];return[n%1e7,Math.floor(n/1e7)%1e7,Math.floor(n/1e14)]}function arrayToSmall(arr){trim(arr);var length=arr.length;if(length<4&&compareAbs(arr,MAX_INT_ARR)<0){switch(length){case 0:return 0;case 1:return arr[0];case 2:return arr[0]+arr[1]*BASE;default:return arr[0]+(arr[1]+arr[2]*BASE)*BASE}}return arr}function trim(v){var i=v.length;while(v[--i]===0);v.length=i+1}function createArray(length){var x=new Array(length);var i=-1;while(++i<length){x[i]=0}return x}function truncate(n){if(n>0)return Math.floor(n);return Math.ceil(n)}function add(a,b){var l_a=a.length,l_b=b.length,r=new Array(l_a),carry=0,base=BASE,sum,i;for(i=0;i<l_b;i++){sum=a[i]+b[i]+carry;carry=sum>=base?1:0;r[i]=sum-carry*base}while(i<l_a){sum=a[i]+carry;carry=sum===base?1:0;r[i++]=sum-carry*base}if(carry>0)r.push(carry);return r}function addAny(a,b){if(a.length>=b.length)return add(a,b);return add(b,a)}function addSmall(a,carry){var l=a.length,r=new Array(l),base=BASE,sum,i;for(i=0;i<l;i++){sum=a[i]-base+carry;carry=Math.floor(sum/base);r[i]=sum-carry*base;carry+=1}while(carry>0){r[i++]=carry%base;carry=Math.floor(carry/base)}return r}BigInteger.prototype.add=function(v){var n=parseValue(v);if(this.sign!==n.sign){return this.subtract(n.negate())}var a=this.value,b=n.value;if(n.isSmall){return new BigInteger(addSmall(a,Math.abs(b)),this.sign)}return new BigInteger(addAny(a,b),this.sign)};BigInteger.prototype.plus=BigInteger.prototype.add;SmallInteger.prototype.add=function(v){var n=parseValue(v);var a=this.value;if(a<0!==n.sign){return this.subtract(n.negate())}var b=n.value;if(n.isSmall){if(isPrecise(a+b))return new SmallInteger(a+b);b=smallToArray(Math.abs(b))}return new BigInteger(addSmall(b,Math.abs(a)),a<0)};SmallInteger.prototype.plus=SmallInteger.prototype.add;function subtract(a,b){var a_l=a.length,b_l=b.length,r=new Array(a_l),borrow=0,base=BASE,i,difference;for(i=0;i<b_l;i++){difference=a[i]-borrow-b[i];if(difference<0){difference+=base;borrow=1}else borrow=0;r[i]=difference}for(i=b_l;i<a_l;i++){difference=a[i]-borrow;if(difference<0)difference+=base;else{r[i++]=difference;break}r[i]=difference}for(;i<a_l;i++){r[i]=a[i]}trim(r);return r}function subtractAny(a,b,sign){var value;if(compareAbs(a,b)>=0){value=subtract(a,b)}else{value=subtract(b,a);sign=!sign}value=arrayToSmall(value);if(typeof value===\"number\"){if(sign)value=-value;return new SmallInteger(value)}return new BigInteger(value,sign)}function subtractSmall(a,b,sign){var l=a.length,r=new Array(l),carry=-b,base=BASE,i,difference;for(i=0;i<l;i++){difference=a[i]+carry;carry=Math.floor(difference/base);difference%=base;r[i]=difference<0?difference+base:difference}r=arrayToSmall(r);if(typeof r===\"number\"){if(sign)r=-r;return new SmallInteger(r)}return new BigInteger(r,sign)}BigInteger.prototype.subtract=function(v){var n=parseValue(v);if(this.sign!==n.sign){return this.add(n.negate())}var a=this.value,b=n.value;if(n.isSmall)return subtractSmall(a,Math.abs(b),this.sign);return subtractAny(a,b,this.sign)};BigInteger.prototype.minus=BigInteger.prototype.subtract;SmallInteger.prototype.subtract=function(v){var n=parseValue(v);var a=this.value;if(a<0!==n.sign){return this.add(n.negate())}var b=n.value;if(n.isSmall){return new SmallInteger(a-b)}return subtractSmall(b,Math.abs(a),a>=0)};SmallInteger.prototype.minus=SmallInteger.prototype.subtract;BigInteger.prototype.negate=function(){return new BigInteger(this.value,!this.sign)};SmallInteger.prototype.negate=function(){var sign=this.sign;var small=new SmallInteger(-this.value);small.sign=!sign;return small};BigInteger.prototype.abs=function(){return new BigInteger(this.value,false)};SmallInteger.prototype.abs=function(){return new SmallInteger(Math.abs(this.value))};function multiplyLong(a,b){var a_l=a.length,b_l=b.length,l=a_l+b_l,r=createArray(l),base=BASE,product,carry,i,a_i,b_j;for(i=0;i<a_l;++i){a_i=a[i];for(var j=0;j<b_l;++j){b_j=b[j];product=a_i*b_j+r[i+j];carry=Math.floor(product/base);r[i+j]=product-carry*base;r[i+j+1]+=carry}}trim(r);return r}function multiplySmall(a,b){var l=a.length,r=new Array(l),base=BASE,carry=0,product,i;for(i=0;i<l;i++){product=a[i]*b+carry;carry=Math.floor(product/base);r[i]=product-carry*base}while(carry>0){r[i++]=carry%base;carry=Math.floor(carry/base)}return r}function shiftLeft(x,n){var r=[];while(n-- >0)r.push(0);return r.concat(x)}function multiplyKaratsuba(x,y){var n=Math.max(x.length,y.length);if(n<=30)return multiplyLong(x,y);n=Math.ceil(n/2);var b=x.slice(n),a=x.slice(0,n),d=y.slice(n),c=y.slice(0,n);var ac=multiplyKaratsuba(a,c),bd=multiplyKaratsuba(b,d),abcd=multiplyKaratsuba(addAny(a,b),addAny(c,d));var product=addAny(addAny(ac,shiftLeft(subtract(subtract(abcd,ac),bd),n)),shiftLeft(bd,2*n));trim(product);return product}function useKaratsuba(l1,l2){return-.012*l1-.012*l2+15e-6*l1*l2>0}BigInteger.prototype.multiply=function(v){var n=parseValue(v),a=this.value,b=n.value,sign=this.sign!==n.sign,abs;if(n.isSmall){if(b===0)return Integer[0];if(b===1)return this;if(b===-1)return this.negate();abs=Math.abs(b);if(abs<BASE){return new BigInteger(multiplySmall(a,abs),sign)}b=smallToArray(abs)}if(useKaratsuba(a.length,b.length))return new BigInteger(multiplyKaratsuba(a,b),sign);return new BigInteger(multiplyLong(a,b),sign)};BigInteger.prototype.times=BigInteger.prototype.multiply;function multiplySmallAndArray(a,b,sign){if(a<BASE){return new BigInteger(multiplySmall(b,a),sign)}return new BigInteger(multiplyLong(b,smallToArray(a)),sign)}SmallInteger.prototype._multiplyBySmall=function(a){if(isPrecise(a.value*this.value)){return new SmallInteger(a.value*this.value)}return multiplySmallAndArray(Math.abs(a.value),smallToArray(Math.abs(this.value)),this.sign!==a.sign)};BigInteger.prototype._multiplyBySmall=function(a){if(a.value===0)return Integer[0];if(a.value===1)return this;if(a.value===-1)return this.negate();return multiplySmallAndArray(Math.abs(a.value),this.value,this.sign!==a.sign)};SmallInteger.prototype.multiply=function(v){return parseValue(v)._multiplyBySmall(this)};SmallInteger.prototype.times=SmallInteger.prototype.multiply;function square(a){var l=a.length,r=createArray(l+l),base=BASE,product,carry,i,a_i,a_j;for(i=0;i<l;i++){a_i=a[i];carry=0-a_i*a_i;for(var j=i;j<l;j++){a_j=a[j];product=2*(a_i*a_j)+r[i+j]+carry;carry=Math.floor(product/base);r[i+j]=product-carry*base}r[i+l]=carry}trim(r);return r}BigInteger.prototype.square=function(){return new BigInteger(square(this.value),false)};SmallInteger.prototype.square=function(){var value=this.value*this.value;if(isPrecise(value))return new SmallInteger(value);return new BigInteger(square(smallToArray(Math.abs(this.value))),false)};function divMod1(a,b){var a_l=a.length,b_l=b.length,base=BASE,result=createArray(b.length),divisorMostSignificantDigit=b[b_l-1],lambda=Math.ceil(base/(2*divisorMostSignificantDigit)),remainder=multiplySmall(a,lambda),divisor=multiplySmall(b,lambda),quotientDigit,shift,carry,borrow,i,l,q;if(remainder.length<=a_l)remainder.push(0);divisor.push(0);divisorMostSignificantDigit=divisor[b_l-1];for(shift=a_l-b_l;shift>=0;shift--){quotientDigit=base-1;if(remainder[shift+b_l]!==divisorMostSignificantDigit){quotientDigit=Math.floor((remainder[shift+b_l]*base+remainder[shift+b_l-1])/divisorMostSignificantDigit)}carry=0;borrow=0;l=divisor.length;for(i=0;i<l;i++){carry+=quotientDigit*divisor[i];q=Math.floor(carry/base);borrow+=remainder[shift+i]-(carry-q*base);carry=q;if(borrow<0){remainder[shift+i]=borrow+base;borrow=-1}else{remainder[shift+i]=borrow;borrow=0}}while(borrow!==0){quotientDigit-=1;carry=0;for(i=0;i<l;i++){carry+=remainder[shift+i]-base+divisor[i];if(carry<0){remainder[shift+i]=carry+base;carry=0}else{remainder[shift+i]=carry;carry=1}}borrow+=carry}result[shift]=quotientDigit}remainder=divModSmall(remainder,lambda)[0];return[arrayToSmall(result),arrayToSmall(remainder)]}function divMod2(a,b){var a_l=a.length,b_l=b.length,result=[],part=[],base=BASE,guess,xlen,highx,highy,check;while(a_l){part.unshift(a[--a_l]);trim(part);if(compareAbs(part,b)<0){result.push(0);continue}xlen=part.length;highx=part[xlen-1]*base+part[xlen-2];highy=b[b_l-1]*base+b[b_l-2];if(xlen>b_l){highx=(highx+1)*base}guess=Math.ceil(highx/highy);do{check=multiplySmall(b,guess);if(compareAbs(check,part)<=0)break;guess--}while(guess);result.push(guess);part=subtract(part,check)}result.reverse();return[arrayToSmall(result),arrayToSmall(part)]}function divModSmall(value,lambda){var length=value.length,quotient=createArray(length),base=BASE,i,q,remainder,divisor;remainder=0;for(i=length-1;i>=0;--i){divisor=remainder*base+value[i];q=truncate(divisor/lambda);remainder=divisor-q*lambda;quotient[i]=q|0}return[quotient,remainder|0]}function divModAny(self,v){var value,n=parseValue(v);var a=self.value,b=n.value;var quotient;if(b===0)throw new Error(\"Cannot divide by zero\");if(self.isSmall){if(n.isSmall){return[new SmallInteger(truncate(a/b)),new SmallInteger(a%b)]}return[Integer[0],self]}if(n.isSmall){if(b===1)return[self,Integer[0]];if(b==-1)return[self.negate(),Integer[0]];var abs=Math.abs(b);if(abs<BASE){value=divModSmall(a,abs);quotient=arrayToSmall(value[0]);var remainder=value[1];if(self.sign)remainder=-remainder;if(typeof quotient===\"number\"){if(self.sign!==n.sign)quotient=-quotient;return[new SmallInteger(quotient),new SmallInteger(remainder)]}return[new BigInteger(quotient,self.sign!==n.sign),new SmallInteger(remainder)]}b=smallToArray(abs)}var comparison=compareAbs(a,b);if(comparison===-1)return[Integer[0],self];if(comparison===0)return[Integer[self.sign===n.sign?1:-1],Integer[0]];if(a.length+b.length<=200)value=divMod1(a,b);else value=divMod2(a,b);quotient=value[0];var qSign=self.sign!==n.sign,mod=value[1],mSign=self.sign;if(typeof quotient===\"number\"){if(qSign)quotient=-quotient;quotient=new SmallInteger(quotient)}else quotient=new BigInteger(quotient,qSign);if(typeof mod===\"number\"){if(mSign)mod=-mod;mod=new SmallInteger(mod)}else mod=new BigInteger(mod,mSign);return[quotient,mod]}BigInteger.prototype.divmod=function(v){var result=divModAny(this,v);return{quotient:result[0],remainder:result[1]}};SmallInteger.prototype.divmod=BigInteger.prototype.divmod;BigInteger.prototype.divide=function(v){return divModAny(this,v)[0]};SmallInteger.prototype.over=SmallInteger.prototype.divide=BigInteger.prototype.over=BigInteger.prototype.divide;BigInteger.prototype.mod=function(v){return divModAny(this,v)[1]};SmallInteger.prototype.remainder=SmallInteger.prototype.mod=BigInteger.prototype.remainder=BigInteger.prototype.mod;BigInteger.prototype.pow=function(v){var n=parseValue(v),a=this.value,b=n.value,value,x,y;if(b===0)return Integer[1];if(a===0)return Integer[0];if(a===1)return Integer[1];if(a===-1)return n.isEven()?Integer[1]:Integer[-1];if(n.sign){return Integer[0]}if(!n.isSmall)throw new Error(\"The exponent \"+n.toString()+\" is too large.\");if(this.isSmall){if(isPrecise(value=Math.pow(a,b)))return new SmallInteger(truncate(value))}x=this;y=Integer[1];while(true){if(b&1===1){y=y.times(x);--b}if(b===0)break;b/=2;x=x.square()}return y};SmallInteger.prototype.pow=BigInteger.prototype.pow;BigInteger.prototype.modPow=function(exp,mod){exp=parseValue(exp);mod=parseValue(mod);if(mod.isZero())throw new Error(\"Cannot take modPow with modulus 0\");var r=Integer[1],base=this.mod(mod);while(exp.isPositive()){if(base.isZero())return Integer[0];if(exp.isOdd())r=r.multiply(base).mod(mod);exp=exp.divide(2);base=base.square().mod(mod)}return r};SmallInteger.prototype.modPow=BigInteger.prototype.modPow;function compareAbs(a,b){if(a.length!==b.length){return a.length>b.length?1:-1}for(var i=a.length-1;i>=0;i--){if(a[i]!==b[i])return a[i]>b[i]?1:-1}return 0}BigInteger.prototype.compareAbs=function(v){var n=parseValue(v),a=this.value,b=n.value;if(n.isSmall)return 1;return compareAbs(a,b)};SmallInteger.prototype.compareAbs=function(v){var n=parseValue(v),a=Math.abs(this.value),b=n.value;if(n.isSmall){b=Math.abs(b);return a===b?0:a>b?1:-1}return-1};BigInteger.prototype.compare=function(v){if(v===Infinity){return-1}if(v===-Infinity){return 1}var n=parseValue(v),a=this.value,b=n.value;if(this.sign!==n.sign){return n.sign?1:-1}if(n.isSmall){return this.sign?-1:1}return compareAbs(a,b)*(this.sign?-1:1)};BigInteger.prototype.compareTo=BigInteger.prototype.compare;SmallInteger.prototype.compare=function(v){if(v===Infinity){return-1}if(v===-Infinity){return 1}var n=parseValue(v),a=this.value,b=n.value;if(n.isSmall){return a==b?0:a>b?1:-1}if(a<0!==n.sign){return a<0?-1:1}return a<0?1:-1};SmallInteger.prototype.compareTo=SmallInteger.prototype.compare;BigInteger.prototype.equals=function(v){return this.compare(v)===0};SmallInteger.prototype.eq=SmallInteger.prototype.equals=BigInteger.prototype.eq=BigInteger.prototype.equals;BigInteger.prototype.notEquals=function(v){return this.compare(v)!==0};SmallInteger.prototype.neq=SmallInteger.prototype.notEquals=BigInteger.prototype.neq=BigInteger.prototype.notEquals;BigInteger.prototype.greater=function(v){return this.compare(v)>0};SmallInteger.prototype.gt=SmallInteger.prototype.greater=BigInteger.prototype.gt=BigInteger.prototype.greater;BigInteger.prototype.lesser=function(v){return this.compare(v)<0};SmallInteger.prototype.lt=SmallInteger.prototype.lesser=BigInteger.prototype.lt=BigInteger.prototype.lesser;BigInteger.prototype.greaterOrEquals=function(v){return this.compare(v)>=0};SmallInteger.prototype.geq=SmallInteger.prototype.greaterOrEquals=BigInteger.prototype.geq=BigInteger.prototype.greaterOrEquals;BigInteger.prototype.lesserOrEquals=function(v){return this.compare(v)<=0};SmallInteger.prototype.leq=SmallInteger.prototype.lesserOrEquals=BigInteger.prototype.leq=BigInteger.prototype.lesserOrEquals;BigInteger.prototype.isEven=function(){return(this.value[0]&1)===0};SmallInteger.prototype.isEven=function(){return(this.value&1)===0};BigInteger.prototype.isOdd=function(){return(this.value[0]&1)===1};SmallInteger.prototype.isOdd=function(){return(this.value&1)===1};BigInteger.prototype.isPositive=function(){return!this.sign};SmallInteger.prototype.isPositive=function(){return this.value>0};BigInteger.prototype.isNegative=function(){return this.sign};SmallInteger.prototype.isNegative=function(){return this.value<0};BigInteger.prototype.isUnit=function(){return false};SmallInteger.prototype.isUnit=function(){return Math.abs(this.value)===1};BigInteger.prototype.isZero=function(){return false};SmallInteger.prototype.isZero=function(){return this.value===0};BigInteger.prototype.isDivisibleBy=function(v){var n=parseValue(v);var value=n.value;if(value===0)return false;if(value===1)return true;if(value===2)return this.isEven();return this.mod(n).equals(Integer[0])};SmallInteger.prototype.isDivisibleBy=BigInteger.prototype.isDivisibleBy;function isBasicPrime(v){var n=v.abs();if(n.isUnit())return false;if(n.equals(2)||n.equals(3)||n.equals(5))return true;if(n.isEven()||n.isDivisibleBy(3)||n.isDivisibleBy(5))return false;if(n.lesser(49))return true}function millerRabinTest(n,a){var nPrev=n.prev(),b=nPrev,r=0,d,t,i,x;while(b.isEven())b=b.divide(2),r++;next:for(i=0;i<a.length;i++){if(n.lesser(a[i]))continue;x=bigInt(a[i]).modPow(b,n);if(x.equals(Integer[1])||x.equals(nPrev))continue;for(d=r-1;d!=0;d--){x=x.square().mod(n);if(x.isUnit())return false;if(x.equals(nPrev))continue next}return false}return true}BigInteger.prototype.isPrime=function(strict){var isPrime=isBasicPrime(this);if(isPrime!==undefined)return isPrime;var n=this.abs();var bits=n.bitLength();if(bits<=64)return millerRabinTest(n,[2,325,9375,28178,450775,9780504,1795265022]);var logN=Math.log(2)*bits;var t=Math.ceil(strict===true?2*Math.pow(logN,2):logN);for(var a=[],i=0;i<t;i++){a.push(bigInt(i+2))}return millerRabinTest(n,a)};SmallInteger.prototype.isPrime=BigInteger.prototype.isPrime;BigInteger.prototype.isProbablePrime=function(iterations){var isPrime=isBasicPrime(this);if(isPrime!==undefined)return isPrime;var n=this.abs();var t=iterations===undefined?5:iterations;for(var a=[],i=0;i<t;i++){a.push(bigInt.randBetween(2,n.minus(2)))}return millerRabinTest(n,a)};SmallInteger.prototype.isProbablePrime=BigInteger.prototype.isProbablePrime;BigInteger.prototype.modInv=function(n){var t=bigInt.zero,newT=bigInt.one,r=parseValue(n),newR=this.abs(),q,lastT,lastR;while(!newR.equals(bigInt.zero)){q=r.divide(newR);lastT=t;lastR=r;t=newT;r=newR;newT=lastT.subtract(q.multiply(newT));newR=lastR.subtract(q.multiply(newR))}if(!r.equals(1))throw new Error(this.toString()+\" and \"+n.toString()+\" are not co-prime\");if(t.compare(0)===-1){t=t.add(n)}if(this.isNegative()){return t.negate()}return t};SmallInteger.prototype.modInv=BigInteger.prototype.modInv;BigInteger.prototype.next=function(){var value=this.value;if(this.sign){return subtractSmall(value,1,this.sign)}return new BigInteger(addSmall(value,1),this.sign)};SmallInteger.prototype.next=function(){var value=this.value;if(value+1<MAX_INT)return new SmallInteger(value+1);return new BigInteger(MAX_INT_ARR,false)};BigInteger.prototype.prev=function(){var value=this.value;if(this.sign){return new BigInteger(addSmall(value,1),true)}return subtractSmall(value,1,this.sign)};SmallInteger.prototype.prev=function(){var value=this.value;if(value-1>-MAX_INT)return new SmallInteger(value-1);return new BigInteger(MAX_INT_ARR,true)};var powersOfTwo=[1];while(2*powersOfTwo[powersOfTwo.length-1]<=BASE)powersOfTwo.push(2*powersOfTwo[powersOfTwo.length-1]);var powers2Length=powersOfTwo.length,highestPower2=powersOfTwo[powers2Length-1];function shift_isSmall(n){return(typeof n===\"number\"||typeof n===\"string\")&&+Math.abs(n)<=BASE||n instanceof BigInteger&&n.value.length<=1}BigInteger.prototype.shiftLeft=function(n){if(!shift_isSmall(n)){throw new Error(String(n)+\" is too large for shifting.\")}n=+n;if(n<0)return this.shiftRight(-n);var result=this;if(result.isZero())return result;while(n>=powers2Length){result=result.multiply(highestPower2);n-=powers2Length-1}return result.multiply(powersOfTwo[n])};SmallInteger.prototype.shiftLeft=BigInteger.prototype.shiftLeft;BigInteger.prototype.shiftRight=function(n){var remQuo;if(!shift_isSmall(n)){throw new Error(String(n)+\" is too large for shifting.\")}n=+n;if(n<0)return this.shiftLeft(-n);var result=this;while(n>=powers2Length){if(result.isZero()||result.isNegative()&&result.isUnit())return result;remQuo=divModAny(result,highestPower2);result=remQuo[1].isNegative()?remQuo[0].prev():remQuo[0];n-=powers2Length-1}remQuo=divModAny(result,powersOfTwo[n]);return remQuo[1].isNegative()?remQuo[0].prev():remQuo[0]};SmallInteger.prototype.shiftRight=BigInteger.prototype.shiftRight;function bitwise(x,y,fn){y=parseValue(y);var xSign=x.isNegative(),ySign=y.isNegative();var xRem=xSign?x.not():x,yRem=ySign?y.not():y;var xDigit=0,yDigit=0;var xDivMod=null,yDivMod=null;var result=[];while(!xRem.isZero()||!yRem.isZero()){xDivMod=divModAny(xRem,highestPower2);xDigit=xDivMod[1].toJSNumber();if(xSign){xDigit=highestPower2-1-xDigit}yDivMod=divModAny(yRem,highestPower2);yDigit=yDivMod[1].toJSNumber();if(ySign){yDigit=highestPower2-1-yDigit}xRem=xDivMod[0];yRem=yDivMod[0];result.push(fn(xDigit,yDigit))}var sum=fn(xSign?1:0,ySign?1:0)!==0?bigInt(-1):bigInt(0);for(var i=result.length-1;i>=0;i-=1){sum=sum.multiply(highestPower2).add(bigInt(result[i]))}return sum}BigInteger.prototype.not=function(){return this.negate().prev()};SmallInteger.prototype.not=BigInteger.prototype.not;BigInteger.prototype.and=function(n){return bitwise(this,n,function(a,b){return a&b})};SmallInteger.prototype.and=BigInteger.prototype.and;BigInteger.prototype.or=function(n){return bitwise(this,n,function(a,b){return a|b})};SmallInteger.prototype.or=BigInteger.prototype.or;BigInteger.prototype.xor=function(n){return bitwise(this,n,function(a,b){return a^b})};SmallInteger.prototype.xor=BigInteger.prototype.xor;var LOBMASK_I=1<<30,LOBMASK_BI=(BASE&-BASE)*(BASE&-BASE)|LOBMASK_I;function roughLOB(n){var v=n.value,x=typeof v===\"number\"?v|LOBMASK_I:v[0]+v[1]*BASE|LOBMASK_BI;return x&-x}function integerLogarithm(value,base){if(base.compareTo(value)<=0){var tmp=integerLogarithm(value,base.square(base));var p=tmp.p;var e=tmp.e;var t=p.multiply(base);return t.compareTo(value)<=0?{p:t,e:e*2+1}:{p:p,e:e*2}}return{p:bigInt(1),e:0}}BigInteger.prototype.bitLength=function(){var n=this;if(n.compareTo(bigInt(0))<0){n=n.negate().subtract(bigInt(1))}if(n.compareTo(bigInt(0))===0){return bigInt(0)}return bigInt(integerLogarithm(n,bigInt(2)).e).add(bigInt(1))};SmallInteger.prototype.bitLength=BigInteger.prototype.bitLength;function max(a,b){a=parseValue(a);b=parseValue(b);return a.greater(b)?a:b}function min(a,b){a=parseValue(a);b=parseValue(b);return a.lesser(b)?a:b}function gcd(a,b){a=parseValue(a).abs();b=parseValue(b).abs();if(a.equals(b))return a;if(a.isZero())return b;if(b.isZero())return a;var c=Integer[1],d,t;while(a.isEven()&&b.isEven()){d=Math.min(roughLOB(a),roughLOB(b));a=a.divide(d);b=b.divide(d);c=c.multiply(d)}while(a.isEven()){a=a.divide(roughLOB(a))}do{while(b.isEven()){b=b.divide(roughLOB(b))}if(a.greater(b)){t=b;b=a;a=t}b=b.subtract(a)}while(!b.isZero());return c.isUnit()?a:a.multiply(c)}function lcm(a,b){a=parseValue(a).abs();b=parseValue(b).abs();return a.divide(gcd(a,b)).multiply(b)}function randBetween(a,b){a=parseValue(a);b=parseValue(b);var low=min(a,b),high=max(a,b);var range=high.subtract(low).add(1);if(range.isSmall)return low.add(Math.floor(Math.random()*range));var length=range.value.length-1;var result=[],restricted=true;for(var i=length;i>=0;i--){var top=restricted?range.value[i]:BASE;var digit=truncate(Math.random()*top);result.unshift(digit);if(digit<top)restricted=false}result=arrayToSmall(result);return low.add(typeof result===\"number\"?new SmallInteger(result):new BigInteger(result,false))}var parseBase=function(text,base){var length=text.length;var i;var absBase=Math.abs(base);for(var i=0;i<length;i++){var c=text[i].toLowerCase();if(c===\"-\")continue;if(/[a-z0-9]/.test(c)){if(/[0-9]/.test(c)&&+c>=absBase){if(c===\"1\"&&absBase===1)continue;throw new Error(c+\" is not a valid digit in base \"+base+\".\")}else if(c.charCodeAt(0)-87>=absBase){throw new Error(c+\" is not a valid digit in base \"+base+\".\")}}}if(2<=base&&base<=36){if(length<=LOG_MAX_INT/Math.log(base)){var result=parseInt(text,base);if(isNaN(result)){throw new Error(c+\" is not a valid digit in base \"+base+\".\")}return new SmallInteger(parseInt(text,base))}}base=parseValue(base);var digits=[];var isNegative=text[0]===\"-\";for(i=isNegative?1:0;i<text.length;i++){var c=text[i].toLowerCase(),charCode=c.charCodeAt(0);if(48<=charCode&&charCode<=57)digits.push(parseValue(c));else if(97<=charCode&&charCode<=122)digits.push(parseValue(c.charCodeAt(0)-87));else if(c===\"<\"){var start=i;do{i++}while(text[i]!==\">\");digits.push(parseValue(text.slice(start+1,i)))}else throw new Error(c+\" is not a valid character\")}return parseBaseFromArray(digits,base,isNegative)};function parseBaseFromArray(digits,base,isNegative){var val=Integer[0],pow=Integer[1],i;for(i=digits.length-1;i>=0;i--){val=val.add(digits[i].times(pow));pow=pow.times(base)}return isNegative?val.negate():val}function stringify(digit){if(digit<=35){return\"0123456789abcdefghijklmnopqrstuvwxyz\".charAt(digit)}return\"<\"+digit+\">\"}function toBase(n,base){base=bigInt(base);if(base.isZero()){if(n.isZero())return{value:[0],isNegative:false};throw new Error(\"Cannot convert nonzero numbers to base 0.\")}if(base.equals(-1)){if(n.isZero())return{value:[0],isNegative:false};if(n.isNegative())return{value:[].concat.apply([],Array.apply(null,Array(-n)).map(Array.prototype.valueOf,[1,0])),isNegative:false};var arr=Array.apply(null,Array(+n-1)).map(Array.prototype.valueOf,[0,1]);arr.unshift([1]);return{value:[].concat.apply([],arr),isNegative:false}}var neg=false;if(n.isNegative()&&base.isPositive()){neg=true;n=n.abs()}if(base.equals(1)){if(n.isZero())return{value:[0],isNegative:false};return{value:Array.apply(null,Array(+n)).map(Number.prototype.valueOf,1),isNegative:neg}}var out=[];var left=n,divmod;while(left.isNegative()||left.compareAbs(base)>=0){divmod=left.divmod(base);left=divmod.quotient;var digit=divmod.remainder;if(digit.isNegative()){digit=base.minus(digit).abs();left=left.next()}out.push(digit.toJSNumber())}out.push(left.toJSNumber());return{value:out.reverse(),isNegative:neg}}function toBaseString(n,base){var arr=toBase(n,base);return(arr.isNegative?\"-\":\"\")+arr.value.map(stringify).join(\"\")}BigInteger.prototype.toArray=function(radix){return toBase(this,radix)};SmallInteger.prototype.toArray=function(radix){return toBase(this,radix)};BigInteger.prototype.toString=function(radix){if(radix===undefined)radix=10;if(radix!==10)return toBaseString(this,radix);var v=this.value,l=v.length,str=String(v[--l]),zeros=\"0000000\",digit;while(--l>=0){digit=String(v[l]);str+=zeros.slice(digit.length)+digit}var sign=this.sign?\"-\":\"\";return sign+str};SmallInteger.prototype.toString=function(radix){if(radix===undefined)radix=10;if(radix!=10)return toBaseString(this,radix);return String(this.value)};BigInteger.prototype.toJSON=SmallInteger.prototype.toJSON=function(){return this.toString()};BigInteger.prototype.valueOf=function(){return parseInt(this.toString(),10)};BigInteger.prototype.toJSNumber=BigInteger.prototype.valueOf;SmallInteger.prototype.valueOf=function(){return this.value};SmallInteger.prototype.toJSNumber=SmallInteger.prototype.valueOf;function parseStringValue(v){if(isPrecise(+v)){var x=+v;if(x===truncate(x))return new SmallInteger(x);throw new Error(\"Invalid integer: \"+v)}var sign=v[0]===\"-\";if(sign)v=v.slice(1);var split=v.split(/e/i);if(split.length>2)throw new Error(\"Invalid integer: \"+split.join(\"e\"));if(split.length===2){var exp=split[1];if(exp[0]===\"+\")exp=exp.slice(1);exp=+exp;if(exp!==truncate(exp)||!isPrecise(exp))throw new Error(\"Invalid integer: \"+exp+\" is not a valid exponent.\");var text=split[0];var decimalPlace=text.indexOf(\".\");if(decimalPlace>=0){exp-=text.length-decimalPlace-1;text=text.slice(0,decimalPlace)+text.slice(decimalPlace+1)}if(exp<0)throw new Error(\"Cannot include negative exponent part for integers\");text+=new Array(exp+1).join(\"0\");v=text}var isValid=/^([0-9][0-9]*)$/.test(v);if(!isValid)throw new Error(\"Invalid integer: \"+v);var r=[],max=v.length,l=LOG_BASE,min=max-l;while(max>0){r.push(+v.slice(min,max));min-=l;if(min<0)min=0;max-=l}trim(r);return new BigInteger(r,sign)}function parseNumberValue(v){if(isPrecise(v)){if(v!==truncate(v))throw new Error(v+\" is not an integer.\");return new SmallInteger(v)}return parseStringValue(v.toString())}function parseValue(v){if(typeof v===\"number\"){return parseNumberValue(v)}if(typeof v===\"string\"){return parseStringValue(v)}return v}for(var i=0;i<1e3;i++){Integer[i]=new SmallInteger(i);if(i>0)Integer[-i]=new SmallInteger(-i)}Integer.one=Integer[1];Integer.zero=Integer[0];Integer.minusOne=Integer[-1];Integer.max=max;Integer.min=min;Integer.gcd=gcd;Integer.lcm=lcm;Integer.isInstance=function(x){return x instanceof BigInteger||x instanceof SmallInteger};Integer.randBetween=randBetween;Integer.fromArray=function(digits,base,isNegative){return parseBaseFromArray(digits.map(parseValue),parseValue(base||10),isNegative)};return Integer}();if( true&&module.hasOwnProperty(\"exports\")){module.exports=bigInt}if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return bigInt}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}\r\n        return bigInt;\r\n    })(),\r\n    /*\r\n     *  decimal.js v10.2.1\r\n     *  An arbitrary-precision Decimal type for JavaScript.\r\n     *  https://github.com/MikeMcl/decimal.js\r\n     *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>\r\n     *  MIT Licence\r\n     */\r\n    bigDec: function(n){\"use strict\";var e,i,t,r,s=9e15,o=1e9,u=\"0123456789abcdef\",c=\"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\",f=\"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\",a={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-s,maxE:s,crypto:!1},h=!0,d=\"[DecimalError] \",l=d+\"Invalid argument: \",p=d+\"Precision limit exceeded\",g=d+\"crypto unavailable\",m=Math.floor,w=Math.pow,v=/^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,N=/^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,b=/^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,E=/^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,x=1e7,y=7,M=c.length-1,q=f.length-1,O={name:\"[object Decimal]\"};function D(n){var e,i,t,r=n.length-1,s=\"\",o=n[0];if(r>0){for(s+=o,e=1;e<r;e++)t=n[e]+\"\",(i=y-t.length)&&(s+=k(i)),s+=t;o=n[e],(i=y-(t=o+\"\").length)&&(s+=k(i))}else if(0===o)return\"0\";for(;o%10==0;)o/=10;return s+o}function F(n,e,i){if(n!==~~n||n<e||n>i)throw Error(l+n)}function A(n,e,i,t){var r,s,o,u;for(s=n[0];s>=10;s/=10)--e;return--e<0?(e+=y,r=0):(r=Math.ceil((e+1)/y),e%=y),s=w(10,y-e),u=n[r]%s|0,null==t?e<3?(0==e?u=u/100|0:1==e&&(u=u/10|0),o=i<4&&99999==u||i>3&&49999==u||5e4==u||0==u):o=(i<4&&u+1==s||i>3&&u+1==s/2)&&(n[r+1]/s/100|0)==w(10,e-2)-1||(u==s/2||0==u)&&0==(n[r+1]/s/100|0):e<4?(0==e?u=u/1e3|0:1==e?u=u/100|0:2==e&&(u=u/10|0),o=(t||i<4)&&9999==u||!t&&i>3&&4999==u):o=((t||i<4)&&u+1==s||!t&&i>3&&u+1==s/2)&&(n[r+1]/s/1e3|0)==w(10,e-3)-1,o}function S(n,e,i){for(var t,r,s=[0],o=0,c=n.length;o<c;){for(r=s.length;r--;)s[r]*=e;for(s[0]+=u.indexOf(n.charAt(o++)),t=0;t<s.length;t++)s[t]>i-1&&(void 0===s[t+1]&&(s[t+1]=0),s[t+1]+=s[t]/i|0,s[t]%=i)}return s.reverse()}O.absoluteValue=O.abs=function(){var n=new this.constructor(this);return n.s<0&&(n.s=1),P(n)},O.ceil=function(){return P(new this.constructor(this),this.e+1,2)},O.comparedTo=O.cmp=function(n){var e,i,t,r,s=this,o=s.d,u=(n=new s.constructor(n)).d,c=s.s,f=n.s;if(!o||!u)return c&&f?c!==f?c:o===u?0:!o^c<0?1:-1:NaN;if(!o[0]||!u[0])return o[0]?c:u[0]?-f:0;if(c!==f)return c;if(s.e!==n.e)return s.e>n.e^c<0?1:-1;for(e=0,i=(t=o.length)<(r=u.length)?t:r;e<i;++e)if(o[e]!==u[e])return o[e]>u[e]^c<0?1:-1;return t===r?0:t>r^c<0?1:-1},O.cosine=O.cos=function(){var n,e,i=this,t=i.constructor;return i.d?i.d[0]?(n=t.precision,e=t.rounding,t.precision=n+Math.max(i.e,i.sd())+y,t.rounding=1,i=function(n,e){var i,t,r=e.d.length;r<32?(i=Math.ceil(r/3),t=(1/z(4,i)).toString()):(i=16,t=\"2.3283064365386962890625e-10\");n.precision+=i,e=J(n,1,e.times(t),new n(1));for(var s=i;s--;){var o=e.times(e);e=o.times(o).minus(o).times(8).plus(1)}return n.precision-=i,e}(t,G(t,i)),t.precision=n,t.rounding=e,P(2==r||3==r?i.neg():i,n,e,!0)):new t(1):new t(NaN)},O.cubeRoot=O.cbrt=function(){var n,e,i,t,r,s,o,u,c,f,a=this,d=a.constructor;if(!a.isFinite()||a.isZero())return new d(a);for(h=!1,(s=a.s*w(a.s*a,1/3))&&Math.abs(s)!=1/0?t=new d(s.toString()):(i=D(a.d),(s=((n=a.e)-i.length+1)%3)&&(i+=1==s||-2==s?\"0\":\"00\"),s=w(i,1/3),n=m((n+1)/3)-(n%3==(n<0?-1:2)),(t=new d(i=s==1/0?\"5e\"+n:(i=s.toExponential()).slice(0,i.indexOf(\"e\")+1)+n)).s=a.s),o=(n=d.precision)+3;;)if(f=(c=(u=t).times(u).times(u)).plus(a),t=Z(f.plus(a).times(u),f.plus(c),o+2,1),D(u.d).slice(0,o)===(i=D(t.d)).slice(0,o)){if(\"9999\"!=(i=i.slice(o-3,o+1))&&(r||\"4999\"!=i)){+i&&(+i.slice(1)||\"5\"!=i.charAt(0))||(P(t,n+1,1),e=!t.times(t).times(t).eq(a));break}if(!r&&(P(u,n+1,0),u.times(u).times(u).eq(a))){t=u;break}o+=4,r=1}return h=!0,P(t,n,d.rounding,e)},O.decimalPlaces=O.dp=function(){var n,e=this.d,i=NaN;if(e){if(i=((n=e.length-1)-m(this.e/y))*y,n=e[n])for(;n%10==0;n/=10)i--;i<0&&(i=0)}return i},O.dividedBy=O.div=function(n){return Z(this,new this.constructor(n))},O.dividedToIntegerBy=O.divToInt=function(n){var e=this.constructor;return P(Z(this,new e(n),0,1,1),e.precision,e.rounding)},O.equals=O.eq=function(n){return 0===this.cmp(n)},O.floor=function(){return P(new this.constructor(this),this.e+1,3)},O.greaterThan=O.gt=function(n){return this.cmp(n)>0},O.greaterThanOrEqualTo=O.gte=function(n){var e=this.cmp(n);return 1==e||0===e},O.hyperbolicCosine=O.cosh=function(){var n,e,i,t,r,s=this,o=s.constructor,u=new o(1);if(!s.isFinite())return new o(s.s?1/0:NaN);if(s.isZero())return u;i=o.precision,t=o.rounding,o.precision=i+Math.max(s.e,s.sd())+4,o.rounding=1,(r=s.d.length)<32?e=(1/z(4,n=Math.ceil(r/3))).toString():(n=16,e=\"2.3283064365386962890625e-10\"),s=J(o,1,s.times(e),new o(1),!0);for(var c,f=n,a=new o(8);f--;)c=s.times(s),s=u.minus(c.times(a.minus(c.times(a))));return P(s,o.precision=i,o.rounding=t,!0)},O.hyperbolicSine=O.sinh=function(){var n,e,i,t,r=this,s=r.constructor;if(!r.isFinite()||r.isZero())return new s(r);if(e=s.precision,i=s.rounding,s.precision=e+Math.max(r.e,r.sd())+4,s.rounding=1,(t=r.d.length)<3)r=J(s,2,r,r,!0);else{n=(n=1.4*Math.sqrt(t))>16?16:0|n,r=J(s,2,r=r.times(1/z(5,n)),r,!0);for(var o,u=new s(5),c=new s(16),f=new s(20);n--;)o=r.times(r),r=r.times(u.plus(o.times(c.times(o).plus(f))))}return s.precision=e,s.rounding=i,P(r,e,i,!0)},O.hyperbolicTangent=O.tanh=function(){var n,e,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(n=t.precision,e=t.rounding,t.precision=n+7,t.rounding=1,Z(i.sinh(),i.cosh(),t.precision=n,t.rounding=e)):new t(i.s)},O.inverseCosine=O.acos=function(){var n,e=this,i=e.constructor,t=e.abs().cmp(1),r=i.precision,s=i.rounding;return-1!==t?0===t?e.isNeg()?U(i,r,s):new i(0):new i(NaN):e.isZero()?U(i,r+4,s).times(.5):(i.precision=r+6,i.rounding=1,e=e.asin(),n=U(i,r+4,s).times(.5),i.precision=r,i.rounding=s,n.minus(e))},O.inverseHyperbolicCosine=O.acosh=function(){var n,e,i=this,t=i.constructor;return i.lte(1)?new t(i.eq(1)?0:NaN):i.isFinite()?(n=t.precision,e=t.rounding,t.precision=n+Math.max(Math.abs(i.e),i.sd())+4,t.rounding=1,h=!1,i=i.times(i).minus(1).sqrt().plus(i),h=!0,t.precision=n,t.rounding=e,i.ln()):new t(i)},O.inverseHyperbolicSine=O.asinh=function(){var n,e,i=this,t=i.constructor;return!i.isFinite()||i.isZero()?new t(i):(n=t.precision,e=t.rounding,t.precision=n+2*Math.max(Math.abs(i.e),i.sd())+6,t.rounding=1,h=!1,i=i.times(i).plus(1).sqrt().plus(i),h=!0,t.precision=n,t.rounding=e,i.ln())},O.inverseHyperbolicTangent=O.atanh=function(){var n,e,i,t,r=this,s=r.constructor;return r.isFinite()?r.e>=0?new s(r.abs().eq(1)?r.s/0:r.isZero()?r:NaN):(n=s.precision,e=s.rounding,t=r.sd(),Math.max(t,n)<2*-r.e-1?P(new s(r),n,e,!0):(s.precision=i=t-r.e,r=Z(r.plus(1),new s(1).minus(r),i+n,1),s.precision=n+4,s.rounding=1,r=r.ln(),s.precision=n,s.rounding=e,r.times(.5))):new s(NaN)},O.inverseSine=O.asin=function(){var n,e,i,t,r=this,s=r.constructor;return r.isZero()?new s(r):(e=r.abs().cmp(1),i=s.precision,t=s.rounding,-1!==e?0===e?((n=U(s,i+4,t).times(.5)).s=r.s,n):new s(NaN):(s.precision=i+6,s.rounding=1,r=r.div(new s(1).minus(r.times(r)).sqrt().plus(1)).atan(),s.precision=i,s.rounding=t,r.times(2)))},O.inverseTangent=O.atan=function(){var n,e,i,t,r,s,o,u,c,f=this,a=f.constructor,d=a.precision,l=a.rounding;if(f.isFinite()){if(f.isZero())return new a(f);if(f.abs().eq(1)&&d+4<=q)return(o=U(a,d+4,l).times(.25)).s=f.s,o}else{if(!f.s)return new a(NaN);if(d+4<=q)return(o=U(a,d+4,l).times(.5)).s=f.s,o}for(a.precision=u=d+10,a.rounding=1,n=i=Math.min(28,u/y+2|0);n;--n)f=f.div(f.times(f).plus(1).sqrt().plus(1));for(h=!1,e=Math.ceil(u/y),t=1,c=f.times(f),o=new a(f),r=f;-1!==n;)if(r=r.times(c),s=o.minus(r.div(t+=2)),r=r.times(c),void 0!==(o=s.plus(r.div(t+=2))).d[e])for(n=e;o.d[n]===s.d[n]&&n--;);return i&&(o=o.times(2<<i-1)),h=!0,P(o,a.precision=d,a.rounding=l,!0)},O.isFinite=function(){return!!this.d},O.isInteger=O.isInt=function(){return!!this.d&&m(this.e/y)>this.d.length-2},O.isNaN=function(){return!this.s},O.isNegative=O.isNeg=function(){return this.s<0},O.isPositive=O.isPos=function(){return this.s>0},O.isZero=function(){return!!this.d&&0===this.d[0]},O.lessThan=O.lt=function(n){return this.cmp(n)<0},O.lessThanOrEqualTo=O.lte=function(n){return this.cmp(n)<1},O.logarithm=O.log=function(n){var e,i,t,r,s,o,u,c,f=this.constructor,a=f.precision,d=f.rounding;if(null==n)n=new f(10),e=!0;else{if(i=(n=new f(n)).d,n.s<0||!i||!i[0]||n.eq(1))return new f(NaN);e=n.eq(10)}if(i=this.d,this.s<0||!i||!i[0]||this.eq(1))return new f(i&&!i[0]?-1/0:1!=this.s?NaN:i?0:1/0);if(e)if(i.length>1)s=!0;else{for(r=i[0];r%10==0;)r/=10;s=1!==r}if(h=!1,o=V(this,u=a+5),t=e?T(f,u+10):V(n,u),A((c=Z(o,t,u,1)).d,r=a,d))do{if(o=V(this,u+=10),t=e?T(f,u+10):V(n,u),c=Z(o,t,u,1),!s){+D(c.d).slice(r+1,r+15)+1==1e14&&(c=P(c,a+1,0));break}}while(A(c.d,r+=10,d));return h=!0,P(c,a,d)},O.minus=O.sub=function(n){var e,i,t,r,s,o,u,c,f,a,d,l,p=this,g=p.constructor;if(n=new g(n),!p.d||!n.d)return p.s&&n.s?p.d?n.s=-n.s:n=new g(n.d||p.s!==n.s?p:NaN):n=new g(NaN),n;if(p.s!=n.s)return n.s=-n.s,p.plus(n);if(f=p.d,l=n.d,u=g.precision,c=g.rounding,!f[0]||!l[0]){if(l[0])n.s=-n.s;else{if(!f[0])return new g(3===c?-0:0);n=new g(p)}return h?P(n,u,c):n}if(i=m(n.e/y),a=m(p.e/y),f=f.slice(),s=a-i){for((d=s<0)?(e=f,s=-s,o=l.length):(e=l,i=a,o=f.length),s>(t=Math.max(Math.ceil(u/y),o)+2)&&(s=t,e.length=1),e.reverse(),t=s;t--;)e.push(0);e.reverse()}else{for((d=(t=f.length)<(o=l.length))&&(o=t),t=0;t<o;t++)if(f[t]!=l[t]){d=f[t]<l[t];break}s=0}for(d&&(e=f,f=l,l=e,n.s=-n.s),o=f.length,t=l.length-o;t>0;--t)f[o++]=0;for(t=l.length;t>s;){if(f[--t]<l[t]){for(r=t;r&&0===f[--r];)f[r]=x-1;--f[r],f[t]+=x}f[t]-=l[t]}for(;0===f[--o];)f.pop();for(;0===f[0];f.shift())--i;return f[0]?(n.d=f,n.e=L(f,i),h?P(n,u,c):n):new g(3===c?-0:0)},O.modulo=O.mod=function(n){var e,i=this,t=i.constructor;return n=new t(n),!i.d||!n.s||n.d&&!n.d[0]?new t(NaN):!n.d||i.d&&!i.d[0]?P(new t(i),t.precision,t.rounding):(h=!1,9==t.modulo?(e=Z(i,n.abs(),0,3,1)).s*=n.s:e=Z(i,n,0,t.modulo,1),e=e.times(n),h=!0,i.minus(e))},O.naturalExponential=O.exp=function(){return B(this)},O.naturalLogarithm=O.ln=function(){return V(this)},O.negated=O.neg=function(){var n=new this.constructor(this);return n.s=-n.s,P(n)},O.plus=O.add=function(n){var e,i,t,r,s,o,u,c,f,a,d=this,l=d.constructor;if(n=new l(n),!d.d||!n.d)return d.s&&n.s?d.d||(n=new l(n.d||d.s===n.s?d:NaN)):n=new l(NaN),n;if(d.s!=n.s)return n.s=-n.s,d.minus(n);if(f=d.d,a=n.d,u=l.precision,c=l.rounding,!f[0]||!a[0])return a[0]||(n=new l(d)),h?P(n,u,c):n;if(s=m(d.e/y),t=m(n.e/y),f=f.slice(),r=s-t){for(r<0?(i=f,r=-r,o=a.length):(i=a,t=s,o=f.length),r>(o=(s=Math.ceil(u/y))>o?s+1:o+1)&&(r=o,i.length=1),i.reverse();r--;)i.push(0);i.reverse()}for((o=f.length)-(r=a.length)<0&&(r=o,i=a,a=f,f=i),e=0;r;)e=(f[--r]=f[r]+a[r]+e)/x|0,f[r]%=x;for(e&&(f.unshift(e),++t),o=f.length;0==f[--o];)f.pop();return n.d=f,n.e=L(f,t),h?P(n,u,c):n},O.precision=O.sd=function(n){var e,i=this;if(void 0!==n&&n!==!!n&&1!==n&&0!==n)throw Error(l+n);return i.d?(e=_(i.d),n&&i.e+1>e&&(e=i.e+1)):e=NaN,e},O.round=function(){var n=this,e=n.constructor;return P(new e(n),n.e+1,e.rounding)},O.sine=O.sin=function(){var n,e,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(n=t.precision,e=t.rounding,t.precision=n+Math.max(i.e,i.sd())+y,t.rounding=1,i=function(n,e){var i,t=e.d.length;if(t<3)return J(n,2,e,e);i=(i=1.4*Math.sqrt(t))>16?16:0|i,e=e.times(1/z(5,i)),e=J(n,2,e,e);for(var r,s=new n(5),o=new n(16),u=new n(20);i--;)r=e.times(e),e=e.times(s.plus(r.times(o.times(r).minus(u))));return e}(t,G(t,i)),t.precision=n,t.rounding=e,P(r>2?i.neg():i,n,e,!0)):new t(NaN)},O.squareRoot=O.sqrt=function(){var n,e,i,t,r,s,o=this,u=o.d,c=o.e,f=o.s,a=o.constructor;if(1!==f||!u||!u[0])return new a(!f||f<0&&(!u||u[0])?NaN:u?o:1/0);for(h=!1,0==(f=Math.sqrt(+o))||f==1/0?(((e=D(u)).length+c)%2==0&&(e+=\"0\"),f=Math.sqrt(e),c=m((c+1)/2)-(c<0||c%2),t=new a(e=f==1/0?\"5e\"+c:(e=f.toExponential()).slice(0,e.indexOf(\"e\")+1)+c)):t=new a(f.toString()),i=(c=a.precision)+3;;)if(t=(s=t).plus(Z(o,s,i+2,1)).times(.5),D(s.d).slice(0,i)===(e=D(t.d)).slice(0,i)){if(\"9999\"!=(e=e.slice(i-3,i+1))&&(r||\"4999\"!=e)){+e&&(+e.slice(1)||\"5\"!=e.charAt(0))||(P(t,c+1,1),n=!t.times(t).eq(o));break}if(!r&&(P(s,c+1,0),s.times(s).eq(o))){t=s;break}i+=4,r=1}return h=!0,P(t,c,a.rounding,n)},O.tangent=O.tan=function(){var n,e,i=this,t=i.constructor;return i.isFinite()?i.isZero()?new t(i):(n=t.precision,e=t.rounding,t.precision=n+10,t.rounding=1,(i=i.sin()).s=1,i=Z(i,new t(1).minus(i.times(i)).sqrt(),n+10,0),t.precision=n,t.rounding=e,P(2==r||4==r?i.neg():i,n,e,!0)):new t(NaN)},O.times=O.mul=function(n){var e,i,t,r,s,o,u,c,f,a=this,d=a.constructor,l=a.d,p=(n=new d(n)).d;if(n.s*=a.s,!(l&&l[0]&&p&&p[0]))return new d(!n.s||l&&!l[0]&&!p||p&&!p[0]&&!l?NaN:l&&p?0*n.s:n.s/0);for(i=m(a.e/y)+m(n.e/y),(c=l.length)<(f=p.length)&&(s=l,l=p,p=s,o=c,c=f,f=o),s=[],t=o=c+f;t--;)s.push(0);for(t=f;--t>=0;){for(e=0,r=c+t;r>t;)u=s[r]+p[t]*l[r-t-1]+e,s[r--]=u%x|0,e=u/x|0;s[r]=(s[r]+e)%x|0}for(;!s[--o];)s.pop();return e?++i:s.shift(),n.d=s,n.e=L(s,i),h?P(n,d.precision,d.rounding):n},O.toBinary=function(n,e){return K(this,2,n,e)},O.toDecimalPlaces=O.toDP=function(n,e){var i=this,t=i.constructor;return i=new t(i),void 0===n?i:(F(n,0,o),void 0===e?e=t.rounding:F(e,0,8),P(i,n+i.e+1,e))},O.toExponential=function(n,e){var i,t=this,r=t.constructor;return void 0===n?i=R(t,!0):(F(n,0,o),void 0===e?e=r.rounding:F(e,0,8),i=R(t=P(new r(t),n+1,e),!0,n+1)),t.isNeg()&&!t.isZero()?\"-\"+i:i},O.toFixed=function(n,e){var i,t,r=this,s=r.constructor;return void 0===n?i=R(r):(F(n,0,o),void 0===e?e=s.rounding:F(e,0,8),i=R(t=P(new s(r),n+r.e+1,e),!1,n+t.e+1)),r.isNeg()&&!r.isZero()?\"-\"+i:i},O.toFraction=function(n){var e,i,t,r,s,o,u,c,f,a,d,p,g=this,m=g.d,v=g.constructor;if(!m)return new v(g);if(f=i=new v(1),t=c=new v(0),o=(s=(e=new v(t)).e=_(m)-g.e-1)%y,e.d[0]=w(10,o<0?y+o:o),null==n)n=s>0?e:f;else{if(!(u=new v(n)).isInt()||u.lt(f))throw Error(l+u);n=u.gt(e)?s>0?e:f:u}for(h=!1,u=new v(D(m)),a=v.precision,v.precision=s=m.length*y*2;d=Z(u,e,0,1,1),1!=(r=i.plus(d.times(t))).cmp(n);)i=t,t=r,r=f,f=c.plus(d.times(r)),c=r,r=e,e=u.minus(d.times(r)),u=r;return r=Z(n.minus(i),t,0,1,1),c=c.plus(r.times(f)),i=i.plus(r.times(t)),c.s=f.s=g.s,p=Z(f,t,s,1).minus(g).abs().cmp(Z(c,i,s,1).minus(g).abs())<1?[f,t]:[c,i],v.precision=a,h=!0,p},O.toHexadecimal=O.toHex=function(n,e){return K(this,16,n,e)},O.toNearest=function(n,e){var i=this,t=i.constructor;if(i=new t(i),null==n){if(!i.d)return i;n=new t(1),e=t.rounding}else{if(n=new t(n),void 0===e?e=t.rounding:F(e,0,8),!i.d)return n.s?i:n;if(!n.d)return n.s&&(n.s=i.s),n}return n.d[0]?(h=!1,i=Z(i,n,0,e,1).times(n),h=!0,P(i)):(n.s=i.s,i=n),i},O.toNumber=function(){return+this},O.toOctal=function(n,e){return K(this,8,n,e)},O.toPower=O.pow=function(n){var e,i,t,r,s,o,u=this,c=u.constructor,f=+(n=new c(n));if(!(u.d&&n.d&&u.d[0]&&n.d[0]))return new c(w(+u,f));if((u=new c(u)).eq(1))return u;if(t=c.precision,s=c.rounding,n.eq(1))return P(u,t,s);if((e=m(n.e/y))>=n.d.length-1&&(i=f<0?-f:f)<=9007199254740991)return r=C(c,u,i,t),n.s<0?new c(1).div(r):P(r,t,s);if((o=u.s)<0){if(e<n.d.length-1)return new c(NaN);if(0==(1&n.d[e])&&(o=1),0==u.e&&1==u.d[0]&&1==u.d.length)return u.s=o,u}return(e=0!=(i=w(+u,f))&&isFinite(i)?new c(i+\"\").e:m(f*(Math.log(\"0.\"+D(u.d))/Math.LN10+u.e+1)))>c.maxE+1||e<c.minE-1?new c(e>0?o/0:0):(h=!1,c.rounding=u.s=1,i=Math.min(12,(e+\"\").length),(r=B(n.times(V(u,t+i)),t)).d&&A((r=P(r,t+5,1)).d,t,s)&&(e=t+10,+D((r=P(B(n.times(V(u,e+i)),e),e+5,1)).d).slice(t+1,t+15)+1==1e14&&(r=P(r,t+1,0))),r.s=o,h=!0,c.rounding=s,P(r,t,s))},O.toPrecision=function(n,e){var i,t=this,r=t.constructor;return void 0===n?i=R(t,t.e<=r.toExpNeg||t.e>=r.toExpPos):(F(n,1,o),void 0===e?e=r.rounding:F(e,0,8),i=R(t=P(new r(t),n,e),n<=t.e||t.e<=r.toExpNeg,n)),t.isNeg()&&!t.isZero()?\"-\"+i:i},O.toSignificantDigits=O.toSD=function(n,e){var i=this.constructor;return void 0===n?(n=i.precision,e=i.rounding):(F(n,1,o),void 0===e?e=i.rounding:F(e,0,8)),P(new i(this),n,e)},O.toString=function(){var n=this,e=n.constructor,i=R(n,n.e<=e.toExpNeg||n.e>=e.toExpPos);return n.isNeg()&&!n.isZero()?\"-\"+i:i},O.truncated=O.trunc=function(){return P(new this.constructor(this),this.e+1,1)},O.valueOf=O.toJSON=function(){var n=this,e=n.constructor,i=R(n,n.e<=e.toExpNeg||n.e>=e.toExpPos);return n.isNeg()?\"-\"+i:i};var Z=function(){function n(n,e,i){var t,r=0,s=n.length;for(n=n.slice();s--;)t=n[s]*e+r,n[s]=t%i|0,r=t/i|0;return r&&n.unshift(r),n}function e(n,e,i,t){var r,s;if(i!=t)s=i>t?1:-1;else for(r=s=0;r<i;r++)if(n[r]!=e[r]){s=n[r]>e[r]?1:-1;break}return s}function t(n,e,i,t){for(var r=0;i--;)n[i]-=r,r=n[i]<e[i]?1:0,n[i]=r*t+n[i]-e[i];for(;!n[0]&&n.length>1;)n.shift()}return function(r,s,o,u,c,f){var a,h,d,l,p,g,w,v,N,b,E,M,q,O,D,F,A,S,Z,R,L=r.constructor,T=r.s==s.s?1:-1,U=r.d,_=s.d;if(!(U&&U[0]&&_&&_[0]))return new L(r.s&&s.s&&(U?!_||U[0]!=_[0]:_)?U&&0==U[0]||!_?0*T:T/0:NaN);for(f?(p=1,h=r.e-s.e):(f=x,p=y,h=m(r.e/p)-m(s.e/p)),Z=_.length,A=U.length,b=(N=new L(T)).d=[],d=0;_[d]==(U[d]||0);d++);if(_[d]>(U[d]||0)&&h--,null==o?(O=o=L.precision,u=L.rounding):O=c?o+(r.e-s.e)+1:o,O<0)b.push(1),g=!0;else{if(O=O/p+2|0,d=0,1==Z){for(l=0,_=_[0],O++;(d<A||l)&&O--;d++)D=l*f+(U[d]||0),b[d]=D/_|0,l=D%_|0;g=l||d<A}else{for((l=f/(_[0]+1)|0)>1&&(_=n(_,l,f),U=n(U,l,f),Z=_.length,A=U.length),F=Z,M=(E=U.slice(0,Z)).length;M<Z;)E[M++]=0;(R=_.slice()).unshift(0),S=_[0],_[1]>=f/2&&++S;do{l=0,(a=e(_,E,Z,M))<0?(q=E[0],Z!=M&&(q=q*f+(E[1]||0)),(l=q/S|0)>1?(l>=f&&(l=f-1),1==(a=e(w=n(_,l,f),E,v=w.length,M=E.length))&&(l--,t(w,Z<v?R:_,v,f))):(0==l&&(a=l=1),w=_.slice()),(v=w.length)<M&&w.unshift(0),t(E,w,M,f),-1==a&&(a=e(_,E,Z,M=E.length))<1&&(l++,t(E,Z<M?R:_,M,f)),M=E.length):0===a&&(l++,E=[0]),b[d++]=l,a&&E[0]?E[M++]=U[F]||0:(E=[U[F]],M=1)}while((F++<A||void 0!==E[0])&&O--);g=void 0!==E[0]}b[0]||b.shift()}if(1==p)N.e=h,i=g;else{for(d=1,l=b[0];l>=10;l/=10)d++;N.e=d+h*p-1,P(N,c?o+N.e+1:o,u,g)}return N}}();function P(n,e,i,t){var r,s,o,u,c,f,a,d,l,p=n.constructor;n:if(null!=e){if(!(d=n.d))return n;for(r=1,u=d[0];u>=10;u/=10)r++;if((s=e-r)<0)s+=y,o=e,c=(a=d[l=0])/w(10,r-o-1)%10|0;else if((l=Math.ceil((s+1)/y))>=(u=d.length)){if(!t)break n;for(;u++<=l;)d.push(0);a=c=0,r=1,o=(s%=y)-y+1}else{for(a=u=d[l],r=1;u>=10;u/=10)r++;c=(o=(s%=y)-y+r)<0?0:a/w(10,r-o-1)%10|0}if(t=t||e<0||void 0!==d[l+1]||(o<0?a:a%w(10,r-o-1)),f=i<4?(c||t)&&(0==i||i==(n.s<0?3:2)):c>5||5==c&&(4==i||t||6==i&&(s>0?o>0?a/w(10,r-o):0:d[l-1])%10&1||i==(n.s<0?8:7)),e<1||!d[0])return d.length=0,f?(e-=n.e+1,d[0]=w(10,(y-e%y)%y),n.e=-e||0):d[0]=n.e=0,n;if(0==s?(d.length=l,u=1,l--):(d.length=l+1,u=w(10,y-s),d[l]=o>0?(a/w(10,r-o)%w(10,o)|0)*u:0),f)for(;;){if(0==l){for(s=1,o=d[0];o>=10;o/=10)s++;for(o=d[0]+=u,u=1;o>=10;o/=10)u++;s!=u&&(n.e++,d[0]==x&&(d[0]=1));break}if(d[l]+=u,d[l]!=x)break;d[l--]=0,u=1}for(s=d.length;0===d[--s];)d.pop()}return h&&(n.e>p.maxE?(n.d=null,n.e=NaN):n.e<p.minE&&(n.e=0,n.d=[0])),n}function R(n,e,i){if(!n.isFinite())return j(n);var t,r=n.e,s=D(n.d),o=s.length;return e?(i&&(t=i-o)>0?s=s.charAt(0)+\".\"+s.slice(1)+k(t):o>1&&(s=s.charAt(0)+\".\"+s.slice(1)),s=s+(n.e<0?\"e\":\"e+\")+n.e):r<0?(s=\"0.\"+k(-r-1)+s,i&&(t=i-o)>0&&(s+=k(t))):r>=o?(s+=k(r+1-o),i&&(t=i-r-1)>0&&(s=s+\".\"+k(t))):((t=r+1)<o&&(s=s.slice(0,t)+\".\"+s.slice(t)),i&&(t=i-o)>0&&(r+1===o&&(s+=\".\"),s+=k(t))),s}function L(n,e){var i=n[0];for(e*=y;i>=10;i/=10)e++;return e}function T(n,e,i){if(e>M)throw h=!0,i&&(n.precision=i),Error(p);return P(new n(c),e,1,!0)}function U(n,e,i){if(e>q)throw Error(p);return P(new n(f),e,i,!0)}function _(n){var e=n.length-1,i=e*y+1;if(e=n[e]){for(;e%10==0;e/=10)i--;for(e=n[0];e>=10;e/=10)i++}return i}function k(n){for(var e=\"\";n--;)e+=\"0\";return e}function C(n,e,i,t){var r,s=new n(1),o=Math.ceil(t/y+4);for(h=!1;;){if(i%2&&Q((s=s.times(e)).d,o)&&(r=!0),0===(i=m(i/2))){i=s.d.length-1,r&&0===s.d[i]&&++s.d[i];break}Q((e=e.times(e)).d,o)}return h=!0,s}function I(n){return 1&n.d[n.d.length-1]}function H(n,e,i){for(var t,r=new n(e[0]),s=0;++s<e.length;){if(!(t=new n(e[s])).s){r=t;break}r[i](t)&&(r=t)}return r}function B(n,e){var i,t,r,s,o,u,c,f=0,a=0,d=0,l=n.constructor,p=l.rounding,g=l.precision;if(!n.d||!n.d[0]||n.e>17)return new l(n.d?n.d[0]?n.s<0?0:1/0:1:n.s?n.s<0?0:n:NaN);for(null==e?(h=!1,c=g):c=e,u=new l(.03125);n.e>-2;)n=n.times(u),d+=5;for(c+=t=Math.log(w(2,d))/Math.LN10*2+5|0,i=s=o=new l(1),l.precision=c;;){if(s=P(s.times(n),c,1),i=i.times(++a),D((u=o.plus(Z(s,i,c,1))).d).slice(0,c)===D(o.d).slice(0,c)){for(r=d;r--;)o=P(o.times(o),c,1);if(null!=e)return l.precision=g,o;if(!(f<3&&A(o.d,c-t,p,f)))return P(o,l.precision=g,p,h=!0);l.precision=c+=10,i=s=u=new l(1),a=0,f++}o=u}}function V(n,e){var i,t,r,s,o,u,c,f,a,d,l,p=1,g=n,m=g.d,w=g.constructor,v=w.rounding,N=w.precision;if(g.s<0||!m||!m[0]||!g.e&&1==m[0]&&1==m.length)return new w(m&&!m[0]?-1/0:1!=g.s?NaN:m?0:g);if(null==e?(h=!1,a=N):a=e,w.precision=a+=10,t=(i=D(m)).charAt(0),!(Math.abs(s=g.e)<15e14))return f=T(w,a+2,N).times(s+\"\"),g=V(new w(t+\".\"+i.slice(1)),a-10).plus(f),w.precision=N,null==e?P(g,N,v,h=!0):g;for(;t<7&&1!=t||1==t&&i.charAt(1)>3;)t=(i=D((g=g.times(n)).d)).charAt(0),p++;for(s=g.e,t>1?(g=new w(\"0.\"+i),s++):g=new w(t+\".\"+i.slice(1)),d=g,c=o=g=Z(g.minus(1),g.plus(1),a,1),l=P(g.times(g),a,1),r=3;;){if(o=P(o.times(l),a,1),D((f=c.plus(Z(o,new w(r),a,1))).d).slice(0,a)===D(c.d).slice(0,a)){if(c=c.times(2),0!==s&&(c=c.plus(T(w,a+2,N).times(s+\"\"))),c=Z(c,new w(p),a,1),null!=e)return w.precision=N,c;if(!A(c.d,a-10,v,u))return P(c,w.precision=N,v,h=!0);w.precision=a+=10,f=o=g=Z(d.minus(1),d.plus(1),a,1),l=P(g.times(g),a,1),r=u=1}c=f,r+=2}}function j(n){return String(n.s*n.s/0)}function $(n,e){var i,t,r;for((i=e.indexOf(\".\"))>-1&&(e=e.replace(\".\",\"\")),(t=e.search(/e/i))>0?(i<0&&(i=t),i+=+e.slice(t+1),e=e.substring(0,t)):i<0&&(i=e.length),t=0;48===e.charCodeAt(t);t++);for(r=e.length;48===e.charCodeAt(r-1);--r);if(e=e.slice(t,r)){if(r-=t,n.e=i=i-t-1,n.d=[],t=(i+1)%y,i<0&&(t+=y),t<r){for(t&&n.d.push(+e.slice(0,t)),r-=y;t<r;)n.d.push(+e.slice(t,t+=y));e=e.slice(t),t=y-e.length}else t-=r;for(;t--;)e+=\"0\";n.d.push(+e),h&&(n.e>n.constructor.maxE?(n.d=null,n.e=NaN):n.e<n.constructor.minE&&(n.e=0,n.d=[0]))}else n.e=0,n.d=[0];return n}function W(n,i){var t,r,s,o,u,c,f,a,d;if(\"Infinity\"===i||\"NaN\"===i)return+i||(n.s=NaN),n.e=NaN,n.d=null,n;if(N.test(i))t=16,i=i.toLowerCase();else if(v.test(i))t=2;else{if(!b.test(i))throw Error(l+i);t=8}for((o=i.search(/p/i))>0?(f=+i.slice(o+1),i=i.substring(2,o)):i=i.slice(2),u=(o=i.indexOf(\".\"))>=0,r=n.constructor,u&&(o=(c=(i=i.replace(\".\",\"\")).length)-o,s=C(r,new r(t),o,2*o)),o=d=(a=S(i,t,x)).length-1;0===a[o];--o)a.pop();return o<0?new r(0*n.s):(n.e=L(a,d),n.d=a,h=!1,u&&(n=Z(n,s,4*c)),f&&(n=n.times(Math.abs(f)<54?w(2,f):e.pow(2,f))),h=!0,n)}function J(n,e,i,t,r){var s,o,u,c,f=n.precision,a=Math.ceil(f/y);for(h=!1,c=i.times(i),u=new n(t);;){if(o=Z(u.times(c),new n(e++*e++),f,1),u=r?t.plus(o):t.minus(o),t=Z(o.times(c),new n(e++*e++),f,1),void 0!==(o=u.plus(t)).d[a]){for(s=a;o.d[s]===u.d[s]&&s--;);if(-1==s)break}s=u,u=t,t=o,o=s,0}return h=!0,o.d.length=a+1,o}function z(n,e){for(var i=n;--e;)i*=n;return i}function G(n,e){var i,t=e.s<0,s=U(n,n.precision,1),o=s.times(.5);if((e=e.abs()).lte(o))return r=t?4:1,e;if((i=e.divToInt(s)).isZero())r=t?3:2;else{if((e=e.minus(i.times(s))).lte(o))return r=I(i)?t?2:3:t?4:1,e;r=I(i)?t?1:4:t?3:2}return e.minus(s).abs()}function K(n,e,t,r){var s,c,f,a,h,d,l,p,g,m=n.constructor,w=void 0!==t;if(w?(F(t,1,o),void 0===r?r=m.rounding:F(r,0,8)):(t=m.precision,r=m.rounding),n.isFinite()){for(w?(s=2,16==e?t=4*t-3:8==e&&(t=3*t-2)):s=e,(f=(l=R(n)).indexOf(\".\"))>=0&&(l=l.replace(\".\",\"\"),(g=new m(1)).e=l.length-f,g.d=S(R(g),10,s),g.e=g.d.length),c=h=(p=S(l,10,s)).length;0==p[--h];)p.pop();if(p[0]){if(f<0?c--:((n=new m(n)).d=p,n.e=c,p=(n=Z(n,g,t,r,0,s)).d,c=n.e,d=i),f=p[t],a=s/2,d=d||void 0!==p[t+1],d=r<4?(void 0!==f||d)&&(0===r||r===(n.s<0?3:2)):f>a||f===a&&(4===r||d||6===r&&1&p[t-1]||r===(n.s<0?8:7)),p.length=t,d)for(;++p[--t]>s-1;)p[t]=0,t||(++c,p.unshift(1));for(h=p.length;!p[h-1];--h);for(f=0,l=\"\";f<h;f++)l+=u.charAt(p[f]);if(w){if(h>1)if(16==e||8==e){for(f=16==e?4:3,--h;h%f;h++)l+=\"0\";for(h=(p=S(l,s,e)).length;!p[h-1];--h);for(f=1,l=\"1.\";f<h;f++)l+=u.charAt(p[f])}else l=l.charAt(0)+\".\"+l.slice(1);l=l+(c<0?\"p\":\"p+\")+c}else if(c<0){for(;++c;)l=\"0\"+l;l=\"0.\"+l}else if(++c>h)for(c-=h;c--;)l+=\"0\";else c<h&&(l=l.slice(0,c)+\".\"+l.slice(c))}else l=w?\"0p+0\":\"0\";l=(16==e?\"0x\":2==e?\"0b\":8==e?\"0o\":\"\")+l}else l=j(n);return n.s<0?\"-\"+l:l}function Q(n,e){if(n.length>e)return n.length=e,!0}function X(n){return new this(n).abs()}function Y(n){return new this(n).acos()}function nn(n){return new this(n).acosh()}function en(n,e){return new this(n).plus(e)}function tn(n){return new this(n).asin()}function rn(n){return new this(n).asinh()}function sn(n){return new this(n).atan()}function on(n){return new this(n).atanh()}function un(n,e){n=new this(n),e=new this(e);var i,t=this.precision,r=this.rounding,s=t+4;return n.s&&e.s?n.d||e.d?!e.d||n.isZero()?(i=e.s<0?U(this,t,r):new this(0)).s=n.s:!n.d||e.isZero()?(i=U(this,s,1).times(.5)).s=n.s:e.s<0?(this.precision=s,this.rounding=1,i=this.atan(Z(n,e,s,1)),e=U(this,s,1),this.precision=t,this.rounding=r,i=n.s<0?i.minus(e):i.plus(e)):i=this.atan(Z(n,e,s,1)):(i=U(this,s,1).times(e.s>0?.25:.75)).s=n.s:i=new this(NaN),i}function cn(n){return new this(n).cbrt()}function fn(n){return P(n=new this(n),n.e+1,2)}function an(n){if(!n||\"object\"!=typeof n)throw Error(d+\"Object expected\");var e,i,t,r=!0===n.defaults,u=[\"precision\",1,o,\"rounding\",0,8,\"toExpNeg\",-s,0,\"toExpPos\",0,s,\"maxE\",0,s,\"minE\",-s,0,\"modulo\",0,9];for(e=0;e<u.length;e+=3)if(i=u[e],r&&(this[i]=a[i]),void 0!==(t=n[i])){if(!(m(t)===t&&t>=u[e+1]&&t<=u[e+2]))throw Error(l+i+\": \"+t);this[i]=t}if(i=\"crypto\",r&&(this[i]=a[i]),void 0!==(t=n[i])){if(!0!==t&&!1!==t&&0!==t&&1!==t)throw Error(l+i+\": \"+t);if(t){if(\"undefined\"==typeof crypto||!crypto||!crypto.getRandomValues&&!crypto.randomBytes)throw Error(g);this[i]=!0}else this[i]=!1}return this}function hn(n){return new this(n).cos()}function dn(n){return new this(n).cosh()}function ln(n,e){return new this(n).div(e)}function pn(n){return new this(n).exp()}function gn(n){return P(n=new this(n),n.e+1,3)}function mn(){var n,e,i=new this(0);for(h=!1,n=0;n<arguments.length;)if((e=new this(arguments[n++])).d)i.d&&(i=i.plus(e.times(e)));else{if(e.s)return h=!0,new this(1/0);i=e}return h=!0,i.sqrt()}function wn(n){return n instanceof e||n&&\"[object Decimal]\"===n.name||!1}function vn(n){return new this(n).ln()}function Nn(n,e){return new this(n).log(e)}function bn(n){return new this(n).log(2)}function En(n){return new this(n).log(10)}function xn(){return H(this,arguments,\"lt\")}function yn(){return H(this,arguments,\"gt\")}function Mn(n,e){return new this(n).mod(e)}function qn(n,e){return new this(n).mul(e)}function On(n,e){return new this(n).pow(e)}function Dn(n){var e,i,t,r,s=0,u=new this(1),c=[];if(void 0===n?n=this.precision:F(n,1,o),t=Math.ceil(n/y),this.crypto)if(crypto.getRandomValues)for(e=crypto.getRandomValues(new Uint32Array(t));s<t;)(r=e[s])>=429e7?e[s]=crypto.getRandomValues(new Uint32Array(1))[0]:c[s++]=r%1e7;else{if(!crypto.randomBytes)throw Error(g);for(e=crypto.randomBytes(t*=4);s<t;)(r=e[s]+(e[s+1]<<8)+(e[s+2]<<16)+((127&e[s+3])<<24))>=214e7?crypto.randomBytes(4).copy(e,s):(c.push(r%1e7),s+=4);s=t/4}else for(;s<t;)c[s++]=1e7*Math.random()|0;for(t=c[--s],n%=y,t&&n&&(r=w(10,y-n),c[s]=(t/r|0)*r);0===c[s];s--)c.pop();if(s<0)i=0,c=[0];else{for(i=-1;0===c[0];i-=y)c.shift();for(t=1,r=c[0];r>=10;r/=10)t++;t<y&&(i-=y-t)}return u.e=i,u.d=c,u}function Fn(n){return P(n=new this(n),n.e+1,this.rounding)}function An(n){return(n=new this(n)).d?n.d[0]?n.s:0*n.s:n.s||NaN}function Sn(n){return new this(n).sin()}function Zn(n){return new this(n).sinh()}function Pn(n){return new this(n).sqrt()}function Rn(n,e){return new this(n).sub(e)}function Ln(n){return new this(n).tan()}function Tn(n){return new this(n).tanh()}function Un(n){return P(n=new this(n),n.e+1,1)}return(e=function n(e){var i,t,r;function s(n){var e,i,t,r=this;if(!(r instanceof s))return new s(n);if(r.constructor=s,n instanceof s)return r.s=n.s,void(h?!n.d||n.e>s.maxE?(r.e=NaN,r.d=null):n.e<s.minE?(r.e=0,r.d=[0]):(r.e=n.e,r.d=n.d.slice()):(r.e=n.e,r.d=n.d?n.d.slice():n.d));if(\"number\"==(t=typeof n)){if(0===n)return r.s=1/n<0?-1:1,r.e=0,void(r.d=[0]);if(n<0?(n=-n,r.s=-1):r.s=1,n===~~n&&n<1e7){for(e=0,i=n;i>=10;i/=10)e++;return void(h?e>s.maxE?(r.e=NaN,r.d=null):e<s.minE?(r.e=0,r.d=[0]):(r.e=e,r.d=[n]):(r.e=e,r.d=[n]))}return 0*n!=0?(n||(r.s=NaN),r.e=NaN,void(r.d=null)):$(r,n.toString())}if(\"string\"!==t)throw Error(l+n);return 45===(i=n.charCodeAt(0))?(n=n.slice(1),r.s=-1):(43===i&&(n=n.slice(1)),r.s=1),E.test(n)?$(r,n):W(r,n)}if(s.prototype=O,s.ROUND_UP=0,s.ROUND_DOWN=1,s.ROUND_CEIL=2,s.ROUND_FLOOR=3,s.ROUND_HALF_UP=4,s.ROUND_HALF_DOWN=5,s.ROUND_HALF_EVEN=6,s.ROUND_HALF_CEIL=7,s.ROUND_HALF_FLOOR=8,s.EUCLID=9,s.config=s.set=an,s.clone=n,s.isDecimal=wn,s.abs=X,s.acos=Y,s.acosh=nn,s.add=en,s.asin=tn,s.asinh=rn,s.atan=sn,s.atanh=on,s.atan2=un,s.cbrt=cn,s.ceil=fn,s.cos=hn,s.cosh=dn,s.div=ln,s.exp=pn,s.floor=gn,s.hypot=mn,s.ln=vn,s.log=Nn,s.log10=En,s.log2=bn,s.max=xn,s.min=yn,s.mod=Mn,s.mul=qn,s.pow=On,s.random=Dn,s.round=Fn,s.sign=An,s.sin=Sn,s.sinh=Zn,s.sqrt=Pn,s.sub=Rn,s.tan=Ln,s.tanh=Tn,s.trunc=Un,void 0===e&&(e={}),e&&!0!==e.defaults)for(r=[\"precision\",\"rounding\",\"toExpNeg\",\"toExpPos\",\"maxE\",\"minE\",\"modulo\",\"crypto\"],i=0;i<r.length;)e.hasOwnProperty(t=r[i++])||(e[t]=this[t]);return s.config(e),s}(a)).default=e.Decimal=e,c=new e(c),f=new e(f), true?!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return e}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0,e}(this)\r\n//    bigDec: require('decimal.js')\r\n});\r\n\r\nif(true) {\r\n    module.exports = nerdamer;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmVyZGFtZXIvbmVyZGFtZXIuY29yZS5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmFuaWxsYS1pbnRlZ3JhdGlvbi0yZC8uL25vZGVfbW9kdWxlcy9uZXJkYW1lci9uZXJkYW1lci5jb3JlLmpzPzE1ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogQXV0aG9yIDogTWFydGluIERvbmtcclxuICogV2Vic2l0ZSA6IGh0dHA6Ly93d3cubmVyZGFtZXIuY29tXHJcbiAqIEVtYWlsIDogbWFydGluLnIuZG9ua0BnbWFpbC5jb21cclxuICogU291cmNlIDogaHR0cHM6Ly9naXRodWIuY29tL2ppZ2d6c29uL25lcmRhbWVyXHJcbiAqL1xyXG5cclxuLyogZ2xvYmFsIHRyaWcsIHRyaWdoLCBJbmZpbml0eSwgZGVmaW5lLCBhcmd1bWVudHMyQXJyYXksIE5hTiAqL1xyXG4vL2V4dGVybmFscyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vKiBCaWdJbnRlcmdlci5qcyB2MS42LjQwIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRlcm9sc29uL0JpZ0ludGVnZXIuanMvYmxvYi9tYXN0ZXIvTElDRU5TRSAqL1xyXG4vL3ZhciBuZXJkYW1lckJpZ0ludCA9IHR5cGVvZiBuZXJkYW1lckJpZ0ludCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXJkYW1lckJpZ0ludCA6IHJlcXVpcmUoXCJiaWctaW50ZWdlclwiKTtcclxuLyogYmlnLmpzIHY1LjIuMiBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvTElDRU5DRSAqL1xyXG4vL3ZhciBuZXJkYW1lckJpZ0RlY2ltYWwgPSB0eXBlb2YgbmVyZGFtZXJCaWdEZWNpbWFsICE9PSAndW5kZWZpbmVkJyA/IG5lcmRhbWVyQmlnRGVjaW1hbCA6IHJlcXVpcmUoJ2JpZy5qcycpO1xyXG5cclxudmFyIG5lcmRhbWVyID0gKGZ1bmN0aW9uIChpbXBvcnRzKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8vdmVyc2lvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICB2YXIgdmVyc2lvbiA9ICcxLjEuMTInO1xyXG5cclxuLy9pbml0cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIHZhciBfID0gbmV3IFBhcnNlcigpOyAvL25lcmRhbWVyJ3MgcGFyc2VyXHJcblxyXG4gICAgLy9pbXBvcnQgYmlnSW50XHJcbiAgICB2YXIgYmlnSW50ID0gaW1wb3J0cy5iaWdJbnQ7XHJcbiAgICB2YXIgYmlnRGVjID0gaW1wb3J0cy5iaWdEZWM7XHJcblxyXG4gICAgLy9zZXQgdGhlIHByZWNpc2lvbiB0byBqcyBwcmVjaXNpb25cclxuICAgIGJpZ0RlYy5zZXQoe1xyXG4gICAgICAgIHByZWNpc2lvbjogMjUwXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgR3JvdXBzID0ge307XHJcblxyXG4gICAgLy9jb250YWluZXIgb2YgcHJlZ2VuZXJhdGVkIHByaW1lc1xyXG4gICAgdmFyIFBSSU1FUyA9IFsyLCAzLCA1LCA3LCAxMSwgMTMsIDE3LCAxOSwgMjMsIDI5LCAzMSwgMzcsIDQxLCA0MywgNDcsIDUzLCA1OSwgNjEsIDY3LCA3MSwgNzMsIDc5LCA4MywgODksIDk3LCAxMDEsIDEwMywgMTA3LCAxMDksIDExM1xyXG4gICAgICAgICAgICAgICAgLCAxMjcsIDEzMSwgMTM3LCAxMzksIDE0OSwgMTUxLCAxNTcsIDE2MywgMTY3LCAxNzMsIDE3OSwgMTgxLCAxOTEsIDE5MywgMTk3LCAxOTksIDIxMSwgMjIzLCAyMjcsIDIyOSwgMjMzLCAyMzksIDI0MSwgMjUxLFxyXG4gICAgICAgIDI1NywgMjYzLCAyNjksIDI3MSwgMjc3LCAyODEsIDI4MywgMjkzLCAzMDcsIDMxMSwgMzEzLCAzMTcsIDMzMSwgMzM3LCAzNDcsIDM0OSwgMzUzLCAzNTksIDM2NywgMzczLCAzNzksIDM4MywgMzg5LCAzOTcsXHJcbiAgICAgICAgNDAxLCA0MDksIDQxOSwgNDIxLCA0MzEsIDQzMywgNDM5LCA0NDMsIDQ0OSwgNDU3LCA0NjEsIDQ2MywgNDY3LCA0NzksIDQ4NywgNDkxLCA0OTksIDUwMywgNTA5LCA1MjEsIDUyMywgNTQxLCA1NDcsIDU1NyxcclxuICAgICAgICA1NjMsIDU2OSwgNTcxLCA1NzcsIDU4NywgNTkzLCA1OTksIDYwMSwgNjA3LCA2MTMsIDYxNywgNjE5LCA2MzEsIDY0MSwgNjQzLCA2NDcsIDY1MywgNjU5LCA2NjEsIDY3MywgNjc3LCA2ODMsIDY5MSwgNzAxLFxyXG4gICAgICAgIDcwOSwgNzE5LCA3MjcsIDczMywgNzM5LCA3NDMsIDc1MSwgNzU3LCA3NjEsIDc2OSwgNzczLCA3ODcsIDc5NywgODA5LCA4MTEsIDgyMSwgODIzLCA4MjcsIDgyOSwgODM5LCA4NTMsIDg1NywgODU5LCA4NjMsXHJcbiAgICAgICAgODc3LCA4ODEsIDg4MywgODg3LCA5MDcsIDkxMSwgOTE5LCA5MjksIDkzNywgOTQxLCA5NDcsIDk1MywgOTY3LCA5NzEsIDk3NywgOTgzLCA5OTEsIDk5NywgMTAwOSwgMTAxMywgMTAxOSwgMTAyMSwgMTAzMSxcclxuICAgICAgICAxMDMzLCAxMDM5LCAxMDQ5LCAxMDUxLCAxMDYxLCAxMDYzLCAxMDY5LCAxMDg3LCAxMDkxLCAxMDkzLCAxMDk3LCAxMTAzLCAxMTA5LCAxMTE3LCAxMTIzLCAxMTI5LCAxMTUxLCAxMTUzLCAxMTYzLCAxMTcxLFxyXG4gICAgICAgIDExODEsIDExODcsIDExOTMsIDEyMDEsIDEyMTMsIDEyMTcsIDEyMjMsIDEyMjksIDEyMzEsIDEyMzcsIDEyNDksIDEyNTksIDEyNzcsIDEyNzksIDEyODMsIDEyODksIDEyOTEsIDEyOTcsIDEzMDEsIDEzMDMsXHJcbiAgICAgICAgMTMwNywgMTMxOSwgMTMyMSwgMTMyNywgMTM2MSwgMTM2NywgMTM3MywgMTM4MSwgMTM5OSwgMTQwOSwgMTQyMywgMTQyNywgMTQyOSwgMTQzMywgMTQzOSwgMTQ0NywgMTQ1MSwgMTQ1MywgMTQ1OSwgMTQ3MSxcclxuICAgICAgICAxNDgxLCAxNDgzLCAxNDg3LCAxNDg5LCAxNDkzLCAxNDk5LCAxNTExLCAxNTIzLCAxNTMxLCAxNTQzLCAxNTQ5LCAxNTUzLCAxNTU5LCAxNTY3LCAxNTcxLCAxNTc5LCAxNTgzLCAxNTk3LCAxNjAxLCAxNjA3LFxyXG4gICAgICAgIDE2MDksIDE2MTMsIDE2MTksIDE2MjEsIDE2MjcsIDE2MzcsIDE2NTcsIDE2NjMsIDE2NjcsIDE2NjksIDE2OTMsIDE2OTcsIDE2OTksIDE3MDksIDE3MjEsIDE3MjMsIDE3MzMsIDE3NDEsIDE3NDcsIDE3NTMsXHJcbiAgICAgICAgMTc1OSwgMTc3NywgMTc4MywgMTc4NywgMTc4OSwgMTgwMSwgMTgxMSwgMTgyMywgMTgzMSwgMTg0NywgMTg2MSwgMTg2NywgMTg3MSwgMTg3MywgMTg3NywgMTg3OSwgMTg4OSwgMTkwMSwgMTkwNywgMTkxMywgMTkzMSxcclxuICAgICAgICAxOTMzLCAxOTQ5LCAxOTUxLCAxOTczLCAxOTc5LCAxOTg3LCAxOTkzLCAxOTk3LCAxOTk5LCAyMDAzLCAyMDExLCAyMDE3LCAyMDI3LCAyMDI5LCAyMDM5LCAyMDUzLCAyMDYzLCAyMDY5LCAyMDgxLCAyMDgzXTtcclxuXHJcbi8vU2V0dGluZ3MgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICB2YXIgQ1VTVE9NX09QRVJBVE9SUyA9IHt9O1xyXG5cclxuICAgIHZhciBTZXR0aW5ncyA9IHtcclxuICAgICAgICAvL0VuYWJsZXMvRGlzYWJsZXMgY2FsbCBwZWVrZXJzLiBGYWxzZSBtZWFucyBjYWxsUGVla2VycyBhcmUgZGlzYWJsZWQgYW5kIHRydWUgbWVhbnMgY2FsbFBlZWtlcnMgYXJlIGVuYWJsZWQuXHJcbiAgICAgICAgY2FsbFBlZWtlcnM6IGZhbHNlLFxyXG5cclxuICAgICAgICAvL3RoZSBtYXggbnVtYmVyIHVwIHRvIHdoaWNoIHRvIGNhY2hlIHByaW1lcy4gTWFraW5nIHRoaXMgdG9vIGhpZ2ggY2F1c2VzIHBlcmZvcm1hbmNlIGlzc3Vlc1xyXG4gICAgICAgIGluaXRfcHJpbWVzOiAxMDAwLFxyXG5cclxuICAgICAgICBleGNsdWRlOiBbXSxcclxuICAgICAgICAvL0lmIHlvdSBkb24ndCBjYXJlIGFib3V0IGRpdmlzaW9uIGJ5IHplcm8gZm9yIGV4YW1wbGUgdGhlbiB0aGlzIGNhbiBiZSBzZXQgdG8gdHJ1ZS5cclxuICAgICAgICAvL0hhcyBzb21lIG5hc3R5IHNpZGUgZWZmZWN0cyBzbyBjaG9vc2UgY2FyZWZ1bGx5LlxyXG4gICAgICAgIHN1cHByZXNzX2Vycm9yczogZmFsc2UsXHJcbiAgICAgICAgLy90aGUgZ2xvYmFsIHVzZWQgdG8gaW52b2tlIHRoZSBsaWJhcnkgdG8gcGFyc2UgdG8gYSBudW1iZXIuIE5vcm1hbGx5IGNvcyg5KSBmb3IgZXhhbXBsZSByZXR1cm5zXHJcbiAgICAgICAgLy9jb3MoOSkgZm9yIGNvbnZlbmllbmNlIGJ1dCBwYXJzZSB0byBudW1iZXIgd2lsbCBhbHdheXMgdHJ5IHRvIHJldHVybiBhIG51bWJlciBpZiBzZXQgdG8gdHJ1ZS5cclxuICAgICAgICBQQVJTRTJOVU1CRVI6IGZhbHNlLFxyXG4gICAgICAgIC8vdGhpcyBmbGFnIGZvcmNlcyB0aGUgYSBjbG9uZSB0byBiZSByZXR1cm5lZCB3aGVuIGFkZCwgc3VidHJhY3QsIGV0Yy4uLiBpcyBjYWxsZWRcclxuICAgICAgICBTQUZFOiBmYWxzZSxcclxuICAgICAgICAvL3RoZSBzeW1ib2wgdG8gdXNlIGZvciBpbWFnaW5hcnkgc3ltYm9sc1xyXG4gICAgICAgIElNQUdJTkFSWTogJ2knLFxyXG4gICAgICAgIC8vdGhlIG1vZHVsZXMgdXNlZCB0byBsaW5rIG51bWVyaWMgZnVuY3Rpb24gaG9sZGVyc1xyXG4gICAgICAgIEZVTkNUSU9OX01PRFVMRVM6IFtNYXRoXSxcclxuICAgICAgICAvL0FsbG93IGNlcnRhaW4gY2hhcmFjdGVyc1xyXG4gICAgICAgIEFMTE9XX0NIQVJTOiBbJ8+AJ10sXHJcbiAgICAgICAgLy9BbGxvdyBuZXJkYW1lciB0byBjb252ZXJ0IG11bHRpLWNoYXJhY3RlciB2YXJpYWJsZXNcclxuICAgICAgICBVU0VfTVVMVElDSEFSQUNURVJfVkFSUzogdHJ1ZSxcclxuICAgICAgICAvL0FsbG93IGNoYW5naW5nIG9mIHBvd2VyIG9wZXJhdG9yXHJcbiAgICAgICAgUE9XRVJfT1BFUkFUT1I6ICdeJyxcclxuICAgICAgICAvL1RoZSB2YXJpYWJsZSB2YWxpZGF0aW9uIHJlZ2V4XHJcbiAgICAgICAgLy9WQUxJREFUSU9OX1JFR0VYOiAvXlthLXpfXVthLXpcXGRcXF9dKiQvaVxyXG4gICAgICAgIFZBTElEQVRJT05fUkVHRVg6IC9eW2Etel/OsUHOskLOs86TzrTOlM+1Rc62Ws63SM64zpjOuUnOukvOu86bzrxNzr1Ozr7Onm9Pz4DOoM+BUM+DzqPPhFTPhc+Sz5XOps+HWM+IzqjPic6p4oieXVswLTlhLXpfzrFBzrJCzrPOk860zpTPtUXOtlrOt0jOuM6YzrlJzrpLzrvOm868Tc69Ts6+zp5vT8+AzqDPgVDPg86jz4RUz4XPks+VzqbPh1jPiM6oz4nOqV0qJC9pLFxyXG4gICAgICAgIC8vIFRoZSByZWdleCB1c2VkIHRvIGRldGVybWluZSB3aGljaCBjaGFyYWN0ZXJzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBpbXBsaWVkIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgSU1QTElFRF9NVUxUSVBMSUNBVElPTl9SRUdFWDogLyhbXFwrXFwtXFwvXFwqXSpbMC05XSspKFthLXpfzrFBzrJCzrPOk860zpTPtUXOtlrOt0jOuM6YzrlJzrpLzrvOm868Tc69Ts6+zp5vT8+AzqDPgVDPg86jz4RUz4XPks+VzqbPh1jPiM6oz4nOqV0rW1xcK1xcLVxcL1xcKl0qKS9naSxcclxuICAgICAgICAvL0FsaWFzZXNcclxuICAgICAgICBBTElBU0VTOiB7XHJcbiAgICAgICAgICAgICfPgCc6ICdwaScsXHJcbiAgICAgICAgICAgICfiiJ4nOiAnSW5maW5pdHknXHJcbiAgICAgICAgfSxcclxuICAgICAgICBQT1NJVElWRV9NVUxUSVBMSUVSUzogZmFsc2UsXHJcbiAgICAgICAgLy9DYWNoZWQgaXRlbXNcclxuICAgICAgICBDQUNIRToge30sXHJcbiAgICAgICAgLy9QcmludCBvdXQgd2FybmluZ3Mgb3Igbm90XHJcbiAgICAgICAgU0lMRU5DRV9XQVJOSU5HUzogZmFsc2UsXHJcbiAgICAgICAgLy9QcmVjaXNpb25cclxuICAgICAgICBQUkVDSVNJT046IDIxLFxyXG4gICAgICAgIC8vZnVuY3Rpb24gbWFwcGluZ3NcclxuICAgICAgICBWRUNUT1I6ICd2ZWN0b3InLFxyXG4gICAgICAgIFBBUkVOVEhFU0lTOiAncGFyZW5zJyxcclxuICAgICAgICBTUVJUOiAnc3FydCcsXHJcbiAgICAgICAgQUJTOiAnYWJzJyxcclxuICAgICAgICBGQUNUT1JJQUw6ICdmYWN0b3JpYWwnLFxyXG4gICAgICAgIERPVUJMRUZBQ1RPUklBTDogJ2RmYWN0b3JpYWwnLFxyXG4gICAgICAgIC8vcmVmZXJlbmNlIHBpIGFuZCBlXHJcbiAgICAgICAgTE9OR19QSTogJzMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwOTc0OTQ0NTkyMzA3ODE2NDA2Mjg2MjA4OTk4NjI4MDM0ODI1MzQyMTE3MDY3OTgyMTQnICtcclxuICAgICAgICAgICAgICAgICc4MDg2NTEzMjgyMzA2NjQ3MDkzODQ0NjA5NTUwNTgyMjMxNzI1MzU5NDA4MTI4NDgxMTE3NDUwMjg0MTAyNzAxOTM4NTIxMTA1NTU5NjQ0NjIyOTQ4OTU0OTMwMzgxOTYnLFxyXG4gICAgICAgIExPTkdfRTogJzIuNzE4MjgxODI4NDU5MDQ1MjM1MzYwMjg3NDcxMzUyNjYyNDk3NzU3MjQ3MDkzNjk5OTU5NTc0OTY2OTY3NjI3NzI0MDc2NjMwMzUzNTQ3NTk0NTcxMzgyMTc4NTI1MTY2NDI3NDI3NDY2JyArXHJcbiAgICAgICAgICAgICAgICAnMzkxOTMyMDAzMDU5OTIxODE3NDEzNTk2NjI5MDQzNTcyOTAwMzM0Mjk1MjYwNTk1NjMwNzM4MTMyMzI4NjI3OTQzNDkwNzYzMjMzODI5ODgwNzUzMTk1MjUxMDE5MDEnLFxyXG4gICAgICAgIFBJOiBNYXRoLlBJLFxyXG4gICAgICAgIEU6IE1hdGguRSxcclxuICAgICAgICBMT0c6ICdsb2cnLFxyXG4gICAgICAgIExPRzEwOiAnbG9nMTAnLFxyXG4gICAgICAgIExPRzEwX0xBVEVYOiAnbG9nX3sxMH0nLFxyXG4gICAgICAgIE1BWF9FWFA6IDIwMDAwMCxcclxuICAgICAgICAvL1RoZSBudW1iZXIgb2Ygc2NpZW50aWZpYyBwbGFjZSB0byByb3VuZCB0b1xyXG4gICAgICAgIFNDSUVOVElGSUNfTUFYX0RFQ0lNQUxfUExBQ0VTOiAxNCxcclxuICAgICAgICAvL1RydWUgaWYgaW50cyBzaG91bGQgbm90IGJlIGNvbnZlcnRlZCB0b1xyXG4gICAgICAgIFNDSUVOVElGSUNfSUdOT1JFX1pFUk9fRVhQT05FTlRTOiB0cnVlXHJcbiAgICB9O1xyXG5cclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgU2V0dGluZ3MuQ0FDSEUucm9vdHMgPSB7fTtcclxuICAgICAgICB2YXIgeCA9IDQwLFxyXG4gICAgICAgICAgICAgICAgeSA9IDQwO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDI7IGkgPD0geDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDI7IGogPD0geTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnRocG93ID0gYmlnSW50KGkpLnBvdyhqKTtcclxuICAgICAgICAgICAgICAgIFNldHRpbmdzLkNBQ0hFLnJvb3RzW250aHBvdyArICctJyArIGpdID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy9BZGQgdGhlIGdyb3Vwcy4gVGhlc2UgaGF2ZSBiZWVuIHJlb3JnYW5pemVkIGFzIG9mIHYwLjUuMSB0byBtYWtlIENQIHRoZSBoaWdoZXN0IGdyb3VwXHJcbiAgICAvL1RoZSBncm91cHMgdGhhdCBoZWxwIHdpdGggb3JnYW5pemluZyBkdXJpbmcgcGFyc2luZy4gTm90ZSB0aGF0IGZvciBGTiBpcyBzdGlsbCBhIGZ1bmN0aW9uIGV2ZW5cclxuICAgIC8vd2hlbiBpdCdzIHJhaXNlZCB0byBhIHN5bWJvbCwgd2hpY2ggdHlwaWNhbGx5IHJlc3VsdHMgaW4gYW4gRVhcclxuICAgIHZhciBOID0gR3JvdXBzLk4gPSAxLCAvLyBBIG51bWJlclxyXG4gICAgICAgICAgICBQID0gR3JvdXBzLlAgPSAyLCAvLyBBIG51bWJlciB3aXRoIGEgcmF0aW9uYWwgcG93ZXIgZS5nLiAyXigzLzUpLlxyXG4gICAgICAgICAgICBTID0gR3JvdXBzLlMgPSAzLCAvLyBBIHNpbmdsZSB2YXJpYWJsZSBlLmcuIHguXHJcbiAgICAgICAgICAgIEVYID0gR3JvdXBzLkVYID0gNCwgLy8gQW4gZXhwb25lbnRpYWxcclxuICAgICAgICAgICAgRk4gPSBHcm91cHMuRk4gPSA1LCAvLyBBIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIFBMID0gR3JvdXBzLlBMID0gNiwgLy8gQSBzeW1ib2wvZXhwcmVzc2lvbiBoYXZpbmcgc2FtZSBuYW1lIHdpdGggZGlmZmVyZW50IHBvd2VycyBlLmcuIDEveCArIHheMlxyXG4gICAgICAgICAgICBDQiA9IEdyb3Vwcy5DQiA9IDcsIC8vIEEgc3ltYm9sL2V4cHJlc3Npb24gY29tcG9zZWQgb2Ygb25lIG9yIG1vcmUgdmFyaWFibGVzIHRocm91Z2ggbXVsdGlwbGljYXRpb24gZS5nLiB4KnlcclxuICAgICAgICAgICAgQ1AgPSBHcm91cHMuQ1AgPSA4OyAvLyBBIHN5bWJvbC9leHByZXNzaW9uIGNvbXBvc2VkIG9mIG9uZSB2YXJpYWJsZSBhbmQgYW55IG90aGVyIHN5bWJvbCBvciBudW1iZXIgeCsxIG9yIHgreVxyXG5cclxuICAgIHZhciBDT05TVF9IQVNIID0gU2V0dGluZ3MuQ09OU1RfSEFTSCA9ICcjJztcclxuXHJcbiAgICB2YXIgUEFSRU5USEVTSVMgPSBTZXR0aW5ncy5QQVJFTlRIRVNJUztcclxuXHJcbiAgICB2YXIgU1FSVCA9IFNldHRpbmdzLlNRUlQ7XHJcblxyXG4gICAgdmFyIEFCUyA9IFNldHRpbmdzLkFCUztcclxuXHJcbiAgICB2YXIgRkFDVE9SSUFMID0gU2V0dGluZ3MuRkFDVE9SSUFMO1xyXG5cclxuICAgIHZhciBET1VCTEVGQUNUT1JJQUwgPSBTZXR0aW5ncy5ET1VCTEVGQUNUT1JJQUw7XHJcblxyXG4gICAgLy90aGUgc3RvcmFnZSBjb250YWluZXIgXCJtZW1vcnlcIiBmb3IgcGFyc2VkIGV4cHJlc3Npb25zXHJcbiAgICB2YXIgRVhQUkVTU0lPTlMgPSBbXTtcclxuXHJcbiAgICAvL3ZhcmlhYmxlc1xyXG4gICAgdmFyIFZBUlMgPSB7fTtcclxuXHJcbiAgICAvL3RoZSBjb250YWluZXIgdXNlZCB0byBzdG9yZSBhbGwgdGhlIHJlc2VydmVkIGZ1bmN0aW9uc1xyXG4gICAgdmFyIFJFU0VSVkVEID0gW107XHJcblxyXG4gICAgdmFyIFdBUk5JTkdTID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgdGhpcyB3aGVuIGVycm9ycyBhcmUgc3VwcHJlc3NpYmxlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRXJyb3JPYmpcclxuICAgICAqL1xyXG4gICAgdmFyIGVyciA9IGZ1bmN0aW9uIChtc2csIEVycm9yT2JqKSB7XHJcbiAgICAgICAgaWYoIVNldHRpbmdzLnN1cHByZXNzX2Vycm9ycykge1xyXG4gICAgICAgICAgICBpZihFcnJvck9iailcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvck9iaihtc2cpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuLy9VdGlscyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIHZhciBjdXN0b21FcnJvciA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIEUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlIDogJyc7XHJcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBlcnJvci5uYW1lID0gdGhpcy5uYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XHJcbiAgICAgICAgfTsgLy9jcmVhdGUgYW4gZW1wdHkgZXJyb3JcclxuICAgICAgICBFLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gRTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHZhbHVlIGlzIG9uZSBvZiBuZXJkYW1lcidzIHJlc2VydmVkIG5hbWVzXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcclxuICAgICAqIEByZXR1cm4gYm9vbGVhblxyXG4gICAgICovXHJcbiAgICB2YXIgaXNSZXNlcnZlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBSRVNFUlZFRC5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSB0aGF0IGFsbCBzeW1ib2xzIGluIGFycmF5IGFyZSB0aGUgc2FtZVxyXG4gICAgICogQHBhcmFtIHtTeW1ib2xbXX0gYXJyXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbH1cclxuICAgICAqL1xyXG4gICAgdmFyIGFsbFNhbWUgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgdmFyIGxhc3QgPSBhcnJbMF07XHJcbiAgICAgICAgZm9yKHZhciBpID0gMSwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgIGlmKCFhcnJbaV0uZXF1YWxzKGxhc3QpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gcGFzcyB3YXJuaW5ncyBvciBsb3cgc2V2ZXJpdHkgZXJyb3JzIGFib3V0IHRoZSBsaWJyYXJ5XHJcbiAgICAgKiBAcGFyYW0gbXNnXHJcbiAgICAgKi9cclxuICAgIHZhciB3YXJuID0gZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgIFdBUk5JTkdTLnB1c2gobXNnKTtcclxuICAgICAgICBpZihTZXR0aW5ncy5TSE9XX1dBUk5JTkdTICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmZvcmNlcyBydWxlOiBcIm11c3Qgc3RhcnQgd2l0aCBhIGxldHRlciBvciB1bmRlcnNjb3JlIGFuZFxyXG4gICAgICogY2FuIGhhdmUgYW55IG51bWJlciBvZiB1bmRlcnNjb3JlcywgbGV0dGVycywgYW5kIG51bWJlcnMgdGhlcmVhZnRlci5cIlxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbCBiZWluZyBjaGVja2VkXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwIC0gVGhlIHR5cGUgb2Ygc3ltYm9scyB0aGF0J3MgYmVpbmcgdmFsaWRhdGVkXHJcbiAgICAgKiBAdGhyb3dzIHtFeGNlcHRpb259ICAtIFRocm93cyBhbiBleGNlcHRpb24gb24gZmFpbFxyXG4gICAgICovXHJcbiAgICB2YXIgdmFsaWRhdGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIHR5cCkge1xyXG4gICAgICAgIHR5cCA9IHR5cCB8fCAndmFyaWFibGUnO1xyXG4gICAgICAgIGlmKFNldHRpbmdzLkFMTE9XX0NIQVJTLmluZGV4T2YobmFtZSkgIT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHJlZ2V4ID0gU2V0dGluZ3MuVkFMSURBVElPTl9SRUdFWDtcclxuICAgICAgICBpZighKHJlZ2V4LnRlc3QobmFtZSkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVmFyaWFibGVOYW1lRXJyb3IobmFtZSArICcgaXMgbm90IGEgdmFsaWQgJyArIHR5cCArICcgbmFtZScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IG51bWJlciBmcm9tIHNjaWVudGlmaWMgZm9ybWF0IHRvIGRlY2ltYWwgZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXHJcbiAgICAgKi9cclxuICAgIHZhciBzY2llbnRpZmljVG9EZWNpbWFsID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBuc2lnbiA9IE1hdGguc2lnbihudW0pO1xyXG4gICAgICAgIC8vcmVtb3ZlIHRoZSBzaWduXHJcbiAgICAgICAgbnVtID0gTWF0aC5hYnMobnVtKTtcclxuICAgICAgICAvL2lmIHRoZSBudW1iZXIgaXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiByZW1vdmUgaXRcclxuICAgICAgICBpZigvXFxkK1xcLj9cXGQqZVtcXCtcXC1dKlxcZCsvaS50ZXN0KG51bSkpIHtcclxuICAgICAgICAgICAgdmFyIHplcm8gPSAnMCcsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFydHMgPSBTdHJpbmcobnVtKS50b0xvd2VyQ2FzZSgpLnNwbGl0KCdlJyksIC8vc3BsaXQgaW50byBjb2VmZiBhbmQgZXhwb25lbnRcclxuICAgICAgICAgICAgICAgICAgICBlID0gcGFydHMucG9wKCksIC8vc3RvcmUgdGhlIGV4cG9uZW50aWFsIHBhcnRcclxuICAgICAgICAgICAgICAgICAgICBsID0gTWF0aC5hYnMoZSksIC8vZ2V0IHRoZSBudW1iZXIgb2YgemVyb3NcclxuICAgICAgICAgICAgICAgICAgICBzaWduID0gZSAvIGwsXHJcbiAgICAgICAgICAgICAgICAgICAgY29lZmZfYXJyYXkgPSBwYXJ0c1swXS5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICBpZihzaWduID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbCA9IGwgLSBjb2VmZl9hcnJheVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZihsIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IGNvZWZmX2FycmF5WzBdLnNsaWNlKDAsIGwpICsgJy4nICsgY29lZmZfYXJyYXlbMF0uc2xpY2UobCkgKyAoY29lZmZfYXJyYXkubGVuZ3RoID09PSAyID8gY29lZmZfYXJyYXlbMV0gOiAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBudW0gPSB6ZXJvICsgJy4nICsgbmV3IEFycmF5KGwgKyAxKS5qb2luKHplcm8pICsgY29lZmZfYXJyYXkuam9pbignJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjID0gY29lZmZfYXJyYXlbMV07XHJcbiAgICAgICAgICAgICAgICBpZihkZWMpXHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IGwgLSBkZWMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYobCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBudW0gPSBjb2VmZl9hcnJheVswXSArIGRlYy5zbGljZSgwLCBsKSArICcuJyArIGRlYy5zbGljZShsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IGNvZWZmX2FycmF5LmpvaW4oJycpICsgbmV3IEFycmF5KGwgKyAxKS5qb2luKHplcm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnNpZ24gPCAwID8gJy0nICsgbnVtIDogbnVtO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIG51bWJlciBpcyBhIHByaW1lIG51bWJlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gLSB0aGUgbnVtYmVyIHRvIGJlIGNoZWNrZWRcclxuICAgICAqL1xyXG4gICAgdmFyIGlzUHJpbWUgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHZhciBxID0gTWF0aC5mbG9vcihNYXRoLnNxcnQobikpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDI7IGkgPD0gcTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKG4gJSBpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGgga25vd24gdmFyaWFibGUgdmFsdWUgZm9yIGV2YWx1YXRpb25cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YXJpYWJsZVxyXG4gICAgICogQHBhcmFtIHthbnl9IHZhbHVlIEFueSBzdHJpbmdpZnlhYmxlIG9iamVjdFxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gXHJcbiAgICAgKi9cclxuICAgIHZhciBrbm93blZhcmlhYmxlID0gZnVuY3Rpb24gKHZhcmlhYmxlLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBvID0ge307XHJcbiAgICAgICAgb1t2YXJpYWJsZV0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gbztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgbiBpcyBhIG51bWJlclxyXG4gICAgICogQHBhcmFtIHthbnl9IG5cclxuICAgICAqL1xyXG4gICAgdmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICByZXR1cm4gL15cXGQrXFwuP1xcZCokLy50ZXN0KG4pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgYW4gYXJyYXkgY29udGFpbnMgb25seSBudW1lcmljIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXHJcbiAgICAgKi9cclxuICAgIHZhciBhbGxOdW1lcmljID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmKCFpc051bWJlcihhcnJbaV0pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhIG51bWJlciBvciBTeW1ib2wgaXMgYSBmcmFjdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ8U3ltYm9sfSBudW1cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB2YXIgaXNGcmFjdGlvbiA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICBpZihpc1N5bWJvbChudW0pKVxyXG4gICAgICAgICAgICByZXR1cm4gaXNGcmFjdGlvbihudW0ubXVsdGlwbGllci50b0RlY2ltYWwoKSk7XHJcbiAgICAgICAgcmV0dXJuIChudW0gJSAxICE9PSAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBvYmplY3QgcHJvdmlkZWQgaXMgYSBTeW1ib2xcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICAgICAqL1xyXG4gICAgdmFyIGlzU3ltYm9sID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgU3ltYm9sKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBvYmplY3QgcHJvdmlkZWQgaXMgYW4gRXhwcmVzc2lvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAgICovXHJcbiAgICB2YXIgaXNFeHByZXNzaW9uID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgRXhwcmVzc2lvbik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgdHJhdmVyc2VzIHRoZSBzeW1ib2wgc3RydWN0dXJlIGFuZCBncmFicyBhbGwgdGhlIHZhcmlhYmxlcyBpbiBhIHN5bWJvbC4gVGhlIHZhcmlhYmxlXHJcbiAgICAgKiBuYW1lcyBhcmUgdGhlbiByZXR1cm5lZCBpbiBhbHBoYWJldGljYWwgb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gb2JqXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHBvbHlcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHZhcmlhYmxlcy4gRG8gbm90IHBhc3MgdGhpcyBpbiBhcyBpdCBnZW5lcmF0ZWRcclxuICAgICAqIGF1dG9tYXRpY2FsbHkuIEluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIGJlIGEgQ29sbGVjdG9yIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX0gLSBBbiBhcnJheSBjb250YWluaW5nIHZhcmlhYmxlIG5hbWVzXHJcbiAgICAgKi9cclxuICAgIHZhciB2YXJpYWJsZXMgPSBmdW5jdGlvbiAob2JqLCBwb2x5LCB2YXJzKSB7XHJcbiAgICAgICAgdmFycyA9IHZhcnMgfHwge1xyXG4gICAgICAgICAgICBjOiBbXSxcclxuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuYy5pbmRleE9mKHZhbHVlKSA9PT0gLTEgJiYgaXNOYU4odmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmKGlzU3ltYm9sKG9iaikpIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gb2JqLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZncm91cCA9IG9iai5wcmV2aW91c0dyb3VwO1xyXG4gICAgICAgICAgICBpZihncm91cCA9PT0gRVgpXHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMob2JqLnBvd2VyLCBwb2x5LCB2YXJzKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGdyb3VwID09PSBDUCB8fCBncm91cCA9PT0gQ0IgfHwgcHJldmdyb3VwID09PSBDUCB8fCBwcmV2Z3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gb2JqLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMob2JqLnN5bWJvbHNbeF0sIHBvbHksIHZhcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IFMgfHwgcHJldmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAvL3ZlcnkgY3J1ZGUgbmVlZHMgZml4aW5nLiBUT0RPXHJcbiAgICAgICAgICAgICAgICBpZighKG9iai52YWx1ZSA9PT0gJ2UnIHx8IG9iai52YWx1ZSA9PT0gJ3BpJyB8fCBvYmoudmFsdWUgPT09IFNldHRpbmdzLklNQUdJTkFSWSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFycy5hZGQob2JqLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBQTCB8fCBwcmV2Z3JvdXAgPT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMoZmlyc3RPYmplY3Qob2JqLnN5bWJvbHMpLCBwb2x5LCB2YXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgaWYoIWlzTmFOKG9iai52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFycy5hZGQob2JqLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyhvYmoucG93ZXIsIHBvbHksIHZhcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IEZOICYmICFwb2x5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXMob2JqLmFyZ3NbaV0sIHBvbHksIHZhcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFycy5jLnNvcnQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgYW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0b051bWJlclxyXG4gICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5U3VtID0gZnVuY3Rpb24gKGFyciwgdG9OdW1iZXIpIHtcclxuICAgICAgICB2YXIgc3VtID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gYXJyW2ldO1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN5bWJvbCBpZiBub3RcclxuICAgICAgICAgICAgc3VtID0gXy5hZGQoc3VtLCAhaXNTeW1ib2woeCkgPyBfLnBhcnNlKHgpIDogeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG9OdW1iZXIgPyBOdW1iZXIoc3VtKSA6IHN1bTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXBhcmF0ZXMgb3V0IHRoZSB2YXJpYWJsZXMgaW50byB0ZXJtcyBvZiB2YXJpYWJscy5cclxuICAgICAqIGUuZy4geCt5K3gqeStzcXJ0KDIpK3BpIHJldHVybnNcclxuICAgICAqIHt4OiB4LCB5OiB5LCB4IHk6IHgqeSwgY29uc3RhbnRzOiBzcXJ0KDIpK3BpXHJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHN5bWJvbFxyXG4gICAgICogQHBhcmFtIHt0eXBlfSBvXHJcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IGZvciBleHBvbnRlbnRpYWxzXHJcbiAgICAgKi9cclxuICAgIHZhciBzZXBhcmF0ZSA9IGZ1bmN0aW9uIChzeW1ib2wsIG8pIHtcclxuICAgICAgICBzeW1ib2wgPSBfLmV4cGFuZChzeW1ib2wpO1xyXG4gICAgICAgIG8gPSBvIHx8IHt9O1xyXG4gICAgICAgIHZhciBpbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCBzeW0pIHtcclxuICAgICAgICAgICAgaWYoIW9ba2V5XSlcclxuICAgICAgICAgICAgICAgIG9ba2V5XSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgIG9ba2V5XSA9IF8uYWRkKG9ba2V5XSwgc3ltLmNsb25lKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYoeC5pc0NvbnN0YW50KCdhbGwnKSkge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0KCdjb25zdGFudHMnLCB4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHguZ3JvdXAgPT09IFMpIHtcclxuICAgICAgICAgICAgICAgIGluc2VydCh4LnZhbHVlLCB4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHguZ3JvdXAgPT09IEZOICYmICh4LmZuYW1lID09PSBBQlMgfHwgeC5mbmFtZSA9PT0gJycpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0ZSh4LmFyZ3NbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoeC5ncm91cCA9PT0gRVggfHwgeC5ncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNlcGFyYXRlLiBUZXJtIGNhbm5vdCBiZSBhIGZ1bmN0aW9uIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5zZXJ0KHZhcmlhYmxlcyh4KS5qb2luKCcgJyksIHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGxzIGhvbGVzIGluIGFuIGFycmF5IHdpdGggemVybyBzeW1ib2wgb3IgZ2VuZXJhdGVzIG9uZSB3aXRoIG4gemVyb2VzXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXHJcbiAgICAgKi9cclxuICAgIHZhciBmaWxsSG9sZXMgPSBmdW5jdGlvbiAoYXJyLCBuKSB7XHJcbiAgICAgICAgbiA9IG4gfHwgYXJyLmxlbmd0aDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzeW0gPSBhcnJbaV07XHJcbiAgICAgICAgICAgIGlmKCFzeW0pXHJcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBvYmplY3QgcHJvdmlkZWQgaXMgYSBWZWN0b3JcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICAgICAqL1xyXG4gICAgdmFyIGlzVmVjdG9yID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgVmVjdG9yKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBvYmplY3QgcHJvdmlkZWQgaXMgYSBNYXRyaXhcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICAgICAqL1xyXG4gICAgdmFyIGlzTWF0cml4ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgTWF0cml4KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGlzU2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgU2V0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgc3ltYm9sIGlzIGluIGdyb3VwIE5cclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAqL1xyXG4gICAgdmFyIGlzTnVtZXJpY1N5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICByZXR1cm4gc3ltYm9sLmdyb3VwID09PSBOIHx8IHN5bWJvbC5ncm91cCA9PT0gUDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgc3ltYm9sIGlzIGEgdmFyaWFibGUgd2l0aCBubyBtdWx0aXBsaWVyIG5vciBwb3dlclxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICovXHJcbiAgICB2YXIgaXNWYXJpYWJsZVN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICByZXR1cm4gc3ltYm9sLmdyb3VwID09PSBTICYmIHN5bWJvbC5tdWx0aXBsaWVyLmVxdWFscygxKSAmJiBzeW1ib2wucG93ZXIuZXF1YWxzKDEpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG9iamVjdCBwcm92aWRlZCBpcyBhbiBBcnJheVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFyclxyXG4gICAgICovXHJcbiAgICB2YXIgaXNBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgYSBudW1iZXIgaXMgYW4gaW50ZWdlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG51bVxyXG4gICAgICovXHJcbiAgICB2YXIgaXNJbnQgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIC9eWy0rXT9cXGQrZT9cXCs/XFxkKiQvZ2ltLnRlc3QobnVtLnRvU3RyaW5nKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfFN5bWJvbH0gb2JqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdmFyIGlzTmVnYXRpdmUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgaWYoaXNTeW1ib2wob2JqKSkge1xyXG4gICAgICAgICAgICBvYmogPSBvYmoubXVsdGlwbGllcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iai5sZXNzVGhhbigwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNhZmVseSBzdHJpbmdpZnkgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0gb1xyXG4gICAgICovXHJcbiAgICB2YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZighbylcclxuICAgICAgICAgICAgcmV0dXJuIG87XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhvKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIHJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHN1cnJvdW5kZWQgYnkgYnJhY2tldHNcclxuICAgICAqL1xyXG4gICAgdmFyIGluQnJhY2tldHMgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuICcoJyArIHN0ciArICcpJztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZXBsYWNlIHBhcnRzIG9mIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFRoZSBvcmlnaW5hbCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZnJvbSAtIFRoZSBzdGFydGluZyBpbmRleFxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB0byAtIFRoZSBlbmRpbmcgaW5kZXhcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aXRoX3N0ciAtIFRoZSByZXBsYWNlbWVudCBzdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gQSBmb3JtYXR0ZWQgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHZhciBzdHJpbmdSZXBsYWNlID0gZnVuY3Rpb24gKHN0ciwgZnJvbSwgdG8sIHdpdGhfc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgZnJvbSkgKyB3aXRoX3N0ciArIHN0ci5zdWJzdHIodG8sIHN0ci5sZW5ndGgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoZSBQYXJzZXIgdXNlcyB0aGlzIHRvIGNoZWNrIGlmIGl0J3MgYWxsb3dlZCB0byBjb252ZXJ0IHRoZSBvYmogdG8gdHlwZSBTeW1ib2xcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB2YXIgY3VzdG9tVHlwZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqLmN1c3RvbTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIG51bWJlcnMgYXJlIGJvdGggbmVnYXRpdmUgb3IgYXJlIGJvdGggcG9zaXRpdmVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHZhciBzYW1lU2lnbiA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIChhIDwgMCkgPT09IChiIDwgMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSBtdWx0aXBsZSBvY2N1cmVuY2VzIGluIGEgc3RyaW5nLiBUYWtlcyBtdWx0aXBsZSBhcmd1bWVudHNcclxuICAgICAqIEBleGFtcGxlIGZvcm1hdCgnezB9IG5pY2UsIHswfSBzd2VldCcsICdzb21ldGhpbmcnKVxyXG4gICAgICogLy9yZXR1cm5zICdzb21ldGhpbmcgbmljZSwgc29tZXRoaW5nIHN3ZWV0J1xyXG4gICAgICovXHJcbiAgICB2YXIgZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxyXG4gICAgICAgICAgICAgICAgc3RyID0gYXJncy5zaGlmdCgpO1xyXG4gICAgICAgIHZhciBuZXdfc3RyID0gc3RyLnJlcGxhY2UoL3soXFxkKyl9L2csIGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaW5kZXhdO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZygpIDogYXJnO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmV3X3N0cjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYW4gYXJyYXkgd2l0aCB2YWx1ZXMgd2l0aGluIGEgcmFuZ2UuIE11bHRpcGxpZXMgYnkgYSBzdGVwIGlmIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXHJcbiAgICAgKi9cclxuICAgIHZhciByYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIHN0ZXAgPSBzdGVwIHx8IDE7XHJcbiAgICAgICAgZm9yKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspXHJcbiAgICAgICAgICAgIGFyci5wdXNoKGkgKiBzdGVwKTtcclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBrZXlzIGluIGFuIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCBpdGVtIGluIGFuIG9iamVjdC4gSXRlbXMgZG8gbm90IGhhdmUgYSBmaXhlZCBvcmRlciBpbiBvYmplY3RzXHJcbiAgICAgKiBzbyBvbmx5IHVzZSBpZiB5b3UgbmVlZCBhbnkgZmlyc3QgcmFuZG9tIG9yIGlmIHRoZXJlJ3Mgb25seSBvbmUgaXRlbSBpbiB0aGUgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFJldHVybiB0aGlzIGtleSBhcyBmaXJzdCBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYm90aFxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIHZhciBmaXJzdE9iamVjdCA9IGZ1bmN0aW9uIChvYmosIGtleSwgYm90aCkge1xyXG4gICAgICAgIGZvcih2YXIgeCBpbiBvYmopXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmKGtleSlcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgaWYoYm90aClcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGtleTogeCxcclxuICAgICAgICAgICAgICAgIG9iajogb2JqW3hdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG9ialt4XTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzdGl0dXRlcyBvdXQgdmFyaWFibGVzIGZvciB0d28gc3ltYm9scywgcGFyc2VzIHRoZW0gdG8gYSBudW1iZXIgYW5kIHRoZW0gY29tcGFyZXMgdGhlbSBudW1lcmljYWxseVxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bTFcclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW0yXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB2YXJzIC0gYW4gb3B0aW9uYWwgYXJyYXkgb2YgdmFyaWFibGVzIHRvIHVzZVxyXG4gICAgICogQHJldHVybnMge2Jvb2x9XHJcbiAgICAgKi9cclxuICAgIHZhciBjb21wYXJlID0gZnVuY3Rpb24gKHN5bTEsIHN5bTIsIHZhcnMpIHtcclxuICAgICAgICB2YXIgbiA9IDU7IC8vYSByYW5kb20gbnVtYmVyIGJldHdlZW4gMSBhbmQgNSBpcyBnb29kIGVub3VnaFxyXG4gICAgICAgIHZhciBzY29wZSA9IHt9OyAvLyBzY29wZSBvYmplY3Qgd2l0aCByYW5kb20gbnVtYmVycyBnZW5lcmF0ZWQgdXNpbmcgdmFyc1xyXG4gICAgICAgIHZhciBjb21wYXJpc29uO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBzY29wZVt2YXJzW2ldXSA9IG5ldyBTeW1ib2woTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbikgKyAxKTtcclxuICAgICAgICBibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBjb21wYXJpc29uID0gXy5wYXJzZShzeW0xLCBzY29wZSkuZXF1YWxzKF8ucGFyc2Uoc3ltMiwgc2NvcGUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcGFyaXNvbjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJcyB1c2VkIHRvIHNldCBhIHVzZXIgZGVmaW5lZCBmdW5jdGlvbiB1c2luZyB0aGUgZnVuY3Rpb24gYXNzaWduIG9wZXJhdG9yXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGFyYW1zX2FycmF5XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYm9keVxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHZhciBzZXRGdW5jdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXNfYXJyYXksIGJvZHkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgaWYoIWlzUmVzZXJ2ZWQobmFtZSkpIHtcclxuICAgICAgICAgICAgcGFyYW1zX2FycmF5ID0gcGFyYW1zX2FycmF5IHx8IHZhcmlhYmxlcyhfLnBhcnNlKGJvZHkpKTtcclxuICAgICAgICAgICAgLy8gVGhlIGZ1bmN0aW9uIGdldHMgc2V0IHRvIFBBUlNFUi5tYXBwZWQgZnVuY3Rpb24gd2hpY2ggaXMganVzdFxyXG4gICAgICAgICAgICAvLyBhIGdlbmVyaWMgZnVuY3Rpb24gY2FsbC5cclxuICAgICAgICAgICAgXy5mdW5jdGlvbnNbbmFtZV0gPSBbXy5tYXBwZWRfZnVuY3Rpb24sIHBhcmFtc19hcnJheS5sZW5ndGgsIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zX2FycmF5LFxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcclxuICAgICAgICAgICAgICAgIH1dO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pbmltdW0gbnVtYmVyIGluIGFuIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBhcnJheU1heCA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkodW5kZWZpbmVkLCBhcnIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIGluIGFuIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHZhciBhcnJheU1pbiA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkodW5kZWZpbmVkLCBhcnIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdHdvIGFycmF5cyBhcmUgZXF1YWxcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycjEgXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIyIFxyXG4gICAgICovXHJcbiAgICB2YXIgYXJyYXlFcXVhbCA9IGZ1bmN0aW9uIChhcnIxLCBhcnIyKSB7XHJcbiAgICAgICAgYXJyMS5zb3J0KCk7XHJcbiAgICAgICAgYXJyMi5zb3J0KCk7XHJcblxyXG4gICAgICAgIC8vIFRoZSBtdXN0IGJlIG9mIHRoZSBzYW1lIGxlbmd0aFxyXG4gICAgICAgIGlmKGFycjEubGVuZ3RoID09PSBhcnIyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYW55IHR3byBpdGVtcyBkb24ndCBtYXRjaCB3ZSdyZSBkb25lXHJcbiAgICAgICAgICAgICAgICBpZihhcnIxW2ldICE9PSBhcnIyW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGV5J3JlIGVxdWFsXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb25lcyBhcnJheSB3aXRoIGNsb25hYmxlIGl0ZW1zXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5Q2xvbmUgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgdmFyIG5ld19hcnJheSA9IFtdLCBsID0gYXJyLmxlbmd0aDtcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgICBuZXdfYXJyYXlbaV0gPSBhcnJbaV0uY2xvbmUoKTtcclxuICAgICAgICByZXR1cm4gbmV3X2FycmF5O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbGxzIG51bWJlcnMgYmV0d2VlbiBhcnJheSB2YWx1ZXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyc1tdfSBhcnJcclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gc2xpY2VzXHJcbiAgICAgKi9cclxuICAgIHZhciBhcnJheUFkZFNsaWNlcyA9IGZ1bmN0aW9uIChhcnIsIHNsaWNlcykge1xyXG4gICAgICAgIHNsaWNlcyA9IHNsaWNlcyB8fCAyMDtcclxuICAgICAgICB2YXIgcmV0dmFsID0gW107XHJcbiAgICAgICAgdmFyIGMsIGRlbHRhLCBlO1xyXG4gICAgICAgIHJldHZhbC5wdXNoKGFyclswXSk7IC8vcHVzaCB0aGUgYmVnaW5uaW5nXHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgYyA9IGFycltpXTtcclxuICAgICAgICAgICAgZGVsdGEgPSBhcnJbaSArIDFdIC0gYzsgLy9nZXQgdGhlIGRpZmZlcmVuY2VcclxuICAgICAgICAgICAgZSA9IGRlbHRhIC8gc2xpY2VzOyAvL2Nob3AgaXQgdXAgaW4gdGhlIGRlc2lyZWQgbnVtYmVyIG9mIHNsaWNlc1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgc2xpY2VzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGMgKz0gZTsgLy9hZGQgdGhlIG1lc2ggdG8gdGhlIGxhc3Qgc2xpY2VcclxuICAgICAgICAgICAgICAgIHJldHZhbC5wdXNoKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgbnRoIHJvb3RzIG9mIGEgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgKiBAcmV0dXJucyB7VmVjdG9yfVxyXG4gICAgICovXHJcbiAgICB2YXIgbnJvb3RzID0gZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgIHZhciBhLCBiO1xyXG5cclxuICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IEZOICYmIHN5bWJvbC5mbmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgYSA9IFN5bWJvbC51bndyYXBQQVJFTlMoXy5wYXJzZShzeW1ib2wpLnRvTGluZWFyKCkpO1xyXG4gICAgICAgICAgICBiID0gXy5wYXJzZShzeW1ib2wucG93ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gUCkge1xyXG4gICAgICAgICAgICBhID0gXy5wYXJzZShzeW1ib2wudmFsdWUpO1xyXG4gICAgICAgICAgICBiID0gXy5wYXJzZShzeW1ib2wucG93ZXIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoYSAmJiBiICYmIChhLmdyb3VwID09PSBOKSAmJiBiLmdyb3VwID09PSBOICYmIGEubXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgdmFyIF9yb290cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gU3ltYm9sLnRvUG9sYXJGb3JtQXJyYXkoZXZhbHVhdGUoc3ltYm9sKSk7XHJcbiAgICAgICAgICAgIHZhciByID0gcGFydHNbMF07XHJcblxyXG4gICAgICAgICAgICAvL3ZhciByID0gXy5wYXJzZShhKS5hYnMoKS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZV9Nb2l2cmUlMjdzX2Zvcm11bGFcclxuICAgICAgICAgICAgdmFyIHggPSBfLmFyZyhhKTtcclxuICAgICAgICAgICAgdmFyIG4gPSBiLm11bHRpcGxpZXIuZGVuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIHZhciBwID0gYi5tdWx0aXBsaWVyLm51bS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZvcm11bGEgPSAnKCh7MH0pXih7MX0pKihjb3MoezN9KSsoezJ9KSpzaW4oezN9KSkpXih7NH0pJztcclxuXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gZXZhbHVhdGUoXy5wYXJzZShmb3JtYXQoXCIoKHswfSkrMipwaSooezF9KSkvKHsyfSlcIiwgeCwgaSwgbikpKS5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgX3Jvb3RzLnB1c2goZXZhbHVhdGUoXy5wYXJzZShmb3JtYXQoZm9ybXVsYSwgciwgbiwgU2V0dGluZ3MuSU1BR0lOQVJZLCB0LCBwKSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLmZyb21BcnJheShfcm9vdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHN5bWJvbC5pc0NvbnN0YW50KHRydWUsIHRydWUpKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gc3ltYm9sLnNpZ24oKTtcclxuICAgICAgICAgICAgdmFyIHggPSBldmFsdWF0ZShzeW1ib2wuYWJzKCkpO1xyXG4gICAgICAgICAgICB2YXIgcm9vdCA9IF8uc3FydCh4KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBfcm9vdHMgPSBbcm9vdC5jbG9uZSgpLCByb290Lm5lZ2F0ZSgpXTtcclxuXHJcbiAgICAgICAgICAgIGlmKHNpZ24gPCAwKVxyXG4gICAgICAgICAgICAgICAgX3Jvb3RzID0gX3Jvb3RzLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHgsIFN5bWJvbC5pbWFnaW5hcnkoKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfcm9vdHMgPSBbXy5wYXJzZShzeW1ib2wpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBWZWN0b3IuZnJvbUFycmF5KF9yb290cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29ydHMgYW5kIGFycmF5IGdpdmVuIDIgcGFyYW1ldGVyc1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiXHJcbiAgICAgKi9cclxuICAgIHZhciBjb21ib1NvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBjb21iaW5lZCA9IFtdOyAvL3RoZSBsaW5rZXJcclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb21iaW5lZC5wdXNoKFthW2ldLCBiW2ldXSk7IC8vY3JlYXRlIHRoZSBtYXBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbWJpbmVkLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHhbMF0gLSB5WzBdO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB2YXIgbmEgPSBbXSwgbmIgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5hLnB1c2goY29tYmluZWRbaV1bMF0pO1xyXG4gICAgICAgICAgICBuYi5wdXNoKGNvbWJpbmVkW2ldWzFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBbbmEsIG5iXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRPRE86IFBpY2sgYSBtb3JlIGRlc2NyaXB0aXZlIG5hbWUgYW5kIGJldHRlciBkZXNjcmlwdGlvblxyXG4gICAgICogQnJlYWtzIGEgZnVuY3Rpb24gZG93biBpbnRvIGl0J3MgcGFydHMgd3J0IHRvIGEgdmFyaWFibGUsIG1haW5seSBjb2VmZmljaWVudHNcclxuICAgICAqIEV4YW1wbGUgYSp4XjIrYiB3cnQgeFxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IGZuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd3J0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2x9IGFzX29ialxyXG4gICAgICovXHJcbiAgICB2YXIgZGVjb21wb3NlX2ZuID0gZnVuY3Rpb24gKGZuLCB3cnQsIGFzX29iaikge1xyXG4gICAgICAgIHdydCA9IFN0cmluZyh3cnQpOyAvL2NvbnZlcnQgdG8gc3RyaW5nXHJcbiAgICAgICAgdmFyIGF4LCBhLCB4LCBiO1xyXG4gICAgICAgIGlmKGZuLmdyb3VwID09PSBDUCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IF8uZXhwYW5kKGZuLmNsb25lKCkpLnN0cmlwVmFyKHdydCk7XHJcbiAgICAgICAgICAgIGF4ID0gXy5zdWJ0cmFjdChmbi5jbG9uZSgpLCB0LmNsb25lKCkpO1xyXG4gICAgICAgICAgICBiID0gdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBheCA9IGZuLmNsb25lKCk7XHJcbiAgICAgICAgYSA9IGF4LnN0cmlwVmFyKHdydCk7XHJcbiAgICAgICAgeCA9IF8uZGl2aWRlKGF4LmNsb25lKCksIGEuY2xvbmUoKSk7XHJcbiAgICAgICAgYiA9IGIgfHwgbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICBpZihhc19vYmopXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBhOiBhLFxyXG4gICAgICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgICAgIGF4OiBheCxcclxuICAgICAgICAgICAgICAgIGI6IGJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gW2EsIHgsIGF4LCBiXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJvdW5kcyBhIG51bWJlciB1cCB0byB4IGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNcclxuICAgICAqL1xyXG4gICAgdmFyIG5yb3VuZCA9IGZ1bmN0aW9uICh4LCBzKSB7XHJcbiAgICAgICAgaWYoaXNJbnQoeCkpIHtcclxuICAgICAgICAgICAgaWYoeCA+PSBOdW1iZXIuTUFYX1ZBTFVFKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHMgPSB0eXBlb2YgcyA9PT0gJ3VuZGVmaW5lZCcgPyAxNCA6IHM7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoeCAqIE1hdGgucG93KDEwLCBzKSkgLyBNYXRoLnBvdygxMCwgcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSXMgdXNlZCBmb3IgdS1zdWJzdGl0dXRpb24uIEdldHMgYSBzdWl0YWJsZSB1IGZvciBzdWJzdGl0dXRpb24uIElmIGZvclxyXG4gICAgICogaW5zdGFuY2UgYSBpcyB1c2VkIGluIHRoZSBzeW1ib2wgdGhlbiBpdCBrZWVwcyBnb2luZyBkb3duIHRoZSBsaW5lIHVudGlsXHJcbiAgICAgKiBvbmUgaXMgZm91bmQgdGhhdCdzIG5vdCBpbiB1c2UuIElmIGFsbCBsZXR0ZXJzIGFyZSB0YWtlbiB0aGVuIGl0XHJcbiAgICAgKiBzdGFydHMgYXBwZW5kaW5nIG51bWJlcnMuXHJcbiAgICAgKiBJTVBPUlRBTlQhIEl0IGFzc3VtZXMgdGhhdCB0aGUgc3Vic3RpdHV0aW9uIHdpbGwgYmUgdW5kb25lXHJcbiAgICAgKiBiZW9yZSB0aGUgdXNlciBnZXRzIHRvIGludGVyYWN0IHdpdGggdGhlIG9iamVjdCBhZ2Fpbi5cclxuICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAqL1xyXG4gICAgdmFyIGdldFUgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgLy9zdGFydCB3aXRoIHVcclxuICAgICAgICB2YXIgdSA9ICd1JywgLy9zdGFydCB3aXRoIHVcclxuICAgICAgICAgICAgICAgIHYgPSB1LCAvL2luaXQgd2l0aCB1XHJcbiAgICAgICAgICAgICAgICBjID0gMCwgLy9wb3N0Zml4IG51bWJlclxyXG4gICAgICAgICAgICAgICAgdmFycyA9IHZhcmlhYmxlcyhzeW1ib2wpO1xyXG4gICAgICAgIC8vbWFrZSBzdXJlIHRoaXMgdmFyaWFibGUgaXNuJ3QgcmVzZXJ2ZWQgYW5kIGlzbid0IGluIHRoZSB2YXJpYWJsZSBsaXN0XHJcbiAgICAgICAgd2hpbGUoIShSRVNFUlZFRC5pbmRleE9mKHYpID09PSAtIDEgJiYgdmFycy5pbmRleE9mKHYpID09PSAtIDEpKVxyXG4gICAgICAgICAgICB2ID0gdSArIGMrKztcclxuICAgICAgICAvL2dldCBhbiBlbXB0eSBzbG90LiBJdCBzZWVtcyBlYXNpZXIgdG8ganVzdCBwdXNoIGJ1dCB0aGVcclxuICAgICAgICAvL3Byb2JsZW0gaXMgdGhhdCB3ZSBtYXkgaGF2ZSBzb21lIHdoaWNoIGFyZSBjcmVhdGVkIGJ5IGNsZWFyVVxyXG4gICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBSRVNFUlZFRC5sZW5ndGg7IGkgPD0gbDsgaSsrKVxyXG4gICAgICAgICAgICAvL3Jlc2VydmVkIGNhbm5vdCBlcXVhbHMgZmFsc2Ugb3IgMCBzbyB3ZSBjYW4gc2FmZWx5IGNoZWNrIGZvciBhIGZhbHN5IHR5cGVcclxuICAgICAgICAgICAgaWYoIVJFU0VSVkVEW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBSRVNFUlZFRFtpXSA9IHY7IC8vcmVzZXJ2ZSB0aGUgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSB1IHZhcmlhYmxlIHNvIGl0J3Mgbm8gbG9uZ2VyIHJlc2VydmVkXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdVxyXG4gICAgICovXHJcbiAgICB2YXIgY2xlYXJVID0gZnVuY3Rpb24gKHUpIHtcclxuICAgICAgICB2YXIgaW5keCA9IFJFU0VSVkVELmluZGV4T2YodSk7XHJcbiAgICAgICAgaWYoaW5keCAhPT0gLTEpXHJcbiAgICAgICAgICAgIFJFU0VSVkVEW2luZHhdID0gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvb3BzIHRocm91Z2ggZWFjaCBpdGVtIGluIG9iamVjdCBhbmQgY2FsbHMgZnVuY3Rpb24gd2l0aCBpdGVtIGFzIHBhcmFtXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgICovXHJcbiAgICB2YXIgZWFjaCA9IGZ1bmN0aW9uIChvYmosIGZuKSB7XHJcbiAgICAgICAgaWYoaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIHZhciBsID0gb2JqLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKylcclxuICAgICAgICAgICAgICAgIGZuLmNhbGwob2JqLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgeCBpbiBvYmopXHJcbiAgICAgICAgICAgICAgICBpZihvYmouaGFzT3duUHJvcGVydHkoeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChvYmosIHgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgbnVtYmVyIGlzIGFuIGV2ZW4gbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdmFyIGV2ZW4gPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bSAlIDIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhIGZyYWN0aW9uIGlzIGRpdmlzaWJsZSBieSAyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnVtXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdmFyIGV2ZW5GcmFjdGlvbiA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICByZXR1cm4gMSAvIChudW0gJSAxKSAlIDIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RyaXBzIGR1cGxpY2F0ZXMgb3V0IG9mIGFuIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICAgICAqL1xyXG4gICAgdmFyIGFycmF5VW5pcXVlID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIHZhciBsID0gYXJyLmxlbmd0aCwgYSA9IFtdO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBhcnJbaV07XHJcbiAgICAgICAgICAgIGlmKGEuaW5kZXhPZihpdGVtKSA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICBhLnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIHRoZSB2YXJpYWJsZXMgaW4gYW4gYXJyYXkgb2YgU3ltYm9sc1xyXG4gICAgICogQHBhcmFtIHtTeW1ib2xbXX0gYXJyIFxyXG4gICAgICovXHJcbiAgICB2YXIgYXJyYXlHZXRWYXJpYWJsZXMgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgdmFyIHZhcnMgPSB2YXJpYWJsZXMoYXJyWzBdLCBudWxsLCBudWxsLCB0cnVlKTtcclxuXHJcbiAgICAgICAgLy9nZXQgYWxsIHZhcmlhYmxlc1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDEsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKVxyXG4gICAgICAgICAgICB2YXJzID0gdmFycy5jb25jYXQodmFyaWFibGVzKGFycltpXSkpO1xyXG4gICAgICAgIC8vcmVtb3ZlIGR1cGxpY2F0ZXNcclxuICAgICAgICB2YXJzID0gYXJyYXlVbmlxdWUodmFycykuc29ydCgpO1xyXG5cclxuICAgICAgICAvL2RvbmVcclxuICAgICAgICByZXR1cm4gdmFycztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBhbiBhcnJheS4gUmV0dXJucyBhIG5ldyBhcnJheVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb25cclxuICAgICAqL1xyXG4gICAgdmFyIHJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbiAoYXJyLCBjb25kaXRpb24pIHtcclxuICAgICAgICB2YXIgY29uZGl0aW9uVHlwZSA9IHR5cGVvZiBjb25kaXRpb247XHJcblxyXG4gICAgICAgIGlmKGNvbmRpdGlvblR5cGUgIT09ICdmdW5jdGlvbicgfHwgY29uZGl0aW9uVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBiO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNlZW4gPSBbXTtcclxuXHJcbiAgICAgICAgd2hpbGUoYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyclswXTtcclxuICAgICAgICAgICAgLy9vbmx5IG9uZSBlbGVtZW50IGxlZnQgc28gd2UncmUgZG9uZVxyXG4gICAgICAgICAgICBpZihhcnIubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzZWVuLnB1c2goYSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IFtdO1xyXG4gICAgICAgICAgICBzZWVuLnB1c2goYSk7IC8vd2UgYWxyZWFkeSBzY2FubmVkIHRoZXNlXHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gYXJyW2ldO1xyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgbnVtYmVyIGlzIG91dHNpZGUgdGhlIHNwZWNpZmllZCB0b2xlcmFuY2VcclxuICAgICAgICAgICAgICAgIGlmKCFjb25kaXRpb24oYSwgYikpXHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5wdXNoKGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vc3RhcnQgb3ZlciB3aXRoIHRoZSByZW1haW5kZXJcclxuICAgICAgICAgICAgYXJyID0gdGVtcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzZWVuO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc2VydmVzIHRoZSBuYW1lcyBpbiBhbiBvYmplY3Qgc28gdGhleSBjYW5ub3QgYmUgdXNlZCBhcyBmdW5jdGlvbiBuYW1lc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAgICovXHJcbiAgICB2YXIgcmVzZXJ2ZU5hbWVzID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpZihSRVNFUlZFRC5pbmRleE9mKGl0ZW0pID09PSAtMSlcclxuICAgICAgICAgICAgICAgIFJFU0VSVkVELnB1c2goaXRlbSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIGFkZChvYmopO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlYWNoKG9iaiwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGFkZCh4KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGVpdGhlciBhbiBhcnJheSBvciBhbiBvYmplY3QuIElmIHRoZSBvYmplY3QgaXMgYW4gYXJyYXksIHRoZSBpbmRleCBtdXN0IGJlXHJcbiAgICAgKiBzcGVjaWZpZWQgYWZ0ZXIgdGhlIGFycmF5LiBJZiBpdCdzIGFuIG9iamVjdCB0aGVuIHRoZSBrZXkgbXVzdCBiZSBzcGVjaWZpZWRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gaW5kZXhPcktleVxyXG4gICAgICovXHJcbiAgICB2YXIgcmVtb3ZlID0gZnVuY3Rpb24gKG9iaiwgaW5kZXhPcktleSkge1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgaWYoaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG9iai5zcGxpY2UoaW5kZXhPcktleSwgMSlbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBvYmpbaW5kZXhPcktleV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbaW5kZXhPcktleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHRlbXBvcmFyeSBibG9jayBpbiB3aGljaCBvbmUgb2YgdGhlIGdsb2JhbCBzZXR0aW5ncyBpcyB0ZW1wb3JhcmlseSBtb2RpZmllZCB3aGlsZVxyXG4gICAgICogdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gRm9yIGluc3RhbmNlIGlmIHlvdSB3YW50IHRvIHBhcnNlIGRpcmVjdGx5IHRvIGEgbnVtYmVyIHJhdGhlciB0aGFuIGhhdmUgYSBzeW1ib2xpY1xyXG4gICAgICogYW5zd2VyIGZvciBhIHBlcmlvZCB5b3Ugd291bGQgc2V0IFBBUlNFMk5VTUJFUiB0byB0cnVlIGluIHRoZSBibG9jay5cclxuICAgICAqIEBleGFtcGxlIGJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbigpey8vc3ltYm9sIGJlaW5nIHBhcnNlZCB0byBudW1iZXJ9LCB0cnVlKTtcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5nIC0gVGhlIHNldHRpbmcgYmVpbmcgYWNjZXNzZWRcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0IC0gVGhlIHZhbHVlIG9mIHRoZSBzZXR0aW5nIGluIHRoZSBibG9ja1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIFRoZSBvYmogb2YgaW50ZXJlc3QuIFVzdWFsbHkgYSBTeW1ib2wgYnV0IGNvdWxkIGJlIGFueSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgdmFyIGJsb2NrID0gZnVuY3Rpb24gKHNldHRpbmcsIGYsIG9wdCwgb2JqKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRfc2V0dGluZyA9IFNldHRpbmdzW3NldHRpbmddO1xyXG4gICAgICAgIFNldHRpbmdzW3NldHRpbmddID0gb3B0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFvcHQ7XHJcbiAgICAgICAgdmFyIHJldHZhbCA9IGYuY2FsbChvYmopO1xyXG4gICAgICAgIFNldHRpbmdzW3NldHRpbmddID0gY3VycmVudF9zZXR0aW5nO1xyXG4gICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogcHJvdmlkZSBhIG1lY2hhbmlzbSBmb3IgYWNjZXNzaW5nIGZ1bmN0aW9ucyBkaXJlY3RseS4gTm90IHlldCBjb21wbGV0ZSEhIVxyXG4gICAgICogU29tZSBmdW5jdGlvbnMgd2lsbCByZXR1cm4gdW5kZWZpbmVkLiBUaGlzIGNhbiBtYXliZSBqdXN0IHJlbW92ZSB0aGVcclxuICAgICAqIGZ1bmN0aW9uIG9iamVjdCBhdCBzb21lIHBvaW50IHdoZW4gYWxsIGZ1bmN0aW9ucyBhcmUgZXZlbnR1YWxseVxyXG4gICAgICogaG91c2VkIGluIHRoZSBnbG9iYWwgZnVuY3Rpb24gb2JqZWN0LiBSZXR1cm5zIEFMTCBwYXJzZXIgYXZhaWxhYmxlXHJcbiAgICAgKiBmdW5jdGlvbnMuIFBhcnNlci5mdW5jdGlvbnMgbWF5IG5vdCBjb250YWluIGFsbCBmdW5jdGlvbnNcclxuICAgICAqL1xyXG4gICAgdmFyIGltcG9ydEZ1bmN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbyA9IHt9O1xyXG4gICAgICAgIGZvcih2YXIgeCBpbiBfLmZ1bmN0aW9ucylcclxuICAgICAgICAgICAgb1t4XSA9IF8uZnVuY3Rpb25zW3hdWzBdO1xyXG4gICAgICAgIHJldHVybiBvO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGZ1bmN0aW9uIGFyZ3VtZW50cyB0byBhbiBhcnJheS4gTm93IHVzZWQgYnkgZ2NkIGFuZCBsY20gaW4gQWxnZWJyYS5qcyA6KVxyXG4gICAgICogQHBhcmFtIHtBcnJheXxvYmplY3R9IG9ialxyXG4gICAgICovXHJcbiAgICB2YXIgYXJndW1lbnRzMkFycmF5ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKG9iaik7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY29lZmZpY2llbnRzIG9mIGEgc3ltYm9sIGdpdmVuIGEgdmFyaWFibGUuIEdpdmVuIGF4XjIrYl54K2MsIGl0IGRpdmlkZXNcclxuICAgICAqIGVhY2ggbnRoIHRlcm0gYnkgeF5uLlxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHdydFxyXG4gICAgICovXHJcbiAgICB2YXIgZ2V0Q29lZmZzID0gZnVuY3Rpb24gKHN5bWJvbCwgd3J0LCBpbmZvKSB7XHJcbiAgICAgICAgdmFyIGNvZWZmcyA9IFtdO1xyXG4gICAgICAgIC8vd2UgbG9vcCB0aHJvdWdoIHRoZSBzeW1ib2xzIGFuZCBzdGljayB0aGVtIGluIHRoZWlyIHJlc3BlY3RpdmVcclxuICAgICAgICAvL2NvbnRhaW5lcnMgZS5nLiB5KnheMiBnb2VzIHRvIGluZGV4IDJcclxuICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAodGVybSkge1xyXG4gICAgICAgICAgICBpZih0ZXJtLmNvbnRhaW5zKHdydCkpIHtcclxuICAgICAgICAgICAgICAgIC8vd2Ugd2FudCBvbmx5IHRoZSBjb2VmZmljaWVudCB3aGljaCBpbiB0aGlzIGNhc2Ugd2lsbCBiZSBldmVyeXRoaW5nIGJ1dCB0aGUgdmFyaWFibGVcclxuICAgICAgICAgICAgICAgIC8vZS5nLiBhKmIqeCAtPiBhKmIgaWYgdGhlIHZhcmlhYmxlIHRvIHNvbHZlIGZvciBpcyB4XHJcbiAgICAgICAgICAgICAgICB2YXIgY29lZmYgPSB0ZXJtLnN0cmlwVmFyKHdydCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBfLmRpdmlkZSh0ZXJtLmNsb25lKCksIGNvZWZmLmNsb25lKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0geC5wb3dlci50b0RlY2ltYWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvZWZmID0gdGVybTtcclxuICAgICAgICAgICAgICAgIHAgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlID0gY29lZmZzW3BdO1xyXG4gICAgICAgICAgICAvL2lmIGl0IGV4aXN0cyBqdXN0IGFkZCBpdCB0byBpdFxyXG4gICAgICAgICAgICBjb2VmZnNbcF0gPSBlID8gXy5hZGQoZSwgY29lZmYpIDogY29lZmY7XHJcblxyXG4gICAgICAgIH0sIHRydWUpO1xyXG5cclxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY29lZmZzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBpZighY29lZmZzW2ldKVxyXG4gICAgICAgICAgICAgICAgY29lZmZzW2ldID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAvL2ZpbGwgdGhlIGhvbGVzXHJcbiAgICAgICAgcmV0dXJuIGNvZWZmcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcyB0aGUgbmFtZSBzdGF0ZXMuIEl0IGZvcmNlcyBldmFsdWF0aW9uIG9mIHRoZSBleHByZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gb1xyXG4gICAgICovXHJcbiAgICB2YXIgZXZhbHVhdGUgPSBmdW5jdGlvbiAoc3ltYm9sLCBvKSB7XHJcbiAgICAgICAgcmV0dXJuIGJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKHN5bWJvbCwgbyk7XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYW4gYXJyYXkgdG8gYSB2ZWN0b3IuIENvbnNpZGVyIG1vdmluZyB0aGlzIHRvIFZlY3Rvci5mcm9tQXJyYXlcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nW118U3RyaW5nfFN5bWJvbHxOdW1iZXJ8TnVtYmVyW119IHhcclxuICAgICAqL1xyXG4gICAgdmFyIGNvbnZlcnRUb1ZlY3RvciA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYoaXNBcnJheSh4KSkge1xyXG4gICAgICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFZlY3RvcihbXSk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdmVjdG9yLmVsZW1lbnRzLnB1c2goY29udmVydFRvVmVjdG9yKHhbaV0pKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9FbnN1cmUgdGhhdCBhIG5lcmRhbWVyIHJlYWR5IG9iamVjdCBpcyByZXR1cm5lZFxyXG4gICAgICAgIGlmKCFpc1N5bWJvbCh4KSlcclxuICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoeCk7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHByaW1lIG51bWJlcnMgdXAgdG8gYSBzcGVjaWZpZWQgbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdXB0b1xyXG4gICAgICovXHJcbiAgICB2YXIgZ2VuZXJhdGVQcmltZXMgPSBmdW5jdGlvbiAodXB0bykge1xyXG4gICAgICAgIC8vZ2V0IHRoZSBsYXN0IHByaW1lIGluIHRoZSBhcnJheVxyXG4gICAgICAgIHZhciBsYXN0X3ByaW1lID0gUFJJTUVTW1BSSU1FUy5sZW5ndGggLSAxXSB8fCAyO1xyXG4gICAgICAgIC8vbm8gbmVlZCB0byBjaGVjayBpZiB3ZSd2ZSBhbHJlYWR5IGVuY291bnRlcmVkIHRoZSBudW1iZXIuIEp1c3QgY2hlY2sgdGhlIGNhY2hlLlxyXG4gICAgICAgIGZvcih2YXIgaSA9IGxhc3RfcHJpbWU7IGkgPCB1cHRvOyBpKyspIHtcclxuICAgICAgICAgICAgaWYoaXNQcmltZShpKSlcclxuICAgICAgICAgICAgICAgIFBSSU1FUy5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgYWxsIGFyZ3VtZW50cyBhcmUgbnVtYmVyc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcclxuICAgICAqL1xyXG4gICAgdmFyIGFsbE51bWJlcnMgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBpZihhcmdzW2ldLmdyb3VwICE9PSBOKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAgKiBDaGVja3MgaWYgYWxsIGFyZ3VtZW50cyBhcmVuJ3QganVzdCBhbGwgbnVtYmVyIGJ1dCBpZiB0aGV5XHJcbiAgICAgKiBhcmUgY29uc3RhbnRzIGFzIHdlbGwgZS5nLiBwaSwgZS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXHJcbiAgICAgKi9cclxuICAgIHZhciBhbGxDb25zdGFudHMgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmKGFyZ3NbaV0uaXNQaSgpIHx8IGFyZ3NbaV0uaXNFKCkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYoIWFyZ3NbaV0uaXNDb25zdGFudCh0cnVlKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBtdWx0aXBseSB0d28gZXhwcmVzc2lvbiBpbiBleHBhbmRlZCBmb3JtXHJcbiAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IGJcclxuICAgICAqL1xyXG4gICAgdmFyIG1peCA9IGZ1bmN0aW9uIChhLCBiLCBvcHQpIHtcclxuICAgICAgICAvLyBGbGlwIHRoZW0gaWYgYiBpcyBhIENQIG9yIFBMIGFuZCBhIGlzIG5vdFxyXG4gICAgICAgIGlmKGIuaXNDb21wb3NpdGUoKSAmJiAhYS5pc0NvbXBvc2l0ZSgpIHx8IGIuaXNMaW5lYXIoKSAmJiAhYS5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgIFthLCBiXSA9IFtiLCBhXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQSB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gaG9sZCB0aGUgZXhwYW5kZWQgdGVybXNcclxuICAgICAgICB2YXIgdCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgaWYoYS5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgIGEuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYiBpcyBub3QgYSBQTCBvciBhIENQIHRoZW4gc2ltcGx5IG11bHRpcGx5IGl0XHJcbiAgICAgICAgICAgICAgICBpZighYi5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm0gPSBfLm11bHRpcGx5KF8ucGFyc2UoeCksIF8ucGFyc2UoYikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBfLmFkZCh0LCBfLmV4cGFuZCh0ZXJtLCBvcHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBtdWx0aXBseSBvdXQgZWFjaCB0ZXJtLlxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihiLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiLmVhY2goZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm0gPSBfLm11bHRpcGx5KF8ucGFyc2UoeCksIF8ucGFyc2UoeSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kZWQgPSBfLmV4cGFuZChfLnBhcnNlKHRlcm0pLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5hZGQodCwgZXhwYW5kZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IF8uYWRkKHQsIF8ubXVsdGlwbHkoeCwgXy5wYXJzZShiKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEp1c3QgbXVsdGlwbHkgdGhlbSB0b2dldGhlclxyXG4gICAgICAgICAgICB0ID0gXy5tdWx0aXBseShhLCBiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBleHBhbmRlZCBmdW5jdGlvbiBpcyBub3cgdFxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbi8vRXhjZXB0aW9ucyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvL0lzIHRocm93biBmb3IgZGl2aXNpb24gYnkgemVyb1xyXG4gICAgdmFyIERpdmlzaW9uQnlaZXJvID0gY3VzdG9tRXJyb3IoJ0RpdmlzaW9uQnlaZXJvJyk7XHJcbiAgICAvLyBJcyB0aHJvdyBpZiBhbiBlcnJvciBvY2N1cmVkIGR1cmluZyBwYXJzaW5nXHJcbiAgICB2YXIgUGFyc2VFcnJvciA9IGN1c3RvbUVycm9yKCdQYXJzZUVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvd24gaWYgdGhlIGV4cHJlc3Npb24gcmVzdWx0cyBpbiB1bmRlZmluZWRcclxuICAgIHZhciBVbmRlZmluZWRFcnJvciA9IGN1c3RvbUVycm9yKCdVbmRlZmluZWRFcnJvcicpO1xyXG4gICAgLy8gSXMgdGhyb3cgaW5wdXQgaXMgb3V0IG9mIHRoZSBmdW5jdGlvbiBkb21haW5cclxuICAgIHZhciBPdXRPZkZ1bmN0aW9uRG9tYWluRXJyb3IgPSBjdXN0b21FcnJvcignT3V0T2ZGdW5jdGlvbkRvbWFpbkVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvdyBpZiBhIGZ1bmN0aW9uIGV4Y2VlZHMgeCBhbW91bnQgb2YgaXRlcmF0aW9uc1xyXG4gICAgdmFyIE1heGltdW1JdGVyYXRpb25zUmVhY2hlZCA9IGN1c3RvbUVycm9yKCdNYXhpbXVtSXRlcmF0aW9uc1JlYWNoZWQnKTtcclxuICAgIC8vIElzIHRocm93biBpZiB0aGUgcGFyc2VyIHJlY2VpdmVzIGFuIGluY29ycmVjdCB0eXBlXHJcbiAgICB2YXIgTmVyZGFtZXJUeXBlRXJyb3IgPSBjdXN0b21FcnJvcignTmVyZGFtZXJUeXBlRXJyb3InKTtcclxuICAgIC8vIElzIHRocm93biBpZiBicmFja2V0IHBhcml0eSBpcyBub3QgY29ycmVjdFxyXG4gICAgdmFyIFBhcml0eUVycm9yID0gY3VzdG9tRXJyb3IoJ1Bhcml0eUVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvd24gaWYgYW4gdW5leHBlY3RkIG9yIGluY29ycmVjdCBvcGVyYXRvciBpcyBlbmNvdW50ZXJlZFxyXG4gICAgdmFyIE9wZXJhdG9yRXJyb3IgPSBjdXN0b21FcnJvcignT3BlcmF0b3JFcnJvcicpO1xyXG4gICAgLy8gSXMgdGhyb3duIGlmIGFuIGluZGV4IGlzIG91dCBvZiByYW5nZS5cclxuICAgIHZhciBPdXRPZlJhbmdlRXJyb3IgPSBjdXN0b21FcnJvcignT3V0T2ZSYW5nZUVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvd24gaWYgZGltZW5zaW9ucyBhcmUgaW5jb3JyZWN0LiBNb3N0bHkgZm9yIG1hdHJpY2VzXHJcbiAgICB2YXIgRGltZW5zaW9uRXJyb3IgPSBjdXN0b21FcnJvcignRGltZW5zaW9uRXJyb3InKTtcclxuICAgIC8vIElzIHRocm93biBpZiB2YXJpYWJsZSBuYW1lIHZpb2xhdGVzIG5hbWluZyBydWxlXHJcbiAgICB2YXIgSW52YWxpZFZhcmlhYmxlTmFtZUVycm9yID0gY3VzdG9tRXJyb3IoJ0ludmFsaWRWYXJpYWJsZU5hbWVFcnJvcicpO1xyXG4gICAgLy8gSXMgdGhyb3duIGlmIHRoZSBsaW1pdHMgb2YgdGhlIGxpYnJhcnkgYXJlIGV4Y2VlZGVkIGZvciBhIGZ1bmN0aW9uXHJcbiAgICAvLyBUaGlzIGNhbiBiZSB0aGF0IHRoZSBmdW5jdGlvbiBiZWNvbWUgdW5zdGFibGUgcGFzc2VkIGEgdmFsdWVcclxuICAgIHZhciBWYWx1ZUxpbWl0RXhjZWVkZWRFcnJvciA9IGN1c3RvbUVycm9yKCdWYWx1ZUxpbWl0RXhjZWVkZWRFcnJvcicpO1xyXG4gICAgLy8gSXMgdGhyb3cgaWYgdGhlIHZhbHVlIGlzIGFuIGluY29ycmVjdCBMSCBvciBSSCB2YWx1ZVxyXG4gICAgdmFyIE5lcmRhbWVyVmFsdWVFcnJvciA9IGN1c3RvbUVycm9yKCdOZXJkYW1lclZhbHVlRXJyb3InKTtcclxuICAgIC8vIElzIHRocm93biBpZiB0aGUgdmFsdWUgaXMgYW4gaW5jb3JyZWN0IExIIG9yIFJIIHZhbHVlXHJcbiAgICB2YXIgU29sdmVFcnJvciA9IGN1c3RvbUVycm9yKCdTb2x2ZUVycm9yJyk7XHJcbiAgICAvLyBJcyB0aHJvd24gZm9yIGFuIGluZmluaXRlIGxvb3BcclxuICAgIHZhciBJbmZpbml0ZUxvb3BFcnJvciA9IGN1c3RvbUVycm9yKCdJbmZpbml0ZUxvb3BFcnJvcicpO1xyXG4gICAgLy8gSXMgdGhyb3duIGlmIGFuIG9wZXJhdG9yIGlzIGZvdW5kIHdoZW4gdGhlcmUgc2hvdWxkbid0IGJlIG9uZVxyXG4gICAgdmFyIFVuZXhwZWN0ZWRUb2tlbkVycm9yID0gY3VzdG9tRXJyb3IoJ1VuZXhwZWN0ZWRUb2tlbkVycm9yJyk7XHJcblxyXG4gICAgdmFyIGV4Y2VwdGlvbnMgPSB7XHJcbiAgICAgICAgRGl2aXNpb25CeVplcm86IERpdmlzaW9uQnlaZXJvLFxyXG4gICAgICAgIFBhcnNlRXJyb3I6IFBhcnNlRXJyb3IsXHJcbiAgICAgICAgT3V0T2ZGdW5jdGlvbkRvbWFpbkVycm9yOiBPdXRPZkZ1bmN0aW9uRG9tYWluRXJyb3IsXHJcbiAgICAgICAgVW5kZWZpbmVkRXJyb3I6IFVuZGVmaW5lZEVycm9yLFxyXG4gICAgICAgIE1heGltdW1JdGVyYXRpb25zUmVhY2hlZDogTWF4aW11bUl0ZXJhdGlvbnNSZWFjaGVkLFxyXG4gICAgICAgIE5lcmRhbWVyVHlwZUVycm9yOiBOZXJkYW1lclR5cGVFcnJvcixcclxuICAgICAgICBQYXJpdHlFcnJvcjogUGFyaXR5RXJyb3IsXHJcbiAgICAgICAgT3BlcmF0b3JFcnJvcjogT3BlcmF0b3JFcnJvcixcclxuICAgICAgICBPdXRPZlJhbmdlRXJyb3I6IE91dE9mUmFuZ2VFcnJvcixcclxuICAgICAgICBEaW1lbnNpb25FcnJvcjogRGltZW5zaW9uRXJyb3IsXHJcbiAgICAgICAgSW52YWxpZFZhcmlhYmxlTmFtZUVycm9yOiBJbnZhbGlkVmFyaWFibGVOYW1lRXJyb3IsXHJcbiAgICAgICAgVmFsdWVMaW1pdEV4Y2VlZGVkRXJyb3I6IFZhbHVlTGltaXRFeGNlZWRlZEVycm9yLFxyXG4gICAgICAgIE5lcmRhbWVyVmFsdWVFcnJvcjogTmVyZGFtZXJWYWx1ZUVycm9yLFxyXG4gICAgICAgIFNvbHZlRXJyb3I6IFNvbHZlRXJyb3IsXHJcbiAgICAgICAgSW5maW5pdGVMb29wRXJyb3I6IEluZmluaXRlTG9vcEVycm9yLFxyXG4gICAgICAgIFVuZXhwZWN0ZWRUb2tlbkVycm9yOiBVbmV4cGVjdGVkVG9rZW5FcnJvclxyXG4gICAgfTtcclxuLy9NYXRoMiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vVGhpcyBvYmplY3QgaG9sZHMgYWRkaXRpb25hbCBmdW5jdGlvbnMgZm9yIG5lcmRhbWVyLiBUaGluayBvZiBpdCBhcyBhbiBleHRlbnNpb24gb2YgdGhlIE1hdGggb2JqZWN0LlxyXG4gICAgLy9JIHJlYWxseSBkb24ndCBsaWtlIHRvdWNoaW5nIG9iamVjdHMgd2hpY2ggYXJlbid0IG1pbmUgaGVuY2UgdGhlIHJlYXNvbiBmb3IgTWF0aDIuIFRoZSBuYW1lcyBvZiB0aGVcclxuICAgIC8vZnVuY3Rpb25zIHdpdGhpbiBhcmUgcHJldHR5IHNlbGYtZXhwbGFuYXRvcnkuXHJcbiAgICAvL05PVEU6IERPIE5PVCBVU0UgSU5MSU5FIENPTU1FTlRTIFdJVEggVEhFIE1BVEgyIE9CSkVDVCEgVEhJUyBCUkVBSyBEVVJJTkcgQ09NUElMQVRJT04gT0YgQlVJTERGVU5DVElPTi5cclxuICAgIHZhciBNYXRoMiA9IHtcclxuICAgICAgICBjc2M6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIC8gTWF0aC5zaW4oeCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZWM6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIC8gTWF0aC5jb3MoeCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb3Q6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxIC8gTWF0aC50YW4oeCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY3NjOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hc2luKDEgLyB4KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzZWM6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3MoMSAvIHgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWNvdDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChNYXRoLlBJIC8gMikgLSBNYXRoLmF0YW4oeCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qaWdnenNvbi9kZjBlOWFlOGIzYjA2ZmYzZDhkYzJhYTA2Mjg1M2JkOFxyXG4gICAgICAgIGVyZjogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSAxIC8gKDEgKyAwLjUgKiBNYXRoLmFicyh4KSk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAxIC0gdCAqIE1hdGguZXhwKC14ICogeCAtIDEuMjY1NTEyMjMgK1xyXG4gICAgICAgICAgICAgICAgICAgIHQgKiAoMS4wMDAwMjM2OCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICogKDAuMzc0MDkxOTYgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICogKDAuMDk2Nzg0MTggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKiAoLTAuMTg2Mjg4MDYgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAqICgwLjI3ODg2ODA3ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAqICgtMS4xMzUyMDM5OCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCAqICgxLjQ4ODUxNTg3ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgKiAoLTAuODIyMTUyMjMgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ICogKDAuMTcwODcyNzcpKSkpKSkpKSlcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICByZXR1cm4geCA+PSAwID8gcmVzdWx0IDogLXJlc3VsdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpZmY6IGZ1bmN0aW9uIChmKSB7XHJcbiAgICAgICAgICAgIHZhciBoID0gMC4wMDE7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGVyaXZhdGl2ZSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGYoeCArIGgpIC0gZih4IC0gaCkpIC8gKDIgKiBoKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXJpdmF0aXZlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbWVkaWFuOiBmdW5jdGlvbiAoLi4udmFsdWVzKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdmFyIGhhbGYgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHZhbHVlcy5sZW5ndGggJSAyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1toYWxmXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWVzW2hhbGYgLSAxXSArIHZhbHVlc1toYWxmXSkgLyAyLjA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldmVyc2VzIGNvbnRpbnVlZCBmcmFjdGlvbiBjYWxjdWxhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqfSBjb250ZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnJvbUNvbnRpbnVlZDogZnVuY3Rpb24gKGNvbnRkKSB7XHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBjb250ZC5mcmFjdGlvbnMuc2xpY2UoKTtcclxuICAgICAgICAgICAgdmFyIGUgPSAxIC8gYXJyLnBvcCgpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZSA9IDEgLyAoYXJyLnBvcCgpICsgZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRkLnNpZ24gKiAoY29udGQud2hvbGUgKyBlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyBjb250aW51ZWQgZnJhY3Rpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgbnVtYmVyIG9mIHBsYWNlc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29udGludWVkRnJhY3Rpb246IGZ1bmN0aW9uIChuLCB4KSB7XHJcbiAgICAgICAgICAgIHggPSB4IHx8IDIwO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbihuKTsgLypzdG9yZSB0aGUgc2lnbiovXHJcbiAgICAgICAgICAgIHZhciBhYnNuID0gTWF0aC5hYnMobik7IC8qZ2V0IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgbnVtYmVyKi9cclxuICAgICAgICAgICAgdmFyIHdob2xlID0gTWF0aC5mbG9vcihhYnNuKTsgLypnZXQgdGhlIHdob2xlKi9cclxuICAgICAgICAgICAgdmFyIG5pID0gYWJzbiAtIHdob2xlOyAvKnN1YnRyYWN0IHRoZSB3aG9sZSovXHJcbiAgICAgICAgICAgIHZhciBjID0gMDsgLyp0aGUgY291bnRlciB0byBrZWVwIHRyYWNrIG9mIGl0ZXJhdGlvbnMqL1xyXG4gICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgZXBzaWxvbiA9IDFlLTE0O1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gMWU3O1xyXG4gICAgICAgICAgICB2YXIgZSwgdztcclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9IHtcclxuICAgICAgICAgICAgICAgIHdob2xlOiB3aG9sZSxcclxuICAgICAgICAgICAgICAgIHNpZ246IHNpZ24sXHJcbiAgICAgICAgICAgICAgICBmcmFjdGlvbnM6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qc3RhcnQgY2FsY3VsYXRpbmcqL1xyXG4gICAgICAgICAgICB3aGlsZSghZG9uZSAmJiBuaSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLyppbnZlcnQgYW5kIGdldCB0aGUgd2hvbGUqL1xyXG4gICAgICAgICAgICAgICAgZSA9IDEgLyBuaTtcclxuICAgICAgICAgICAgICAgIHcgPSBNYXRoLmZsb29yKGUpO1xyXG4gICAgICAgICAgICAgICAgaWYodyA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qdGhpcyBzaWduYWxzIHRoYXQgd2UgbWF5IGhhdmUgYWxyZWFkeSBnb25lIHRvbyBmYXIqL1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gTWF0aDIuZnJvbUNvbnRpbnVlZChyZXR2YWwpIC0gbjtcclxuICAgICAgICAgICAgICAgICAgICBpZihkIDw9IE51bWJlci5FUFNJTE9OKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qYWRkIHRvIHJlc3VsdCovXHJcbiAgICAgICAgICAgICAgICByZXR2YWwuZnJhY3Rpb25zLnB1c2godyk7XHJcbiAgICAgICAgICAgICAgICAvKm1vdmUgdGhlIG5pIHRvIHRoZSBkZWNpbWFsKi9cclxuICAgICAgICAgICAgICAgIG5pID0gZSAtIHc7XHJcbiAgICAgICAgICAgICAgICAvKm5pIHNob3VsZCBhbHdheXMgYmUgYSBkZWNpbWFsLiBJZiB3ZSBoYXZlIGEgd2hvbGUgbnVtYmVyIHRoZW4gd2UncmUgaW4gdGhlIHJvdW5kaW5nIGVycm9ycyovXHJcbiAgICAgICAgICAgICAgICBpZihuaSA8PSBlcHNpbG9uIHx8IGMgPj0geCAtIDEpXHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLypjbGVhbnVwIDEvKG4rMS8xKSA9IDEvKG4rMSkgc28ganVzdCBtb3ZlIHRoZSBsYXN0IGRpZ2l0IG9uZSBvdmVyIGlmIGl0J3Mgb25lKi9cclxuICAgICAgICAgICAgdmFyIGlkeCA9IHJldHZhbC5mcmFjdGlvbnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgaWYocmV0dmFsLmZyYWN0aW9uc1tpZHhdID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwuZnJhY3Rpb25zLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgLyppbmNyZWFzZSB0aGUgbGFzdCBvbmUgYnkgb25lKi9cclxuICAgICAgICAgICAgICAgIHJldHZhbC5mcmFjdGlvbnNbLS1pZHhdKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJpZ3BvdzogZnVuY3Rpb24gKG4sIHApIHtcclxuICAgICAgICAgICAgaWYoIShuIGluc3RhbmNlb2YgRnJhYykpXHJcbiAgICAgICAgICAgICAgICBuID0gRnJhYy5jcmVhdGUobik7XHJcbiAgICAgICAgICAgIGlmKCEocCBpbnN0YW5jZW9mIEZyYWMpKVxyXG4gICAgICAgICAgICAgICAgcCA9IEZyYWMuY3JlYXRlKHApO1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IEZyYWMoMCk7XHJcbiAgICAgICAgICAgIGlmKHAuaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbC5udW0gPSBuLm51bS5wb3cocC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbC5kZW4gPSBuLmRlbi5wb3cocC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBudW0gPSBGcmFjLmNyZWF0ZShNYXRoLnBvdyhuLm51bSwgcC5udW0pKTtcclxuICAgICAgICAgICAgICAgIHZhciBkZW4gPSBGcmFjLmNyZWF0ZShNYXRoLnBvdyhuLmRlbiwgcC5udW0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR2YWwubnVtID0gTWF0aDIubnRocm9vdChudW0sIHAuZGVuLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsLmRlbiA9IE1hdGgyLm50aHJvb3QoZGVuLCBwLmRlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTQ1NDE4My9ob3ctdG8tbWFrZS1hLWZ1bmN0aW9uLXRoYXQtY29tcHV0ZXMtdGhlLWZhY3RvcmlhbC1mb3ItbnVtYmVycy13aXRoLWRlY2ltYWxzXHJcbiAgICAgICAgZ2FtbWE6IGZ1bmN0aW9uICh6KSB7XHJcbiAgICAgICAgICAgIHZhciBnID0gNztcclxuICAgICAgICAgICAgdmFyIEMgPSBbXHJcbiAgICAgICAgICAgICAgICAwLjk5OTk5OTk5OTk5OTgwOTkzLFxyXG4gICAgICAgICAgICAgICAgNjc2LjUyMDM2ODEyMTg4NTEsXHJcbiAgICAgICAgICAgICAgICAtMTI1OS4xMzkyMTY3MjI0MDI4LFxyXG4gICAgICAgICAgICAgICAgNzcxLjMyMzQyODc3NzY1MzEzLFxyXG4gICAgICAgICAgICAgICAgLTE3Ni42MTUwMjkxNjIxNDA1OSxcclxuICAgICAgICAgICAgICAgIDEyLjUwNzM0MzI3ODY4NjkwNSxcclxuICAgICAgICAgICAgICAgIC0wLjEzODU3MTA5NTI2NTcyMDEyLFxyXG4gICAgICAgICAgICAgICAgOS45ODQzNjk1NzgwMTk1NzE2ZS02LFxyXG4gICAgICAgICAgICAgICAgMS41MDU2MzI3MzUxNDkzMTE2ZS03XVxyXG4gICAgICAgICAgICAgICAgICAgIDtcclxuXHJcbiAgICAgICAgICAgIGlmKHogPCAwLjUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5QSSAvIChNYXRoLnNpbihNYXRoLlBJICogeikgKiBNYXRoMi5nYW1tYSgxIC0geikpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHogLT0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IENbMF07XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgZyArIDI7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB4ICs9IENbaV0gLyAoeiArIGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0ID0geiArIGcgKyAwLjU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKSAqIE1hdGgucG93KHQsICh6ICsgMC41KSkgKiBNYXRoLmV4cCgtdCkgKiB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2ZhY3RvcmlhbFxyXG4gICAgICAgIGJpZ2ZhY3RvcmlhbDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9IG5ldyBiaWdJbnQoMSk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDI7IGkgPD0geDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gcmV0dmFsLnRpbWVzKGkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZyYWMocmV0dmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9nYXJpdGhtI0NhbGN1bGF0aW9uXHJcbiAgICAgICAgYmlnTG9nOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgQ0FDSEUgPSBbXCItMjUzNjMxOTU0MzMzMTE4NzE4NzYyNjI5NDA5MTA5MjYyMjc5OTI2Mjg4OTA4Nzc1OTE4NzEyNDY2NjAxMTk2MDMyLzM5OTcwMDkzNTc2MDUzNjI1OTYzOTU3NDc4MTM5MDQ5ODI0MDMwOTA2MzUyOTIyMjYyNjQyOTY4MDYwNzA2Mzc1XCIsIFwiMFwiLCBcIjI0NTUzMDkwMTQ1ODY5NjA3MTcyNDEyOTE4NDgzMTI0MTg0ODY0Mjg5MTcwODE0MTIyNTc5OTIzNDA0Njk0OTg2NDY5NjUzMjYxNjA4NTI4NjgxNTg5OTQ5NjI5NzUwNjc3NDA3MzU2NDYzNjAxOTk4NTM0OTQ1MDU3NTExNjY0OTUxNzk5Njc4MzM2LzM1NDIyNjIxMzkxOTQ1NzU3NDMxNjc2MTc4NDM1NjMwMjI5MjgzMjU1MjUwNzc5MjE2NDIxMDU0MTg4MjI4NjU5MDYxOTU0MzE3NTAxNjk5NzA3MjM2ODY0MTg5MzgzNTkxNDc4MDI0MjQ1NDk1MTEwNTYxMTI0NTk3MTI0OTk1OTg2OTc4MzAyMzc1XCIsIFwiMzY5MDE3MzM1MzQwOTE3MTQwNzA2MDQ0MjQwMDkwMjQzMzY4NzI4NjE2Mjc5MjM5MjI3OTQzODcxMDQ4NzU5MTQwMjc0ODYyMTMxNjk5NTUwMDQzMTUwNzEzMDU5ODg5MTk2MjIzOTE3NTI3MTcyNTQ3LzMzNTg5NDA1MzkzMjYxMjcyODk2OTk3NTMzODU0OTk5Mzc2NDU1NDQ4MTE3MzY2MTIxODU4NTg3NjQ3NTgzNzQwOTkyMjUzNzYyMjM4NTIzMjc3NjY1Nzc5MTYwNDM0NTEyNTIyNzAwNTQ3Njg2NDAwMFwiLCBcIjI0NjA2ODUzMDI1NjI2NzM3OTAzMTIxMzAzOTMwMTAwNDYyMjQ1NTA2MzIyNjA3OTg1Nzc5NjAzMjIwODIwMzIzMjExMzk1NjA3OTMxNjk5MTI2MzkwOTE4NDc3NTAxMzI1ODA1NTEzODQ5NjExOTMwMDA4NDI3MjY4MTc2NjAyNDYwNDYyOTg4OTcyOTU3NTkzNDU4NzI2NzM0ODk3MTI5OTU0NzI4MTAyMTQ0LzE3NzUwMDkyNDE1OTc3NjM5Nzg3MTM5NTYxMzMwMzI2MTcwOTM2MzIxNDUyMTM3NjM1MzIyMzEzMTIyOTM4MjA3NjExNzg3NDQ0MzExNzM1MjUxMzg5MDY2MTA2OTM3Nzk2MDg1NjY5NDYwMTUxOTYzMjg1MDg2NTQyNzQ1ODU5NDYxOTQzMzY5NjA2MDE4NDUwMjEzMDE0MTQ4MTc1NzE2NDAwMTQ2NDg0Mzc1XCIsIFwiMzk5MDczNTY4NzgxOTc2ODA2NzE1NzU5NDA5MDUyMjg2NjQxNzM4OTI2NjM2MzI4OTgzOTI5NDM5NDUwODI0NTU1NjEzNzA0Njc2NjM3MTkxNTY0Njk5MTY0MzAzMDEyMjQ3Mzg2MDk1OTQyMTQ0ODI1NjAzNTIyNDAxNzQwNjgwODA4NDY2ODU4MDQ0LzI0Nzk1ODM0OTc0MzYyMDMwMjAyMTczMzI0OTA0OTQxMTYwNDk4Mjc4Njc1NTQ1NDUxNDk0NzM3OTMxNzYwMDYxMzQzMzY4MDIyMjUxMTg5Nzk1MDY1ODA0OTMyNTY4NTE0MDM0NjE2OTcxODQ2NTc3MzkyNzg3MjE3OTg3NDk3MTkwODg0ODExNjYyNVwiLCBcIjE0NjgxMDI5ODk0OTU4NDY5NDQwODQ3NDExNDY5NDcyOTUzNzgwNDE4MDg3MDEyNTY5MDkwMTYyMjQzMDk4NjYxNDMyOTQ1NTY1NTE0MDc0NzA4NjEzNTQzMTE1OTMzNTEyNzY2MTI0NjM4NTg4MTY3OTY3MTQ1Njk0OTkwMjEzNzU4OTk3OTM4NDkxMzY4NTUwODU4NDkxMzM3MDIwMjkzMzc5MTA1MDI0NDgxODkwNTUzNTcxODI1OTU0MjQ5NTkzNjAvODE5MzYzODc5MzA5Mjg2MzAzNDk3MjE3NTI3Mzc1NDYzMTIwNDA0NzM5MDk4MjYwMjAwMjc5NTIwNzg4OTUwNzc3NDU4OTAwNDM4MzA3MzU2NzM4MDgyOTMwNTg2MDMyNDYyNjAxMjE1ODAyNjM2MzIwOTkzNjQ4MDA3OTA3NzI0ODk5NjExMjk2NjkzOTk3MjE2OTM4OTg5ODU0ODYxMDQzMjk4NDk0OTkwMjE0ODI1MTYzNTIzMzg3NjAwOTgyNzc3XCIsIFwiNTg5NjcwNDg1NTI3NDY2MTc2NzgyNDU3NDA5MzYwNTM0NDg3MTcyMjc5MDI3ODM1NDQzMTQyMjcyOTY0MDk1MDgyMTIzOTAzMDc4NTY0Mjk0MzAzMzE1Mzc5MzI0NTkwNjg2MzIwMzgyMjM2OTI3NjI3MTA1MDE2NDYzNDIwNjk2NTA1NjIzMzA5NzQ3OTExNzk4MDc4MjY0MTgzOTY2OS8zMDMwMzA2ODUwNTY5MzA5MzQ0MDEzNzI2NzQ1MTAwMDcwNjAxMjc3OTgyMTMyNTQzOTA1NTM3MzY2NTYyNjM4NTUzMTk4MTY3MDA3MTU5MDY3NTQ0Nzg5NTkyMDg5OTYwOTExMDY1MTgxNjA2MjgzNDc4ODQzMzU5ODU2MTIzOTkyNzA3NTk4Njg1MDU4Mjk3MDY3MTc5MzQzODcyMDAwXCIsIFwiNzY2MzE3NzI5NDM1MzQ5ODU3MTM4NzM0MjcyNjI4MzAzMTQ2MTc5MTI1NTY5Mjg0NzY1NzMzNTg1NDgyNTY4NzIxNDE1MTY5ODk1MzgzNzQ3NjE5MDk2MTE4Nzk5MjIzNDk0Nzk0MjAwMTQ3NzE0OTkwMTgxNTU0NDcxOTgxMTIxNTU1MTU0NTM2NzExMjg4MTQ0ODgxMzk2MzM4MTA0OTMyNjQzNTIyOTQ1NjAwNDM5MTIwNjYyNTMwMjYwNTkxNDA2NTMwMjczMjY1NjY4MDEzOTg3ODQvMzY4NTIwOTI5MzMzODg5ODg2NDkzOTYwNDI4ODMyMTg1MDk2MDc1MDMyMDQyMTExNDg0OTM1NDU4OTI4NDk1OTU0OTg4MjI4MTc2MjM4NDI1NzkwMjY5NDI2MjEwOTg4NTE2MzE4NDI3NTQzOTUyMzE1NjE2Nzk2NzE0MDAxOTcwNTYzNzczODAwNjMyMzM3NDAyMDIzNzA2ODYxNDQ2NzM1ODU5NTU1ODE0MDMwNDY4ODYwODM5NDg0NTAxMzYyNDcxMzQzMDgzODE5NDAxNjU4MDQ4NzVcIiwgXCIzMTU5MDc2MDgzODE2Mzk5NTA5NzU0OTQ4NjEwOTI5NDY3Mjc4MjU3NDczODg4MjgyOTQ3MzExMjgwNjUzNTc0NjM0ODAyNTgwOTEyMjgwOTQwNjg2OTU0NzYzMzEzODgyODIzMzI3MDc3MTcxNjI0MDE1NzM3NzE5NjE3MzczOTMyMzE4MTUxNTk0MzI1ODM0NTI0MDAwMjc1ODQ3NDc1ODY2Mjk5Mzg3OTEzMDQ4LzE0Mzc3NTc0ODU2OTQxODg4MjI3NTgzMDQ0Njc3NTY0MTk4NDU4NDIwMzc2MjMxNDg0NjExMDczNjI5NTc5OTQ4MTY1NTQ3ODI5ODkyNTA1NTUzNjI1MTQzNTQ2NjE5NjE0ODI5MzkyMjYyNzIzMDkwMjYwOTIwMDk5NjI0MTQ2MTY0MTc0MTI5MzgwODc0OTQ0NjcyNTQxNDYwMDIyMzMwMjg0MTE4NjUyMzQzNzVcIiwgXCIyMjI2NjA2NzI1OTkwNzM2NDk4NDUzMTYxMTYwMTg3MDI5MTM2ODI3MjY3NDU3MzY1MzQwMzk2NTYzMDYyODk5NjY4NzM3MDk5NDEzOTg4NDgzMzg5Nzc3MzQ2ODE0OTE0OTY2NDgyOTkyMjMwMjQ4NDc4MjQyMzUxNDE2NzQwNTM5NzY2NTA5ODM4ODQwMDQ1MDE0OTA3ODk4MjQ2MjMxODc4MTc1MDY2MTAwNTgzMzAzNzIzNTE4MzM5NDIyMTQ5NjE4NjUzOTc3OTcxMjQyODI2NTgzNzkyNjQxNzU4MTk1Mi85NjcwMDMwMTQ0NjY0NDI4NTY1MTI4OTYyMzA5NjU3MTAwMTM4MDk2MDQ3MDI4Nzk0Njg5MjQ5MzIwODU5Mjc2MTk3MzQwMzk4OTIwNzI1NTY5NDI4NTMyMjkzMzczNjc2NDE1MzU5OTY1NzczNDYwMzY0NDk0OTk4MzM0MjU5ODkzMDc5MDAzMTI1MzczODcyMTA4NzcwNTM0Nzg4MjgzODQyOTA3MzE4MDcxMTcwMjg1MDM4Nzc3MDkxNTg4MjkyNTM5MTAyMjY5NjE3Mzc2MTgwMzkwOTgyOTE1NTY3Mzc1XCIsIFwiMTQ2MDQ2NTQ1NjQ5ODkyMzk5NTg1NjkzMzE0NDMzODUzNjk1MjI4NTA5NzUxODUzNTg2NDcxMzI3NzAwMjI3MTY0MzMyODAwNzIyNzEwMDc3NjcxMTEwMzY4Nzc4MDMzMjg3Njg5MTAyNzQ0MDA1MTU1OTAxNTE5MzQ2NzY4MTkyNjIwODUyMTE4MjgwMjg2Mzg0MTczMjk1NTgyMjkxMjM5ODk1NTYzNzYxMDg0NTQ0OTc4MTMwNTUvNjA5MDYxNDAxOTE2MjUxNjY5MzAxMzk3MzQwOTY1MDYxMzIwODIyNzg4OTA3ODg3ODc4MTAzOTEwNTA0NzAxNTc1MjQ5MzUxOTE0OTMxNDIyNzcyMTk4NDQzNjk3MzM3NDAzMjI3OTQyMTM0NDgxODMyOTI4NTIwNzEyNDI4MDI5NzYxMTI1Mzg2MTE3MzgzNTIzODM3OTgzMTAwNDAxMDc0ODM3OTg3NDM5MzI5MjIzMTY3MTgwOFwiLCBcIjE5MDEyNDE4ODU0MDc2OTYwMzEyMTcyOTI4Nzc4NjI5MjUyMjA5MTc2NjAwNDcxMjcyNjEwMjY4Mjc4NjkwMjcxNTk5OTMyMzk1Njc5MzM1MzQwNTI2NjMzMzU0OTgyODE0MzkyMzk3NTMwMTg1MDcxODIwMTYxNTM2NTc0MDk3Nzc3NDk3OTIyMjg1MzgzODAzNzk3MDM0MTEyOTg0MTE2MjM0NjkyOTI4OTE0NzY5Njk4OTQwODQ4Mzg4NzYwMDE1NDU4MTgxNDE1NDM4OTAyNzMyNTY5ODU3Njg2OTA4NDc1ODc3MTEyNzA5MzA2ODgvNzY1MTE2MDE5Nzc4ODM4ODM5ODEyNjU1NDAyMTAzNTEyNjg1Njk1NzY5MTYxMjEyMzYwNTUzMDk5NzMyNjg5Nzk1NTc4OTA0NzYyMDkxMjE2OTk4NzkwNTg5OTI2MDU3ODE5ODM4NTM3ODA1ODU2NTc5MTA5OTEwMTk4NTUzMzMwMDc1OTI0ODU3NDE5Mzk1MTYwNzU1NjQyMzcxNTUwMTEzMzQ3NDY1MzAwMjA4NDIyMTI2OTQ1MjY1ODg3MDY1NDM0MTE2NzgxNjc4NzAyNzQxNjU3Mjc1MTgxNjk0ODUxNjcwMzI1NDY5NDM0NjI1XCIsIFwiMTM5NDU5ODA2Nzg2NjA0NzUxNzkzNzM3OTI2MTQ2ODQwNjIzNjA3MDEwMjA4MjE2Mjg5NTQzMDM2MDI2MjA2MjA4OTYyMDU5NTkzOTAwNzQ1ODg2MjAyMjE0Nzg4NzQ3NDUzMjc5MTc5MjgzMzQ0MzUwNDc4NzM0Mjc1OTczODc4OTMyNTM4NDMwMTk0MzYzMzU1Nzk1ODIzNTgxMzE1MzI5MzExMjIwNzAxNjQwMjM1NjUzMjg4OTc1NTY5ODEyMTYxNDM2LzU0MzcxMzY4NTM0NDEyNTE3MDUzMDU2MTAxMzUzNjE4Njk0NzE4MjE1NzExNzY3MjY2Mzc2NTczMTM4NzcyOTY4MjU3MzAzNTc4NDY3OTI2NDUwMjEyMjkzMjMzMzMyNDAxMDY3NjczMjcwODUzOTUzMzk5MjY5ODUyMzc2NTkyODU1OTkyNzI0OTM0OTQxMTczMzQ2MjYwMTI5MjU3NzU0NDE2NDEyNDc2MjAyNTI2OTc4NDQzNjgxNTg0NjMzMTE2Mzc1XCIsIFwiMTA0NTY2OTA5MTEyNDQ5MzA3MDcwOTY4MzI0MTE5MDAyMjk3MDkwODY0MDUwMTE3MTM3ODc3NjYwNDEyNjc3MTE0NDAwODMyNDM1ODIzMzgxOTU2MDY0OTAyMTk0MDE0NTE2NjI1NDY1OTAyODUyNDMxOTUxNzI0NDcxMTY0NTE2MjEzMjUxMzQxNjIzODk1ODE3MDgxOTM0NzM2MTE4NTk0NDk0NTY4MDI2OTQ0Mjg0NTgyOTM5MDExMjA2MjEwMTI1NTUwMDgzNjA3MjA4MjgxNzgyMDk1MDQ0ODQ2MzMxNDAzNDY3NzM1MzcyMzI1Njk2OTM0NC8zOTYyMjgyNTkwMDQ0NDYyMzQ5MjEzMTA5MzY5MTU5MzE2MTE3MzY4MTU1OTg1MzU5NjM1MDQ2NjAwNzYzMTUyMjg3OTg5ODk5MzI5NTk0NTk0MDY3MDIwOTExODAwNjA0MjkwODAzNDUxNDY3MzUxNzM1OTE3NDk0NDg1MDk4MTAyNzA3NTk1MzE5NzcyNzg2NDIxMzU1OTE2NzIxODkwMDIwMDYyNzIzMjYxMzE4ODUzMTU3NDMxODEyODk5NzA4ODUzMzc1NzQ3ODA4OTc1MjkzNDczNTY1NjcwODY1MzU1MDU5NTA0NTA4OTcyMTY3OTY4NzVcIiwgXCI5OTEyOTE5MjM4OTE1NDM3MzAyMDA2MjY0NDc3OTMxMDMxNjExNDQ3NDY3MDcwMTAzOTczMTA2NTY3NTM4NTI4OTUxODc4Nzk3OTMyNTU5OTM1ODYwNzM4NzQ1Mzc0NDM3NTIyODE5MTI0MzQ3NTEwNTkwODAwMzcwNDcxOTEwNDkyMzM4NTg0Mjg0MDkyNTM0MjY0NjA4ODAxMjIxMjM1MDI5MDYyODgxOTY0MTAxOTk2NzYyMDExMjk2OTk2ODUxODkzNDU1ODI4OTQ2NTIxLzM2NjA1Mzc0NzI2NjgyNjQxNTEyMTg5NjE2MzQ2ODk2NjUyMTA5MzM5MzYyNDk5ODYyODUyOTA1NTMzNTcyNTQyMjQzNjA0MTczODY1MTUzMTE0OTMzMTAxOTkzMTk1MjM2ODcxNzE3NTc2NTMyMTY5OTQ3NDExNTAzNzc1MDgyMzQzMTcwMjUxNTgzMDIwNTc3NTgxOTY0Mjk2MjM3MjMwNzIwODQxNTc5MjgyMjQ3OTgzMjI4NjE3MzI4ODAwMzQ4NDcyNDM4OTQ3ODQwMDBcIiwgXCI5MjYzNzEwMTc1NDMzMTgxNzQ2NTc1MTg2MzY5MzE4MjQ2MDAyOTE5ODk1NjQ5NjIyMTI3NDEwODI0MDQxMzcwMDc5MjI1MjAwMjgyNDAzMzY4MzE5MzcwNzQzMzYzMzAzMTY0MzEzMzk1NzIzOTA0NTEwNTM5MDUwMTU3MDMyNjg0NzEwNDY4MzY0MDY3MjA0ODc2NDM0NTQ2ODQ4NjM0ODQyMzMzNDM2OTU3MjQ1Mjc1MjE3NTgzMjQ4ODA1OTkzMTQyMjI3NjMwMjk3OTI0MTE5MzMwNTUzMzA4NDY2NjYyNDg4NjgzNjI0NzgzMzA3MDIzMDE0OTA5MzYwNjQwLzMzNDExNzcxODI2OTc1MTcyNDg1NTI0Mjg4Mzc2NjE5MTkyOTk3MjUwMzEwMzU4NDk4NjU2MzI1MTE4ODI2ODg3ODYyMjY4ODgxMzc2MzQxNjgwMjQ5NzYwMzM2NTI3NTM2ODkyMTA3MDAyMTgxNjM2MjE3MzkwNzg1MzQzNTM1Nzg1MTAzNjQzMDE0ODEwOTM3MzAwNTQ3MjUwNzgxMzg2NTg4MDUwMjUwMTQ2MTU2NTEwNDMzMTM5OTA2ODQzNDc2MzIxNjYwMzAzNTkwODY4ODU1NjExMDQwMzQ1MTA5OTA4MjY2NTUyODkyODgzMTk4NDA1OTU3NTMwMDI3NzFcIiwgXCI1MTE2MDgyMjMwNzEzNjIyMTcxODMyMzI3NTQyNDM5MDUyNzI3NDY1MTE0MzIyNDc5NTcwNjAzOTA1NDk5NDk2MjIxMjI0NjUzOTgzOTYwNTk4OTQ2MDMzMDgxMjEyOTA5MDY2OTE3MTM3NTQ2MDY1NTQyOTUzODY1NjEyNzE4ODM2OTE0MzkzMjc1NjgxMzE4NjY3NjY3NTIxNzI2Nzg1NjMzNjM4MTg5MzczOTk4MTkxMDkwNTAxMjAxNDI3OTA2NjE4MDc1ODg5NzQ0NDg5MTkwMjA5NTg0LzE4MDU3NTI1NTM3MzYwNjA0NDM4MjA0MDYxMDEyNzc3MDY5NzA3Njc2NTcwMDYzNDYyNzYxODM3NDg3NDk2MzAxNzk0NDIzMTgwNjM1NjgyODYzNzIzMjAxODg0MzM4NDM3Mjk5NjAyOTQ5NjUzNjYzNDY1MjIzMDM4OTg2MDk2NTU3NjI0OTE2MjMwOTg0NTMyNjk5MTYxNjM2MjEwODkwMDU3MTE4MjM0ODg3NDkyOTc0MTgxMTM0NzQwNTY2NzYxMDk1ODExMTA3MTUwNjgxMjQ0Mzg4NzVcIiwgXCIyNDY1NjkxMjU2MTk3MTMyODI0MzQ0NDg1NjY5NzAzNTIyMzE4NDU0MTQzMTcwMTgzNzkxNjA4MjQxNzY2MzgzNTE1NzQ5Mzg5OTM1MzU0NjQ3NjM4OTA5NjIzMzY4ODI3NjA4ODIzOTg0Nzk3MDIyMzc1NjQzODQyOTEyOTA0NTk5NjEwMzYwNjg5MTY4NTcyNjU0OTk2MzMwNjE2NjA1NjI1MzIwMTEyNDg1MDE0NzYxMTQ0MDE2Mjk4Mzk3NDIwNTgzODkxOTU3MjUzOTM3MDIwMDAwMTE4NjA3OTk3OTM3NzgyOTU2MDY5ODgwNTczMDMyMjU0OTM4MTQwMDU3ODk1MzM1NzA0MzIvODUzMDcwNjMwMjA4MzYzMDU3OTcxNzgyNzMwMjkzNTM2MjMwNjA4NjAwMDkxNTIxMTQzNjE0NTM0MzQwMzI0MzQ2OTk2MzYwNzgxMTUxMTQ0MTI1ODg3MTk0MzIyNzc0NDEwNTUwNDkxMzI1NTk3ODIyMDM5ODgzODc3OTQ3MTE1ODUzNjgyOTY4MTcyMjI1NjU0MzQ5NTEyNTY3ODg4NjcyNDQ2ODcwODEyMzM2MzI2NTA5NTM4NTAzODMyMjA4NjQzOTQyNjE3NjM4NDQxOTQ5NDgzODk4NjExNDc2MjI5NDQ2NTE1NDY5MTIzOTQ1OTMxNjQ0MDY5MjY0ODk4NjIwMzYzNDMzNzVcIiwgXCIxMzM2NzIwMjYzMDM0NTI5MTEwNDYxNjM5OTg0ODA4NjA5MTcxMTkyOTA1NzY2NTgzMzA5MDk3ODU3MDc2MDQ4ODY4ODExNTU2MDY3MjU4MjI2ODUwODg5MjkyMzYyNjY1ODM0MTY3MDg2Njg1MDI3NjA5MDc2NzcwMTk1OTgwMDIxNzUxMjI0NTMxNzA1NzQ3MjkwMjg0NTI3MjE0NzY0NjQ3Mjg1NjYxOTE0NjQ4OTc5Mjg2OTY2MzA5Nzk4NjMxNTQ2NjE3MDQzNzQyMDYxNzE0NjkwMTQyMjUxNDMvNDUzOTgxMzA5NzUyNzA3ODUwNDU0ODI1Njc3NjI4NzE0MDUwNzIxNDA1NDg5OTgxMjU0NzEwMjU0NTE2NjY1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiwgXCI2MDQxNjkzOTUzMzYwMDAyODAwMjI0MDkxNjczMzM2NTYyNTA4OTEzMTk5OTk1OTg3NDc5MjY0NjA1MjE2MjUyMjIwNTc5NzQwMTM0NjAxNDM1NzcwMDg1OTIwODY5Mzc2NjQxMTgwNzYzNDE5OTA3NDQyNzIxNzA1ODg3MTY5ODg0MjMwNjQzNzk1MTI2NTY4ODE1MTIzNjQ3NjAzMDQ3NzM5Nzk5MzAyNTYyMDk1NTQyNDU5MzQ0ODExNDI5ODgyMDUzMDg2NTUwOTAwODAzNzY4OTY0NjEyMTkzOTQxNDI0MTI4NjQ5OTc2NzA0NzI3MTgzNzk3NDk1NzU5MDgyNzQxMTY2OTM4MzUxODcyLzIwMTY3NjY5OTIxMjIzOTU2Njc4Mjg1NTMyNzc5OTc0Nzg1NzA1MDM0NzU2MjYxMDcyODYzNDM0OTc5MTc3MDU0NDYxMzIwMTcxMjUwNzk2MTI3NTYwMzUyNTQ3NTA4MjI4NjA4MTU1MTU4OTk1NTc4NTUxNjY4MjQ1MjM4NTE3NzkxNTYzMzYyMzUyOTQ5MTQ3NzczMDc4MDIyNTY0Mzk2NDU1MjU4MzUyMjM2OTE3NTE5MzE4NjYxODg5NTczMjQ3OTIyNzYxNDk1NDkwNzY1MDA3ODQxOTE3OTEzODA4MDM1MDAxNTY3NzYwODg2ODM5MDAzNDYwNjU4MzAwNjYzNzAzNzAwODMzMDk4NzVcIiwgXCI3MDU4NjgzOTE1OTcyNDQ1ODI3NjQ3NDkyMjkzNTYzMzE0NDE5Nzg4MjAwMjQ3OTYwNjY4NzA1NTExMTA0ODY2MjU3Mjk4MjYxMTExNTgyMzY2ODY2OTYzMjYwNTg3Nzg4NzQyMDE2MzkwMDYyMzQ0NDk1NTc1OTIzNTMyNDc1NDI5OTU4NzE0OTEwNzgzMDgxODcyNjEzMDQ5MzAwNDIwMTk2NDA4MzA2Mjk1MjYwMjM5NzI2OTMxMDcxOTM4OTcwMDkxNjg5NTU2NzQyNDA2NTkwMjYyNDcwOTQ2NTc2NzkwNjAvMjMxODQ4NjQyNzQ4NDc0MzM5Mjc3NTMyMDAwMzM2MzM4NjMyOTEwOTkwODIzNTYyMzgxNDY5NDQxNzE2OTIyMDA2MTA3NDMzNDA0NTIzMzE2MjUyNjE4NDkwMjY1OTI3MjY1NzM0NjcwNTM5Mzg0NDg1Njk5MTMyMDgwMDYyMjE1MTk2NDYyMTc4OTMzOTYzOTU3Njc5ODgyMzQyMDgzODkzNDE3NTQ1ODU4MDc0Mzc4NzU0MDg5NzE5NTQ3OTIwOTAxOTE3NTE2MDE2MzQ2MjExMzAxMDU0MjA2MzgzNjQzMzgzXCIsIFwiMTAxODMyMTYwNjA0MTU3OTQzMDkzOTQ0NjczNTQxNjUxMDEzOTA3Mjc4MTg4NTcxNTMzMDc1MzExNjczMjQ5OTIzOTQ4ODU2MDM0NjMzNDQ2NjE3NjMwMDU0NzYxNjgxMDA2MDYyOTEwOTgwMzcxOTAwNzgyNzgxMjI2OTc5MzkxNzY1ODE4MzI1MDY1MDMxODg5MzM0NTYzOTgxMjM1ODk0MzY5MDM2NDM5OTI5NjUxMjYwNTg3MzM1NTQ0MDU2OTc1NzE1MDc2NTk4NzM5OTc3MDY1MzkwNjc4MjIxOTk5OTE4ODk5MDAzODgxNzc4NDQ5MDkyMDM4NzUwNzEyOTY5NDM3NTE5Mjk1ODc4NDkxMDE4MTEyLzMyOTQ0Mjc3OTEwNTcxNjY2MDAyNDQ5MDg2NDkyNTE1NDY0NTQxNTUwMTM4MDA0MDAyMTQxNTcxNjcwNjU3NjQzNzcwNzEzNzgzMzI5MDYzNTQ4NzkwMjAyMTIwODA1MzQxOTg5NjA4ODc3NzM5ODExNzg3OTM3NzgyMjQwODAyOTYzOTYyNTIwMjYxODQ0MTE0MzI3NDMyMTYwNzg4MTkzMzE0ODc0OTEzNjg3Mzg3MjY5NDA4Mzg3NDE3ODA2MTc2MjAyOTc5MjQ0NjM3OTE1ODEyOTA1NDI2NTY1MjYzMTk2OTU0MjAzNDg3OTM0MjI1NTg5NjIyODY0MTQ1OTYwMDc5NzM2NjMzNDM0ODMxOTk2NjI1XCIsIFwiMTA2NTU3MDMxMTkyNzE0Njg5MTM1OTc2NDA0Nzk0OTA1OTQxODA5NjQ3MDA0NDgzNDA3NzgxNjg3MTU5NTY3MTIxMzA2MzY5NTgzNzMyNzAyMDI0ODQyNzY0MDI3MTg1NjYzMTQ4ODExMTk1NTkwOTA4NDI0NDk2MTA5NTc5NzQxMTIyMzAzMDYzNDM0ODYwOTE5MTAyMTczNDA2NjUxNDY2MDI1OTg1Njg5OTE1MjA1NjM5ODc0OTA2ODY5OTY3NDY1NTg4NTgzNjYwMDIzMDE5ODI0NDMwMjk0MzAyOTA2NzkzODU1NTEvMzM5ODQxMjY4NzM2NjYzODU0MTIzMzM2NTEzNzA4NDcyMjM2ODIwMDMxMTExNzg5MTE5MjM0ODUzMjE1NjY0NTM3NDc4NjEwNDE0MjAwOTY5NTc5NjQwOTEwNzM4MDM0NTc5NTk5ODQwMDg1MDgzODcwNjY2MTg1MTE3Njg4NTE4MzE0NDkyODcwMTYwODY1NDUxNDgxMjI2MTY5NzU5ODM4MDA3MDc0NjUyMDE5NzE3MTU3NjYxMDU3MjkyMTAwNzA2OTEwNDMwMDY5NTU5Mjc1MTU0MzU2MzQ3MjQ1NjM4NDUxMjAwMFwiLCBcIjE5MDMwMzkzMzI4NzY3NjM4Mzc0MTk5MjAyNDA1NDM3Mzg3OTk1MzExMzE3NzUwMjg5NzEzMjM0Mzk4NzA4Njg3MzAzMjEyMjE2MTU1MTUwMDgzOTQzMjc3MjM1MDg2NzA5NzU2MjM0OTg1ODgyOTEyOTgwNjQzMjA3ODY5NzA2MjYyMzI2Njg5NTYzNzIwMDQwMDQ4OTc4NzI4MTAyMzAxNzg1MjYxMDExODQ2MTEyNDI1MTExOTM0MTU3OTY2Mzg2OTQzNzA1MDMxMDAyMTk3MTA4NjQ1NDMxNjg5NTI2ODI2MTc4MDE4MzMzMTg0OTM0MzYxNzQzODc1NjgwNjc4MTE5Mzg0OTA5NTM0OTU4MTk0MzgxMDg2ODYzMzYvNTk4ODA2NTM0MzY3NTAzMzM4MzA3Mjg3MjQ2MzIwOTYzMjgwNTU4MTM0OTM3MzgyMTQ5NDA1MzA1NDY2NzA5Nzg3MTc5NDI5MzE3OTE0ODAzNjE3NTI3ODI3ODYyNDQxNjE1MzUwMzk2ODY0MzU5OTc2MjczMjEyMjcyNTg2ODkyMDc0Nzk5NjUxMDg4MzE3NTQ0MTAxNzU1MzYxNDM5Mjk0Njg3MzIzMjMzMDg2Njk2MTgyNjg3NjY0NjM3NDIyNzk2OTk1Nzg5OTY3MDc1MjcxNDQ4NTYwODcwNjgxMjEwNTgwNjkxNTc0OTI0NTQ0ODk2NjU2MTc1NTYzMjY1Mzc4NTE0MTg4MzQxNzk2Mzk4MTYyODQxNzk2ODc1XCIsIFwiNTI1NTczOTE1NTYzODI2MTMwOTYzNTI1ODI2MTkxNDExOTQ5MjYyODQ2OTE2NzUwNDMyMDE5NTk2MDI4MzQ0ODA4Mjk4NDcxMjkzMzc4OTE3NTA4NTQ5MTY0OTkzMzY4MzkyODM0MDIzNzgyNDgwNzAyODkzNjQzNDg2Njk5Nzg3ODcwMDU5OTQ2NDI5ODEwMDcwMjIyMTI2MjYwMjAwMDI2MzMyODc0NDgwMjM5MDkwMzcwMDg4MTIzODMzNDkxNDk5NDAwOTkxMTgxNjU5NDQ1OTE0MzUyNTAwMjQ3NTk2NzU3MDA1MTQyNjIzMzY4LzE2MzI3ODcyNzMyNDkzNzM4OTA5NTgyMjQwNTAzNDQzNTY4Nzc3NjM0NTc5OTgzNTQ0MjAyMjc5NTUzMzc4Mzg4OTM1NjM0NDc1NTIyNTgxNTI2NzgxOTUwODYwODU1OTA3NjE5MTI5MjkwMDM2Nzk4MjQ5MDgyNzM5Njg2OTQwNTUzNjQ4NDg0NjExNTk1NTU4MTA0MzA5MTIyOTIwMjA1MjQwNzQ4Mzc3NjU4NzY4Nzk2NzEyNTg4NTY2NTQ5MzY4MTcwNzQ2MTM0NTg5NTk5OTU0MjM4MTQ3NjE2NDE1NzA1ODM5Mzk3MTQzMTM3NVwiLCBcIjkyNjM4MTU2NTcxNzc4NTg3ODcyNzM0OTQ3MDUzMzg1MTY4NjEwNDU3NzE2NzQ4MzgwNTczMjkxNzAyMzk2MTA5NTMwMzk5ODcwMjM0Mjk3MzY3NTIwNzk1NDQwMTQ3ODA3MDc0MDg2NjY2Mjg0NzU5OTcyOTExMjQ4MDU1NjI5OTgyMjcyOTY2Nzc2MTYyMDQxNDA2MDUzNTYyNTc3MTIwMjIzODQzNjg0OTI1NzUzODEzNTU1NjM5NzYzMzAzNDc3OTI1MDQ2MDU2NjY2MzE1MTIzNDM0NDc1NjAzMDE0MTczMjUxNTQwMDM0ODEwNDAyNTAxNDg1NjE4Mzk4NjE4Mzc3Nzg1OTczNDY2MjM2MzAwNDY2MjM3NTEwOTQ0MDAvMjg0MzMyMTcwOTk0ODQ5OTk1NTA5NTU5MDg2MjI1Njc0NDUzMjIyNzY5ODAwMTQwODkyOTE0MjU0ODA1Nzc5MjIxNzc5MDUzMjYyNDAwMzE5MDQ0NzM2MzU3ODA0ODU2MjQ0ODE2ODcyMTUzOTE3NzQ1ODA2NTQ4MjE3MDE0ODQ4MjM3NTU4NTg2NzIzMDEyMzg3MzE3ODEwMDExNzA5NDUzMzE0MzA1Mjg4NjUyNzQ1MjY2NTQ4MDYxNDYyMDEyMzc2NDAzNjk3NDE4MDkxNzIwNzQyMTQ4MjQzMTk4MzQwNzc0MjE1NDYzNDM5MTI2NDYxOTYxNTI4OTIyNTc0NzY2NDUzMjMzMjQ2OTc4MzMwMTcwNDY0MzI1NDA3NjYwMVwiLCBcIjQwNzk1OTMzOTcyNjExNDQ1NTYyMjE4MDE4Nzc1ODc1MzAwNzM0OTIwOTAxNjM5NjI0ODc2MzA3NTc1OTI1NzM1NzkyNTYzNjAzOTc1MjQ3NDIwNzY4NTY4MjIxODQyMjcyMTgyNzg1Nzk5NDc2ODAyMzM5OTYyNTA2MDIwNjcwODM3ODQzMzk2MDk5Mzk0NjE1NjgwMzk0ODY1NTA5ODY2NzE1NjkzNzk0OTE3NDQwMDg3Mzc0ODU1NzI0ODgwMTg3NDczNTgzNDk1Nzc5NTA0MDEzOTQwMTU2MDQ5NDA4NzQ3Njk2NzU0ODA2MDIwODI0Mzg2Ny8xMjM3ODAyMTg3NTE4MTIxNTY3NDQ0MDExMjE2OTA5OTYzMDU5NzgxMzQ2OTQ2Nzg5MzQ0NDcyMzc0MDI1MTExMTY3MzE0NTkyMTQ0OTg3ODQ0OTc0MzYzNTgxNjA5NjQxOTgzMzY4NzQwNDM3MDI2NTI3NDY4MzQ3NjMxMzE0NDQwMzAxODUxNTExNDM5ODczMzE0MDQ2MDQwODc3Nzg1MTQ4NjM5NzM2MzM5NDE0MDE4MjYzMzQ3NTAyNjg0MTYwMTUyMjQ5MDYwNTY1NzY2NDEwMTg5NjI4NjM2NDUwNDM5NzY1Mzc2NjQyMjc2MzkyOTYwMDBcIiwgXCIyNTQ3Njc2MzkxNTk4OTE3Mzc5NTE2Njk4NDM5OTcxOTE0Njk1MjMwNTQ4NzgyOTA0NDc5Nzc4NjA1NjkxMzM4MzY0NDUzNjA2NTM3NjQzMDg4ODU3MTE2MTQxOTM5MTcwODk5MTM1MDI2NTUyMDE2OTY5MzIwMDYxOTAwOTI2OTU0MDA4NTIyNzgxMTYyMTg2OTk1ODU2NTgwOTU1MDkwNTQ4NDcxNDQ4Mjc2NzM2ODc4MzAwNzE3ODY5NjI1NjUxODkzNzQxMzE2NTMwMTA5NDM4ODc2MDY3NDE5ODI2MjE3OTAxNjU3MDE3NTA2MTU3OTk3NTg4OTQ0MjMzNjc3NDY3MzU3MjIwMzE2MDg0NTgzMzgzNjIzNjAyODY1Mzc5MzI1MTg0Lzc2NDU2MjAzNDc1NzM5MjI5ODc4NjQyMDM3NDY3MjI2NjQ5ODgxNTAyMTIyOTUxOTg1MzcyNDg1MDg3NDU3NjQxOTg4NTM4MDgzMDc1MjkzMTcwMTgzMTI1Njk1OTE1OTgwMDc2NDY3MjYwNTAwNDg4MDM4OTM1ODYwMTY1ODM0MzIwMzUxMzE3NzA4NDM4OTQ5MDI4NjcyMzI0MDE4NTE0NjU3MDkyNTk1NzI4NjA4MzAyNTY3Njg3NTE5NzAyOTY2MjAzODIxMzIxNjU0MTM1Mjg3NTU3MDEwMTM2MzY2ODkxNzc2NjIyNTcwOTU2OTM1Njg2MTI3NTQzNDQ3MDU2ODc2NzA3Nzg0NDY3NTU5MzE3NjE3ODYxMTAyMTEzNTU3MzYyNVwiLCBcIjE4NjU0NTM1MjI4NjQ2MzczMDU1OTkzMzM0NjU2NTMxMTUzNTU5ODI0MzY2NjAyMjIzMjAzNzA1NDczNTgwNzI4OTUwMTE3MzQ0NDEwMzY5MjMwOTczNTc2ODcwMzg5ODMzMDQzMDEzNTM5OTAzMzUyOTM1NTM2MDM5MTY1ODcyODk4NzM3OTM4NTczMjA5ODk2MDYwOTc0NDMxMzg3ODQ3Nzk2Nzk3MTU1NzIwNDIwNzA0MzgwMjkzNTc4Mjg3ODc0NTI3MTg1OTQ2ODI0ODcwNDAxMjYxODI1NDIwMzEwMTc2Nzg0MTUxNzU2OTQ0MzU1NTE0MzI1Mi81NTM5OTE3OTY0MTYyMTY1NjIzMzU4OTgyMDk5NjE0MzgyNTk1OTM2NTc4OTA5MzI2Mjk3ODk4ODI4OTQ0NTYyNTE1MzA5OTU5MjQ2MzM3MjU3OTQ5NjI0NTQ0MjMzODY1MzA1MzY2MjEzNDY5OTY0NjQxMzgxNzg2Njc3MDIxODU3NDc5NTM3ODY0NDQxNTAxOTk0NDMwNDg2ODI4OTExOTQ0Mzc3NDkzMjc4MjIzNTYzODczNzg4ODQ2OTc0Njc0NTYyMTM4MjEzOTI2Mzg1NjYwMzIzOTU4ODU5NDA3ODY2ODM5MzE5NDY3NTQ0NTU1NjY0MDYyNVwiLCBcIjY2NDg4NDQ0MDE2NDc4NjQ3MzM0NDg1NDk1NTMwOTA0OTExMzI2OTM1NzMxNDk1Nzk4NTI2NTcyODEwNjkyNDIzODU4ODcwNTUzMzQzNzE2OTc5NjU1MTkxMjIwMjkzMTE4NTc0NjE5MzE1NTgwMTkwNTg0MTcxMjUwMzQwNzI1ODE2NjEzNTA3NTk2NjI4MDQzNTc4MDgxMjcxNDI1MjY3MDM2MjIwMjA5MTY2MzI4NzA5NTQyMzcxMjU5NjQ2MjY5MDc1MzQ2ODY4MjYzNDI2MTAyOTM5Mjc5NDE3MzYzNjk0Mzk3ODQwNDAwMjgwNDQxMzAwOTU5MDAwNTk4NDczNjYxMjQyMTE3Mjk3OTEwMTk3MjU1Njc3MjAwNTU5NDQ5OTc3OTg2MDYwOC8xOTU0ODU1MTc3NzY0MDcxNDUyODY0MjQ0NjA0NDg5OTU0NjA3NTQ2NzQwMzk1NjA2NTE3OTExOTI2NDc1ODY1NTA2MTU4Nzg5ODgzODAxNTM3MzA2MDI2NjU3OTU2NDcxODc4ODQ1NDMzNjEyMTg5NjIxMjUxNzI4MDg3OTIxNzYzODI5NTY1OTkyNTYxODg3MDY2MzY3Mjc0MTg1NzI1NDEyNTQ0ODA3OTgzMDM1NjY4NDAwMTAyMTc3MjkzODY5MDUwNDEyMTc3OTM2MTQyMTQ1MTgzNjM4NTkwNTgzNDgyNDk5NjE3OTAxMDQ2MTg5MTA4Nzc4MTMwNjc1MTA3NTgyMjUzMDI4ODQ4MTU0MTAzNDcyMzgyMDAxMzM2OTM3NTY0OTM3MDM4NzVcIiwgXCIyNjE0OTU3MjgzOTM0MzE0OTA0MzE1NDcxMzM4NDg1NDUxMTY2MDUzNjY0NDk0MzgzMjQxOTI5Mzg1NDI0NTk5Mzg5MzA5MjE1MDczMjY3MDUyODYwNDY0MDA5OTgxMDYzNDgzNDQwMjAxMTkzNzcxNjA3NTIwNTcyMDc3MjMxODg5Njk5ODU4NDgyNTgyMzYzODQ1Mjc1NDUyMjgwNjA2Mjc2OTQ5NjUzOTcwOTkyNzE5MzMyNDcyMzcwMzUxMTcwNzMyODk5Njc2MzE2OTY3MjQ0NTA0NTM0MTU0NjE2MDM2MzcxOTc5MDMxMzk5NDI1ODQ2MTAwNTI3Njg1Lzc2MTQ5MzY2NDQzMjc0OTA4OTMxMjY2NTQ4MDc3MzQ5NjI5MDY1ODAyOTk3MTAyNzY4NjU0MzQwNDg4NTQwNzY0NDA2MjQ4NTc0NjA3MjcxOTU1OTI4ODIzMTM2MjA2MDE0OTYyNjIzNzkzOTAyOTY0MTA5ODMyODI3ODY1MDkzOTY2NTY2NTk2OTAxMTUyOTI5Mzg2OTU2MjYzNjY1NjY1MDk5OTc1OTcyNDcwNDI3Mjc0MzIzNTIxMDg2NzY3Njg3MzUyNTE0NzgyMDc0OTU2MDE1NTI5NDAyMjQ4ODk5NDQyNjcyOTkzOTg5NDc1MzI5MzkwMDk3MjAzMlwiLCBcIjEyNDg0MzM4MDUxODQ5Mzc0Njc2MTE0MDM2NzI4MzAwNzUwNzg1NDM2NDUwMzk2MTE1NjcwNDA5NTE5ODAxMDI1NTQ2NTk0MDA4NTUzNDA5OTc0NzI5NzYwMDA4NTkwMzgxNDAxNDQxNTgzMDc4NTY2Mzc2NDM3MzA1Nzg5NjAxNDM5OTgyMjEzMTE3NTIwMjM0MjM5OTUzNjQzOTI4NDEyMzkxODg1NTg5MzgyNTIwNzIwMjI0NDgzMTMxNTU3NTU5NDg4NjY3NTgxMzI1NjQ0ODg0Njg2MzcyMzA5MzI0MDk1NTkwMTkxNjIyOTEzNjM5MzQ1NDYwNTQ1NTQ0NDEwNTQ0NDk4NzAyODM5MTc0ODEyMTA1NDM5OTUzODA2NDY4NjA3NDUyMzUwNjE3Ni8zNjAyMjIyODIxMjA1MTY1NDM5NTQ4MDIxMDM3ODYyNjY0ODUxODQzMDI4MDMzNDQ1ODE0NDg5Mjg4OTI3MTI3MjEyMjY2MjQ2NzYzODMzMTA5MTg2MzIxNTE0NjU0ODA0ODE0NDY3NTY1NzIzOTg0NjMzNzE2NTgxMzkzODQyNDM4NzQ5OTM1ODg1MjMwMTAxNjkyNjMxMjA4Mzk0MDIxMjEwMDAwMTIyMDE4MDc2MjE4OTk3ODAyNDgyMTE2Njc0NDk2NDkwODg3MTQ0MzY4MTMzMjY2NDc5ODk0MDY2MDQyMTQ2OTUxOTk5Nzc0Njc3NTI3NTg3MzA4NTc3MDAxODI2OTcwNjg0Nzc0MTA2NDAzNzg3NjEzNzMxNTAwMTIyODMxNTgwNjY1OTg3NVwiLCBcIjgyNzk5MjM2OTA2MzA0MzE1NTU3ODczMDg3MTg5Njc1MDU3MDk1MTc2NjYyODQ3MjgxMDUwNjkyNjA5ODUwNTAyODI2NDU1MjA0NjgyOTA5NzA4MjA5NTY2NTE5NDAwMDAwMjgwMjY2MTYwMDE5Njg0MDYzOTIwNDMwMDgwNDIyNTM1MjMzNzYzMjI1OTk4MDcwMzgzMjcxMzAzMTc5MDkyMjQ4NTczMDYxNTMwNTQ0MTMwOTkxNzY5NjA0NDk1NDI4OTE4NzgzNzY1MzkzMzE1ODk1MDc3NDI0NjAxNzIyMzU3MTQ2MTg1ODkzOTQwNzM4NjA4NzA4MTUyNTEzMDgzMTM5Mi8yMzY4MDU5MzI4MjM2ODY1MzQ5OTExNTMzOTM4NjkyODg1MzAzNjgwMTE1NzQ2NjU4NTkyMjY3MDQyNzk2ODU1Njc3MjM4MzA2OTY3NTQ4MjE2NTg3NzAxNzYzODUxMzg5MTc3MjI4MDgzNzc5NjIzNDY2OTA3NTcxOTExMjIzMDk4NzY5MjIwNjk4Njc0NzI1MTgxMTc2Mjg2Mzk5MTMwNzc0NDI4MDYxNDc5MTA4ODQyNjc2OTQ4NzkwODk3NTMxMzg0Mjk3Njc0MDE3MDAyODMwMTQxNDMyNDg0NDU5NjY0NzQ4MzkxOTM2MjgzMDk2Njg3MDIyMjM5OTQwNzEzOTQ2MjVcIiwgXCIxNzM0NzI3Njg4Njg3ODMyMzczNjU0MDA1MTMyMTU4MjU0ODcyNDM3ODQ5NzgzOTc4OTk0MzYzNDA3MTAyNjMzMTAwMTU4ODY0NTUxOTg2NTk5Mjc3MzE1NzU2NTU5NTg4NjI1MDIzMDE0MDQ1MjE1NDI2OTE5Nzc3MDYxNTA5NzM3NzQ4NjAxMzA5Nzk3OTA4NzY0Nzc3NDUxMzUwMDcwMTc5Mzg4NTk3ODE5MjIxODQ1NTY4NzA3ODg4Mzc2NjA4NjMwOTcyODI4NzE3MjU2NzQ2NjQwNjQ0OTM3MjY1OTY4MDA0MDE4MzI3MzYzNDcwMTA5MjU2MTcyNzUxNDcxMzQ5NDkxNDc5MzQyNTQwNzE0OTE4NjA0MTc5NjkzNTA1NTE4NzI4MTc0NDM4NjQzMi80OTE5MzI1NjIxODA0NjgzNjIzMzM5NjA2ODQ5OTcwODMyMDk0NzE0MzcxOTAzNzA5MTk1NTM5NDQwNDI0NzM4OTczNTc1OTAyMzI5Nzk3NTQ2NTkyNDk3Mzc4MDAwODU4MTk2MTczNzE4MTQ1ODgzNzgzNzA5MjIzMTU4MjYwNzAwMzY1MjI0NzU2MDgxMjc1MjcyMDIxODU2MzkzNzM1NjYzMzk5NTUyMTY2NzM3NjkwMDM4ODMyNTUwODUzMTQ1ODMxMTg1OTc5MDk0OTc5NTU2NzE1Mjk0OTkwMjU3MzE1MzY5MTI0MDY1Nzg3NDczNzA3MTM2NDY0NzcyMjQ3OTE3MTU2MjMyMzY2MzIwMjY3NjAxNjIyNjE3ODAzNTE0MDAzNzUzNjYyMTA5Mzc1XCIsIFwiMTM3OTg0MjMxODMwNTI2ODY2MjM2MTg2MzU3NDYxNDU4OTE3MDIwNTM4MTA4MDU4NjE1NjMyODAxMjk4MDkxMDMxNTQwNzI5MTExNTI3NzM0ODcyMDQ0NzkwNDg3Mzk2MzAyNTQ1OTEwMTA4Mjg1OTIxNDIxNDE3MzU4MTEzMDU1NTIyNzI1MTk3OTk4NDgzMzgzMzgwMTkyMzkxMzEyMzA0NjQ3MDA0MjQwMDYwOTcwOTI5MDcyNDk4MjkzMjEwMDU3MTIwNjE3MzMyMzIzNDQ1Mzc5NDI0ODY3OTY1NzY0NzQ5NTM0MTI1MDgxMTMxMzI3NTY1NTA3NTI0NTAyMTYzNDYwNzYxLzM4ODEwNDQ1NzkyNjQyODE3NTYxMTY4OTUwODkwMzE1MjEwNDcwOTQwMDA2NjEzODE5NzkwNTQzNjUzNzQ1MzI3Nzc4NTc5Nzg3Njk0ODA5NzgyNjAxNzc3NTE0MTE2ODU4NTE0MDQ5NTg1MDc0NjY3MDg1Mzk5OTI1Mjc4NDU5MTM4NTA4NTE0ODM4MjY4MzIxMzQ5MDY5NDgxMzM0OTY3MjIxNDU1NzIyODExNDE0Mzk5NzM4NzU2MTUxNDE0OTA2MDkyMjI1MjY1MzU1NDQ5MDExMTUyMjY3MDY4NzI2NDE3MDQ1NjQ0MjIyMzIzNDg4NDQ1NjI2MjkyNTc0ODc5NzQ0MDAwXCIsIFwiNzQ2NTY3MTIwNTQ3ODIzMzM0OTE0MTM2MzM5NjMzNzY2MDk4NjI2NjM2NjQzNDQ5MTQ0MDMyNjI2MjcwMzU4NjE5MTI1NDAyODI2MTEzMjY5Njk5NzA5NzIxMDcxMTM1NDcxNjI1NTg4OTgxMTI2NjM3Njc0NDAyMDQ4NTE5OTkwMDEwNDk5MTgwODQ0NjY1MTUxOTcxMzU2MTQ5MjkyODE4Mzc1NDQ4NTA0MTIyNTQ1NDAwMjI3Njk2NjIxNTcyMjYzNjIxNzI5NTEyNDYxNTI4NTUwNTg4MTA4Mzg0NjE5MDY0OTEyMjI0ODg0NDY1NzM3NDE3NTk2MTkwNzM1OTY2OTE1MTY3NTMwMzMyNzYyMjAzMDc0NDQwNjg4Njc2MTIzNzU2MTYyNTcyODI5NjkyMTYwLzIwODMzNDMzNzA1NzkyMzkyOTYzNjg4NDE3MDUwNTU3MDM2MzE3MTQ0MTE0Nzg5OTgxNjgxNTc4NTE1MDk1NDQxNzU5ODY0MzYxNDE1Mjg1Njc2NzE4NjEzMjQ2NzA2OTM2NTYwNTQ5NjIxMDAzNjE3MTQyOTcxMjQ4NTE4MjE2Mjk0MDQ2MDEyMDgzNDM0OTAwNjc4NDk1NjUyMjYwMDY3OTM1NzMwNzg0OTk4MTg2MjAwNjcxMDIzOTMxMTc1MDI2MTUyMjgzMjk5Njg3NzcxMjM1MDMzMDI5MDgzMTYzODY0MDkxMzkzMjI2NTAwNDEwNzYyMzk1NDkxMzE1NTE0NDk3NTI1Mjc0MzI1Nzg0Njk0NTYwOTczNDM2ODUxODQyNDE3Mjg0NjExOTMwNjY0MzQzMVwiLCBcIjY0NjQ5MzcxNzI4MzMwNjk1MDc2OTI4MDEzNjYxMDAxODE5OTg5MzMwOTUzMzgxNzMxMzcyNDUwMTQwNDgzNzc5NTM2MTI2OTQ4OTU3OTkzMjYxMjk5Mjg3NzUzNzkxNzcwNjIyNTEyMjQ4NjMwMjI0NzI0OTkwMjM0OTAzOTI4MDU2Mjc1MDgwNjgyNTM3NjQxMzc3MzkzMjEwNzI4NTQ2MzY0MTc2MjY3MDM0MzM5MjIxNTU4NjQxMDg0NzMwMDUyMzA0NzcwNDk4OTI5OTU4ODM4OTk3MjM5NjM1NzkwNDY5NTM2ODU3ODYzOTYzNTg5MTE4ODg4MjM4MDY5NzM4NjQ3MjM5MDc2LzE3OTAzOTUxNDk4MjAwMjEyMzI3ODAyODQ3NDI1OTEzNzIzMzU4NDUyMTAwNjg2MjQ2MjI0MDA4NzQ1NDE0MjE0NjkwMDQ3MDc4MTIyOTI1MjQ3MDg2NTIxMzYyMzI5ODMzMzA3ODQ5ODE3OTQ0NjQ1NjQ3NzUwNjQ5MjkwMjQ4MTEwNTA5Mzk1NjI4MzA1OTcwNTIzMzg0ODMxNjcxNzM3NTY5ODcyNTk3Mjk1OTQ3NTkzNDEwMDY3MzY0Mzc5Njg3NTg4OTE5MTM1NjIxNjIxMTYyMDA3NzQ4NjM1OTIwODY0OTI2ODY3ODcwNTAyNTY4OTM1NzM5NzI1MzEyNjg3MDk0MDQ3Mzc1XCIsIFwiMjQ1NDkxODk0MjE1ODAwMzA5OTY4ODkyMjAyNjAxNjM5MzY4ODA5MjM5OTI5NTE2NjMwNDYzNDMxNzYxNjc3MzA4MzM4NjA4NzUzMjg2OTE5MzQ1ODU5MDQ0ODkxODk1ODMzNzUzMDQwNjQxMDgwMzg0MDgzNzY0NjQ2NTUyMjY1NjY3MDA1MDExMzU0ODIwODYxODY1NTA3MDIzMTI3NDc3ODU5Mjc2NjI0NDI4Mjk2NDQ2MzcwMjM1NDg3Mjc1MzY1Nzc2NjEyMTgyNTE5Njg5ODkxNjcyNTQ5ODU1Mzg4MjY4OTIxMDI4MDA4MDIwNjYyNzkxNjA0NjQ4NDk0MjgyNzQ4NzcyNjMwMDgyMjMxODc2NDA1ODA4NDMyMzMxNDEwOTU5NTMyOTMwNDQwNzQ2NjE4ODM4MzYxNi82NzQ4ODAxODU5MzEzMjU5MjU5NjY1ODY1ODM4MjAwMTA1Nzg5Nzk2OTkxNDE4MTQ0MTczMjY1NTI2MjkyMDYxNDAyNTIzNDg4MjI5Mzk4NDUwMDY4NDU2Njk1NzA4ODUyNzE1NzY2OTg3NzE0MDQxNjI1MTIwMDE1NDk5MjI5MDkwNDg5MTYwMDAwMTc4Mzc4OTg2NDkxMDA4MjU5NzYyMzI3ODQ0NDY2Mzg3NzYwMjE0ODM4MDI5ODk3OTc1MDE3MDU2ODU2MjA2MTI5ODY3NzE1MjEzOTA0Mzk5MzYwNjY1Mjc3Mzg2ODIzOTY1NjA0NjI4OTk3NTM2NTc5NDI3MTUzMDY3OTI3ODMyODM3ODIyMzg2NjIxNTU5MjIwODIwMDU1OTE1MTIyOTYwMDc4MjA2ODI5OTUxMjVcIiwgXCI3NDAxODU1ODA0MTA2NjE2MjkxNjQ1NDAxMDY4MDU5NDA0MjUxODQ2Mjc1NjIzNDI1NDc4ODE1ODE0MTExNTI0NDM0OTA0NDk1ODQ0MTUyMTc0OTI3NzY4Njg1MTkyODcwNjQzMzU1NjI4NTk3MTA4ODQ1NTIyNjIxNzY0NDAwOTYyODM5OTQ0MTk2NzUwODgzODU1MzM0NTE1MjMxMDczMDU2MjIyNDkxMDc5NTQ0NjM0MTYwMTA0OTY0NzM5MjA2OTM3Mzk3MDEwMTQ5MTc0MTgzMDYyMzA3ODEyNjM0NDkyODgwNDAyOTUyNDE4MTU3ODk0NTU4NjY2MzExMDg0ODE0MjU3MTE0OTg2MS8yMDIwNDE1MzYyMDAwNjc4MDY4OTkyMzMyODYzNDU4NjA5MTEwMTAyMTQyMzk3OTYyMjE3MDU3OTAzNjE0MDU5NjA4NTU2NjE3Mjc3NTA1MTU5NTU4ODQzODU5Mjc0MjU2MzkyMzQyODkwMDg2NDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCBcIjIxMjcwMzIwMzY3NTgwNDU1MTMzMzU2OTAxODU2MDg1NjMwMjM5NTQwMDkwOTUyMDYwODgyMjQ0ODczNjU1NDE5OTUzMjY3MTQyODUxMTkzODQ3NDM5Mjg5ODc2MzU3NTI5MzE2NjQyNDA3NTIzMjM5MzczMjEwOTc5NTU0NTY1NDM4NTQ5NDMyMDYwOTI5MzEyNDc0OTg4MzMwMDE0OTk5NTU0NTYxOTA3MDE2OTU0MzA0NTk1ODM4ODUxMjUzODIwODY3Nzc2MDcwMjE2NzA0NDc3OTUzMjE2Njk5NDg3MzMzMjg5NzMzNTAyNzk4NDY5Mjg2MTM5NDkxMjA5MjkyNTAzMTI2NjYzOTMzNTk0NDI0MjMwNjYyMTIzMTEwNjA5MzE0NjkwMTc3MzcxMDYwMjgzMzk4ODI4MzA4NDgvNTc2NjEyNDE4NTExOTAyOTI4NzU3MzQwMDYyODQwOTY4NTI2ODYyMzgxMzI2Njk4MzA5NTc4NzcxMjM4NzE1NDYyMTgwMjgyMjEyNDIyMzAyMjYxMDQ0OTgwMTMxNTk0NTIyNDA3MDY2MzY5MjIyOTk4OTAzODA4OTYwNjE3NDYxMTY0OTg1MzE4NjMzNTE4NjgwMzA0OTk1Nzg0NjE0MzA4OTc5ODgxNzM1NTM3Njc4MTgyMTM0MTI4MzE5NTk2NjM2OTIwNzE5MTA2NTA2ODI5NTcxMDcyNDQ3MzYyMDUyMzE5NDM4MDkxMzQ3Njk5NzIwMTQ3MDAzMjA5NDE3ODA2MjMwMTQ5NTk4MzQ1MDY4MDc4NzE3OTQ4MDI1MjA3NjM1NDQ4MjA1MjUzMTg0NTQwOTM2NDc4NDQ1MTI1XCIsIFwiMzUyODk2NTM5NzU1NjEwODM1NzY2NDE5NTQ5Mjg3NjIxMTY4OTcwNjEyNzQ4OTk1MTczMDkxMDI3ODQ3NTAzODQwMDIzMzUxODcxMTcyNjMyNzM0ODg3NTEwNjY1NjkyMzQzODYxMjA3NTk4NjYyMDQzNzIzOTg2MTExOTYzNTY4ODg0NzkwMzY5NDkwNTMyODIzMDEwMjc3ODk1MzA5OTk3MzczMDY1MDEwMjk3MDAxMjg3NDQ0MDgwMTU2NDIyMTEzNTk0NDIxODM5NDM5MTYxMDY3OTA2NjYxMTQ4NzA5NzQyMTIxNTk0MTAyODQ3NTE1NzE5MDUyNzU2MTA5MjE3ODQ3MTYxODQ1MDg0NDAvOTUwMzAwNjA2Njg4MDcyODM4NjgwODE0MzA0NTkyNDExOTAyNDIxMjM3NzE1MDIxNzUzMzI1MDU2MjE4ODIyODA2MjE3NDA2NDY5MzM3NTEzNTMwNjQzODEyMDM4NTg3NzMyMDE2MjcxMDkxODcxNjYxMzU0NjA3NzE1NjM4OTU4MzM4NDY1NjM0MDcwOTYzODQzMDY3NDM2NDIzMjM0MzYwOTcxNzczNTU3NDAzNTUzNTEwMjk1MzQ4MjM2NjkxNDQyMTIwNTIxNjY3NTI0ODQ3MTY5NTExMTcyMDk4NjM0NjA5MjczODcyODkyOTg3ODUzODQzMDY2MjE5MTI3MjczNzE4MzgzMjU1NjEzMVwiLCBcIjEwMjYzMzU1MTAyMzk2NDc5NDQ4NTU3NTQ5MTA2NTkwOTQ2NzEyNTQ1ODk3MjI1MDIyMjU4MTEzMzY4MTA4MDUyNDM3MTUwNzU0NDE1Mjk3OTQ2NzMyODA0ODcxODEyMjQwOTg0MTA2MDUyNzU0NTkyNTEzNjE5NjI2Nzc1MTgxOTY4OTkzNTU5OTU5OTMyMTA5MDU3MTY4NzYzMjEwMzg1MDg0NzYwNTQ5MzIyMzYwMzc1MTAzODk5NjU0ODUyMDU1NzMzMDAxNjA0NjAzMjY3MTk2MTg1NzYyMzA2NjI5Mjk2MjI2MDE3Mzg0MDk3MjMzMjEwODExMTUwNTk3MTIzMTAyMTQ0Mjg5NjAzNjc2MDk2NzEwNzA2MDMwOTk5MTM1NTU0NTU1NDYzMTAwMzY4MTU0NDYxMTczMTI0NTQ3NTk2OC8yNzQ1OTY1ODEyMTg4MjI2NjMyODc1Mjg4NjYwNTUyOTk2NDgwNDA3ODMxNjczNzY0ODAxMjE2Njg3NDQ5NjAxNTgwODYyMDI2NTQ3MTIwMzUxMjYwNjQ2MzIxOTI5NzA1OTU0NzQyODg1NTE5NTc4MjM4NDIzNjMzNzk5ODczODIzMzY2ODM5OTE3Mzc0NjY2MzI4OTg1MjQxNjY5NzkxNzM5NzY0NDIzNDQ0MTMwMDU3MDIxMjU1NTg3MDQwMTQyMDU3OTczNzk3MzcyMjE0NTY2MzI4NzEyNDE1MTA0OTY5MjI5MDQzMjc1NjIzMTM5MDg2NDE4NDQ5MTg5MTY5NzQ2OTg3NDYwMDM0NTk1ODk4OTQzMzEyNTk0MjMzNjc1NzA0OTYzOTc5NzIyNTMwOTMyNzAxOTI3NTY4OTA3NDYyNVwiLCBcIjEwMDM0MzkzNTU4Mzg4MzkwMDY1NzY2Nzk1MDA4MjEwNDU3MzY4NzEzMzY1NDkxNTY2Mzg3MjkyMTYzODE0OTE1NDM1OTA2NjQ5MjY4MTE5MDYwNTUwNTExMTQ1MDIzNDUwNzkwMzkzMzUzOTM3MTI0NDk1NDg4ODYwNDUxMTIzMzAyNDEyMjA0NDgzNTcwOTEzNTU3NzYyNDYwMzg1Mjk3NzcwNDI3OTQ2MjE5MTE5OTExOTIwNjQwMzA2OTE0NDUzMjA3MDk3MTAzODUzNzY2MDIzOTM0NjAyNTM0NTAyNDc2OTYyMTU5NjgyNzUwMjYyMTQzMzgwNTI3NTI5NTM2NDk4MjE1Mzg0NDY3OTc1MDIzLzI2Njc5MTk5MDI2MDMzMjI3NzE1ODYzNTgwNzc3NjA2MjE5NTU0NTU0NzA3ODE4NjU2MjQ4NDQ5ODQxNjk0NDM3MzkwNzU5NzY1NzIwNjE4Mjc3MDk1Mjg3MTAxMDg4NzcwMTU0ODkwNTAzNjk1ODkxMTc0OTE2MTEwNDU1MTgyMjEzNTQ3OTM0MTg4ODQ0NDc2MzIwNjM1Mzg5OTQwNDY3MTQ0MDEyMjk1MTA0OTc1OTk3ODM3MjYzNzY0OTAyNjAxNDA3MjMwMzIxMDI4ODM2MTczNDE5NzA5NTI2NjM5NDc2NDYwMTc0ODk0MzkxNzk5NTM0NTQ5NjQzNzQ4ODczODg2NTI3OTI0NDY5NzYwMDBcIiwgXCIyNDg1MjgxNDUyNjM4NDMzNzUzOTAzODYxNzI4MDAwNDg1MDkzODA5NjYxODMzODQ1Njc5ODMyNDIyMTM5NTkxMTM5Mjc2Njg0Mjk4MDIyMzcwNjc1MDU4OTA0MzY5NTc2OTM0OTU2MTYxMDcwODkzODQ3NDE1ODUyODM2MjAwOTc5ODI4NTkzNDUwODE3MzY3MzA4OTk5MTI1MTkyNzMyNjI5MzQ3ODU5OTIyMzU4NTI4NjY2Mzc4Nzg4MzE4Nzg0NDgzNDg0NDQ2MTE0MTI3NjQxNjEwNzg0NTgwNjg1NDk3MTk4MDA3MzMyMzcwMjQyODU1MjU4MTY3MjM0ODA4Njg3MDQ3NDI4MDQwNzcyNTUyNDI2ODIwNzcyOTE3MTMwOTI3OTAyNTA1MTE1Njc2MjE3MzUwMDQyMzc0NTA5NDYzMDQvNjU2NzY4NjU2NjkxNDg2MjQ4MDkzNDA4NzIxNTE5MDYwNDU3ODE0NDY5ODE2NjQ1NjExOTY2ODYyMTc1NTEzNTg0ODY4MDIyNzQ2OTgyMjg4MjU0MDQ2OTg5NTA5NzQ5Mzk1NDUwOTk3MjcyNDIyNTk1NDcxNDUzOTIzNTI2NTg2MzczMzM1NjIzNDU0Nzc5MzE5NTE4OTA5ODQyNzY3MTg2NzM2MTg3MzY1NjU5MjY2NjM1Mjg2MjU3OTY0MTI0MjA3NTM5NjEyMzE0MDQ2ODA4NzY1NTg2NTk3MzUyNTE0NjkzMjY3MDc1Njc0NzkwNzE4ODE5NjY4NzUzMzY5NTExMzM0NzUxMzU0Mjc2NDAyMTg5NzI3MjI5Mzk0Mjc4MjE4NDIxNzMyMTYyODIzOTAwNTgwNDA2MTg4OTY0ODQzNzVcIiwgXCI3ODA1NDQ4NzE4ODA1NjM1Njk2NDk1ODA5NDE0NTAxMjA2OTY0ODQzMjYyMTE0NDcwMTA5MTQ2MzQxMzA1NjU2MzE4MDE1MDU5NzQzMTI3MTE0MzI0MjQ1MDM1NDg5NTc3MTM0OTM4NTc5ODU2MDAzOTU2ODYxODgxMTI1ODU2NTk1OTgxNTAwNTkzNDI2ODQwOTY4MDg3NjE4MjQxNzg1OTMxMTI4OTc4NTE2MzQwODEyMDY2NTAyOTY0NTYxMjMxMjM1MDczMDEyNjcyMzU2NTMwNTA5NjYzMzg0NzM5MTMyNjg2NTQ4OTM0Mjg4NzAzMTc5NDc5MDExMDE2NzE5MDQ1NTMwODU1MDMzMjA1MjcxNTQ4LzIwNTA1MjUxNzgwMjQwMzk3NDQxMjY1OTI1MDUzNTIyMDIyMTY5MDU0OTE4MzMzNjAyNzI1NTMxNjk1MjA5MTUwMjA3MTU0NjQyMDYxNDE5NDIxNTEwODYxNzY1MDk0MjM0MDY0MTMzMTE1MjA4Mzg1NjgzMjQxMzQwNzc0MDI4NDEwMzAxMTM0MjczMDk3MjU4NzMzNDQ4MDYwMzA4MzYzMTQ1MDAyNjcxMDQwNzAxMzE0NTE3MjA5NDc1MzE5OTQ4MTQ3MTAxODkwMDAwNzY2NTE4OTU1MjAyMjI2NDY5NzQ1OTA0ODE0OTczODI4MzAzMjU0ODUxNzQ4OTkxNjkwOTMwNDkyOTk3NjQ4MTMyNzYzNzVcIiwgXCIzMzU1MzI1MDcxMjkzMTk3ODM5NDM0MTE5MTA1MDM5NjczMzI0MjY0NzY1ODA5NzcxMTkyODE1OTgyMjQ2MDQwNDE1NTgwMzg3NzI5MzgyNDA0NjI0NjEzODc1NjUzMDA1MjYxNTc4ODc3MDQ3NDA1MzY1MDMyMTc4NjE5NDUwOTYzNzMxNzE5Nzc3MTY3MDE1OTU5OTIwNjQ1MDU1NjAwNDM5OTg3MTYxODAwNTQ3OTAxNTM5MjY5MzIxMTAwNTU5MzkzMDQ4OTczMjU1Mzg4ODYwMTkzOTQ4Mjc0MjU1MzQwMzM1ODc2ODkwNDkxNzQ2OTAwOTkxNjY4MTY1NTY1NzI5MjY5Njk4MTk2MjMzODA1OTkxMjA2NjkxMTk2MDQ1MTgyMjE0NjQxOTM1NDgzMDgzNjYyMzU2NjY2OTk2OTIyMjQwLzg3NjQwMjU3OTExOTExNzU3OTU4MjU2OTgzOTc1NzQ2MjQ2MTA1MDg1NTE3NDM1MzEwODg1ODk1NDI4MjkxNTY0NDc5MDY1OTQyOTM0MTg1MzQwNDgyOTY2MTg5OTg1MDg0MTY0NTUyOTY0MDQ1NDc2NjE3MzIwOTg5NzUxMDk4ODA5MDMxODMwMzQ1NDU0MjU0NzUxOTg1MDQ3MzgwODc4OTIyMjU1Mjk2OTkzMzIyMjIwMzQyMDg0Nzg1OTE3MTI1MDMzMjM1MDA3NjUwOTk5NjI5NTg0NDIwMzk2NTU2NDQ0ODE1NDQ4NDU2NjQ5MzM5NTQwMzk2NzYyNjU5NjIxMzc5MjkyMjc4NDUwOTg5MjA4NjM2MTU3Mjk1NTE3NTY1NTk4NzMzNDg4MjAzMDc2NjAwMTc5OTg2NzY1OTgxNDExN1wiLCBcIjIxODg3MTA2MTk5MTA0NTg2ODM3Mjg2NjM4MTU0NTI2NzU4OTM2NTQxMDM1MDI5NDAyODEzODc3ODU3MjQ2NjIzNTQ4NjM5NzQ3ODAyODgyMzcyMDg0NjE5MTk5ODgyNTYyODE1NjcxNjE5MDQ2MzI2MzQ5MjMwNDYzOTg5MDY1OTI1NDI4MjQ0NTQ2NjgwNjIyNDk0MzQxMzQ0NjAwODY0NTA4NzE4NjMwNzk4NTM0MzU3NDgwNzM2MTk3MjIzODIzMDUyMDk3NTQzOTczNjE5OTI5MTAxOTU0NDU3NjQ0Mzc5MTkxNjMwMjgyNTE5MzY0Mzc3NDM2MDA1NTU0NTE4Njc4MzgxOTM2NzM3ODQ5MjYzMTgwNjI5Ny81Njg0OTU2MDcyNjQxNjg5NjQzMTU1Nzk0MDMxNDc2MDY4MDk2MjY1MzY1ODEyNzQ1ODAwMjIzMzc4MjAyODA0MTUzNzEyMTIxNjQ4Nzc5MDAwODA4NTg3Njk5NDAyMDgxMjQ5Mjk4NzczMzk4NzQxNDc0MzYwNDIzOTkzNTIyMzc4MzM0OTg3MDUxNjI4NDA0ODM2ODc2MTYxNzczNjEyNzg5MjE2MDg0OTA2NTg5NTIyMzI4ODAyMzUzMTkzMDQxMTcxODgwNzA2NTIwOTkwMzU5MzY2ODExNzA4NTUwNTQ4MjAwNzA2MTk2OTMzOTIzNzQwNDk0NTE4MDM3OTQ2MDA1MzE4MDU3MDQwNDg0NjA0MzEzNjAwMFwiLCBcIjUwMDg2ODUxMDgzNjUyMjY5MzE1ODI5Mzc5NjQ0NTE3MDA3NDY4NTM5ODYxNzA2MzM0MzM3Mjg0MDkxNzE5MDQ4MDM3OTUwMTgxNDYxNTI4MDQ2OTA3NTk1MzA5OTAxNDA1NTI0NjA1OTYwNzU1ODg0NjMzOTQyMDA1MTAwNDQ2MTc4MTYwODUyNzU2NjAwNzg1MDIxMjY1MDcyMDkzMDI5NTEyODY2MDY5NTMwMzk5NTM4NDM2ODU4MDA5NDE1NTgyMTI0NDA1MTk1NDI2MDIwOTI5MTk3NzYzNjYwNjc3MjA1ODYyOTUzOTA4ODYwNzAxMjA4MjgxOTk1NjI2NDMyMDg2Mzc5NzQzNDczOTA5Mzg3NzIwNzAwNDkzNDQ5OTEyNzI2MjExMDI2MjI5MzE1NzYzMzk5ODgxMDM2NzQwNzA4NzY1MTg5MTIvMTI5Mzg4ODUzOTY4MDM1NDI4MjU0MTI3NzY0Njk0NzM4MDYyNzI0MTk3OTk2NzYxMTg4MzM0MTgyMzM3ODMzMTY2Nzk3NjA0NTI4NzMxMTk4ODEwMzE2MzM4MDY1MTMzNDgyODAxMjg0MDMzMDcxMDc2MDc1NzI3MTg2MDIxOTU4NDM3MTEwOTQ3MjEzMjIxMTIxNTk1NzQwMjI1MTU5NDA1NTAwOTkzNzM5NzE4NDc2ODE4NDUxNzYyMTk3ODk0NzM4NDAyOTM3Njc2NjI5MDQ5ODEwMTcyODk3MTE0NTYzMzEzOTU0MTgyNzU0NDUzOTk4ODM0NDc3MjU3ODE4NDMxNjg0MzczNDI2NzkxNTY2NTczMDk4MTg1NzM3Njg3MjYyMjc4NzYyNzM3MDg1OTQxMTkwOTMzMDIyNzA4MDY5Nzk2NjM1MzM3NVwiLCBcIjE1Mzg4MzQwMTEzNTI1NzExNjYwMjI3NTY2NDQ2MTAxOTA5NTg1Nzk2NzQ2OTc5Mzk2MDkzNzc2OTYwOTg5ODY4NDU3MjExNjg0MDI4MTQ5NTAyNTc4MTE2NDU2Nzg1MjIxNzIwNjgyMjAyODE2MTQwOTExOTQ0NjYxMDUxMDAxNjc1MTI3MjYyNzc0ODI0NTkzNDIwODI1NTg3MzE5NDM2NTM3MzQ2MzExODMxMDAzMjEyNDI0NDk3NDg4NDg1MDk4NTQzNTEyMzE0MDYyMTEyOTQ4Nzc3NTcyMDM4NzMxODIzOTQ4MjI0NzM0NTA1OTMwNzQ4MzcxNTIyMzA5NDUxMTY4MDg4MDU3MTkwMTYyODc4MjI0ODAxMjMyLzM5NTQyMjA1ODI5NjA4MzE2OTEzNzc0MzUxNjA4OTA2NTYxNzM2NTQwNjM2MTE3Njg0Mjg0NTg4MDcyNzM3MDgwNDA1MTg3Njk1NDEyMTE3Mzc5Mjc5NzU4OTQ1ODQwMjQ0NDgxOTM4MzUxNjUxNjc4MDE5NzY0MjMyNzU3Njc1OTA1MDI1NTI5NjQ0MDc0OTQ1NDkwNDk3NzcwMDYzNDYxODk0MzY4MTcyMTUzMjk4OTE1MzA4MTE0NTE4MTE4NjQ1Nzk2NDQ4OTQ5ODc4NjQyNjczODkyOTA4NDg1OTgyODk3OTQ5NzczODI1MDQ4OTAyMTYyMTkzNjIwMzEzMjQ2MzU2MDkwNTMwNzUzMTM1NjgxMTUyMzQzNzVcIiwgXCI1MDk5MDM5MzMzOTg3NTYxMzc0MjIyMTkzNTUxMTU1MzIzNDcwNjc1NjE3OTc5ODE2OTQxNjQ2MTk2ODk1NTg5NDM5MzkxNjg1OTM4MDQ2ODY1MzkxMTE5NDg0NTEwMzI5NjM0MDE1Mjc1ODkzNTIwNzI1MTM1MTQxODc4NzUxMTUzMzYwMjY0MzY4MzUzNTk1MzQ4OTIxOTUxMjgwNTYxMDI5MDI4OTEyOTUzNTAwOTQ0ODE0NzcxMDY0NDA5NjExOTE3NDc1ODE4OTU2NjU5Nzc1MTMxNzUxMTIxMzEyMzE2MDg0NDY1MzIxOTE3NzY5Njc5ODgxMDUyMTQ0MzY0ODM0NDg1ODY2NDc3Mzc5NDM3NzA1OTEzOTExMzcxNDgxODI4MTQwODE3NzU5NDAxMTE3NzgwMTk5MjQ2MzAxNzA1NjAwMDIwNjcxMTA0LzEzMDM1MDM2MDAyOTc2NzkzNzExMzY5NDM0NTQwNjAzMTk5NTg2ODA1NTMyMjg4NzkwMzEzMjY2Nzk0NDkyNjM2ODIwNDg3MDMxMDM0NjQ4NzI5MTQ5NzI5MDAxMDU1Njk4MzUwMDQ4Nzg5NjM3MDE1OTk3NjUwMzA1OTAwOTc3Mzk2MzkwNDU4OTAwNjA1NDg3NjA2OTIxMjU1NDY3NTQyOTQ1MTQwNjgwNTI5MDI1NDMyMjAzODIxMDQ0ODM4MjI0MzgyODMwNDAwOTA0NDQ4Mjc5ODA5Mjc1NDQ0NDA5ODQ4MjM1MzUyNjAyNzc1OTU0NjYzMzk0MDM3OTU0MDMyMDA3MjA2MjI4NTIwNjkyNDQ3Njg5MTA2MDM4MjAwMDc2MzIzOTUxOTAyMDQ1Njk5Mjc2MTIzNDgxODkwODkxNjE1NTE5NTExMDY2MjVcIiwgXCI0OTAyODM3MTQxMzM0MDczMDI2MTQ1ODI3MDI3MzYxOTM3OTk2MjYxMzI0MzQ5NzIyNzI2ODY5MTE2MTg1MTU4Nzc3NDM5MzM3MDQxMjYzNDgyODUyMzc2MTk0OTg4MzcxODUzNDEzNDY3NTU5NTU3OTIzNDEwOTQ5ODk4MDQ4MTM5ODMwMTgzMzM1MTk3OTkyNzU0NzQ4Mjk0ODEwODM4MTg3MDY4MTI2ODY3NjExNjE1ODAwMzgzODM0OTc1NTYzMzEzMjIwNDk3NTczNzc4NDgwMTA5MjY0MTc4NjczMzg5MTQ5NjcxMTk0MTQ5NzQ5NzM1ODMzMzc4NTU3MTQzMTM1NDgxMzg3OTA0OTYxNTM3OTQyNTY5OTA0MDc1LzEyNDcwNDUzMTA1NDU5OTEyNjYyOTEyODU3MzAwMTY4NTMxMTg5ODEwOTk1MTY5MzUyNTE4NjExNDYwMzgzNjk5ODUxMDkyODgwODQ0MjA1MjgxNzEyMTc5NDIwNjU4MzIyOTI3MzkxMzAxNDU3ODA4MzM0MDYwMTQ2NzM2ODkxMTk1NjM2OTg1MjgyMjUwNDg4MDA3OTQ3MTg3ODkyMTgyNjc2Mjg1MDc3MTM2MjEyMzUwNTY1MzgyMDIwNzAxNzE1OTYxNzc3NzUwOTUwNzE1MTMxOTQ4ODU1Njg4NDMzNzU1MjY4MDQ3OTYwMTYyNjExNzMzODg0NTIxODQ1MDU1MDMzNDExMzIyMzY3MTk0ODQ4MDk3MTQzMzU3NDRcIiwgXCIzODExNDc0MzUyMjcxNjgzMjEwNzkxNzQ2NjQzODI1NzYxNjcyMDQ3NjQ4ODgxMjUzODMxNjEwMTY1ODEzOTYzMjg2Nzc4ODQ2NDM4MTg2MjI5MTI0MDcyNzMwOTYxMTQ2MDE4NzE1OTkzMDY1MjE4NjQ4NjA5NjMwMDg2MjM4ODU5MTUyMTYyNTA5MzIzNzAxOTY2MjI3Mzc2NDM4NzU5MTQ5NDA3NDc5MjU3NDkyOTQ5MDM4MTkxMDQ0NjI4Nzk0Nzk5NDE1MDY1NTA3Nzg3NzIwNDQ0Njg2NDAwNDA2Nzk1NjA4Nzk3NTAxMjc3Mzk4ODgzMzMzOTUyMTc3NTQ2Mzk3NzIzMzA2ODQ5ODQwNDE0NDIyMTA0NTgzNzE5MDM5MjY3MDMwODQzNzM5MTY4NjA4MTQxODMxODYyNDc0NTAzOTQwMjE0NTQzOTIyMzU1Mi85NjQ3MDAxMDgzMzgzOTk5NDUzNjY4MTExODA5Nzc1NDUxMDc4OTc2MDQ2NDg4NzQ2OTE2MDcwOTc2MjE4NjQ1NDMxOTQ2NjQ4MDg3MTcxNTg2MjUyMTcyOTM2NjAwMTE1MDMyMzE2MzgzNDI3MjY1MjE3OTkzMTkzNDQ0MTk5ODYzMTM4NDI5NjAyMTM4ODQxOTc2NTg2MTkwNTI1NDUxMzI0MDkzNzcyMDk3MjQxMzQ5NDE3OTM4NTc4ODc4OTM0NTc3MDkxNjcxMDQ2MDUwMzI2MDg3ODk4MjU5NjkyOTE3OTMxMjMwOTc0MTc0Nzk5ODE1MTk4NDkzMjc5NDEzNDM4MTkyMzAxNDM3MDY4ODIwMTg1NzU3ODY5NjA4NTIzNzYxNDU2MTYwMzQxNzU0NTEyMzI5MjY0NDQyMTE1MzUxOTI2OTY3MTIwNDA0MTI1XCIsIFwiNTczNjk1MDU1MjI1MjI1NzI3MDA4ODAzNzMwNzY3NTE4OTA2NDkwNzA0OTk1OTI5MTc3NjE3NjQ2Mjc1NjQ2ODg0NTU1NzA3OTYwOTg2NjI1NDgxOTQ0MTAxNjIyNzA4NDE1NDE1OTg4ODQ0NzQwMDI4NzE4MDI3NTU0NDUyNjYyMzU4OTU3OTMzNTI2MTczODI0MzI1OTU1OTA0MDA1NDA0MTEzNjg0MDAzODQxOTkwMTk4MTU3MDcyNTQwNjU5MTg0OTk1NzM4NzE5MDQwMDI0NjQ3MzcwODY5MDEwNDczMjU0MDcxNjgxNTMzODgwNTc2NDYyMzY4NjAwOTAxODI0NjIyNDMxMDQ1NTI5MDY0NjUxNjc1NjQwMDU1OTE3MDkyLzE0NDUwOTQ4MjUxMTExODgxNjM5OTA4OTA5NjAyMTI5MDU4NzQ4OTU5NDU0MTI4MDM5ODg3MTI1NTg3NjU2MzYxNTQ2NDYyODcxODUyNzYzNDY3OTMzMDI5MTc0MTQ3OTEzNTQxNTE2ODUzOTc2NTg4NzI5MTc4OTYxNTc5MDUxMzUyNzMzMDYwMDM5NDkzNzYxNDQzMzUwMjM0MTExNjA2ODMwNTM0NzQ2ODEzMzk1MDIwNDE1MjE3NDA5NDcwNDA5MjQwMjk3ODA4MzM3MDc5MjEzNTQzMjQ4NjI0MDkxNDk1MzkyODE4ODgzNTgxOTc2Nzc1NTE3MjY2NjY5MzIxOTIxMzg2ODU0NTg1NDM3MTEwMzEyMDYwNDk0NjIwMDg3NVwiLCBcIjIzODc2OTYwMzI5NjUzNTg5NjQ3OTI1MTI2MTgwOTAzMzkxNjg3NjY2Mzc4MjMzMjAxNzk0NDAzMzM5NjMwOTk1NDIwMjE1MjY3NDE1NTc1MTQyMjY2NzA3MzU3MjU1NzI2MzMwNTM2MDk0NDQ4MzE0MTk5NjAyNjE2MDI2OTM1MjUxMTI2NDY5MjIxOTI1OTQ1OTYwOTAxNzQ4Njc5OTE5NDM1OTA4NTU2NTUwMjcxNTA0NzY3Nzg0NTUzNDg0NDM0MzYzNjQ2NDg5MTc0NTg3NDYzNDY2MzMzODY0NTc3NzA1NzQ1NDUyNDkyMzk1Nzg1NTU3NDI1OTA0NzM1MDQ4MTgwMTY0Njk3MDQwMzEzNTI4ODMxMTczNDQ4MDI1NDAwNjM0NjI5MTYzNzk1MjIzNzM5MDYxNjYxNDYxOTg2OTIzNjc1ODMzODgwMzc4NDk2LzU5ODYzMTI0MDg1OTQzMDY5NTQwMTM1MjYxOTc0NjU2MDg1NTkwNjg2MjEyNDg4OTYzMjA2NTI1MTIyMjgyMzgxMTU1ODk4NzU1MTQ2MDQ2MzIyMzAwOTg5OTc2MDk0ODIyNDgwMDA4ODg1NjcxMzU2ODUxNjcxMzg3NjIxNzI0NzU3ODgwNjAyODQyMzI0NTk4MTM5OTgyMDE3MTk1OTAyMDg3NDIwOTE2OTcyOTQ1NjI1MzgyNjU4Mjk5NTQxODYxNDkxNjI5NzQ5NzI0NzE1MzMyMDI4ODAzNjgzMTcyMzc1MDg5ODc0NzcwNjk4NzI0MzEwNjQwNzUwMDUzMDU4Mzg4MDE4NjI5MDA1MDE4MTk5NjM3OTMwNjIwNDEwODE2MDE4NDQ3NTk0NTIyMDIyODI1NDU4NDA3MTY5MjA3OTMwNTY0ODgwMzcxMDkzNzVcIiwgXCI1ODE2ODI4OTkxNzU2NzcyMzE3MTIyNjk5MjM4MzU1OTg2NjIxNDA5NDE1Nzg5NDk5MjMyNzU1NTQ5NTQ0MTY5ODAyODg2NzcyNzg0NTc2NjQ4ODEyMTkwMDYyNjkxMjg0ODY5ODk1Mjg2MzQzODY1NDg5NTI1MjgxMTU4MzE0NDQ3OTMwMDM4Mjc2MTEyOTQzMzkxMTI4MDA0OTAwOTM2MjY2NzM4MDAwMTQwNjU3OTE3NTU2Mzc0NTgyNDM2ODYxMzMxOTEwMzY3MzgxNzA5NDQ5ODExNzk0NDg1NjAwNDQxNTgxMjg3NzIxMzcyMjQ1NTI5OTQ5MTE0NTY0OTg3OTY3Njc4NzA3OTc0NDQxMDc2NTA1Mzg0NTU1MTk1ODc1NjcwMS8xNDUxNzA2NzI4OTM0NzkwMzY1NTUwMDAyMDE2MDY3MTExMzQ1MDM0OTc0MzY1MDYzNjk1MzcyNjI1MTE5MTY5MjA3NDM4NTUyMTk3NTEzMjI2ODMxMzI2MzcyMzgzMTgwNDE1MDg3MjIzODE3MzYwMjg0NzA2NTQyMzQ2MzEzMTkxNzM3MzM1Njc5ODc1MDEwMDMxMzE0NTIyODYwODg5NDg4MTQ1NzEwNzY4OTQ5OTk1NjkwMzA0Njk4NDQ0MzU0NTc4OTA1MzQzODk0NjA1MDk3NDU2NzY2NTA0OTIzNzQxNDU4ODQzNTc5NjM4MTY3NDU5MDA5ODYyOTc3OTM4NDM1NTI3NTgyMDc4MjUzMjQ3OTcwODgwNzUxMjk4MTUwNDAwMFwiLCBcIjcyODYyMTg5MDU2ODI4MTg1OTI5NTQwOTQ4MTQyMjQ0NzAxMjUyODMwMjU5NDM2NTY5MzQxMDc2MzgyMTcwNzA3NDQ0NDc5OTc5MzY5MDczODEzNzU5MjEwMTIzOTg2MjczNjMxMzM0NzI3MzE2NzQ1MDA1NjYyNTkyOTU5MTk2MDYxMDIwODMzNTI5MDg4MjA0NzQxMzAxMTU3MTc4MTE2MTAwODI5NjA4NDYzMDA3MjgyOTA3OTc4MzMyODkzNzQxODY0MTQxNzY0Mjg1NzE5NjM0NjAyNjM2NjM3MDA1OTUyMjk5MDgxMzUzNzczMTM5NDgyMzYzMDIwNzQzMzI2Nzg1NDYxNjc2ODY1ODk5MDI4OTQ1NDYzNTc5MzMyNjc2NjY5Nzg4NDc5ODUzODU3NjA1NTk0OTQ1NzEyMjA2NzgyODE1MzY1NTQxNjY4ODY0MC8xODEwMzA3MzA3NTk1MTY5OTE4NjM3MDg1OTM3NDc5NjQ3ODc4NzQwNzMzNTQwNTE2NzU1OTcwNTAzOTkwODc2MTIxNDI1Mzk1MTczMDg3MjA2MDM2ODczMjI5MjQ0MjY1OTE4ODkxNzk3MjY0OTI0MDM5MTMzNTY0NjE5MDg3NDg3MzM5NzI3MDc0NjAwNjMwMTcwNTc4MDkwNjAxOTA0Mzc5MTc4NTE3OTA3Njc5Njg4NzcyMTU3OTU2Nzk4NDQ5ODMyODg5MzUwNzU2ODgyMTkyMzQ4ODUzNjA4Mzk5ODQ2ODE2MTkwODQ4MzQyMjgyMjY3NDQxNjU2MTAwNzM2ODU3MTkwMTc1OTY2MzAzMDI0NjIwNzAxODg5Mzc5OTg1NTgzMTI1MDc2Mzg0MzQzMjkyOTkwMTc1ODQzMjk0Nzk1MTY0MTA5MDc3ODY2ODEwOTNcIiwgXCI4Njg1NTk0NjkyMzQzODMyMjIxODYyMjQ3MDA2NzIyNDY5MTg2MDgwODI3Mzg4NjE4NDk5NzA2NTY2MzU1NDg0MTU3Mzk4Mjk2Mzk5NTM0MDk3NzA4MzA0OTEzMjUxODgxMjkyMzMyOTQyMzQ4MDM5MzMwNjkxODg1NjY1MDU3NzA3MjUyNTYzMzkyMDQ1NjcyMTI2NTk1MzU3NTQyNDIzMzcwMTkyOTg5MjAxOTQxMDA5OTE2NjMyMjUxMTQxMzE0Njg5MTEyMTI0ODM4MTY0ODE0NTM5MTY0MjU3MTYzODg1NzU3Njg5MDU2ODg4MjUxMjEyOTk2MDI5MTE3MTg2Njc3MjY2NTg2MzE1OTQ3NDYwMjYwNDY0NzI4OTA1MjA3OTk5MTc2OC8yMTQ4NTc1MzUwNzM2NTkwMTk0NzUyODU4ODg5NjQwMjI2NDY3MDc4MTMxMDg3ODU0NzcyNjEwNDQ4Mjc0MDY0NzU1NDczODE1MTEwMDk1NDgzNTc4NDExNTExOTAzNTk4MDUyMzUyOTY3NzA4MzUwNDQ5NTgzOTczMDQ5OTY2NDA1Mjg4MjQwMDkxNTIwODI1MTU5NDM4NDAzODgxMDkxNzI4MjIwNzQ0OTg2MDg3NjI1MTU1ODMwNzI4ODcwMDIwMDkxMDc0NzMzODc1ODcyMzMyNDY4NjkzOTM3OTEzODIwNjExNzYzNDU0Njk4MTE2MzM1NTA2MDc0MDI3MDczNDE0Njc4MDk0MjY5NjI5MTY2OTQ2MTE4MjU5OTUxMjMyMDA5OTYyNVwiLCBcIjIxNTg5ODkxNTIzMDEwMjI5MzgxNDg2ODAxMDIxNDIxODg1MzE0NDg4MjEzNTk1MDUxODgwNTUyNjQ2NjUxNjczMTM0MTg2MTk2NjU2OTMwOTIzMzc2NjU1NzMxNTAzNzQyMzE0ODQ4NDA5NDg0NDc2MzcyOTcyNDcyNzc1NzY0MTU0NjA4ODkyOTY3MjQ4MTM5NDAxMjg5NTUwNzAyNDAxMzc1OTAwNzMyMzMyNjMxNjg4MzU2Nzg3MTQxMzEwNjI3NjQyNDc0MzQxNDQ5OTQ3Mzc2MTAyMjk5MDk5NjQ4NDc1Njg0OTE0NDY2MDYwMTI1ODEzNzA4NDA2OTk1ODIwNTUzNDE2MjYyNjY1MzM3MzM3NDQyOTM5Mjk2NTg5NDk2OTc4MDU4NTUzNjIxMTQyMjk2NjY2MjY2MjA3NjYyNDU2MzAxMjIzMzM3MzM3MDM2MTgxNzYvNTMxNzk0OTE1NDA1MTY0MDA1NjEzNzMzNDU0NTk3OTMxNDgyODc4NDc5ODgyNzA0OTU2MTEwNjg1MjIzODkyMzI1MDc0MjExNjk0ODM3ODM2MjIxNzU5OTk1OTQ4NjEwMjEyODE4NjQyNzg5MTMyNzQ5MDgyNDMwMDU5NTkzNjUyODU0NjU5MTMwMjE3MjI1NTA2OTQyNjc1NjA4NjkyNzAxNDQ3NzM4NzMyMDMxMzAyOTg3ODAyMTk2NTAxODk1ODQwNTEwMjM1MTYxODI1NTAxMjM1MTMzNzk0NDQ5NDIxOTE5OTI3Mzk2MTQyNDcwMTk2OTYxODc3Mzc2NzAxOTU3ODI5OTIxMTUyODQ4MTc4MDc2NDEwMTQxODEzOTI2OTI0NzQ5MDU3MzA0MjIyMjgyNjg3Njk3Mjk3MjE2NjYxNjg3NTgzMjU3OTAxNDE1NDY1MTI1XCIsIFwiMTM5NDMyNTQ4NTc0Mzk2ODI5MDc0NTg2NzA0Mzg3NjU2Njk3MDk3NzYwMDU3ODk3NjI4OTk0NTQ4MzU4NjE5ODE1MDUyOTM2NDgxNjUwMzk2MTU3NDI4NzQ3NDExMTczNTY3ODAxMDQ3MjIxOTI4NTkzMjUzNDc5MzMwNDgwNDU0NDY5MzU4MjIwNjg1ODU0MzUxMjM2OTgwMzgzOTE0MjIzNjkzNzIyODY4MjMzODE5NDgzMTM3NDAxMzM5ODAwMzA0OTQzODkxOTY4MDUwMzk5MzQ1NDMwMjQzNzkwODk4OTU1NDE2OTA3MjI4OTQ4Mjg3MzY3MzU2OTkwMjYzNzQwMjA3MDQ2OTAyMjA5NTYzNDE3MjY3Njg2NTkxOTk0NzQzNTQ3NjIxLzM0MjAxMTUxNjg4Nzc1MjE0MDcxOTYzMjA2NzY1NDM2MDgzNDQ1OTAxNjIxNDQyMDAyMDYxNzA3NDkyMDgyODQzMjMyMjMxNzU0ODI5MjI3MzAzNTM5MDQxMjg2MzAxMzk4NjY4NDM3MjAyNTQ3MDAzMzAwMzk2MTYyNzQxMzc1NDM1NzAzMTg4NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsIFwiMTEwMDg1MTcxNzQ4NzI4MzMyODYxNTA5ODUxODAzMjI1ODQ0NDgxNjI4ODQ4MzIwOTkzNDQ5Njk2MDkyOTEwNzA4NDQxOTM1MjQ4MTY4NTI5MjA5NDIzODM4NTA1ODAyMTc0NDMyMDk0MDI4MzYxMDA0Njc5NDA2NTE1ODEwOTIzNTA2MDAzMjkxNDU2Mjc5Njc1MTU4MTg2ODQ0NDIxNzE1NzExNTY0NDYzMjEyMjg1OTY5MTQzNTU3MDQyMDU2MjM4NTc4NzE0OTczMTU5NTUyNjkyNjY0OTgyMjk4MjMyNzg4MDA3MTc5MDkzMjEyNjkxNzk4MzkwODQ0NTIzODQ1MDkxNDI3MTI2NzcyMzU1NTIxMDM0NTk3Mzc3OTA2NzQxMDM5OTQ0NDUxNzMwNzQ2NzAzNDcwODA1MDY2OTgxNjg0ODI1NjQwMDk0NjUyNzYxNjU4MjQ3NjgvMjY4OTIyMzM5NjkzNjA4MDg1Njg1NTI5OTIxNTY1OTIwNDE2MTk0NjcwNDIwNTkzMTg4NTEyNTE0ODIwMTY0MzA4NzE3NjU1NjgyMjU0Mjg5NTMyNTE5MTQ3ODI4MzcwNjU4NTQwMDIzNzkwMTIxNTQ4NTE1MDkyODAzNjg5NTQyODcyMTkxMjExODQ2Nzc2MDc2NjUwODE2MjYzMTkwMzU4NTEyNjM3NzY3NjQxMjU3MzE4NzkxMjQ0Mzg3ODIzMjUyMTQ0NDc4NjA5MDUxMDg5MTU5OTE3MTc0MTc3MzI0MjAxMTAxNzkyNjY1ODIzMTYzODAyMjk0MzAxODQ2MTA4NjUxNzUwMjU4NDg1NDM5MDgzNjM0Nzc4MTY3NDYyNjYxNTcwOTc1MTM4NjQ1NTI5MjAyNjc3NTY2MzU0NTQ3MDc5NDE2NzYyOTE0NDQ1NjI2ODc1MDEyNVwiLCBcIjE2MTA4NjM4MDc0MjExMjYwNTg4ODAwNTM3NTQwNjgwNzA3NjQxOTg2MDczOTE0MjUxNDI0ODc4MTIxMjU1MjM0NjY4NTU4MDY3OTg4MTcxNTY4OTQ2MDc5ODQ4ODYwMzM1OTQ4OTkxODM0NTI1NTUyNTE1NjY5MDQwMTYzMDI2MTMxOTE5ODA0OTg3MzQwMTEzMjQ0NzYwNzM4ODQ2ODg0OTExMDM4MDk3OTA3NzU2MjIwOTQ1ODgzNzUwNTAyNjczODk5MDg0ODgwNTc4MjI5NjAxODcwODgyNjMxMTY1NTEwMzk2Nzc1MTI2ODUwMzA3ODM4NTA1MDYzOTIyMTAxNjgyMzMzODA2Mjg0NjY4NzYyODI1NjA5NTU2MDQ5NDI2ODI5NTMxNzgwLzM5MTkzNjM5NjEzNDQyNjE3NzcxMDA2NTgzMTgxMzc4ODQyOTk1NzUxOTMwODk0NjI5NDQ1NTQyODIyMTgyNzg0OTYyOTg2MTA4Mjg3NTc2NTAxMDQ5MjI1ODMzNTk2NDIzODQyNTMwNjY4OTY1MzgyMDM1OTYwNTczMDIyMDM2MzUxMzQ4MzM1NDU1ODA4Njk4NzEzMzM4OTI5MzUzMzA5NTA1ODM2NjQ0MDA1NTU0NjM1NTc3MzU3MjMzNjQ0OTc5NDc5ODY4ODUxNDYwNDMwMTcwMTAxNTkzNDcwNDYzODk2MDQxNzIxODY3ODg5MDI2MDgyMTY4OTQwOTQyODk3Njk4NTA1MTcwOTgwMjc0ODY0NjgwODQ0MDc2MTg3NDg4OTU2MjY4NTNcIiwgXCIzNDQyMDc1NTg0OTE4MDI3OTU5NzMwMjEwMzcyNjE4MDExMDAyMjY0MDk0NjY5MjU5MjU0MDYzNDM1MzczNDE1NzQ3OTUwNTQyMDMyMDAwMDMyNDI2MDUzMDc2NzE4NjEzMjI2MDk3MDU3MjQ1MDQ4OTUzMDAzNDQ0MDIxNDI1OTU1OTMyNTExNDUxMTI2NTA3NTQxNjUxMjMxNjIyOTE3Nzk1MjE0MDIxNzczMjY1NTQwNTI4OTgwODMyNjM0MTY5Njk4Njc1NTE0MTk2NTA0MzcxOTM0NDE2OTY4NTYxMTIxNzk1ODYxOTEwMjc3NDYxNzIyNDg0NzI4NDEyMjkwMTAyMzc3NDk1Njg4NzY4NzAyNjkwNDc2NzcxNDk1ODA5MDI1NjI4Mjg5MzAwMzAwMDc1Mjk0NzQyNzg1NzcwMzI1OTcwNDY4MjQ1NTM3NTQ0MjczNTg1NzAyNC84MzQyMDMwMzExNzE2Njc5ODI2ODg5OTE3NDk0OTU3NTkzMTY1NDY0NzQ4ODg0NTcyMjk4MTczNTU2MjU3NjUyMzg5ODQ1Mjk0NTMwMzI1NzY0ODM3MTI0OTk4MjkzMzk4NDQ1ODA0NDU4NjEzOTU2NDg5MDk2MDA3NTY0ODExMTAxMzYxMjY2MTk2NTQyMTI5NzY0Mjg3MDg0ODIzNjA0ODk3MTg3MzExNTQwNTYxODU3NzQxMjg1NzkzNDQ3MTc0MTE5NjY3MjE1ODAzODM3NzE5NjYwNjc1Mjk4MzA4ODczNDk2MjE5Mzg1MjI2OTk4MDc4NjQ4NDI4MzY4MDYxODY4OTQ0MzIyNDc4Mzg0Njg0NTA5NDY2OTY1MTI5OTcyMDMwOTMyNDE4OTIwNDE1MzA4Mjc2NDMwMzU1ODgyMzI5NDU3MzQyOTM3NTQ5MTYyMDAwMjUyNjI1XCIsIFwiMzQ1ODg4MDc1MjYxMDIwMDA0MDcxMjIwODQzNzE0MDYwMzUzNzYzMzgyMjgwNjY0OTYwOTI5OTAzNTQ0OTY0MTE4ODMxMjM3ODc2Njk0Mzg0MDUzOTA0NTcxNDk4ODMwMDY4ODMxMDI2NjQ0MzAzNzk3Mzc3NzYyMzQ1NzA5OTc2NTk1MzYwNDIxNTAyNTk0NjU2MzA4OTM3NjQ5MjM5OTc4NTI1NzEzNDcxMzkzNTcwNTM2NjgwNDEyODE0ODA1MDc2MzIzNDI2MjU2NTg0NTA0MjUxNzI4NTA3NDE2MzY4NjA5NDIwODgyNDQyMjkzODMxNjg0NjgxMDcxNTUzNzY2NjAzNDc4NDc5MDA2NDk1NzU3MjIyOTEyNTAwMDEyNDQ0Nzg3ODA0NTc3ODExLzgzNTA1NzAzNzMxNDY5NzM0NjI4OTYxMzk1MDYzNDgxODkzODAxOTM4MzcxNTE2NzUyNDE3NzU5MTMxNzc0NTMwNzIwMDc1MjYyNDU5MTU4Mzg0NDMzNzg1MDA2Njg5NTQ4NDM0NzAxOTA0MTA2MzEyMDM4ODIyOTY5NjU4NDU1MzY0MjE5NDM1MDIyODQxNTk3MjQzMTc4NzU3NDIzNTk4MjQ4NTY1NDYzOTg1Nzg2MjEzMTU2NTU2NTIzNjg1NjY2NDMwNzk5MjgzODcwNTQ4MjM4NDY3ODE3MjI2OTE1NjgwNzQ3NDEyMTkxMjQ1MDQ2NjM0Mjc5NzY2NDUwNjI5ODg2OTA0NzE2Nzc2NzE5MjE5Njk4OTIyMDg4MjExMTU0MTg3ODQ1NjMyMDAwXCIsIFwiMTA2MTcxNzgzMDYxOTE3NzUyNzA4MjI5NjcyMzA5OTg5MDM5MjI3Mzg5NjM4NjYxMzk5NzAwNDg3NDY2OTA1MzQ0NTk0MzI1MjA0Njc0ODI1MTg4MzUzMjYzNDUyOTc1OTE2OTUwMDc5NTQ1MjU3NjM5MjcwMDQ3Mjc3MTM2NTI0MDk5Njg0MjYxMDIwNzI3NDEyODEwMjMyOTA5NjYxOTAyODQ4NzM2OTYyMjAwMTczNzEyODQ2MzYzMTAxNjQ5NDM3MTYzNTY4Nzg0MTczMzY0NDMzOTYzNjE2NDU3MDgxOTQzMTU3MzgyOTE3MzUzMzk0MTA1NjI1ODc0NDQ0MjkzMDY0MzczNTU4Nzc4MDkwNzMxMDQzMzM3MTQ1Mzk5MjA2MjY0NzczNzI1OTU4NzU2MzM5ODExMTY4ODY1OTY1NzQwNjA4OTAwMzI5MzU3Njk2MTQ3NTg0ODcwNC8yNTUzNTk2MzE1MzcyMTU3NDc5Nzk4OTU5NTU4MDY5OTUzNTI3OTk1NzQ3OTAzNDAyMTgzOTkzNTExNjgxNzg1NTU0NzgwNzM5OTc4NzYxMTA4ODk0ODM0NTY5NzI2ODc0Mzg3MDIyNjIwMTc4MDAxNjcwNDgyNDM3NTQxNDE3MjI0OTYyNzY1Mzc2ODU4NTMzMTE0MzQwNjk5OTEyMjIzMjQwMzkwMDUxNjAwNTc3MjQwNzMxNTY5NTc1MzAxMDY2MjM5MDg2OTYyNDEyNjgyNjgwOTY4Nzk1Njk3OTQ0MzE5MTk3Mjk2MjAxNzgzNzUyMTI5MDUyMDM0ODQxNjU3NDU4NjY5MTM3NzMzMDQzMTkwNjkzMjE0MjYyNDU1MjE0NjcxMjI0NzIwNDYzNzAzNTY3MjU1MzA5MTQ1ODc4MDcyNzQwNzQyOTM2NzMwMzg0ODI2NjYwMTU2MjVcIiwgXCIyNzQxMjI5NDQxMDYzMDAyOTY3MzgzOTk2MzI2ODQ5NTU0MDA3NjE0OTU4MzAzNjE2NjM5NjY0NjYyMjU2NTI5MTg2ODMwOTk3Nzk0NjU0MzgwMjQ4NDY5MDMyODY4MTY4MTM4NTY0OTA4ODg3OTYzNzIxMzQ1NTcyOTU2OTk5ODA1MjgxODc3Nzk2MjQ4NjUwOTg0NDU3NTYwMTM1NjM1MzUzMzkwNTYyMzM5MTIzOTQ5MDg1NDQxODU4ODU1NDc4NDIyMzUwOTc2Nzc3NjUzMjUzOTYyNTU2NDkyMDczMTcwMTg3NTQ5Njc2NjY0NTA3MDgyNDkxMjUzMTYxOTIyMDAxNTE1MDU1Njg0MTY0OTUyNzQ2NzE2Nzk1MDA1OTQ2NTY2NzE3ODUyMDI0OTYvNjU2ODc1OTI2MjE5NzY1NDYyNTA1ODE1NjAxMDIyMDE1MzU1MzM2MDgxNTgyNTY5NTMwODc3NDU4NTY5MDY0Mzc0MDAxNDkyMDU2OTM0MjcyODUxNjIzMzM1MDI1Mjg3OTM2NzU1ODUwMjIwMjU2MDIxNDQyNDM1NDMwNjQxODU2NDc3OTI5NDg0OTUzNzI0NDI2MzAzMzM4MDAxMjYyNjkxMjM1MzE2MzY4MDAyMTM0MDUyNTQwNDUyNjIxMjc1OTM3NTk1Mzk3MDY3NTAyNDI0MzAxNTM0NTY4OTE3OTI1MzMyNjc5NDgyMzExODUyOTYwOTEyOTc5Nzk5MzM1NjI3MjcxMTI0ODcwNTcyMzQ0MjIwMDk0MjY4Njg1MzE2NTE2MzQ3MDYyNjIxMjVcIiwgXCI3ODQyNjgwNDgwNzE2NTE2ODAzMTQ4ODIxMTk4Njk3OTY3MjM3MTM2NzIxODYwMDE3MTMxMjQ0MjY2OTc0OTk2MjY3MDc0NzQyMjQ4NTk5MDg1MjUzNTY5NjM3MTgzMDA3NzQwNTY2OTQxMTI1NDUyMjE1ODM0NjQyNjgzMDUzMzM0NjA3ODk2NzIzNDQ3MTQwODUxMzQ0NTAxMDg0MTIyOTY1MDE0MjQyMDkxMzEyNDExODg0OTg1NTY5MzQxMTY2NTQ1MDc0Njg4NzU2NDQwNzI4OTIyNDA4NzQzODQxNTkyNjU4Njc3NzkyNzk2ODgxMTg4NjA0NzczNDY5MTA4ODA3ODY5OTYwMTYxMzk1NzU5ODM3NDA3OTc4NTk2Njc5OTExMDY2NTg2NjI2ODg1ODMwOTkxNTU2MDkwOTc4MzI3NTA4NDU5Mjc2MDI1OTQzMjc5MDY0OTY1Njg4OTYwLzE4NzI1Mjg2MTIyNDU2NDg2NzU3MjAzODIxMzgwNDUwNzExMzEzMDQ2NTIwNTA2OTY4NDI4NzI1MjkxNjM3MjA1NTgxMjY2NTUwNzU5Mzc4NDU1Mzk3OTIxMDgwNDgzMTAyMTkzOTU3NDYyNTk1NzA1MDYxNzU5MDIyMDYyMTUxMDE1MTg2OTg0OTAxNDQ3MTY1MzE2OTc2ODk1MzQ1NTk4Mjc0MjI3MzU2NDk4ODEzODE1OTc3NjE2ODQxNTQ0MDk3OTYzMTU0NTU0NDU0NTk1Mzc1MTUzMDgxNzQ5MTk0ODg0OTcxNTQ0MDk2NDM4NzY0OTA0NzIyMTUzNTIwNTY1MDIxOTMxNTAxMjU2NDQyODgwODYyOTQ0MTgyNTMzMDk5NDcyMjkxNTEwNzQ0NjQ5Mjg4NzQ4ODE4MjcyMjc3MDY5OTI4NTk2NDAyMzYwODY0MTc4ODk5OTA1NDE4ODlcIiwgXCI1MzAwODI0NDIyMjUxMjQyMDcwMDc0NTY5MTg2ODI1OTI5MTE5ODQ4MTExNzIzMDEyODQxNjI3Mjc1ODMwMjE2MzAxMTg4MjI4NjYwNzc5MDA4MzUzMDQ5NjAzNTI3NTY3Nzg0MTE5ODc3NzA2OTg0NzIyMTcxMTc4MTM3MjcyOTg2MzQ1NTYwNDg1Nzg0OTA3MzQ1NTAwODkzNjQ4NzE1MzQxMjczODQxMTQ3MzIwMjg4ODUxMDM0MDc4ODYzODQzMzc0NjY1ODUwODUyNDgxNzQ3MDAwMjM3ODM0MjM4NzAzMjQ4NjM0MTc0Mzk3NzkyNzQ1OTE0ODQ3Nzc0Mjk3MjIzMTc2Njc0OTE3OTEyNDA2NjU5ODMxMjA2ODY5NDQyNTEwOTQ4OTY1NTcxNjYxLzEyNjExNDA0NzYwMTM3MDczMzg0Nzc2MDQ2Nzc0Mjg1NzM4MzE3OTEzOTYzNTI4MTQ4MDIxNDk5OTQ2NDA2MTc3MDE3NzMwNzgxNzQ4ODI0NTU1MTI2NjgwODkwNzI0NDExNzY4NTc4OTIzMzE0Njg2OTExNjA5OTEzMTA0NzQ3MzQxNDM4NDIzMzYwOTI2MzY4NDg0OTIwNjY1OTIzOTc4OTI2MzgwNTIyMTIyNTAyMjkxMjkzNTUwMDk5MzkxMTg0MzE2NDM0MjU4MzY5NDQyODI0NTY2NDc1NzE1NTgzODM3NTUzMTUyMzg1MDA4MzI4Njg1MzU4MTYxNDQyODAwODg2NDQ5Mzk2OTYzMzkxNjAwOTI5NjM2MjkwMTIwMDE5NTgyMDUwNjMxNjgwMDBcIiwgXCIyMjIwMjIzNzE4NzYyMjE1NTg0NjU5MzA5MDU5ODgwMTA2MzM0NDI1NTE1ODc1NjE1MTA3MzY5Mzk5NzY3ODkyMDUxNTUxNjM0MDAwNjE0MzI3MjcyMjYwMDgxMDU2OTczODYzNjY5MDA0MjI0OTgxNTYxODcwMjQ2MDc4MTIwODYyMjU2MzgzNTgxMDEyMTgzODUyMjkxNDQ0NDYyNzMwMDE4NTQ2NzUzMTgzMTU2OTgyODk3Mzg2NTYzNTYxNDE4NDI0MDkzODgzMTY0MDI3MzA1MjU0MTc2ODc0NjUzNzgwNDI1NDUyOTg3MDY2NTEyNTYzMTQwNTMxMzY3NzY2OTAwNjEwNDE0Mjc3ODI1MjYyMjM5MTk5NTgwOTI1ODc5NDUzODA2NDE0ODYwNDA5NDQxODQ1NjMxMTU4NjgwNzIxMDkxNjIxNDYwNzc1MDQzNTYyMDY1ODE1MTc5NjE3NTM2LzUyNjM4MzIwNjYwNzg0MTI1MTI1Mzg2MTg0MTM3NDc3OTgwMzc5ODQ4MDYyMzcyMjc2MDM2Nzg0MzA3MDQ2NjA0MzAzMDIyODY2MjM0MDE1NDMwNDQwNTE4MDkwNzk0MTA3OTg4Mzk3NjE2ODYwOTA4MjI1NDMzMTQ2NTU5NTI2NzIwOTE0OTk2Mzc4NjM4ODYwMDAyODcwMTA3MzQzMDc3MzU4MTIyODIxMjQ0MTQyNDQwMDc0ODIyMDgzMzU0Mjk2NDk3MTQ5NTAwNTcxNDQ4MzIzNTM1OTQ3OTQ3MDQ1MjU5MzI2NDI4MDY0NTM2MDEzMTQ4MjcxMzE0NzExNjM2NjUwMDMwMDA2Njc3MTIyMzM4MzAwNzIxNjE4Mjk4ODI2MzM1NTQ1MTkyMzMzMzMxOTE3MDE3NDc1NTMzNDU5ODk3MzIwMjc0MDEwODAzMjA5NzI0MjQ3NTU1NDEyODg3NVwiLCBcIjUyMTg5MTc5NzEwOTYyNjI5NjY4NDg5MTQ1NTk1OTI2MzcxMzI1NzM1MzUwMDg2NzY1MjI2ODU0MTUzNTk0MDE1OTgxNTE1MjEyMDg3MTE0MjE5NjUzNTIzMzMyNjg5MDM1MzkxNDc2MTI0MjAyNTkzMTM3MzQ5MTkwNjEyNzI3NTU2MTAwMjkxMDE1NzkwOTMwNjk3OTA5MzI0NjU3NDIwNzEwNDA4MTEwODE4ODk5NTA3MjEwNTk0ODEzODI5OTA5Nzg0ODE3NTAxNjA4Mjk0NzE3NDE1NjI3ODQzOTk4NjcwNTI0MTU3MTYxOTc5MzA1OTUwMTcyNDI2OTY0NDQ0NzU3MjMyMzUwMTI2MTQyNDc3MDc0MzMyOTg1ODAzODA0MDY4NTMxMzYyMTQ0NjUyNC8xMjMzMTAyNTY4MjY4NzM5MjM3NjU2MDQ4MjU0MTMyMDc0ODE3Mzk4ODYzNDAyMjU3MTMxMDg2NDk3NTg1NzUxMDY1OTg1MTAwMjIzMzg0ODAxODk2NDk3ODcyMTY4NDUwNDEzODI4NjA4OTkwOTkyNTA1NDc2NTc1MzQ5NzIxNTYzMjgwODA3MzYxNDkyMzkzMzIzMzAxNDM3NzExMzgxMTU2OTU1OTg0OTMwNTkzMjUwNjQxMTkxNzYwMzgxMzcyOTQ4NjMwNTMxNDg2MTg2NTYzNTY0MzYzMzI5OTEwNzkxNTA3MjMyMzUyMTQyNzg4NDg2MDI2NzEzMzMwNzYyMTk1Mjk1MzUxMjM4NDIyMTIxMjk4Mjk5MzE2NTQ5NjczNjc2NDkwNzgzNjkxNDA2MjVcIiwgXCI2NjA4NjA0NDUzODMyOTY3NzM3Mjk4NjExODcyNzk5OTYyMjkwMDQ3MTkzNzYxOTg5MTMzNzcxNDM1Nzc5Mjc2ODIwMDM0MTUxOTE5MzUwMDM5MzczOTMyMjg5NDAzMzMwMzI0NTM3NjIyNTU4NDg2NTM2OTQ4NjY5NjI3NjYwNzA2MDQzMjQ0OTc5Mjg5MzAyODA2MTgxNzIwMzkzMjA2ODA4NTg2MzgwMDQ5NDA1NDI3NDQyMzUxMjk1NjEzNjY5NTIxMTc5Njc1MTg0NTI5NTkyMTAxNTk1MzUzODMyOTM4NTI1MzI4MDg2NjY2OTQwMzE2OTkxOTYxNDk4MjE1NTM1MDg5OTY0ODYyNjQ4MTQwNTc4MTUxNDQzNDc2MTU0MTI4MTIyOTE1OTM5Njc4NzI4NzU1MzQ5MzA0NjkyNzQ0ODU5NTk2NDEwMzU4OTEwMDQyOTcyMjk0ODkxMzQwMzAwOC8xNTU2MjEzNzMzOTQ3NDM1MDU2NTY3MTI0MDUxNTI3MzY2Njc5ODA2MzkwMTUwNDA1MTk3OTk4MDQ1MjQ5MTY1Mzk3NTI1MDYzMDcyMzY3NzI3OTA4MTA1ODg4NDE2MzM5NjkzODU0ODc4MDg1NjI5MzAzNDc3NTQ1OTIyMzg3MTI4MTA0OTAyNjE0MDk5OTA1NTkyMzc0MzQ3MTQ2NjQ3MTgzMDU3MjY3Mjc2NjYzMzA4NjM0NzMxMjE3ODcxMTY0MzcyNDQ4NTk1NTU3NjU3OTk4ODE4MjU0NjEwNTA0ODA0MTY0OTk0NzI3NzY3Mjg2OTYxMzk5MjMzNDU0MTQzODc4NDczNzk5MzcwNjQ4MjczMTY5NjgwOTk0MzAyNzUyODg4MjkyNzk0Mjk2NzQxOTQ0NzI1MDU4Njk2NDI1ODgwNzQ1NDAwMzc3NTY5MzU2NzM2NjE2NTUwNzE0NDg2NjM3NVwiLCBcIjMzNTM3NzYxNTM5NDEwMDE0ODc1MTY0NzgzNzk2NzAxNzQ2NzcxMTYxMjI5NzE3MDA3OTk0OTI5ODMyODA2MTE1OTU1OTkzOTk2OTIyODIyNjQ3NDYxNTcxMTA0NDg5MTA4NTYyNjUxOTg3NzYzNDg0MjY5NDk4MzY2OTYxMTk3NDgwNzEyOTMzMzA1MjQ3MTc5OTY4NzQyNjY2NTU1NjczODMxNjYyNjE3MTQwODIxOTczMDg1Mzg3MjQxMDc5MjgzMTg3MTUyNjE3NDk4NzQwMjEyOTY5MTg5NzQzMzg4ODAyNzA3MjgwNzMwMjQxMTQ3NDY5MDYxMzk0ODk1MTY3MzU2MjQ3Mzc1ODgxNDY2NDM0NjI1OTEwOTg4Njg3NjUzODUxMDQ1MzQ3NTI5MDk2NzgzNS83ODcxNTU5Mjc1MjI3MTQ2MjMwNjU4ODM1ODg4MDMzNzM0NzYzODAwMDYwNTAzMTAwMDU3NTg3NjIxNDExNjYxMDMzOTgyNzQ5NTI2MTUxMjI4MTYzNTM2MTU2ODk1MTY3NTAzNzgzNDU0NDgxMTU3NTAyNjcxODEwMTE2NjU2MjA3MjkxNzg1NTAwNDgyMjYwNjc1MjI5NjIzMzQzNTAxNzI4NDEyNzU5NDg0NzY1NjUyOTYwNjY0ODM0NTUzMzE5NTQzNzYzNTg5NDk0ODgyOTg1NzkxMzc5ODMzNjM1NjY0NzI4NjAzMjM3MjY5NTEzMDQ2MTU3Mzk0MDUwMDc4NTEzNzQyNDM2NTg0MDA4MTUwMzEzMzE1NzMwODc5NjUwNTYyMjQzOTc5MTY5ODExNjYwOFwiLCBcIjIwMDkwODc5NzAxNjE4NzI5NjAyNTU0MTcwNzE2NzgwOTcwODQ4OTI1MDM5OTE3OTg3OTQ1NDcxMzIyOTk0ODY3MTcxNjYwMzA3OTk4NjAzNTE1NzQ1MDY2NDExNjg3OTgzNDUwNDAwNDEyNzM5Mjg1NTc3MjY5NzUxNjAzOTIxMTYzODM1NjE5Mjk2ODIyODAxODQwMzQ4MzE5NzQyMjAzOTc0MDIzNTA1MTg2MTg3MDYwMjUxNTQ0MjQ4NjQ0MzM4NDEyNjY3NjMxMjMyMjQ3MTA4Njc1NTA0NjI5NTM4MzE5NDI1NzY5NDY0Mjc3MzA5OTE1NTAyMTQ0NDQzOTczMzk3MzcxMTM2MjU2MTUxMzM2MjU1MTM4NTA2MDAxMjkyMzU1MzMwODc1MTE0MjQ1OTAxODIwNDM4ODIxNzMyODQzNTQwNzI1MTE2NzI4ODY2MzAxMjcxNDY2NjE0NzYyNDk3MDI0LzQ3MDAyMjM1MTk0MTA1Mjg4NTcyOTg3MzIwOTY3Mjk0ODM1NDQ4MjA4NDE0OTc4MjA2MTE3OTU2MTc5MjMwNjM0NDA5NDYwOTczMjY4MTczNDA2MzczMDM0MzEyODMwMDU1MDk5MDQ0ODEzMjMyMDU0ODA3Mjk4MDY4Nzk1NzA0MzA4Njg4OTczNDIzOTg3ODMwMjg2NDk2MzM5NTEzNjIzOTgxOTYxMzc0MjkwNzY4NDQ1MDQ1MjkwNTEwNzIzOTM3MDkxNTQ0ODM2NzgzNDkyNzI5MzAzNjExMTA1Njg2MTYxMTI3MjM3NDc3MjY4NTM2MTQ2NjE5NTM1Mzc5NTcxMTcyMzE5MDAwMzIwNDQyMjE1MzU1MDI3NDU2NzYzMTAzMTM1Njk5OTc2NjUzNTIyNTI0OTI1NjgxMDAwNzUxOTE5MDA5NjkxNzA5Nzk0NjAyOTgxODkxNzA0ODY2MDE1MDI2MjVcIiwgXCIyOTA0Nzc4OTc5OTg1NTI0MTcxMjA2NTczMDI4NDQ1Mzc5ODcyMjQwNTU4MDg0MjM2NDY0MjAwODU3NTk0ODE0NjMxMDMxNTgxMzg3ODA0NjIxMzcxODIyMDc0MDYxMjg5MzYzMzcyNTIzMzY0MTY3MTg0Njk3Nzg1NTcwMzI0ODMyODE1OTcyOTcwNjU4NjMzNTUxODc5MTQzMTg3NzA5NzA3MTY0Nzk2NjYzMDE1MTgwODc3NDEyNzE3OTEwODcyMjM0NjQ3NzA0NTM2ODE3MTA4Njc2NzM2NjYxODA0ODc4MDY4MDc4NTQzMjQxMzkwODI4MjI5OTIzNDI0MTkxMjA0NTg2MzEzNjIwNjEyNTM5Njc4OTMwOTk5NzY5NTQzNzU2MjE4NzY1ODcwNTEzMDQ5OTg2NzkyLzY3NzQwODA5OTA0NDgyMzY0MTU4MTY1ODg2OTIyMTA0NDM3NTMxMjA3NzkyOTk3NjcxOTE4MzQyNDg2NTgzNDgxMTU0MzczNzgwMDk1Njg5NjkyNjYzNzYyNTE2Njg0NDM3MjQyNDA0NDAwMzkyOTM0MTM2MTczNDg4NjIzMjc0Mjc3MDkwOTY4MzAyMTU2MzgyMjk4NzUwNTIzNjI5NTcyNzQ3ODE1OTkzODEzNTQ2Nzk3NTUyMjMzNjc3NDQ3MTkxNTE2NzYwNjY3MzQ4OTcyMjEwMjA3NzA0MTMzMDY1MjE4NTgxMTE5NjQyMzQwMDcwMTc5NTc5MTY2OTc4MDY5NTE1ODczMDc1NjI0MTE3ODI2Mjk2MjUxNTkxNzM4OTM4MjMwMjc1NzM2NjMyNTc2ODA2OTYyNVwiLCBcIjMxMjcwMTU1ODA5MzI5NzUxODYzODg1MjI0NzMyNDU0Mzk3MjkyMjMwOTY5MDAyMDA0OTUzODMyMzU0MDY1MzE5NzM1NTMwNjI0OTk2MjU0Njk1NDUzMDYxODUxNDQ5NjAwMzQ1OTc3NjQ2NDU1MDcyNTEyNDAwNzYwNTM5NzQ3MDU0MDAzODUxMjg5NTQwMzM5NDI1ODQ4NjgxODA0MTkwMjg0NDUxMjUzNDYyNjYzNzMxMTM1MzM3Nzc1MDg4Mzc5OTU0NDAzNzQwMDU4MDg0OTQ5Njc1NDYwNDQ1OTA5ODI2MzIyMjk3ODE3NTM1NDAwNjA0MTgwMzM4MjAxMzIyNjY3MTM5MDYyNTAwMjY5Mjg1NDkzNDE3NTYzMDk1MzY1ODk5NjMxMzYwOTAxNzMyNjg0MTI0OTMwMjk2NjQzMTA4NTUxNzEwNzA0Nzg1OTA2NDMxMzI0ODc2MDcyNDcwMjMxNDI0LzcyNjk1NzgwMzgwMDA1MDQwMTcwNzMwMDc5Nzg4NDQ5OTIzMTk5ODc0MTE3MzI4NDg1NjcxMTY2NTU4MjExOTY2NDQzODI3NzcwODg3MDMyMjg5NjAwMjA4OTQ3NTY3MjI2NzU4ODc0NzM5Nzc0ODA1Mzc1Nzc1MDkwNjEyNTYxMzgyNjEwNjM5MjY4NDU2NDMzNjA4NDkyMTc1NTYzNzA4Njg3NTI5MDk1MzEwODgzNjEyMjkzNzQ0NjcyMDcxOTY5Mjg3NDU2NzM0MDIzODA0NzM3MjEwMTgxNTczMjcxOTM1MDk1ODYyOTU4NzkwNTE0MTExODM2NTcxODUxNzY4MTI3MzgyMzE0NTYyNTMzMjExODc0MTkyMjQ3MDQzMDEyMzYyMDU0NzgxODQxMTU5OTYxMzU5NDA4NDg1MDM0ODcxOTkzOTQ2MTI2MTY3NDI5NjExMDg2ODQ1Mzk3OTQ5MjE4NzVcIiwgXCI0MzI1Mzg4MjIwNzk3MDc3NjAzODIwOTQxMjEwMjA0MjE3MzU2NzkxMTg4MzAzNjM3NjQ1NzA2NDA3ODkzNjgyMzU0MDc4NTMxNTIzODAzMjg4OTEzNTA4MTY0MDA1NDExODkxNDg1NTAzNTMzMzc4NzQzMDk4ODUzMzQ5MjA5OTU3MTMxNTQyMjU3OTk2NjA2MDEzODk3ODQ0MTA5MTE2NTg5Njc0OTkxMDA2MTAzNzYwNjU2NDA3ODU1ODUzNDIwMzUwNTgzNjQ2NzYzMTQwODQ1OTUyODM4NTAyMTM5NDI1NzY0MzEzMTA4MjM4MzY3OTI0NDAyMTgyNzE4NzkzNTQ2NjkyOTEwNTI1ODk4MDQ5NTY0MzU3NDM1MDAyMDQxODUxMDcyMTU5Mjk4NDkwNTQ3ODI4OTMxMTMvMTAwMjQ2NTc0NzM5MzI2MjkxMDM1ODI0OTU0Njc3NTAyNTkxMjc5MzQzMzExMDUxNzE5MTUxMzI3MDY2MzQxMzcwOTk1MzkwNDIzNzEzNDAzNzM5MDQzMzk2NTAzNzg1MjYxOTE3NzcxODU5MjIwNTM1NTA1NjkxNzYwNDcyMzk1MzA2NTQzMjc2MzE0OTM4Mjg3ODY4NzM0MDA5NTgyOTA2ODk1NzYzMDczNTE5Mzc0MDk5MjcyMzQwNTc3OTIxNjcxMjk4ODc4ODM3NDAwOTIxMDQ1MjUyMDM1NTA3OTI1MDIxOTA0OTU0NDQ1MTcyMzcyNDc5NzQ0NDY1NjY2NzYwNzYyOTA5NzMxMjM3NjM0MDgyMDUxODU1NTg4MDI1NzMyNDk0NDYxOTM5OTgwODU2OTgzNTUyMDAwXCIsIFwiMTkxNDMzMzY3MzY4OTIwNjM4OTExNjk0Mjc4OTExNjkxNzU3OTA4ODY2NDUxMTExODU4MjYxMDI5MzM4MzQyODcxMjkwMjIxMTYxMjU1NDIxMjc3OTg4MDYzODA2NTg4ODUxODQ4ODQ5MjI5ODU4NjY0MTk5Nzg0NDE0MTUxMDgzMjk0MDQwOTUwMTY5NDcyNjg1MTY2NjQ3ODY1MDQxNDE5MTI0OTUzNDczMzA4NzkzMzg3OTk4MTczMzU2MTU2NTI0OTgxODU3MjIwNDkzMjcxNTM0Nzc1Mjk0OTA4NzgwMDc3ODY0NjA2NTk4NjI0NDY1NzI2MDgzMjIzNDQ3OTIwMjIwMTEyOTg0NTExNzk1NTk1NzI0MjYxNjk0NzM2MTAxNjYwMzcwMjY0MDgyMTI1NjA5OTg5NTQ2OTA4ODIyOTMzOTI0MDQwMjQ3ODU3NjI4NTg1NDc4MzA2MzYxMjMwNzIwMC80NDIzMzM4MDEwNzYyODE3NTcyOTgxMTc3ODQ1Mjg5NjI4MzcxMTUzMjM4MzU5NjI0NjA2NjE2MDE5MDUxMzE2MTgzNDE2MDkzNzE2NDkzNDcxMzE3MjQ3MDAxOTI1NTE1NzQ2MjU0MDA3MDE0ODcxMjU5ODQzNTk0OTQ4MDQ4Mjg5MzU1NzcxMjQ2MDI2MjI1ODI1NTA2MjYzMzY5ODY4NzE3OTE0MDczOTg2MDk5MTUyMDgxMTQzMzkwMTIzNzQ0NTY3ODU3MDUxNjE5OTQzNDMzNDgzNTE0NzMzODU4ODc5NDk4MDkwNTE3OTY0MDczNDA5ODg3MzU4NTM4MTAxNzQ1ODkyNjEzMDA2ODEwMzA4MjYzOTI2NzIyODI2MzA2MTMzNTQ0NjE5MjcyMDg1Nzk5OTMwNDI5Njg1MjA2NTAzMTM2MjE1MjI5MzMyMTQwNjMzNjY1NTg3MDM0MjI3NTcwNzFcIiwgXCI1NzA0NjkxNjI2NDAyMDcyMjEzMDA2MzU0NTQ1MjkyMzY0NzYxMjQ2ODkzOTE5OTk3NTMxMDI0ODYxNDA4MjQ4NzQ2MjQxNjE5ODE3OTU1ODI0NjgyNjM5NTgyODMwNDg2NzkwNjE4NjY4MjIxNTMwMzY1NDI2MjAzNDI0ODg4NzM3NjU4Nzc4ODgxNzIxMDYzOTQxNDk1MzUwMjM3NDE5NzIzODU1MDAwNTE1NzQ3NzI1OTI2NzM1MzE5NDcxNDgwMDI3MjkzMjEwOTkxODY5MjU1OTcxMzY1NTIyMTcwNzQ5NTY4OTk2NjUxNDA2MDAyMzExMDIwODgzNjM1NTc3NTkwMDQ1NjUwMDM3NTY5OTA2MDAxOTI0OTcxMDQxODEwNTQ3NTQzMTYzMzYzOTc2NDY0NzgwNzI5OTMyLzEzMTQyNDAzNjIwNzY3OTI1OTI2NzE3NzM4NzM3NTQ3NTc0NDMyNzYyNTYyMjM1MzMzMzkwMDQzMzkzMzA1NTkzMjU3NTQ1NzQwMjM2MTk2OTgxNzEyMjU3Nzc1ODU0MDgxNjA0Mzg4MzQ0NDk1NzY1MjY5OTcwNTU2NDk4NDk4NzU1MTYzMTAxMDUyOTc4OTQ4NTUyNjQwMzg0NTA1ODUyOTU0MjIzNDM0NTQ0NTg1NjgxNTI2Njg5ODAxMzE5NzcwMDU4MDg4NDAxNDEwNzk1MDI0MzYzOTE5MDkzNDkxODIxODU1OTYzODE1MDkwOTE0Mjc3NTIxNTE4NjAyMDQyMzUwNzExMjI3ODg0OTk5OTY5OTEwNzg5MzUyMTY2ODYwMTA4ODg3MzQ0NzExNzMxMjQ0ODc5Mzc4NzVcIiwgXCI0NTEyMTkzNjQwODQzODYyMDg3MTg0NTYxNDIzMjk0NDQwMjMzMzczNDM0MDkyNjE1NDU0NDQ2NDMwMzEwMTQ3Njk0ODQwODUyNzg0NDA2MTI2Nzc4MTM2ODI4OTI5MjY4NTI0Njk1NDAxMTg2MjU3MzgyMzgxMzc0NTgzMjExMTIwMDUxODk1OTU3MDM2MTkxNzg1MzMyNjM3MDY4MTE2ODk2ODcyMTMxMjg4ODcwODIxOTczMzAxMzc1MDIwNjQyNjAxMDUzODc1MDA1NTI4NTY4NTE5NzIxMjQxNzIyMDY5OTYyMDU5MTk1NTY1NTMyNDYxMzMyMTg0NDE3NjkzMjUxMzM3MjU2MzE2NjU1OTMzNzIxODg3NTUwOTAwOTQ1NDE0NjI0NzQ5NzA1MjU4MjAzMzQzODUwNTgzMzM3NTY1OTEyMjI0OTI4MDE2NDcxMTA1OTQ0Mjg5MjIwNDY2NDE5NDUyNTkzOTIvMTAzNjQ4MjUwMTcyMjAzMzQwODY1NDU4MTE1ODM5NzY0Mjk3NTU4OTI1NjkzMDYxNzk4MTY5NDM0NTE2MDAxNzc1MDY4NzY5OTExNzY4MjgxMDg0MTg4ODgzMjc4ODQyNTQ2NzkxNjEyMTk5MDI1NDEzNTczMzk0MTY3NjM5OTI1Mjg3MDY4ODA5NjMxOTU4MDA2NjIyODQyNzE2ODY5MjExMzc0NTEzMTM2NzY2ODk5ODc3NTA0MTM2OTI5MTc3MjY3MzYyODYyMzE5NzQ4NTA3MzcyMTQ3MjQzOTExNTIyNjY3NTkxMzc1MDE1NjExMzEyMTY1NDY0NTE0MzA4NDUxMjIyMTgwMjcyOTM1Mzk4ODI4MDkyNjQ2MzkzODMwNTcyODM4NzcyMDg1MzY2NTY3MTU0NjQ2NDI1NTk4Mzg4NjIwMTA1NTM5NjE5MTc0ODM3NDg5NTM2Mzc4NjA1MTQ0ODkxNzY5NjI1XCIsIFwiMTU5MTA3NjU2NDU3NzYzNDU3NTcwMTc5MTM5Mzg0MjUzNTQ2MDg3NTczMzk3NDQ2NDgwNTE5NzI4MzYzMjY3MDAxMzUxNjE4MzI4MTU0MjkwMzM3Nzc1MDMwNDQxOTk5NjY4MTIyMjc1ODQwMTQ5NzMyMTI3ODU1NTY4NjY2MTk4MTQzNTYzNzQ2MTM1MDMyMDQ3MTI1ODM4NjM4ODg0MzE5ODcwNjI3NzY1NzIwODUyNjM3MjEwMDY5ODcwMDYxNTgzNTczMzcxMjUxOTMzMjU0ODYwNzExNTg3NTI4ODc4NzYwMjA4NDMzNjM0MTU5NDU3NjQyNjYzMDY3MDkxMTQ3ODI3NjEwMTcwMjExOTk3MjE5NTU1ODMxNDM1Nzk3NTM2NTg2MzgwMzI2NTE2Mzk5MTk2MTE3My8zNjQ0MzMxMDg0MTAxOTMzOTM4NDcyMDMzNDg3Mjg5ODEyOTYyODU3NDIyMDI2MTc5ODg5NzAzODQyNzcxNjIyMjU4NDcyNTYyOTU4NjU1NTQzNDE2MTExNzE0NjA0MzYzNjI3ODA0OTcxNzkwOTAzMjk4MzE4ODU4NTMzMjQzOTI5MjM0NDk1Nzk1MzgyODY4MDQ3Mjk4NTYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiwgXCI1MzA3NTA3MTQ4NzA5NDM1ODA3MjYxMjI5MzQ1MTMyNTM1MTM0ODQ4MDMwMzQzOTAxMzAwMzI0NjIzNDA5NzIxNjk4MjE3MTM0OTMyODY2NDg4OTM3NzcyOTg2Mzg2NTAxNTM4MDI2NjkzOTU2MTIxMTIxNzcxMDg5NzQwMDk1NzYwNDg2MzYyNjU0NzU0MjI5OTA0NjMzNDc2MjM0MDkwNzkyODI3OTMwNDMzNTk4NDUzMjAwNTM2NTUxNzc5Nzg5MDQ5MzUyMTMxMDA1MjIyNjU5OTk1ODQ1NDI3NjgwNjg2Njc3MzI0OTYzMjIzNjUzOTQ5Mjc3MDM3NTIwNzExNjA5MzQzMTY2OTI2NjI3NzEzNzU4OTkwMzg0MDExMjc0Nzc3MDg3OTY4Nzk5NzkzNDEwNTA2MzkxODg0ODcyNDU2NDIwMDQxNDk0NTk4MjczNzAzOTE0Njg5NTg2NjM3OTk1MTM5NTgwNzk0MzY4LzEyMTIyNDQyOTAzODE1MjQxMTUwODIwMDU1NzUxMDU3MDM0OTY1ODMzMTUxODg1NDAxNzc3MDI3ODAyMTY1NzAyNjUxNTk5MjM2NTQxOTc3NDYzODg1NjgxNTE3MDY1MDkyNDM2MzgzMDI3MDc1MTEyMzg1Mzk4NDU1MzE2MDgzMTMzMzQyNDg3ODg5ODAxODgwNTQ2NTE2MDE1MzYwNjc3NDA3MDk5Nzc2NzgyMjI3OTA0ODEzNDgwMDMwODUwMzQ4ODgyNDQ0NDc2MjYzNDczMTIwOTQ1ODYzODkzNDc1MzUxNjc5MDM0MDg1MTkwMjQxMDU3NDg1MjMzODQ5MzI5NDI0NDE4NDMxMTg4MTM4MTk3ODEzNDcwODk3MDIyODY0ODE5MjQ0OTMzNjEwNTgzMzk3MzE5NDk4NDQ2MjA3NjMyNzI3Nzg5NjA4NjA1MDk1NzA2MjI2NzMwNDg3ODY5Njg2NjAxMjk2NTAxMjVcIiwgXCIzMDQ2NTc3MDk4ODQzNTgwNTc4NjE5OTU1NjAzMDI5MDczMzI4MzYxMjk4NDM2MTI5NzkxOTMxMzA0NjY1Nzc3MDM2MTUyOTE1ODU4NTc1MjgyMzYyNzQyMDA4MTM2NzIxMjg0ODE3ODk5NTQyNDc1NjY2MDU0MTAxOTU3ODk5ODU4MTM4NTkwOTYzNzg5MDcyNTMwNzEwNzc1NzkwNDMzNDY2ODQ3MTAwNDIyODc1OTA2ODY2NDk2MzE4ODA0OTg2MjAyMDg5NTI4MTk4OTEyMDk4Mzc3ODI4NTgwMDMxODUyMTUyOTk3OTA3NDMzMzM1MTc2MjY3MzAwMjg2NDY2MDcyOTk3MDE0MDIzMTIwMDg3OTg4NzQ4Mzk2NTk4MTc2NjIyNzY1OTIzMDU5Mzg1ODc2ODU1MzAzOTQwNzIwLzY5MzkxMTg1OTA3Nzc1Mjg5NTk3ODgzMzI0MTMzODkwMjY5NTc1NTUyODYxMzcyOTUwODU1NTkzODQxNjQxOTg2NDc3MjM4NTMzNjc3NzkyNDg5MjQzNDcwMTgwNDA3ODg5MzgyMjQ0NjcyNzc2MjA3NzUzNzk1NTI0MDYwNTkyNzU1MDU0ODA0NjMwOTgyMzA1MTg0MTMyNjM1NTY1NTg0ODQwNjY0NjI0ODU5NTYyODcxNTE4NTQxMzg1MjA0MDI5NTYzMTQ0ODI1MDQ1OTA3NjA0MzgxNjMyODA4MjU2MTI0ODQyMDkyNTkzMDQzMTc3NzUwMjYyMjE0ODAxOTM3MTM4MzI1NDMxNjYzNjk3OTA3MDczMTQyNzczNzc2NDE2MDE0NTA5NzI5MzI2MDkzODk3ODQxMzQ4ODgxOVwiLCBcIjE1NTMxMDkyNjc0Mzg3MzM0MzQyNjMxMjYwNzE4MjA2MDA3MjkzOTAzMDc2NTI5NzYzMDUzNDU0NDg5OTIzMDIxMzA1NDcxNDQ4MjQ1NjgyOTE5ODQ4NTk5OTc4MjA4Njk0NDI3MTQ5MDIyOTQxMjcwNzk4MDk5NzQzMjUyODY1MzUwOTk0NTMwMTU3NDc5NDI0MjExODQzMzg2ODc0NzE3MjI3OTIyNDExODUzNDQ2MDU2MzQwMDQ0MDY3MDAxNTMyMzMyNDYwMjExNzUxNzM0MjIwMTY0MDAxNjg1MzkyNzkyMzk3Njc5NjQ1MzU3NzA0ODk5NTI0MzYwMDk2NzIwMjQ2MjQ2NjY4MTExMjgwNDQ3NjY3MjM0ODIwNjQ5MTQ5MDUxMzQxOTMzNjMwODU3NTQ0MjA4NjUxMTAxNTEwMTk5OTg0Nzg5NjE5NzU0NjkwMDUxMjc2NDIzMzY3NDc0NzQxNTg0NDA0NTE4NC8zNTI3ODE2Mjk4NjU4OTY1OTMwMDY3OTA4ODUzODE3NjA3MDY0OTI3Mzk5MTg2NTY2MzA0MTYxNjA4ODg1MTkyMzExMTE3NTUxODQwNTExNzM5MTEzNDg2MzY0NDU0MDkxMTAwNTc4MjM3MjgzMTQ5NjEyMTM1NTk1NDQ3MDc0NDE2OTk2OTc3NDU0MDg5MjA5NjMyMDk3ODY4NjU0ODI4NDUwMTEzOTg2MTc4MzI5MjIyNjE0MDQxMzc2OTY2NTQ2MTQ5NDY2ODQ3OTQzMDgzMzg5Mjg1Nzk5MjQwMTM5MTI2MjkwMzU4MjEwOTk5MzgzODcyODI4MTkxNTgwNjM5NDc0NzgzMzU4ODYyOTQ2NzYxMzMwODgzNzE5NjI2OTQyNDQyMTEzMTkzNDg1OTA3OTI2MDE4NTA1MjA4MTUzNjQ4NzQ2MjI1NzgwOTk4NzAwMjE5ODQzNzE4MjUzOTQ0MTM0OTQ3NDQyNjM3NVwiLCBcIjQ2NzI5NTkxMDI1NjIxODc0NzgyNzU4NTE5MDc0NDUxNzI4NDc2Mzg2NjU3NTc2MDM2MzYwNzM0MzU4NzE5OTc2NDAwOTQwMzAxNDkzOTM5MTkyMDgzMzM5MjkzNzc5MTQ5MTI3MTMyNjUxNjE2OTcyODE3MTY1MTcyMTE2MjY5MzA3Mjc2NDg3MTU4MDY5MjkzMTE0ODYwMzkxNTAyNDg0MTI1NTU0NDA2OTQ1MjQ5NzI4ODAyNDg0MTI4NzU2OTI0MDQ0NjMzODI1NjkyNzc5NzgzNDI1NjI4MjkyOTU5MTcwNTk3MDA5OTM1MzA1NDI5MjM5NzAyOTI2ODk4OTMxOTc1MDIzNTk4NDU2MjA3MTY1MDY3NTY4OTE5NzU3OTAyNzY0ODE1MTA4NzUxNzM1NzUzNDMxMTUzNTgxODQ5LzEwNTg1ODY4MDg0MDc5MDMwODM4NjUxMzkwNzM4MzcxMTQxMTQyMjQ1MDg2NDY1MDMzNDU5NjQwNDU4MzY2MTQ2ODQ5MzE0Mjc0Mjg1ODcxMzc1NDU5ODk4MDE0NDE0ODMzMjk1ODA0MTM5OTc5MDE2MzYyNzk2MzU3MDQzMzcyMzE2MzIxODcyMzU3ODE3NzI3ODIxNTU5MjMyMzUzOTkzNzE0MDYyNTM1ODgzMDc0NjYxNzM0NTA5NDQwOTk0NjY0NzI2NDI1Mzk5ODgwOTk1MTMzNzExMDM4NDgzNjA3NzczNzgyNTMyNDMwODc5MTk2NDA1NzkzNjk0NjU4MTg1MTc1NTgzNjkxMTgwNzU3NzgzNTk3ODk1NjE2OTIwNDMyNTI3MTI1OTkzMTE4MTcxMzYxMTE2Njg0Mjg4MDAwXCIsIFwiMzczNjM3MjM0ODEyNDE0NDcyMDg1MjE5MDc2OTcxMDEyOTQ2MTE0NTg4OTAxMTU5ODYzNjkyNTIyODY1NzM5MzkzNDEzMjgyODYzMzEzMjM1NzIzMjg4MzQ3MDQ2Njk0MDMzMDg0ODE3NzQyNTU0Mjc0ODEwMDIxMTQ5ODE4NDQ5NDI1MjcxNDYxNjM3OTQ1MDI3MjYxMTg1MDA2ODg2NzgxNjI1MDIwOTg2NzUzMDkyMTI3ODY0NTI4Njc2OTQxODA4MDAxODcwOTk0NzgyNjg3NjQ2MTQxOTY1NDc4MjM0MTMwOTEyNzcwOTcwMzYyNjQwMTIxMTk5NjI1NTc0MzgzMTk5ODkxODg5NDY2MTA1MzY2OTE4OTMxMjM3NTE1OTA1ODcxODc2NzA4MjE2MzE1Njk4ODc2NjgyMTE5NDAwMjU5NjMzMTgyNjE1MDMyMTg2NDkyNzgzMjYxODEyNjU4MDUwOTczMjM1OTQyNC84NDQxNzY4NTEwMDc1MDQwMDM2MjcwMTY5NDUyMTIwMjMyMzkzMDgzNDg0MjgwOTQwMjM0MzcyNjk1MzI3NDMyMjE5MzcwNjkzNDU2ODI5MDA4ODQ2MTgzNzg4NDkyODMwMDI5OTgyMjA1MTMzMDcyNzMzMzMwOTY3NzU2Njk1NTYwOTMwMDU2Mzc2MTUwMTI3NTA3MzMyMTY0NjA0NTg2ODkyODI3OTE2MzI0Mzc4NTEzNjQ2NzQ4NzkxNTI2OTU0Mzg1ODk2OTIyMjcxNTkwMzg1NTU3MjI1MzkzNDU5NzI4MzMxNjExNDYxMDgzNjczMjkzNzA1NjQ4Mzg2NzE3OTEyNDE0MzExMjUwMDM0MDE4NjE4ODc0Nzc5Njk5NTQ3NDA1NDQwOTIxNzg3MjEzMjc3MjQ2MjA0NTA5NDc2NDYyMDk5MTQ2MjEwMDcxODY0OTcwODE0MjAzODQzNDc0Mzg4MTIyNTU4NTkzNzVcIiwgXCIxMjU4Nzc0NzU1ODI4OTkxMjgxNTc4OTY4MDIzMzgyNjI0NzIzNzcyOTI3NjQyMDAyMDE2MjcwNDg0MDkwNDA5MDQzNDU0MzM2MDQwODU3OTI2NTgxMzE2OTk0NTk0MTA5MTY5MTIzMzU0NTUzMzIxNDY5NTAwODQ4MTQ2MDE1NzE5ODUxNjA5MjIwNDIzNzM2MTUzMzY1MTM5ODA0MDg2NDEzMjg0Nzg3NTk4MjUzNjE4MzYxNzY5MTI1OTk2NzU1MTU5NTcxNTIzNjMyNzQ3MTI5NDgwMzg3MjU0MTY0MDA4OTY4OTkzNzM0NDQyMTY0ODkyNDg2NDQxMTUyMjI3NDMzMjgxNjI1MzkxNzUzNzAyNTc3MTQzOTg1MDQ3ODMyNTE5MDYyNTk1MTIzMjU1NTY5MTcyOTY4Njg1MDYwODQ0LzI4MzY1OTg1OTY2MTY3MTE4MTUyNjU0NzgzMzQxNTY1MzQ1MzUwNjQ3Nzk1MDY3ODY1MTY3NTE5MzIxMDk2OTE3MzEzMDExNjEyMTAxNzcyMzM2MDI1ODI0OTQzMDg4NDIxMzAxMTk4ODY3ODAxMTM1NzQ1ODcyNzYwMzQxMzUyMTY4ODE4NDUyMTU3MzA5NDc4MzI5MTQ5NjM2ODAwNTY5NzQ4MTMzMzczOTUwNDQ5MDY0NzE5NDQ1NDY5NTUwNDcyMjU0MjAxNDg0NTcwNjIxNjIyNDQzMjM3MzQ0MjQzODI0MjM1NTE4ODQ2MTk1MTg4MzQ1NDY2NDY5MzI2MjY4NDg3Mzk4ODA2MTAxODk3NjcxMTIwMTM1MTM4MjE2MzUyNzA5Mzc4NDc1MzM5ODI1NzA5NDQyOTQwMzY5MTYyNVwiLCBcIjg0OTMyMDYzMzU1MjkyODI5OTg4OTA4OTYxMTkyNTc0NzEwNDkzMDk4ODk3MTQ4NzAxNDczMTcyNzU0OTQ5ODQ2NDU1NjI2MzgxMzI5NDU2NjYxODA4NTY2MzY1MzI5MjY2ODk4OTkwODI5MjQ3NDQ2MzU2OTcwNDU0NTAyMDA3MTI3MjY5NzA4NDg3NTYzMjc5NTM2ODI1Mjc3Mzc0MTMzNjgxMTY3MjM1ODExMDgwMjk4MTM0ODk5NjI5NTgwMzE4ODEzMzgyNjY4Mzk5NjQ0NTUzMTExMDgwNjI1OTE4MjEzMjUwMjIzMTk3NDQwNDI2MTQ3ODIxMjI1NTkzMzA0OTkzNjIxNDUxMDUzMTM1MzMyNDUxOTk3NjMzMTMyNzcyNjA4MjMzNDMwMTMxNDAwMTg2NTcxNzkzOTI5Mzc3MTI5MjExMjI4Njg5NzAzMzc2MDY3NzYzNjI1NTY4NjIzNTM1NTg4NzA5NTc2MzIwLzE5MDg5OTc4MTMzMzI0ODUyOTEwOTUwNDY5NjU4NTY2NDU4MDM3MDk2MDI3NzIyMzI2NzE2ODAwMTEzMTA3ODQ4MTE1MjMxNTYzNzg3NDU1NTg0Mjc4MTkzOTU0NTE4NDQyNjAxODEwNzc2MzQ3MDkxMjUzNTYxOTU2ODc3MTU1NjczNTUwNDU4OTU1NTYyMTAyOTM1NTU1NTEwMzkyOTU0NDI1MTk2MTY1Nzg1NDEwMzE5MTI2MDk4MzkzMzUzODc4Mjg2NDAwODc3MzA1MTY0ODY5NTQ4MzgwNjcwMjA0NTc3NTQ0NjMwMzUzODU5MDA5MTc3MDUxNjk4MDk2MTM2NDcwMDcyMTM3NTc5Njk4NDczMDE3MjU3Mzk3OTQ5OTk0NzIyMDE1MDg5NzY4NzQ1MDEzNzEzMzgzNzY5NzY1NjA5NjEzNTE0MDIxMjAwODg4NjQ3NDcyODA0NzIwNDU2NDk0NzU3NDIzMjk5NjI3XCIsIFwiODAyNjM4ODgxNTMwODMyNDMxODI4MjQ5NjA0MDQwNTc5NzUwOTE2MTE4NDIzODMzNzkxNjA4NTg5NTYwNDAyNDQ5MDM2OTIwMTY1NzA0MDEyMDcwMzQ5NTM3MTE0OTIwODgyOTM4NDY2NjM1NTk4NjAyMzg3NzE4MzAwMDc0NzMzNDc2MTUwNTQ4NzI0NzI2NDYwMjA5MDE2ODM0NDE2MDk0MzE3NzI0MjYxODU3OTY5OTU1NDE0MDAwMTU1ODA3MzEyODUyMDkyNzIwMzEwMTU5NTcyNTQ3NjQ0NTY5Nzk3NTEyMjMzODk5NDk1MzAwMDI4MTU5NzIxMzQ4NTk5ODE2MDgzMTY2NzEyMzY1MjE1MDc1NzI4OTY4MDA1OTQxNjEwMDU2MDE4MDIzNjMzMjM1MzcyOTM2OTAzMDE1NzcxNTgzLzE3OTk1MTE5NzM4NjExOTA3OTczMjQzODYxNzQwNzkyMTUzNTA2NTE0MDUwMzA0MzQyOTE3NDM5NDYwNTY1MjkxMzg3OTk4MjQ4NjA1MTYyNzc2MDY1MjE5NzQ4NDE0MjU0NzQ0NzAwMDUwODE4OTQ1NTEyNjQ5Mzg2ODIyOTU2NTY0NzI4NDMzMjczNTU1MjQ2MjUyNTU5ODQ2NTE5MjA3MzU1ODc5MzMzNTkxMzAwNTQ1OTI2Njk3NzA4NjEwNDM1OTYyMTAyMjY5MTkzMTAwMjQ4ODA1MjcyNzU5NzUxMzQxMzQ5MjM5MzUyNTY2MDI3MjkwMDE2MTM3NTY3NzQ5OTIyODI1Mjg2MzUyOTkzNDU3Njg4MTU5NjM4NDAzNjQwMTc4NDAzNTI0ODY0OTAyNjA3NjU4MTMwMjM3MDMwNDAwMFwiLCBcIjI1MjA4NzQyMzk5Mzc1MzYyODgxMDk5ODExMDMyMTM1NTc1MzYwMTA5NzE1OTY0MDI0NzQ3MjEyMDI2MjQ1NTI5MDg3NTk5NjMzMjgwMTQyMzE0OTYyNTgxMTkzMzAzNjgzNzU5NjA1MDg0OTk1ODE4MjUzMTI0NDQ1NzczMTE1NTc0NDcwNzE3MTk5MjE4ODI4NzU2NDQ5MTg3MDU1NTM3ODc3NDc4MDMzMTI5ODYyNjAwOTgyMDY4NzgyMjQ5OTQzMTUwMDE5NjM3MTg2NDY2MjYwNzA3NTUyNDE2NDMzMDEwNTQ1NDM3MzIxODE0MTE1MjMzODQxNjg3NzAwMDUxODMwMTcwMTkxMTA3MTI3Nzk5MzU1NDg1OTIwMDQ2NTA1NTkxMTkzNzcwMTY0NzUwODg2MDM3ODg1Mzk3NDc4MTkxNTM0Nzk3NjU1NjE2NzQ1NTI4MzQzMTcyMzE4MzE4Njc4NDA1NTc2NDMwNTQ0ODk2LzU2Mzc3MTMzOTg5OTU1Njk2MTQxOTYzOTc4NTc1MjU2NDYzMjUyMzQwNTYyMTk1MTMyMDI5Mjg1ODc1ODA1MzQxNTk1OTY4OTc4ODA3MzEwNDMzMzY3OTAyNzMwNDA4MTMwNDQwNzcxNTMwNTEyNjA5ODk3MzAzNzI4NDY3MTM2MTg5MDAxNDU0NDQ4MDIyMzQ2Mjk5MjI3MTc0NjQwNDEyNjEzNzA4MDM1OTg3OTk4MjY2MDQ4NDE2NTQ2MDg3MjQ3MjczMjA3OTgzMjQwMDYxMjk1MjQ2MTA2NjYyMzU5OTgxMTM2NTUxOTM2NDI1OTQ3NDQ1NDQyMjY4ODA5NDQ4ODIzNDIyMDQ0MDc3NTAxOTM1MTI4Njk2NzI4NDk5MTAwMDMyNDY1MDQwNTIyOTgwMjI0NjgwMTI1OTQ0NTk5NzQyMDk5NDA2MDc0NTA0ODA2MDkxOTA4NDE4OTMyNjcyMDMzOTI4ODAzNjA4MjM4NzVcIiwgXCI3MzIzMzI2MzcxNzg1ODQ1NjAyMjA2ODg5MDAyNjg1NjYxMzAyNDY4MjAyMzU5NTY3Njg3MjQ4NDU3NDc4MzA5NTk1NDc1MDE5NTA3NjUwNjM5ODI5NDMwNjExODE1MjYyMzcwNjE4MDkwNTI0NDQxMTA0Mzc5MzAxMDAyMTAxMDUyNzQ4MjQ2MDczNDQ5MDI3NjQxODQxNTEwMzA4MjcyNjYxNDIyMjU4OTQ2NTU1MzE0OTc4NDkxNjE2OTI3NjAzODU5Mzg3ODY3MzY0MzY5NzcyNjg2MTYwMjk4NjI1NzcyOTM5ODQzNzYxNzA5MDUwMjQ3MTI5NTI4MTMyMzQ5NDk1MDgxODYzMDY3NzQyNTcwMzU1MzU4MDUzMzAzNjY3NDIzMjI3Nzc2MTEwNjM0MDI0NTUyNjEzOTEwMjEwOTcxMjgvMTYzMzc3OTg4MTUyMTc5NjM2OTIyNDA5OTM4MTYzMDA1OTQ4NTk2ODIyNjU2ODY4MDQwNjYyODMxMDAzOTkxMzk1OTA1MTg1ODIzODM2MDg5ODg3OTkwMjAxNTIyNjczMTk2NzE5NjI4MjQ3MTA2Nzc3ODgxNzQxODQzNzg2MzY1NzAxMTM1NTU1OTE3MjYzMjg1MjY4NzUzNjA1NTE0ODEyNTY4MjU4MTc5MzkxMjcyMTEzNDA1OTIwMzY5NTg3OTIyNzAyMDAyNzMyNjY3ODQyNTExMTA4NzMyMDY4NjgzNDA3MTY4MDkwNzI1NzEyNDAxOTU0MzE0MjkzMTkzNTcyNjU0MzQ3MjM3NzE2NjkxNzg0Mzg2NjkwOTQ4NDk0MDAzMDk0OTkyODc2ODY3NzYzNjk4MTAxMDQzNzAxMTcxODc1XCIsIFwiMjIzOTEzNzQ4NTQyOTk0NjIxMDc5MjM1ODMyNjc1NzA1OTM4ODYwMDI2NTg3ODY3NzUyMTE1OTc4OTYyNTI4Nzk3MDg3NTM0NTA3OTQzMzIzMDExNDI5MDk3MTU4NDUxNTE3NDY3ODYwMTY1MzUxNTc3OTcwMjMxNTMwNDEwMDcyNjMyNTg3MzI5OTE0NjUwMzc2NDg1MzY3MDIyMTcyNzM4OTc4NzY4NjQzNTE1NTk3MzY0NDk0ODEyODU1MTgyNDk4NDYyNjQ2MDA5MzU1NDM1ODI1NjIwMTg4NzQ1NzQ2NTU3NDA2NjA4MDA2MzQ4ODM0MDM1OTcxODE4NzYzNjQ3MTI1MjEyNTM2NTA3NDQxOTczMjEwODA2NTUwMjgzNzQ2MDI3NzI2OTY3NzAyMjc3NDE2MTA4NzQzOTk0NTQzNjI1ODM5ODA0NjUyMjUyMzU2NzQ4MTY3ODU5ODgxNjQxNTczNTEyNDMxOTMyNjU0MDE3MjgvNDk4MzI3NTk5NzE4ODk2Nzc1ODM4MjE2Nzg2NzY1NjgwNjY4MTU2NTUyMTk2NDEzNTEzMTcxMDY3ODQ0NzI0NTk4NDIzOTczMzU0NDk0MTg4MTQxODk1NzY5NDYxMjkwOTU5OTI2MTg0MzY5MzU1NDA0MzUwNDg1NTIwNzE3MDc4Mjc0NDUxODk0Mzc3ODA5Njc2ODg1OTMzNzk4MDQ3MDIxOTc4MzIxMDE5MTc2NTY3ODkwODUzNzY0NTI3MDM5MjUwMDc3NzQxMTEzNDE2NDkxODgwMzk0OTE1NTAzNzU4MTEwODY3ODk2ODcwMTk2MTU0NDk3OTQ1MTA4MTgzNjg3MjQyNTU3NDEyMzY4MzU3NDQ3NTc5MDk5NzQxNDQ4ODY0MTUzNDA3NDg3MzI0ODgwMjQ1MDEwODUzNTE4MzQxMzk3MDA1NzMxOTI0NzAzMzM3OTAxNjYwNjgwOTIyNjU0NzgwNTI2OTc1MjEyMzc0NjM3NVwiLCBcIjIxMjUyMzQ0OTk1NTkyMjY5Nzc1MTA3MjM2Nzc0Njg5MDEyNzYwNzUwODUwNTk4NTY3Nzk5NTYwMzQzNTM1NzMxMjUxNzY2NzgwMDE2NTMwOTc4NjYzMDc5Mzg2NDUzNDMwMjcyNjk4MDA2OTc3NjY4MDYzMjA4NTAyNDA4NjA3MjI3NTQ0MzIyOTQ1NDQ2MDc5NzA4MDAwMzA0MTc5MDczMTg0NzQ1NjIzNzQwNDY2MzM0MTI3ODY3NDY0ODgzNzYyODQzMzQ2NjE5ODUzMzI1NDE1OTYzMDYyMTgxMDE4NzM2NDEwNTcwMTEzMTcxMzg3ODkxNTE4Mzk4ODQ2NjE3MTk3MDk3NDA3NjEyODUyMDM3OTA1Njg3ODk5ODAwOTMyMzQzMTU2OTc5NTkxNzQwMzEwOTI4MjU3NzY2MDgxNjk3NjQ1LzQ3MTg1MTUzNzg0ODQ1MDkxNDIzNzc1NTg0MTIxODQxODM5OTEzNTc3NDcyMzU4OTIxOTQyMzQzNzc5MzIyMTM2MTM3NDYwMDgzNzM5MTg5MjM2MTEyMzYzNDYzMzAxODkyODczMzY0OTM3OTQ0OTkxODg2NDAzODA5NzUzNjQ5OTE1NDg3OTQzNDExNzcwNjAzMjU1MDk2OTg0MDQ1NzEzMTgwMzcyOTgxMTIyOTM5MjY4MzM4NzcxMDM1NTQ1NDY0NjYwNTU2MTI0OTg5Mjc0NzQyMjU2MTk2ODAxODYxMTkzMTMxMjk2MDQzMTkwOTYzNzQ5MjQwMzc4NzA4MDM1NTQxNTM0NTgxMDQyMjU3NDEyNTU3NTMzMTQ5NTUxMTU2NDUzMDQ5NDg1NjQxNTE3NjU1MTYxODM2NjM2MzQ1NDY2ODhcIiwgXCI3NjcwMzA4NTY2NjU2MDYwOTMxOTM2NTY1OTIwOTQ0NTA0NDk1NzA1MjM1OTUwMDc0NTE5NjcxODI2OTY2NTIzNDY0NjEyMTEzNDc4NzgwNzkzODY4MDc4NzM0MTAyMzIwMzc4NjkwNDMwODA0Nzk4MTA5OTIyODM1Nzg1MDAxNjYwMjIwMzUzOTk3OTI0NjU3OTQ1NDIyOTA3ODQ5NzUzNzE0ODc5OTM0OTM1MzI1MDE2NzYyMTkzNTM4NDE5MzUwMjM4MzE4NzUxMDkyODYwOTgxODAxMTE0MjY0Mjk1NDU1MDMzMDA2OTk5MTU3MDk4MzkwMjg0MTMxODIwMzc5NDExMzg5ODg3MTUxNTcwMjQ0NTcyMDIwNzE0NDg2Mzg3NzAyNjUyNjAyNTQ0NzgxOTUzNzM5NjE0NjgyMjIwMTgxOTQzNTUzNjQzNTgzNTI4NTA5ODQ4NTk5MDI2MDY3NzczNzE5MjIzMDk4NTA2OTgyNC8xNjk4OTg5MjgyMTEwNDEyMjkxNjMxMjk5MjYxNjY2NTc2NDk0MzcyMzIyMjE5OTI3NzQxMjg1NzA1Mzg5NjMxOTgxNDQzODk2MTQ3NTExNzk1MTkwNDg2NzA2Njg0NTQxMjYzOTIzNjc5MDc2MjQzMjk5NjMwOTcxNzkyNDAzNzQ2Nzg2MzAyNDM2MDIxMTE2Mzk3MTE5MDAwNjI3MjE2ODg0NTE5NzAwMDMwNDMyODQ4MDkyMDQ4MzY1MTU1ODY3Mjg3OTk2NzM1MDk4MjE5OTc2ODI1NTI1Njc1MzExMDM3NTQ2Nzk3NjI0NjMzOTI2MDMyNjQyMjg5MTkxMzU2NDE1MTQ1MzcyOTI4NTE5MTM1MTI3MzM0MjIwNjE5ODM2NjYyNDg4MjE5NTEzNTA1NjE3NjUwMjcyNDkxMjg0OTU3NTM4NTU3NjU1NDIwODg0NDgxNDA4NTIyODY5NjgzODgzNDY2NTMzOTgxMTAyNzYyNVwiLCBcIjQwMTUzODMxMTY2NTIxMzkxMjI1NDg5ODk0ODU3NTUxODM4NDY4MTUwNTc2ODI3MTI5MTMzMTY4OTcyODU5NDQxMTIyNzI4NzEwMTY1MjMzODY1MzA5MDg0ODcyMTU5NTgzNzg3MDgzMTMwNzEzNDczNzAyMjk2MTIyNDY1MzE5Mjc2NDYxOTkxNDU3MTczMDg1MzEyNDA3NjEyNzU3MjgwOTE1ODUzNTg0Njk4NDIwMDgzNDM2OTQ2OTc2ODQ0MjQwMDYzNzMxMzMzNjM4MTUwNTk5MDE3ODg2OTM3NzgzNDcwOTQyMDA3Mzc2NTIzOTQ3ODQwMTA0MjQ2OTI3NTgwMjU0NjEyOTkxMTkxMDQwOTUxMDAxNTM5NjQxOTQ3MTUzODQ3Nzc2MDUwMTM4NTMyMjE5NTk1NzQ2MDU2MDc2Nzc2ODA5ODEyLzg4NzM1NzYxMTM1ODEwNjU0OTMyNzM1MTk2Mjc1NDQzMDc0MTgxMzk5MDg2NDAzMjUyMjcxOTY5MTIxMTQ1MjA5MDM1MDU0MjY3MjIwODYyNjU3MjM5MDAzMjY3MzU5ODk3NzE2NjA5ODc2MDk2MDQ1MDc1MDM3NTAyMTIyOTg3NTQ0MTQ0NzI4MjI0NzcyNDMyOTM2Mzg0ODYwNDczMTM5OTA4NzgzNDg4MjA1NzM4NzQ4MDk2MzYwODQ1NzQxMDg5MDk2MTUwNDQ1MjQ2NjM3MTI0OTU0MjI1NjUxNTEzNDAwMzc1NjQxNTYyMzU3NDU2Mjg0NjUxNzIyMTkyODY2NjQ2NTMzNDMxOTMxNjI2NTczNzQ0MTA5MjYxNzExNTM1MTY4NzE3NjU2ODA1NjE1MDU3NjgyMjM2NjAwNTU2MTc5MzQ2MjVcIiwgXCIyMDA3MzYzNzQyNzc4MzUyNzI0ODUxODY1MjM0ODAxNzcxNTk0NTMwMzAwODI3Nzk4NzI0Mjk2NDg0NDk0MTIzMTMyNDc2NDAzMTI0NzkyMTQyNjE2ODE4OTkyODY1MTM4MTg5MTI5OTE5NDUwNDYyOTczMzQ0MTgxMDI3MTE2Mjk5MzM0Mzc2NTQzNzc3NjAwMjg0NzY3Njc0ODIxNjIwMzE2NDE3ODE0OTkxMTQ4NTk1NTM2Nzc1MDIwMDI5MDEyNDgxMjQ3NTA1MzkyNzAyMzUwOTg0OTIzNzc4MjYyNDAzMTk3NjY2Nzc4NTY0NjUwOTM4NzEzNjc4MTc2ODM3MzQwNzk2MjEzNTkxODY0NzczMDYxNzM2MjAzMzE3NDg0OTYzNjkxMjIxNDMwMTkzMDM3NDAyNTI0NjE4MjQ1MjM1OTAwOTY5MjM1NjE5MjgzNTQwMjA5NjAxNzY2MDUwMDg4ODk1Nzk1Nzg0OTUwNzMyODM3MTIvNDQyNTk0NDAwNjUxMjU0NDI5NjQwMTQ0NTM3MzkzOTE1OTQxNTMyOTA5MjM5Mzc3MzcxMzY4MjMzNTUzMTI4OTI1NTc5NzUzOTkwMzUzNzA2MzE1MjEwMTQ1NTQ5ODAxMjkyOTE1ODI0ODY5NjgwODMyMjg4ODgwODMwNzkxMTgxMTYyODYzMTI1ODM5ODk0MzMwMzcwOTczOTcyNTI1MDYxNDAyMjQ0MDQxMzAzNzExNjA2MDgzNjU3Nzc2MjU1MzgxNDgzMDM5MTczMDYzNDA2MjAwMTk4ODI5Mjg3NDQxNTEyOTQ3MzgzMDgwNDc4MDA3MTEwMjgxNTgyNzc1MDAzMTcxMzQ1Mzc1NDA3NzI3NTk0ODYzNjU2NTgwMjQxOTQ0Mjg3OTY4NDYzNjQ0ODYxODcxMDUzNDMyNjYzOTgzMzgwNjAwODA2MTE2NDMxMTAwNzExODQ5OTIxOTM1OTM2NDM2MDU3MDkwNzU5Mjc3MzQzNzVcIiwgXCI0ODg0NTkwNDkzMjU0OTQ2OTMyNTkxNTk0NDQ1MDc0Mzc5ODMzODE2NDU3NTcyOTE4NTgwOTI5ODMzNzE2NzIzMzQwNDMwMjk2MTU5NjU4ODI1NzQ0MDk4MDg5MzI1MDkyODUwNzk0MDEyMzk0MDMyNzI0MTQyNzE2NTI2MTc0NzQxODQzMjE4NTIzODgzOTcwMjE4MzY5MDk1ODU2NTkzMjc5NzQ2MTEyNzM4MjA2NzYxMjg2NTA4MTA5MDc1OTgxMDY1ODg0MzM5Mzk1NDE2NTQyMTU3NjY4ODgyMTIyODczMTE5NDMzODcyMzI2NjQ0MTczNDc4ODM3MTcyMDM2MTEwOTI0NTA5NzE3ODYwODM4MDYzMjM0MDQ0MzIyNjYxOTcyNTA5MTk4ODAyMjU4OTIwOTkxNDY3MjI0NzQxMjQ4NzQyNTY1MjMvMTA3NDU1ODU1NDY2MjY3NDEwOTIzNDgwMTQwODk4NTUyNTk4MzA2Njk5MzQxMzY2MDMyMDk1OTA0OTM4NDMwMDg0NzY4NjI0MTQ4ODI5NDczODQ4NzYzNzYxOTM2NzAzMDcyMjUzODQxNzUxOTY2OTA2MTQyMjgzNjQwMzc5MzM2MTMxMDgzNDYxNjQ2Nzc3MzkwODc0NDA1MzIzMjk4NDA2NTE3MjUwMjMxMzg5NDkzMDg0OTE4MDY1MjQzMDc5ODE5ODk4NjkxMTQ2ODQxNjk1MzUwNTg5OTkyMTcxMTAyOTM5MDQ2NzQwMTY5MTk4Mzk0NjcxOTY1MDY5NzQ3MDQyNjIxMjY1Nzc1OTQ4MjE3MDU0NTE5ODU1MzQ2NjE3OTY3ODY2NjE0MzAzNDk3MjU4MDQyNDM5MDUyNjgxODQ5ODY0MTkyMDAwXCIsIFwiODQzMDM3NDA2ODU5NjQxMzc2ODk3NTMyNjMyOTMxMzY0ODY4MzIyMjc0NDc4NzA5NzM3MzExMTQ3Nzc4ODc5NDY5MjQxODkzMjA1NjkwMTIzNTE3NDAxOTMzMzM5Mjg0NTUyOTgyMTcyMjQ4ODk4MjQ0NzY4Mzc5NDc0NjUxODcxMjA3MDYzNTA2MzM5NzQ2NDkwNDQ4OTQ1Mjg0MDE2OTQ3MjU5NjQ5NDQzMzg3NDQxMjcyNjcyMzA2NTU2MDM1ODQwNTAyNzc2NDAxNTI3Mzc4OTA1MzA2NDgzMDUyODkxOTA5MTQxNDUzMTQwMDU4OTg1MDcwNDM5NTg4NzI1MDc1NjQ1Nzc4MDg2ODY3NzU1MzA2ODE2NDkzMzI5OTgwMjk0NDM5NjU3NjM2MDM1Njg5Njc1ODc0NTAzMDk1NTkwNzI1ODIzMjI1NzM1ODA1NjkzMTY4MDYxNzYyNjYwNjcxNTM5Mzg4NTM3ODg4NzY1NzM3NzI4MC8xODUwNDgwMzU4NTgyNzQ4NDEyNzY3ODkzNjU2Mjk0NjY5NDg2MzkwNzY5MjQ2MzQ5MzQ5NzA2MjAwODY5NDQ2Njc5MjEyODEyMjY0NDAwODc2Njg1NzY0NzYyMjExNjU5ODQzNjU4NTQxNTY3MDcxOTc3ODEzMTEwNDk2MzI5ODUwMDEwMjg4MTc5NzAyNTg5NTAxMjU1MzY3MzQ1OTM1Mzg5MDUwMzczMDIxNTkxNTcyNTM5MjYwOTUxMTQ5Njk2ODAxNjY1OTUzMTIzNTk3NTIxOTgzMjU3ODUyMjA3MjgwOTcwNTc3Mjg3NDcyOTMyMTY3MzYyNTIxNzQwMjMwOTczNTQ3MDcwMjY0MjczODUwMzgxODk2Nzg2ODIyMTI3MjkwMzk3MDc1NzU4NzgwMTc0MDgzNDE1OTIzNDgyNjQwMzEzMjc3MzQxMTIwOTM4NjkwNTk0ODU5MTE4NjAzMDE3OTMwNTAwMDE0NjQwMTY5MjExMjM5XCIsIFwiNTgyNzM2MTU4ODI0OTE5MjU1NDA4ODE3ODQzMjgzNzA5NTc3MjA1Mzk3OTcwMTA4MTYxMzAwMDczMjIyMTE1MTIwNzA2MzQyOTUxNTQ2MjY4MTM0Nzc0OTg2MDc3NjEyNjA2MTMzNTM2MzM5OTY0NTE3OTc2ODYxNDMxMzE4OTM4ODQ1NTk5MDk2Njg4MDU2MjgyNjk5NTk5MDEwNDQ5NjE2NjY1MzU1MzM4NzYzNDAxMTY3Mjg5ODIwNzI2MjY4NzUwMTAzOTExOTUzNzI3NTkxMzU0Njk0NDYwNDgzOTQ4MzUxNDg2NTQ0MDc4NDYyNDI3MjE0NDM4NDUzNTE4NTUyMzQzNDc0MjIyNTY3MDA4NjQzNzAyNzMwOTI5NzE4MDQyMDc1MTQ3MzY5MjQ3ODc1Nzc1NjkzNTU5NDk2MDEzODU3MDU1MTcxNTIvMTI3NjMxNzIxMzgzMjg0MzI5ODQ1NzM4Mzc1Mjk3NjQ5MDI3MzA0NDg2NjY1OTQwOTc0NjY1NDQ2NTI4MzA3MDM3MzcxOTU4MDQ3NDc2ODI0NTA1NDg0ODgxNjIyMjczNjQ1MzgwNTI1ODU0ODQ0MTg0OTE5MTQzMjM2NTgyMTU0MDYzMjczNjM4MDUzNTM1NDAyNjYwNDg5NDMxOTc4MjI4Mzg5MjUxODQ5NDI2MDAzNjc2NDcyNzg3NjQ5NTI4MjY2NjQ2ODQ4Mzk5NTM5MDI1Njc2OTQ4MzI2OTA2ODM0Njc2MzU3Mjc0MDk5NzYzODgyODAwOTIyNjI4MzkxMjY3Nzk3MzAxNjg4ODk2ODY2Mjg2MzAzMDI1MTkwNjMyMjUwMDc0OTc3MDcwMjg2MDA4NjU2MjQxMzM5NjgzNjM5MjE5MTUwMTY2MjVcIiwgXCIyNjg1Mjc4Njk0OTQ3MTUyOTY5NDY4NDA3MDU1MTA5OTU5OTAwMTYwODA0ODM1MjI4NDY2MjE0NDc5NTI1ODkxMTAzMTI4NDU5MDY1MTMxMjIxNzM2NzEzNTg1MDM4MTMwNzM3MDk5MDY3MDQwMTk2MzI2ODE1MjgzMTcxODU3OTc3NzA2OTc5OTkwNDY3NDQ0NjIyNTUwNDk3NTY1NTIxODYzNDQxNjE3MDAxMDk3MzU0NjQ5OTcyNjYwMTgzMDM4ODUwMDMzOTUwNjQ3NTk0NzU0NjQ0OTk3NDM2NjI0NjIzMzI1MDAzNTM3MzA4NDI4ODI4NzUwMDA4MzA1NDY0MTc0NDQzMjEwMDc5MDU5MjUzOTIwMzgzNDExOTEwOTExNTk0NjM2MDQ1NTE3NjYyNzk2ODExMDAxMjg1OTg0NDQ3NjcxMzcxOTQzMjY3NDE5MTUxMjIwNTE4NzI2OTQwNDU1NzU2ODMzMDQwOTM0NTA2NDE0MTMzODg4LzU4Njg2NDgxNjA0NDk2ODk5NjgyNTkwNzQ4ODcyMTY3ODMwNDIxMTI5NjI2NzM3MTkzNjQ2MzI3Mjk1NTQ4ODA3NzY2Njc5NjI4MDAyODEyNzMzMzIyOTQ1MzM0MjM1NTU1NDQ1MDcwODI4NDkzNDIyMTQ2MTk0Njk5MTU1NjIxNjA5NTIxMzYyNzA1OTA0Nzk4NDE5OTA5MTYyNTkyMTQzMjExMDkxMzA5NjI1MzM1MjA2NTIzODc2NTI0MDA2MzU1NTM0NzI5MjM5MzQyNzcyNjc1ODAxMDg4ODU0NjQyNzQxNTI3NjA0NjIzODI5NzM4MjQ3NDcwODYxMjUyNjc3MDA1NTQ4ODMyMzAwMzY5ODY0MTQ5MzkzOTE0NTYyNDE4NDk0MzM4ODE1OTYxNDExMTM1MDgzOTU1NTE0MTIwMjAyNDk5MTg3NjIyMTg3NDExMDY0NDg3OTY3NjYwMjkyNDczMDUwNjg4MjM4NDYwMzQwOTEyMTYyNVwiLCBcIjI3NzAwMzQ1NzEwMjY0MzQ3OTU3NzU4NjM4NzQxOTUyMzk0NTMwNTM4NTk4MjI1OTA0NzcyNjY0MzkxMTczMTE5NTk0NjE2NjgwOTk2MDMxODg2NjY1MjE4MjIxMzkyNDUzNjI4ODI0NTcwMjU2NDM4OTYwMzQ5MjIwMjYzNTc1NzQxNDk1Mjg1NzgwODQ1Mzk5MTg3MDEzNTgyMTY5OTA3NTE4NDYyNDM3OTY2OTYyOTIzNTkyNjAxNzIxMTE5MjU4NjYzNDkwNjU1MDEzNDE5Njc1NDY5ODY0ODA5MDA0NTYyMjcyNzk5MDEyMjI3MjkzOTc0MjU0MzI5OTI5NDA0MDM2MDcxMDU1NTI4NzY2Mzk3MDc5NzQzMjAwMTc5OTI0MjQzNDc5MzcwNTk0OTczNjI2NzY0MzMwODU1NDkzNzg5MTEyNDE0MTkxLzYwNDA5OTc4MzkwNTEyMTM1NDEwMDEyNzkyNzYyODc0NzgzNDM4NzQxMDc2NjAyODc2NTE3MTE2MDkwNjcyMDUxMTE1NzQ3MTg0NDIyMjkyMjQyMTIyNDUxODc2NTUzMDAzNDg0ODQxNDQwMDEyOTg0Mjg5NTgwMjUwNTIxNjIyNTM4NTQ2NzYyMTA0NTE2NTc0MjU0Mzc1ODgyNDQ2NzY1ODk5NjU4MjAzMTI1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiwgXCI4MDE2MDI2OTc4NzU3NDI3MDk1MzAyMDQ4OTIxMjYxOTc5MTgzOTY0MzIwNzc5Mzg4OTAwOTUwMzIzNDg3OTY4MzQ5NDkyODM5NjIzMTc2OTE2NzA4MjM1NTE0MzU2NDcyMzI3NDU3NjE2NjYzODg2OTQzMDU3Mjk3NzQ0MjAyMDIzNjI5OTMxOTcxODY0Mzg5NDg3MTczNjUzOTEwOTgyMjE3MzUzODI2NjI3ODE2NTI3NjU5MTk2MjIxNTkyNzgxNjU0MTE2NTU0ODY5OTM4MDEyOTAxNDg0MDk1Njg5NTkzMTI4NTIxNTQ4MDM1MDMyMTI1OTA1NDM1OTgzNTQ3MjMyMDM5NDA4OTY0Njc2NDM2MTgwMjQ0NTA2ODc5ODQ1MTc5NjUyNTg5NzMwNDIyMTUyOTg1MDEzMzQwMTc2ODAyNzQ2OTEyNjQwODA5MDU3NzEyMTE3MjIzODgwMjI4MTA3OTkxNjI1ODk1MTc3MDEzNTQ4NTY5Ni8xNzQ0NDk1NzA4NDkzNjQ1NTU1NTA3NDg3NjcyMTgwODI0MTMxMTY1MTY2ODgwMjA5MTgyODU4OTkxMTMxMDI1MzcwOTUxNzIyNjcxNTg4MDcyMjk0ODI2Nzk3NzU2MDM4MTQzNjMwNzE1MjM0MjgyMTMwNDUyNTA3MzY1MTM3OTc2MzE0NDI4MTY3ODkxMTA0NzI3NjM4OTIzMTcxMzg2MDM5Mjc5NDk3NTQ1MzUxODEwNzA1NTU2ODc2NTAwOTQ4Njk3MzAxNzM0MTQ3OTU2MDE1NDc5MjM0MDg4ODc4MDMzNzAyOTQ4MTY0NjA0NjIzMzk2NzkyMzI4OTQ2ODE0MTI5MzY5OTIzNjgxNTE5NjU1MzgxOTM3MzgyODI4MDM5ODQ4ODk2NjY2NTk5NDA5Mjg3NzY4MDg2MDY0MzI2NjkxNDg2MTgzNzYzOTMyMjYwNzc2MTgwNDc0MDI1NjkyMDQyOTUxODQzNDM1MzgzOTg3ODI4MDg3NVwiLCBcIjIzNTI4MTY4OTcwNzI2MjM0MTYyMjAwMDIxMzQ0NzY5MjExMDg0MDU3MzU5NTUyNjY3MDM1MTkyNTIwOTUxNTA0MTI0MTkyNjQzMTcwOTE3ODUzMTc4MDMwMjQwMjg1NjU4NTE0ODc4NjE5Nzg0NzcyMDg3NTUyMTE1ODk4Njc4MDMwMDk3MDA5OTY4MjgwODI4NTA3OTYxMDM3ODkwMDkxOTQ3Njc4MTM2MTE3OTg3NjkyOTc2MTc2NzQ2MzEyNzc4NDc5MTAyMzgwODgwNDAyNTcwMzc2NzgxMjYzMTY4NjY1MTc2MDEzODgyODk4Mzc1NzU3NzgxNjUzMDE4MjgxMzcyNTk5NDgxNzMyOTI2NTg0NjI3NjU2NDU2NDU4NjgwOTQxOTc3MzYzODI2ODM3NzU0MTU2NDUzMDc2NDcwNDMyMDU5ODgzOTQ3MDAvNTEwOTczNDExMzE2NjkwMzEzNDg1NjgxODMzOTkxNjQ1NDIzODAyNzc2ODY1NzIwNTgwMjgwMDU4MzQ0MTExMzYzMzYzMDkxNjE2NTU4MjMwMTgyNjY5Mzc2ODQxMzgzMzc1MzIxOTEyNTUzNzcxMDI3MTA3ODkxOTkxMzE4MzEzOTM4NTA1OTg4OTAzNzM1MTE0MTkxMzEzMjE0MzI3NjgzNDQ5NTE0Njc2NzM3Nzk2OTQyMzg5Nzg0OTU3NjU4Mzk1ODA2OTUxNzE1NDU0MzcyNTY4NTIzNTk3NDIwODY2MDUwODI1ODIyMDI4ODE3NDIyODA1MDQ2Mjg3Nzk4MDU0NjgyNDg0MTU4MDExMTQzOTQ5NDEyOTU2Njk3NDQyOTkxODk4OTE0NTYwMTkxNDExNjI0MDQwNDkwMTIyOTUxMzI4MzY0ODMzNzk3XCIsIFwiNjQwMzI5NTU4NDg3MzE2NTY4ODM3MjkwNzQ5NDA0NjIwMjE1MDA0Njc2OTY2NzgzNzc5MDgzNDg5NjMzNDQ4NjY3OTU0MTg4NzU2NzUxNzA1MDQ0NjExOTUxMTY5NTI0ODkyNjk0MTM4MzIwNzQ3ODE3MDE4MjY1MDkyNzM2ODE3NzAwOTY2OTcxNzI4ODE4NDkwMzMwNjY4OTMzMjc0NjEyNzg0NTk1MzE5MzU4NzUxOTU3NTMwNDk3NDIwMzA5OTg3MzczMjUwMjYwNTczOTIxOTAyODk5NTI2NjEzOTM4MzE2MzA2MjgzNzAwNzk4Mjk5OTE4OTExNDgxMDUzNDg1NjIyNzg0ODU2ODgwMDMwMjUyNzc2MDEwMDE2MzM1MDgxNDEyMDU0NTU4NzA3NDg2NTU2ODQzNjc4OTAyMTA4MjYxOTM5ODEyNjcxMzk0MzYzNzg5ODY1Nzg2MTk0OTA5MTU0NTUxNjQwMzk4NzU0NjE0NTkxNTQwOTAyNC8xMzg3Nzk0MjcyMDEwMTExNTM1ODkzMjA1NzAzOTk5NzEyNDM3NzgzMDQxNTUzOTAwMzQxMTEyNDg4NjQxNTI4OTg2Mzg1NDYyODEwNDQ4NDkzNDQ0OTY4OTY5ODQ1MzUyNDAxMDU4MzMzOTI5NzExMjM3OTc4MjIzMjE0MTg2NjkzMTc3MjUxNTY2MDY5NDE5ODA1NzU3NDQwMTc0ODQwMTcwMjEzMTU5NjUxOTYyNjg2NDY3NTIzNTMzOTM4MTQ1NjI5NDQ0NDY4MzY2MjM1NTU0NTk3MjQ1NzEzMTI4ODEyNTMyNzE2NjE2MDg3NzUzOTQ3MjQ2ODAwNjI2MDA2NTA0ODc4MjAzNjY2OTcyNjUxMzg0NzMxNDk4NzcwNDM1NzU1MjI1MjIwNzk2ODcyMTU1MjQ5MjAyOTYwODAxNzY4MDQ4ODU0ODY5MDAxMzEwNzIyOTI3MjMwMjM3MDgzNDE4MDE3NDgyMTM0NTg4ODY1MjQ0NjQyNjU4ODc1XCIsIFwiODI5OTMyNDc2ODM1MTQ0MTk1NzA0NjY1Mjk0NTcwNTk2NjA2MzQ0ODM4NjA2NjU1NTc3Nzk3MDkxNTM1NDkwNDU0Mjc5ODc2NzI4Mjk3Nzg1MjAyMDEzMTUxNDgxNDk4Nzg1MjUyNzQwMDU5NzgzNjg5MzkwOTIxMTUxOTM2MzYxMTM3NDE5NzIyMzYyMTg1MDI2NjQ4ODE0NTAzNjc0NDM2MTQ5NzExMDk2NzczNjM2Njg4NzQ0ODQ2OTY1NDM5ODIyMzk0OTI0MDkyMzE4NzA5NDI0MTQxOTM0MTk2MzQ2NzUwMjQ2MjE5NDIxOTYwODc0NzM1NTc5MTQxNjc4MzIwNTgxMTExMTM0NzYyOTU5MjYyNTA3MzkwOTkyODQyNDE4MjY1NTM3MzcwNzQ2Nzk5NTM1NTExOTE3NjcxNDg3MTI2ODQxNTczMTg2OTcvMTc5NTA5NDY0MjM5MjczNTc3MjU3ODc2ODk4NTUyNjM1MzIyMjQwMDU2NDM4NTkwOTUxNjg4NTI3Mjk1MTMwMzQ0NTYyMDg4NzI0MjA1MTM2MDE4OTQ1MDg0Mzg2NDA1MzExNzEwOTcwODI1MTY1NTk5NjI3NTUyNDQ2OTg2OTU2MjI4MjQzODYwMDEyMTk0MzU2NTE1NTU1MTM3OTU1MDk2MTY5MDYzNTUzNjM1NzM2Mzg5MTY4OTUwNzQzNDk0OTE1MTM1MzkwOTMwMjQ5ODA1NzU4NTI2OTMyOTM0NzQyODg2MzgyMDk2ODAwODUwMzcyODYzNTQwNTA5NTg4NTk0MjU2NDc1MzY3MzUzNDE4ODY2NjMwNzQ1ODE5MDkxNDgzMjMxMDUwMjAzMzc4NTc5NTk2NTE2MjQ3NjA4NzM3MzY1OTAwNjU2NjQwMDBcIiwgXCI1ODQ4OTE2MTEzNzY3NjM3ODE4NTIxNDQzOTcyNjAxNDA4NDQ5NzczNDYzMDU1NDExOTczNjI0MzQyMjcxOTQ3Nzk3NjY2MTI5Mzk5Nzg2Mjk2MzYxOTg1ODk4MTgxMDYxMzczMTkyNjcyNDM0MzE4MTA0ODE5Mjg2Mzk0NDIzNDM5NDYzNDYwMzQ0MzM4Mjg1OTkzMjM0MTY4NzcyNDgzMjYzNTYzNDU2MzE2MTExNDg3NDkwMDU5MzcxNDQ2ODQ4NjI1MDIxOTgxNDcwODc3MDI2Njg1MjQ0NTA3MDkxMTg1ODg3NDE2MDY5NTU5NjY1Njk0Mjc2MzY2MzAxNTk3OTM0MDk1NDQ2NTM5NDQ2MDg5NTg4MDg2MDI1NTEwNjExODY3OTk0MDEyMTI3MTIyMTYxNTY3OTkyNzMyNTQyNTc0ODY5NTUzNDgyMzY5MTQyMzc2NDQxNTE5NTYyMjYzMzY3NTAyMTI5NTcwOTIyMDQ4MzAzODU0NDE3OTIvMTI2MjU2NzEwODYxNTQ5ODM4Mzk1NDk5MDc4MjQ5OTIyOTg2NDE3NDg4OTg1ODY2NTIyNjYwNTIxMjk0NjEwMjgwODIwMDA3NDk5MDk5MTc2MTkwODIwMjkxMjE0MzcwNjk5Mjg5OTc3ODg4ODEzMTA5NTE0ODU0MTc4MTgwMjY1MzgyNDcxOTcyNTgzOTIxNDc3MDIyNDExNjU3Mjg1ODUwOTExMjcwMzg5NzIwNTA4NzE5Mzc3MDcxOTQ5MDUwMjUzMjQ2MDIxOTIxOTE2Njg1NzE2MzUzMzkzMDE4NDExNjgzNzU3MDY3MDkzMjU5MTAxMTUxNDgxMTg5NjM1NDIzMzk5NjExNjI1MDA5NjE3ODg0OTgzMzE4MTQxNDYzMTQwMTk5ODM5NzI0Nzk3NDEyNTE0Nzg1NzUxNTQ5Mjc3MjMxMjU5MzQ1OTIzNjYyNDk5NjIzNjQwODg2ODgxMDQ4NTcyODMxNzg3MTY4OTc5NjQ0Nzc1MzkwNjI1XCIsIFwiNDc0MzA1NDg2NzQ2MDg1NjQyNTM5OTc0MjA3MjkyNTczMjQ2NTY2MDYyNjM0MDE4MzY5MDQ2NDc0MzIxNzE0NzEwOTQwMzEzMDczMDQ0NTg0MjY3Mzg2NjYyNDk0NzM2MDg2MjQzODkyNTE5NDc4NjYwMDUzMTIwMDA1NjEzMTMwOTYwODY0MjM2MzM4OTgzMzQ3NDAyNjAwNzc5ODY0MzIzNTM0NjEwNDkzNzczMzM0OTc5MTY2NzY5NDg2MjUxNDM4MzUyMDY4OTU5NDU5NjY2MDI3NTMwNjI0NzYxNTMxNDI3MjIyMzY2MDg2MjIxMjUyNzM0NjU3MjgxMTQyMjkxNTIyMzQxNzc4Mzg4NzcxNzQyNjY0MTMxNzkyMTk3MjQ1NjkxMzUzNDMzODcwODc0NTU0OTI1MjI1NDg2NTYxNTcyNTg1OTg4MTQ1NzkwNjM3Ni8xMDIxODQwMDM3ODMyMjg5Nzg4Mjg0NjkxNTM1NTQzMTM4MTY0Mjg4NDYyNzcwMzg0OTYxODAyMjg3MjUwMjM2NTE5OTgzODg3MjYyNzcxOTQ0MTc0NTU3MDg3MjA3NTY2MDMwNzMwNzQzMDc1MzM0MTY5NjI4OTcxMzM2MzU4NzA4NTgwMTI0NDI3ODU3MzIxOTUzOTgxNDc1NzE5NTAzNTc0ODY3NDcxMDkwNjA3Nzk1MjQyMTkyNDE3MTYyNzkxNzYyNTExOTQwODQ4NDkzMTc2ODQ3OTI1ODM4NzM4MjQyMTUzMTc3MzExNjQ5MTMwNzE4ODg2Nzk0MjQ5NjczMjU0MTgzOTA3NjIxNDQ5NTIwNDE1MDYwNjYwNDk2MjI1OTM5OTYzNDcxNzUzMTIyNzY2NDIxMzM4MjQxMjkxNzU2ODkyNTcxODI0OTg0MzQ0NjI1XCIsIFwiMzc4NDY2NDA3NDE1NTc2OTQ2NzcwMjk5OTc4NTAxNjUxNDQ2ODI4MTkxMzM3NTM0MTEzNDg5OTg3ODg5MzA2MTMyNTQ2NTc5MDU4OTEwMTMzNTAxNTU2OTg0MDMyNTc4NjA3MDc5NTI2NzA1NTM4NjY4MTM1NjI0MTIwOTQxMjk0NzExNjM0MDUyNDU4ODgzMTUxMDc2ODg2NDIzMTkzNzkyOTI2MDIzNjc1NDg4MTgyOTAwNTA2NTA1NjMxMDIyNjQwNzM1ODIwNDI3ODY1ODY5OTk5OTYxMjU5Njg2NjE1NjI5NDE5NTMxNjg2NzkzNDAzNTg3NzI4Mzk1MDg0MTkxMDcyNjIyNDM1NTQ2MTUyMjA2NTc3MzgxNjEwOTg0OTEwNzQ4NzIxNDI3NTgwMTgyOTg0Mzc2MjQ4MjA4MjgwMzU1OTE4MzY5NDYzMTg1Njc3Mjc3NzMxMzY3MzA4NjcxNTYzMTU0NzMyNjQwMDE3MDk2MjcyMjg0MjI0MC84MTM3ODMyODE0NzMyMjM1NTk5ODEyOTE2OTQxNzUwODc1MDg4MTI1MjA1MDU5MzE0NTQ4OTU4ODQ0NDI1ODAyODAzNDI0NTU1MTYxNTQ2NzQ2ODMyMTczNDgwMzkzMzY3MTI5MDE4NTA3Mzg3NDUyNzY0NDUxMDc0Nzc5MTk1MTg5MDUxNTUxNTYzODA2MjA0NjYxMzU5NDY2NTQ5NTI4Mzc1NzM3OTc0NzkwNzYwMjc2ODg4NjYzMjYzNTk0NDg1NDMwNjUzMDUwNzE2MDU1OTE0OTc3Nzg5NDE1NjE5ODY1NzkyMzA2OTgzODQzMDU1MzYyMjQ0MzA3OTQyMzM0NjI5NDkwNTYzMjY4NjQ0OTk4Mjc0NDQzNjMyMDYxNjIyNTExMDQ1NTI3NDAxNzU1MDM5OTY2NzA5OTc3MDU0MjM4ODgzODIzMjgwMTQyMTAxNzEzMjQzNzY1OTMwOTAxODc2MDQyNjgwODYzMzQ3OTYyNDU1NTI3NjIzMzNcIiwgXCIxOTQ2NjcxMjU4NTM2ODQyNjQyMzgxNjU1NzQ3Mjk0NjIxNzc2MDcwMDUxNTI1MjA5OTQwMTMwMTE1NzY5MTUzNjY2MzY4OTMyMDQyMTUyMzExNDc3NzQ2NzI4Njc4MTgyOTIwODQyMjM4ODAxNzYzNTY1NzI2MDg2NDU5NDg1MDUwMjM3ODYwNjkzMzk0NDcxNjQ0MDIzOTk5NDY3NjcwMDE3NDcwMzc2NzQ2NjA5ODkyNDg0MTkyMDcyMjk3OTM4MjU0ODk4ODgwMzU0MDE0MTc2MzczMjUzODc1NzIyNDEwMTg2NjgzODUyMjUzODI4Mjk5NjY5NTMwMDIyMTY2MzYxMzA0Mzk3NjMxNjY3MTMzNjg5MTI4MzU4MzY1Mjk2NzAxNzU3NzgyMzgyNDc1NjkyNDY1OTc3Nzk0OTYwMTA5NjkwMzYyNDYyMzMwODU3LzQxNzc3NDAzOTY5ODQwODU4MTAxMzAwMzg4MzkyOTEyNzUxMjA2MjMyMTYyMzg3MTQ4NjM3OTEwMTQ5ODk2ODE0NTY3MDI2OTE3NDgzMzUwNTA4MDI2MDM4OTg2MDg2MzQxNzQwODg0ODIwOTUyNTQyNzcwNTI0OTUyNjUxNjc2NjczMTQyNzYwMzY0MTgwNjI1NjI4OTA5ODIwOTQyOTExMDc5NDMxMTY2MDg0NDEyNTM3NzcwMjAxNjA1Njk4NDU3MzY3MTAyNDAzNTIxMzA0NTQ3NTEzMjEzNDg5NjgzNTgxNDc0NjQyNTg2NDMwNDkwNzk3NDAwNTk1MDE1NTY1Nzc4OTE1NzQ5NjM4OTIzNDkxOTEwNzc3MjIwMTMwNTY3MjQyMTk4MjE5ODk4NDYxMzYwMTUxMTM4ODQxMzM4MTIxNTIyMDkyNDQxNjAwMFwiLCBcIjMyODU3ODQ4NzcyMzM3NzE1MzYwMDgyMTgxMzQxMDYzMTQ2NTIyNTE1OTU4OTcyNzMyMDg5Mzk4ODk5MTcyOTMwNjY4ODY2Mzc3MDY5NzUyODE1NjYyNTM5ODE3NjkyOTI4ODYyODkzMDQ5NjMzODAzNjgxNTkxMDY2OTU3OTAxOTcxOTYzMzEyNDgzMjE2MjAzNTU4ODU4MzI0MjMyMDUzNzQzNTU1NDEwMTg0MTQwNjU2NjAwOTIxOTA1OTA0Mjg4ODQxMjg5MzM1MjQxNzQ0NjQzNzIyNzQ0MDA3Njg2OTQyNzU3NzcwMTcwNjcxMzU2NDIxMjE4NTE2MzAwNTY0NDExODg2OTQ5Njg2OTk4MDkyNTIxNDQyNDU5MTI2NDg3MDM4ODIzNzA3OTc3NjUwMzU0NzMxNDU4NzEzNzcyMTYzMzkxODgyNDY2NDk0Njk3NDU3MTgzODYzNDg2MDM4Njg5MzQwNDM2NDQ5OTk3Nzk2Njg5OTA2ODc3NzAxNjA2NC83MDM4MjY5NTkyNzA5NjYyODM0NzYzNzQ1NTAzMDk3MDY0NDYzMDk0Mjg3Mjg4ODMxMTg3MDEyNDg5NjU3NTg3NzU4NTY5MjI4MTYyNDE1MTEwMzIwNDU1MTk0Nzc3NjkwNjUxMDM2NjUyMTk3MjgzNDM1NzAzMTc3NzI4NzUwNjg0ODg4NzYwNzQ1Nzc1MTY2NzgxNjUxNDIxNjkwNzMzODMwOTM3MjkwMDMyNzkxOTQxMzM3MjA0NDYyNTYwMjU1NTg2NjI5NDMzNzY3MjAyMjM2Mjg2NTE2MTUyMzY4NDA1Mjk0MDEyNjUwOTg1NDg5NTMyMDEzMjgyODAwOTU1MTAxMjYzOTE1NjM0MTg3ODA3MzY4MjUwMTE4NTY4ODQ2MTcyMDY2NDgwMTgyOTkzMzY4OTI4MDc1MjYyMzc3Mzc4OTM3MzE5OTIxMDQ3Mzk5NTgyMzM2NzE5OTc5MzQwNzA0ODc0MTE5MTc4NjM3Nzk5MzM5MDk2NTI5NzY2NDg3NVwiLCBcIjI2MTcyMDE0NzY5MjEzNjg1MTc4NTc5NDIzMjY0MzIwOTA4NzY4NzQ0MTQyNjk2ODkxNDA0MzkxNTE5MDc5ODI2MzE3Njg5NDY3OTkyMDA3NDQ2NzgwNTU5ODA4Mjc3ODk4NTk1NzkxOTY4MzI3MTg4NDkzOTMwNDYxNDc2NTY0NDc2NzI1MzE4NjEzNTM0NTYzNDM4MjExOTY4MTI4ODE4ODIwMjMxODg4OTg4MTUxNzk5NDc2NTEyNzQxMzExNjY4MzUxMzM5NjU2MjkxMTU3NDkzNjg0NDE2MDU2ODAzODM2MDUzMzEzMDAwMzA4ODY2NzYwODE0MTg4NjczMDUxNzAwMTIwMzI4MjQwMTE5MTI1MzE2NzM0NjgyMTU1NjE1MDY0MjM4MzM5MTE2MjEyNzA2ODAxMDQwODM1MzM5MTc1NjI2MjI2MDA0Nzg1NDgvNTU5NTY3MTIxMDg1NTM0ODY1MTg5OTc2ODc1NjAwODQxNzE3MTYxNjE3MTUzNzc2OTA0NzUyMzUxMjMxMjEwOTcwMjQwMzIzNDYwODAwNzg1NzI4NzM5NDEyNDc0OTYwNDIxNzcwODA2MTYyMzYwMTI1Nzc0MDAwNjI1MDM1NTIyNDI4MTYwODM3ODU1OTQ0MjE1NDE3ODIxMzI0NzU4ODczMTI3NTY3NjU0MjQ0NDY1MjgxMzU0NjU0Mjk5MDY4NTQ2NTcwNzg5NTQ3NjkxMzQyNjA5NzkzMDUwMzAxMjU4NTMyNTg2MTMxMDEzNTg1OTU5MTY0NzE5NTMzMTIzODI2MjAxOTM3ODAxOTg2OTQyNjA2ODQ0ODU0MTIzNzY5NTMyNDQ3NTcwMTA3NTI1MDgxMDg0NTMxODQ4MzE4ODc0ODM1OTY4MDE3NTc4MTI1XCIsIFwiNjM2MjI1NzM2MDM4OTg2NTM3NTU5ODgwMjY1OTg4NDMxNzMxNTI5ODM3NDUxMjg5NzM3NTQyMzk1NDk0NjgzMzkzNDkyMDQwODA4NTY1OTA1Mzc2MjM1MDc0NTM0MjA3MDI2NTM3MTQ1NDA4NTYyNzg1Mjc5ODIzNTQ3NjU3Mjk5NTY1NDQwMzA5NTEwOTMxMzM2Mzk0MDMxOTA0OTIwMDU2NDY0OTU5OTc0NzQzNTI1NjYyNDU5NDMzODg5Mzk4MDAzNjgzMDc4OTY3NjQyNjUxODEyMDgxNDUwMjI3NjU0NDc4MDk1NDIwMzA2ODgwNzYyNzUzNDAxMTExMjYwNjMwNjU0MDQ5Mzg5MTk3NjAyMzg5OTQ5ODkyNjM2OTQzOTcxNjkwMjEyNDg0OTgxNjcyMDEwMzk4MTA4NDI2MDAyMTM3MTE0ODE5ODM4Mzk5MjIyMDk2NTM4OTIxMjI1NDU4OTEzMjY2OTkzODgxOTYwNzMyNjYzMzk0NTY2MDI0MDY0LzEzNTc3NjUxMDE3Njc5Mzk3MTA3NDExNTEzMTY0ODYzNzUwODc1ODk1MzA1MDM5MDU5MTc3MzU3NDk1MTMxNzgwNzkxOTA1MTYxOTY5MDMxMzMzMTE5MjAyNzg3MTE3NjE2MDQyNDY2MzgxMTExNjg0OTg1NjQ4OTE4NzU2MjcyODQ5NjA5OTc1NzkxMDU0MDM2MjcwMzg4ODkzNzc2ODU1NTgyNDUxMzc0MDExODk0MTM4NzgzMTgyMjkwMDE5ODAyOTI2NjIwNjMzNDM1MDQ0ODYyNjczMzEzOTEzNjA4MzQwNDQwNDEyMDIxMDg5Mzk4NjY1NDQyMjg1MDE4MzgzNzk3NDc3MDY3NTYwMDk1MjA3ODk1NjMyNjMxNzY5ODk5ODEwMzc3MDgzMzA2OTcxMjYxNjgzMjY1MDQwNjIyNTgyODk2OTAzNjc4MTUxNDY0NTczMTAyMjYxNjIzNjA4MjE3NTU4MjkzNzkwMDczMTQxOTU3NTMzNzQ3MzM4NDEyNVwiLCBcIjI2NjY5NTc3MTkzMzEyNDYzMzY3NzM2NzE0OTM4OTY0MzQxNzYwODQ2MTM2Njg3NDMxMDU4ODg4NDM3NzE1MTUzOTMyNTg1NDU0NzgyNjM3MzcxMTA5OTUxNzg3MzcyMTYxNjU0MzU3MDYwNTkzNTk1NDMzNDk0NDAzMDgxNjM4Mzg1ODQ4NTI5NjU0MjI2MDE1Mjg5NDAzNTk3OTE0MTI2NjkwOTA1MDI2NzQxNDA3Mjk4MjA0MjA5MDM0MTcxMjAzNTUxODY4NTk5NzQ4NDI1NzMyNjIxMjQ1NDc0MjgxNjk3OTgwNjQ2MDI4Nzk3Mjc1NzYyNjEwNTUyNjkwNzUxMDE5NzMyMTM1MDg5NTg3MzQ3MzY1NjIxNTk0MTAzNDYwNTc0NjQ5NDE3MjMxNjA4OTYzNjIxNjkxNTgyNTAyMjMzOTg1NTMwNDkyNTUxNTY4NS81NjgxMTcwNjY2NTIxMDM1MjI4MzM2MjYyMzcyODE5MTIxODY5ODI5NTA1NjE3NjYyNTIxNzkzOTUyODMzMjI0NzUzNzI3ODYwNTExMzQ5NjE0NzYzMDE4NTU0NDAwNDY1NDU4MzQ0MTQ0ODMxOTI2MDU3ODY1OTkyMjkzMTc5ODg0NTQ5Mzc1NjE4OTQwMjgwNTE3MzAzNzQ5MTY0NTQzNDA1MjczNzQwNTM3OTY3NDYwNzUxNzY1ODExODQyNzYxNDA5MDMzODkzODUxNzk2MzIxNTgxMjQ0NDc3OTE4NDE5MzkzMzc0OTUyMDMxMzY3NjU2NDE4NzUwNzU5NDI3NDU1MTc5MTM4ODAzOTEzOTQwOTIzNTA1NjExOTc4ODI2MTY4OTA4NzgzMTIwOTQ0MTc3OTg3MDg3MzMwNTIzMjAyMTcyODAwMjY1MTk3OTc3NlwiLCBcIjM1MTE4MDY2ODMxNjE2OTc3MDg0OTc1NDc2MTc5NTc3MTkzOTAxODk5ODI3NjEwMDIxNTQzODY4ODE1ODAxNjA4NTY3OTI3NDI5NTIzNjUxNTk3NjQ4MzA0MzM1MTE5NDk2NzgzMDQyODE1Mzk4NzUzNjYzNzgxMzExOTU2NzAwMDQzNDU1NjgwNDc2OTAyMTYxMjYwMDEwNjcxOTQ5MDQ0NDYyOTUzMzY3MzQ5MzE2OTE3NDM0Nzc1MzE4MzA4OTIwMTU2OTA4MTYyMTA3NTI3OTU4MDYxMjAzMDMxOTg3NDU2ODUzOTQwMTUxNjEzMjM5ODIyMjk5MDgxMDUzOTc4NTc3OTExODAzNDIzMzAwOTgyNDA3MDIzMzIwNzIzOTYwMzA3ODAzODYzNjI3MzU5NjcwMjEwNTUyNTA0NTA2NjY1MzU0MjI1Mjg2Mzc3Mzc2OTUwNTMzMTUxMzcyMzgzNjg3ODc2MDc0MTI0NTk4NzQwOTQxNjQwMjcyMTQ5NTM5ODQvNzQ2NzQxNTY5ODc4NjM5OTgzNDkxMzkwNzQxNjM3ODEzOTg5OTc4ODA0MjAyODk4NDM4NzA4NzQzMjU4MDAwMTUwOTk2MDgwMzg2MzgxMjgxMzA3NjA5MDM4ODMwNjk4NTc5MzU4ODc5MzMzMDc5MjE1MzI3MjAyOTExOTc3NTY4NzI2MjU4NTI3NjQ2NTYwNDk3MDc5NjIyNzAzMDUyNzY1MTY0MDMxMDg5NTkwOTY1MTk5NjI4NTM0NDc3MzgxODQzMDc5ODkyMTIzNDQwMjE0Mzc4OTQ5NjMyNzA3NjY4OTM1MDAxMzcxNjE2NDc1MjgyODgzMDk1OTM5NzUwNzA0MjkyNjE2NzU4NTY4OTY0Nzg2NzM3NzUyMzI1NjUyODM5MjI2MDEzMzM1MDkyMTQ4Nzc3Nzg4NzMzNDUzNzAyNDM4NDMyMjc5MTQ5Mjk4NDgyMDA0MTIyNTkzMjQzODYwODI5MDYwNTU3Mzg2Njk5MjMxNDQ4OTU3MjMyNDIwMTI1XCIsIFwiNDk5NTQzOTUxMjUyNTA0NjUxNzE3Mjc5NDYxNDg3MzM3MTY4NzIxMzc2MTgwNDQxMzIyNzM1ODA3NzEzNDk5NTIxODc4MDc2NzgwMjA1NDI3NTk4MDg2NzU2Njg2MDYxMDA5NzE4MDE2MTc1MjE1MTQ2MzA1NDg5ODg1ODM1ODM5NjczNDE5Njk4NzUxNTMwMjA3NDA0MTE1MDAyMzgzMTgwMDU0NzA0OTI3Njk1MjY5OTIxMDcyMjMyMzk1ODI4MjU4ODI2MjEzNTU0ODA2NTcwNDIzNjAyOTY2NzQzMzM3ODAxNzQxNjMzODY5MjY3NjIwODQzNjI2ODA0MDE2NzQyNDEyMDQ2ODQ0NzcwNjAxMzIyNTEzMTg0MTIzNTE1NDA1NjkyNzk1MzQ2NzkwODEzNTAyODA1MjM4NjM1MDAzMDk5OTc2NjkzNzg2MDEyODE2LzEwNjAzMjk4NjIwMzY4MjU1MDUxNDYwMjk2OTQ2MjgwMzIxNDgzMTU1OTQ0MjM1ODgxMTY1NjQ4NDAzNjk1MTU1OTk5MTMyMjA4NDkzNTY5Mjk1MzIxMTEyMDI4OTM1MjYwMDQ4NDk4NzkzMTgxMjYzMjUwNTQ5OTYxMjIyMDQ5NDMxMTMyNDY3OTU2MjE1MjA3ODg4MzE0MTQ2NDQwNjkzODUyNDA4NzM3Njk2NDkzNTQ5NDI0NTAxMDYzNjE2MzcwNTY5ODIyMDMwODI0Mzk4MDc4OTUxNDgxNTU3OTMxOTUzMzM0MTkyOTk4OTQ1NTIxMTYxMzg5MDkwNTQ4NTk4MTM1MzgzNzMyMTM0MjczMDMwNzgxOTA2MDgyNTEyNTk4MDUwMDk3NTAyMzQ3OTgxMzc1NzAyNDM5NTQyMjA0MTUwMTIwODgwNTMzOTE3NjM3NVwiLCBcIjg1NDA4NDk3MjIyNDIxMjI4MzU4NzMzMTE2Mjk5NTI5ODUyODU0Nzc5ODY3NjU4MTk1ODQ1NTgyMzMzMjQ4NjgzNjMzMTAzMDIyMDYwMDY3NzM4Mjg4OTc4MTY1NDcyOTkyNDU3MjcwODc4NzY5ODQ4NTc3MjY2NTI5MzI0ODE4OTk3NjY1MTA2Mzc0MDM1NzcxNzU2MjMwMzE0Njc5MzM0ODY4MjM5OTQwNDA1NzY0MzE3NTUxNzIyMjA5MjE5MjE4NzcxOTIwMDY2ODUwNTM1NzIyMTU5MjIzNDc0MTg4NDY0MjM0MTk2ODM3MjM2MDk3OTk3MjkzNTk1NTE4Mjg1MjI5NzgxODYyMDg5ODMxMzgzNDU0NzY4MDEyNDc2MzQ3NzM5NzUzMTE0MDU5MTMyNzQ1NTI2MTYwMzcwMDU4NTQ4MzYwNDAxNjIyMTI3NjEwOTkzNDc1MTgyNDIyMDA4MDc2OTIyMjQ0NjA1MTQwNTc1MzA2NTY2NTg2MTY4NTA4MTYvMTgwOTY5NDU3NTk5MjgxNjQ0MDkyNDE2NTc0MTA5NDk5NjUxMTM2MTI4ODQzMDcyNzk4MTE1OTMxNDE5NDAwMDU4NTUzNjgzMjE5MjAwNDI3NDcyNjY1MTgyODc2MDI2MzUyMjk2Mjg2ODk0NDYxMjIxNTYzMzk3NjIwMzU5NjE1MDYwNjUwMzg0OTU5NTYzMzM4ODMxOTMzODI1MTk3NzE2MDI1Nzk3OTg0NjIzNTk5NTY1NDM1NzA4MjMyMTYxMTcxOTY1NDEzNjA1ODI1NzQ1ODc1MzEwNTEyMjAyNDg1OTA3ODQyMDE3MzUxNTE4OTY0MTUxNTczNjAyOTcyNTg0NzMxNTY2MjIxNTc3ODI1MTM3MDM5ODAwNzQ2ODY2NTk4NjYwNDUyOTI2MzA3MTk4MTA0MDAxNDMyMTcxNzU5ODQ2OTMxOTM3MDY1MTg3NzI5NjA4NTI1MDMyMjU5OTI0NzE0MTM5NzQyNzE4NTQzODU3MzM2MDQ0MzExNTIzNDM3NVwiLCBcIjUxMzc3MDU3NjkzMTE4NzIwNDU3Mzg3MzMwNTE5MzIxNjg0ODEwNDExMjg5NTgyNDQ1OTgyMDc4NzU2OTg5MTU4NDQ3NzExMDgwNDE0MDMyMDU1ODQzODA1NzMzMzQ4NTU4NjIxOTQ5MzgwNTU0MDI5Mzc1Mjk0NDUxMzAzNDMwMjY5MTk3MTE1ODEwNDk0NzU4MjEzOTgwODMzMzc5MjE0NDAyNDUyOTkyNjU3NTAyNzc3MDY3ODUwNjMxODYyNDUzMjM5MzQ5ODM1MjE1MjYwNzA1MTMxODY0OTExMTk0NzQwODMyNjk0NDk4MDE0MDQ4NzE3ODcxNDI5Nzk3MzQxMTA0MjI3NzU5NTU3MTk5NzE2OTQ0NTU0MzQ3ODc5NzY3OTE2ODAxMTA2Mjc5MDgxODY0MTI3MTkyNjExNTQ2NzU3NjI3MDM4MDM3NzgwMjQ0NjgzLzEwODY3MjQ2NzQ4MjA1MTM5Nzk3ODI2NTE2MTA1NDU4NDA2ODc4Mzk4MjYzNDk1ODkwMDQ4NjM3NzQxNTg0OTY5MTQ0NDA2MjA2OTAyMDM3NjE1NDk2OTM2NzI0NjgzMjM3NzAwOTc0MzMzODE3NTI3MzUwMTIxMTA2MzIwOTkxMDU0MDU4NDA2NTA0NTcxMzQ3NjgwMDQ5OTQ1NzQ1NDMyNDMyMzg0NTcwNTE1NzIzMDMzMjQ1NDMwMTQ4MTc3MDk3MTQ0ODUwMTU4NzU4NDYyOTY4OTQwNTI1NTY4MDQxOTI2ODYwODU2NzYzODg0NDc0NjA1MDU3MDU2NTUwMTQ2NDkxMDAxNDU4NjQ5MjQ0MDk0MjExMzU0MTUzMTcxMzM3NDYzNDA2MTkyNjUxMTUwMDI4NzY3MDY0NjAwMjcwMTEyODM4MTU5NjI0NTY4ODMyMDAwXCIsIFwiMjUxNzE5OTgyMTU0ODE1MzY1NzkxMDkwNDI0MjI5MDAyOTAyNjIyOTYyMTkzNTkxODc3MTkyMjE0NjQyNTM3MzA1NzI0ODA5MDQ2NzM4ODQzMDk5OTg3MDAzNjYwODI3ODU0MjQ0OTY2MTk3MTgzMDA3Njg0NTExMzM2MzQ0MzQyMTc1NzI3ODYxMjM5NDE2NzE5NTQzMTc1OTgwNzkwODQxMzM1Mzc0MzM3NzU4Njg5Mzg3MjkzMDgyODU0ODI1NjIxNjUxMDczNDkxMjAyNzQ1MDY0MjY0ODc4OTkyNTE0MjQ4MjAyMzcxMzMzNjkzNzI1ODkzMjk3ODUwMzMxMDU1MTk0NTYzMDM1OTY0Njc3NzA4MDA3MzMyOTA5OTI2ODUyOTA2NDQzNzEyMDAwMjU2Nzc1ODY2NDQxOTQ0MzM3NDExMDk0MTgyNDEwNjcyNzIxODM0MTc5NTEwMDc0MDMxNjk2NzM4NjQ5NzA5MTA1ODkxNTA2NjE0NzYwNDQ4MTI4MC81MzE1MjQyNjAzMjQwMTY5NjkzNzA3MjgwNTc3Mzg4NTEzNDA3OTI3MDI2NDA5MTE2MzE4MDcxNzg2NTQ3MjMyMjQ1MTExMDgwNjU2MzM0MzMwMjc3NzMzODg3Njg4ODkwMzUwODM3MzQwNDEyODkzMDgxMjQ5NDMxMzAwOTk1ODA3NjU5OTUxNDk4NjUyODgzMjg1NTA3NTEyODkzNDY4NjY0Njc3NTU4ODEwMTMyMTcyODcxNzUzOTIxMDEzMzQ1MzgzOTI1OTY5NTYyNDg5NTI0MzA0Mzg2NzMyOTIxODY3NzkwMDYwMTU1NDk5Mjg4Mjk5NTM5Nzk1OTEyNTAyNzQ0NTc2NTgwNDI5MjY1Mzk1NDE0MjI2OTc4NTIzOTAyOTQ4ODY3MTk3NzAwMzQwNTg5MTY4ODY4OTQ0MDgwMTU2MjQyODgxMTU3MzIxNTQ0OTI1NTQxMDU1MTI5MzY0Njg1MjAyNjUzMDUxNjIzNTg2NjU0OTE4ODA5Njg2NTI2ODdcIiwgXCI5MzcxNTk0ODUwMjc1NTMwNjkwMjA4MDU4NjQ1NDczNDk1NTQ1NDc2NjE2OTM4MDMxMzc2OTYxMjUxNDA1MTAyMDEyOTc0MTcwNzcyMzMwNjE0NjIwNjg5MzAwNjE5MTUzODE0NjgxNjA2Nzc1MDA0NDU1MzU5NzE4MTg2MDk2MzE2NzQzNjEwNzQ1ODc3MzIxODMyOTc3NzU3MjgzODkxMjQ5NjY3MTM3NDk0NTA5OTY2NDMxODM5NjU3OTU4Mjk3ODAzNDU2Nzg2MzQzNTY3NDE3NTYwMzMwMzkyOTM1OTAyNjQzNTU3MzIxMjk3ODkxMTA0MTY5NDM3ODkzMjY0ODI2NjM1Nzk0MTMyMjk4OTM4Nzg0MjI2NDMxMTA4NTIwNjkyMjU2NzE3ODMwMTc2MTAzODc1NzA5MzU4NjMyMjgyNDg0NjQzOTY2MTU5ODgyMjI5NjgxODgvMTk3NTUyNjQyMTk1MTY2NjE0OTEyOTkxMzk2NzcxODQ1Mzc0NjU2ODkxODU0MzU3OTQ4MDA2MjIxMTAwNTg1OTMxNjU2MDE2NjQwOTgyMzQ1MTU5MjA3NjAxMjUzNTk5MjM1MjY1MzUzMDYwOTQyMzEzOTk1MzQ1NDgzODYyMTUyNDg5NzY2OTkzNDQyNDE5NjY4NDkyODc3MzkwNzc0MDE2Mjk5ODc4OTQzNDU0MjQ5MjA5OTE3MDAyMTY5NDgwMTM0MTMxNjEyNTMwOTc3NDUyNTc5NTIwNTY0NDAwMTI0OTA4MzkyMzM5MjYzNTQ1OTExNDQzODAzNjE5OTcyNzY1MjMxMDk0NTAyNzQ1OTgwMDgzMzUwNTY3NTA5MDE0OTkxNzM1MjI3MzkwOTc4ODUwMDQ4MDg4Mzc4NzIxMjEwMjE5MzIxODc3MTUwNzU2ODU1MzcyMTI1XCIsIFwiNTExOTM0NjY3NTEwOTA4MjQ5OTk4MDc1NjY3MjA1MjA2NjI0NzY3NjY0MTUxMDY2MTAyNDY4MjU3NDI5NjA3NTY1OTY3MTc0MzM5Nzg4MDU5MTg4MTQxOTUxNjMwNzI5MjYxMDQ0OTE2MTIzOTIzMzEzOTA4ODM0ODUxMDE2NTQ0MjU5NzI3ODk2NTcxODQ5MDA3MDk5NzE3MzE4MjE4NDQxNzY0ODk4NzYxMTQyMjQ0NjM0NzIzNTY1OTA4NTA5MjUzMDkyNzMxMjc2MDIyOTQ5OTA4MzM0ODIxNzM5MjEyNTkwNjg1MTkyMTUwMDM2MDU1Mzc1ODYwMDc1NjY5ODYwNTA0NzE5NzUyOTQ0NjU5NDYwNjMzNjM2OTQyNTA0MDIzNjg4MzE3MTU0MjM2NzcxMzk1MTUwMDAwNzYwMDM1NTQwNjQ5MjEyODc0MTY0OTA5MDUwMTk4OTEwNTY5NjU3NjY5NzM4NzYxMzAzNTM2NjA4MzUzNjYyOTM1ODQ0NDIyOTI0OC8xMDc3MzQ5MTkwOTMwMDE4NjQxMTk3OTg3MzM5MzY1MDU2NzcxNjY3NDU1MzczNTAwODQ2MzU0Nzc4MDc5ODc4NTU4MTQ2MzIwMTkzMzg0MTY2OTgyMjMxMTcxMzE3NDE5MzU2MTM2MjM3MzQ2Mzg5NTcwNDIyMzMyMjc4NDQ3MjE3MDMzNzczMDIzNTU2MzgzNDIwMzcyNjg1MDQ5NjIwMzYxNDgxMzA5MDY3MDE3Njk3NTY0NzYwNzQ3MDQ3ODM5OTMwNDIyNTUzMzI0NjgxMjE4MjUzMzU5NTg2MzIwOTUyODk2MzUyMjQ1MzY2ODg1MTcxNTgzMjIxODY0MTEyMDQwMDM4NTMxMTE2OTQ3MTg3NDgyNDEzMDMxNDgzMzA5NTM0NTUzNDYxNjEzNzE3Mzk4NTIzMTMyMTc2OTQ4MzIxOTY0MDY2ODMzOTAxMjE1ODc4MTMzNTk0NzM5ODMzOTEwOTYwODQzMTg1NDY0MjQxODQwMDM5MzkwMjA0Mjk1MDk3ODc1XCIsIFwiNTg0Njk5ODA4NTMzMjcwMjg2Mjg4NTQzNzgwNTI1NDg0MzUyMjUyNjQzNTM3NDc0MTQ2MjQ2MjA4NDc0NzYwMzY5NzkyOTA2MDQ2MDQ5ODg2Mzc0Njk5Nzc2MjQxMDU0NTE5NTk3OTYxNDIxMTIyMDAyODUzNjYxOTkyNDcwNzU1MDM0MjQyMDQwNDQ4ODQ1MTIyNjkwNzEwNjExNzY4NzcyMjUzMTU4ODQxODg0MDI5NTQyNDk2ODMxMDc2Mzk3Nzc0Nzk2NjMyNzU0Mjg0NjUyNDI5MDUzMTQ0MTg5MzAwNTM4Njk0NjE5MDQ5MzQxMzg3NTIwMzExMjQ2ODU1NDE4NTM1OTk0MDc3Mjc0NDY4OTY1NTgwNjQyNTI2OTY4MTMzNzA2OTI2Njg0OTY0NTI3ODMwMDMzMDYzODY2Njk5NjIxMTA3MzQyNTc4NTE5NTUwMDE0ODEvMTIyODQ0NTg3ODQ0MTI1MzM2Njg5NjAzODcwNDY1ODM0NDAxOTk2NDYwODEzNjI0ODQzMjEwNzg4NzI4OTE0Mzg1NTE2Mzk0NzA4MjY1ODI5MzM4Nzk5MzQ3MTE4NjE1NTEwMTQyNTg0OTM4OTg4NzA4Njc1NDEzNDk5NjI1MzE0NDc3MjQzOTMzODEwMTE2MzM3ODU4ODQ3NDM4ODk0NDU0MDc3NDkyMzgxODMwODA5NDE4NDY1MjgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiwgXCI2MzI2OTQzMzgwMzYyOTEwODY4NjgyOTI1NDE3MzYyNzIxNTE1MTcyMTI5NzE2NDc2ODA5ODk1NTMzODgxOTkzNzQ3Mzk4NDE0OTQ3MDAzMTU3MTExODA5NjE3NjAzODQ0ODQwNDIxNTk1MzM5Nzk4NzM2MDQzOTU2MjEwMTYyNzI3NzIxMDk2MTk0MDExMTI0NTIxMDU0NzU5MDY4MTIzMTM1NDg1ODc4ODA4OTkwNTg5MDU0MTkyMjA0OTc0NTY1MDI1NDM5NzExMzEyMjY0MzA3NzU2OTI3NDQ1MDYwNDcwMzk5NTg1NTE2NDEyNzAwNzA5OTYxMTA2NjEwMzYzNzEzNjI1MjY0MDE1MjUyMDc0OTMyNzA1OTA5OTkzODc0NzYyNzU2Mjk0MTI2ODc0NzMzNjIzMTA0MTQ2MzQ0Njk3ODg5NzkyMzY4OTUzMDAxMjkyMjcwODI0MjEwMjE5OTkyMTA4NDEzODQ1OTY2MTc0NTIwOTcyNzMzMjA1MDkzNDgxNTk0ODgvMTMyNzEwODc0MDg3MDc1MjIxNjI2MTU3MTM2MTEwOTc4NTM2NDg4MTY4MzEzMTI3MjI4NzAzMDI1NDA4OTQzMTUzNzgyODAyMjY1NDcyOTc4OTQ1NzAzNzQyMTUyOTU0ODgxNDM4MDU4MzczNjg2OTcyNDc3MTk1ODQ2MTYyNzA4OTg2OTgyNzQyNjQ3MDM4MDE0MTQ3OTAzODE3NTM5NDE4NDQyODY5MDExOTk1OTg4MDI0NjM4Mjc4NzQ2NjY0MjMwMDQ2NDUyNTQ1NDk5NzIyNjE0MzIwMjg0NDc4OTI1MDU5NTI3MDg2NjYzNDU1NDc4Mzc0MjAwMzUyMzc1MTIxOTEwMDAwOTY3MDQ0MzY2ODMxMjc1NjgxMjU0NTMwOTE0MzA2MDY0NTM1MTEwNTI4NzIzNDgyMjgyNTAxMzU4NzQ5MDAxNjU3NjA4MTIyMzA3Njg2NDgyNzIwOTI2MTg5NTM3MjI3NDkyMDQxMTM1MDU1MDkwNzg0MDU5OTk0MTE4MTkyNjI1XCIsIFwiMjAyMjQyMjQ2ODI0MjE1MTE5MDM0NzUxMTg4MzE4NTg0MTMzMzk2ODM5MDk5MTQzMDM2MzY2MDI0ODY4NzI4NDAyMTUyNDIwNjA3OTE2MjIxMjAwNzI2MzYwNjgxOTM4NzgyMTA1NTE4MzE5Mjg3MTk1MTA3NjY0NDcwNzExMTgwMjk3MjM1NDEyODAxMTkwNDcyMDU4NjcyOTkxOTgyNjc1ODY1MTE2Nzk4NDUwNzgwNDg2Nzk1NDk3MDA2NDkzODAyMjEwNjQ4NDY1NjU2MDg2NjQ0NzI5MDkzNDEzNjYxMDIxNDE3NTUxNjQ4NzU3OTEyMjMyODA1NTQ4MjM5MjEzNzYxOTgyOTczOTU2MDkyMzgwNzg4MDc3OTg2NTQ0MjAxNjUzMDcxMjk4Njc1MDcxMTE5OTk5ODE5MDE0ODg4NTcyNjE0NDU5NjY2MzE0MzY1MTI0MC80MjM1MjgwMDkxMjcwNzA0NTg2MDM4Mzc1ODA4NDQ1NTkzNDc0OTM3NzUyMzY5NzAyNTM1MTMyMDMxODY5MTIwOTExNDAyNTE4NTg2MDUzNTQyMTg3MTU1MDgwOTEzOTQ1NjQwMDAzMDQ0MDA4NTg3NjE3NTg4MzgxODI2NTQyMDE2NTM5MDE0MDgwNDY5NzQ2Njg1OTkyMTY4MDQyMjM3MjExMTQzMzEwODU1MDc3NTI2MDA4MzIzOTAyMjcwNjg5ODU2OTMwMDYwMTc1OTEzMDQ5MTY1MTk1NDAyNDU5MDI2NDU3MTI1MzI5OTM4ODkwMDAwNDg5OTIwMjY5MzE0NzU3NTQ1MDgyNDgyNjUzNTYxODEwOTk4MTc0Njc2MDg4NjMwNjgwNjg5NTM3NTYwNTUzMzQyMTM1ODQ2NDkxMzY1NDE0OTA1MzA4NDk1NzczNjM2NDdcIiwgXCIxNTA1NDIyMDE3NzY3MzUyMzE2MTg3MDk2NTMzODg1MDYzOTQ4ODc3Nzc4Mzc2NDY2NTE0MDYwMjMxNzQ2NDMyNDE3ODMwMDY3NzYwMTkzODgzMzYzMTgyMTYwNTMwNDUzMDA0MTcwODY5MjkwNjE1NjU4Njg2NjMwMzEyMzc1MDIxMzcxNTA4ODAzMTM5MjI0ODgxMDY3NTEyNDEwMDY3MTU0NDk0NTg3MzY3MjMxMjk1NDU0MDAxMzM0NTAzNzYzMzkxNTYwNjIzODc4NTk1MzYyODk2OTQ3Mjc2MzU0NjgzMzgyMzUwODQ1MzM1NTI1MDE2MTg2NTkyNzIwNDc5NjYwNDA4Mzg1MDkyODY5NDI4MjU0MTQ0NjM1MTExNzU1MzEwMDE0MTA5MjMwMTQ3NTExMjQ3MzI3NDgwOTkzNTU0NzYzMzI2NDk0NTg0NzExMzUwMjc3NzMzNzE1NDE1NzIzNzQwMTYwMzg1MjUzMzY3MjgyNzYwMjQ2NzY2MDE3NzgyOTkyNjQvMzE0NzU2MTg1MjI1Mjc5NzU3Mjg4NTMzOTExNDY3MDIxNzIzNDcyOTA4MTkyNTIyNjg1NTEyMTk3NzEyMDE4NDY3MDE2NTg4NDg3NTQzMDA4MzgzODM2MzcyNDcwMTQ3MDU3MDYwNjYwNTA2NzMwOTYyNzg4OTc5MzM4MzEyNzI2MDc3NzQxMTAxODM0ODg2MTUzMzgwMjE2NTY5MjM0MzMzMzU2NjE4OTA0MTQ3NDA2NjQ0ODA2NzExNjI0NTkyNzE4NTA4Nzc4NTU1MjE4Njk3NDE4MzMwMzAzODQ2ODI1NDk2NDg2MjYwMzgzMTQ2ODY2MzIxOTUxNTg1MDc2OTMzMjE1MDU1MDA4ODg5ODgxODMyNzAyNzYxMzQ2NjcwNzEwMTQwNzUwMTczMTc2OTIxMjE5ODYxNDQ3NDI0NzMxMzkwNzg4NTc4MTY1NzgxMzM2OTM3NzYzNjg4ODI1OTY3ODAxMjA0MDc5NDkwNzYxMjk2ODU3MTkzMTQ3MDM0MjYyNzg4NzVcIiwgXCIxNjI2NjQzNTE0OTkyODMxODI1NDY3ODgxMjk4NjYyNTkwMTE1NDI1MjkwMTcxNTU2Mzc0MDUzMjgwMDUwODQzNTcwNzgwNDgwNzQwNjU1NDgzNDk2MDI2MjY3MjQyNjUzMDc3MzMwMDU3NDUyNDQzMzg5ODI2NjEwOTA1MDYzOTQ3MDgxNzAxMDU5MTYxNzc2Nzk3MTQ2NjQ0MzI3NTQxNTM3OTU3NzI4MTEzODk2MTI3MDAwNTEwMDIzMzY3MTk4NDI3ODQwOTg1MDc0OTgyODYyNjA0NTA5MzkyODkxMDkxMjM3NTk4NTk3MTAyNDg2MjE1NDQyOTYwMDgzNTYwNzE0MTU3MTM5MzE3MjExMDI4MjQ0MzQ5NjQzMzY2Njc5ODAwNjI3Mjg2NTM1NjIzNjk2OTcyODk3NjE5MTM5MjUyMTU2Mzk0MzA0OTY0NDM4MjA0MTE4MTE2NTEvMzM5NTY0MzMyOTg1MDkyMzI2MzIzMjc2NjcyMDY5MzYzNzkyNDgxNzIwNDk2MTk2NDAwOTExODY2OTg2Nzc5NTQ4NzQyOTc4Mzc3NjQyMzUzMDA4MDY4MzYzNTAwMTk1NjU5NzA1NTA1MzMyMDYyMTY1OTA2MzkwMDg2Mzc5MjUyNjY0MDU1MjQ3MTUwNDEzNzI0MDc3MDE5NDc5NTMyODM4MDM4NTQxNTM4NzY4NDQzMjAyODM3MzUyODEyMDk3MjU2NTEwMzY1MTM0OTEyNDYyMzg2MjI5NjcwMzE5NzkyMzMyNjUxMzYyODA2ODc5OTUxODEzNzU1ODI4NDQ3ODA4MzA1MTc4MjU1OTUyNDU1MDYzMjE4NzkxNzc5NjU4Njg3NDc1NDYxMjc2ODUyNTY4Njc0NTYzMTkxMTIyNDc1NzIzNDg0MTY2NTUzNjc2NjcxODc3MTIwMDBcIiwgXCIyNzIyODU4MzcxMzczNDE4MzYyOTQ1MTgwODg4OTE0NzU1OTI0MDI1NDU3MDU1NDA0NDY2NzYwNzUxOTIzODg2NTg5MTA4NDE2NTM4MjA3NTY1ODcwNzY3NTQwNTY3MzI3NjYxNTAzOTcwMjkxNjQ0MzE1Mjk1NDE1NzUzNTE5NTUwODAzMzI4NDM1NTU4MDc0Mjc2MTU2OTEwMTkzNDgyMTA4ODAzNjA4NDQ4MDI5NzQ0MjAxODAwNTk3MjY1MzEyNDI0ODgzODQyMDAyMTQ0MDg5OTM2ODg2OTc0NDE0MTY5ODU1NjM1OTI5NTQ4OTQ3MDQ5OTI0MzQwMjc5OTQ4MzA4MjQwNjIzODEyODg3NTM4NjkzOTM4OTEyMzMzNjMwMzYzMTk5MzU1Nzg0NDU2NTkyNzk2MDAwOTc0NDc4MDgyMzE2NjQ2MjMxNDExNjAzOTQ2OTYyMjIxNjI2MzIyMTI3ODQwMjY3MzAyODIyNTIxNDUzNDg1OTA3Njg1NzQxMzU1NzQ2NjM2OC81Njc1MTM0Nzg3MzQwMzU5Mjc2Mzg3MDg1OTEwNzMyNTMwNjc4MTYzNjA0MTg3MDA5NTY3NTc2ODk1MzMxMTM0NTIxMTMyMDcxMDkyMjkzMTM5MTY3ODI0OTU3MjUzMDUwNjM3MDg1ODg1NDI2MTAwMjA2MzcwOTc0NDc5Mjc5MjkyODA0OTU5MDQ5OTk5NjQ3NTM5Njg0NzY2NjMyMjc4NDQ5MzU3ODkzNTYwNTYxNjA4NjMzMzI5NTYxMzg1NzY1MDM1NzM4MDcxNzI2MjE0NTEwODMyMDY2ODg1MTU2NzY3MDYwMzI0NDI3MzMwNDAxOTY3MDM0ODg5OTY2NzI3NjM4Mjc2MzcxMzIwNDAxMDUzMzAyNDEzMTM2NTUxMTQyMTAzNjc4NDEyNjkyMTExOTczMDI4NTg3OTIyMzk5NjcwNDU2NjcwMzgwMTg5NTcwOTc5NTgxNjc0Njk5MTAyOTM0NzMzNTYzMzMwMzgyODIxNzMyMjAwNjgyMTYzMjM4NTI1MzkwNjI1XCIsIFwiMTM0MDkzNzcyNjgxODY4ODM4NzYzNjAxODY3Nzk2MDUxODYyMjEwNjk4OTMxMTU3NzQ0NTYxNDM0NzA2MTYxNTQxNzgzMTE2MDI5NjM2OTUwMDcwNDUyNDAyMjg2OTYxMjk3MzMzMTQ0NDI0MjAwMDc4ODExMDEzMzE1NzY4OTc4Njk3NjgzNDkxMzI5NzU0NDA4NzI0OTU5MzYwMTQyMDk3MjExMTc4OTU1MjkwNTg0NjE2ODkzMzAxNDU3MDM5OTU2MjQ2MDc4OTA3NTg3MTExMjIyNDUzMzcyMzI1OTY2MDk2NzQ4MTI4ODUyNTIyMDY4OTU3NzI5MDM4Njc4MTE2OTMxNjAwODk4NzAxMjU2NjIxNjIzNTg3Njg0Mjc1NzE4MzIzMzIwNzk0MzA3MTUyMzQ0Nzg1NTYyMzAwMTkyMDg1NDU3MTU5Nzg4NjQ5MTE2MzE2NTE1MDU1Ni8yNzkwNTQzNjg4MTQ1MjI0ODMyNDE0NDY1OTQ5MTE5Njg1MTk3NjA4NjkxODA0MjkwNzk3ODA4Mzc5OTQ4MTI0MzYzOTU3OTI1OTQ0NDk5Mjk2MTcyOTM1MDM5NzUxNjk0ODk5NDUxMzYyNDQ2MDIzNTA5NDE2OTU0Nzg4NjE1ODQyNjE2NjU1ODIxMjMwMzgzNDA4MjQ3MDAyMjQ1ODMxNzAyNzA0MjcxNjM0Njk3NjI3ODk2MDM2NTcwMjU5NTg2OTU1NTE0NDg0NzcwNTA5NTg1NTc2ODEyOTk0OTUwNDE5OTQwNTA5NTE2OTI5MTYwMzI1MDE4ODQ1MjMxNTA5NzI4NDE3ODI2NTgzODk4MzYwNTkyMzYwNDAwOTE2MDU4Mzg1ODMxMjY0MDA2NjAzNDQzNDQ2MDE4Nzk5NjkzNTQwNTMxMzc1Njg1ODgzMzgwOTY1ODkwOTU4NzVcIiwgXCI4OTEwOTUxNjYwMzM5MjQ5NDc5NTE3NzMxNTMwNzczNTA5MDM3MDM0OTc3MzUzNDU3MTg1NDUzNjE3NTY5MDQ2ODg1MTMyNDM0NTUyNzcxNzIyNzI3NDQyNjQ5MDk1MDA3ODI4NDY4ODc4Mzc0MTM5MDAxODA4ODI1NzQxODI5NzI4Mzc1MzcwMTQwNTA1MDg4MTMzMjQ0OTUyMjg4MjM5NjE5MTQxNTQ0NjYxNjk1MDY1MzE4NTY4MDc0ODYzMzE3MDU0OTg5OTgyNjIwOTQ0NjAyMjQ1OTY3MTU1NDAwNzEyNzAyMjU5MTgwNDQzMjM4NDczODg1NjkwMjk3MjgxNTI1OTYwNjE4OTA1NjI1MDg0NjM5ODcwNDA3MTEzMDI5NzEyNTEwMzQ1MjYyMjc5NTA3MDU1MTk3MDI0Njc3MjkyNTIzMjE0NDY3MzA2ODk4NTczOTU2NjA0OTI4NzMwMzc3MzE4MjEwNTg4ODM3MTI2NDUwOTQyMDg2NTI3ODkzNDM3OTU0ODY0MDAwLzE4NTE1NzMyNTUyNTY0NzYzNjI5Nzc2MDQ3NTk2NTUyODQyNjMzNTg1OTUyNTQzOTI3OTcwNzg3MzA0MDExMTM1NTA1MjIyMTQxODIwMzAwMTY2NjA0NTg3ODAxODA2MzY5MzA1OTExNDkwMzQ0OTkxNDI0NjQzNTc1MTExNTg4Njg2MjUzMDk0NDI4NDM3OTIxODkzOTQyOTI3ODc2NTc3NzQ2Mjc0MjU4MTY2OTQ2Mjg4Mzk5ODc0NTY0Nzc3OTkzNDg4NzQ4NTM1NTU1ODY5MzE4NTA3ODg2NDU2Nzc5OTgwMDQxODY0MzczMDAxNzMwODAwODg4Mzk5MzAzODQ0MjQ3OTc3MDYzODEyODI0MzAyMDg5NjE1NjU1NTU5NTMyNTQxNDUwMDIzMTg4OTMxODgxOTc1NjEzMTU4NTUyODYxNzMyNzY1NjQwMzY0MDI1NDY3OTgzMTgzNTEyMjk5NzgxMDMyNzY4NDM4MjIzNDUwMDQ3NTc2NjEwMDU4NzY2MzgwMDUyNzQwMzdcIiwgXCI4NDk5NzY2MzM1Mjk4NzUzNjQxNzAzODQ5NjEyODExMTE1OTIxMDM4NjQ1NTQxOTQzMTEzNzkzMTMwODMwMTk4OTQxNDQ2MjMxMTEzNTcwODExNDMyMjA0NjIzNDcwODA1MzQ0ODA5ODUzODYyOTE2NjY3MjQ1NjcwMzY1MTUyNDQ4MDczODIxOTgyMjg1ODQ2OTEwMDQ1NDkzMzU4Mzc3NDQwNDAzMjk2ODMwNDMyODg1OTM2NTQ4NDI0OTg5NzkxMzY3NjM4MjkwOTA1MDQ1MDg1NTIyMjU2NzE0NzY2MTg0MjE4NDUzODMwMjk5MTUyNjYzNTk3NDE1ODg2MjAzMzI4NzE1NDMyMTkwODQ4MzAwNzUwNjMyNjgwNzQ2OTIzOTc0NTg1MTM3OTU1OTI1OTI2MjQyNTY3NTAzNTc5MDU3NDg0NjIyOTQ3MDA0MTU5NjgwMTM0MzA4NzA0MS8xNzYzNDY4NzU3NTEyMjcxNTUwNzkxNTM4ODA5Njg1NzA2OTM2NjE0Njk4MTE1Njg5NzIzMDYyMDM3MTcxNDUxODcwNzUxODEwNTE1NzQ4MzI4MzI1MzM3NDc5NzEyNzA3NTY4OTIzNjI5ODExNDMzNTczNDg3NDU1MzE4MzI5MTgwNjI2ODE0OTc0NzgyNjA1MDgzODA4OTkzMTM1MTE1ODQ4Mzk4MDczNTMzNjc3Mjg3OTA0NTAyNzIxMzk4MjY2MTYzNDg2NTU1NjEyOTU0ODM1NjQ4NzcyMjUzNzE5MzkxNDk4Njk5NDI4MzcyOTc0NjU3ODA0NDYyMTExNTU4OTE5NTA2NjIxMjA0MzE4NzIyOTYwNjkyMTA2MjAwNzA0Nzk0MDI5Mzk3MjM4MTEyMTIwMDcyMzI5MjI5NzcxNjYyMTIzMTMyMDI1NDMwOTA2MDMyMTQ3NjYwODAwMFwiLCBcIjE2NDg4NDkyNTc0ODYzMTI5MzU0MTYyNzQwMDk0NzQ1MjA1ODk3OTk3NTA3NTc4NzcyNTIzOTA1NDMzMjk4NTEwMjk0Mzc0NTI5ODg0OTk0ODUxNzkwMjY4NDUyOTIwNjgzNzc5NTc2OTc4ODQ3MzkwNTI0OTE0NTU4MDc2ODg0Mjk2MzA1MjQyMTA4MjM1NjA1MjQxMjI1OTY2MTAyNzY5NTc1Mzc3NTYxNDIyNzg1ODUwOTEzMTUxNDEwOTYxNDYzNDE3NzM5ODIzMDI4ODgwMDc3NTE2MzI0MDEwOTA2NDI0NzI1MDY1Mzg4MTc5OTgwNDMzMjY0MTU2OTM4NDA4NjIyNjE3MDEzNjQxMTQ5MjMzMjcyODY0NjI2NTA3OTc5NjM5NjkyODk3NDM1NzE1MTQ4OTA3MjMxNDUyNTE1ODM4ODE3NTI4NzYzNDA2MjgwNzMzOTU3MDg3MTY3MzUxOTI2OTA4MDgzNTIxODg4NjczMzQ4NDI3NDM4OTU3Mzg5NTU3NjIwNjc5NjgvMzQxNTgwNDExOTAyOTYyMTQwNTI5NTQ3NjIyMjY3MzgxODM0NDI1MjY0ODkzMjI2NDQ3NjU4NzIzNjU0MTIwOTIwNTQ5MTY2NDE2MTE0ODQ5NzMxNTg4NTUyNTc4NjI2MDQxNTk3ODQ3MDAyOTQ2MTA1NDU5ODEyMjMwOTc5OTAwNDgwMTM1NDIzNzg3NzE3ODI1Njk3OTU1MTUyMTkzNTI2NzI0MDI5ODkwODI5NjE1ODQ1MzE0NzY1NjA1NzcwMDYwOTc1NTM4NTQyOTc2NTIzMTc3OTc2MTgyNDAxODIwOTI2ODU0NDA2OTQ1MzkyMTY3MTQwMzQ3NDQ0NDMzODg1Nzg2MzQwNDE1NDM3MDA2Nzc1MDc1MTk2MDMxNDMzMzY1ODI3ODc0MjU0NDc3MzUxMzc0MjM2OTMyNjI0NTE0NDY5MjQxNjM0NDIyMzEyOTkwNTU1NTM0Nzg5NjA3Mzc3MDIzMzM5MjM2NDE3NDM0NTc0NzU1NTY2ODU2NDg5MDEzODI4MjA2NjI1XCIsIFwiNDg5OTYyNjY1OTIzMTYzMzQwNjU2OTM2MjE5OTE4NzE5MjM1MjkzMzU2NzM0NDk2MDQ5ODEzOTg1NDQ2MDU0NTY0NDIxMDExOTcyMjg1Njg3MDYzNDY1MjU2MjUzMjA4MzU0NjM0NDk2NTE2NjM0MDA2MzI5NzY0NzUyMDYxMzQ1NTAzNzI0MDE0NDczNDAxNDU3NTE5Njc2NDAyMTEwMjYxNDc0ODIxODgzNDA1NDE1NzE2NTc4MTA1NzQwNTEwMDU3ODY2ODAwMDI5MDQ5MzQzMTg2OTc5Nzg4MzE1NTc2NDk2MzIzODc2MDYxMjMzMzA0ODMzNjk1MzQzNDY2Mzg2NzU4MDg2MjY5MjI2NzU3NDU3NDQ2NTM3MTYxNTAyMzk5OTUzMTAzMDQ0NjI1MDM1MTMwNTA0NjU3MjI2NzY4NjU2Njk5OTIwOTIyOTIwMjU4NzI1ODE0NDMxODU5Mi8xMDEzNTIyMzc3NTcxMjA5MzAzNzMyMjA3MDQ4NTk3OTY0NTU1MjYxNTEyMzQyODYwMzI2ODI3MDI0Nzg2NTAwNjg2NjkyNDc1Njk3NTcwMjg0MTIwMzU5ODQwNzI0NTk2NDQ0MjA5Mjc3OTQ4NjQ4ODYzMDE0NDc5NDYwMTg4NDk2NTg3NzIxNTc4MDc1MTUxNzkzMDgxODIzNzk1MTYxNDA0MTEwODExNDgwMjY5MTA2ODQ2MzU5OTY0NDM2OTkzMTkwMjkzNjE1MzgxNTkzNzU2MDc2NTE1MDEyNTE0MTAwMjg5NDA2ODYyNDg3OTcxMjIwMDIwNzUyNjI4NjUzODQ1MzQ1NzgwNzY2MjQ0ODQyMzg2MTM2NzQwNzY4NDc0NzAzMDA5MDkxNTUyMDQzOTQ1ODQzNjMyMTk5OTk5MDA3MDcwODAwODcxNTg4Mjg5NzM3NzAxNDE2MDE1NjI1XCIsIFwiMzYyOTAzODQ3MzU4MDg4NDIzMDMyMDk4OTM5NTg5MDE5NTk4MDM2NTkzNTI1NzIyMDQwODg3ODgzMTY0MTE1OTgxNzY3Nzc3ODczODYwNzk5OTU1NzE1NTg3NDM2NTY2MjMzMDEwNTQzOTM3NDk4OTIyNDM1OTYzMzg1MDkxNDAwNjcwMzAzOTU2NjEyODgxOTc0NDUwNTQ4OTA0OTA2OTQ5MDMyMDA1ODc4MjQxNjM4NTQ2NzM0NTk3MzA4Nzg2NTE0MDg2Njc4NTYxOTAwNzEzNzQxNzQ2OTA1NzQyODY2NjM1Nzc5NDMyMjE2NzYxNzk5MzcxNzkzMjYwMDI1NTQ5Njk4ODY1MzE5NzYwNzg2OTIxNDQ0NTA1MzIzNzU4MjM1MTY0ODA3OTY2Mjc3MDI0MDMxNjA1NjczNDgxNDgwNTkwMTkzNzI0OTgwNjU5NDQ4NjkyNDg3MTA4ODkyMTU0ODA5NDkwMTk5NDE0MzcwMDIzNjk2NDA0MjU5NjkxMjk5NjE0MTQ3NzEyLzc0OTU5NjAzMTczNzU2MDkxOTIyNDM1NzA4NTA0NzUxNDYxNDQ4MzE4ODE5NTQ4OTQzNTg2Njc2MTU5NTQ1MDI4MDYzOTc5Njk1ODgwOTMwOTI2ODA1NTc0OTUxMjc1NjAyOTUxMDQ3ODQ1OTA0NzcwODI4OTAwNjQ1NzE3NDc3MDk4OTg4MTI0NTUzNDc0NjE2NzY0MDQwOTM4MTIxMTcxNzc2NTU2OTk5MDY5MzUxNzcyMjg2MjYyNTI5NzI5MDU2Mjg4NDUxMDM3NzE3MTk4MjczNTIxODEwNTg1ODY4MzA3NDAyNjkzMjYxNDc5Mjk4OTIzMjA5NTg3MTQzNDY4MjA2OTA3Mjc4MjIwOTA5NDQ3NDgzNzM4NzMwNjU3NDM4OTYxNDM1NTg3NzUyODczODc5MjQ0MTM2ODAxMTY4ODM2NzY3MjczOTM0OTk3NDE3MTU2NTQzODY2NzIyMTcxNzY2Nzk0MTcxNjIzMjI0ODU1MzU4NjQwMTU2ODU4NjA2ODQzNTc2MTI1XCIsIFwiODUyMTM0ODE1NDk1ODYxMzU1MDU3NDA5NTc0NTU5NjY1NzI0OTkyNDMyODMzNjI2MjEyNzI0NDgyNzk1NTg4NjQ3NDc0MjMxOTI3NzQyNDM4MTM2MDY3NzY1NTIzOTAxNzU4MzYwNjg1MTQ4MzMxODk1MTQ0MDY5MTc1Nzg3NTI3MDAwMTI4MzIyOTU4NTA3NTEzNzA5MTYxNzA3MzUwOTA0MTY0NDA5NzUyNjA0NzEyNzYxODk1NDI5Mzg4MTI2NDExMzY5NDM2MjU5ODE1NzQ1Njg3ODc4NDgxNDY5NjU3NzA4Mzk5NzkwMjU4ODkyNjQyMTY3NTg0MzI5MTE1NzA0OTE1MzcwMTEwMDIxODc4NDQ4MTQwNjA4NjgxMDI2NDI0MzE0MzMzNzAxNjA0MjMwMTgwNjM3Njg2NDQyNDYzMjI5MDIyNjM3Nzg4MTIwNjc2NTA1MTg5Njc0NS8xNzU3NTg0NjczMjU0MTQ1MTA5NjE0OTE0ODYyMTM0MjE3MzQ1NDU2MDY1ODczOTA4MjYyNzUzMTY5NDA0ODQ4NjU4OTEzNzc0MzYzNjUwODYzOTA0NjI3MTgzMTA0Nzc3MzM3NDYxNDQ1MDYzNzA0NjU1MTY0MzI1OTMwODkxMjY5ODQzNjY5ODYwNDA5NzYzNTY5MzYyODYzNjAwOTMyMjY3MzE5MzM1ODg5NTQwNDUzMzAyNzg1MDk5NTMyNjg4MjY0NDI1OTg4Njc3MDgyMDQ0OTA1OTQ4MTc5MTUzMjg2Mjc2NjA5OTEwMTU4ODU0MzQ5NzExMDU0MTQ0OTY4MTMxOTM0NzEzNDE5NzcyODUyNjYzODYwODkzMjQxMzY0NDMzODcyODUzMzM4NjMwMjE2MjMyMzEzNjA3OTY5NzkwMDgzNDQ4NDMzNjY2MzM0NzQyMTA4MTc2Mzg0XCIsIFwiMTgwMjQ2MTQyMDU2MjY0Njk5Mzg1NjczMDA4Mjk5OTgyMzUwODE0NTYwMjIzODEyNTA1NDcxNzgzNjUwMTIwMTU0NTkyMDYwNDAyMDM4OTM2MTM3MDkzMTM0NTQ5MTE2MDU0OTc4NzQxMTY2ODI4ODM1OTAxMzA1OTE2MDMzMTM3MDc1MTQ5NjMyOTgwNjQ4ODI0NjEzNTEwMDc3NjI2Mzc3Nzg2MzM5OTA5NjQ4NTg5NDMwNjMwNjYyMTg1MjU5NjY5NDcwMDg0NTkxODYwODE5OTMyOTA5MTg1Mjk1NjMxNTg3MDY2NDUzMTYxNDM1ODM3OTE3NjY4MDMyNjUwODg3NzMyOTg2MjcxMzMzMzMzNjE4ODU1NjE4MTQ3MDkyODYxMzQyMzk3MjMxNDk4Mzk2NDU3ODY0NTY4ODg3NjU1NjM1MTQzMzQyOTQ5NDAwODUxMzgxMjEzNjE1MjU3Njg2NjY1MDE1MjYyMzUxMDI5NjkxMTcwODExMTA4NTUxODk3NDE0MjcyODkwMzQyNC8zNzEyMzg0MzkyNTIwNjQwMTYyMTQ0NDgxMTUyMzExMzkzNjA4MzU0ODE5MjA3MzE2MjUzMjEwODQ2MDE1NjY5OTI0OTcwNTczNzE0MTYxMjE0MDcyOTMyODYwMjc4MzIzNTc4MTYyNTc1MDcyODcyOTU3MTkyNjExNDE0MjYxMzAxNTkyNjk0MzMxOTk4NjIwMDI4NDE0MzMyMzU5NTU4MzUxNzI3NzQ0MzA2OTAzNTI0ODE4MDY5MzM4NjAzOTAwMTU4OTk5NzMyOTkyNjgzNjE1MTM2NDM1MjQwODgyNDI5NzM5Njg1Mzc1OTUwODU2MDAzMzUwMjExMjA1MjM4NTI0MjAxMzUwODE2NDMzMTA2NjM4NjkzMjczNzE4MjEwNjQ4NjI0NDk0MjY0MDQwNDQ5NTE1NzE1ODU0MDYwOTI1MjM0Nzg4NjE4NzkxNDg1NDU2Nzg2Mzk2OTc2NzkyMTUyODk1MjMyMzQzNDIzMzczNDc1MjkyMjU1NDM4NTI3ODc1OTkwMTYyNjUxMjVcIiwgXCI4ODc5NTI4MDY3MDExMjI0MDk3Nzk0NTA4MjA2OTIxOTU0MTkwMjQ4MTc2ODUwNDUzNjE2NzgwODgxNjQ1MzAyMTk2MjYxNjU5NjQxMDM5NjgxMzMxNjA2NDY4NTU3OTQxMjQyOTk0MDAxOTA3MTExNDkxNzgyODkyODA4MDE4MTYzODA1ODQ0NDMwMjQzOTYyNjQyNTE1NTk0NjU2MjM2MjU1MDA3MDE4NzQzMzA4MzU0MTQxNDU2OTQ0NzYxMjE5NTM3MDkxMTQ5ODMyMTE0OTM2Nzk2OTk3NDc2MjI0NDE0MDc4ODQ5NDk1NTE0NjI4MDIwMTAyMDM0NTg0OTM4NTg2NTA4NDA5NTE4OTk4MjI5MTE5MDEzNTI5MzExNDQ4OTQwNzgwMTc0OTUzMzQ0ODQ0MzIyMjU4NDA5MjU3NTg2MTA5Njk0NjYwNTQxODQzODE4MTQxMTQ4OTI3Ni8xODI2MjU5NjIyMzA2OTU0OTMxMzk2OTI4ODY5Mzk3MDI0NjY2MzcyNjE0Nzg4NjM2NDM1NDU4NDgyNTYyNDMxMTQ4NjU1Nzg4MTIzOTAwMzIxNjk3MTYzMDU5OTM4OTY0Mjc1MjY0ODgxNTM3Nzc5NTAxODEzMDQ0OTM4NDUxMzgyNDkyNzEzODU2NjIwMzcxNDg5MTA5MDAxNzc4NzI1ODkyMDUyOTk5MDUyMzUxOTQ3OTM4MzAzMjU2NDIwOTYyOTk4MzgxMDg2NjIzMTM2NzQzODI3MDg1OTQyMTU3MjY0MTQ5NDQyMDgzMTQzNTU2MzU4MDA1MDk1NDg2NzEwMTI5MjU2ODM5OTEwNzk2NTk4MjcwNDIxNjQzNDQ2NzI0MzIyMzk2NDk2NDUzNTQ2NDYyNDk4ODM0NDM0MjA4NDA4NDIzNzQ4NDI2MjYxMjEwMDk4MDUxOTYwMjYyNVwiLCBcIjc1MjkxMTQwOTM1ODE1ODA3MDY4ODEzMzMzNjkxODA3ODIzNjQzODA4NjUyMTc4MTczMTczNTEyMzI5NDc0MTczMTY2OTUzMDczNDkwOTU2MzE1NTczMjA5MjQwNjA5OTAwMzU4Mjc0OTE4Mjk2NzI0NjIzNjY1NzAyMTg3NTQ4ODEzMDMwNDEwODA4MjQwNDEzNDAwNDM4MTE5NjkyNTA0MjYxNzkwOTEwODY1NDEwOTEzODcwMjk5MzkwMzU2MTAzNjk4NzUxMTQxMDM5NjU2NzYzNjMzMTQ2NTgwMzk0OTA0OTk0Njk0Nzg4ODQ5MDI4NzIxMDAxMzc4ODgwMjI4NzI0NzQyMjk5MzM4NDg3NDY3MDM2ODY0OTYxNjc4MjgzNzA5NjIzMzM4NDI3OTgxNzI5NDc3ODkxNjQxOTA2NzQwNDg2MzQ1ODMxODQ1MTcyMjk3MTExNzY2OTY0MjEzNDg5NDkwNjIzNTA2NjMzMjIwNTc0MDg3MjkzODQwNjc2Nzc2NzAxOTI2NTY2NC8xNTQ2MzUzMzI4ODMwODYzNzc2NTY4MTM0NTg3NTQ1NzcyODg4MzQyMTY2NDE1Nzc0MzkzNTY4OTE1ODUxMjU3MDEwMjA1Nzk3NjgzMTU1MjAzMjQyOTM0MzUwMDg1NjE2MjY5MjYwNDY5ODgwNTYzMDI3NDU2MDQyNDgyMjA0MDgxNTQ0NTQyNjc2NDMyMjIzMjg2OTY2MDYzNjc0MDk3MTUzNjk0ODE1NjcyMTM2NDAxMDMwNzYxMTIxNDY2MTU5MzgxODAwODkzMDMyOTQ3MDkwMDk4MTM3NzI1MDk2MDI5NTQ1MTQzOTE2NzUxNTI1OTc0NTg0MjgzMjY2NDQ5ODgyMjU1NTU5ODc4ODMyNTA2NDIzODk1NTA1MzExNjMxNTMzMzg1NDE4NzAwMjk0MTUwNzc5ODI1Mzk2MTQ3ODQyMDYxMTkwNzQ3MDIwMjIxMTc3OTA2NzkzNTE3Nzg5OTM1NDE0MjYxMTA0MzYyNzY1MzA4OTA2MDkxMzc3MTM5MDkxNDkxNjk5MjE4NzVcIiwgXCIxNTI4NjA4OTA3NzQzOTkxODU4NDk1MzE0NDU1ODc3NTc2NTAwMjA2MTgzMjk1MjA5MDg0NzExNzI4NjQ3Mzg2ODY5NDkwOTcxMzc5MTY3ODM5NTIyMTQzODExMjAwNjQ3NTA0NzYzMzAyODU0MzUwMTYzMjYzMTY3OTMxNjg1MDUxMjc5Nzk3ODU5NDQ3NjIyOTIyODMyNTIyODQwMzg0OTA4OTA3OTY3NTY4MTA0MjIyNDA1NzIzNDQxNTk1MTI1Mzk1NDA0NDIzNTA5OTEzOTk4MzM4NjA1NjYxMDM4NDQ4OTIwMjU4OTQ4NDU3MDg1MjA0ODE1NzI3MjU1MTA5ODkwOTQ1NTI1MzAzNzU2MTk5NDk0NDY2NTU2MzI5MTUyNjU5NzMyMzE5OTUzMDk5NzkyMzI3Mjg5NDExOTM1MDUxMjcyNzgwMjQxNDY4MDc3MjUxMzc2MDA4MTM2MDI5MS8zMTM1MTYxNDE4MDM3ODM2MjU5NDQyODMxMzAyOTc3MjE5NzUwNjE0NzI2MTM5NjU3NzE4NzcwMjA2OTYwNzc2NTE0ODIyMTA3MTU1OTI4ODAwNjk0Mzc1NTIyNTcyNTIzNzEyMjc3Mzg5Njc5MDM1NjMyNTMxNzI3MTU1OTU3MTIwNTY2NjE3NzM2ODE3MjI1NTQxNjczMTQ4MzU0ODI5MjEyOTY5Nzc4NjY0MTQ0OTA3NTAzNDExNTg5MTI2MTExODg4OTE3OTI5NDk1MTA2MDI5ODkwNTMyODkxOTE5MDAxMTM4NzcwMjEwOTc3MDEyNzA4MTA3NDk2MTg3MjI3NzUxNDk2OTgwMDAwMTM3MjIzMDQ3MDc5MTI3MDk2MDI4OTM5NjI0ODMwNjU0MjI3NzU4NzM3MzM5NzI1MzQ1NjgxNzQ1ODQ3NTk4MTU3NTM4NDgzMzA4MDY4ODY0MDAwXCIsIFwiMTc3MjM0ODIzODE3Mzc2OTMyNjk3ODcwNzY3OTgyNDY0MjMzMTA4MDIxMjYwOTI1MDA0Mzg2ODE4NjQ2NzMzNzU3MDQ0NjQzOTQxMDU3MzQwNDkwOTkwOTQ4MTg3MzgxMTUzNDU3MDYxMDAxOTE1ODA5ODI3MTIxNDY4ODIwMzQ2MTgxMDMxNjEyNjg0NTM4MDg4MTk0NzE2MDM4MDUzNDU5OTAxNjI3NjI3MjI1NDk5NjQ0MDYwNDIyOTUzNTU5MTY0NTg2MjQ4MzY4OTQyOTEyNjc1NTMxMzgwNDEwMzU1MjgzMTU4MzkxMDgyNTI0MjI0Nzg2MTA4NzkzMDE2NTYyMDc3NzI0OTE1NDg3NDI5ODE5OTA0Njk0NTQ1Mjk1MzcwNDkxMjM5NDg2MDQ5MzE2NjE4Mzc1Mzk5NDM1MzY4NzgyNjA2NjU2MTc1MjQ4MjQ2MDQyOTE1NDczNzM4NzI3MTYxOTQxNTQxOTg4MjQxMDcyNjYyNzU3MTYwODM4NDgyNjI2MjUwNjg5NTg3MjAvMzYzMDA5MTU2NTcyNTg4NzA4NzYwNTYwMDc3MTM1ODIxNjkyNzA5OTc0ODAxMzgzMTkxMjA4MDM4MDk4MzU0NTg3MjA3NzE5NzM2NjE3MjYxOTIyNTc1MTIxNzYxOTA5NzY1NzQwNTY2MDE3MjgwMTg0OTkyNjIyMDk0ODQxMzkxOTgyMzAzODQyNTUxOTAwNjQxMzAwNTk5ODUwOTY3NzQ3MjIyNjcyOTI5NTI3ODY1MjI4NDg2MTgzNDE3ODc5MTMzMjYzMDY3Njc3MjI4NDk3MTc2MjY4MzU3OTA0NzUwODAxNjY4Nzk2OTA0MDY1ODU5MjQzNjIzMDA2MjA0OTA1MTE0MzAwMTQ4NDM4NDc2NzgzNjM1MzIzMzMyNDU3MDY4NjI0OTgyNDk4MDUwODUyMDE4NjY0MzQ3NzMxMzk0MTA1NDkwMDE5NzI2ODU4NDQ5NTEyODYxMDgxMTI3MzgzNDE5MjA5OTA5OTU5MjY4NzQ4NTE3NjQwMDUzOTc0ODYxNjM2MDc5OTUxODM1N1wiLCBcIjM5MTYwNTE0MDMyNDkwMjU4Mzg5MDAzMjE0NTg3OTAxNzgxNzIxNTQ4MDExNjMyODIxMDUzMjMwODgxMjM5MDAxNDM2MzQxMDEyMzk2MTY2ODU3NTE1MTk3MjUxNDk5NDYwODQyOTU0ODYzMzQyNjQxMDE1MzA2MzA0ODU0MjI2MTk0NTUxMTg5MjI0NzIxMjU3NjY0NDIwNzc4NDE2NzMzODg5MDMwNjgwMjk1MjA2MTc5MTA5Njc5NjI3NTIyMTEzNTkyMzczOTM4NjAyNzM3NDE2ODIyOTgxNjk4MzYyMzYzNTUzNDkyNjEwODQyMjAxMDA1NDIwNzI3NzUwNTA1NjgxMzU4NTk1MzQwMTI3MDk5ODU1ODIzNzQ2NDEwNjYzNzUwMTMzMDE5NzQzMTcwNzAwODg4Mzc1NTU0OTE4MjEzMTgyODYyNzg5MDI4NTMxMjg0MzY0ODc3NDM1ODk2LzgwMDk5MTkzMzc0MzQ3ODYyNDQzODA4MTgzOTAyMTM1NDY4NjY3OTQ5NTgzODk2MDM2NjY3Mzc1NjIwNTM0MjM3NzUzODYxNzMxNDkzOTU5NDMzMTAyNzY0Mjk4OTU5OTE5MDM3NTM0NDE1ODQ1NTc5MTc1NjUzNDM2NzM2MDUwMTk5ODkzMzYyNjQ3NDg1ODg3MzUzOTAxODIxMzAzMzQyNzg4ODc2NDI1Njk1MTUyMDIxMDA4NzAwNDIyMDkyNjE1NjEwMDE2MjczODY1MjUxODIwOTYwOTAxOTQwNzY4MzkzNzA1ODk3ODA0MzEzMjYwOTc5NjU0MjgzMTE3ODY2MzUzNjY4MTkwOTQ2MzM2NTEyOTcxNzk5ODczNDA0OTgyMTU5NDcxNDQ4NzAxNjQwNjY0MDk2NTQ0NjQ1NTEwMTc3NjE2NTg3NzUyMDczOTI4MDM4MjU5OTYzOTQ4NzVcIiwgXCIxODE4ODM4ODE2NzgxMTQ3Njc2MjQ3NzY1OTAwNjg0OTEyMTkxMjY3OTc2MzU5NzEzMjIzMzU4ODE3MDQwNjY2NjcxODc1ODUxMTQ3ODE1NDQxODk0ODg1NTE2MDgzODIxMjE1MTM3MDQ1MzIxMzk0Mzc4NDA2Nzc5NjE3MjEwMjkxNjYxODEwMjAyNDE5OTIwMDA4NjQ3ODAyMTUzMzE3MTk4NDI1NDc5OTAwODU0MTk0ODk3MzY1MjIxOTUzMzgxOTUxMTgwNzY4MTE0ODE3OTgwNjA1MTgzNTMxODY0NTU5MTEwMjI5NjI1NjM0NzkyNzAxODk0MjM0ODU3NDc3NDgyMTQ3ODQ5OTA5MjA1NDQ5NzM5MDc5MDczNDc5ODE0Mzk4Mzk0NTA5Njk4MjI0MDUxNzA1ODg2MTQ2NzQ0MDIxNzU1ODU4NjgyMjY2Mzk4NTU4NDc3NTkyMDUxNzc1NTkwOTQ0NDg3NjQ0MzIxMTQwNDIyMjQwMDMzNTUwMDYwODczMzI4NDQ2MTY4NTg4OC8zNzE1Mjc4MjQxNzk1MDg3NjEwOTQxNTQ3MTMzNDkwODI3NzExMTMzOTA5MTQ1NDE0ODc4MjE3OTY1MjczMDYxNDkzNzQwNzE5OTgzMTkxNzc1MTA1NTUwNTU5OTA1MjgzNzMzMTM0MTg5MTk1MTkwMzIxNjQzOTY1ODU4NzcxNDYxNTYwMTMwODY0NzE0NDc3NDQ4MDExMjI1ODE2MjEwMjE5NDUwMDQwNTU4NTgxNTcxMjA2NzExNzkxMjcyMjg0MTk3NjE0ODEwMDI2MjIwNzQ1MTYwNjkzODk4NDIxMDY4MTY4NjMwODcwODUwMzkyNzM5ODE3MzQwMzcwMTQ2MTg2NzAzODY3MDk3OTgyODU4NTYwMzQ3OTcxMjgxMTQyNzY2MjM1ODUwOTcxODM3MzMwMjIyOTcwOTAwNjYxNjUzODAwMDQxNzk1MDIwMzgyODQ3NTg4MzYyNzc0Njc3NTY4MDU5MzU1MjM4MTc0NDAyNDE1Mzg0Nzg4MjgwODUyMDU5NTMyOTU4MTIxNjI1XCIsIFwiNDYzNTM0MzA2MzY4NzQyODQ0MDIzNzYwMDgzNjExNzY4ODA5Mzg3OTg3NzU1MDYyMzY3MTQwOTgxMjM5MTY2Njg1NDUzMzE3MTg2Nzc0MDcxNDUxOTkzMTExOTExMDgxOTkxOTU0MDUxMzk1NzUxNDc5MzMyODM1MjMzMDUzNDMwMjcyOTc4MDg0NDM2NTM0NjA1NzUxNDE3OTk3Mjk1NTQyMDkxODE0NTQ2NzY4NzYyNjM1ODI3NTg5MTk5Njk5NDg1NDY5MTg0NzExMjgyOTk1MjI3MTU2OTE2OTQ4NTU5MDQ1MzU0NDg3MDMxMTgyMjE2ODU4ODcxOTUzODMwMjUxMzM5MjQ4NTIyMjQ1Njg5MjI5OTkzMTc1ODM2Njc5ODU0NTkwNDc0MDc0NzM0MTkxOTYzNjc4MTI5NDk1Nzk4NTgwODExODE2NjA2MTAxNTUzMTc5MTEzMTg5MzczNDkvOTQ1NTg5MDE3OTg5NzgyOTA1MjcwNTQwODkzMTA2NDEyMDgyMDU1OTI1NDIyMDM5NDE1MjQ0NzUwMjM5NTI5ODgyNzM1NzE0NDA4MTM3ODUxMzA4MDM5ODgyMzE4ODI0MzY2Mzk0MzE3NzUzOTgxNzk4MjQ4MTcxMzQ1Njc5ODc1NzU2Mzk1MjE2MjU5ODQ2NDkyOTc4NDM3MDMwNTY5NjQyMDI0NTY0ODAzNTIyMjA4MzIwNzU5Njc5NzMyNzQ5ODUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCBcIjEzNjA3NDE0MjExMTI2NDEyNjg5NDM1OTIwMTcwODMyNzc5NTIzMjM1Mjc5MzA4MDM5NzEyMjk0NjgxNTcwMTI3MjQxNDAzNDA2NDU1NzI1MDY0NjA1MjEwNDczOTIzOTY1Njg1ODU4MDEyMTE0MzMyMDIxNTcyMDg4NTUxMTI3NzYyNjI4ODkyNjExNDU5Nzg1NjI1NDA3MTA3MzAwMzU1Mjg3NjIzNzYxMDQ2NDM4NzI0NzA2OTE4MzAwOTc2MTAyNTgxOTI4NjQzNzQwNTk2MzM2ODY1Njk4NDg1ODM4NDMxOTcyMDUwMjY3MTE0OTQwMDc5MzUzOTk2MTAwNjIwMzExMDk3NTYxNDA1MTkyMzY1NDk2Mzg1NTg0MTY0NzI1MDM1ODQyMzA3MTQ2MzUxMjExMTgzNDQzMjY3NTgzODcyMDY3MzUyODgxMzg3Mjk0NzY2ODA0Mjk4NjgxODQxNDAyODYxNjI2NDQxMjA1MDM3NjM3MjgyMDA3ODEwODExNjAyMjg5NTAxNDc3MzUwMTQ0LzI3NzIyMDU5NDcyNDAwOTU2ODQ3NDMzNTgyNDU5NTA0OTQ0MDA5MzQxMzY5NzM4NDU1NDMwNDk5MzgyMTI0MDM3MDMwMDUxNTA5NTQ0MjUwODc4NjY3NTg4NDI2MjUwNDE0MDkwNjAyMTc1NjI4NzgxNTc5MDAxOTc5NTEzODI3Mzc2MTU4MjI2NTU4NjM1NDgzNTY3MzU1NTM2NTA3NTUzNDIxMDgxODM2NDEzNTMxNDIxNTc3MjgzNjQ0Njk3MDY5MTk5OTM1MTkwNzEzMjkwNjk4MDU4NzU4MzQwNTc3NDM3OTM0MzQxNjQ3MjAzNzAwMjYwNzMxNDM2MjYwNTUyOTMwNTg2MDExMjQzNjIxMzA1MzkwNDA0MDQ0OTE3NzAzNDYwNDM5NzcxMDY5ODgxMDA5Njk5MDEyOTc2Njk1MjMxNzA1MDgzMjE3MDM0OTY5MDM2NzIzMzM3ODEzMDY3NDM0ODg1NzMwODY5MDE1ODMwMjI1NTAzNTYzNDUxNTY0NTc0OTYzOTY3NDk3OTc4NzVcIiwgXCIyMzI2NDM1MDA5MzMxNTY5MDUwNzEzMTUwMDcyNjkxNDQwMTc3MTYzMzI1OTYwMjkwNDg5NDM4NzMxMjc0MjI3NTQ2MjYwMTU3NDc4ODQ4NTU3NDkxMzE5NTk2Nzg1NDAwOTg4NjgyNDQzNjIzNzc0MDc4OTkxMDg1MTg0MzA0NTMwNjY3MzUyNDMyNDYxMTEzMDUzNjcxOTgwMjcxNzkxMjYxNTYwOTEwOTI4NTI2MTE2MzIyMDAwNzI0MTQ5Mjk2NDgzMzkzMzk3NTc4OTI1NzY4MTc1NTAwMjA1NDg5MDQ1Mzc0NzgwMzQxODQ2NTExOTU2NzM4OTMxNTc1NDgwMTc5MTk1MDU1MzMwNDAzNDY2NjM5OTY3NzYzMDAzMDY4Mzc1OTQ2NjYyNzc5NzEyMzk3MTc0MjA2MTg2NjkyODIxMzc4MDQ1MjMyNTg0Nzg0ODkwMTY4Mjc5Mjg4Njg0MDk4MC80NzMzNDMwNTA4MzE2ODUxNDQ1NTI1Nzk5MzU5OTkyNjI3MTQyMDA3MDI4MzI2ODY1MTE2NTIzMDMzOTU3ODY5NjA5MTI1MjEyMjUxMTM2NDUyMzk2NDEwMjM2OTMwMDI1ODc2OTgyMjY1OTE1OTYzMDg5NTk3ODI1MzkzMzE3OTA5NjQ4MDU0ODA4Mjc0NDg4MzU2ODg3MTk3OTMzMzkzNzk5MjQxOTQxMTIwNjkxODI2OTE2NzQxNjQ3MTczODQzNjM0MDc2Mjk5NjMwODg0NjU1OTk3NDAxMzcwNDAwNzM0OTU0MDk4MjQ5NTE5MTExMTk4NTA5MDE1Mzg3ODY5NDYyMTk4Njc0NjU3MTcxODA4ODQxMDA1MjEyMDU4ODIyMjU0NTEzNDI5ODM2NDU3NTM5NjI5MDM1Njc1ODIyNzE5NzIwMjk1MzUyNTA4OTE2ODk4NDc2MTM3MTExOTgxMzk3XCIsIFwiNTM4OTYwOTM0ODA3ODI2MTYxOTI3NTY0MjUxMDY0ODk2NzMwNjYzOTE4NTc5ODE3Nzk3MTMxODAxMzI2ODQ4ODM5NTI0MzczOTM2ODg4NDAyNzYyMzMxMjU0ODgzNTA1MTU3ODQ2NjU5ODMwNTU1Nzk5OTA5ODIyODYxODUzMTQ1MzA2NTQ3Njk5ODE3OTg2MDEwMzUzNzc0NTAwNTQ1MzA1NTk2NjMwOTI0ODE1NjU3MDE2NTY5NDQ0ODI0Mzg5ODkzOTk2Mzk5NTUwMzQzMDIyNDQ0OTM3NjkwNzk4MTI2MTg5MTYyOTU0MTg4NjgwMjU3NzMwODkzNDI0Nzc1MzAzODAxNTYyMzI3NzU3NjU1MzUwMDAyMDAxMDgwODExODY2NDUxNDI1NjY1MzAxNjc0Njg4OTI4NTE1MDQxNDI5NjU0NjI0OTcwNzA3ODAzMzM2ODAwMTI1NjQ4NzQyMTY4MzgwNjc2ODE1NzY5NDU3NDY3MDM4ODQ5MjEzMjI1MjA2ODI0NjcxMDI1ODAzMzkyLzEwOTUxNzQ0ODgzMzIxMTIwODkwOTIxMzUyMjU3OTY2NjM3NjAwNzkzNzY0ODg3NTA0MjYwODM1NTgxMDY4NzMyNzQyNDYyMTQ2OTMyMzc4ODc5OTE2OTcxODI2NzcxNTgwODU4MDc3NTI5NjQ2MDk0NDk0MzY1ODQyODI5NTQ4MTM0NzkxNTEzMTA5MTI5NzMwNTI2MDY3NDczMTY1MTk4MDU0NzY2ODc2MjMxNzEzODc1MzI1MDQ1ODYzOTA0MzQ3NzQ1Mzk1MDc3NDYyOTg2MjU0MDAxNzAzNDU2NjQwNzI4Njk2MzU2MjU3NDE4ODE3Mjc1Mzc2NDk3ODk2MzY4NTUzNTIwMTAyODI4NjM1OTgxODUyNDUxOTk4MDg4NTgyNzQ3MzkwNDU3NDg0MDI4NTQxMTI2MDAzNzI2NDA1NzE5NzE1NTUyNzgwOTkxNjYyMzQ4NzE0NDQ5MzAxOTk4MjQxOTYwNjMwODE0NDU3NjkzOTUzMjA1NTA1NzY5NzU2NzI2OTU3NjgwMDU0Mjg3NVwiLCBcIjI0NDUxNDgxNTU0MzUwMjUxNjU2NTk4MzUwMTI0MTYzOTgzNDg5NTQ0NDQ1OTkxOTkyNjYxMDQ5ODI5MDE0MjY4MzY2MjUwOTY4MDQ2NTg5MTI3ODEwNDY2NDgzMzQ5Mzc4NTYwNzAxNDkxNDQ1NjU4NzI1MDgwNDk3MDc4NTkwOTg2NzQzNTEyMzk3OTI3NzQ3ODg1Mjg1MDk1ODQ2Mzk4ODUyNTc0MjE5MzY3NTgwMDY4MDQ5NzI5ODk0NjY3Mzc0MjE0ODYxOTM5ODk3NTU3OTMwNTI3NjQ2OTMwNzkzNDMxNTEyNjgzNzUwNzMzMDkyNDQ4ODYyNTUxNTgwNDk0MjQ1NDg2MzA4MTE0MTI5Mjk1NDY3OTc2ODc0ODQzODUyMTM4MTQ0NTM5MjUwMjM1NjMyOTg1Njc2OTUzNjYyMjg4NTM2NjY5Mjg2OTE1OTgzMjYxODIwOTQ5Mzg2ODQ1ODA2NzgxLzQ5NjIyNDA2ODM4NTExODYyMjUzNDA0NzkzMTY5NTk2MDUyMDcyNzg5NDgzOTc4MzM4NDk4OTkyMzYzODMyNzMxNDU4NTMwNDU0ODgxMzE2NzQyOTAzMzI2MDk4NzY3NTEyMjIxMTI5MTcwOTUwOTYxNTA1MzE4MjUyNTU2MTE5MTEzNzcwNzE4ODcxNDUwMTk3MDI0MzM4ODMzNDM4NDkxMTkwMTc2NDMxMTc3NDYyNzM1MjM3NzA5NjEzMDQ2MDk5ODk3NzkyMzEwNDgwOTU2NjUzODgyMDkxMjU5Mzk4Nzk1OTU1MDk1MTY0OTAyMzA5NjE1NTgzNTMwNzQ3NTEzMTI4NzYyNTIwNzA4ODk5ODM5NDY3NjgxNzU0ODgzNDEzNzA0NTMwNTM0OTUzMTk4MjMzODE5NDM3OTM2NzkwMDMwOTY1MDQyMDA0NDA5OTc5MDgwNzEwMjc5NjI4MDYyNzIwMDBcIiwgXCIxNjY1OTE5NjQ2ODU2MDk5MjA1MjU0Mjk3MTk5NjE3NTgzMzU4ODc5NDE0NjEwNTIzNTcyOTcxNTk1MjMzNTA0NDgyNDE0ODQxMDY1MTUxNTgzMTAyOTgyMTYxNTAwMzA3Njg4MTI4NzM3ODEzNTYzMjY5MjMyMTQ2Mzc4NDc0NDk4OTM1NzUwNzQ4MTM5OTExNDEwOTI2ODExMDc1ODMxODMyNzUwMDM1NzA4MDQxMzQ0NjExODcyMTMxNDM4MzIxMjM2Mjg3MDE4NzYwNDEzMTU3MzYwNDg0NTEzNzQ4MjQxMDEyNTY5ODA4MzI5OTEyMTQ5NDU3NjIyNjY3NDg3NTU3MjM1NTE4OTkwMDE0NTgyNDUxNjQzMTc1ODE2MTc3MzEzMzI0NjYwMzk3NTc3ODY4Mzk0OTI4NjkyMTEyNDgwNjQ2NjI4NTc5ODcxMTEyODQ1MTgxNTU0NjIxNDgwNDQ4MTI2MjYwNTU4NDIwNjEyODM5MDcwNjM3ODQ0OTIzMjU2OTM5OTQ5MTE4MTEwNzIvMzM3NjU5NDM0NjY4NTk3NTYzNDcyMzE3MzcyODU3Njg1MTYyNDA3NDk3MTQyNjQ1NjQ0MTA4MTQ4Mzk5NjYwMTE0OTAyMzM1OTgwMDYyMjcyNDYzOTY5MjM1OTQwNjk0ODg0OTYzNjg5OTQ4NTc3MTg3MzQ1NDk3ODcwMDAyMTM5NDQ5OTA2OTU5MjAxMzA1OTE3NTAzNzc0ODM5MTExMTY4NDU2OTcyMzEwNzQ1NDM1MjY5ODI1ODA1Mjk5MzcwODEzNzgzMDM1NTUyNjI5MzM4MDAzNzU1NzY0OTQwNjc5NTkxMjk2ODI3NzAwNjU0NDM2NjcwOTE2NjgxMDQxMzI4ODQzNzU4NDA4MTI2MzU2MjQ4NjI0OTU1NDg4ODg0Njc1NzU4NDg0Mjg0NjM4OTU3NTYzOTQwNTAyNTI0NTc1OTI1NDA1NzA0OTAwNjE1NjE2MTY5MTQ0NDMwMDkyMjQ5MTc2NTI0NDAyMTIxMTI0NTI0MDAxMDYxMjE3ODU5Mzg3Mzk3NzY2MTEzMjgxMjVcIiwgXCIxNDI0NjQ3Mjk1MTkyMDY2NDI5NDM5ODU3MTU0NjUxOTYwNjU2ODAxMDE2MzQyNjQ3ODczNzU3NDA0NTk3OTI2MTk3NTQ4NDIzOTY0NTM1MzU2NDY1MDkxNzAwNjYwOTE0NzgwNjk3OTkwODAxNzIyOTkzNjk5OTQ0Mzg4MzY0ODQ5MzgzNzg5OTEyODMwMjA5NzgzNDI4NzkwNTcyNzEwNDUwMzM5MDM1MTgyNTU1NDY3MDUyMTE2NDc5MDA5NDUxNDM1NDYyOTMzNjA0OTY2NjE0NjY2NTc2MDA0OTQ3ODcyMjg0NzYwMDkyMTY1MDgxMjQ3MzYyNTQ5Njc3NjE5MDEyMjQ1NDcyNjk0OTY2ODIwNzg0NzAzNzg2NzY4NjU5ODE4NTU1NjgxOTc3MDU1MDcxMTE5NzA5MDEzODkxMDU3MjM1ODk2NjY3MDk1ODA4NTE2MTE2NTY4MzgyODU3Nzc1NjY3MzYvMjg4Mzk2NDMwNzU4ODkyOTQzNDY2MzU0MzAyNzI1MjUzNDk2NTE1NTUwMzk4MDc2MTUzNTg3OTUzMzQ2NjM3MzQ5NDAxMjYwNTM5NjgyNDk2MDg2MDE3MjU5OTE5NDYzNDI0NDk2NjA4Mjk4NDczMjI1MTc1NjQzNzA2MDY3NDY5NjQ3MTQwOTg1MDgyOTg3MDU3NDM2ODk3MjkzMDY1MDc1NTQzNjM5NTQzNDg3ODAxNDQ2NzU5Mzc1MTA5MDA5ODM2MjI4MzY3NzAyMjM5NDU1Mzg4NDQzMTQ0Njg1NTA2NDQ1NDM1MDI1MDE0ODQ1MjE1NjE1Njc3ODg5OTIxNTY2MzI4OTIwMjg1OTE2Nzg3NDIwMTQxMzQxMzA4NzgxMDE1NTM2MzMxOTU1NTE2MDU3OTYxNTgxMDMwMzM3OTQ2OTU5ODQ5NTg5ODczNjc3OTk2MDc0MDc2MjYzMTkwMjQwMzQ2MjVcIiwgXCIzODA0NTcxNTQ4NTc0MjIwNzY3ODQ0MTY2MjU0MzYxODI3MzQ4NDAwMTIyNzc0NDI0OTY2MDAxNzg2NjQzMjM4MjEwNjQ5Nzc0ODUyNzEyODg1MDI4MDYxMjQ3NDAyMDQyOTU4MTE3NTk5MTc0Njg1OTgzMTU5MzIzMzEyMTk5MDYwNDAyNTM0NjM5NjA5NjE5OTU4NDk3NjEyMzU5MTExNDU0MzY1NTI5OTE2NzcwNTA1NjUwMjIxODE1MTY1OTY0NjQ5NjgzMTYyOTI3ODkwNDg4MDk1NTkxMjk1MTY5MzA1NzQzNDA3MTA5OTg2MTEwODg5OTY1MDg2MTM4NTA0MDcyOTQ3NDM0NTcxOTc1MTkwOTExNjAxNzA2MDQ0MjYwMDI5MjQwMjI5MjMzODgzMzg5OTkzMjQxODIyNjE5NTQ2ODU3OTQ1MjI3Nzg4MzMwMjk5NTAyMTQ0NDMyNzE1MjY0Njk2MDc1MzI1ODk3NzU5MTYzODE3ODY0OTIwODk0MzI0MDc1NTAyMjQxMzczNDQ2NDAvNzY5MjIxNDIyOTE4Mzk4NTkxOTYwMzMyMTUzOTU1MjY0NDg0MDg5ODk3OTk3MjIwOTAzMzA4NjYyNTY5MzA4OTgyMjMwMTI0MjczMzIyMDkwNTQ2OTk0OTQwMzM1MTE0NzgwNTA1MzY0NjMwNTE0NTk0NTA4NDQ1MjAwMjA0MjY5NDI1NTMxMDc5NDYyODI4MzIwNzI4MjYwNjkzNDIxMjA4MzUzNTE0MjE2Mzc5NzA0NjIwNTQ3MDc1NjY0ODEwODYyMDIyODc2ODY0NTMzNzE0ODMxMjY4NzMxODgwMjA1Mzg2NjE4NzExNDc3NzgzMTI5ODYxMzE5MjAwMjE5Mjk0NTUyNzYxODc0MjU5NDA2NjY1ODAxNTgxNzM2NzYyODQ1NDU1ODY5NDQ4MzM2Nzg4MTk2MjI4OTU1NTAzNDUwODMxNzU2ODU4NDY5NDQ2MzM5ODI2ODA5MDg1MDU5MDAwOTkzODgwMzcwNTAxMzUyMTA5MzY4NTIyMTAyNjM3MTcxODU2MzcxNjY3MjU2MDU1NzdcIiwgXCI3OTk5OTgwMDcwODM2OTY2NjY3MDY5MzM0MDgxMzYwOTI2NTk4ODYwMDQ2MTI1MTg0NDIzOTk4MjkwNDkyODYyOTA4Mzk3NTk4NjM4NTIzNTgxNjU4NzQ5NzY1NzY3ODI5NzY2MzE1MTI5ODcwOTA3Njg4NDUxNjE2ODc5ODY5NDI5Mjg2MjU1OTA4MzczMDI1OTgzOTUyNDk2ODgxMzkzMjE1MTgxMzIzMzM2NjE3NTA5MTMxNzA0Njc1ODI2MDkzNDM1NzA5Njc1NzMyMjM2OTEzODc0NzczMTIyNDQxNDE3NjYwODI0NzYwNTMxNDY2ODA0NTgzODc2OTQzMzgxMTc4MTQ5MDAzMDYzNTM3NDg1NjA0Mjc4Njk0NzEwOTEwMTU4NTA5NzAzNTc5NDk2OTUwMjExMTM1NDEyNjc3MzE2NTM5MTU3NzIxNzA3MTk1NjkyODE3MTMzNjA2MDI0NzYzMzYwNy8xNjE1NDg1MDI2NTQxMzYxMDExOTMxMjU5NjI5OTYzNTM5MTQzMzM4MDMxOTMxMTY4MjIwODc1NTM5MDM0MTY1OTE1MjE2MDU3ODM2NjI0NDc3NDAyOTMwMjI4MTA2ODgzMzk2Mzg0ODgxMTU5NjU0NTc5MTEwNDkxOTU1NjM0NjgxMDE5MzM4NTAwMTE5NjM5NTQ4OTc0MDU3MTE4ODg4NDg3MzI0NjEzMTgxMzg2NDc4MjU4MTM1Njg4NzExMDQ5OTYzOTU0NDY2MjMyMjAwODgyNDcwNDgzMDgxODEzNjY2MDU0NDY3MzI5Mzg2NTkyMTc1NDU2OTM1NjU4MzY5ODk1MTYxMjc5NzIxOTc3NjI5MDgzNTE2MTc4MDMyNjk0NTYyNTYyMTc1ODIwNDkzMTI5ODk0ODYyNTg4NTA4MTMyNTI2ODEyMzM0NDQwNjI2MTc0MDg0MzE5NzIzMjMxNjQxNjAwMFwiLCBcIjI2NTE3MDE0MDA0MjQxNDk4Nzk4ODQ4MDAzMjA4MTMzMTExMzA3MzAwNTkyNjIwOTQ3OTA4OTMzMDcyNjYxODEyODE2NjgzMDg1MjYxMzU5Njk2ODg3MDY0NDM2NjExNzQ3MjkyNDY4NzE3NzM5NjA5Nzc2ODI1NjY0MzQ0MDY0MDI0NTM1MDI4MjQyNzM3NjE2Nzg2MjM4MjAwMjAwNDk4MjkxMjI2OTg0NTQxOTQyODM2NDU5MTg4MzI4MzQ2NjA5NTQ5MjM5NzI0NjUzOTUwMzAyMTQ1Mzg4ODc3NDcyMjc0MDc0NjY1MTY2NjMxNTA5NDkwMjk3NjMwMzQ0MzUxNTczMjQ1MjY1NDQwMTY0MDgyMzM0MDkyOTk3MzA3NzI5MDA3NDI5MjE4Mzg1OTMzNjIyNjIzOTM1NzA0NDgyMzcxMzYwOTg1ODM2NjU5ODIzMjY5NTExMTE1OTM3NDQzMTYxNTMyOTg3NjYwODU1NDkwOTA2NTQ2MTMwMTMxNzE2ODI5OTA5Mzg4NjIwNTM5MTUzMTUyLzUzNDgyNTc1Mjk1MzAwNzM1MjQyODA5ODkyNTc1NzcwNTA4NzgwMzMyMzk0ODY4ODU2NjQ3NzczNDA5NDcxMDI0MTcwNzc4NzU2MjgyMzg1MDE3OTE3MTEzMzY4MDM0MTg1MDM2MTYwNDI5MjI4ODAyMTg4NjAyNjY2MTE1OTU1OTQ0MDAwMjAyMDYxOTI1OTk1NTk5MjUxNjk1ODkwMjMzMzkyOTUyNTYwODQ1Nzk5NjY1MzMyNjA4NjEyNDk1Mjk2NzAxNDE4NTQ2MzI5NjUyMzE0Njg1MzM0NDg3MDkzNjM0NzcxMjA0MzcyNzc0Nzc2NjgxNzMxNDk5NTgyNjc5NTY2NTQ0MTE4MjIzNjAwNTMzMzU2OTU5NTYyNzA3MTk2ODAwODY1MjQzMjI1MzA1MTQyNDk4OTExNTc0Mzk4Nzg0MDc0MTc5NzE4Mzk3NDQzOTIwNDQwNjQ3MjA0NzY0MTc4NDQwNTYzNDYxNzQ3OTU2MDE3MTA0NDc1ODM4NjExMjc5NTY0NTU0MDY5MDIxMzk2MjVcIiwgXCI3MTE5NzM0ODI5MDc3MTk3ODQwNTYwMjczMjgzOTUzNzAxMjMxMDYyNjAwOTMxODEzMzU3MDg5MDQ4MjM2NDM3MTA1NjE4NjUyMzk4OTMzMDE1Nzk2NjA0NTI4OTEyNzk4MDY4Nzc2NDIxODM2MzA2NDk0MTM5MTQ4Mzc4MTAwODI2NTI2Njk2MzUzNzYyMzc3MDY4NTM5MDE0ODgxMDQ1NTI0NDM0OTg1OTM1NDg1NzQyMTQ3NDI3Nzk2MzAwOTg1NzAxMTY1Mzg2NTQ3NjA4MTM4OTk2ODEyMjQxODY5MTkzNDM1NDEyMjIzMDc4MDMwMDgzMzAwODc1MzY4NjIzNDQzMzY0MjA3MjkxOTkyMzU4MzE3NjMzMzY2ODI4OTk5ODY2MTQ5OTE0NjYxNzI3Nzk4MTY5MTM3MjA1NzA0MjkzMDEzMTcxNzMzNjI1MDMwOTY4MDc2NDI4OTI1NjA4MDg5NTA5Mi8xNDM0MjY4MDk5Mzg5Mjg4NjMwMzk1NDg1MzU3OTg4MzM2MzIyNTkyMTEwOTYzNTA3OTYwNTM5MjMyMDk0NDUyMzEwOTE4NzY0MTI4MzExNzE4MTQ2MTY2Mjg0NjQxMTkxMjMwNjQ4MDY5MTkwMTUxNTY1NTIyMDQ5MDg1MDU4NjQzNDk0NzUwNDUwNDMxNzA4MDE0NDM3ODE4NTk4OTU5NjU3ODg5MDg3NTU2MTMzNjQ5NjQ3OTU3NjY1MTUxNjkwMjA0ODYwNjMyODYwNDY5NjYxMDMxNDQ0MTIyOTMyMTIxOTYyNzAyMTYxMDc4ODM5ODczMDE3MzE2MTQ3MzQ1Njk1NDg2MTkxNjExNjM5MTY4Nzc0ODE1MTQ0MzMzNTUxMzI0OTgxMDgwODMwOTIwMTgzMDIxNDE1MzU2NTk2NjMzOTYwOTYxNjM5Nzg2NTQ2NTg0MjE4NzQwNDYzMjU2ODM1OTM3NVwiLCBcIjM0MjQwMTAxODc1NDAyMzg5MTA1OTM1MjYyOTUwOTcxNTM1NzA1MzQ1NDUwNjAzNzI4NDc4ODcyNTEyNzA3MzE2ODQ0NTE4OTQyMjE4MTU0MDQwODg5NjQ1MjY1MTIzMjc1OTgyMTc2NjYxNjg1MDI2NDEyMjU5MTIyNTMzMTEyMDU4ODkxODg2NTg4MjA2MTM0NDMyMjk5NjY4ODg4MDY2OTY2NTQ1MDIzMTk4MjAwMjU5NzM5ODczMjIwMTc4OTAxNzQ5NTQyNzU2NjI2MDY1MTE4MDQ3MDYzNTQ2NzAwMjQ1MzI0OTQ3OTQ4MzkwMDI2ODMyMDU3MDAwNDI5MzY3OTM2MTY5NjE5NzkwNTgyMzY5MDE0NTMyNjUzMTE4MDMyNDQyOTMxODkxNjA5MjQ3MTg2MzM0NzU3NTUzMzcxNDg3MTM1NTY1MTU1ODYxMDUxNTkzMTM3MzA4MDk5NzUzNjc5MjI0MjI3ODUyOTU3NTcwMDgwODg3ODc4NjczMjEyNzYzMDAyNDA2NDQxODQ2ODkxNjYwOC82ODg5NDY0NzY4MjQ2MTk1NjA4OTM4MjQ2MTQwNjQ5OTc1OTYxMzY5MTE0ODY1MDczODk1NzAxNjAxNTg0NDgzMDMzMzE2ODMwNzAyMDI4NDI4MTUzMjAyNjQ0MjI3MjYxODM3MjI5MDY0NjI4Mzc5NDEyMjc3MjEyMjY2NTUzMTEwODQ4NDcwNDIyMzMxMTY2MzI3MDgzNjY0NTM5OTU1NDk0MDc0MTkyODM1ODMxNzg4NDYyMDQyMDg4NjYwOTcwNTI2NzI0ODY1Njc2NTM1NzM0ODQ3Nzg1Nzg1MjY4NDE0MDU2MTcxNDkwMDYxNDMwMzczMTc4NjYyMTY1NjA0MTg4MTk3NTMyODE2OTU0Mzg4NDY2MTc4MDUzMTA1NzI3OTU4Mjc4NDAzNjY4OTQwMTIwNjcwNjA2OTAyODIyOTc5ODkxMzA4MjM2MjMzMTMzNDgzOTk5NzEzMzc3MTg4MDUxNDUxNTk3MjAyNDg5OTQwODU1NjUxNzE1OTc1OTkwNzg4Mzc5MzY3NTY3MjA2NTM2MDEyNVwiLCBcIjE5MDI4NjU3MTgzODgwNTQ5NTY4Njg5NTQ2Mzc1MjQ5MjE3NDc5ODE2MjgyNzk2NzQ5MDM0MzYyNTU0MDMyMDY3OTc2MDcwMDU1MTI4NjM5NTk1NjI0MTA1OTk2OTY4OTAyMDg4NTcxNDE5MDg4MzMyMzI2NjM3NTA2NzYwNzI4Mjg5MDA2MzQ0NDY1MjkyNjE1MTg2MjY1MDQyNjMyMzMzOTE4NzU5NjI3ODc2MDk2MjM5MDQwNDY1NjM0MjMwOTczNzQyODIxNDQ5MzQyMjAyODU0NTkxMjUwNDUwMzk3NDc2MzIxNjIzMDkyNzE5NjE4Nzc0MzQzOTIyNjI0Mzg4MDkzMzk0NzQxNzc2MDE0Nzc4NTQwNTQ0NDk3NjE3NzgyMjE0MzcyMjU2OTY5NjE4MjUyMDgyNjIxODEyMDU5NTI5ODA1OTAyMDMwNTU0ODY4MTgyMzQwODI2ODU1NjQ4Mjk4MTMyNS8zODI0MjYwODI5MTkxMjQwODgxNTgzODA4MTk5MzA0NTEyMzg2NDYxNzA1ODM5MDU4MzM5NDgyODczNzY0MDAzNjE2Nzg5Mzg1OTUwNzQ5NDA5MTg2NDk2MzM4MzU5Njg2NzcwMTQzNjI0NDAwNzkwNTc3MDI4NDkzOTk5MTkxMjg4NDQ2NTEwMTU3NTQ5MDU0ODgxMzg5NDE0ODgzMTk2NjEzMjk3MDczMDI2MzU2MjExMzk2MTY4NTM2NDIxNjk4OTk5OTg0NDk2MTY4ODQ0MTkxNDQ1NTQzNTkzNDcwMzc5NzM1OTM2MDc4MDM1NjQ4MjYyOTQ5NTIxNDg1OTkxNzI0OTQ2NTU2Nzg0NjkzNDI4NDEyMTAzMjI0NzI1MDMzMjYzNDI4MzY4OTQwOTg4MzQ5OTI5NTQ2OTExODQ4NTkxMjQ4OTA1ODk4MjU5NjcyNTIxMjk3NTMxMTE0MDYxODc2NDI4OFwiLCBcIjE1MzQ1Mzc5NzAxMTUzNzE0NDM2OTM4Mjg5NTY3NjM5MTAyMzA3ODg3MjczODk4ODM0MDUxNDU2NjkzOTgxNTE0OTU2MzI5NzMxNTcyNjAwMDI2ODY2MTYyMjg2MDk3NjYyOTU4NzEyOTIyODM2MzgzODgxODQwMjExMDcyMzg5ODY3NDYzOTg3ODk1ODk0MDY3Mjg4Njk5OTU1ODU4MzM3NDg4ODEyMzQzNjc0ODE4NTY1NDMyNzgwMjI0NjU0NDIzODcyNjE4MzgwOTI4NDYyOTM5NDgyMjQ3OTAwMDU1NTcyMDc5OTE0NzUzNjUyOTE1MTg0MzEzNjg1MjcwNzIyNTgzOTI2MjYxNDk5Njg3NzI4ODE0NTYwNjgwMDkyMjMxNTI2NTAxOTcwNDMxMjgwNzgzMTc3MzU3NzM1Mzk4NTgwNzAwMzAwNDAyMDM2ODczNzgwMzg1OTI2MjI1MDA1NTYxNzY2ODIyNDc5ODc4MjgwODkxMTMwMjMyMDM2Mzg5NzA3NDUyMDA1MTgzMzcwMTUyNzQ5MDU2LzMwODA0MjY2MjMwODc4MTk2Nzg2MDIwNDkxNzE3NTY5NjE4MjQxOTY0MjU1NDg1Mjk2MTk1NzY5NzI3OTM2NTM1ODUwODkzODAxNjU4NjI4ODkwOTI4MzIzNzU5MzQ1MzU0NjQxNjA0MjU1ODA0NDkxOTMwNzIxMjU5NTU2ODUwOTkxNTE1MDA3NTUyNzg3NjMzMDY1OTkzMDcyMTgzMDI2MzUyMzM1OTUzMjkwODI3MDIxNDg2NzczMDA5NDU1NTYxMzAxMDYxOTc0ODEyMzYxMjI0Mzc5NzgzNzU5NjMyNjExNzI1MjQ1MDM2MjU1OTMwNjYxMDI2MDEwNDIwNjA1NDE2MTc3OTEwMDg3MjI1Njk3OTk3MzUyMDI3NzkwMDU0MDczODEyNjcwMjE2NDE1NDU2NDQyNjQzMzQxMDkwNTIyNTgwODEyMjUxNTk3NDgwNDM3OTIyODg2OTk2NzQxNTM3MjIwNDY2NTk4ODAwODU4NTA5ODA4NDM0NjA3MTUwODA5NjU2MDc0MzQxMTQyNzUyNTYxMjVcIiwgXCIzNjQ0MzYwMTY2MjE0NDI3OTMzNzAzMzQ4NDQ1MjI3MjEwNTU0NzI1NzA2NTQ2MzE2NzQyNzQxODUyNTg4Mjg1MTUwNzk4OTQ0OTM3NTQ1MjA3NjIyNzY1MjYzNDQ0MDQ3NjUwMjcwMjU4NDg4OTA1NzM3NjgyOTMyMDU0ODQ2NDY3NzYyMzAzODY0ODg0MzI1MTcxOTE2ODgxMDcwMTc0NDMzODczNTIwMjg1MzQxMjY1MTE2MDY4MTI1OTUzMzAxNTI5Mzk5NzUwMTUyNTQzMDIyMjg3MDY5NjIzNTE0MTQ2ODI3NDI3NDA2NDM5MDI3MzIxNDQ4NDkyMjA4MDIxOTY0MzA5NTk3ODY0MDMwMDg3NDA4NjU4NTM4Njk5MTMzODQ0MDQxNTIwMzg2MzkwMTcxNDIxNzgxODIyMjY2NjcxNTY0MjQ2NzIzNzE4MzI2NzMwMzIxNDQ3MTg1NDQ3MjI4NjQ3ODM0NC83MzA3MjM3OTkwMTQ4MzEyNDUxMTU1MDkwNTA2MjY0NjQyNjU3ODcyMjI0Njg0ODc5ODYwMDA4NDM2NzM1NDMwODc5MzE0MzQ5NTU0MDIzMDk2MzY2ODQ2ODU2NDcwMzc1MDI1NTU1MTM5MjE5OTYxNjY2NzU0NzgwODY0ODM1MDM1OTAyODU2MzE0OTgxNDgyMjY4MzE5ODg2Mzk1ODgxODA5NjU5MzY4Mjc1NzIwMzc1NTc2MTUyMDA4Mjg5OTQ5MDg1NDUzMzI2NzIyMTU2NTUzNjAzMzU4ODc5NDIwODIwMDEyOTY0MDA2OTc4ODA4MTEzMzA3MzQwMzIxODI0NjYwNDg0NDQxNjE4NDg3MjkyMTM4NjMxNTc5NjE2MzUxNzc3MTkxMTQ0MDczODIwNjg2NTk1NTk3OTg2NTQ4Mzc0NTg4ODM5NzYzNzE5MDgyMzIzMTE0NjYzODQ0MDQzMDQ2MDg3Mzc1XCIsIFwiMTU3NTI5NDkzMDg2MDY2MzkyMjg0MzE0OTExMzA5NzkyNzE2ODAyNDg5MzczOTk2MjQ2NDMyNzAxNjc2Mzc0MTMxNDA2ODQzODQ0NzI3MTMyNjMwMjEyOTY4MTkzMTU2NDA2ODc5NjYzMTMzNzU3MTEzMzQ0NDE2MzAyNDIyNDA3MTI3MDA2MzE3NDgyOTY2NDg0ODI1OTQ4MjA2NjcyMzEwNDI1MTcxODgwODkzNjc2MjkzODI0OTAyODU4Mjk5MjU1NzgyMjU1MTk1MDIxMjA5ODc5NzcxODYyNzQxODc4MjM3NjAyNzEzMzU3NjIwOTcxODM3Njc4NDgzNDQ1NjU2ODY5NDgxMzU3Nzc2NDMwMDcxNjEzOTgxNzAzMTU0NTQwODYwODExMDg4MDk3MzM4MDE2MjczNjUzNjMxMzE3MzMyOTk3MzE3MTg0NDUyODA4Mzc1NjUyNDgwNDU3NDI2NzgyNjY5MTE1NjM2ODY5NjQzNjI3MzA4NzE3MTQ2NzI1NDE2MTkzMDI2NTkxMDk3MjUxNzUwNC8zMTU0OTg1NDY2NTQ1MTIwNDc2Mzc0NjE2MDg3NTAwMTgzNDk0MjE0OTI5ODY0NjUzNzM4NDAzNDc1MTk5NDI0OTQ5MDQyMDA3MzM4NDAxODk0ODM5MzQyNDU1Mjk1NjEyMzE2MDQwNTA2Mjk2NTM5OTI5NDQxNDAzNTExMDY4ODc3NDcxMDU5NDU5ODQzMjU0NjY0NTIxMzY0MTUwNjc4MDc2NjYzMTYyMDIzNDY4OTU2NTc5MTQzOTM1MTIwMDEyMTI2NTY5MzY0NTA0MjUyNjg1MDcyMzU4NjMxNTMyNTg3NjkzNjAyOTY1MzYwNTAwMjg2OTUyNjYzNjM1NTMxNDEzMjc4OTYwNjQ5NDQ1MDYyMTYwMTc5MzMxMzUyNTE4NzUwODcwNjkwMzEwOTgwOTkxOTIzMjU4MTczOTU5NTgwMTk1MjQ5NTYzMjA4NDA5MjUxNzY1ODk2MTY0Mzk0NzcxMzQ0ODAyNjIxMDAyMzcwNTc5NTM5MzMxMTc0NjAxMTAyMjQ3ODM0MjA1NjI3NDQxNDA2MjVcIiwgXCI3NjkyMDU3NTk5NTUzMTMzNDE3MjI1OTk3Nzg2OTgwMTI4Mjk5MzcyNDM5NTQyMzE1MTI1MDMwMDc3NDA0NTE5Njc5NDUwMzcyODA1OTg5NzU1MTU4MDAwODY0Mzc4OTI0ODc3MDM2MjI1MTg5Nzg0MDQ1MTcxMDQ1MTM5NjY3NjkxNTI0NzYzNjA5ODQwODIyNjI4NzA2NDIyOTE4OTI2NDEwMzc3MTg1NDk0MDQ4MzU1MTI4MDQ2NzgzMjk0OTU0MzczMTk3MDgyODUxNTAxOTI3NDEwMzUwMzEzNTg1NjQwMjM3NTUwMTA3MDcwOTM2NDk4MTY0NTk3MjMxNDMxMjQyODU4NzcxNDU3ODk4MTUyNjg0Mjk4MDQ3NDQ2NTMwMjIwODczODg0MDIyMjEzMTE0ODE5NTU2ODIyMDUwMTc4NTc5NzA3MjEwMjY0MjQzMDg3MjU3MDUwNDY4MDAwMDkyODQyNzYxLzE1Mzg4MTQ0ODcyNDExMTI3NjA3Mzk1NjE3MDQ4NDYzODE1ODUwNjMwMDI3ODQ3OTUwNTcwNjY0MzgzMzAzMjU1NjY4NDMxMDgxMTQ3ODcwODM3NDE3ODgwNzg2ODA4NjE0OTUzNDAwMjYxMTc2ODI2MDY2ODkxNTYwNjUwMDg2NzIzNDQ3MDc2MTU0MjA1MDE5NjQxMjMxMjE2MjA0MDEwNzM2NzU0MzA2OTA1NDE2MTc5MzA1MjA5NDcxNzAzMDY3NjM1NDEyNTExNTI4NTQzMDQ5NzUxMzE4NzE1Mzc5Mzk2MTg2ODQxODY3NjYxNjgzNzY1MTQ2NjQ0OTQ0ODg2OTEzMTEzOTczMDc0MTgyOTg1NTYxODU3MjQ5OTMxMDQ3NjA2OTIyMTY2MTkxNzgzNTgyNjg5MzQ3NDA3NDY5MzI0MjA1NjI2NjQyMzQ3Mzg1NzYzOTQ3NDI1NTkzNDk0MDc3NDQwMDBcIiwgXCIxNTE5MDgzNjQ3MDU1MDU1NzkyNjE0MDAxMjI2MzMxMDIzMDM3ODQ1NTM0MDc5NzA5NTEwMDQ3NDcyMDc3NjExMzc2NTMwMDA4MTQ2Mzk2MDIzNTUwNjk1MDc5OTg2OTA3Mzg5NDEyNzg4NDE4OTg1NzUwNTk1MTMxNDQyODgxMDQyMzczNDk3ODAyNTQwOTIwNTQxMzc4OTAyNTcyMDY0MjYwOTAzNTExNzEyMTM4NTQ1Mzg1Njg3NzcwNjIyOTc3ODE2NTUzMzAzNDY4MzEzMDA2NDg2NTI1NjQ0ODQ0NDc2NTkwMjQ4MjE0NjY3NjY2ODE5NzU0NjA5ODgwOTA1NTM0MTA1MDg3MzQ5NDQ0NjIzMTc5MzMxMjQwNzUxNjQ2MzU3NjM4MDEwMjA3MzE3MTA5MDg5ODk3MzA0NjYxMTU3MjAyMDU2NDY1OTA0MjE0NjQ2NTM0NTMzNDI3MzU5NTA4Njk0MTU2MjQyNTAwNjc2Mzk2MDE5NzgwMTAxODc5NjkwNjExNDkyNTAwNTgxMDA2OTY4NDQ4MC8zMDM1NTU2NTk4ODI5NTI2OTY4MTI0OTQyOTE2Mjk3MDI1NDE2NTIyNjA2MzU3MDEwNjM3NjUyNjM1Nzk5MDk2NDk4MjA4NjQzOTcwMjczODI4NDk2NjU1MjI3NTcyMTAwMTU5NDE0MzUyMDIwOTA5ODQ2Mjk4ODE3NTIxMDgyNTM4ODk4NzAyMzkzOTE2NzA4ODA0Nzc1Nzk4NTUyMjA2NDAxNzE4MzIzOTI5MTU3ODYzMTczNTA0Nzk1MTI3MTgwMTc3NjIyNjY3Mzc2ODY3MjM1ODA2MjA4MDIxMzI5OTgxMTM2NjM3MTc1NTcwNDA5NzkxNDQyMzI4NDY4NDczMTExNzY4MTQwNzQ2ODk1MDA1NTYxNDcxNTc0MzU2ODg5MDQ3OTgxNDU4MDAyMjU3ODcyMDkyNDA4NzcxOTU5NDc4Mjc1NTM0MDk4Nzg5OTgyODk5MDU2MTE4NDk4NDE3NjQ5MTY3NDQ0NDgwOTEzNTUyNTQ4MjQ5MDA1MjY4MzgwODM4NDU3NTA1OTQ0NDYyNDk0ODc0NTgxXCIsIFwiMjkyMzc1NDU0OTA5MDk0MTQyNDU0Njk3NDI4MTAxMTc3MDY4OTUzNDk2MTQ0MjI2NDM1MDk4NDM5MzIzNTk4MzE4OTE2ODAyNDA3OTYxNzg0ODE5MDIzNjYzOTMyODY3NjQzNjQ4NTQ2MDMxMTA5MzM5MTk4MjgyNTAyNzUxMjIzNDQ2Nzg1MzA5ODc1NzQ4NjA4NjQ5MjMzMzQxMDc1MzkxOTkyNzUyODg2NzgxNzQwNjM4OTY3ODQ2MTM1NDI1Nzg0MTAwNzcyMjQ3MjEwNjQ2NDc4NTU1NzE3OTg0NDYwMjI3NzM1MDQxMTU5Mzk1OTEzNjUyMDczMjg2MjkzNTc0MDQzMzE2MzM4Mzg4NTUyNjI0OTg5NzE4MzgwNTk4MTIxOTQxNjQyMDM5MDEzNzUxNjgxMjcxNTI0NTU2OTAzNzU2MTk2NjkyOTU3MjQ0ODI0NzA3NzU3ODQxOTUzNDY1MTk5MDgyNzA0NC81ODM1OTk2OTE2MTUzNzg1NDUxMDA5NTA3Nzc2MDExMDQwMDc4MTI3OTI0MzUxMDI5NDUyNDg0MTE0MzkxMDIxMTI0MjQyNTE0Nzg1MTI5NTIwODc1MTc0NjM0MDAwNTQ1Njc4MzIzNTM5Njc3MzE4ODcwNjIzNDk0OTY2MTY0NDU0MTk3ODI0OTk4MTc1NDg5MjgwNzg2NjUyMTIwNzc0NDk0MjAyMTY4OTI1ODM5OTc1MDU5MDg4NTgzNjAwMTE0MTMyOTAwMzg2NDU1NzM1MDQ0NzI0MjI2MTA3ODAwNzM5NzU0NTAzOTE3MDcwODQwMTY5MzE2NjEwNjg2OTQwMjQwMjMwODM0MTcxMjYyODY0Njg5MDkxMTcyNTQ1MzEzMDcwODU1NDU3Njg0MTI1MTM0NDcxOTcyMDU0ODIyODUwMjI0MTc2MTEwMTgxMjY4ODY0OTE0MTYxMzM2NjU2MjU4OTEwNzUxMjVcIiwgXCI0NDE5MjI4MTUyMTM1Njg5MDg0ODk1ODkxOTM1NTY1NjA1ODYzMTg4NjQzMjY0MjUzOTc3MDIwNDc5NjUzNzIyODkyOTU5NjIyMjgyNTQ2NTgzMzEyMDEyNzQyOTE2OTc2MjY2OTQ4NTk0MTQ3ODYyOTIyNjYwMDg0NzYxMzc2Njc4NDM4NzQ3ODA1MDY4ODY5MjkxODE4MzU0NjkzMDIxNDIzNjU3NzI3NjMxMjk4MzgyMTczMTY5NTM4MzU4MzEwNTk2MTYyNjgyODgzOTkxMTk2NDIzMTQ3NTgyNjE2Nzc2Mzk5NDUwMDQ1NDc4MzM4MTAwODA3MDAxMjc4NDcyMTQ2NjY3NjM4NjMzMzgwOTE1MjM3NTM4OTgzNjI2OTkyMjI4ODA3NzIyOTgxODM3NjAyMTc3MzEyMjg2Mjg0NDI3ODI0MzE1NzM5Nzc0OTA3NjE2NjUwOTEwMDU3NTY1MzQ0MjA3ODkyNTgyNzYwNzUxNzQ0MzYwOTE3OTg0NzU4MzgzNzAxNTIxOTIwNzc0OTQ1NTMyNjMyMzIvODgxMTM1MjczNzM1NzMwNDkzMzI3NDkyOTQ2NjM0MDI0MDY0NTQ1MjQ2NDAyMjE4NjY0MDcxNjU4MzkxNjI1NzY5Nzk0NzcxMzg2OTQ2NTM0MDQyODE4ODkyMjc0MTY5Nzc2MTg5MTMyNDkyNzU3MTI5MTc1ODI3NDM0MjYyMzE3NDQ5ODA0NjE5MTg3NzI3OTM2NzMyMDIwNzc3MTYyMzQwMjYwOTAzMDg3OTE4OTM0MDkyMDAxNTg5NjkxMDg5MTA1NjU0NjcyNzM3MjUwNjQ3Njk4OTA0NDM0MDgzMjQzODY4OTcwMTc4MjU0ODk2MTU2MDA3ODc2MzQ5ODUzOTc4ODUyMzA0NTUxNjg1OTEyNDAzMjg1ODUwNDE4MzY3NzE5MjE5Mjk1Njc5MTQ4OTEzNzkyMzU1NzM5ODI0NDIzMTEyNjkzOTI1NDE2OTQ1NjQ2NzUwNTM2MzYwNzg5OTA4MzY0OTExMDQxMTYyODA0OTIyNTQ3OTU2MTYwNTU4MTgzNzU3NzQxNDE2NjczMTk3NzQ2MzA4NzVcIiwgXCI5MTE5NzEzMzc2Nzk2MjQ4Mzg1MjI3ODQ1NjI4NTU5MTgxMDU3OTk3NDc4MzA3Nzg3NDMwNzU4OTU1NTU1OTcxNTU3NzU5OTYwNDYyNjgxOTI0NTAwMDY3MjkyOTUxODY0NTAwNDc3MTA4NTEwNjc3MDc4NDc2Mjk5NDQ3Njk3Mzg0MjcxMzAzNTc5MTQ4NzIwNDEyMjY1MzI0NTc5NzEyNjkwNjE4OTI3MDIwNDAyOTczNTg3MjUwODQ2MjEwNjUyNzI0MDMyMDkzMjQ1ODAzNjIzMTcwNzMxMTk5Mjg2ODM0NzIyMTE3NjQ2MDQwNzAwMzQ4NzM3Mzc1NDAxNDM2NTg4MTIwOTY0OTYzMjU0NzY4NTY1NzY2NjY5MTU4OTYwNjU3MTg2NTc0MDU5NTgyOTk4Mzg0OTk0MTA0OTQ1MDQ3MTIxMjM4NzgwODYxNzI0NzkzODk0MTQxNzAwMDk2NTE5ODEyMzA1OTQ2Ny8xODE2MzY3OTYxMTIxNDY3NzgxMzY0MzQ1NTE5OTk3OTA5ODI2MTg0OTQwNTE4OTgwNTM2NDk4NjAzNjkxMTk0NTAxMjAxNjI0ODI5NzY0NTU5NjI3MDYwMjUwODAxNTg2NDM3MTc4ODk3NDY4NDMxNzIzOTcyODIzOTg0Nzg4ODk2MDE1NTM2NTM0MjQ2MDg0MzU1OTY1ODIzMzA2OTYxMzIxODQ0MjkxMDIyNjEyODExMzE5Njk4NDgwMTEyNjI0ODg2MjI3MzUwMzIzMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLCBcIjczMzM5NjcyNDQzNDU1NDQ4MTQ3MDY1Njk2NDE2NzIzMzY5MDg1MTI3OTkyMzA4NTE5NzE0NDg3OTY0NDc1MDQzNzQwMjYyNzkzNjcyMzUzMTYzNTg5ODU0MjQxNDEzNjk0MzAwMzIzNjQ3ODQzMjg0ODk2NTUxNjkyNTg5MTk1NjYxNTExMTY3ODQ0NDU4NjM4NDQ5Mzg4MzExMzM4NTMzNTQ2MzYzOTY3NDY5OTQ0MzgwODA4NDgyNzcxNTk5NDEzNzQxMDc0Mzk5MjEzMDcxMjkwMzk5NzgxNTQ3MTM2OTIwMTQwNjY4Mzg2Mjk4NTY3Nzc3NDE1NTcwNDI2NzAzOTIyNDU0NjM1MjQxNDQxNzYzMjQ3NTYyODEzNjQ2MDkxOTkwMDM0Nzk3Nzc1NDY0NDIxNDcyNTkzMjQ3Njg1NjAxODMzNTE5NTkyNzYwNDc3MTQwODk0OTk4MDYzNDE0MjI1NTQ5NzgxMjU2Njg2Njc5NTc5OTIzMDUwMTAyNjA2NjE0NTQzNDc1NTgzODMzNjk5MDM2NTE4NC8xNDU5MTI0OTU2NDQxNTk4MTAzMTMwMjY0MjAwMjUwNTM5ODk2MDk5NDIyNjU2ODYzODg2MzAyNjYyMjY4NTY2NTA3OTYwODg3NjgxNjQzNTg5NjE2NDQxMTMwNzY4MDk1MTE1NjYxMjUxNDUzOTU2OTkyNzE1MzA4MDI4OTE1MjM3NDE2MzY3MDc1MzI2NzYwNjU4MzMzMjcwODIwOTI1MjE5ODk5NTg5NzExNTQ3OTg0NjU3ODQ4NDcwOTI4NzA0NTc5NDQ4NTc1OTA2MjMwOTc3ODE5NTY4ODQyOTcxMDM5NjE3MTMzNjIyNjgyNjQxNTkwMTU5Mjg1NTQ3MDcxNTgyMzkzOTg3MjE0MTYyMTg5NTMwMDMyMTUxMDkyMDI3NzE2NTE5OTM2MjIyNDQ3ODg1MDU2NDkwOTg0NDUxMDk0MzgxMDQ0NjYyNTY0MDgwNjA5NDQyOTg0MzcwMzMwNTgzODA4MDQxMjY1NzQ4NzgzNzc4NzQ0NTkzNzEyNTEwNTY4MDA4OTUzOTQ5MDQ0NTk0Njk4MzI4NzVcIiwgXCIxNjc2MDY0MjM4NTM2NTg3MTM2MTU3NDkxMDExMjMzMzYzMjY5MDgzODE2MTk1ODY4Mzg2MDY5MjI1NjUzNzg1MDUyMTEzODYxODUxMzA0MDc0MjM1ODcyNjQ3NzY1MTk1ODkyOTU0MjA3NTgwMDk3NjQ2Nzg3NTkyMTM1ODc5MDYyMTY1NDMxNjA4MDEwNTkwMjkxMzM0NTcwNjIwNjc1Mjk0Njg0NjQ2MzYzNzY2MzkzMDc2OTA2NTc5NDU1OTc4NDcwODA3MDYxNDQ4OTg5MjAzMDUzNzk2NTM3NTQ5MjA1NzE3OTc3NzExNzgzNDE1NTA4MDgwNDE2NTIzNjA2MzU1ODQ0MDE3ODk5MDE1MjU3MDkxNjYxNzIyODMzOTAxNzc2NzMwMDk0ODMzNDE4MjY5MTExNzk4NjE1ODQyMTMzMTQzOTU4OTMzMjMwMzU1MjcxMTYyODM3NTg0NDUwMzg0MTM2NDY3NTcyODAvMzMzMTAzNjQ4NDg3NDQ0ODg3Mjc0NzA3NjE4ODk4NjEwNjk5OTMwNzE5NjUxODA3NTYxODczMTExNzgxMjQ4ODcyODYxMzM1NTQzMjQwNDI0MjI1MDMyNjM5OTQ3MTc5OTMxMjk1Mzk0NDgzMTA3NDM1OTgxMzgzNjQxNzI4ODkzMDU1MzI0MDE1MDU4OTAzODQ4MDYwNzg3OTAwMzQ1NTcwNDkwNzQxNjkyNDUwNzg0MTY3MDQ4NjY4NjczODAwODkxMDMwNjQ4MjE3MzI2NzM5NjcxMjA4MDg2MTE2MzY2MTg1MjY3MzcxMzg0MzU3OTI4MTg4Mjg5OTA0MDMzNzQ3NjYyMjgwMzcwMDM5Mjc1Njk2NDM5NzIyMDM5OTMyNjMzMjk0MDM0Njk3NDczNDIyMDQ4MDgzNjA5NDc4NDAxMDM4NDMzMTc1MzMyMTA1MjM4NTM2MzE3MTE2MDE0NTA2MTcwOTU3MzY0NzNcIiwgXCIyMjQ2NjczNTQ3ODY0Mzc3MTgwMzYyNDkwOTM1MjE4MTgxNzkxMjM4NzczMjExNzM3ODUzODI4NDEwNzQ4NTYyMTAwMTI0NjE3NzE1MjY0NDE0MTg1MzYwNDYzMzY3NjkzOTY5NDIwODEzMTI0MzA4MTIyNzY2ODIzNzcxNjE5NDMxNjczMjEyNTQ0NTA0MTI2MDU2ODQwMzc1MjMyNTQxNjIwMzg1ODMyOTQ2OTQ3Nzc3NDcyMDk5ODg0OTMzNDk2MTc1MTU0MTE5MTc2MTUyMTIyNDY0NDUyMDc0MjY5MTk4MTM3Mjc4MjAwOTM5NDgyNjczOTI0OTYwNDI1NzA5ODI0ODc1MTYyNjk1NzUyODU0MzU1ODU0MjQ0MzEyMjQ3MDY1NzIzMDgzNTE3NjQ2MjYxMjUzMDQ2NDA0NDY1MjE0MDU4MTM2NzY2NjI3MTc3MTg4MjE5ODc0NzE4MjExNDY4NTExNjMzNjUxMjYwNDAzODgzMzMyNzcwNzE2MzEwNzIwNzY2NDcwNTEyMDcyODA2ODk4Nzk5NjU2MDUxMi80NDYwMzQyMjYwNTk5MTEwMDcxODE5MTQyNTM1OTAzOTkwODE3ODkzNDI0MTkyOTcyMzQxODcyMzk0MDE0NzQ4MzE1MDkwNDMwOTk5MjI0MTA3Mjc0Nzc3Njk1MzA2MDMyNzgzMTA1OTQ0NzIxMzM3MDUzMTU2MDc0ODUxMjQwMjAxMTc5OTAyODM1MzUzMDk3NjgzMjY5Mjk4NTk0MTkwNDU2Mjg2ODg4MzI2MDY3OTMyNzc3NzIwNTYxMTgxNzYwMzY5NzgzNDg2ODcyNjY2OTc0NjIzOTEwNTE1Nzk1MjA4MzUzNjA1Njk3MDY1NDQ3OTQyODA0NDE0MTIwMDMwNjc4NjAzNTM4NzYxNTM4Mzg1NzkzODI5Nzg3NzM0ODMwMTI5NzY0MTUyMjYzNjkxMjk2NzE5NzI2OTA5NjMzNTgwMzE4ODk3Nzg3NzI5MDA0OTcyMzIzNTk5NzczNTQ4Njg5MjcyMDA4NzEyNDI3OTI2NzM0MjU4OTEzMjcxMTAxODk5NzgwNTM4NjM1MjEzODI2MjM5NTQyODg0MTI1XCIsIFwiMTk3Mjg2MjAwMjA2NjI1Mjc5ODgzNzk3NzE1NTI3MjUzNTM0MjcyNzQxNTMyOTYzMjI1MjIxMzUwODI2Nzc4MTM5MDg3MDY0NjkwOTY4NjcyNDk1NTg2MTYwODA0NjMyNTc2NTY1MDQwNzM0MDEwMjQ3MjgzMzQyODkwNTI3OTQ3MzE4NTgxODg5ODY5Mzg1NDM0NDEzODQwMzc0NDc1Nzg1NzkyODg4MzYwMTYzNzkwOTYwNDA4MjU4ODMzODg2OTYxMjIyMTc3NzI2MzU4MjM2NTc0NTQxOTcxOTgwNTU4Nzk0NjU1ODMyNjA0ODA4NzEzODE5NzY5NDAxNjIyNDYxMzExODMwNDYyMzg2NDcwOTE4MzY4MTE3MjM2MjY5MzEwNjQ2MDUzNTExNzQ1OTE5Mjk5MjgzMjk2OTEzMDg5NTgyOTkxNjIxMDkzMzcxMDgyMDAzNTQ3OTE2OTU2Mjk3MDk4Mjc4NDU4MDg2MS8zOTEyNjI4NTQyNDU5MzYxOTg2NDk1MDkyNzU3MTk2MjQxNTIzMDUyMDY4MDcyNjEzODI2MjEzOTA5NDYwNjA2MzYwMzIzNzYwNTczODU3MjM0Mjc2MDExMTMyMzMwNTAyNjAzNTk2ODQxNTM5NjM1MjA3ODIyODUwOTc2NjQ2MjgyNzk1OTY2MTg1MjE5NjM0NDQ1NzQ1NDM0MDkwNzY0Mjg2NjA4NzQ1NjQwMjY2NTE3NDIyMzQ3Mjg5OTczMzk4NDQxNjE1MTQyNzM2Njk3MzU2ODY1MTY3NjEyMzkwNzY1MjkwODgxNDUyMDg5NTg5MzgzODQ3MzI4MDA1ODYyOTg5NDMyODE3Mjg0MzUyMDc0NTIyNTMxNzA5MzU3MTUyMzkzOTI1MzQ4MTU2ODMzNjcxMTQyOTA2NzYxODA4MzkyMTc5MTk1MzkzODE2NTE4NDExNTE2NzQ4NTk3MTU5OTIzMDk3MjcyMzIwMDBcIiwgXCIyNTQwODY5MTQyNjI4NjY1MzI3NjAwNDU1NjQyNjUxMzQwMTc2NzcxODMyODY0MDA0ODk0NTkxNzc0NTc4MzIyNTQ1OTcwOTQ4NzQ4NzM1NjA5NTE2NDE2NDY1MjIxODEwMDkyNTg4ODg0NzY4OTA5OTE1MzMyMDc3NzM4OTM4MTg1MTU5ODIzNjA0NjQwMjEyNDY4NDUxMTk2ODM4NTMyNTEwNzQ5NzA0NzAyNTQ4NTMwMjMzMzUwMzA3NTA4NTU2MjUzMzQ3MjQ4MjY0NTAyMzk2MzcxNzM0Nzg2NzY5Njg2MTg4NTM2MzQxNzU5NTI5ODc1MTQ5MDIxMjQ5NTkzMjc2Njg3Mjc0ODEyNTExMTExNTAzOTMxMTUwNzM3NDM2MzAwMDA2MjUxMzk3NzQzNjkyMTc3MjA5NjQ0Mzk0ODE1OTI4OTcwNzk5Njc0OTA2MTAwNzExMjQ1ODEyNjMwMTYxODc2OTI5NTE2MjY0OTYwMDY3MzI0Nzc5OTk2MTExODY2MjYwMjc1Njg4OTQ0ODE1MjUxNzM2NDk5Mi81MDMzODcwNzcwODE3MTA0OTA5MDI1NTEyMzMxMjM4NDE5Nzc2NDA3MzMxMjgxOTQ0NTY1NjQ0NDU3MzQ1NTA3MjYyODgxMTAwNjE4OTA4NDA1OTI0OTUxNTU5ODUzMzUyODQxMTU0NzMwODAyMDA2NzUwNjg4NTgxNjAzMjcwODQ5ODgwNzU2MDI2MjYyMjE3NjUxNjg1ODEzNTg0OTAwMzAwMzU3Njg1ODc0MDQ0NDgyMzI5NjAxODk0MTM0NDQzNTQyNzUzNjkwMDQ4OTYyMjYwOTE0NjQyNjc4NDQ1MDU4ODkxMzg3MDQxOTE5NTgxMzc2MTk1NTQzMTkzMTk5MzA3NTI0NTcyNjcxMzQ0MzIzMzYxMjgyNjMzODI4MTQ0NzA4NjgzNTM2NzIxMTE4OTEwNTQ5OTMzMzM2ODAwNDYxMjQ4MzM4MDU5MjA5ODUzNzY2MzA1MDU4OTQzODg4OTY1Mjc5ODYzODUyMTA3NTA3MDc1OTE2OTgxMTY1MTY0NTQzMTk5MzUyOTIwMDU1Mzg5NDA0Mjk2ODc1XCIsIFwiNjE2NTY1OTQwNDgxNTc3NzY1MDExMTc0NjE3NjE5MTI0ODQxNjMxNjAzOTQ0MjY3MjU2MTc4MDkzNTU1MjM1NTkxMjA4Mzg3NTg4ODk0MDY4MDA1MTYyNzY2NTEzNzIwNTQ2NjI2Mzk5MzA4MTY4OTIzOTA0NjI1MjEwNzQ4MDUxNzg4NjUyMzI4MDcyMjQxNDk0MjQzMDQwMTg1NjExMzczMDM1MDU5NjE5MTM2NzEyNTU5NTA1MDIzNzAzMTUzMTk0ODE1NjExMjY4NTAzMjkxMjk1MDU5NjQ4MjY5NzcyNjYzOTM5MTM3NDQ2MjUzNDM3MjQ4NTQxNDk2NjMxODUyOTg2NDk5Njg4MDUyNjc4OTYxNDk1MTE2MjEwMTMzNDU4NTk2ODY2Njg0NDEzOTMxMTg4MzQ4Nzk4MjQ0OTY5Nzk3OTczODQ2NTY4MTYwOTk5NTY0NTQwNjUyMTExNTk5MDgyMTgxODcxNDM2LzEyMjAyNTY4MjE0OTYyNzQ4NDUyODY1MTUwNzM2ODA1MTM2NzYyMDU3ODQ2OTM5MjIzMzg3NTQ5MzU1NjgyODYyMzQzNzg2OTY1MDI4NDM1NjcwMzI5NTgzNjk5ODE3ODI1Njg3NTc2NjMxOTUwODc5NzkwMzkyMzYzODk2NzA3MzY4Nzk5MTIyOTcwODA1MTI4NTYwNTE4NzM1ODYxNjUzMTkyNjExMjczNjQwMjUxMTU2NzcyMTg4OTg0NTY5Mzk5MTk2MzYxMDE5MjE2MTQxMzY5MjkyODM3ODcwODIyMzcxMjc5MTkzMDExMzM4Njg0MDEwOTcyOTM2ODc3Mjk5ODM0NzAzNjA5MDkwMjM2NDgwMTAxNDA0NTMyODM0ODgzMDc0ODMwNzE3OTU5MDc1NTcyMzE2MDE0MjQ2ODU2Mzk3NzAxMTcwMDc2NDUxNzg4MDQ2NzExNjc2NjE1MDMyMjczNjAwMzE0NzEyNVwiLCBcIjk3OTg4MjA1NjgzNDU4MzI0MTQ3NzE4ODY4NjU1MDU2MTYyNTI4OTMzNzAyNTc0Nzc4NzEzMjc3Mzg1MzY5MDE0MzM1OTY1NzUxOTQ4MTM5NzU3NTU2MTgxMjcyNzM5NDQ3MDEyNTE3MjI3MjI0Njc3NDU3ODQwNDU0MzI1NzIxMDEyNDQxMjcxODcyNTA4MTUzNjMwOTgxODM4MzMxMDg5NjEwMjk1ODE2NzMzNzMzMzQzMDU1NTE2ODY3MTMyNzk5MjM5NTkxNjczNTAyMjcxMTI5NzQzNTI2MzE1NzY3MDUwMTExNzczNDQxMjU4NzY5MTI3MTA4NDk4MTE0MDE2NzAxNzQyMTkwMDg1MjU1MDgyMjU3OTQxMDYzNjE4NDMzMzE0Mjk0NDQxMTA2MDc4ODcyMzY1MzU5NjM3NzAxNTM1OTAzNjEwMTE3MDA1NDgyODYyMzY2OTE2OTA0NzExODU1MTAxMDEwMjI1ODgwMjQ2NTU1NDAzMzE3Mzk2ODQ2ODE4MzQ5MjA1ODI3MTM2NTgwMTc1NTk4NjU2MC8xOTM3MzIwNjY2MjA1MDQ3NzU5ODE3NTk4MTI3MDMwMjg3NTc2MDg2MDAxMjU3NDI0NzcxNzg3NTExODk2MDc2MDI5ODMxOTg1NTk3NzgwMzkxNDExOTI0OTI1ODk3MzQyNzc3MzkwMTc5MDk4ODk5MjQ0ODg2OTkzNzI5NDA3ODc5Nzc3OTQ1NTU1MTk0NzQ4MDc5MjAxOTg5NDQxMDk1NDkwMjM1NDcyNTk5MTIzMjQyNzk3NDEwMDY5NzUxMjk1MTgxOTEwODEzNzM1NTQ4MTc1ODQyMTQ5NDE2MjkwMjEwODgyMDY5Nzc1MzI1OTkwNTUwMTQxNTA0MzM1ODE1NDQ1OTk3MjE5MDM4ODEyODQ1ODEyNTc4MTI4NTA2OTc0MjMzNTA4MDU3MTU1ODY0MzYxMTQ4NDIxODMyOTU3MzA2ODA0OTAxMTA3OTMyMjU1MTQ2MDIxMzMzMDQ3Mjk0ODQ1NDcxODE3NDAyOTA1MzQwNTY0NDU0ODIxODY0MzA3MjkzOTg3MDEzMTE1NjMyODU0OTQ5NjQ2NDU0MTlcIiwgXCIxMTM4MDU5NDQxODkwNDI4OTAzMzM2NzE4NzEyMTU5OTA3MzY0OTc1OTU5NDgyMTYzMDA0Mjc2OTAxNjc2MDYzMTg2OTM5Mjk2MjE3NTY5ODQ5OTkwOTUxOTMwOTU1MjcwODQ5NjkyNzc1MDc3ODEzMzU5NTczMzk0NDM1OTI0OTM0NTQwMjY5MzEwNjI5NzMxODAxMzc2MTM0NTQ5MTY5MzIyOTQ2MzEwNzU2NzM4MTg3ODM0MTI4OTU2NjcxMTk1MzU4NDEzMDI0MDYyMjMwNzc0MTExOTM1MTA5MjAzMjA3NzY4ODk4NTI1ODgyNDE3MDc4MTE5MzE0MDAzMTYyNTkyMDg3OTIwNzU1NTcyMDUwOTkzMzU1ODQzNjgxOTMxMTM5MjU3MzAzNDg0NTI2MjIzNDYxODQwOTM5ODgwNzU5OTA4NDQ5MTgxMTM1MDI5MzI3NDQyMDM5NjY2NTEzMzI1OTE2NzI5MTEyODUzLzIyNDc3NzM5MzcwNDk4NTMwMzI2MDQzMzQzOTQwMTUwMzUwNzcwNTE0ODU3NjcyNzM2NDM4ODcyMDM4NzE3NDk3NzE1NDIwNDYyOTMzNjk4NTI5ODA4Mjg5MzQ0MzIwNTIyMzAxNzk2NjE0NTA5ODA2NDg2MTU2Njc1NDI0NDYyNDczMjY3MTQ3MDkzNTcyNTMyNjA0MzQ5MTkxMTE0MjQ2NzE3ODAyNzAxMzExMjUyNzY2ODE4Mzc4MzQ1MDkzMjk5MjUzNDUxNzgyNzg2MzI5MzgyNTA2MTI5NjI1NzQyMDE4MzY2OTM4MzcxOTA0Mzg3MzY2NjI4NDM3ODY0Nzk1MjM4NTQwMTMwMzczMzI3NDc3MTA0MjM4NTY2NjQzNjIxNDUxNzIwNTY3ODY3NDIxMzExODM3NDg4OTEyMTU0MjM2OTk5NjA0MjMxMzg3OTI1ODYyMjE0NDQ2NDU2NTQwMzEzODM5MjA2NDAwMFwiLCBcIjYxNDI2MjYxNzYzNDkwNDUwOTQxMDU1NTY5NTM5ODA5MjE5MDE2NjMyMzI4OTc4NzcwMzk1NDMyOTExMzQxMjY0NzM0MjIzMDg1NTgyNjU2ODg3Mzk0NjIzMzEzNjMwMzU2NjE3ODYwNDI3NTI5Njg3MzIzNDkyNjY1MjA4MDQ2MjI1OTU1Mjc3NTI1NDc1NTEwOTkzMTMxMjUxNjYxNjgzODA5MTg1MjkxNTM5Nzg0Njk4NDM4MTE4MzczMjc3MzQxMTI2MzgyODYwMDEwODQ0MzA3MDc3ODg2MTk4Njg0OTI3Mjc5NDQ0MjEwNTEwNzI4NTIzNDcyOTA3NzgxODYxNDMzMjE1NTg5MDk0NjgwNDI1NzcyNDExMjE0MzYzMTY0MjY2MzA4NDY2MDAxMjM2MjY5MTEwMDg3MjQ2NTE0ODg2NDQxMzM0MzU5ODA2NzU2NzE0Mjk3NzEzNDg0NjI2NjQyNTA3NTE5NTU0NjI2NTEwMTcyMDMyNjI3MjUwMjAwOTIzNDY4OTM4ODM1NTM2NTc5NDg4OTQ0NDI1NzU1NzUwNC8xMjEyMDA4NTQ2NTUzMTAzNDU4NzgwNjkxNTUxOTA3MzQzODE0NzY5MTQ0MTY4OTMwMzE5NDE3NjE3NTYzNzkxNDg2MjI1OTEzMTAxNTI3OTMzMjg5MTAzMzQzNTc3MjQ3NjIwNzkxMzk1MDk4MTMzODE5OTcyODc5NTQzMTk5ODMxNjU5NzE2Mjg0MjkyOTU4MDMxNjI1NjM4NTYyMTkyMTE2Mjc3OTYyMDA1OTkxOTYyNjM4Njg3ODE5MzcyMzQwMTU4MjEzNjc1NzU1MTI1NDg1MjI3OTAxNTgxMDE4OTI1MDc5OTY3ODA2NzU4NjMyMzQxODE3MDAyNTM1NDU5MTI2NDM1NDg0NjYyNTY5Mzg5MzY4MzU0Njk2NDYxMTQ2NTk1OTg3Mjc1OTIzOTA2MjgyMDkzNjIwOTY3MzgzNDM0MTc3NzUwMDkzNjE2Nzg1OTkwNzU2NzExNTQ0MDUxMzc2NjMwNzc3OTg0MTk4OTc5MzI0MDQxMDQ1NzkxMTMwNTYwMzgyNzE3NTM5ODg2Njk4MTM5ODgwNzY1MTU0NzYxMjVcIiwgXCIxMDY4OTM0NDU1MzE5OTU0MzAxMzE4Mzc1Njk4OTU3MDM2OTc2MDQ5Nzg0NDU4NTk0MTI3MzkzMzEwNDIxNTE1NDYwODMyMzQzNzM0NDM2MDE5MjM5ODM3MTQyNTI4MDExMDM1NTE4NzQ5ODYwMzM4NDE2MzcwNzk0Nzk3OTQ4OTU0NTIwNzc4MDMxODI2OTgyOTE4MjI2Mjk3MTM1MDAwMjE5OTUyNDE5NDAxMzMwMzcyMDAyNjgzODE3OTMyODIzMTg2OTE1NjgyMzQ3MjgzMjkzNzg4MjkzMDEyODIxMjE1NjI2NTI0NTI5MzYyOTc0MjIxMzY5NjExNDc0MzI1NTk3NjY4OTYxNDMwODEwNTk1MTgyMzgyMzQ3NzcwNTU5MzE5OTk3MTQ5NzM5OTk1NTM0NTY1NDc3NDY4MjU2MTcxNjgwMDU2NTAyMjE1NDI0MTcyMTYyOTE0MTIzMjQxNzQ3NzI4OTM2MzU4MzIvMjEwNzAyODc1NDY1ODMxNTQ4OTUxMDI5MjcwMjkyMDMxMjU1NzczODU1MjgzNTAxNzE0NTc2MzQyMDMyNjExOTcxMzcyMzg5MjM5MjMyNDUzODI0OTM4NjgxMzQ4NjkwMDk4NDQwOTQ0MzUwNjgyODQzMzU5MDkyNjYxNTIwNDI5MDMxNTc3MDA1MTA1MzQ5MDQ4NDcyNTc0MzY2NjY5ODA2NzEwNjczMjkwODQ0MDkzNDYxNDk3MjkzODU2MjUxMDgyMzMyMzQ1NDIxMzM4Mzg5MjQyODExMTM0NTQ1MjY0NzE4NTU1NzMyNzEwNjY4NjU1MzQ0ODA5NzQ0ODQxOTY2NDQxNzMyNzAxNDEwNTY0NzA4NTc2NjY2MzI5MDI4Mjc2MjU0NzU3MTk3MzgwNzY1MjQwNDc3MzYxMjMxODIyNTUzMDY0Mjk2Nzc2ODgxMjkyMzE2ODI5Nzg1NzA0NjEyNzMxOTMzNTkzNzVcIiwgXCIxMTEyNzQyNzk4Nzc2NzQ4NTUxOTI4NzQ0OTgzMzA4NTg0NDkzODE3MTEyNDAwNTM2MDg0NzQ0ODUwOTY5MDI1MDYzMzYwNjc5Nzg1Mzc4Nzg5NzY0ODc1MDc2NTI5NTc1NTgzNzkyNTcxMTk4NTEwMzA2MTg2NDE3NzczMTAxMzQ2NDI1NzA0OTY5NjcxMjU2NTY0NDk0MTM1NzUwNzgzNjQyOTEwMzk0MjEzNzI3MTg5NjM5NjYxMTg0Mzc5MzQxOTYxNzM3MTM1NzY0NTcwOTQyOTYxNjkyMTU5MTc3MTg5NzUzMTM5MjA5NjM4OTI5MzAyOTI4Njk5NzA1MDQyODMyOTIyNzc0MDEyNjIyMDE3MjcwMTcyMzMxNzIyMjk1ODgxNDEyMTExODEyOTMzNTkzMzcwNzQzMjEwMjE0NTQ5MDM4MjEyMzk1OTQxNjc1MjU3NTU4NDQyODc4MDEyMTM2NDg0MDUyODI3NDM5MDA3NDgzNzc3ODU5MzkxMjE1MjIyNjQ3NDk5NzQxNTcyMzI3NzI1Njg5ODQwODUwMDQ4LzIxOTEyMTkwNTUxNDY1MjU3NTE1NTU3OTE4NTMyMjM2NzE3NTQwMDY2OTM4NjEzMTg5MTg0MzM4MjQ0NzQzMjg1MTEyMjQ2MjQyMjk5MjE0Nzc1NjMzMzcyOTg5MzAyODM2MjAxMzMxODI2NDE1NTQ4OTUzNzEzODEzMzM3MjcwMzI5NTgwNDAwMjg0MDkyMDQwMjQ4MjExMDI2MDU5MDA1NTc0OTg0MzE3MDA2NDkyMTg0MzQ2MDQ5ODgyNDEyODI3NDQyMDkyNTM1NzU0NzAyMzg3NjQ4ODkzOTc4Njg2MzY2MjgwMTI2ODc5ODk4NzY4NTUwMzM5MTA1ODI1MDkwMjYzNDk5OTM1MjY1MjA2MzY2ODY2MzI0NTgyOTQ5NjgzNjg1MzUwOTYxNjg3MzI0NjU1NDI5Mjc5NjgyMzc3OTM5NzMxNzgxOTEzNDg5MTg3MzU4Mzg1NzYyMTYyMzE0MzI1Mzc4ODg1NDUzMDE0NjMwMzY0MTQwMDk4NjAyODUwMzUzNDQwODg3MDE5NDk4OTQ3ODQyMTI1MzA1NzYyNVwiLCBcIjk4Mzk5NTE3MDI1OTYzNzQ5Nzk0MDEyMTcwNzg1NzY3MzI2ODYyMDYwMzk4Mjg0NDQzOTYxMDA3NjMzNDc0OTc5MjExOTUwMjU1NzM4MDM2MTYyNDA5Njk2MDA3MDE0ODYyNzY2MzMwNTE3MTMxMTY0Njg1MTU2NjgxMTY4MzM1MTIzMjI2ODI0MDE2OTg0ODgxMDY1ODA4OTY5ODYwNjQwOTE5NTc0NDQ3MTM0MzQxNjE5NzQzNDkyNjUxMzY4NDg4MjQzOTU5NjE0MTM2ODc5NDE3NTE2MjMxNTYzMzE5MjAyODk3NzIxMTkwOTY5ODU5NTc3ODgzOTQ5Nzg0NDg0NzI4MTI2MjU1OTg5OTkxNDUwNDA4MDA5Mjg0NDgxNjMxOTI5ODI4NjUxMTQzNjY5MDQyOTE3NTc1NzgwNDYwNDY3Mzc1MjgzODc4Njg1MjI3NzI1NTA2NDQzNDM2NTQwMTg3MTkwMzMwNzY0MzcwNS8xOTM1Nzk0OTk3MDk3Mzk3Nzc1Nzc4OTM2Mzk2NjU2NDM0MTc1MjE5MjQ1MTAyNDIxMTk1NjE3NjU5MzIwNzg4MzUxMjE5ODMxOTA0MDE3NjI1NjE0MzYyMDg3NTgyMTA1MTkyMzExMDM3NjcyMzI4OTk1Mjk0NTc0NDA2MDIxNjY5MTg3MDE1NTAzODYxNTIwNzA4MTM1MjY3NjA4MjM1MTM4ODQzOTEwNTUwNTQwNzY0ODUyOTU5NDU5NzIxODU0MDI5NzcwOTU4MTU2MDk0NDg2NTEzMTY4MjQ0NTUyNTAwMDU1MDU0MTAxOTIxMDExNDgxNDkyODQ3NTY5MjgyNTAyNTg2MzIwMzE5ODE0MzkzNDUxNjQwMzczMTgxMjk5ODc5OTk1NDY2ODMxMTM0ODM3MDA2NjA4Nzk0MzE4MDE3MjgzOTE5MTExNjE5MDA2ODY3MDcyMzE1NDMyMTYyODMzMDQxODIwNjMwMzg0NjRcIiwgXCIzMDY5MTAxMzA3NjgzNjM4MDMxOTY1Mjg4NDg0ODU4NTQzMTkxNzQzOTM1ODM3NTExODQzNzAzNTk0NDk1MDQ5ODE1NjgzNjg4NTQwOTExMDA4NzYxNjYwMjA0MzI0Mjc0NzQxMzcyODg2Njc0Nzk3NTYzMTcyNzU2NjYxMzU5MzI1NzYyMzA5OTU0OTU4MzAwMTM2MjI0NjY0OTkyODA3NTg1OTk0NDY5NTA2MDk0NzQzNDg4NTcwNzEwMjY4NDU2ODYzMjU1OTMzOTM4MzQwOTM3ODk5NzU2ODE4MjQ0NTAxOTE4MzkyODA1ODkwMjQ0NTczODcwMjYxMDQzNjE4NzkwNzE5OTQ4MjYwNDg2NzE0ODQ0NTkwMzkyMTQ3NDg0NjEwMzU4NjI1MzMyMDk1MDcyODk4OTIyODg5ODMyNDgyOTE0NDcwMTc4Mjc5Mjc2Nzc2Mzc5NDg5NTEzNzMxMzA1MDM4MTExMjg3Mjk3MjgwNjcxMjU3MDU1OTk0MjU4MzkwNjYxOTM3MzE1OTA1MzY1NDQ4MTI1MDgwOTE2ODEyOC82MDMxOTM2MTkwNTk0Mzc2NTg1MjM4NDA3OTA1NDY5MDM1NTk4NjY4MjExNjc5NTIxNTUzMTQ0OTU4MDUzMDk5NDYzOTMxMjE3ODU2NzgwMTcxODcyMjUzMjU4NzM4NjM1NTMxMzg1NzExNzAyMTc2MzQ3NTc1NTk3Mzg3Mzg5Njg1NTI2MDk4ODg5Mjc4Mjc4MDI5MzE0OTgyNzIxMjg0NjkxMTk4OTY3MjA0NjY0NzcxMTc4NzYxNDE2ODkxMzE3NjcyNzA1NzE5MzAzMDg4NzQ2OTUzNjQ0OTc4NDcxMjg5MDAxNTc3Njk4NTU0MDI1NDEwODIwMDQxNDk3MTA4MzExMjcwNDMxMTMwOTExMDIxNjUzODYwODc0MjM4MjEyMDQwNjQwNzM3MTcxMTAzODIzNjMxNzE4NDgzNTcyNDY0MzYxMjc2NzAzMzc4NTg3MTA2MzExMTUzNDU1NTU3ODk2NTI3Mzg0NDI2MzI3MDUzMTY1MjE0ODE0OTU0MTU0MzI4NDgzMjU3NjU3NDI0ODczOTI5NTAyMTEyOTA0NjI1XCIsIFwiMzM2MzMwMDI2NDEyMTg1NzEwMjc2ODI2OTAzNzcyMzkzMDA1NjcyNzcyOTczMDE3OTE0MzQ4OTA0MzE2NDU5MDk0NDcwNDA4MzA0NTcyNTMxODYyNjI5NzA3NDc0MDU1MTQ4OTczNDAzMTU0OTA5NzA4NDY1NTM2NjYyMDExOTAzODY0NTcyMjE4NDY2OTQxMjY2Mzc5OTg0NjI4NzM3ODYzMzQ4Mzc5MDEwMDE4MzM3NzE1MTAzNTMzNjU4MjUwODcxODc1ODI4MDc4NDM5NDA0NzkxOTI1NDQ3NzI1NTkxMTgyOTM4NTExMzEyMzQ5MTA2Mzg3MDUyNTg2NjQ5MDEyMjU0OTQxMjkwMjMyNDQ5MTYxMjU1NDUyODM2MjE2MDc5MjA5ODMyODc3OTk2NDg5OTI2MzI4MTQ0NjE4Mjg5OTg1MTc5NDk0NDk4ODc1MjI4NjYyNTk3MjQ2NzUzMTgyMzM1MjIwNjA3Mjk2NTQ3OTYvNjYwMzgwMDU3NTE5MDg2NDgxNTEyNTMwNzgxNzkzNDMyNzA1MzUzMDMxMTkxNTU3MjMyMzU0NDIyNTE3MzkzNTgzMDU1OTc1NjA3NzYzNzI1MTUzODA5NjE2NDQ5OTExMjQxMTY3MjkxMzkxMDc2NzAzMjQ4MjE4ODU3MDg3NjUyNjYwNjExODA2ODkyOTkxMzUxNTQ5NzQwMDM5NzU2MjcyMjY2OTYwMzg2MTgxMzQ1MzQxODYyMTI0NjUzODExNDg3MjMzMDUzNjA0NDUxOTI0MjY2MzUzODY2MjA3NjU4MzUxMTA3ODUyMzU3MzMyMDAzNTA4NDc0NDM5OTUzNTU4MTIxNjgxNTAzNDgzNzU1MzE2NTg1MzU3NjYxNjQyMjU5Mjc5MDEwMzcyODE0MTQ0MzY5NzM2MjQwODcyNzA1NjgxMzk3NzIzNDA3ODIxNDM4Njc3MTExNTU4NjQzNjk4NTEwNTAzODg3Mzk5ODg3NVwiLCBcIjkwOTA1NTA3NDMzOTU0NTMyMzc2MDgzNzM3NjE0MjI3MDU5MjI5ODkzNTYzNDY2OTY2NzczMTQyNzc0NjM5MDAxMDMyODMyOTY4ODk0ODg0OTAyMTc2NjM0MDAzNDkzNjE5NjI2OTUyNzk4ODg0MzM2Nzc4NTY0NzE3OTI4NTY4NTMxMDk0Njk0MzMzNTU0MjI4MDI2NjM5NDczMDU1MDM0Nzk1NjE0OTMwMzM4NTEwODE5OTMyNDc1NTY4Mjg1NDQzMDgyNTg4MjE1NTc5OTQ1MTIxMzM3MDg2NTYxNzQ4NjQ1NDQ0NTcxNDM3OTMxMDY3MDM1Nzg0NzY5MTQ5MjQzMjg5NjAxMDkzOTAzNTAwNDA5NTQxNTg3OTc4NDUyODg3ODYzMjEyMTUwMTAzMjQ1NjUwMTA0MjA3MzQwNDQwNTk5Njg5MzE1NTgwOTkwNzc5MzI3NzY1MjU5NzQxODc3MTc2NTUxMDU5NTE1MDYyMjM2NDk5NDc4MDY1Njg5ODQ4NDg4ODMyNTgxNDQ2MTY4OTc1MjYyNTcwMzg1NTA2NTYvMTc4MzIxOTk5NDQzMjQzMDEzMzk1MDQ3MjAxNDU4MjEzMDg4Mzg3MzUxNTA2MzE4MjE0MzUyMzcxMjA2Mzg1OTk2NDEzMzA5OTc3MDc2Mzg3NDc0NDEyMTg5NTg4NTY0NTM0Njg4NDM3MTI3MzkzMDcyNzQ1MDA2OTQzMDcwNDE0NTkxNTI2MTEyNzA2MTUzODI4ODcwMjg1NTAxMTIyMDU0NTUzMDMyNjU4ODc5OTQxMjA3Njg3OTk4NTAyNjAwNjU5Mzg5MzY0ODkxMTYzNzk4NjMzNzc3NjE3NDU1NTE5ODg2NTM3OTU3ODQyNDgzODIxMDQ2NjcwMzY4MzY0MjEwNjkzNDE1NDYwMzcxMDU4NzQwODUxMjM1NzM1MTQ1NTg5MTU1NzU5NDk3NzE5MTY0MTUyOTQ1MTc0OTQzNzI3MDIwODI1ODA3MjkyMDUxNDYwMjI0Mzk4NTE4NDc0NDk1NTQ3NjU1NzAxMjkxMDQ0NjAyMzkxMTM1ODAzNzc2MTIzMjI1MzYxNTE2MjMzNTMzNjIwODM0MzUwNTg1OTM3NVwiLCBcIjM5NjIyNjA4NzEyOTUxMTc4NzYxNjQ3MDcxNjI0NDk5Njk2NTUyOTM5MTU3MTAxOTYyMDM0MjY1NzQwOTE1MDI1Mjk1MjMzMDUzNzM2NjUzNzM1MjE4Mjc2MzQ3NzgyMDE2MDM1NTkzMTAwMzE3NDk0NjEwOTQ4MDAzNjkxNTYyNDk3NDUwMDE4NzE3OTM2NzYxODQ1NzAwODgwMjY2NzA4OTAwNDY3ODkyNTU5NTc3NTI0OTcyNTYyOTQ5NTg0ODE0NjY2OTc3MzU3NDM5NTY5OTAzMjc4NTAyNDUyMjg4Mjg5Mjc1Mjk4NzgyNTA2MzkzMzU3MzM5OTY5MTc2NDg2NjgxNjI4NDA5NzIzMjg2OTE5ODQwNTk4MTgzMDEwNjU2ODgyNjkyMzQwNzk5NjM2NzMyMTM1MzAwMzU2OTA1MjQxOTk5OTg4MDA4OTE4MDQxODc1OTI2NTI3NDMzMTI5OTc4NzQ2ODEzNDk3NDgxMS83NzY1MTEzMjkwMjM4MjU1MDU0MDIwMTY0MTYyODkwNjc1Mjk0NTA3ODk2NDAwMjgyMjU4NTAwMDYxOTM0MDI2MTEyODU1NTA0ODYyODg2Mzk5Njc4NDc0MDQ2OTkwODg1MzYwMjU5MDg3NzcyNjg0NTQ3NTY3MDExMDEyNzUyNzg3NDA4ODYyNTIxNDkxMjU5ODk5NTAxMjk3MTYzMDg1MjU5MzU5NzAyNzY0OTE1NDQ4NzI2NDU5NTEwMDMwMDE4MDU5MTAxNjU4MTI1NDk2NTI5NTI4MDA4OTkwMjQ5NzU0MDA0MzkxNjEyODIzMjg3MTY4NTE1OTEzMTIxMTIxMzQ5NzIzOTU2ODQ4MzE0MTAzMTEzNzkwOTIwODAzMTM5MjQ2NDgxNTE4NzUwNTcxNDA2NjIzNTg2ODc0ODk1MDE4NDA2NTkyMzIzNjY3MDQxODgyMjkxMTYxNDc4MDA2MTc1MjkwNTE3MDk0NDAwMFwiLCBcIjEyODg1MjMxMzA5MDA3Njc0MTI0Nzc4NTY5NTIwMzU2OTA4NjcxNTM0OTY1ODQ3NDc1MTAyNTM5ODQ2ODYzMzYzODI5ODAyMjE2MDM5MTc1Mzg5OTYxMzgyOTQzMTEyNzQzNTc3MTM4OTM5NTY3MjU2NzIwNjI4MzIyNjQ4NzE0MTUwMjU3NTAxMzY2OTAxNDM0MTE4ODQxMTE1ODAzMzU0NTg1Mzk4MjQ1NzMyMzk3NzEyNjcwNDM0MTQyMjUyNzE3MjkxNDE1MDgyMzU4Mzk5ODIwMzMxODI2MDU0NDUxNzMwNTA1OTAxNTE5MTIyOTc3MjA4MDAxNjg2ODczNjk4NTIyODAzMjMzNTY2OTEzNDUzMTc2NDk0NDU4NDMwNzgyOTEzNjkzOTQzMjQ4NjIwMzkxNDMyNDcwODc0NDIzMDkxMzUwNzQ0NTMyNjU2NTg3MzAwMjgxNDU1MDA4NzE1NTk0NTg1MTkyODI0MzMwMTI0OTQwNTQ3MjQ2NzgzMDI5NTcyNzYzNzE0MTg5MzYyODI5MDI0MzQyMDMyMjU2MDAvMjUyMjg0NDUwNTE1MDgwMzcwNjAzOTQ5MjEzMDg0NTI5OTkzMzk1MDUwNTc1OTUxMTg4MDQ0MDMyOTA4MjcwNDcwNTE0OTk5ODgwNTU0ODYyNDQ5MjIzMzQ3NzYxNTA3MDIwMzU0MzIxNDIyNzg1NzYwMjc5MTU0OTEzMzEwNDg4Mjk2NDg1OTg5OTc5NzA2MjA4MjU0MjA2OTc0MDc1NDM4NTcwNTIxOTM5ODI2MTI0ODYwNDgzODQyNzU4MTM3MjMxMzczMTgyNDk2NDM4NTY4MjAyMTEwMzM3NzUxMjkxMTA2MTY1NjU0OTQ1MzUyMTgzMTY3NTc4Njc1NTA4NjAyODMyNDc4NzUyNDAwMDExNTY3NDgyNDM0MzAxNjE0MjY5NTc5MzY4ODgyODU4OTczODUwOTE0NTEzODcwMjk3MDcxODY2NTQ0ODc1NjUwMTg5MTA2NTc2NjcyMjg5NzM0MzI2NDkyNDkyMDU5ODE2NjY5Mjg4OTA3MDE4MDk1ODMyODQyMjQ5NzM4MDgxMDIyMjI3MjgxNzE1OTE5MzU3XCIsIFwiNTU5NTA2NzgyMTc1MzY4NzQ4MTg3MTQ1MDY3MjM2OTAwODAzOTI1ODIzNzkyMDg4MjkzODUxNDUzMDA1ODgyNjIxMTczMTI0NTkwMzY4MTAxMjEzNjUyMzcxOTY1NzQwMzY1MTE5Mzc1MDY5MDUzNzQ3NDE1NDE1Njg0MTkzMDkyNjA3NTIzMjExNjM2OTEyMDc0MjE5MjE1MDUzODA5ODgxODE0ODU5MTI5NTE1NTkxNDc5NzgwNjY5NTExNTMzNjE5MjU4ODM1MTk5NzE1MTQ2NjU1Nzc0OTE5NDE4NDM0MDgwODA3ODM3NTg3Mzk2MTE1OTU1MTA1MTI2ODA2NzYyOTYxMjkyNDI5OTA0MzgwMTMyMTE2OTg2OTg0NDM1NTI4MzA3NjEzMDU0ODI4OTI5Mjk0NjAyMTg1OTI3MzIyMjM4NDYxNDkxMDU5NzQwMzQyMzg3MjY2MDg0NDMxOTg4NzI3MzIxNzExMTg0MzA4MTc2LzEwOTQ0NjE4ODIxNjg2NDQwNTE1NDkzNjY4MjM3NDYwOTQ0ODA4MjQzNjM0NzYwMDMwMTc2NTk0NDIzMzI3ODMwMzY0Mzc0NDczNjU0NDEwOTI2Mjc5NDM4MzA2OTE5NzI3MTQwOTM5ODYxNTg0NjM4MDcwMTQ1OTg4Mjc4NDU0Nzg1NzgyMTgzMTgxNjg2MzIxNjA4MDA2OTk0NDgxODQ1MzkwODc2MDQ3NjQ3NTg3NDMxOTc5MTUxMjc4MjQ0NTQwODEzNjE2OTg3ODIwNzM1ODY2MzI1MDQ5OTYyODAwMjk3MTY0NDQzMDE2NDE4NTU3ODk2NjM5OTkwODYyMjY0MDczMjQxMTg4NTU2ODYzODA1NDIyOTE4MDY3Mzc1NTY5MDg4OTQ3MTM4ODU4NTUyMTExMzg2MjQ5MjQzMjk0NjExMDkwMjA3MDEzOTY3OTE2NDg4NDIwODk4ODQ4OTk1NTg3NDEzMTIwNjM0MzU5NzM3NVwiLCBcIjM2NTg0MjEwOTc3NjA4NTI1NjIwNzgyOTQ1MjM4NTc4MTEyOTQwMjY1NjY4NDU2OTkyMjMyMDgxMjYyNTQzODI5Njk1ODE3NDEyMDA4NDgwMDA2NDY2OTA0ODAxNzIyNzAzMzE4NTk2OTU5NjQ1ODc3ODIxMzMwNjE1MjM5Nzc2NjYxOTY5MjY0NDY5NDY0MTY3NzIyMzIxMzE4NTk3NzYyNjk0MDE5MzEwNzYwODEzODgyNzc3MTI1OTMzNDM3OTg5NTAyMDM3NzcwMDc1OTc4OTc3NDk5NDgwMDAwODkzMzEzNzU2OTU0MzU5MjgyOTIyMDYxMTU0MzA2MDE4OTg0OTYwMTgyODM0Mjk4OTAyMzY5Mjg3NjE4MjE0ODgxODM2MzY4OTI5MzAwOTE3NDM1ODE2ODgyNjM0MDAxMDQ5MTcyODcxNTU0OTkwNDk4ODE5NjM0NzMxNjcwMzk4NTg5NDM1NTIxNzIzNTMzOTU0ODA3ODE4NzE2NDE3NjI1NTQwNTU5NjMxMDYwMjkyMTY0NzIwMzQyODIwMDI2OTY2NjE3Ni83MTQ5NzI2NjkzNzc4MzgyNjMwNjc3NDM2NzIyNTE0OTgzMzc4OTc4ODMwMDYwOTUzMDY4MDM5OTk5NDgwNDcwNDE5NjIxMjI1MjE0ODMyNDU1MjE5MzE0OTMzMjc1NTA1Nzk4MjY2Mjg0NDk4ODU4ODY3ODE1OTYxMDUxNjYzNDY2NzU5NzcwNzIwNDgxODI5NjQ1NzYxNjMxNTQ4NDk3MzI4ODk0NDYzNzEzOTkzOTkxMjE2NjAzNDY5MTE1NTI3MjA3ODYwOTg3Njg4ODkxOTE3MDg5NDkxNTIyNDAyMjk4Mjc4NTEzODkyODAwODEzMzAwMzQ3MzMyMDAxODE1MTM3MDQ4Njg5NTYzNzkzNjEwMjUyMDM1Mzk1MTUxMTUyNTk5NjE5NzI2NzU3MjM1NTc4MjYwODM1MjA3NTIyOTU0Nzc2NDczMjYwMjU1NzEzMzQ5NDY0ODIzNzI1ODkwMDI3MzM1NDM2NDA1MDY2MjkyMTg4OTkzNzM1NTY4MjQ4NjI4Nzc5OTIzOTM2Mzk3NjU1Njg0ODMyMDA0NjkzMzg3NVwiLCBcIjU5Mzc4Njg0ODk0NjA1NzczMzk3MDcwNzgzOTM2MTEzMjQ0MjYxMjk3OTY2ODYzNjY4NTQ2MjgyODg3Mjk4OTk5ODExOTUwNTk5NzcyNzMyMzc3OTc5MzgyNjIwNzY2MTgwNjYyMTU5NDYwNjY2MjIwODk0ODk2ODk2NTY0MzU3NTMzNjA0OTYyOTc3OTY4ODQzNDc0MDYyMDkyMDgzMjc5MTY1ODM3NDI0MjEwNTkxMDQyNjU1MjcxNTc3OTc0MjcyMzk0MjAzMjUzODc1OTY1NTg5NjExNDkzMzg0Mzg0MjU3MTE3MDg4NTE4NTIxNTk4Mzc5MzAxMTY5OTE2MDYwOTUxMzUwNjUwNjIxNzU3MjM3MjA2ODA1MDM3MjYxODc4MjEyNDI0MjY3NzgwMzEyNjE0OTQyMTczODcwNjUxNjg0NTg3MTY2NjkxNTM5OTA5MDY4NDUyOTMyODkxNjQ5NTU0NTc1MDcyMjA1MDgwNzYzLzExNTkzOTE2ODc3OTIwMTMxMjYwNDg0MTQ4MzIyODEwMzE3NjI5MzI2ODUwNzYzMDU3OTUzMDI1Njc0MTU0OTI4OTIwOTc3OTY1MDk1MTQxNDg1NTM2NTY2MjE3ODczNzk2MDE5MDA2NzA5MjQ3OTM4MDE5NDA0ODQwNDQwNTExNDMzNDY3MDQwOTE4NzcwMTY1NDU2OTI1NjA5MTI0MTY2OTcwODYyNDMwMTA0MzI5MzU3NDE5NjY5MTc1MzIzNzYzMTQzMzc3OTE3OTEzNzYwMDI4NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsIFwiNDQwNzA2NjI5ODQyNDAyMDc1MTM3OTI2Nzk3NzMyNDA1MjY4MDE1OTE1MTk5MzM0MzQxNTY1MjE4NDQzNzQ4Nzk4NDc5NTYzNTA1MTI1NjA1NDc4MDYxNjY0MzI3NjU4MTM3NTk4MjA0MTkyNTU0MzUyNjg4ODMwNjc5NDc1ODQwMzg2ODgyMzUwMDM0MTUwMDc3NTA2ODA0Nzk5ODU5NTg2NzcyOTA0OTI5NDAyNjgzMjc2ODk4MDk4NjAxODE0MDkxNDMwNTk4MjU5MzQ3OTgwNTczMDg0Njg2OTMyOTQ5NTAyODA5MDY4NTY1NDIwOTM3MzAxNjMyNDk0Mzg3NjkxMjg0OTAyMDI2MDg4OTUwMDkzODg4NDI2ODcyMjIyODEzODU3OTI4MDkyODcxMjY3MTMwNTA1NzQ0MDk1Njk3MTcyNDk0MTE5Njg5Nzc5NDc0ODQwMDM3MjY2Mjk1NTg2MzU5MjQ0ODk5NDc3NzgxMzQ1MjQ5NjU3NDU1MTg2ODQ3NDUyMjQ5MDQwODk1MTUxMjg4MTE0MDg1MzUyOTc0OTMzNzA4NTQ0Lzg1OTcxODc2MzE4MzM0MDEwNTQyMzEzMDQ4MDU2NzczNDE5NTY3Mjg1NzAxODUyODE2MzA5NzExNzM4NjQ0MDc0MzAyNDY3NzYzMDc1NjcxNTMxMjQ4NzkzMDgwNDI1MzQ5NTcwNTg0MTAyMDc4NzY0NDY0MTk2NjUzODQzOTczOTM2MTE5MDM3MzIyMDAwNjk1OTQ5MjA5MjgzMzI3NjA2MjgwNDIzNDA2MzAyNTE3MzAyODc0ODA2MDkyODM1Njk0MTk2MzUzNzc4MTYxNjYzMzM4NjY3MDkxMTk1MTk5MDMyODMxNTg3ODk3NDEwMzI5NTA5NDg3MTY1MTg3NzUzNDE4NjE1MzU2ODM2NjM2MzUyMzE5MzEwMTAzNjM5MDc5MTIzNjk4MTE4OTk3NTAwMDY4NjQ0NTAwODkzMjgyNDM4MTM3NjE0NDIwMjg4ODM5MjMwODI3MDk2MTA5ODM1MjA2NjA1Mzg1NjczMTk3MTIzOTk0MzU3MzkzMjU3MzA0MDQ5MDkzNjgzOTM0MjI0ODI2MDA2NzA0MTk4MTcxNTkyMzA0MTI1XCIsIFwiMTMyMjAzNzExNzgzMTIyODQyNDgxMDc4NjM4NDkyODc1NTg2OTYyMTA3NDE1MzUyODAxODQwMDMzMDE1NTUxODgwODY3NjE3NjcxNzY1NjA4MjMxNzQxOTY5MTUwNzAzNzg3NjMwOTE4ODkzMzMyMDM2MzU3ODQwMzcyOTQ3Njk3NDc2NDE5NTk4NjA4MTAwMzk4MTY1MzM2MDkxNDA2NjIwNDM0OTM5NjI3MDc0NDU1NjQwNTcxOTcxNTA2MDMyMjY3OTc0NDY5MzM1MzIxMzM5NTYwNTQ2NzExMDM5NDI1MjAxNDI1Njg2NzQzMzk0MTEyNTAwMDE1ODU5OTE3NDM2MDg3MjMxNTAyODQyNzAxMDEzMjY0MTk0NjQwODgyOTAxNTE0ODM4MjMwNjE2MTM0MDM2NzM5NTY5MTg0NTg0NTYxNjU1NTI0ODI5MTMwNzkyODM1Mzc1MzYyMTQ5NjcyOTQyMTEyNDQzNjEzNTMwNjAvMjU3NjY4MzAxMzc5NzA1NTIyNDM3NzcwNzcxMzcwNDg5OTMxNTM3NzM3OTU0ODYzMDUxMTA5NTEzNjU2ODIyMDE0NTgwODc4MDE2MjY3MTQ3MzkwNzI2MDYyMzUwMzU1MjM4NTM4NDQ4MjcyMzE3MzkxMzU2MjQyMzMxNjk5NzUyODkxMzY1MTA0NDI3NzQxODIyNzYxNjQ0NzgxNTYwOTg3Mzk5MTAyODA3MzAxMTczODExMzkyNzk2MTgyNDYzMjg2ODk1NjgwMjI3MTI2MDI5MjA3NTgyNTU2MTY0NjE1NjY4MDc0MDMyMzY4NjEyNjgxMTkyODM3MjY3MjY3MDkxNzMzMjYxMzQ5MDI0MTYxNTg1MDk1MzY2MDI0NjI3MTU0MTU5MjA1NjE0MzYxMTU4MTIyMzI5NTA0NTA2MjE1NzQwNDk5Njk1ODEwMDEzNjM1ODY0OTEwOTY5MzY1OTYyMzg0NzAyNDAxMTI2NTE0N1wiLCBcIjE1MzgzNzI1NzgwNzIyNDY3MDUyNjYwNzgyNDc5NTAwODkyMTk4ODExOTcxMzkzOTkwODE2NDM2NTAyNzEzNDg3NzAxMTAxNzgyMTc5NTk4NTY4MTkxNzAzMjU0MDA0NzY2NTU5NDQxMTU1NTMyMzg5NDA1NDE2OTUxNTIxMTA5NDkwODE2NzU5ODUyOTkxODk5MTM1MTU5NzUyNDI4NDA0NzM2MTYxNjk3NzU4ODAyNzI0ODk4MDUxMjMxMjQ1NDgyNTY2NjY2NTg1ODQxMjk4NzM1OTcxOTIyMTMwODAwMzg5Mzc0MDkwNDYxMTQ5MDg3MTkyOTgxNzAwNzg0NzYzMjU0MjM0NjY3MzQ0Mjk4NzAwNDg2OTczODMzMDQyNjUzNDIxMjU0MjUwODcxMDU2OTgxNTI2NDMxNDU1MzE3NjA4NTMxMjc4MDExMjMyNzIzODkxMzQ1MTQzMzM3NTIxNzMxNzMxNjE1NjIyNzM0ODc3NTIwNjQ4NTA0NjE4MjM3MjY5NDg1ODgyMjE5MTM1NDA3OTk4MTY0ODk1NjY4ODM3OTg5MTIvMjk5NTY2MTAyNDQ2NzQ1NTUyODEzNTQ0ODA4MTY5MzIzMjcwMzE1MzI3MTIyMjQ5MzI3Mzk0Mjc5NDY3OTk5MzA4NjY5Mjg1NDE2MTc5NDg2MDc1MjU1MDIzNTIzNzI2NDQ5NDI4MTUxODA3NjcyNTI4MzY4NjA2MDcxMDQ3ODEyOTA3OTM1NDI2NDA2ODg2MjUzMjg0NTgwMjk2MzQ5MzQ5NTU4Nzk3MTI4NTkzNDQ2MzE2Nzg2MjQzNjY2MjkwNjQ5NDQyOTU2MTM0NDQ4NDgwNTk4MzAzNTI3Nzk1OTk2MjIyNzAzODM3NjYzNjA1NjAwNjI0MjcxODA3NDYxNjA1Mjk1OTU2Njc0OTI1Mjc3NjU4MzMxNzYwMDAwMTE3NzYxMDEzMzgxMTk5ODgwOTA1NzQ4MTg4MTUxNTU2MTg0NjIwNzc5NjY3NjcwMjc4NTU4ODM5MTE2OTgzNjM2OTcyNjgwNzQ5ODM2NDk3MzQ2ODYzNzUyNjYyNTIxMTk3NzAwNzE3NzAyNzkwMzU5MTYyMzA3NjE3MDI0NTY2Njg5MjcxNjI1XCIsIFwiMjgxNjk2OTM3MjIyMzYzNjg1MzMzNjg4MDk3OTE1NTM5MTQ2MjcyMTE3NDE3MDI0MDcwNzI4MDMxMDYzODIxNzgxMzk4OTg1Nzk1ODEzMzMzNjUwNTQ3OTgyOTY1MzQxMjk4ODk0NjM0NzYyMjg5NjY5MjU2MTI5ODA1NTQ1NTQ5MjgwMzU1NjQzMTIyNTAxMTgxODUyMTM2MzMyNTI5NTE1NzU2MDc0NTAyOTAyMjA0ODc3NjY0Mzk1NDU2Mjc4MjA1NzcwMjA2MDE5NjYzMDgyNTExMDk4OTU2NDY4NzI0ODI5NDc1MjIwOTk2NDI3MTMwMjk1MDEwNDMwNzUxOTQyMTI2MjYzNjIwMjA2ODg2NDA0MjQ0NDMyNDA5MTY0NjUxNTI0NDA4MTk4Mjg2ODMxMzI5NjgyNjA1OTU5ODgxOTkzODQ1MTg5NTg1NjQwODc0MjIwMDMyNTE1NDY1MDE0MDk3MzQ1NzU5NDkwNzUwMzA3MjA3LzU0ODA2Mjc0OTI3OTM1NDk1NTk2ODkxMzEyMDI5MTczODYyNDczNjg3NjEwMDk5MzI1OTk4NTgzMDkyMDkxOTE1MTAxMjY1MzkzMTU3NjMxMjQ0Nzc1Mzg3ODMyNjIxMDMyMjMwNDM0MDA3NDg2NjAyODE2OTcyNzY1MjEwMjA1NTk2NDgyOTQyMDkxNTE4NDU5ODQ5Nzc1NDU4MDg5NTc1NzQzNjk5Nzk3MDk2Njk3NTQyMzA2MDQ5NjI4OTM5OTE5NDY2Mzc4MTg5NjU2MDY1NDYxNzA4Njg2NDIxMTMwOTU2OTk2OTY1MDA0Nzc2MTA4NDk5MjczODcxMDU1NjE1NDEzNTY2MDQzMDgzNjM0MDkwMDgzMDk2OTY3NTY3OTY1MzczMjAzNjgzMjMxMTcxNTk0OTIyMzQ3ODEyOTY2OTA1MTQ5ODczMjY1NjU0OTYyODk2NDU2NDUxNjgxMzMyMjE2NzM1Mzk2MjQ5MjA2Nzg0MDAwXCIsIFwiMjI4NTA2MjM4NTMzNDEwODA1MjM4MjUzMTIyOTYxNDcxNjM3NTAxNDk4NDA2MTA0NDMwMDQ2NzI3NzkzNDIwNDk3ODk1ODUyNDEyNTEzNTYwMjAzNDc1NDQwMTU2MjE2MDYzNTc0NjU0MzcyNzI2MTk0MjE1MDEzNDA3MzI1MjA3NzYzMzY5MDc1MjUwODE5Mzg2ODk3MDg2NzAyNzU3MTI1NDE4MzI3MDg0MzEyOTMzMDYxNzM4MzkyNDA2MzIxMDAzMjMxODUzMzQ5ODY1MDAzMzIyNjk3MzYwNjU5NzEyNzcxMTY3MDY2NDUzNDMwMzA5OTk3NjM5NTQ4MzIwNjczMjc5OTY0MjEwNzMwNzAxMzczNzA3NzY1MDUxMjQ2NTk1ODA2NjczODY1NjQ2NjA3ODQxODc2NDYzNjA4MDM5MTExMjUyNjA3NDUyODQzMzcyOTcwNzk3NDc5OTU5MjEzNDQ3MjM3NTQwODMwNTYzNDY5Mjk3MTQ0NDQ2MDY5Njg5MTQ5NTQ5NTE1NDU3MzE4ODk5OTgxNzYzNDg5NzkyLzQ0NDE4NzU5ODEzMTg4NDcwMjQ2NTk2ODIyOTc0MjgxOTMyMjE5MDg4Njk3MDA1MTIzMjg1NTk4OTA5MzI5MzI4NDE5ODc5MjEyMTY0NTY0NTYxNTU4NjU2NTQ3Njc4MjExMjY1NTI5ODAzMDg2NzAyODQzMzgwMTI4NDU3NzQ0NDQ1NzY1ODU5MzkzNDI2Njc1Mzk2MzkzMDUzMDk0NTg4MjQwNDU3NTY5MzgwMTU1NTI2MTc5MDQwODkxMDA5NzE3MzIzMDU5NjQxMDM1MTg5MDE3OTE4NDk1NDg1NjMwNjU3MzYwNTI1NDEwNTA2NDUzNTU0MjU1NzM0MDA1NDU5NjE0ODU4OTcyOTA0Mzc0NzM5NjczODM0MTQ1MDgzNTEyMTYwODgzNDAyMTUxNjM2NjY0MjA4MjUzMTE2MzYyMDg5MjExNjU4NjQ1MzEyNzc4NDA0ODg2NDYwMjAzNjAwNzYyNTQ2ODEwODk3ODg5NjI5MzMwMDIyMzA5NzA1NTgzNDM4Njk5MjUwMTA5NDkzNzMyNDUyMzkyNTc4MTI1XCIsIFwiMjM5NjExMDI5NzE4NzU3MDUwNjI1NzgzNjQyNjI1MTkzMDUyMTI0NTExNzk2MDk4MDY2Nzg5NzE5NDY4MDg5NzQ3ODk5NjMyMjU5MDkyNTM4MDMxMDkxNzQwMDc2MzU4MTc4Nzk4MTk5MjEzMTc2OTA3NTk2MTI1OTM5MzY4NTMzMTUyMzYwMDI4NzM3Nzg0MTk5MDY3ODExNzExMzU2Njk5MTEwMDcyMDk5NjA1OTE4NzE0NDkzNDU2OTcwMzA0NTk2NjIxMDMwNjI4MjM0ODUyNzcyOTUzMzgwNjg4MjQwODMyMzk2MTMzNjE2NjE5MDE2MjA3NTE1NDU3OTM0NDE4NTI0NDk1NzY3MzEzODM3MjM0Nzk5NzEzNDM4ODgwMTA4NTc4ODM1MzQ4MjI3NjI1NzQwMTAwNTczNDkyOTA1OTcwMDM0NjY4Nzc4MzQwMDc3MjMzMTI4MDY0NDY0NzA4OTUyMDY0NjU2MjY2OTg1NzY1MjY0OC80NjUzNzAxNTQyNjI4NjMwMzA4MDA3MjkxODA3NjMwOTE5Njc1NzM1MjI3NzkyNjA0MDc2MTU1Njc1NjMyNzQwOTYwMzcyOTc1OTM3NjQ5NTU4MjA2MjYyMTM4Mjc5NjI2OTc2MDEzMzQ5MzU3NzM4MDIyMDE5MTk0ODM2NTczMTAyODIyMzYxMDAyNTA1NDM5OTIzMzQ4NjU0NjE4MDA5NzY4Mzg3OTEwMzUzMzU4NjE0MjA4OTI5Njc2OTk4NDM2MDg4NTUxODU3MTA3NTM0MzM4NTIyNzk3Mzc3MjQ0NDYyOTQ0NDMzMzczNjM0Nzg2Nzk2MDEwNDk0MzI0MDQ0MzU2NzI0NjkwOTg4NTA2NzYzMDI3MjgxMTYzNjk5Nzk0NjAyMjIxNDgyMDY5NDQzMjM3MzA1ODYxMzgwODc4NjI3MTkzODYzMjczOTYzMzQ0NjgzMDI2MDg0OTkyMzUxMTI1MjAzMTgzMjI3NjM4NTc2NzYzNzVcIiwgXCIxMTg4MjcyODg4MDc1MjQ3NTIwNDUzNTY4NzkwNjUxODE5MTg3NDg2Mzg5NTQ2NzU1NzQ1OTYxOTUyMDMzMTUwNTc2MjQzNTc1ODYyMTIwNTY5Mzk5ODA4NDY3MDY3ODAwODMwODkwODc0MzkxNDg3ODIyNzIzODc5NzE3NTI1MjY0ODc1NzIyNzIwNDE2MTczMjc2OTYzMTcwNjcyNjIyMjE0MTIxMzA4MDM4NTMwOTY4MjkxNzU4NDQ1NTEwOTgyMTg2MDE0Mjg5NzQ1MDI2NDM5NDc3MTk3MTQ4NDQ1MDg3NjE0ODEzMjYyMTcwOTc1MDU2ODY2ODgxOTA5MDU2NDUwMDIzMzI0NzQzNDA5MTE0MTE1MTQxMTQ1MzQwNDgwODQ2MDg4ODY5ODA3NTQwNzk4MDczNDE3MDM1MTY4MTM5NDc2MTUzODk3MDY2MzI1MTI3NTQwNjA5NzU2MzEwMDY4NTU4NjEwMTEyNzMxNjA3NTIyMDk2MDk2ODIxOTM4MTYzMTM0MDgwNDI2MzU2ODk0ODk5MjQ1NTc1NDEwNDk0MDgwLzIzMDU4Njc2MjM5NTkxNDg2MzYyNTcwOTA0ODc4OTkxMzg0MDUxMTEzNDAwNDMzNzk0NTcwMDM2ODExNzc5NTE5NTc2OTU3Njg1NjQzNDU4ODE0NDM2MTQ1OTc0MDgzMzAwNzEyNTUxNjkwNTAxNzQxNTE4NDc4NzA3ODcxMDAwMTk2OTgxNTQxNjI4MTM4MTQyNzM4Nzk0OTI2Mzc5MjIwMDU3Nzc5MTY0NDI3ODIzNDY2MTk1Mjg1MjE0OTIxNjU0MDQ5MTg1Mjc1NzE3NDg0MjE0NjM3Njc4ODI4MDY3Nzk1NjM1MDkwMTA4MjgzODQ3NDcwNTIyNzY0MjQyMDI2MTY0MTc4MzcyMjg5MTk0ODcxMDgzMzg5ODI0ODU2Njg5MzMyMjE0NDQzNTQ1Nzk2NzQ1MjQ0OTk2NTc3MjU0MzA3NzQyMTQwNzgxNjIyNTcwNDk1MjI3MDY5NzAxNjE1MjQ1MjAzMjUwNjg5ODMxMTI2MDk3OTU5NDU1MDE0MzM0NDk3MTQxNjc4NjU5NTg4ODA1MzE0OTM3NTI4NzEyMDczM1wiLCBcIjEwNzIxODQyOTkyNTg0NjgyNDkwMDQxMTQ1MzYwMjM5MzQ4Njk1MTgxNTI2MTgzNjk4OTU2MTMyNzE2MTg2OTg5MDg0MDU1MTQ2MzAxNTQ4MTk0NTM5Nzk0NzcwNzc3Mzg1MjY2NzM3MTYyNjQ4MzAxMDY3NDUwMzEzODU5NTE3MzYxMDgzNzY4NjYyNTM5NTUzMTk3MTEwMjYwNDIzODkyODIwMDkzNDg1OTQ4NDU0OTcyNTIwNTk5MDY5MDE3NDg4NjAxMTE5ODY4MTEzNDU3NDI5OTg5NjgyODQwNzcxMTkxNjUwODI0MzU1OTgzODE4MTAzMDY2OTEwNzgwMzcwMTg0MzI3NjYxMTY4NjU3OTI2Nzc5NTU1MjA0NjUzMTkxODQzMTE1Mjk2Njc2NDI5OTUyMTcyMTQ1MDc2NTg2OTMyNTk2OTQ1ODYxMDc4NDcwOTk5MTEzNDEyMTk5MTM1NzYwMzg2MDU4NzIyMTg2ODA1NjIwNDcvMjA3ODgyMTI5NTM1NjA3MTE4NTIwODE4NTY1ODExMTYyNjQzODExODExNTYzNTE2MDA2ODM2OTI0MzQxMTIzOTc2ODQ4MDIyOTcwMDI0NzkzMDA0NzAwNzEwOTkyOTM4OTg3NDc2NzI4NjQwOTQzODM0MDEyNDczNjg3ODkyNDgxMDU5NjE4ODIzNTIwNzIxNzM3NDc5MzY0MzUyODg3MTc4MDE3ODY2NDI1MDI3OTUzMjU1ODU2NDQwMDk5NDQ2MTEyNTA4NjYzNjAzMzE5NzQ1MDY2NzUwNTIyOTM2NDA4NzgxNTkxNTc4MzIxMDMxMTczNjIwNDQ1ODY1MTEzMjk1NDA3NjAzMDkwMzIyMjgzNTM5OTc0NTYzNjkwMTU3NDE4OTMxMDYwNTY1Njk4MzE1NDA2MDIxNTY5NDkxNzUxNjEyNzYxODg4NjQxMTQxNDQ2NDA2NTMxNjQ1Mzc5MjY0NzIwNjg0MjQ4Mzk4Mjk5MTM2MDAwXCIsIFwiMTU4MDk0MDIzOTA0Mzc0NDY0MDU3NzAyMDEwMTI2OTkzMjMxMTUxNDMzNDc0MzYxODIwMjY2NTg0MDIwNDAwMTAxNTMzNjUxNTg3MDcyNDMyNzI4MDUwNzc2NTA2NjcyNTI3NzE4OTc1MDQyNjE2NjUxMTc3MDM0NjM1MTg4MTc4OTY3NDYyOTgyOTI2MjYxNTE2NzQ4ODQyMDczNTg3OTgxOTUzMDM4NDQ1OTc3NTE0NDQ2ODM4NzMzNTU3OTI2Njk2OTM5NTkxMDY5NzEyMzk3OTQ3MDU1MjYxNzc3NDE2NzA0MDI4NTA2NDQxMTczNTQwMzM4MzI3NTkxNTE0NjUwMzk4MzQ5MDY5MzQ4MzgxMzA5Njg4Njc3MzM1MTMyMTAwNDQxOTA1NjAzNjY0MjgyNzM1MzEwMjk5Njg2MjY4NzIxNjM0MzY5NTAyMjk2ODY3NDA5NTE0Nzc3MzU5OTM1MDIyMzAxNDI1MTY1NzUwNzgwOTg4MjMxNjM5ODI4Njc1NDI0MjM5OTMxNTMzODQ5ODk2NzQ0MTk4MDEyNzQ3NjcwMjcyLzMwNjI2Mzg0MzY2NTEzOTIzNjcxMDYzOTU1NDY5NTM3Nzc2MjkxMTgyNTk0MDgwMDgzNDk0NzM3MzQxNjA0NTc5NTc1NDQ2MzE5MTkwOTE2OTI0NjgyODA5NTQ2MDI0MzY5MzMwNzA2MDEyNjUzNzk5NzgzMTIyMzI4Nzc1ODc1Mzk5MzYzNzU5MzA4MTkzNDMyMzI3MzU4ODM3NzcyODI1NjA5MzU2NTUzOTU1MzUwNDAxNzI1Njg5NjgyODM4NzAxOTk2NDQ2NDA0NTU5MDA1ODk2NDc5NjE4MzExMzU3NTczMjAzMDgxMTUzODU1OTYxNDg0Mzk4MzYwNjcwODM3NTk5ODUzMjk0NjI3MTUzNzQwMjI0NTQzMTc1NDk3NjU1NDE0NTg1OTE4MjMxMjE1NjM5OTA2OTI0MzEzNzc5OTMzMjExNzc0MjkxNTY1NDI1MzYwNDE1Njg0NTU2NjU1MDIxMDMxMTMxMzQ5MzE3MzkwMzgyMzIwMjg2MDkyNjY3ODUyMTczODE1MjU5NDIyNzM3OTU2NzY3OTIyMTU0Nzk4Mzc1XCIsIFwiMTIyMTYyNzg5MjQyODY0MDE4OTc0NzA1NDAxNjk4MjI1NDI0MTc2MTEzNTY3OTc2NzYxNjAxMjgxNzY3MDY3MjEzNDM1MTE1OTg5NTE4NjYxMDc4NTg3Mjk0MDU2MTU2MzEyNDYwMDM0NTgwNjI5NDk3MjMyOTAxOTIyNDI1OTQ2MDk5OTQ2MTM3MDUxODM0NjA4MTQ3OTc1MjcyMTQ1NDkxNDIwNDM1NzM4NjM5NDc2NTg4MzI2OTQ4MDAxODQ2OTEyMjI0MjY1MjE3MDM3MjgzOTQyMDM3MjI0MjAzMzY3NzMzMTA5MDg2ODcwNzE2NzAxMDc3OTQ1NDMwMjI1Njc5NDM0Nzg4NDMwNjUyNDYwMTE1NDQ4ODgzOTA3NTc4MTA1MzQyMTE1NTQ2NjY3MzYyMzk1MDY1MDM2MTM3NTA3NTYyNDYzNjQ2MjE1MDkzNTk4MDQ5MDIyNDM0ODcxMTM2NzMwMTQ1ODgzMjU4MDYyNDk5ODgzMzIvMjM2NDU4NDEyNzczNDY4MDU4MDQ4MTcwODM2ODkyNzkyMTEyNTkzNDMzMDAwMDE2MjkzNTExODM3MTE3NDI2OTY0MjgzMTQwOTA4NDYzNDM3NTY1NDIzOTczNTA1NDM2MzkyODc0ODE2MjIyOTI5NDgyOTUyNjMzOTkyNzkwNzc3ODUxMDUzMDQ0NDY0Njc1NDYwMzMyMjM3MzcxMjc4ODE0NzE5MzY5MTAzNzY4ODU1Mjg1NzE4MzExNjMzMjI5MjA0ODczMTcyNjMwNTQ1MTUxNjk1NDY3OTI3NzMyMDc3Nzk1NTM0MjI5NTU2NDAwMDU4NjkyMzIyNzc3NTIwODU4MDc3Mjg2ODU5MDc0MjEzNjE1MDQzMTE1MjQ5NTcxODEzMjE0Mjc0MjE1MzY0MzA4MTE4NzY5MTg0OTgyODIxNzU5Mjk1NDUxOTQ4NTg2OTEzNTkzMDc1NTY0Njc2ODM3NTI5OTg3MDk2Nzg2NDk5MDIzNDM3NVwiLCBcIjU3ODkzOTE5NTAxNzQ0Nzg2NDM4NTgzNzM0MTk3NTU1ODY3OTI5MjkwMzcxNjU4MDExNDQyMTAzMDUzODcyODc3ODQ5MTYwNjI4MjE1MzU4ODkzMDk4Mzk2NjEwMDUxNDE0Nzk3NjMyMTMwNTYxNjE5NjQ2MzE3NDA3MDM0NTg4NDI5MjY3Mjg0MjQ5NzcxNTk2NjkzMzcyMjA4ODUzNjYxOTMzMzkxMjY4NzEwODczNzY1NzA2ODcwMTM1MjkxODU4MjY1NjEwNTQxODQ5MTY3MjM3NzI3MTMwNDk3MDQwNzczMDc4NjkzMjkxMzQ5MDg2OTc5NzQ3MTA4MTA4MTQzMTA3MjgzNjgxNDU4MTA5OTI3MTgzMjY5Njk5MDA2NDgyODcxNzI4NzI1ODg2MDE2Njg0Mjc5MTk4NDE1ODYzNDY4NDA3ODM0NjQ1MzIwMjkyODEzNzk4NzkzMDMyODgyNjIxMjAxMTc3NDY3MDM5NjM1NjE1MTI2NTc4MTA1MzU0NzQxMjYzMzMxMDMyNzczNzkwMDc4NjYzOTg0MjY3NDI4ODcxNjQxNi8xMTE5NjYyOTE2NDk2NTE2MDA3MDE4NzUxODY4MjczNjA4MDc1NTg5NjA4MTc1ODk3MTkwOTY0MDc4ODc5OTkxMDgwMjQ1NTcyNTQyMjEwMDg4NDk1MTAxNTI0NjkxMTkyMTE1NjcxNTI2MTY3NDU3NjkyNTYxMjM5Njg4MzIyNTAxMDQwMDY1NjAwNjE5MDc3NDE1NjcwMzQwODcxMDk1MTI0ODMzNTc4NTE5MTk0MDIwMTc5NTA4MTI3OTU0MjYzOTM0MTU0MDkxOTgyNjgyNDYzMzc1NDI2Mzk0NzA4MzQxNjgwNDAyOTUxMzQxMzA2NTcwNzMyMDEwMjAzNDA0MzIyMzY3MjM4MjQ2NzA4MDM0OTg5NDkwNzE4NzA1OTcwMzkzMDkwMDQ1NjIwMjQwMzM2NTY0ODgxNTA0MDYxMDUxNzU0MDEzNzI3MDkwMTEwODI3MjUzNTkzODI2OTEyNzA2NTkyNDUzMTIxMzM5MTk1MTg3NjAzMjg0MjI4MjcwNjc1NzgzMDYwMDU2NDQ4MjU5MjcwNTA5OTQ4NjA3MjM0MDU0NzMzNzVcIiwgXCI4MDQxNTE0ODIxNTQ1ODMzODY1MzUwODczMjEyODUzODczMDQyMTEyMzQzMzI3NTczMzY0NTIzOTQ4NzgwMDMwODQ5NTQzNzUzMDcyNjg4NTI2NzE3ODg2NTkwMDEzMDI4MjI3NzE0NTg1OTY1MDk1MjE2MzgxODI5OTE0OTk2NTM5MTMyMzU5MjQ3NDg4NjM5NjkyODI4NjM5MTcwMDc1NzI2MzAxNDExNzc3MzA3MTY4NzM3NjY3MDc3NzMwNzkyODkyMzI2OTc5NDQ2NDI2MzQ5ODEzNjQyNjgwNTM3Njk5OTA1NjUxMTI1MDY4MDkxMzYyMTM1MDU1OTAyMTUyOTk0MjE2MjMzNjIyNzMzNDI0MTI4OTgyMDExMjQ4OTIzMDUxNDEwMTQxMDMzMTQ2NjA0Njg4MDgzNzIxNDEzNDAyMzk1MjkwODQyNzM4MDIxMzY1ODYxNjcwNDE1ODMzMzU2NDAzMzY0Njk2NzU5NTgzMDA5NjM1LzE1NTM5Mzc4MzM0OTk1NTkxMDQ5MTA1NTE4MTE1OTIxMzg4MzMxODk4OTI0NjQ0NDY3NjEyNDc3MzEzMzA2NzIyODQxOTEzMTM1OTA3MDg0Mzk2ODA0NjA1NDAzMjk4MzYzNDQ3Njc1NTc1OTk3NDYyMzQyMTMwMDY0OTM4NDI4NDI4NzkzOTg2ODQ3NDU4NjQ5MTk5NzMwNTE2MzUxMjcwODA3Mzg2MTIyNDgxNTAxMDg3OTMzOTc4NTUxMTMxMjIzNjg1MDc0ODM0MjkyMDkxMjcwMzUyNjM1MDQxOTQ4NDc3OTg4MDk2MTIyNzg4NjQ0MzgyODc4MTU0NzA3MTEwMzY1NDg2OTUwMzI0MjExNDgxMjU4NDk2NjkxNzU3MjkzMzE0NTkxNDk4MzM5NDUxODMyMjg0MTM5NjE5ODUzODEzMzgxNjIxNTU1OTYwMDg2ODA5MDY2NzY0OTg0MzU5NTQxNzgyMjY5NzMyNzIzNzE2MjU5ODRcIiwgXCIxMjA1OTY1OTM5OTMwOTE2OTE2NzMwMTM1Mzg0MjEyMzE5MTQwOTMwNjk5NTc4ODYzMzk2NTY4MDQxNDYyMDMwMjI4NTYwNjg5NjE0NjY2Nzc1MTQ3MjgxODU0MTUzNzE4Mzc4NzkzNTM1MjcwMDcyNTk4MjA1MzUzNjAzMjkzMDg2NjcwODQxMzAxMDk3MTg1Njg1Njc2ODM4NDk3NDg0OTY5NTc3NDQzNzE3ODc5MDg5MDAxNTI0MjMyMzg3Mzc2OTY5NzQwNzQxMTU1ODcwNjYyNjEwNTE0MDU5NjE2MDA0OTczNTYwNTM4OTMwMTQxNDQ2MDgyNTY3NDYzMTEyMjQ2Mjc2MDAxNDQ1MTI5ODQ5NDg3NTI0NDc1NDM1NDA1NDQ0NzY5NzUwMjUyMTM4ODM4MTI1MzI5MzE3NTM2NzU1ODAxNDQ1Mzg2NTkwNTEwNDQ2NzM4MjE4NDk5NzUyODg3OTE3MTEzNjQ5MjI3NzIyMjEyNzM5OTAxMjM2ODY3NzYwNDkxMDQ5Nzc4OTM2MDIxMjU3MTIzODE0NjYyNzA0ODA4MDU2ODQwMDM4NC8yMzI4NDk0MDU0MDAyNzAzMDY3MjE5MDA0NDg0NzgyOTMxNDcxOTE5NzUxNTg1OTY5NDg3MTYwNjAyMjY5NjA1OTE2Njc2MjIzMzE1MDU1NDUwODQ1OTQyNzYzNjkwNTgxODc3NzcxMTU5NjE1NDI4ODU0ODAyNzIxOTQzMTE0NDYzODM0OTkyMTA2MzAwMTg1MzI4ODc2OTEwMjcxNjEyMzc1NTA5MTY2OTc1NjI4NTQwODM5ODU4NzcxMDc4NDk1MjY3NTY2MDA4MDcxNTMyODc2ODE2ODI2NzUxMDY5NDA4MTUzMzIzODQwNTE1MDM3NDk3NjY0ODcxNjg5MDg1MzcwNjk5OTkxODYwNzM4MzY4MzcxNTEwNTc4MDc2NjgzMzk1MTAxMDYyNDM5NDkzODMxNzczMTk0NDk4NTc5NjIwNTEzMDczNjkzMDIyMTkxNzAyMzk4NjAxNDcxMjM3MTY2Mzg3MDQ1NzkwNDgwODYxOTMyMDA1MDEyODA3MjM0MDcxNDI5NjI4NzI1OTgxOTM1MTQ3MDY5NzM4OTg4NjgyODU4NDE3MTgyNjI1XCIsIFwiNjgzMDA5NDI2NzA1MDA4ODUwNjgyNTQ5NzAwMzgyOTAxNjAzNzQyNjkxNzA1MTIzMzU2ODY2MzM4OTUxMzk3MzQ3MzY4MDU5MTA1MTQwODI2NjU1NDg2NTE4NDE2NTc4Njk3OTMxMjQ0MzQ3NTU0MzIyNjU0NDI4MTYyNTU0OTAzODYxNzgzMjI3NjgwOTM1MzQxNjkwNzQwNTc5ODY3NjUxNTQ1MjA1NTYyNjkwMTcyNDI1MDE2ODM2NTU5Njc4OTM3Nzk0MzEyMjg3NjM5MTkzNzQ1NTE3ODExMjM0MjU3MDYyMzU2ODI2NjIyMjA3NDc1OTE4MjkzMDE1MTQwNDcyOTQyNTc5NzEzMzg4NjcxNzgyMjAyMjYyMzk2NjQyNzM1NjQwMzE1OTQ4NjEyNTcyOTA4NDQ0NTAxMTA4NTc5NDU3NTIwNzE0NjMyMzcxMDU2Mjg4ODc0MzUxMDE1NjY2OTk1NTQ5MTM5MDAzOTQ2MzE0MDg1Njk2LzEzMTc2OTIxNDI0NjUyMjg2OTc4MDQyOTgxNzIzNjE1MDQwNjU0ODU0OTA0NDY1ODQ3NDQxNjkwOTgwNjE3OTczNDg3MzM5OTEwOTY1NjQxMTYzMzQ4ODA5OTI0OTE5ODg4MjE2NTI3OTc0NTYyNzAzODk4NDQ4NzM2NTU4OTYyNTU2MjkwMTkxNDAzMDg1MDE3ODMzMDEzMzA4MDQwOTQyMDM0MDIyNzE3OTQ0NzU0ODA0NDU3MjU5NDE4NDYwMTQyNTY5MTgyMTYxNzkyODEzMDQyMzQxMDk5Nzg1MzM4NDQyNTM3Mzk5OTk2Nzc1OTQ5OTU3MTg5MDMyNjc0MDQzMzA4MTA2MzQyNDkwMzA5ODI1MjUwMjc5MTQ3Nzg1NDMwMjIwNDIwMDk0MTM3Njk4MzI5NTYyMjQzMDE3NzQ0NTUwNzMxNjcwNjYwOTgwMjI5MjEyMTI4Mjk1NzUxOTU3MTE2MjE1ODYyMDk3MTk1MjA4NDQ4NjM3NVwiLCBcIjE0MTgxMTYyNTk3NDkwOTE0MjAzMDkyNzE5MTM5MDkzMzcxNDM3NTY1ODkzMTQ1OTc1NTcxMjg1NTMxMTc4NzA1NzM5MjgwNTUxMDkzMjI4NjQ3OTQxNjk1OTIzNTUwNTgzNzA4OTEyNTE0MjUxMjUxODc3NzA3MjQ4MjgxMDg5ODg1ODc4ODgwODcwMjM5ODI0NTEyMDU0NzU5ODAzNzE0NDA0MjM5OTI4Mzg0ODE1NDcyMzY2Mzg0NTY3MTc1MjA4MzU2Njg4NTkwOTM0MTM5NTYzMzkyNjE4MDIzMDU1OTc2OTQ0MDMzODEwMjE4NjMyNTg3NTM0NDE4ODk1MzYzNjEwNjE0MDc1NzkzMzI1NzA0OTM2MzQyNTQ1NDIwMTMzMzc5OTk4NDQ0MDcxODEzNDY4MTU1NDk1OTQ4MzYzNzQ0OTc1MTI0NDc5Njk3NTE1MTQ0NjY0ODE0NjY3MTc1OTAyNTUzNjk4MTA1MDY4MTM1NDM1Nzc3MzUwODAyMjg3MTg2NjA3NDc5NDA5NTYyNDg0MjczNTY3ODU3ODQxOTkwNzM1Njk0MDgvMjczMzY4ODgyOTgwNTE2NTU2OTIyNTMyMzM5NjUzMzAzODIyMTA0NTEwMjAzOTE2MDI0NzYwMzcxODQ0NDkxNzA1NTk5MDkzNDM1MTMzNzM4Nzc0OTc1NTM4MzY0MjQxNjMwMDc5NDY4NzEyOTgxMDU2MzM2NjU1NzY2MTE3Mzc4MTYwODIyMzkzODc2MzQ4NzU1MzcwNzExOTQyMjczODc2Mjg0OTQ0NDIyNjEwOTc0MTQ5NzEyMjEyOTQ0MjExNTEzNDYyOTIxNjQ5ODcyMjMyNjU2NDQ5OTQwOTg3NTUyMjI3NTI1NTA0NTI5NzEwMzczMTQ0MjI4ODE4NjA2MTI3NTQxOTM3ODMxMTAzNjQyNDE1NTM0MzE4MzAzMTg3MzkzNTkzMjM2MjA5Mjk4MjQyNTc0Njc3MjkzMzUyNzk4NDE5NDI4NzEyODczNjg1Nzk4NjM2NDc0NjY3MjA0MDgzOTM4ODc1NjcyOTM0MjM1ODE2Mzk2MzcxNDc3MTQ2MDg5MTY4Mzc1MTk4MTQxODAyNjg0NDAzOTU1OTM2NDMxODg0NzY1NjI1XCIsIFwiNTQ2NDExMDc3NTgxODQ1OTk5MjQ4MjM4MDY5Njg0MTk0ODMxNjIxNjkxMTkzMzY2NDY2OTcyODk4NjI4MTQxNTExNDIyMzE3OTU0NDc3MjExODY1MTY3NDAyMjg0MjExOTcxMjk2Mjg2MzQ2NDkyNjk4MzU0MjE0MDQzODQwMDgwMTgxNzAyNjUyMTMyODM1NjgxMjM5MzAyNzk4MzM5NjY3ODM1NDM5MTg5Mjc1NDU3MTE2MDUxMjc5MzY2MTk0NTUxNjMyNzEyODE5MDI4MTc3NDAyMjIxODE1MTQwMDQ1MjEwNjkwOTA4NjMxNzY3Nzg2NzExNjc1MDI5MTk0MzU5OTk4ODI2MjUyMzMyNDM0NTczMTIxNzQwODMwODI3NDE3MjkzNTU3MjM0ODkxNDA2MDIxMTAyMDgzNTU1NDcyMTU1NDc5MTQ4MzMyNjk3ODM5OTcyNzAyNjMxNjQxOTEwMjEzODIxODI3ODIwMzc0NTg2NDU5MzE5LzEwNTI0Njk0NTg4OTc5OTE0MDMzODA3Mjc1NDM2NTkwMTcwNTU0NDUzMDY2MTc4MTI5NTM2MjU2MzIxNDI4NTk1Mzg4MTg5MDIzMzk4NzUxNjIzMDU2ODY2MzE0MzM0Mjk1Mjc5OTAzNjM0MTcwMTk1MjI2NzAxMTIzNjY2MzExODExMTIyNjYyMzgxNTk3NTg0NzQ5NDM3MjA3NjQyMDE5OTQxODcxMjk0MTAxODI4ODczODU5MDI2NDQ3NTUyMDIyOTY1MTM3MDAxNTM3NzYwODYzODA3NTg2NjQ1OTY4NDY5MjQ4ODA3OTIyMzY4NjI5NjU0MTAyMDg5NzkwNDU4ODM0NzA4MzA0NTcyMzE2Nzc2MjY4Mjk1OTQyMjg1ODk5NjY3Mzg5NDE4MDgwNTcwMjI5OTkwNzQ3ODY4NTM3NDA2NTU5MzE2MTIyNjg0OTQ0NzEzMTEwMDQ2MjAyMjA4OTc4MzI2NTM0NjU5NzU1MzE3NjU3NjAwMFwiLCBcIjIzOTgzMzA2NDA5NTg4NDE0NzQ3NzI2MDY0Mzk5MTYwNzAwNTA5Nzc1NDQ1MzU1ODA2MDU3MzczODM5OTUxNjA0NDcxMDU3MzYyNzY5NTAxOTY4ODU5MDY0MDgzMTc2MjgwODMxMTA5MjMzMjIxNTcxMTM4OTI5Mjg5NjMyMzc4NDU5MTQwMTc4NDU0NDQyOTUwNDA5MjQxMDE3ODQ0MjMzODI2ODE4MDE3NTQxOTEzMDE4NjAzODM5MjcxMjkwMDY5NTMzNTQ3MzkyNDA5MjY2NDM1NjI5ODc4Mzg4MzY5OTc0NTM5ODU4NTU1NzY0MDI2MjgxNjY4NzU4NjkwNDEwMzI2MzE2NTE1OTE4NzE5NjI4NTI4ODQxODk1NDg1MzgyNzIyODUzODcwOTI4NDMwNDQ2Njk0OTk2ODgwMzUxMzQxODE4NTkzNzY2NjU0MDk3Njc4ODYxODgzMDQzMTQ4ODg3NTM4OTQ5MDUzMTc5Mjk4NzcyMzgzMjI2MTU4Mzg1MjQzNTQxOTEyNjM1MDIzNDc4ODEwMzM4NTU0NDExODE0MjAzOTkzNjAvNDYxNTg4MDcwODY4NTkwMTIyODkyMjY1NjgxODc5NzM0Mjk1MDA3MDI5MTMwOTY1NjI2MDYwNTUyNzgzNzYwMDY4ODk3MDAwMTk1MjA3ODc4MjI3NzE0ODQyNjE3NDcwMzIwMjMxNTI3MjIyMDc0NzAxNDQ0MzQ5NTMwOTUyNjk5NzA4NDM1NjY4MzM5NzEyODYwNDY0NTMzNDU1MzQ1NjY1MDY4ODQxMzMzMjMyMzU5Njk4NDQ5MDg4NDk3MTM3MDY4NzEzMzA5ODExOTQyOTY4NDMzODY4NjA5MzI5MzAxMDgyMDAxNzUyNjE3NDIwMDAyMzc3ODkyNzU2ODIxNTMyMjIwNjc2MDg1MDE0ODc0MTEyMDgzNjE1MDU0NTUwMjc4OTAzOTYwNjI3MTg1Njc1NDU5MDE1MzQzNjA2MzkxMDk0NTIzNTExMTE3NzA1NzQ3ODQyNjQ1OTI3MzQ5MTMwMzAyNTQ5NTU0NTM0MDU2MjY5MzMxODA5MDE2NzcwNzE1ODE5OTM0OTcwMjAwNDgzMTYxNTQ4NTI3OTMyNjE3MDM2MTg1MjUzXCIsIFwiNjA0MTAxNTg3OTQyNDcyNTM4MzAwNjQyNDUzNjEzMDQwOTIwOTYwNzg1NDA0NDY0MjExMzc0NzI2NjA5ODE5ODc3NzAxMTk4MTMyODc2NTUyODM2MTYzMDUxNjEwODY4MDM5MjUwMDk5MDU4MDkwODUwOTQwMzQ4Mzg5MTc2MzIxOTY1OTcyNjA5MDY3NTE0MDY3Mjk4OTY1Nzc0Mzg4MjE4Mzk1MTk1NDI5NDc0NTM5NjQxNzgyOTk0MzQ2OTIwMTMwNjU5NDAxODQ1NDk5NTg2MjMyMTgyMTAxNjA4NzQxNjg0MDI0NzQyMjM1MDkwNjQxMjAwNzMzNjEwMzA4NjYyMDM5NjQ2NzQ1NjE4MTc3MTU4MzIwMDM2NTc0MDI1MzM4OTEwNzk2ODEyMjg1MDA2MzYwNzA4NTk1NzEwOTk2NTQwNjYzNDczODc0MDk5NjMxODQxNTUxNDM2MDk1NjAyODU3NTU2MDk3OTIwMzQ0NzczNTEyMTQzNi8xMTYxNzUyNzk5MTA5NDI4NDIyMjg4MDIwOTQ3MDYxMjgxNTQwOTg5NzA4OTM3NDUwNTY4MTAwNzY0ODMwMjUxOTA4ODUwNTk2NzE3NjA2NzAxMDQ3NDEzNDA3NjM2OTA3OTM0MzIwNzg5ODcwMTc1OTA3NzkyMDE3NTEzODk2OTk5MjA4ODkyMjgyMTM3Mjk5MDcwNzYxNDY3MDk2MjExODE0NTg2OTA5NTk4NzA1NjE1MzEyODE5NTk2NDk1NjM2MDE3NzI4MzEzNTEzNTIwMTkzNzg2MjY2NDUyODM2ODA1MjkxNDY0ODI2MjI2ODMzNTkzODc4NTA0ODA0Mzg5NzI4NDc3MTkxMTcwMDI3NzI5OTYzNzczNzE2MjY3ODY4Mjg0NDc5NzY4Mzk3NjAzNDQ0OTE5MDA4OTE1Mjc5NTIyMzc2MDA0MzI2Mzk4NDAzODUxNjg0NzYxODA4Nzg1MzgxNjA5MzcwNzY3MTY5NTIxMDM0MzgzNjI1XCIsIFwiMTMyNDAwNzc0MzY0NDM5ODg3NDkxNzk1MDg0NjIyNjcyNjcxODcxNjk0NDE5NDg3MjIzNTgxNjUwOTA1NTQ3NjkyNTA1MDU3MTM3NDc5MzQ2NDMyMDA4MDQ4MTk0MTg2NzAxNDcyMjU2OTUzMjQ0MzI2ODQyNjY5MjQ2OTQ1MjQzMzc5MjA4MTY0NTIzNDY1OTk3NzQ0NTI2ODE4MzEzMjAwMDUyODYzMjY5ODY2NzU5MDc4OTk2MDg1Mzc5NzIzODQ5MjQ4ODI5OTY3NTc1MDMyNjQ2MjI5OTEzNTU5NDkwMzk4ODI1MjYzODkzNDIxNzQzMDcxNjg4MDUxNjYyMTU4MzgxMzgyNzc1NTcwNTIzMDM0MzA0OTI2NjkxOTM5MzkyMTIzNjI2MzgyNjM1ODI4OTk3MTMxOTg3MTY1NDE3MjMzODMxMzgwMTY1NjQwMjc3NjY1NjAyMTU5NDQ0MDkzNTM0MjcxNzYxMzU4OTU5ODI1OTYzMjc2ODU2NjU4NDQ4MTU2MTg0MDI4ODEyMDI2NDU2MTA2MjAyODQ3OTI3OTM0MjA3ODA1MTcyNDgvMjU0NDIyMzA4NDQ2ODE1ODI5MTg4MzY5ODgxMzMwOTU0MTgwMTQ1NTMxMTQ2ODk4MjIzMjU0Njg3MjQ4NTQ0NDMwODIxMTQxNTUyOTk5ODQ3Mjc4NzM3NzgwMDU1OTg4NDIxMDgzNzIxMzA0MjkzMjE4MDQ3OTA5MDI3NzI4NTYzMDIzNDIzODcxMTg1MTQ4MDIzMjUyMDEzNzg1Njg0ODgwOTk4NjYzMTc4NDg0MzUyODM4MTc3ODUyMDcyNzQ2NTE0NjY2MTc5Mjc5NzkyNDQ1ODU0MDk1NzEzMzQyMzY2NTc0NjIyOTc5OTY3NTY1MDI5MDI5NjIxNzY1ODQ0NDg5OTYwNTIzNjU1MDk3MjA0MzU0OTI3ODEyODA4NzY0NTIxMTkwOTQ3OTAwOTA5OTc2NjYxOTM1NTY3Nzk4NDIxODkyOTY3MjQ2MTUwNjY5MTk4MDQ0MjA3MTg2MDU5MTc2NzI2NjkxMzA0MTE0NzU4NzgxNTQ1MjAwNzcyNjUxMzg1MzgyMDExNjYyOTQ4MjczMjA2MDU5MzExNjYyNDU5NjM2ODgwNjU2NjYyNVwiLCBcIjE5NTM5OTkxNjYyOTY5NTU4MzA5MzU0OTUxNTg3MzUzNTkyMDAzNjI5MDQxODE3OTI5NDc3OTQ1MjkzMzk0ODc0ODk3MzAwNDI1NjgzMDU5OTcwOTk5NTkzMDIzMjI5NTY4OTgyOTk2MTYxOTQ5MzIyODMwNjA1NTQyNjE1NjY0MTA5ODg2MTgwNDUxMDczOTgwOTIzNDU0NzY1MzIzNzE0MDIxMzQyMDY2MzUyMzU1NzAyODE3MzgzNzcxODg0Mzg0MDc3MDMwODkzMjUzMTU0NDYzNzExMjcwNDI1Mzc1NzYwOTM1MzY4OTYyODI5NTU1MjQ4NDI2MzI3MDg2NDU2NTU0ODEwMjgxNjE0NzEzMTM2MDg5NzQyMzgxMTA3MTgyNDIyNzM5MzU5NTY5Nzc1NTU2MTAxNDc3MTQzMTYxNTg0ODY1NTM2MzM4NzEzMTIxODcwODQ2MTgxNTQwMTQ5MjExOTA1OTUyMjI3OTkyODM5NTcxNDAzNTMvMzc1MTkxMTY1MDg0ODgyNTIxMDM3MDQ2MDE0NTY5MTg1MTY1ODg1NDU5MDgyNjI5MTM2MTI0MTc3Mjg2NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJdO1xyXG4gICAgICAgICAgICBpZihDQUNIRVt4XSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZyYWMucXVpY2suYXBwbHkobnVsbCwgQ0FDSEVbeF0uc3BsaXQoJy8nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeCA9IG5ldyBGcmFjKHgpO1xyXG4gICAgICAgICAgICB2YXIgbiA9IDgwO1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IEZyYWMoMCk7XHJcbiAgICAgICAgICAgIHZhciBhID0geC5zdWJ0cmFjdChuZXcgRnJhYygxKSk7XHJcbiAgICAgICAgICAgIHZhciBiID0geC5hZGQobmV3IEZyYWMoMSkpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBGcmFjKDIgKiBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGgyLmJpZ3BvdyhhLmRpdmlkZShiKSwgdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IHQuY2xvbmUoKS5pbnZlcnQoKS5tdWx0aXBseShrKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbC5hZGQocik7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWwubXVsdGlwbHkobmV3IEZyYWMoMikpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy90aGUgZmFjdG9yaWFsIGZ1bmN0aW9uIGJ1dCB1c2luZyB0aGUgYmlnIGxpYnJhcnkgaW5zdGVhZFxyXG4gICAgICAgIGZhY3RvcmlhbDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIGlzX2ludCA9IHggJSAxID09PSAwO1xyXG5cclxuICAgICAgICAgICAgLypmYWN0b3JpYWwgZm9yIG5lZ2F0aXZlIGludGVnZXJzIGlzIGNvbXBsZXggaW5maW5pdHkgYWNjb3JkaW5nIHRvIFdvbGZyYW0gQWxwaGEqL1xyXG4gICAgICAgICAgICBpZihpc19pbnQgJiYgeCA8IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xyXG5cclxuICAgICAgICAgICAgaWYoIWlzX2ludClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoMi5nYW1tYSh4ICsgMSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gMTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMjsgaSA8PSB4OyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSByZXR2YWwgKiBpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9kb3VibGUgZmFjdG9yaWFsXHJcbiAgICAgICAgLy9odHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0RvdWJsZUZhY3RvcmlhbC5odG1sXHJcbiAgICAgICAgZGZhY3RvcmlhbDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYoaXNJbnQoeCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVuID0geCAlIDIgPT09IDA7XHJcbiAgICAgICAgICAgICAgICAvKiBJZiB4ID0gZXZlbiB0aGVuIG4gPSB4LzIgZWxzZSBuID0gKHgtMSkvMiovXHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGV2ZW4gPyB4IC8gMiA6ICh4ICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgLyp0aGUgcmV0dXJuIHZhbHVlKi9cclxuICAgICAgICAgICAgICAgIHZhciByID0gbmV3IEZyYWMoMSk7XHJcbiAgICAgICAgICAgICAgICAvKnN0YXJ0IHRoZSBsb29wKi9cclxuICAgICAgICAgICAgICAgIGlmKGV2ZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8PSBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByLm11bHRpcGx5KG5ldyBGcmFjKDIpLm11bHRpcGx5KG5ldyBGcmFjKGkpKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8PSBuOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSByLm11bHRpcGx5KG5ldyBGcmFjKDIpLm11bHRpcGx5KG5ldyBGcmFjKGkpKS5zdWJ0cmFjdChuZXcgRnJhYygxKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLypOb3QgeWV0IGV4dGVuZGVkIHRvIGJpZ051bSovXHJcbiAgICAgICAgICAgICAgICByID0gTWF0aC5wb3coMiwgKDEgKyAyICogeCAtIE1hdGguY29zKE1hdGguUEkgKiB4KSkgLyA0KSAqIE1hdGgucG93KE1hdGguUEksIChNYXRoLmNvcyhNYXRoLlBJICogeCkgLSAxKSAvIDQpICogTWF0aDIuZ2FtbWEoMSArIHggLyAyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLypkb25lKi9cclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBHQ0Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcnJheVVuaXF1ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh4KTtcclxuICAgICAgICAgICAgICAgICAgICB9KSkuc29ydCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBNYXRoLmFicyhhcmdzLnNoaWZ0KCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBhcmdzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlKG4tLSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBiID0gTWF0aC5hYnMoYXJncy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhICU9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGIgJT0gYTtcclxuICAgICAgICAgICAgICAgICAgICBpZihiID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBRR0NEOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGFyZ3NbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IGEuaXNOZWdhdGl2ZSgpICYmIGIuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgYSA9IGIuZ2NkKGEpO1xyXG4gICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgYS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIExDTTogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhICogYikgLyBNYXRoMi5HQ0QoYSwgYik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL3BvdyBidXQgd2l0aCB0aGUgaGFuZGxpbmcgb2YgbmVnYXRpdmUgbnVtYmVyc1xyXG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjgxMDc2NS9jYWxjdWxhdGluZy1jdWJpYy1yb290LWZvci1uZWdhdGl2ZS1udW1iZXJcclxuICAgICAgICBwb3c6IGZ1bmN0aW9uIChiLCBlKSB7XHJcbiAgICAgICAgICAgIGlmKGIgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhlKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKm50aCByb290IG9mIGEgbmVnYXRpdmUgbnVtYmVyIGlzIGltYWdpbmFyeSB3aGVuIG4gaXMgZXZlbiovXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoMSAvIGUgJSAyID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtTWF0aC5wb3coTWF0aC5hYnMoYiksIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhiLCBlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZhY3RvcjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgbiA9IE51bWJlcihuKTtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24obik7IC8qc3RvcmUgdGhlIHNpZ24qL1xyXG4gICAgICAgICAgICAvKm1vdmUgdGhlIG51bWJlciB0byBhYnNvbHV0ZSB2YWx1ZSovXHJcbiAgICAgICAgICAgIG4gPSBNYXRoLmFicyhuKTtcclxuICAgICAgICAgICAgdmFyIGlmYWN0b3JzID0gTWF0aDIuaWZhY3RvcihuKTtcclxuICAgICAgICAgICAgdmFyIGZhY3RvcnMgPSBuZXcgU3ltYm9sKCk7XHJcbiAgICAgICAgICAgIGZhY3RvcnMuc3ltYm9scyA9IHt9O1xyXG4gICAgICAgICAgICBmYWN0b3JzLmdyb3VwID0gQ0I7XHJcbiAgICAgICAgICAgIGZvcih2YXIgeCBpbiBpZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3IuZ3JvdXAgPSBQOyAvKmNoZWF0IGEgbGl0dGxlKi9cclxuICAgICAgICAgICAgICAgIGZhY3Rvci52YWx1ZSA9IHg7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3IucG93ZXIgPSBuZXcgU3ltYm9sKGlmYWN0b3JzW3hdKTtcclxuICAgICAgICAgICAgICAgIGZhY3RvcnMuc3ltYm9sc1t4XSA9IGZhY3RvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmYWN0b3JzLnVwZGF0ZUhhc2goKTtcclxuXHJcbiAgICAgICAgICAgIGlmKG4gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGZhY3RvcnMgPSBuZXcgU3ltYm9sKG4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKnB1dCBiYWNrIHRoZSBzaWduKi9cclxuICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICBmYWN0b3JzLm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VzIHRyaWFsIGRpdmlzaW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBuIC0gdGhlIG51bWJlciBiZWluZyBmYWN0b3JlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmYWN0b3JzIC0gIHRoZSBmYWN0b3JzIG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2ZhY3RvcjogZnVuY3Rpb24gKG4sIGZhY3RvcnMpIHtcclxuICAgICAgICAgICAgZmFjdG9ycyA9IGZhY3RvcnMgfHwge307XHJcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5mbG9vcihNYXRoLnNxcnQobikpO1xyXG4gICAgICAgICAgICB2YXIgbGNwcmltZSA9IFBSSU1FU1tQUklNRVMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIC8qYSBvbmUtdGltZSBjb3N0Li4uIEhvcGVmdWxseSAuLi4gQW5kIGRvbid0IGJvdGhlciBmb3IgbW9yZSB0aGFuIGEgbWlsbGlvbiovXHJcbiAgICAgICAgICAgIC8qdGFrZXMgdG9vIGxvbmcqL1xyXG4gICAgICAgICAgICBpZihyID4gbGNwcmltZSAmJiBuIDwgMWU2KVxyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVQcmltZXMocik7XHJcbiAgICAgICAgICAgIHZhciBsID0gUFJJTUVTLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByaW1lID0gUFJJTUVTW2ldO1xyXG4gICAgICAgICAgICAgICAgLyp0cmlhbCBkaXZpc2lvbiovXHJcbiAgICAgICAgICAgICAgICB3aGlsZShuICUgcHJpbWUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbiAvIHByaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnNbcHJpbWVdID0gKGZhY3RvcnNbcHJpbWVdIHx8IDApICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihuID4gMSlcclxuICAgICAgICAgICAgICAgIGZhY3RvcnNbbl0gPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFjdG9ycztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvbGxhcmQncyByaG9cclxuICAgICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IG5cclxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmYWN0b3I6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IG5ldyBiaWdJbnQobik7XHJcblxyXG4gICAgICAgICAgICBuID0gU3RyaW5nKG4pO1xyXG5cclxuICAgICAgICAgICAgaWYobiA9PT0gJzAnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsnMCc6IDF9O1xyXG4gICAgICAgICAgICBuID0gbmV3IGJpZ0ludChuKTsgLypjb252ZXJ0IHRvIGJpZ0ludCBmb3Igc2FmZXR5Ki9cclxuICAgICAgICAgICAgdmFyIHNpZ24gPSBuLnNpZ24gPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIG4gPSBuLmFicygpO1xyXG4gICAgICAgICAgICB2YXIgZmFjdG9ycyA9IHt9OyAvKmZhY3RvciBvYmplY3QgYmVpbmcgcmV0dXJuZWQuKi9cclxuICAgICAgICAgICAgaWYobi5sdCgnNjU1MzYnKSkgeyAvKmxlc3MgdGhhbiAyXjE2IGp1c3QgdXNlIHRyaWFsIGRpdmlzaW9uKi9cclxuICAgICAgICAgICAgICAgIGZhY3RvcnMgPSBNYXRoMi5zZmFjdG9yKG4sIGZhY3RvcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWUuaXNQcmltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnMgPSBNYXRoMi5zZmFjdG9yKGUsIGZhY3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnNbZV0gPSAoZmFjdG9yc1tlXSB8fCAwKSArIDE7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgYSBzYWZldHlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4ID0gMWUzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZldHkgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSghbi5hYnMoKS5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobi5pc1ByaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmhvKGMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGYgPSBuZXcgYmlnSW50KGMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ogPSAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IG5ldyBiaWdJbnQoYyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IgPSBuZXcgYmlnSW50KDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShmYWN0b3IuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPD0gY3ogJiYgZmFjdG9yLmVxdWFscygxKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyaWdnZXIgdGhlIHNhZmV0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2FmZXR5KysgPiBtYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdG9wcGluZycpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSB4LnBvdygyKS5hZGQoMSkubW9kKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gYmlnSW50LmdjZCh4Lm1pbnVzKHhmKS5hYnMoKSwgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN6ID0gY3ogKiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ZiA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZhY3Rvci5lcXVhbHMobikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJobyhjICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gcmhvKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGZhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKmRpdmlkZSBvdXQgdGhlIGZhY3RvciovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gbi5kaXZpZGUoZmFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IGZhY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3JzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkKGlucHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qcHV0IHRoZSBzaWduIGJhY2sqL1xyXG4gICAgICAgICAgICBpZihzaWduID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNtID0gYXJyYXlNaW4oa2V5cyhmYWN0b3JzKSk7IC8qL2dldCB0aGUgc21hbGxlc3QgbnVtYmVyKi9cclxuICAgICAgICAgICAgICAgIGZhY3RvcnNbJy0nICsgc21dID0gZmFjdG9yc1tzbV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZmFjdG9yc1tzbV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3JzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9mYWN0b3JzIGEgbnVtYmVyIGludG8gcmVjdGFuZ3VsYXIgYm94LiBJZiBzaWRlcyBhcmUgcHJpbWVzIHRoYXQgdGhpcyB3aWxsIGJlXHJcbiAgICAgICAgLy90aGVpciBwcmltZSBmYWN0b3JzLiBlLmcuIDIxIC0+ICg3KSgzKSwgMTMzIC0+ICg3KSgxOSlcclxuICAgICAgICBib3hmYWN0b3I6IGZ1bmN0aW9uIChuLCBtYXgpIHtcclxuICAgICAgICAgICAgbWF4ID0gbWF4IHx8IDIwMDsgLy9zdG9wIGFmdGVyIHRoaXMgbnVtYmVyIG9mIGl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgdmFyIGMsIHIsXHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IE1hdGguZmxvb3IoKDUgLyAxMikgKiBuKSwgLy90aGUgZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLCAvL251bWJlciBvZiBpdGVyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgc2FmZXR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGMgPSBNYXRoLmZsb29yKG4gLyBkKTtcclxuICAgICAgICAgICAgICAgIHIgPSBuICUgZDtcclxuICAgICAgICAgICAgICAgIGlmKHIgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgaWYoc2FmZXR5KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbiwgMV07XHJcbiAgICAgICAgICAgICAgICBkID0gTWF0aC5tYXgociwgZCAtIHIpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgc2FmZXR5ID0gaSA+IG1heDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW2MsIGQsIGldO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmliOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbihuKTtcclxuICAgICAgICAgICAgbiA9IE1hdGguYWJzKG4pO1xyXG4gICAgICAgICAgICBzaWduID0gZXZlbihuKSA/IHNpZ24gOiBNYXRoLmFicyhzaWduKTtcclxuICAgICAgICAgICAgdmFyIGEgPSAwLCBiID0gMSwgZiA9IDE7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDI7IGkgPD0gbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmID0gYSArIGI7XHJcbiAgICAgICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgICAgIGIgPSBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmICogc2lnbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vZDogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHggJSB5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9odHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0ludGVnZXJQYXJ0Lmh0bWxcclxuICAgICAgICBpbnRlZ2VyX3BhcnQ6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKHgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIE1hdGguZmxvb3IoTWF0aC5hYnMoeCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2ltcHNvbjogZnVuY3Rpb24gKGYsIGEsIGIsIHN0ZXApIHtcclxuICAgICAgICAgICAgdmFyIGdldF92YWx1ZSA9IGZ1bmN0aW9uIChmLCB4LCBzaWRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGYoeCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IDAuMDAwMDAwMDAwMDAxO1xyXG4gICAgICAgICAgICAgICAgaWYoaXNOYU4odikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ID0gZihzaWRlID09PSAxID8geCArIGQgOiB4IC0gZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwIHx8IDAuMDAwMTtcclxuICAgICAgICAgICAgLy9jYWxjdWxhdGUgdGhlIG51bWJlciBvZiBpbnRlcnZhbHNcclxuICAgICAgICAgICAgdmFyIG4gPSBNYXRoLmFicyhNYXRoLmZsb29yKChiIC0gYSkgLyBzdGVwKSk7XHJcbiAgICAgICAgICAgIC8vc2ltcHNvbidzIHJ1bGUgcmVxdWlyZXMgYW4gZXZlbiBudW1iZXIgb2YgaW50ZXJ2YWxzLiBJZiBpdCdzIG5vdCB0aGVuIGFkZCAxXHJcbiAgICAgICAgICAgIGlmKG4gJSAyICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAvL2dldCB0aGUgaW50ZXJ2YWwgc2l6ZVxyXG4gICAgICAgICAgICB2YXIgZHggPSAoYiAtIGEpIC8gbjtcclxuICAgICAgICAgICAgLy9nZXQgeDBcclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9IGdldF92YWx1ZShmLCBhLCAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vZ2V0IHRoZSBtaWRkbGUgcGFydCA0eDErMngyKzR4MyAuLi5cclxuICAgICAgICAgICAgLy9idXQgZmlyc3Qgc2V0IGEgZmxhZyB0byBzZWUgaWYgaXQncyBldmVuIG9yIG9kZC5cclxuICAgICAgICAgICAgLy9UaGUgZmlyc3Qgb25lIGlzIG9kZCBzbyB3ZSBzdGFydCB0aGVyZVxyXG4gICAgICAgICAgICB2YXIgZXZlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvL2dldCB4MVxyXG4gICAgICAgICAgICB2YXIgeGkgPSBhICsgZHg7XHJcbiAgICAgICAgICAgIC8vdGhlIGNvZWZmaWNpZW50XHJcbiAgICAgICAgICAgIHZhciBjLCBrO1xyXG4gICAgICAgICAgICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpbXBzb24lMjdzX3J1bGVcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYyA9IGV2ZW4gPyAyIDogNDtcclxuICAgICAgICAgICAgICAgIGsgPSBjICogZ2V0X3ZhbHVlKGYsIHhpLCAxKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCArPSBrO1xyXG4gICAgICAgICAgICAgICAgLy9mbGlwIHRoZSBldmVuIGZsYWdcclxuICAgICAgICAgICAgICAgIGV2ZW4gPSAhZXZlbjtcclxuICAgICAgICAgICAgICAgIC8vaW5jcmVtZW50IHhpXHJcbiAgICAgICAgICAgICAgICB4aSArPSBkeDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9hZGQgeG5cclxuICAgICAgICAgICAgcmV0dXJuIChyZXR2YWwgKyBnZXRfdmFsdWUoZiwgeGksIDIpKSAqIChkeCAvIDMpO1xyXG5cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2lqcy9pbnRlZ3JhdGUtYWRhcHRpdmUtc2ltcHNvblxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgLSB0aGUgZnVuY3Rpb24gYmVpbmcgaW50ZWdyYXRlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gbG93ZXIgYm91bmRcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gYiAtIHVwcGVyIGJvdW5kXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvbCAtIHN0ZXAgd2lkdGhcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4ZGVwdGhcclxuICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG51bV9pbnRlZ3JhdGU6IGZ1bmN0aW9uIChmLCBhLCBiLCB0b2wsIG1heGRlcHRoKSB7XHJcbiAgICAgICAgICAgIGlmKG1heGRlcHRoIDwgMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4IGRlcHRoIGNhbm5vdCBiZSBuZWdhdGl2ZScpO1xyXG5cclxuICAgICAgICAgICAgLyogVGhpcyBhbGdvcml0aG0gYWRhcHRlZCBmcm9tIHBzZXVkb2NvZGUgaW46Ki9cclxuICAgICAgICAgICAgLyogaHR0cDovL3d3dy5tYXRoLnV0ay5lZHUvfmNjb2xsaW5zL3JlZnMvSGFuZG91dHMvcmljaC5wZGYqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZHNpbXAoZiwgYSwgYiwgZmEsIGZtLCBmYiwgVjAsIHRvbCwgbWF4ZGVwdGgsIGRlcHRoLCBzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYoc3RhdGUubmFuRW5jb3VudGVyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGgsIGYxLCBmMiwgc2wsIHNyLCBzMiwgbSwgVjEsIFYyLCBlcnI7XHJcbiAgICAgICAgICAgICAgICBoID0gYiAtIGE7XHJcbiAgICAgICAgICAgICAgICBmMSA9IGYoYSArIGggKiAwLjI1KTtcclxuICAgICAgICAgICAgICAgIGYyID0gZihiIC0gaCAqIDAuMjUpO1xyXG4gICAgICAgICAgICAgICAgLyogU2ltcGxlIGNoZWNrIGZvciBOYU46Ki9cclxuICAgICAgICAgICAgICAgIGlmKGlzTmFOKGYxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm5hbkVuY291bnRlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKiBTaW1wbGUgY2hlY2sgZm9yIE5hTjoqL1xyXG4gICAgICAgICAgICAgICAgaWYoaXNOYU4oZjIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubmFuRW5jb3VudGVyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzbCA9IGggKiAoZmEgKyA0ICogZjEgKyBmbSkgLyAxMjtcclxuICAgICAgICAgICAgICAgIHNyID0gaCAqIChmbSArIDQgKiBmMiArIGZiKSAvIDEyO1xyXG4gICAgICAgICAgICAgICAgczIgPSBzbCArIHNyO1xyXG4gICAgICAgICAgICAgICAgZXJyID0gKHMyIC0gVjApIC8gMTU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3RhdGUubWF4RGVwdGhDb3VudCA+IDEwMDAgKiBtYXhkZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZGVwdGggPiBtYXhkZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm1heERlcHRoQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gczIgKyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKE1hdGguYWJzKGVycikgPCB0b2wpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gczIgKyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gYSArIGggKiAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgVjEgPSBhZHNpbXAoZiwgYSwgbSwgZmEsIGYxLCBmbSwgc2wsIHRvbCAqIDAuNSwgbWF4ZGVwdGgsIGRlcHRoICsgMSwgc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzTmFOKFYxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5uYW5FbmNvdW50ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFYyID0gYWRzaW1wKGYsIG0sIGIsIGZtLCBmMiwgZmIsIHNyLCB0b2wgKiAwLjUsIG1heGRlcHRoLCBkZXB0aCArIDEsIHN0YXRlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNOYU4oVjIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm5hbkVuY291bnRlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWMSArIFYyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnRlZ3JhdGUoZiwgYSwgYiwgdG9sLCBtYXhkZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heERlcHRoQ291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbmFuRW5jb3VudGVyZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRvbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9sID0gMWUtOTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKG1heGRlcHRoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKklzc3VlICM0NTggLSBUaGlzIHdhcyBsb3dlcmVkIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgaXNzdWVzLiAqL1xyXG4gICAgICAgICAgICAgICAgICAgIC8qVGhpcyB3YXMgc3VzcGVjdGVkIGZyb20gYmVmb3JlIGJ1dCBpcyBub3cgY29uZmlybWVkIHdpdGggdGhpcyBpc3N1ZSovXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ZGVwdGggPSA0NTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmEgPSBmKGEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZtID0gZigwLjUgKiAoYSArIGIpKTtcclxuICAgICAgICAgICAgICAgIHZhciBmYiA9IGYoYik7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIFYwID0gKGZhICsgNCAqIGZtICsgZmIpICogKGIgLSBhKSAvIDY7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGFkc2ltcChmLCBhLCBiLCBmYSwgZm0sIGZiLCBWMCwgdG9sLCBtYXhkZXB0aCwgMSwgc3RhdGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN0YXRlLm1heERlcHRoQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybignaW50ZWdyYXRlLWFkYXB0aXZlLXNpbXBzb246IFdhcm5pbmc6IG1heGltdW0gcmVjdXJzaW9uIGRlcHRoICgnICsgbWF4ZGVwdGggKyAnKSByZWFjaGVkICcgKyBzdGF0ZS5tYXhEZXB0aENvdW50ICsgJyB0aW1lcycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN0YXRlLm5hbkVuY291bnRlcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBkb2VzIG5vdCBjb252ZXJnZSBvdmVyIGludGVydmFsIScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBpbnRlZ3JhdGUoZiwgYSwgYiwgdG9sLCBtYXhkZXB0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgLypmYWxsYmFjayB0byBub24tYWRhcHRpdmUqL1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgyLnNpbXBzb24oZiwgYSwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5yb3VuZChyZXR2YWwsIDEyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJpZ29ub21ldHJpY19pbnRlZ3JhbFxyXG4gICAgICAgIC8vQ29zaW5lSW50ZWdyYWxcclxuICAgICAgICBDaTogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSAyMCxcclxuICAgICAgICAgICAgICAgICAgICAvKnJvdWdobHkgRXVsZXLigJNNYXNjaGVyb25pKi9cclxuICAgICAgICAgICAgICAgICAgICBnID0gMC41NzcyMTU2NjQ5MDE1MzI5LFxyXG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8qY2FjaGUgMm4qL1xyXG4gICAgICAgICAgICAgICAgdmFyIG4yID0gMiAqIGk7XHJcbiAgICAgICAgICAgICAgICBzdW0gKz0gKE1hdGgucG93KC0xLCBpKSAqIE1hdGgucG93KHgsIG4yKSkgLyAobjIgKiBNYXRoMi5mYWN0b3JpYWwobjIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgKyBnICsgc3VtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypTaW5lSW50ZWdyYWwqL1xyXG4gICAgICAgIFNpOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IDIwLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IDA7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBuMiA9IDIgKiBpO1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IChNYXRoLnBvdygtMSwgaSkgKiBNYXRoLnBvdyh4LCBuMiArIDEpKSAvICgobjIgKyAxKSAqIE1hdGgyLmZhY3RvcmlhbChuMiArIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypFeHBvbmVudGlhbEludGVncmFsKi9cclxuICAgICAgICBFaTogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYoTnVtYmVyKHgpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcclxuICAgICAgICAgICAgdmFyIG4gPSAzMCxcclxuICAgICAgICAgICAgICAgICAgICBnID0gMC41NzcyMTU2NjQ5MDE1MzI4NjA2LCAvKnJvdWdobHkgRXVsZXLigJNNYXNjaGVyb25pKi9cclxuICAgICAgICAgICAgICAgICAgICBzdW0gPSAwO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzdW0gKz0gTWF0aC5wb3coeCwgaSkgLyAoaSAqIE1hdGgyLmZhY3RvcmlhbChpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGcgKyBNYXRoLmFicyhNYXRoLmxvZyh4KSkgKyBzdW07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKkh5cGVyYm9saWMgU2luZSBJbnRlZ3JhbCovXHJcbiAgICAgICAgLypodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL1NoaS5odG1sKi9cclxuICAgICAgICBTaGk6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gMzAsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBrLCB0O1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBrID0gMiAqIGk7XHJcbiAgICAgICAgICAgICAgICB0ID0gayArIDE7XHJcbiAgICAgICAgICAgICAgICBzdW0gKz0gTWF0aC5wb3coeCwgdCkgLyAodCAqIHQgKiBNYXRoMi5mYWN0b3JpYWwoaykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKnRoZSBjb3NpbmUgaW50ZWdyYWwgZnVuY3Rpb24qL1xyXG4gICAgICAgIENoaTogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgdmFyIGR4LCBnLCBmO1xyXG4gICAgICAgICAgICBkeCA9IDAuMDAxO1xyXG4gICAgICAgICAgICBnID0gMC41NzcyMTU2NjQ5MDE1MzI4NjA2O1xyXG4gICAgICAgICAgICBmID0gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoTWF0aC5jb3NoKHQpIC0gMSkgLyB0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgKyBnICsgTWF0aDIubnVtX2ludGVncmF0ZShmLCAwLjAwMiwgeCwgZHgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyp0aGUgbG9nIGludGVncmFsKi9cclxuICAgICAgICBMaTogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgyLkVpKE1hdGgyLmJpZ0xvZyh4KSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKnRoZSBnYW1tYSBpbmNvbXBsZXRlIGZ1bmN0aW9uKi9cclxuICAgICAgICBnYW1tYV9pbmNvbXBsZXRlOiBmdW5jdGlvbiAobiwgeCkge1xyXG4gICAgICAgICAgICB2YXIgdCA9IG4gLSAxLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHggfHwgMDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IE1hdGgucG93KHgsIGkpIC8gTWF0aDIuZmFjdG9yaWFsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoMi5mYWN0b3JpYWwodCkgKiBNYXRoLmV4cCgteCkgKiBzdW07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEhlYXZpc2lkZSBzdGVwIGZ1bmN0aW9uIC0gTW92ZWQgZnJvbSBTcGVjaWFsLmpzIChvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5IEJyb3NuYW4gWXVlbilcclxuICAgICAgICAgKiBTcGVjaWZpY2F0aW9uIDogaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9IZWF2aXNpZGVTdGVwRnVuY3Rpb24uaHRtbFxyXG4gICAgICAgICAqIGlmIHggPiAwIHRoZW4gMVxyXG4gICAgICAgICAqIGlmIHggPT0gMCB0aGVuIDEvMlxyXG4gICAgICAgICAqIGlmIHggPCAwIHRoZW4gMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIGlmKHggPiAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGlmKHggPCAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIHJldHVybiAwLjU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJlY3RhbmdsZSBmdW5jdGlvbiAtIE1vdmVkIGZyb20gU3BlY2lhbC5qcyAob3JpZ2luYWxseSBjb250cmlidXRlZCBieSBCcm9zbmFuIFl1ZW4pXHJcbiAgICAgICAgICogU3BlY2lmaWNhdGlvbiA6IGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vUmVjdGFuZ2xlRnVuY3Rpb24uaHRtbFxyXG4gICAgICAgICAqIGlmIHx4fCA+IDEvMiB0aGVuIDBcclxuICAgICAgICAgKiBpZiB8eHwgPT0gMS8yIHRoZW4gMS8yXHJcbiAgICAgICAgICogaWYgfHh8IDwgMS8yIHRoZW4gMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gTWF0aC5hYnMoeCk7XHJcbiAgICAgICAgICAgIGlmKHggPT09IDAuNSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICBpZih4ID4gMC41KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBTaW5jIGZ1bmN0aW9uIC0gTW92ZWQgZnJvbSBTcGVjaWFsLmpzIChvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5IEJyb3NuYW4gWXVlbilcclxuICAgICAgICAgKiBTcGVjaWZpY2F0aW9uIDogaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9TaW5jRnVuY3Rpb24uaHRtbFxyXG4gICAgICAgICAqIGlmIHggPT0gMCB0aGVuIDFcclxuICAgICAgICAgKiBvdGhlcndpc2Ugc2luKHgpL3hcclxuICAgICAgICAgKi9cclxuICAgICAgICBzaW5jOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBpZih4LmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oeCkgLyB4O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUcmlhbmdsZSBmdW5jdGlvbiAtIE1vdmVkIGZyb20gU3BlY2lhbC5qcyAob3JpZ2luYWxseSBjb250cmlidXRlZCBieSBCcm9zbmFuIFl1ZW4pXHJcbiAgICAgICAgICogU3BlY2lmaWNhdGlvbiA6IGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vVHJpYW5nbGVGdW5jdGlvbi5odG1sXHJcbiAgICAgICAgICogaWYgfHh8ID49IDEgdGhlbiAwXHJcbiAgICAgICAgICogaWYgfHh8IDwgdGhlbiAxLXx4fFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRyaTogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgeCA9IE1hdGguYWJzKHgpO1xyXG4gICAgICAgICAgICBpZih4ID49IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgcmV0dXJuIDEgLSB4O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9OdGhfcm9vdF9hbGdvcml0aG1cclxuICAgICAgICBudGhyb290OiBmdW5jdGlvbiAoQSwgbikge1xyXG4gICAgICAgICAgICAvKm1ha2Ugc3VyZSB0aGUgaW5wdXQgaXMgb2YgdHlwZSBGcmFjKi9cclxuICAgICAgICAgICAgaWYoIShBIGluc3RhbmNlb2YgRnJhYykpXHJcbiAgICAgICAgICAgICAgICBBID0gbmV3IEZyYWMoQS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgaWYoIShuIGluc3RhbmNlb2YgRnJhYykpXHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IEZyYWMobi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgaWYobi5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQTtcclxuICAgICAgICAgICAgLypiZWdpbiBhbGdvcml0aG0qL1xyXG4gICAgICAgICAgICB2YXIgeGsgPSBBLmRpdmlkZShuZXcgRnJhYygyKSk7IC8qeDAqL1xyXG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBGcmFjKDFlLTE1KTtcclxuICAgICAgICAgICAgdmFyIGRrLCBkazAsIGQwO1xyXG4gICAgICAgICAgICB2YXIgYSA9IG4uY2xvbmUoKS5pbnZlcnQoKSxcclxuICAgICAgICAgICAgICAgICAgICBiID0gbi5zdWJ0cmFjdChuZXcgRnJhYygxKSk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3diID0gTWF0aDIuYmlncG93KHhrLCBiKTtcclxuICAgICAgICAgICAgICAgIHZhciBka19kZWMgPSBhLm11bHRpcGx5KEEuZGl2aWRlKHBvd2IpLnN1YnRyYWN0KHhrKSkudG9EZWNpbWFsKDI1KTtcclxuICAgICAgICAgICAgICAgIGRrID0gRnJhYy5jcmVhdGUoZGtfZGVjKTtcclxuICAgICAgICAgICAgICAgIGlmKGQwKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIHhrID0geGsuYWRkKGRrKTtcclxuICAgICAgICAgICAgICAgIC8qY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3Mgbm8gY2hhbmdlIGZyb20gdGhlIGxhc3QgeGsqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGRrX2RlYyA9IGRrLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgZDAgPSBkazAgPyBkazAgPT09IGRrX2RlYyA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZGswID0gZGtfZGVjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKGRrLmFicygpLmd0ZShlKSlcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4aztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamlnZ3pzb24vMGM1YjMzY2JjZDdiNTJiMzYxMzJiMWU5NjU3MzI4NWYqL1xyXG4gICAgICAgIC8qSnVzdCB0aGUgc3F1YXJlIHJvb3QgZnVuY3Rpb24gYnV0IGJpZyA6KSovXHJcbiAgICAgICAgc3FydDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgaWYoIShuIGluc3RhbmNlb2YgRnJhYykpXHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IEZyYWMobik7XHJcbiAgICAgICAgICAgIHZhciB4biwgZCwgbGQsIHNhbWVfZGVsdGE7XHJcbiAgICAgICAgICAgIHZhciBjID0gMDsgLypjb3VudGVyKi9cclxuICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGRlbHRhID0gbmV3IEZyYWMoMWUtMjApO1xyXG4gICAgICAgICAgICB4biA9IG4uZGl2aWRlKG5ldyBGcmFjKDIpKTtcclxuICAgICAgICAgICAgdmFyIHNhZmV0eSA9IDEwMDA7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIC8qYnJlYWsgaWYgd2UncmUgbm90IGNvbnZlcmdpbmcqL1xyXG4gICAgICAgICAgICAgICAgaWYoYyA+IHNhZmV0eSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjYWxjdWxhdGUgc3F1YXJlIHJvb3QgZm9yICcgKyBuKTtcclxuICAgICAgICAgICAgICAgIHhuID0geG4uYWRkKG4uZGl2aWRlKHhuKSkuZGl2aWRlKG5ldyBGcmFjKDIpKTtcclxuICAgICAgICAgICAgICAgIHhuID0gbmV3IEZyYWMoeG4uZGVjaW1hbCgzMCkpO1xyXG4gICAgICAgICAgICAgICAgLypnZXQgdGhlIGRpZmZlcmVuY2UgZnJvbSB0aGUgdHJ1ZSBzcXVhcmUqL1xyXG4gICAgICAgICAgICAgICAgZCA9IG4uc3VidHJhY3QoeG4ubXVsdGlwbHkoeG4pKTtcclxuICAgICAgICAgICAgICAgIC8qaWYgdGhlIHNxdWFyZSBvZiB0aGUgY2FsY3VsYXRlZCBudW1iZXIgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSBudW1iZXIqL1xyXG4gICAgICAgICAgICAgICAgLyp3ZSdyZSBnZXR0aW5nIHRoZSBzcXVhcmUgcm9vdCBvciB0aGUgbGFzdCBkZWx0YSB3YXMgdGhlIHNhbWUgYXMgdGhlIG5ldyBkZWx0YSovXHJcbiAgICAgICAgICAgICAgICAvKnRoZW4gd2UncmUgZG9uZSovXHJcbiAgICAgICAgICAgICAgICBzYW1lX2RlbHRhID0gbGQgPyBsZC5lcXVhbHMoZCkgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmKGQuY2xvbmUoKS5hYnMoKS5sZXNzVGhhbihkZWx0YSkgfHwgc2FtZV9kZWx0YSlcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8qc3RvcmUgdGhlIGNhbGN1bGF0ZWQgZGVsdGEqL1xyXG4gICAgICAgICAgICAgICAgbGQgPSBkO1xyXG4gICAgICAgICAgICAgICAgYysrOyAvKmluY3JlYXNlIHRoZSBjb3VudGVyKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSghZG9uZSlcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4bjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy9saW5rIHRoZSBNYXRoMiBvYmplY3QgdG8gU2V0dGluZ3MuRlVOQ1RJT05fTU9EVUxFU1xyXG4gICAgU2V0dGluZ3MuRlVOQ1RJT05fTU9EVUxFUy5wdXNoKE1hdGgyKTtcclxuICAgIHJlc2VydmVOYW1lcyhNYXRoMik7IC8vcmVzZXJ2ZSB0aGUgbmFtZXMgaW4gTWF0aDJcclxuXHJcblxyXG4vL1BvbHlmaWxscyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy9odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL1xyXG4gICAgTWF0aC5zaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgeCA9ICt4OyAvLyBjb252ZXJ0IHRvIGEgbnVtYmVyXHJcbiAgICAgICAgaWYoeCA9PT0gMCB8fCBpc05hTih4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHggPiAwID8gMSA6IC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLmNvc2ggPSBNYXRoLmNvc2ggfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgeSA9IE1hdGguZXhwKHgpO1xyXG4gICAgICAgIHJldHVybiAoeSArIDEgLyB5KSAvIDI7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGguc2VjaCA9IE1hdGguc2VjaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHJldHVybiAxIC8gTWF0aC5jb3NoKHgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLmNzY2ggPSBNYXRoLmNzY2ggfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gMSAvIE1hdGguc2luaCh4KTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aC5jb3RoID0gTWF0aC5jb3RoIHx8IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgcmV0dXJuIDEgLyBNYXRoLnRhbmgoeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIE1hdGguc2luaCA9IE1hdGguc2luaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIHZhciB5ID0gTWF0aC5leHAoeCk7XHJcbiAgICAgICAgcmV0dXJuICh5IC0gMSAvIHkpIC8gMjtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aC50YW5oID0gTWF0aC50YW5oIHx8IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYoeCA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoeCA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciB5ID0gTWF0aC5leHAoMiAqIHgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHkgLSAxKSAvICh5ICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBNYXRoLmFzaW5oID0gTWF0aC5hc2luaCB8fCBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgIGlmKHggPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgTWF0aC5hY29zaCA9IE1hdGguYWNvc2ggfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCAtIDEpKTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aC5hdGFuaCA9IE1hdGguYXRhbmggfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpIC8gMjtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aC5sb2cxMCA9IE1hdGgubG9nMTAgfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTtcclxuICAgIH07XHJcblxyXG4gICAgTWF0aC50cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICBpZihpc05hTih4KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih4ID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh4KTtcclxuICAgIH07XHJcblxyXG4vL0dsb2JhbCBmdW5jdGlvbnMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhIGhhc2ggb3IgYSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIGEgU3ltYm9sLCBNYXRyaXgsIG9yIFZlY3Rvci5cclxuICAgICAqIElmIGFsbCBlbHNlIGZhaWxzIGl0ICphc3N1bWVzKiB0aGUgb2JqZWN0IGhhcyBhIHRvU3RyaW5nIG1ldGhvZCBhbmQgd2lsbCBjYWxsIHRoYXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBnZXQgaXMgYXMgYSBoYXNoXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gdXNlR3JvdXBcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRleHQob2JqLCBvcHRpb24sIHVzZUdyb3VwLCBkZWNwKSB7XHJcbiAgICAgICAgdmFyIGFzSGFzaCA9IG9wdGlvbiA9PT0gJ2hhc2gnLFxyXG4gICAgICAgICAgICAgICAgLy93aGV0aGVyIHRvIHdyYXAgbnVtYmVycyBpbiBicmFja2V0c1xyXG4gICAgICAgICAgICAgICAgd3JhcENvbmRpdGlvbiA9IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIG9wdCA9IGFzSGFzaCA/IHVuZGVmaW5lZCA6IG9wdGlvbixcclxuICAgICAgICAgICAgICAgIGFzRGVjaW1hbCA9IG9wdCA9PT0gJ2RlY2ltYWwnIHx8IG9wdCA9PT0gJ2RlY2ltYWxzJztcclxuXHJcbiAgICAgICAgaWYoYXNEZWNpbWFsICYmIHR5cGVvZiBkZWNwID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgZGVjcCA9IDE2O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB0b1N0cmluZyhvYmopIHtcclxuICAgICAgICAgICAgc3dpdGNoKG9wdGlvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZGVjaW1hbHMnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnZGVjaW1hbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcENvbmRpdGlvbiA9IHdyYXBDb25kaXRpb24gfHwgZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlY3VycmluZyc6XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcENvbmRpdGlvbiA9IHdyYXBDb25kaXRpb24gfHwgZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YoXCInXCIpICE9PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gb2JqLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy92ZXJpZnkgdGhhdCB0aGUgc3RyaW5nIGlzIGFjdHVhbGx5IGEgZnJhY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhYyA9IC9eLT9cXGQrKD86XFwvXFxkKyk/JC8uZXhlYyhzdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGZyYWMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NwbGl0IHRoZSBmcmFjdGlvbiBpbnRvIHRoZSBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gZnJhY1swXS5zcGxpdCgnLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZWdhdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0gTnVtYmVyKHBhcnRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihtIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gLW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBOdW1iZXIocGFydHNbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFuKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL3NvZnR3YXJlZW5naW5lZXJpbmcuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE5MjA3MC93aGF0LWlzLWEtZWZmaWNpZW50LXdheS10by1maW5kLXJlcGVhdGluZy1kZWNpbWFsI2NvbW1lbnQ3NDM1NzRfMTkyMDgxXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1b3RpZW50ID0gTWF0aC5mbG9vcihtIC8gbiksIGMgPSAxMCAqIChtIC0gcXVvdGllbnQgKiBuKTtcclxuICAgICAgICAgICAgICAgICAgICBxdW90aWVudCA9IHF1b3RpZW50LnRvU3RyaW5nKCkgKyBcIi5cIjtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZShjICYmIGMgPCBuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgKj0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RpZW50ICs9IFwiMFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlnaXRzID0gXCJcIiwgcGFzc2VkID0gW10sIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHBhc3NlZFtjXSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVmaXggPSBkaWdpdHMuc2xpY2UoMCwgcGFzc2VkW2NdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGUgPSBkaWdpdHMuc2xpY2UocGFzc2VkW2NdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcXVvdGllbnQgKyBwcmVmaXggKyBcIidcIiArIGN5Y2xlICsgXCInXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5lZ2F0aXZlID8gXCItXCIgOiBcIlwiKSArIHJlc3VsdC5yZXBsYWNlKFwiJzAnXCIsIFwiXCIpLnJlcGxhY2UoL1xcLiQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IE1hdGguZmxvb3IoYyAvIG4pLCByID0gYyAtIHEgKiBuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzZWRbY10gPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHMgKz0gcS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAxMCAqIHI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWl4ZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIHdyYXBDb25kaXRpb24gPSB3cmFwQ29uZGl0aW9uIHx8IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKCcvJykgIT09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBvYmoudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3ZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgaXMgYWN0dWFsbHkgYSBmcmFjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFjID0gL14tP1xcZCsoPzpcXC9cXGQrKT8kLy5leGVjKHN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZnJhYy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3BsaXQgdGhlIGZyYWN0aW9uIGludG8gdGhlIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3JcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBmcmFjWzBdLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bWVyID0gbmV3IGJpZ0ludChwYXJ0c1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbm9tID0gbmV3IGJpZ0ludChwYXJ0c1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZGVub20uZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5vbSA9IG5ldyBiaWdJbnQoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRoZSBxdW90aWVudCBwbHVzIHRoZSByZW1haW5kZXJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGl2bW9kID0gbnVtZXIuZGl2bW9kKGRlbm9tKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVvdGllbnQgPSBkaXZtb2QucXVvdGllbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9IGRpdm1vZC5yZW1haW5kZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gcGFydHNbMF1bMF0gPT09ICctJyB8fCBxdW90aWVudC5lcXVhbHMoMCkgfHwgcmVtYWluZGVyLmVxdWFscygwKSA/ICcnIDogJysnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocXVvdGllbnQuZXF1YWxzKDApID8gJycgOiBxdW90aWVudC50b1N0cmluZygpKSArIG9wZXJhdG9yICsgKHJlbWFpbmRlci5lcXVhbHMoMCkgPyAnJyA6IChyZW1haW5kZXIudG9TdHJpbmcoKSArICcvJyArIHBhcnRzWzFdKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzY2llbnRpZmljJzpcclxuICAgICAgICAgICAgICAgICAgICB3cmFwQ29uZGl0aW9uID0gd3JhcENvbmRpdGlvbiB8fCBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2llbnRpZmljKG9iai52YWx1ZU9mKCkpLnRvU3RyaW5nKFNldHRpbmdzLlNDSUVOVElGSUNfTUFYX0RFQ0lNQUxfUExBQ0VTKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcENvbmRpdGlvbiA9IHdyYXBDb25kaXRpb24gfHwgZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YoJy8nKSAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2lmIHRoZSBvYmplY3QgaXMgYSBzeW1ib2xcclxuICAgICAgICBpZihpc1N5bWJvbChvYmopKSB7XHJcbiAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gJycsXHJcbiAgICAgICAgICAgICAgICAgICAgcG93ZXIgPSAnJyxcclxuICAgICAgICAgICAgICAgICAgICBzaWduID0gJycsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBvYmouZ3JvdXAgfHwgdXNlR3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmoudmFsdWU7XHJcblxyXG4gICAgICAgICAgICAvL2lmIHRoZSB2YWx1ZSBpcyB0byBiZSB1c2VkIGFzIGEgaGFzaCB0aGVuIHRoZSBwb3dlciBhbmQgbXVsdGlwbGllciBuZWVkIHRvIGJlIHN1cHByZXNzZWRcclxuICAgICAgICAgICAgaWYoIWFzSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgLy91c2UgYXNEZWNpbWFsIHRvIGdldCB0aGUgb2JqZWN0IGJhY2sgYXMgYSBkZWNpbWFsXHJcbiAgICAgICAgICAgICAgICB2YXIgb20gPSB0b1N0cmluZyhvYmoubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICBpZihvbSA9PSAnLTEnICYmIFN0cmluZyhvYmoubXVsdGlwbGllcikgPT09ICctMScpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xyXG4gICAgICAgICAgICAgICAgICAgIG9tID0gJzEnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9vbmx5IGFkZCB0aGUgbXVsdGlwbGllciBpZiBpdCdzIG5vdCAxXHJcbiAgICAgICAgICAgICAgICBpZihvbSAhPSAnMScpXHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IG9tO1xyXG4gICAgICAgICAgICAgICAgLy91c2UgYXNEZWNpbWFsIHRvIGdldCB0aGUgb2JqZWN0IGJhY2sgYXMgYSBkZWNpbWFsXHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IG9iai5wb3dlciA/IHRvU3RyaW5nKG9iai5wb3dlcikgOiAnJztcclxuICAgICAgICAgICAgICAgIC8vb25seSBhZGQgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgIGlmKHAgIT0gJzEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pcyBpdCBhIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzU3ltYm9sKHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvd2VyID0gdGV4dChwLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG93ZXIgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoKGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE46XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllciA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcm91bmQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBkZWNwICYmIGFzRGVjaW1hbCA/IG9iai5tdWx0aXBsaWVyLnRvRGVjaW1hbChkZWNwKSA6IHRvU3RyaW5nKG9iai5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3MgbnVtZXJpY2FsIHRoZW4gYWxsIHdlIG5lZWQgaXMgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZyhvYmoubXVsdGlwbGllcikgPT0gJy0xJyA/ICcxJyA6IG07XHJcbiAgICAgICAgICAgICAgICAgICAgcG93ZXIgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUEw6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmouY29sbGVjdFN5bWJvbHMoKS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4dCA9IHRleHQoeCwgb3B0LCB1c2VHcm91cCwgZGVjcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHR4dCA9PSAnMCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eHQgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR4dDtcclxuICAgICAgICAgICAgICAgICAgICB9KS5zb3J0KCkuam9pbignKycpLnJlcGxhY2UoL1xcK1xcLS9nLCAnLScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDUDpcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iai5jb2xsZWN0U3ltYm9scygpLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHh0ID0gdGV4dCh4LCBvcHQsIHVzZUdyb3VwLCBkZWNwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHh0ID09ICcwJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4dCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLnNvcnQoKS5qb2luKCcrJykucmVwbGFjZSgvXFwrXFwtL2csICctJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENCOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqLmNvbGxlY3RTeW1ib2xzKGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBzeW1ib2wuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYm90aCBncm91cHMgd2lsbCBhbHJlYWR5IGJlIGluIGJyYWNrZXRzIGlmIHRoZWlyIHBvd2VyIGlzIGdyZWF0ZXIgdGhhbiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc28gc2tpcCBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoKGcgPT09IFBMIHx8IGcgPT09IENQKSAmJiAoc3ltYm9sLnBvd2VyLmVxdWFscygxKSAmJiBzeW1ib2wubXVsdGlwbGllci5lcXVhbHMoMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5CcmFja2V0cyh0ZXh0KHN5bWJvbCwgb3B0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQoc3ltYm9sLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJyonKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRVg6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBnID0gb2JqLnByZXZpb3VzR3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwd2cgPSBvYmoucG93ZXIuZ3JvdXA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vUEwgYXJlIHRoZSBleGNlcHRpb24uIEl0J3Mgc2ltcGxlciB0byBqdXN0IGNvbGxlY3QgYW5kIHNldCB0aGUgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICBpZihwZyA9PT0gUEwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqLmNvbGxlY3RTeW1ib2xzKHRleHQsIG9wdCkuam9pbignKycpLnJlcGxhY2UoJystJywgJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZighKHBnID09PSBOIHx8IHBnID09PSBTIHx8IHBnID09PSBGTikgJiYgIWFzSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGluQnJhY2tldHModmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoKHB3ZyA9PT0gQ1AgfHwgcHdnID09PSBDQiB8fCBwd2cgPT09IFBMIHx8IG9iai5wb3dlci5tdWx0aXBsaWVyLnRvU3RyaW5nKCkgIT0gJzEnKSAmJiBwb3dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3dlciA9IGluQnJhY2tldHMocG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iai5mbmFtZSArIGluQnJhY2tldHMob2JqLmFyZ3MubWFwKGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dChzeW1ib2wsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICB9KS5qb2luKCcsJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vVE9ETzogTmVlZHMgdG8gYmUgbW9yZSBlZmZpY2llbnQuIE1heWJlLlxyXG4gICAgICAgICAgICBpZihncm91cCA9PT0gRk4gJiYgb2JqLmZuYW1lIGluIENVU1RPTV9PUEVSQVRPUlMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhID0gdGV4dChvYmouYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHRleHQob2JqLmFyZ3NbMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYob2JqLmFyZ3NbMF0uaXNDb21wb3NpdGUoKSkgLy9wcmVzZXJ2ZSB0aGUgYnJhY2tldHNcclxuICAgICAgICAgICAgICAgICAgICBhID0gaW5CcmFja2V0cyhhKTtcclxuICAgICAgICAgICAgICAgIGlmKG9iai5hcmdzWzFdLmlzQ29tcG9zaXRlKCkpIC8vcHJlc2VydmUgdGhlIGJyYWNrZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGluQnJhY2tldHMoYik7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGEgKyBDVVNUT01fT1BFUkFUT1JTW29iai5mbmFtZV0gKyBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vd3JhcCB0aGUgcG93ZXIgc2luY2UgLyBpcyBsZXNzIHRoYW4gXlxyXG4gICAgICAgICAgICAvL1RPRE86IGludHJvZHVjZSBtZXRob2QgY2FsbCBpc1NpbXBsZVxyXG4gICAgICAgICAgICBpZihwb3dlciAmJiBncm91cCAhPT0gRVggJiYgd3JhcENvbmRpdGlvbihwb3dlcikpIHtcclxuICAgICAgICAgICAgICAgIHBvd2VyID0gaW5CcmFja2V0cyhwb3dlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vdGhlIGZvbGxvd2luZyBncm91cHMgYXJlIGhlbGQgdG9nZXRoZXIgYnkgcGx1cyBvciBtaW51cy4gVGhleSBjYW4gYmUgcmFpc2VkIHRvIGEgcG93ZXIgb3IgbXVsdGlwbGllZFxyXG4gICAgICAgICAgICAvL2J5IGEgbXVsdGlwbGllciBhbmQgaGF2ZSB0byBiZSBpbiBicmFja2V0cyB0byBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2YgcHJlY2VkZW5jZVxyXG4gICAgICAgICAgICBpZigoKGdyb3VwID09PSBDUCB8fCBncm91cCA9PT0gUEwpICYmIChtdWx0aXBsaWVyICYmIG11bHRpcGxpZXIgIT0gJzEnIHx8IHNpZ24gPT09ICctJykpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgKChncm91cCA9PT0gQ0IgfHwgZ3JvdXAgPT09IENQIHx8IGdyb3VwID09PSBQTCkgJiYgKHBvd2VyICYmIHBvd2VyICE9ICcxJykpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgIWFzSGFzaCAmJiBncm91cCA9PT0gUCAmJiB2YWx1ZSA9PSAtMVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IG9iai5mbmFtZSA9PT0gUEFSRU5USEVTSVMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGluQnJhY2tldHModmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihkZWNwICYmIChvcHRpb24gPT09ICdkZWNpbWFsJyB8fCBvcHRpb24gPT09ICdkZWNpbWFscycgJiYgbXVsdGlwbGllcikpIHtcclxuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIgPSBucm91bmQobXVsdGlwbGllciwgZGVjcCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvL2FkZCB0aGUgc2lnbiBiYWNrXHJcbiAgICAgICAgICAgIHZhciBjID0gc2lnbiArIG11bHRpcGxpZXI7XHJcblxyXG4gICAgICAgICAgICBpZihtdWx0aXBsaWVyICYmIHdyYXBDb25kaXRpb24obXVsdGlwbGllcikpXHJcbiAgICAgICAgICAgICAgICBjID0gaW5CcmFja2V0cyhjKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHBvd2VyIDwgMClcclxuICAgICAgICAgICAgICAgIHBvd2VyID0gaW5CcmFja2V0cyhwb3dlcik7XHJcblxyXG4gICAgICAgICAgICAvL2FkZCB0aGUgbXVsdGlwbGljYXRpb24gYmFja1xyXG4gICAgICAgICAgICBpZihtdWx0aXBsaWVyKVxyXG4gICAgICAgICAgICAgICAgYyA9IGMgKyAnKic7XHJcblxyXG4gICAgICAgICAgICBpZihwb3dlcikge1xyXG4gICAgICAgICAgICAgICAgaWYodmFsdWUgPT09ICdlJyAmJiBTZXR0aW5ncy5FX1RPX0VYUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICsgJ2V4cCcgKyBpbkJyYWNrZXRzKHBvd2VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvd2VyID0gU2V0dGluZ3MuUE9XRVJfT1BFUkFUT1IgKyBwb3dlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy90aGlzIG5lZWRzIHNlcmlvdXMgcmV0aGlua2luZy4gTXVzdCBmaXhcclxuICAgICAgICAgICAgaWYoZ3JvdXAgPT09IEVYICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGluQnJhY2tldHModmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY3YgPSBjICsgdmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZihvYmoucGFyZW5zKSB7XHJcbiAgICAgICAgICAgICAgICBjdiA9IGluQnJhY2tldHMoY3YpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY3YgKyBwb3dlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihpc1ZlY3RvcihvYmopKSB7XHJcbiAgICAgICAgICAgIHZhciBsID0gb2JqLmVsZW1lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBjID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgICAgICBjLnB1c2gob2JqLmVsZW1lbnRzW2ldLnRleHQob3B0aW9uKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBjLmpvaW4oJywnKSArICddJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHByaW1lIGZhY3RvcnMgZm9yIGEgbnVtYmVyLiBJdCBmaXJzdCBjaGVja3MgaWYgdGhlIG51bWJlclxyXG4gICAgICogaXMgYSBwcmltZSBudW1iZXIuIElmIGl0J3Mgbm90IHRoZW4gaXQgd2lsbCBjYWxjdWxhdGUgYWxsIHRoZSBwcmltZXMgXHJcbiAgICAgKiBmb3IgdGhhdCBudW1iZXIuXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gbnVtXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBwcmltZUZhY3RvcnMobnVtKSB7XHJcbiAgICAgICAgaWYoaXNQcmltZShudW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbnVtXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsID0gbnVtLCBpID0gMSwgZmFjdG9ycyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgZXBzaWxvbiA9IDIuMjIwNDQ2MDQ5MjUwMzEzMDgwODQ3MjYzMzM2MTgxNkUtMTY7XHJcbiAgICAgICAgd2hpbGUoaSA8IGwpIHtcclxuICAgICAgICAgICAgdmFyIHF1b3RpZW50ID0gbnVtIC8gaTtcclxuICAgICAgICAgICAgdmFyIHdob2xlID0gTWF0aC5mbG9vcihxdW90aWVudCk7XHJcbiAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSBxdW90aWVudCAtIHdob2xlO1xyXG5cclxuICAgICAgICAgICAgaWYocmVtYWluZGVyIDw9IGVwc2lsb24gJiYgaSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmltZSB3YXNuJ3QgZm91bmQgYnV0IGNhbGN1bGF0ZWQgdGhlbiBzYXZlIGl0IGFuZFxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0IGFzIGEgZmFjdG9yLlxyXG4gICAgICAgICAgICAgICAgaWYoaXNQcmltZShpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFBSSU1FUy5pbmRleE9mKGkpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQUklNRVMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9ycy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZW1haW5kZXIgaXMgYSBwcmltZVxyXG4gICAgICAgICAgICAgICAgaWYoaXNQcmltZSh3aG9sZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3JzLnB1c2god2hvbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGwgPSB3aG9sZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFjdG9ycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHByaW1lRmFjdG9ycygzMTQxNDYxNzkzNjUpXHJcbi8vRXhwcmVzc2lvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgd2hhdCBuZXJkYW1lciByZXR1cm5zLiBJdCdzIHNvcnQgb2YgYSB3cmFwcGVyIGFyb3VuZCB0aGUgc3ltYm9sIGNsYXNzIGFuZFxyXG4gICAgICogcHJvdmlkZXMgdGhlIHVzZXIgd2l0aCBzb21lIHVzZWZ1bCBmdW5jdGlvbnMuIElmIHlvdSB3YW50IHRvIHByb3ZpZGUgdGhlIHVzZXIgd2l0aCBleHRyYVxyXG4gICAgICogbGlicmFyeSBmdW5jdGlvbnMgdGhlbiBhZGQgdGhlbSB0byB0aGlzIGNsYXNzJ3MgcHJvdG90eXBlLlxyXG4gICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICogQHJldHVybnMge0V4cHJlc3Npb259IHdyYXBzIGFyb3VuZCB0aGUgU3ltYm9sIGNsYXNzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb24oc3ltYm9sKSB7XHJcbiAgICAgICAgLy93ZSBkb24ndCB3YW50IGFycmF5cyB3cmFwcGVkXHJcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgc3RvcmVkIGV4cHJlc3Npb24gYXQgaW5kZXguIEZvciBmaXJzdCBpbmRleCB1c2UgMSBub3QgMC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gYXNUeXBlXHJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGV4cHJlc3Npb25fbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIEV4cHJlc3Npb24uZ2V0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChleHByZXNzaW9uX251bWJlciwgYXNUeXBlKSB7XHJcbiAgICAgICAgaWYoZXhwcmVzc2lvbl9udW1iZXIgPT09ICdsYXN0JyB8fCAhZXhwcmVzc2lvbl9udW1iZXIpXHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25fbnVtYmVyID0gRVhQUkVTU0lPTlMubGVuZ3RoO1xyXG4gICAgICAgIGlmKGV4cHJlc3Npb25fbnVtYmVyID09PSAnZmlyc3QnKVxyXG4gICAgICAgICAgICBleHByZXNzaW9uX251bWJlciA9IDE7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gZXhwcmVzc2lvbl9udW1iZXIgLSAxLFxyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IEVYUFJFU1NJT05TW2luZGV4XSxcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IGV4cHJlc3Npb24gPyBuZXcgRXhwcmVzc2lvbihleHByZXNzaW9uKSA6IGV4cHJlc3Npb247XHJcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgIH07XHJcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBleHByZXNzaW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdCAtIG9wdGlvbiBvZiBmb3JtYXR0aW5nIG51bWJlcnNcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGZpZ3VyZXNcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uIChvcHQsIG4pIHtcclxuICAgICAgICAgICAgbiA9IG4gfHwgMTk7XHJcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCAnZGVjaW1hbHMnO1xyXG4gICAgICAgICAgICBpZih0aGlzLnN5bWJvbC50ZXh0XylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbC50ZXh0XyhvcHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRleHQodGhpcy5zeW1ib2wsIG9wdCwgdW5kZWZpbmVkLCBuKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGxhdGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBleHByZXNzaW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiAtIG9wdGlvbiBmb3IgZm9ybWF0dGluZyBudW1iZXJzXHJcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBsYXRleDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICBpZih0aGlzLnN5bWJvbC5sYXRleClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbC5sYXRleChvcHRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gTGFUZVgubGF0ZXgodGhpcy5zeW1ib2wsIG9wdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbC52YWx1ZU9mKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZhbHVhdGVzIHRoZSBleHByZXNzaW9uIGFuZCB0cmllcyB0byByZWR1Y2UgaXQgdG8gYSBudW1iZXIgaWYgcG9zc2libGUuXHJcbiAgICAgICAgICogSWYgYW4gYXJndW1lbnQgaXMgZ2l2ZW4gaW4gdGhlIGZvcm0gb2YgJXtpbnRlZ2VyfSBpdCB3aWxsIGV2YWx1YXRlIHRoYXQgZXhwcmVzc2lvbi5cclxuICAgICAgICAgKiBPdGhlciB0aGFuIHRoYXQgaXQgd2lsbCBqdXN0IHVzZSBpdCdzIG93biB0ZXh0IGFuZCByZXBhcnNlXHJcbiAgICAgICAgICogQHJldHVybnMge0V4cHJlc3Npb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IGV2YWx1YXRlIGFuIGVtcHR5IHZlY3RvclxyXG4gICAgICAgICAgICBpZihpc1ZlY3Rvcih0aGlzLnN5bWJvbCkgJiYgdGhpcy5zeW1ib2wuZGltZW5zaW9ucygpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGZpcnN0X2FyZyA9IGFyZ3VtZW50c1swXSwgZXhwcmVzc2lvbiwgaWR4ID0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vRW5hYmxlIGdldHRpbmcgb2YgZXhwcmVzc2lvbnMgdXNpbmcgdGhlICUgc28gZm9yIGV4YW1wbGUgJTEgc2hvdWxkIGdldCB0aGUgZmlyc3QgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICBpZih0eXBlb2YgZmlyc3RfYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IChmaXJzdF9hcmcuY2hhckF0KDApID09PSAnJScpID8gRXhwcmVzc2lvbi5nZXRFeHByZXNzaW9uKGZpcnN0X2FyZy5zdWJzdHIoMSkpLnRleHQoKSA6IGZpcnN0X2FyZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGZpcnN0X2FyZyBpbnN0YW5jZW9mIEV4cHJlc3Npb24gfHwgaXNTeW1ib2woZmlyc3RfYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGZpcnN0X2FyZy50ZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gdGhpcy5zeW1ib2wudGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgaWR4LS07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdWJzID0gYXJndW1lbnRzW2lkeF0gfHwge307XHJcblxyXG4gICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IEV4cHJlc3Npb24oYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGV4cHJlc3Npb24sIHN1YnMpO1xyXG4gICAgICAgICAgICB9LCB0cnVlKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBzeW1ib2wgdG8gYSBKUyBmdW5jdGlvbi4gUGFzcyBpbiBhbiBhcnJheSBvZiB2YXJpYWJsZXMgdG8gdXNlIHRoYXQgb3JkZXIgaW5zdGVhZCBvZlxyXG4gICAgICAgICAqIHRoZSBkZWZhdWx0IGFscGhhYmV0aWNhbCBvcmRlclxyXG4gICAgICAgICAqIEBwYXJhbSB2YXJzIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBidWlsZEZ1bmN0aW9uOiBmdW5jdGlvbiAodmFycykge1xyXG4gICAgICAgICAgICByZXR1cm4gQnVpbGQuYnVpbGQodGhpcy5zeW1ib2wsIHZhcnMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZXhwcmVzc2lvbiBpcyBqdXN0IGEgcGxhaW4gb2xkIG51bWJlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzTnVtYmVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc051bWVyaWNTeW1ib2wodGhpcy5zeW1ib2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgZXhwcmVzc2lvbiBpcyBpbmZpbml0eVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzSW5maW5pdHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc3ltYm9sLm11bHRpcGxpZXIpID09PSBJbmZpbml0eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIGV4cHJlc3Npb24gY29udGFpbnMgaW1hZ2luYXJ5IG51bWJlcnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc0ltYWdpbmFyeTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGUoXy5wYXJzZSh0aGlzLnN5bWJvbCkpLmlzSW1hZ2luYXJ5KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFsbCB0aGUgdmFyaWFibGVzIGluIHRoZSBleHByZXNzaW9uXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhcmlhYmxlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFyaWFibGVzKHRoaXMuc3ltYm9sKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYoaXNBcnJheSh0aGlzLnN5bWJvbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbJyArIHRoaXMuc3ltYm9sLnRvU3RyaW5nKCkgKyAnXSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2wudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vZm9yY2VzIHRoZSBzeW1ib2wgdG8gYmUgcmV0dXJuZWQgYXMgYSBkZWNpbWFsXHJcbiAgICAgICAgdG9EZWNpbWFsOiBmdW5jdGlvbiAocHJlYykge1xyXG4gICAgICAgICAgICBTZXR0aW5ncy5wcmVjaXNpb24gPSBwcmVjO1xyXG4gICAgICAgICAgICB2YXIgZGVjID0gdGV4dCh0aGlzLnN5bWJvbCwgJ2RlY2ltYWxzJyk7XHJcbiAgICAgICAgICAgIFNldHRpbmdzLnByZWNpc2lvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIGRlYztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vY2hlY2tzIHRvIHNlZSBpZiB0aGUgZXhwcmVzc2lvbiBpcyBhIGZyYWN0aW9uXHJcbiAgICAgICAgaXNGcmFjdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNGcmFjdGlvbih0aGlzLnN5bWJvbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2NoZWNrcyB0byBzZWUgaWYgdGhlIHN5bWJvbCBpcyBhIG11bHRpdmFyaWF0ZSBwb2x5bm9taWFsXHJcbiAgICAgICAgaXNQb2x5bm9taWFsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbC5pc1BvbHkoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vcGVyZm9ybXMgYSBzdWJzdGl0dXRpb25cclxuICAgICAgICBzdWI6IGZ1bmN0aW9uIChzeW1ib2wsIGZvcl9zeW1ib2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHRoaXMuc3ltYm9sLnN1YihfLnBhcnNlKHN5bWJvbCksIF8ucGFyc2UoZm9yX3N5bWJvbCkpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24gKG90eXBlLCBzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoaXNFeHByZXNzaW9uKHN5bWJvbCkpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuc3ltYm9sO1xyXG4gICAgICAgICAgICBlbHNlIGlmKCFpc1N5bWJvbChzeW1ib2wpKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gXy5wYXJzZShzeW1ib2wpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24oX1tvdHlwZV0odGhpcy5zeW1ib2wuY2xvbmUoKSwgc3ltYm9sLmNsb25lKCkpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb24oJ2FkZCcsIHN5bWJvbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb24oJ3N1YnRyYWN0Jywgc3ltYm9sKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbignbXVsdGlwbHknLCBzeW1ib2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGl2aWRlOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbignZGl2aWRlJywgc3ltYm9sKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBvdzogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb24oJ3BvdycsIHN5bWJvbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKF8uZXhwYW5kKHRoaXMuc3ltYm9sKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlYWNoOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGkpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5zeW1ib2wuZWFjaClcclxuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sLmVhY2goY2FsbGJhY2ssIGkpO1xyXG4gICAgICAgICAgICBlbHNlIGlmKGlzQXJyYXkodGhpcy5zeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5zeW1ib2wubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLnN5bWJvbCwgdGhpcy5zeW1ib2xbaV0sIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcy5zeW1ib2wpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXE6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2wodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfLnBhcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gXy5zdWJ0cmFjdCh0aGlzLnN5bWJvbC5jbG9uZSgpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5lcXVhbHMoMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGx0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gXy5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGV2YWx1YXRlKF8uc3VidHJhY3QodGhpcy5zeW1ib2wuY2xvbmUoKSwgdmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkLmxlc3NUaGFuKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBndDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF8ucGFyc2UodmFsdWUpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBldmFsdWF0ZShfLnN1YnRyYWN0KHRoaXMuc3ltYm9sLmNsb25lKCksIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5ncmVhdGVyVGhhbigwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGd0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmd0KHZhbHVlKSB8fCB0aGlzLmVxKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGx0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmx0KHZhbHVlKSB8fCB0aGlzLmVxKHZhbHVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBudW1lcmF0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHRoaXMuc3ltYm9sLmdldE51bSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlbm9taW5hdG9yOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbih0aGlzLnN5bWJvbC5nZXREZW5vbSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhc0Z1bmN0aW9uOiBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2wuY29udGFpbnNGdW5jdGlvbihmKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAodmFyaWFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sLmNvbnRhaW5zKHZhcmlhYmxlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy9BbGlhc2VzXHJcbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS50b1RlWCA9IEV4cHJlc3Npb24ucHJvdG90eXBlLmxhdGV4O1xyXG5cclxuLy9TY2llbnRpZmljID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIGZ1bmN0aW9uIFNjaWVudGlmaWMobnVtKSB7XHJcbiAgICAgICAgaWYoISh0aGlzIGluc3RhbmNlb2YgU2NpZW50aWZpYykpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NpZW50aWZpYyhudW0pO1xyXG5cclxuICAgICAgICBudW0gPSBTdHJpbmcodHlwZW9mIG51bSA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogbnVtKTsgLy9jb252ZXJ0IHRvIGEgc3RyaW5nXHJcblxyXG4gICAgICAgIC8vcmVtb3ZlIHRoZSBzaWduXHJcbiAgICAgICAgaWYobnVtLnN0YXJ0c1dpdGgoJy0nKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNpZ24gPSAtMTtcclxuICAgICAgICAgICAgLy9yZW1vdmUgdGhlIHNpZ25cclxuICAgICAgICAgICAgbnVtID0gbnVtLnN1YnN0cigxLCBudW0ubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2lnbiA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihTY2llbnRpZmljLmlzU2NpZW50aWZpYyhudW0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbVNjaWVudGlmaWMobnVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udmVydChudW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBTY2llbnRpZmljLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBmcm9tU2NpZW50aWZpYzogZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBTdHJpbmcobnVtKS50b0xvd2VyQ2FzZSgpLnNwbGl0KCdlJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBwYXJ0c1swXTtcclxuICAgICAgICAgICAgdGhpcy5leHBvbmVudCA9IHBhcnRzWzFdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgICAgIC8vZ2V0IHdob2xlcyBhbmQgZGVjaW1hbHNcclxuICAgICAgICAgICAgdmFyIHBhcnRzID0gbnVtLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIC8vbWFrZSB6ZXJvIGdvIGF3YXlcclxuICAgICAgICAgICAgdmFyIHcgPSBwYXJ0c1swXSB8fCAnJztcclxuICAgICAgICAgICAgdmFyIGQgPSBwYXJ0c1sxXSB8fCAnJztcclxuICAgICAgICAgICAgLy9jb252ZXJ0IHplcm8gdG8gYmxhbmsgc3RyaW5nc1xyXG4gICAgICAgICAgICB3ID0gU2NpZW50aWZpYy5yZW1vdmVMZWFkaW5nWmVyb2VzKHcpO1xyXG4gICAgICAgICAgICBkID0gU2NpZW50aWZpYy5yZW1vdmVUcmFpbGluZ1plcm9lcyhkKTtcclxuICAgICAgICAgICAgLy9maW5kIHRoZSBsb2NhdGlvbiBvZiB0aGUgZGVjaW1hbCBwbGFjZSB3aGljaCBpcyByaWdodCBhZnRlciB0aGUgd2hvbGVzXHJcbiAgICAgICAgICAgIHZhciBkb3RfbG9jYXRpb24gPSB3Lmxlbmd0aDtcclxuICAgICAgICAgICAgLy9hZGQgdGhlbSB0b2dldGhlciBzbyB3ZSBjYW4gbW92ZSB0aGUgZG90XHJcbiAgICAgICAgICAgIHZhciBuID0gdyArIGQ7XHJcbiAgICAgICAgICAgIC8vZmluZCB0aGUgbmV4dCBudW1iZXJcclxuICAgICAgICAgICAgdmFyIHplcm9lcyA9IFNjaWVudGlmaWMubGVhZGluZ1plcm9lcyhuKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vc2V0IHRoZSBleHBvbmVudFxyXG4gICAgICAgICAgICB0aGlzLmV4cG9uZW50ID0gZG90X2xvY2F0aW9uIC0gKHplcm9lcyArIDEpO1xyXG4gICAgICAgICAgICAvL3NldCB0aGUgY29lZmYgYnV0IGZpcnN0IHJlbW92ZSBsZWFkaW5nIHplcm9lc1xyXG4gICAgICAgICAgICB2YXIgY29lZmYgPSBTY2llbnRpZmljLnJlbW92ZUxlYWRpbmdaZXJvZXMobik7XHJcbiAgICAgICAgICAgIHRoaXMuY29lZmYgPSBjb2VmZi5jaGFyQXQoMCkgKyAnLicgKyAoY29lZmYuc3Vic3RyKDEsIGNvZWZmLmxlbmd0aCkgfHwgJzAnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm91bmQ6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmNvcHkoKTtcclxuXHJcbiAgICAgICAgICAgIG51bSA9IE51bWJlcihudW0pOyAvL2Nhc3QgdG8gbnVtYmVyIGZvciBzYWZldHlcclxuICAgICAgICAgICAgLy9zaW5jZSB3ZSBrbm93IGl0IGd1YXJhbnRlZWQgdG8gYmUgaW4gdGhlIGZvcm1hdCB7ZGlnaXR9e29wdGlvbmFsIGRvdH17b3B0aW9uYWwgZGlnaXRzfVxyXG4gICAgICAgICAgICAvL3dlIGNhbiByb3VuZCBiYXNlZCBvbiB0aGlzXHJcbiAgICAgICAgICAgIGlmKG51bSA9PT0gMClcclxuICAgICAgICAgICAgICAgIG4uY29lZmYgPSBuLmNvZWZmLmNoYXJBdCgwKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2dldCB1cCB0byBuLTEgZGlnaXRzXHJcbiAgICAgICAgICAgICAgICB2YXIgcm91bmRlZCA9IHRoaXMuY29lZmYuc3Vic3RyaW5nKDAsIG51bSArIDEpO1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIG5leHQgdHdvXHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF90d28gPSB0aGlzLmNvZWZmLnN1YnN0cmluZyhudW0gKyAxLCBudW0gKyAzKTtcclxuICAgICAgICAgICAgICAgIC8vdGhlIGV4dHJhIGRpZ2l0XHJcbiAgICAgICAgICAgICAgICB2YXIgZWQgPSBuZXh0X3R3by5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYobmV4dF90d28uY2hhckF0KDEpID4gNClcclxuICAgICAgICAgICAgICAgICAgICBlZCsrO1xyXG5cclxuICAgICAgICAgICAgICAgIG4uY29lZmYgPSByb3VuZGVkICsgZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29weTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5ldyBTY2llbnRpZmljKDApO1xyXG4gICAgICAgICAgICBuLmNvZWZmID0gdGhpcy5jb2VmZjtcclxuICAgICAgICAgICAgbi5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XHJcbiAgICAgICAgICAgIG4uc2lnbiA9IHRoaXMuc2lnbjtcclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgdmFyIGNvZWZmID0gdHlwZW9mIG4gPT09ICd1bmRlZmluZWQnID8gdGhpcy5jb2VmZiA6IFNjaWVudGlmaWMucm91bmQodGhpcy5jb2VmZiwgbik7XHJcblxyXG4gICAgICAgICAgICB2YXIgYztcclxuICAgICAgICAgICAgaWYodGhpcy5leHBvbmVudCA9PT0gMCAmJiBTZXR0aW5ncy5TQ0lFTlRJRklDX0lHTk9SRV9JTlRTKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5jb2VmZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGMgPSBjb2VmZiArICdlJyArIHRoaXMuZXhwb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNpZ24gPT09IC0xID8gJy0nIDogJycpICsgYztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFNjaWVudGlmaWMuaXNTY2llbnRpZmljID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHJldHVybiAvXFxkK1xcLj9cXGQqZVtcXCtcXC1dKlxcZCsvaS50ZXN0KG51bSk7XHJcbiAgICB9O1xyXG4gICAgU2NpZW50aWZpYy5sZWFkaW5nWmVyb2VzID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IG51bS5tYXRjaCgvXigwKikuKiQvKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xyXG4gICAgfTtcclxuICAgIFNjaWVudGlmaWMucmVtb3ZlTGVhZGluZ1plcm9lcyA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICB2YXIgbWF0Y2ggPSBudW0ubWF0Y2goL14wKiguKikkLyk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcclxuICAgIH07XHJcblxyXG4gICAgU2NpZW50aWZpYy5yZW1vdmVUcmFpbGluZ1plcm9lcyA9IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICB2YXIgbWF0Y2ggPSBudW0ubWF0Y2goLzAqJC8pO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG51bS5zdWJzdHJpbmcoMCwgbnVtLmxlbmd0aCAtIG1hdGNoWzBdLmxlbmd0aCkgOiAnJztcclxuICAgIH07XHJcbiAgICBTY2llbnRpZmljLnJvdW5kID0gZnVuY3Rpb24gKGMsIG4pIHtcclxuICAgICAgICB2YXIgY29lZmYgPSBucm91bmQoYywgbik7XHJcbiAgICAgICAgdmFyIG0gPSBTdHJpbmcoY29lZmYpLnNwbGl0KCcuJykucG9wKCk7XHJcbiAgICAgICAgdmFyIGQgPSBuIC0gbS5sZW5ndGg7XHJcbiAgICAgICAgLy9pZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgc2lnbmlmaWNhbnQgZmlndXJlc1xyXG4gICAgICAgIGlmKGQgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvZWZmID0gY29lZmYgKyAobmV3IEFycmF5KGQgKyAxKS5qb2luKDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZWZmO1xyXG4gICAgfTtcclxuXHJcbi8vU2NpZW50aWZpYyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvKlxyXG4gICAgICogSmF2YXNjcmlwdCBoYXMgdGhlIHRvRXhwb25lbnRpYWwgbWV0aG9kIGJ1dCB0aGlzIGFsbG93cyB5b3UgdG8gd29yayB3aXRoIHN0cmluZyBhbmQgdGhlcmVmb3JlIGFueSBudW1iZXIgb2YgZGlnaXRzIG9mIHlvdXIgY2hvb3NpbmdcclxuICAgICAqIEZvciBleGFtcGxlIFNjaWVudGlmaWMoJzQ2NDU4OTQ5ODQ0OTQ5NjQ2NzkyNDE5NzU0NTYyNTI0NzY5NTQ2NDU2OTU2ODk1OTEyNDU2ODQ4OTU0ODQ1NCcpO1xyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gU2NpZW50aWZpYyhudW0pIHtcclxuICAgICAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBTY2llbnRpZmljKSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2llbnRpZmljKG51bSk7XHJcblxyXG4gICAgICAgIG51bSA9IFN0cmluZyh0eXBlb2YgbnVtID09PSAndW5kZWZpbmVkJyA/IDAgOiBudW0pOyAvL2NvbnZlcnQgdG8gYSBzdHJpbmdcclxuXHJcbiAgICAgICAgLy9yZW1vdmUgdGhlIHNpZ25cclxuICAgICAgICBpZihudW0uc3RhcnRzV2l0aCgnLScpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2lnbiA9IC0xO1xyXG4gICAgICAgICAgICAvL3JlbW92ZSB0aGUgc2lnblxyXG4gICAgICAgICAgICBudW0gPSBudW0uc3Vic3RyKDEsIG51bS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zaWduID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKFNjaWVudGlmaWMuaXNTY2llbnRpZmljKG51bSkpIHtcclxuICAgICAgICAgICAgdGhpcy5mcm9tU2NpZW50aWZpYyhudW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb252ZXJ0KG51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIFNjaWVudGlmaWMucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGZyb21TY2llbnRpZmljOiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IFN0cmluZyhudW0pLnRvTG93ZXJDYXNlKCkuc3BsaXQoJ2UnKTtcclxuICAgICAgICAgICAgdGhpcy5jb2VmZiA9IHBhcnRzWzBdO1xyXG4gICAgICAgICAgICB0aGlzLmV4cG9uZW50ID0gcGFydHNbMV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgLy9nZXQgd2hvbGVzIGFuZCBkZWNpbWFsc1xyXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBudW0uc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgLy9tYWtlIHplcm8gZ28gYXdheVxyXG4gICAgICAgICAgICB2YXIgdyA9IHBhcnRzWzBdIHx8ICcnO1xyXG4gICAgICAgICAgICB2YXIgZCA9IHBhcnRzWzFdIHx8ICcnO1xyXG4gICAgICAgICAgICAvL2NvbnZlcnQgemVybyB0byBibGFuayBzdHJpbmdzXHJcbiAgICAgICAgICAgIHcgPSBTY2llbnRpZmljLnJlbW92ZUxlYWRpbmdaZXJvZXModyk7XHJcbiAgICAgICAgICAgIGQgPSBTY2llbnRpZmljLnJlbW92ZVRyYWlsaW5nWmVyb2VzKGQpO1xyXG4gICAgICAgICAgICAvL2ZpbmQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkZWNpbWFsIHBsYWNlIHdoaWNoIGlzIHJpZ2h0IGFmdGVyIHRoZSB3aG9sZXNcclxuICAgICAgICAgICAgdmFyIGRvdF9sb2NhdGlvbiA9IHcubGVuZ3RoO1xyXG4gICAgICAgICAgICAvL2FkZCB0aGVtIHRvZ2V0aGVyIHNvIHdlIGNhbiBtb3ZlIHRoZSBkb3RcclxuICAgICAgICAgICAgdmFyIG4gPSB3ICsgZDtcclxuICAgICAgICAgICAgLy9maW5kIHRoZSBuZXh0IG51bWJlclxyXG4gICAgICAgICAgICB2YXIgemVyb2VzID0gU2NpZW50aWZpYy5sZWFkaW5nWmVyb2VzKG4pLmxlbmd0aDtcclxuICAgICAgICAgICAgLy9zZXQgdGhlIGV4cG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMuZXhwb25lbnQgPSBkb3RfbG9jYXRpb24gLSAoemVyb2VzICsgMSk7XHJcbiAgICAgICAgICAgIC8vc2V0IHRoZSBjb2VmZiBidXQgZmlyc3QgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXHJcbiAgICAgICAgICAgIHZhciBjb2VmZiA9IFNjaWVudGlmaWMucmVtb3ZlTGVhZGluZ1plcm9lcyhuKTtcclxuICAgICAgICAgICAgdGhpcy5jb2VmZiA9IGNvZWZmLmNoYXJBdCgwKSArICcuJyArIChjb2VmZi5zdWJzdHIoMSwgY29lZmYubGVuZ3RoKSB8fCAnMCcpO1xyXG5cclxuICAgICAgICAgICAgLy90aGUgY29lZmYgZGVjaW1hbCBwbGFjZXNcclxuICAgICAgICAgICAgdmFyIGRlYyA9IHRoaXMuY29lZmYuc3BsaXQoJy4nKVsxXSB8fCAnJzsgLy9pZiBpdCdzIHVuZGVmaW5lZCBvciB6ZXJvIGl0J3MgZ29pbmcgdG8gYmxhbmtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuZGVjcCA9IGRlYyA9PT0gJzAnID8gMCA6IGRlYy5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vZGVjaW1hbHNcclxuICAgICAgICAgICAgdGhpcy5kZWMgPSBkO1xyXG4gICAgICAgICAgICAvL3dob2xlc1xyXG4gICAgICAgICAgICB0aGlzLndob2xlcyA9IHc7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdW5kOiBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5jb3B5KCk7XHJcblxyXG4gICAgICAgICAgICBudW0gPSBOdW1iZXIobnVtKTsgLy9jYXN0IHRvIG51bWJlciBmb3Igc2FmZXR5XHJcbiAgICAgICAgICAgIC8vc2luY2Ugd2Uga25vdyBpdCBndWFyYW50ZWVkIHRvIGJlIGluIHRoZSBmb3JtYXQge2RpZ2l0fXtvcHRpb25hbCBkb3R9e29wdGlvbmFsIGRpZ2l0c31cclxuICAgICAgICAgICAgLy93ZSBjYW4gcm91bmQgYmFzZWQgb24gdGhpc1xyXG4gICAgICAgICAgICBpZihudW0gPT09IDApXHJcbiAgICAgICAgICAgICAgICBuLmNvZWZmID0gbi5jb2VmZi5jaGFyQXQoMCk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy9nZXQgdXAgdG8gbi0xIGRpZ2l0c1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdW5kZWQgPSB0aGlzLmNvZWZmLnN1YnN0cmluZygwLCBudW0gKyAxKTtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBuZXh0IHR3b1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRfdHdvID0gdGhpcy5jb2VmZi5zdWJzdHJpbmcobnVtICsgMSwgbnVtICsgMyk7XHJcbiAgICAgICAgICAgICAgICAvL3RoZSBleHRyYSBkaWdpdFxyXG4gICAgICAgICAgICAgICAgdmFyIGVkID0gbmV4dF90d28uY2hhckF0KDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKG5leHRfdHdvLmNoYXJBdCgxKSA+IDQpXHJcbiAgICAgICAgICAgICAgICAgICAgZWQrKztcclxuXHJcbiAgICAgICAgICAgICAgICBuLmNvZWZmID0gcm91bmRlZCArIGVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBuZXcgU2NpZW50aWZpYygwKTtcclxuICAgICAgICAgICAgbi5jb2VmZiA9IHRoaXMuY29lZmY7XHJcbiAgICAgICAgICAgIG4uZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50O1xyXG4gICAgICAgICAgICBuLnNpZ24gPSB0aGlzLnNpZ247XHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHZhciByZXR2YWw7XHJcblxyXG4gICAgICAgICAgICBpZihTZXR0aW5ncy5TQ0lFTlRJRklDX0lHTk9SRV9aRVJPX0VYUE9ORU5UUyAmJiB0aGlzLmV4cG9uZW50ID09PSAwICYmIHRoaXMuZGVjcCA8IG4pIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZGVjcCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB0aGlzLndob2xlcztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSB0aGlzLmNvZWZmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZWZmID0gdHlwZW9mIG4gPT09ICd1bmRlZmluZWQnID8gdGhpcy5jb2VmZiA6IFNjaWVudGlmaWMucm91bmQodGhpcy5jb2VmZiwgTWF0aC5taW4obiwgdGhpcy5kZWNwIHx8IDEpKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHRoaXMuZXhwb25lbnQgPT09IDAgPyBjb2VmZiA6IGNvZWZmICsgJ2UnICsgdGhpcy5leHBvbmVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNpZ24gPT09IC0xID8gJy0nIDogJycpICsgcmV0dmFsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgU2NpZW50aWZpYy5pc1NjaWVudGlmaWMgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgcmV0dXJuIC9cXGQrXFwuP1xcZCplW1xcK1xcLV0qXFxkKy9pLnRlc3QobnVtKTtcclxuICAgIH07XHJcbiAgICBTY2llbnRpZmljLmxlYWRpbmdaZXJvZXMgPSBmdW5jdGlvbiAobnVtKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gbnVtLm1hdGNoKC9eKDAqKS4qJC8pO1xyXG4gICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbiAgICB9O1xyXG4gICAgU2NpZW50aWZpYy5yZW1vdmVMZWFkaW5nWmVyb2VzID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IG51bS5tYXRjaCgvXjAqKC4qKSQvKTtcclxuICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xyXG4gICAgfTtcclxuXHJcbiAgICBTY2llbnRpZmljLnJlbW92ZVRyYWlsaW5nWmVyb2VzID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBtYXRjaCA9IG51bS5tYXRjaCgvMCokLyk7XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoID8gbnVtLnN1YnN0cmluZygwLCBudW0ubGVuZ3RoIC0gbWF0Y2hbMF0ubGVuZ3RoKSA6ICcnO1xyXG4gICAgfTtcclxuXHJcblxyXG4vL0ZyYWMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgZnVuY3Rpb24gRnJhYyhuKSB7XHJcbiAgICAgICAgaWYobiBpbnN0YW5jZW9mIEZyYWMpXHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIGlmKG4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYoaXNJbnQobikpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5udW0gPSBiaWdJbnQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZW4gPSBiaWdJbnQoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZyYWMuc2ltcGxlKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYWMgPSBuIGluc3RhbmNlb2YgYmlnRGVjID8gRnJhY3Rpb24ucXVpY2tDb252ZXJzaW9uKG4pIDogRnJhY3Rpb24uY29udmVydChuKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubnVtID0gbmV3IGJpZ0ludChmcmFjWzBdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVuID0gbmV3IGJpZ0ludChmcmFjWzFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBGcmFjLnNpbXBsZShuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG4gICAgLy9zYWZlIHRvIHVzZSB3aXRoIG5lZ2F0aXZlIG51bWJlcnMgb3Igb3RoZXIgdHlwZXNcclxuICAgIEZyYWMuY3JlYXRlID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICBpZihuIGluc3RhbmNlb2YgRnJhYylcclxuICAgICAgICAgICAgcmV0dXJuIG47XHJcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcclxuICAgICAgICB2YXIgaXNfbmVnID0gbi5jaGFyQXQoMCkgPT09ICctJzsgLy9jaGVjayBpZiBpdCdzIG5lZ2F0aXZlXHJcbiAgICAgICAgaWYoaXNfbmVnKVxyXG4gICAgICAgICAgICBuID0gbi5zdWJzdHIoMSwgbi5sZW5ndGggLSAxKTsgLy9yZW1vdmUgdGhlIHNpZ25cclxuICAgICAgICB2YXIgZnJhYyA9IG5ldyBGcmFjKG4pO1xyXG4gICAgICAgIC8vcHV0IHRoZSBzaWduIGJhY2tcclxuICAgICAgICBpZihpc19uZWcpXHJcbiAgICAgICAgICAgIGZyYWMubmVnYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIGZyYWM7XHJcbiAgICB9O1xyXG4gICAgRnJhYy5pc0ZyYWMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiAobyBpbnN0YW5jZW9mIEZyYWMpO1xyXG4gICAgfTtcclxuICAgIEZyYWMucXVpY2sgPSBmdW5jdGlvbiAobiwgZCkge1xyXG4gICAgICAgIHZhciBmcmFjID0gbmV3IEZyYWMoKTtcclxuICAgICAgICBmcmFjLm51bSA9IG5ldyBiaWdJbnQobik7XHJcbiAgICAgICAgZnJhYy5kZW4gPSBuZXcgYmlnSW50KGQpO1xyXG4gICAgICAgIHJldHVybiBmcmFjO1xyXG4gICAgfTtcclxuICAgIEZyYWMuc2ltcGxlID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB2YXIgbnN0ciA9IFN0cmluZyhzY2llbnRpZmljVG9EZWNpbWFsKG4pKSxcclxuICAgICAgICAgICAgICAgIG1fZGMgPSBuc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICAgICAgICBudW0gPSBtX2RjLmpvaW4oJycpLFxyXG4gICAgICAgICAgICAgICAgZGVuID0gMSxcclxuICAgICAgICAgICAgICAgIGwgPSAobV9kY1sxXSB8fCAnJykubGVuZ3RoO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspXHJcbiAgICAgICAgICAgIGRlbiArPSAnMCc7XHJcbiAgICAgICAgdmFyIGZyYWMgPSBGcmFjLnF1aWNrKG51bSwgZGVuKTtcclxuICAgICAgICByZXR1cm4gZnJhYy5zaW1wbGlmeSgpO1xyXG4gICAgfTtcclxuICAgIEZyYWMucHJvdG90eXBlID0ge1xyXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmlzT25lKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtLmNsb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYobS5pc09uZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgYy5udW0gPSBjLm51bS5tdWx0aXBseShtLm51bSk7XHJcbiAgICAgICAgICAgIGMuZGVuID0gYy5kZW4ubXVsdGlwbHkobS5kZW4pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGMuc2ltcGxpZnkoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpdmlkZTogZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgaWYobS5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGl2aXNpb25CeVplcm8oJ0RpdmlzaW9uIGJ5IHplcm8gbm90IGFsbG93ZWQhJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsdGlwbHkobS5jbG9uZSgpLmludmVydCgpKS5zaW1wbGlmeSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3VidHJhY3Q6IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuYWRkKG0uY2xvbmUoKS5uZWcoKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZWc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5udW0gPSB0aGlzLm51bS5tdWx0aXBseSgtMSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICB2YXIgbjEgPSB0aGlzLmRlbiwgbjIgPSBtLmRlbiwgYyA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgdmFyIGEgPSBjLm51bSwgYiA9IG0ubnVtO1xyXG4gICAgICAgICAgICBpZihuMS5lcXVhbHMobjIpKSB7XHJcbiAgICAgICAgICAgICAgICBjLm51bSA9IGEuYWRkKGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYy5udW0gPSBhLm11bHRpcGx5KG4yKS5hZGQoYi5tdWx0aXBseShuMSkpO1xyXG4gICAgICAgICAgICAgICAgYy5kZW4gPSBuMS5tdWx0aXBseShuMik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjLnNpbXBsaWZ5KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtb2Q6IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIHZhciBhID0gdGhpcy5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBtLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vbWFrZSB0aGVpciBkZW5vbWluYXRvcnMgZXZlbiBhbmQgcmV0dXJuIHRoZSBtb2Qgb2YgdGhlaXIgbnVtZXJhdG9yc1xyXG4gICAgICAgICAgICBhLm51bSA9IGEubnVtLm11bHRpcGx5KGIuZGVuKTtcclxuICAgICAgICAgICAgYS5kZW4gPSBhLmRlbi5tdWx0aXBseShiLmRlbik7XHJcbiAgICAgICAgICAgIGIubnVtID0gYi5udW0ubXVsdGlwbHkodGhpcy5kZW4pO1xyXG4gICAgICAgICAgICBiLmRlbiA9IGIuZGVuLm11bHRpcGx5KHRoaXMuZGVuKTtcclxuICAgICAgICAgICAgYS5udW0gPSBhLm51bS5tb2QoYi5udW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zaW1wbGlmeSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2ltcGxpZnk6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGdjZCA9IGJpZ0ludC5nY2QodGhpcy5udW0sIHRoaXMuZGVuKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMubnVtID0gdGhpcy5udW0uZGl2aWRlKGdjZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGVuID0gdGhpcy5kZW4uZGl2aWRlKGdjZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG0gPSBuZXcgRnJhYygpO1xyXG4gICAgICAgICAgICBtLm51bSA9IG5ldyBiaWdJbnQodGhpcy5udW0pO1xyXG4gICAgICAgICAgICBtLmRlbiA9IG5ldyBiaWdJbnQodGhpcy5kZW4pO1xyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlY2ltYWw6IGZ1bmN0aW9uIChwcmVjKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdGhpcy5udW0uaXNOZWdhdGl2ZSgpID8gJy0nIDogJyc7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubnVtLmVxdWFscyh0aGlzLmRlbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnMSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9nbyBwbHVzIG9uZSBmb3Igcm91bmRpbmdcclxuICAgICAgICAgICAgcHJlYyA9IHByZWMgfHwgU2V0dGluZ3MuUFJFQ0lTSU9OO1xyXG4gICAgICAgICAgICBwcmVjKys7XHJcbiAgICAgICAgICAgIHZhciBuYXJyID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMubnVtLmFicygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGQgPSB0aGlzLmRlbjtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHByZWM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHcgPSBuLmRpdmlkZShkKSwgLy9kaXZpZGUgb3V0IHdob2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBuLnN1YnRyYWN0KHcubXVsdGlwbHkoZCkpOyAvL2dldCByZW1haW5kZXJcclxuXHJcbiAgICAgICAgICAgICAgICBuYXJyLnB1c2godyk7XHJcbiAgICAgICAgICAgICAgICBpZihyLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIG4gPSByLnRpbWVzKDEwKTsgLy9zaGlmdCBvbmUgZGVjIHBsYWNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHdob2xlID0gbmFyci5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZihuYXJyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB3aG9sZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihpID09PSBwcmVjKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBsYXN0IHR3byBzbyB3ZSBjYW4gcm91bmQgaXRcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAyOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgbHQudW5zaGlmdChuYXJyLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgIC8vcHV0IHRoZSBsYXN0IGRpZ2l0IGJhY2sgYnkgcm91bmRpbmcgdGhlIGxhc3QgdHdvXHJcbiAgICAgICAgICAgICAgICBuYXJyLnB1c2goTWF0aC5yb3VuZChsdC5qb2luKCcuJykpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRlYyA9IHdob2xlLnRvU3RyaW5nKCkgKyAnLicgKyBuYXJyLmpvaW4oJycpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIGRlYztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvRGVjaW1hbDogZnVuY3Rpb24gKHByZWMpIHtcclxuICAgICAgICAgICAgcHJlYyA9IHByZWMgfHwgU2V0dGluZ3MuUFJFQ0lTSU9OO1xyXG4gICAgICAgICAgICBpZihwcmVjKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNpbWFsKHByZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bSAvIHRoaXMuZGVuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcWNvbXBhcmU6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5udW0ubXVsdGlwbHkobi5kZW4pLCBuLm51bS5tdWx0aXBseSh0aGlzLmRlbildO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICBpZighaXNOYU4obikpXHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IEZyYWMobik7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5xY29tcGFyZShuKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBxWzBdLmVxdWFscyhxWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFic0VxdWFsczogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgaWYoIWlzTmFOKG4pKVxyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBGcmFjKG4pO1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucWNvbXBhcmUobik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcVswXS5hYnMoKS5lcXVhbHMocVsxXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvL2xhenkgY2hlY2sgdG8gYmUgZml4ZWQuIFN1ZmZpY2llbnQgZm9yIG5vdyBidXQgd2lsbCBjYXVzZSBmdXR1cmUgcHJvYmxlbXNcclxuICAgICAgICBncmVhdGVyVGhhbjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgaWYoIWlzTmFOKG4pKVxyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBGcmFjKG4pO1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMucWNvbXBhcmUobik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcVswXS5ndChxWzFdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGd0ZTogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JlYXRlclRoYW4obikgfHwgdGhpcy5lcXVhbHMobik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsdGU6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlc3NUaGFuKG4pIHx8IHRoaXMuZXF1YWxzKG4pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGVzc1RoYW46IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc05hTihuKSlcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgRnJhYyhuKTtcclxuICAgICAgICAgICAgdmFyIHEgPSB0aGlzLnFjb21wYXJlKG4pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHFbMF0ubHQocVsxXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0ludGVnZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVuLmVxdWFscygxKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLm51bSA9IHRoaXMubnVtLm11bHRpcGx5KC0xKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnZlcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmRlbjtcclxuICAgICAgICAgICAgLy93aHkgaW52ZXJ0IDAvMT8gSXQnbGwgYmVjb21lIDEvMCBhbmQgdGhhdCdzIGEgbGllLlxyXG4gICAgICAgICAgICBpZighdGhpcy5udW0uZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNuZWdhdGl2ZSA9IHRoaXMubnVtLmlzTmVnYXRpdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVuID0gdGhpcy5udW0uYWJzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm51bSA9IHQ7XHJcbiAgICAgICAgICAgICAgICBpZihpc25lZ2F0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubnVtID0gdGhpcy5udW0ubXVsdGlwbHkoLTEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzT25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bS5lcXVhbHMoMSkgJiYgdGhpcy5kZW4uZXF1YWxzKDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2lnbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0uaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWJzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubnVtID0gdGhpcy5udW0uYWJzKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2NkOiBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICByZXR1cm4gRnJhYy5xdWljayhiaWdJbnQuZ2NkKGYubnVtLCB0aGlzLm51bSksIGJpZ0ludC5sY20oZi5kZW4sIHRoaXMuZGVuKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZGVuLmVxdWFscygxKSA/IHRoaXMubnVtLnRvU3RyaW5nKCkgKyAnLycgKyB0aGlzLmRlbi50b1N0cmluZygpIDogdGhpcy5udW0udG9TdHJpbmcoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHtcclxuLy8gICAgICAgICAgICBpZih0aGlzLm51bSA9PSAyNCkgdGhyb3cgbmV3IEVycm9yKDk5OSlcclxuICAgICAgICAgICAgaWYoU2V0dGluZ3MuVVNFX0JJRylcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYmlnRGVjKHRoaXMubnVtLnRvU3RyaW5nKCkpLmRpdihuZXcgYmlnRGVjKHRoaXMuZGVuLnRvU3RyaW5nKCkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtIC8gdGhpcy5kZW47XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc05lZ2F0aXZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGVjaW1hbCgpIDwgMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuLy9TeW1ib2wgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8qKlxyXG4gICAgICogQWxsIHN5bWJvbHMgZS5nLiB4LCB5LCB6LCBldGMgb3IgZnVuY3Rpb25zIGFyZSB3cmFwcGVkIGluIHRoaXMgY2xhc3MuIEFsbCBzeW1ib2xzIGhhdmUgYSBtdWx0aXBsaWVyIGFuZCBhIGdyb3VwLlxyXG4gICAgICogQWxsIHN5bWJvbHMgZXhjZXB0IGZvciBcIm51bWJlcnMgKGdyb3VwIE4pXCIgaGF2ZSBhIHBvd2VyLlxyXG4gICAgICogQGNsYXNzIFByaW1hcnkgZGF0YSB0eXBlIGZvciB0aGUgUGFyc2VyLlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9ialxyXG4gICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU3ltYm9sKG9iaikge1xyXG4gICAgICAgIHZhciBpc0luZmluaXR5ID0gb2JqID09PSAnSW5maW5pdHknO1xyXG4gICAgICAgIC8vIFRoaXMgZW5hYmxlcyB0aGUgY2xhc3MgdG8gYmUgaW5zdGFudGlhdGVkIHdpdGhvdXQgdGhlIG5ldyBvcGVyYXRvclxyXG4gICAgICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2wob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29udmVydCBiaWcgbnVtYmVycyB0byBhIHN0cmluZ1xyXG4gICAgICAgIGlmKG9iaiBpbnN0YW5jZW9mIGJpZ0RlYykge1xyXG4gICAgICAgICAgICBvYmogPSBvYmoudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9kZWZpbmUgbnVtZXJpYyBzeW1ib2xzXHJcbiAgICAgICAgaWYoL14oXFwtP1xcKz9cXGQrKVxcLj9cXGQqZT9cXC0/XFwrP1xcZCovaS50ZXN0KG9iaikgfHwgb2JqIGluc3RhbmNlb2YgYmlnRGVjKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBOO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gQ09OU1RfSEFTSDtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gbmV3IEZyYWMob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9kZWZpbmUgc3ltYm9saWMgc3ltYm9sc1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdyb3VwID0gUztcclxuICAgICAgICAgICAgdmFsaWRhdGVOYW1lKG9iaik7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvYmo7XHJcbiAgICAgICAgICAgIHRoaXMubXVsdGlwbGllciA9IG5ldyBGcmFjKDEpO1xyXG4gICAgICAgICAgICB0aGlzLmltYWdpbmFyeSA9IG9iaiA9PT0gU2V0dGluZ3MuSU1BR0lOQVJZO1xyXG4gICAgICAgICAgICB0aGlzLmlzSW5maW5pdHkgPSBpc0luZmluaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9BcyBvZiA2LjAuMCB3ZSBzd2l0Y2hlZCB0byBpbmZpbml0ZSBwcmVjaXNpb24gc28gYWxsIG9iamVjdHMgaGF2ZSBhIHBvd2VyXHJcbiAgICAgICAgLy9BbHRob3VnaCB0aGlzIGlzIHN0aWxsIHJlZHVuZGFudCBpbiBjb25zdGFudHMsIGl0IHNpbXBsaWZpZXMgdGhlIGxvZ2ljIGluXHJcbiAgICAgICAgLy9vdGhlciBwYXJ0cyBzbyB3ZSdsbCBrZWVwIGl0XHJcbiAgICAgICAgdGhpcy5wb3dlciA9IG5ldyBGcmFjKDEpO1xyXG5cclxuICAgICAgICAvLyBBZGRlZCB0byBzaWxlbmNlIHRoZSBzdHJpY3Qgd2FybmluZy5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB2YW5pbGxhIGltYWdpbmFyeSBzeW1ib2xcclxuICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgKi9cclxuICAgIFN5bWJvbC5pbWFnaW5hcnkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHMgPSBuZXcgU3ltYm9sKFNldHRpbmdzLklNQUdJTkFSWSk7XHJcbiAgICAgICAgcy5pbWFnaW5hcnkgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIG5lcmRhbWVyJ3MgcmVwcmVzZW50YXRpb24gb2YgSW5maW5pdHlcclxuICAgICAqIEBwYXJhbSB7aW50fSBuZWdhdGl2ZSAtMSB0byByZXR1cm4gbmVnYXRpdmUgaW5maW5pdHlcclxuICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgKi9cclxuICAgIFN5bWJvbC5pbmZpbml0eSA9IGZ1bmN0aW9uIChuZWdhdGl2ZSkge1xyXG4gICAgICAgIHZhciB2ID0gbmV3IFN5bWJvbCgnSW5maW5pdHknKTtcclxuICAgICAgICBpZihuZWdhdGl2ZSA9PT0gLTEpXHJcbiAgICAgICAgICAgIHYubmVnYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9O1xyXG4gICAgU3ltYm9sLnNoZWxsID0gZnVuY3Rpb24gKGdyb3VwLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzeW1ib2wgPSBuZXcgU3ltYm9sKHZhbHVlKTtcclxuICAgICAgICBzeW1ib2wuZ3JvdXAgPSBncm91cDtcclxuICAgICAgICBzeW1ib2wuc3ltYm9scyA9IHt9O1xyXG4gICAgICAgIHN5bWJvbC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICB9O1xyXG4gICAgLy9zcXJ0KHgpIC0+IHheKDEvMilcclxuICAgIFN5bWJvbC51bndyYXBTUVJUID0gZnVuY3Rpb24gKHN5bWJvbCwgYWxsKSB7XHJcbiAgICAgICAgdmFyIHAgPSBzeW1ib2wucG93ZXI7XHJcbiAgICAgICAgaWYoc3ltYm9sLmZuYW1lID09PSBTUVJUICYmIChzeW1ib2wuaXNMaW5lYXIoKSB8fCBhbGwpKSB7XHJcbiAgICAgICAgICAgIHZhciB0ID0gc3ltYm9sLmFyZ3NbMF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgdC5wb3dlciA9IHQucG93ZXIubXVsdGlwbHkobmV3IEZyYWMoMSAvIDIpKTtcclxuICAgICAgICAgICAgdC5tdWx0aXBsaWVyID0gdC5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgc3ltYm9sID0gdDtcclxuICAgICAgICAgICAgaWYoYWxsKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnBvd2VyID0gcC5tdWx0aXBseShuZXcgRnJhYygxIC8gMikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgIH07XHJcbiAgICBTeW1ib2wuaHlwID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBhID0gYSB8fCBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgIGIgPSBiIHx8IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgcmV0dXJuIF8uc3FydChfLmFkZChfLnBvdyhhLmNsb25lKCksIG5ldyBTeW1ib2woMikpLCBfLnBvdyhiLmNsb25lKCksIG5ldyBTeW1ib2woMikpKSk7XHJcbiAgICB9O1xyXG4gICAgLy9jb252ZXJ0cyB0byBwb2xhciBmb3JtIGFycmF5XHJcbiAgICBTeW1ib2wudG9Qb2xhckZvcm1BcnJheSA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICB2YXIgcmUsIGltLCByLCB0aGV0YTtcclxuICAgICAgICByZSA9IHN5bWJvbC5yZWFscGFydCgpO1xyXG4gICAgICAgIGltID0gc3ltYm9sLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgciA9IFN5bWJvbC5oeXAocmUsIGltKTtcclxuICAgICAgICB0aGV0YSA9IHJlLmVxdWFscygwKSA/IF8ucGFyc2UoJ3BpLzInKSA6IF8udHJpZy5hdGFuKF8uZGl2aWRlKGltLCByZSkpO1xyXG4gICAgICAgIHJldHVybiBbciwgdGhldGFdO1xyXG4gICAgfTtcclxuICAgIC8vcmVtb3ZlcyBwYXJlbnRoZXNlc1xyXG4gICAgU3ltYm9sLnVud3JhcFBBUkVOUyA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICBpZihzeW1ib2wuZm5hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgIHIucG93ZXIgPSByLnBvd2VyLm11bHRpcGx5KHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgICAgIHIubXVsdGlwbGllciA9IHIubXVsdGlwbGllci5tdWx0aXBseShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5mbmFtZSA9PT0gJycpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sLnVud3JhcFBBUkVOUyhyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICB9O1xyXG4gICAgLy9xdWlja2x5IGNyZWF0ZXMgYSBTeW1ib2xcclxuICAgIFN5bWJvbC5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHBvd2VyKSB7XHJcbiAgICAgICAgcG93ZXIgPSBwb3dlciA9PT0gdW5kZWZpbmVkID8gMSA6IHBvd2VyO1xyXG4gICAgICAgIHJldHVybiBfLnBhcnNlKCcoJyArIHZhbHVlICsgJyleKCcgKyBwb3dlciArICcpJyk7XHJcbiAgICB9O1xyXG4gICAgU3ltYm9sLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG50aCByb290IGFjY291bnRpbmcgZm9yIHJvdW5kaW5nIGVycm9yc1xyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuXHJcbiAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE50aDogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgLy8gRmlyc3QgY2FsY3VsYXRlIHRoZSByb290XHJcbiAgICAgICAgICAgIHZhciByb290ID0gZXZhbHVhdGUoXy5wb3coXy5wYXJzZSh0aGlzLm11bHRpcGxpZXIpLCBfLnBhcnNlKG4pLmludmVydCgpKSk7XHJcbiAgICAgICAgICAgIC8vIFJvdW5kIG9mIGFueSBlcnJvcnNcclxuICAgICAgICAgICAgdmFyIHJvdW5kZWQgPSBfLnBhcnNlKG5yb3VuZChyb290KSk7XHJcbiAgICAgICAgICAgIC8vIFJldmVyc2UgdGhlIHJvb3RcclxuICAgICAgICAgICAgdmFyIGUgPSBldmFsdWF0ZShfLnBvdyhyb3VuZGVkLCBfLnBhcnNlKG4pKSk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSByb3VuZGVkIHJvb3QgZXF1YWxzIHRoZSBvcmlnaW5hbCBudW1iZXIgdGhlbiB3ZSdyZSBnb29kIFxyXG4gICAgICAgICAgICBpZihlLmVxdWFscyhfLnBhcnNlKHRoaXMubXVsdGlwbGllcikpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91bmRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSB1bnJvdW5kZWQgdmVyc2lvblxyXG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiBzeW1ib2wgaXMgdG8gdGhlIG50aCBwb3dlclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzVG9OdGg6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IGJ5IGNoZWNrIGluIHRoZSBtdWx0aXBsaWVyIGZvciBzcXVhcmVuZXNzXHJcbiAgICAgICAgICAgIC8vIEZpcnN0IGdldCB0aGUgcm9vdCBidXQgcm91bmQgaXQgYmVjYXVzZSBjdXJyZW50bHkgd2Ugc3RpbGwgZGVwZW5kIFxyXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0TnRoKG4pO1xyXG4gICAgICAgICAgICB2YXIgbnRoTXVsdGlwbGllciA9IGlzSW50KHJvb3QpO1xyXG4gICAgICAgICAgICB2YXIgbnRoUG93ZXI7XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgYnkgYXNzdW1pbmcgdGhhdCBhbGwgd2lsbCBiZSBzcXVhcmUuXHJcbiAgICAgICAgICAgICAgICBudGhQb3dlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgaXQgdGFrZXMgaXMgZm9yIG9uZSBvZiB0aGUgc3ltYm9scyB0byBub3QgaGF2ZSBhbiBldmVuIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAvLyBlLmcuIHhebjEqeV5uMiByZXF1aXJlcyB0aGF0IGJvdGggbjEgYW5kIG4yIGFyZSBldmVuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNOdGggPSB4LmlzVG9OdGgobik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFpc050aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudGhQb3dlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBvd2VyIGlzIGRpdmlzaWJsZSBieSBuIGlmIGl0J3Mgbm90IGEgbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgbnRoUG93ZXIgPSB0aGlzLmdyb3VwID09PSBOID8gdHJ1ZSA6IGlzSW50KF8uZGl2aWRlKF8ucGFyc2UodGhpcy5wb3dlciksIF8ucGFyc2UobikpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG50aE11bHRpcGxpZXIgJiYgbnRoUG93ZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgYSBzeW1ib2wgaXMgc3F1YXJlXHJcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpc1NxdWFyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1RvTnRoKDIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIGEgc3ltYm9sIGlzIGN1YmVcclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzQ3ViZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1RvTnRoKDMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIGEgc3ltYm9sIGlzIGEgYmFyZSB2YXJpYWJsZVxyXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNTaW1wbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG93ZXIuZXF1YWxzKDEpICYmIHRoaXMubXVsdGlwbGllci5lcXVhbHMoMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaW1wbGlmaWVzIHRoZSBwb3dlciBvZiB0aGUgc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH0gYSBjbG9uZSBvZiB0aGUgc3ltYm9sXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcG93U2ltcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvd2VycyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gdGhpcy5tdWx0aXBsaWVyLnNpZ24oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0geC5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAvL3doeSB3YXN0ZSB0aW1lIGlmIEkgY2FuJ3QgZG8gYW55dGhpbmcgYW55d2F5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNTeW1ib2wocCkgfHwgcC5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG93ZXJzLnB1c2gocCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBuZXcgRnJhYyhhcnJheU1pbihwb3dlcnMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2hhbmRsZSB0aGUgY29lZmZpY2llbnRcclxuICAgICAgICAgICAgICAgIC8vaGFuZGxlIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHRoaXMubXVsdGlwbGllci5zaWduKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSB0aGlzLm11bHRpcGxpZXIuY2xvbmUoKS5hYnMoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWZhY3RvcnMgPSBNYXRoMi5pZmFjdG9yKG0pO1xyXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBoYXZlIGEgbXVsdGlwbGllciBvZiA2NzUwIGFuZCBhIG1pbiBvZiAyIHRoZW4gdGhlIGZhY3RvcnMgYXJlIDVeMyo1XjMqMlxyXG4gICAgICAgICAgICAgICAgLy93ZSBjYW4gdGhlbiByZWR1Y2UgaXQgdG8gMiozKjUqKDE1KV4yXHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0XyA9IG5ldyBGcmFjKDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluXyA9IG5ldyBGcmFjKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBtZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IEZyYWMobWZhY3RvcnNbeF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFuLmxlc3NUaGFuKG1pbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG4uZGl2aWRlKG1pbikuc3VidHJhY3QobmV3IEZyYWMoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbl8gPSBpbl8ubXVsdGlwbHkobmV3IEZyYWMoeCkpOyAvL21vdmUgdGhlIGZhY3RvciBpbnNpZGUgdGhlIGJyYWNrZXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG91dF8gPSBvdXRfLm11bHRpcGx5KF8ucGFyc2UoaW5CcmFja2V0cyh4KSArICdeJyArIGluQnJhY2tldHMobikpLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgU3ltYm9sKGluXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0geC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucG93ZXIgPSB4LnBvd2VyLmRpdmlkZShtaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBfLm11bHRpcGx5KHQsIHgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHh0ID0gXy5zeW1mdW5jdGlvbihQQVJFTlRIRVNJUywgW3RdKTtcclxuICAgICAgICAgICAgICAgIHh0LnBvd2VyID0gbWluO1xyXG4gICAgICAgICAgICAgICAgeHQubXVsdGlwbGllciA9IHNpZ24gPCAwID8gb3V0Xy5uZWdhdGUoKSA6IG91dF87XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHR3byBmdW5jdGlvbnMgYXJlIG9mIGVxdWFsIHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGVxdWFsczogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2woc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woc3ltYm9sKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHN5bWJvbC52YWx1ZSAmJiB0aGlzLnBvd2VyLmVxdWFscyhzeW1ib2wucG93ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5tdWx0aXBsaWVyLmVxdWFscyhzeW1ib2wubXVsdGlwbGllcilcclxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmdyb3VwID09PSBzeW1ib2wuZ3JvdXA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhYnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGUubXVsdGlwbGllci5hYnMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBHcmVhdGVyIHRoYW5cclxuICAgICAgICBndDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2woc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woc3ltYm9sKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNDb25zdGFudCgpICYmIHN5bWJvbC5pc0NvbnN0YW50KCkgJiYgdGhpcy5tdWx0aXBsaWVyLmdyZWF0ZXJUaGFuKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIEdyZWF0ZXIgdGhhblxyXG4gICAgICAgIGd0ZTogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2woc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woc3ltYm9sKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKHN5bWJvbCkgfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29uc3RhbnQoKSAmJiBzeW1ib2wuaXNDb25zdGFudCgpICYmIHRoaXMubXVsdGlwbGllci5ncmVhdGVyVGhhbihzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBMZXNzIHRoYW5cclxuICAgICAgICBsdDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2woc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woc3ltYm9sKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNDb25zdGFudCgpICYmIHN5bWJvbC5pc0NvbnN0YW50KCkgJiYgdGhpcy5tdWx0aXBsaWVyLmxlc3NUaGFuKHN5bWJvbC5tdWx0aXBsaWVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIExlc3MgdGhhblxyXG4gICAgICAgIGx0ZTogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2woc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG5ldyBTeW1ib2woc3ltYm9sKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKHN5bWJvbCkgfHxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQ29uc3RhbnQoKSAmJiBzeW1ib2wuaXNDb25zdGFudCgpICYmIHRoaXMubXVsdGlwbGllci5sZXNzVGhhbihzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCZWNhdXNlIG5lcmRhbWVyIGRvZXNuJ3QgZ3JvdXAgc3ltYm9scyBieSBwb2x5bm9taWFscyBidXRcclxuICAgICAgICAgKiByYXRoZXIgYSBjdXN0b20gZ3JvdXBpbmcgbWV0aG9kLCB0aGlzIGhhcyB0byBiZVxyXG4gICAgICAgICAqIHJlaW5zZXJ0ZWQgaW4gb3JkZXIgdG8gbWFrZSB1c2Ugb2YgbW9zdCBhbGdvcml0aG1zLiBUaGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgICogY2hlY2tzIGlmIHRoZSBzeW1ib2wgbWVldHMgdGhlIGNyaXRlcmlhIG9mIGEgcG9seW5vbWlhbC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IG11bHRpdmFyaWF0ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzUG9seTogZnVuY3Rpb24gKG11bHRpdmFyaWF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMucG93ZXI7XHJcbiAgICAgICAgICAgIC8vdGhlIHBvd2VyIG11c3QgYmUgYSBpbnRlZ2VyIHNvIGZhaWwgaWYgaXQncyBub3RcclxuICAgICAgICAgICAgaWYoIWlzSW50KHApIHx8IHAgPCAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAvL2NvbnN0YW50cyBhbmQgZmlyc3Qgb3JkZXJzXHJcbiAgICAgICAgICAgIGlmKGcgPT09IE4gfHwgZyA9PT0gUyB8fCB0aGlzLmlzQ29uc3RhbnQodHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIHZhcnMgPSB2YXJpYWJsZXModGhpcyk7XHJcbiAgICAgICAgICAgIGlmKGcgPT09IENCICYmIHZhcnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RoZSB2YXJpYWJsZSBpcyBhc3N1bWVkIHRoZSBvbmx5IG9uZSB0aGF0IHdhcyBmb3VuZFxyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSB2YXJzWzBdO1xyXG4gICAgICAgICAgICAgICAgLy9pZiBubyB2YXJpYWJsZSB0aGVuIGd1ZXNzIHdoYXQhPyE/IFdlJ3JlIGRvbmUhISEgV2UgaGF2ZSBhIHBvbHlub21pYWwuXHJcbiAgICAgICAgICAgICAgICBpZighdilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gdGhpcy5zeW1ib2xzW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc3FydCh4KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bS5ncm91cCA9PT0gRk4gJiYgIXN5bS5hcmdzWzBdLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzeW0uY29udGFpbnModikgJiYgIXN5bS5pc0NvbnN0YW50KHRydWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1BMIGdyb3Vwcy4gVGhlc2Ugb25seSBmYWlsIGlmIGEgcG93ZXIgaXMgbm90IGFuIGludFxyXG4gICAgICAgICAgICAvL3RoaXMgc2hvdWxkIGhhbmRsZSBjYXNlcyBzdWNoIGFzIHheMip0XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaXNDb21wb3NpdGUoKSB8fCBnID09PSBDQiAmJiBtdWx0aXZhcmlhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8vZmFpbCBpZiB3ZSdyZSBub3QgY2hlY2tpbmcgZm9yIG11bHRpdmFyaWF0ZSBwb2x5bm9taWFsc1xyXG4gICAgICAgICAgICAgICAgaWYoIW11bHRpdmFyaWF0ZSAmJiB2YXJzLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy9sb29wIHRob3VnaCB0aGUgc3ltYm9scyBhbmQgY2hlY2sgaWYgdGhleSBxdWFsaWZ5XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy93ZSd2ZSBhbHJlYWR5IHRoZSBzeW1ib2xzIGlmIHdlJ3JlIG5vdCBjaGVja2luZyBmb3IgbXVsdGl2YXJpYXRlcyBhdCB0aGlzIHBvaW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zbyB3ZSBjaGVjayB0aGUgc3ViLXN5bWJvbHNcclxuICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5zeW1ib2xzW3hdLmlzUG9seShtdWx0aXZhcmlhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgLy9hbGwgdGVzdHMgbXVzdCBoYXZlIHBhc3NlZCBzbyB3ZSBtdXN0IGJlIGRlYWxpbmcgd2l0aCBhIHBvbHlub21pYWxcclxuICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vcmVtb3ZlcyB0aGUgcmVxdWVzdGVkIHZhcmlhYmxlIGZyb20gdGhlIHN5bWJvbCBhbmQgcmV0dXJucyB0aGUgcmVtYWluZGVyXHJcbiAgICAgICAgc3RyaXBWYXI6IGZ1bmN0aW9uICh4LCBleGNsdWRlX3gpIHtcclxuICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgaWYoKHRoaXMuZ3JvdXAgPT09IFBMIHx8IHRoaXMuZ3JvdXAgPT09IFMpICYmIHRoaXMudmFsdWUgPT09IHgpXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKGV4Y2x1ZGVfeCA/IDAgOiB0aGlzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuZ3JvdXAgPT09IENCICYmIHRoaXMuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFzLmNvbnRhaW5zKHgsIHRydWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgcy5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsLm11bHRpcGxpZXIgPSByZXR2YWwubXVsdGlwbGllci5tdWx0aXBseSh0aGlzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5ncm91cCA9PT0gQ1AgJiYgIXRoaXMuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCh0aGlzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5ncm91cCA9PT0gQ1AgJiYgdGhpcy5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXMuY29udGFpbnMoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBzLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQubXVsdGlwbGllciA9IHQubXVsdGlwbGllci5tdWx0aXBseSh0aGlzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChyZXR2YWwsIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy9CSUcgVE9ETyEhISBJdCBkb2Vzbid0IG1ha2UgbXVjaCBzZW5zZVxyXG4gICAgICAgICAgICAgICAgaWYocmV0dmFsLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmdyb3VwID09PSBFWCAmJiB0aGlzLnBvd2VyLmNvbnRhaW5zKHgsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmdyb3VwID09PSBGTiAmJiB0aGlzLmNvbnRhaW5zKHgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgLy93dGg/IFRoaXMgc2hvdWxkIHRlY2huaWNhbGx5IGJlIHRoZSBtdWx0aXBsaWVyLlxyXG4gICAgICAgICAgICAgICAgLy9VbmZvcnR1bmF0ZWx5IHRoaXMgbWV0aG9kIHdhc24ndCB2ZXJ5IHdlbGwgdGhvdWdodCBvdXQgOmAoLlxyXG4gICAgICAgICAgICAgICAgLy9zaG91bGQgYmU6IHJldHZhbCA9IG5ldyBTeW1ib2wodGhpcy5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgIC8vdXNlOiAoKDEreF4yKSpzcXJ0KC0xK3heMikpXigtMSkgZm9yIGNvcnJlY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAvL3RoaXMgd2lsbCBicmVhayBhIGJ1bmNoIG9mIHVuaXQgdGVzdHMgc28gYmUgcmVhZHkgdG8gZm9yIHRoZSBsb25nIGhhdWxcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IHRoaXMuY2xvbmUoKTtcclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9yZXR1cm5zIHN5bWJvbCBpbiBhcnJheSBmb3JtIHdpdGggeCBhcyBiYXNlIGUuZy4gYSp4XjIrYip4K2MgPSBbYywgYiwgYV0uXHJcbiAgICAgICAgdG9BcnJheTogZnVuY3Rpb24gKHYsIGFycikge1xyXG4gICAgICAgICAgICBhcnIgPSBhcnIgfHwge1xyXG4gICAgICAgICAgICAgICAgYXJyOiBbXSxcclxuICAgICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKHgsIGlkeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5hcnJbaWR4XTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFycltpZHhdID0gZSA/IF8uYWRkKGUsIHgpIDogeDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmdyb3VwO1xyXG5cclxuICAgICAgICAgICAgaWYoZyA9PT0gUyAmJiB0aGlzLmNvbnRhaW5zKHYpKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIuYWRkKG5ldyBTeW1ib2wodGhpcy5tdWx0aXBsaWVyKSwgdGhpcy5wb3dlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihnID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLnN0cmlwVmFyKHYpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gXy5kaXZpZGUodGhpcy5jbG9uZSgpLCBhLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSB4LmlzQ29uc3RhbnQoKSA/IDAgOiB4LnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgYXJyLmFkZChhLCBwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IFBMICYmIHRoaXMudmFsdWUgPT09IHYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCwgcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyci5hZGQoeC5zdHJpcFZhcih2KSwgcCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IENQKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RoZSBsb2dpYzogdGhleSdsbCBiZSBicm9rZW4gaW50byBzeW1ib2xzIHNvIGUuZy4gKHheMit4KSsxIG9yIChhKnheMitiKngrYylcclxuICAgICAgICAgICAgICAgIC8vZWFjaCBjYXNlIGlzIGhhbmRsZWQgYWJvdmVcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgudG9BcnJheSh2LCBhcnIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmNvbnRhaW5zKHYpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTmVyZGFtZXJUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHRvIGFycmF5ISBFeGl0aW5nJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcnIuYWRkKHRoaXMuY2xvbmUoKSwgMCk7IC8vaXQncyBqdXN0IGEgY29uc3RhbnQgd3J0IHRvIHZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2ZpbGwgdGhlIGhvbGVzXHJcbiAgICAgICAgICAgIGFyciA9IGFyci5hcnI7IC8va2VlcCBvbmx5IHRoZSBhcnJheSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRoZSBvYmplY3QgYW55bW9yZVxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYoIWFycltpXSlcclxuICAgICAgICAgICAgICAgICAgICBhcnJbaV0gPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy9jaGVja3MgdG8gc2VlIGlmIGEgc3ltYm9sIGNvbnRhbnMgYSBmdW5jdGlvblxyXG4gICAgICAgIGhhc0Z1bmM6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHZhciBmbl9ncm91cCA9IHRoaXMuZ3JvdXAgPT09IEZOIHx8IHRoaXMuZ3JvdXAgPT09IEVYO1xyXG4gICAgICAgICAgICBpZihmbl9ncm91cCAmJiAhdiB8fCBmbl9ncm91cCAmJiB0aGlzLmNvbnRhaW5zKHYpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sc1t4XS5oYXNGdW5jKHYpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWI6IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIGEgPSAhaXNTeW1ib2woYSkgPyBfLnBhcnNlKGEpIDogYS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBiID0gIWlzU3ltYm9sKGIpID8gXy5wYXJzZShiKSA6IGIuY2xvbmUoKTtcclxuICAgICAgICAgICAgaWYoYS5ncm91cCA9PT0gTiB8fCBhLmdyb3VwID09PSBQKVxyXG4gICAgICAgICAgICAgICAgZXJyKCdDYW5ub3Qgc3Vic3RpdHV0ZSBhIG51bWJlci4gTXVzdCBiZSBhIHZhcmlhYmxlJyk7XHJcbiAgICAgICAgICAgIHZhciBzYW1lX3BvdyA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFfaXNfdW5pdF9tdWx0aXBsaWVyID0gYS5tdWx0aXBsaWVyLmVxdWFscygxKSxcclxuICAgICAgICAgICAgICAgICAgICBtID0gdGhpcy5tdWx0aXBsaWVyLmNsb25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBtYWtlIHRoZSBzdWJzdGl0dXRpb24gdGhlIGJhc2VzIGhhdmUgdG8gZmlyc3QgbWF0Y2ggdGFrZVxyXG4gICAgICAgICAgICAgKiAoeCsxKV54IC0+ICh4KzEpPXkgfHwgeF4yIC0+IHg9eV42XHJcbiAgICAgICAgICAgICAqIEluIGJvdGggY2FzZXMgdGhlIGZpcnN0IGNvbmRpdGlvbiBpcyB0aGF0IHRoZSBiYXNlcyBtYXRjaCBzbyB3ZSBiZWdpbiB0aGVyZVxyXG4gICAgICAgICAgICAgKiBFaXRoZXIgYm90aCBhcmUgUEwgb3IgYm90aCBhcmUgbm90IFBMIGJ1dCB3ZSBjYW5ub3QgaGF2ZSBQTCBhbmQgYSBub24tUEwgZ3JvdXAgbWF0Y2hcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmKHRoaXMudmFsdWUgPT09IGEudmFsdWUgJiYgKHRoaXMuZ3JvdXAgIT09IFBMICYmIGEuZ3JvdXAgIT09IFBMIHx8IHRoaXMuZ3JvdXAgPT09IFBMICYmIGEuZ3JvdXAgPT09IFBMKSkge1xyXG4gICAgICAgICAgICAgICAgLy93ZSBjbGVhcmVkIHRoZSBmaXJzdCBodXJkbGUgYnV0IGEgc3Vic2l0dXRpb24gbWF5IG5vdCBiZSBwb3NzaWJsZSBqdXN0IHlldFxyXG4gICAgICAgICAgICAgICAgaWYoYV9pc191bml0X211bHRpcGxpZXIgfHwgYS5tdWx0aXBsaWVyLmVxdWFscyh0aGlzLm11bHRpcGxpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYS5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYS5wb3dlci5lcXVhbHModGhpcy5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtZV9wb3cgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihhLm11bHRpcGxpZXIuZXF1YWxzKHRoaXMubXVsdGlwbGllcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBuZXcgRnJhYygxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3RoZSBuZXh0IHRoaW5nIGlzIHRvIGhhbmRsZSBDQlxyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuZ3JvdXAgPT09IENCIHx8IHRoaXMucHJldmlvdXNHcm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViYmVkID0gXy5wYXJzZSh4LnN1YihhLCBiKSk7IC8vcGFyc2UgaXQgYWdhaW4gZm9yIHNhZmV0eVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBzdWJiZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gdGhpcy5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGEuaXNDb21wb3NpdGUoKSAmJiBzeW1ib2wuaXNDb21wb3NpdGUoKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSAmJiBhLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluZCA9IGZ1bmN0aW9uIChzdGFjaywgbmVlZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBzdGFjay5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gc3RhY2suc3ltYm9sc1t4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIHN5bWJvbCBlcXVhbHMgdGhlIG5lZWRsZSBvciBpdCdzIHdpdGhpbiB0aGUgc3ViLXN5bWJvbHMgd2UncmUgZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltLmlzQ29tcG9zaXRlKCkgJiYgZmluZChzeW0sIG5lZWRsZSkgfHwgc3ltLmVxdWFscyhuZWVkbGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ28gZmlzaFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBhLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWZpbmQoc3ltYm9sLCBhLnN5bWJvbHNbeF0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmFkZChfLnN1YnRyYWN0KHN5bWJvbC5jbG9uZSgpLCBhKSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uYWRkKHJldHZhbCwgeC5zdWIoYSwgYikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5ncm91cCA9PT0gRVgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJzZWQgdmFsdWUgY291bGQgYmUgYSBmdW5jdGlvbiBzbyBwYXJzZSBhbmQgc3ViXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKHRoaXMudmFsdWUpLnN1YihhLCBiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMuZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gdGhpcy5hcmdzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFpc1N5bWJvbChhcmcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBfLnBhcnNlKGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFyZ3MucHVzaChhcmcuc3ViKGEsIGIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24odGhpcy5mbmFtZSwgbmFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgd2UgZGlkIG1hbmFnZSBhIHN1YnN0aXR1dGlvblxyXG4gICAgICAgICAgICBpZihyZXR2YWwpIHtcclxuICAgICAgICAgICAgICAgIGlmKCFzYW1lX3Bvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc3Vic3RpdHV0ZSB0aGUgcG93ZXJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ3JvdXAgPT09IEVYID8gdGhpcy5wb3dlci5zdWIoYSwgYikgOiBfLnBhcnNlKHRoaXMucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbm93IHJhaXNlIHRoZSBzeW1ib2wgdG8gdGhhdCBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucG93KHJldHZhbCwgcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy90cmFuc2ZlciB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgcmV0dmFsLm11bHRpcGxpZXIgPSByZXR2YWwubXVsdGlwbGllci5tdWx0aXBseShtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RvbmVcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiBhbGwgZWxzZSBmYWlsc1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNNb25vbWlhbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBTKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sc1t4XS5ncm91cCAhPT0gUylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1BpOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyb3VwID09PSBTICYmIHRoaXMudmFsdWUgPT09ICdwaSc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaWduOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGxpZXIuc2lnbigpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNFOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSAnZSc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1NRUlQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm5hbWUgPT09IFNRUlQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0NvbnN0YW50OiBmdW5jdGlvbiAoY2hlY2tfYWxsLCBjaGVja19zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgIGlmKGNoZWNrX3N5bWJvbHMgJiYgdGhpcy5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnN5bWJvbHNbeF0uaXNDb25zdGFudCh0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGNoZWNrX2FsbCA9PT0gJ2Z1bmN0aW9ucycgJiYgdGhpcy5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNDb25zdGFudCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXguaXNDb25zdGFudChjaGVja19hbGwsIGNoZWNrX3N5bWJvbHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29uc3RhbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDb25zdGFudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoY2hlY2tfYWxsID09PSAnYWxsJyAmJiAodGhpcy5pc1BpKCkgfHwgdGhpcy5pc0UoKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihjaGVja19hbGwgJiYgdGhpcy5ncm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5hcmdzW2ldLmlzQ29uc3RhbnQoY2hlY2tfYWxsKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGNoZWNrX2FsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc051bWVyaWNTeW1ib2wodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBDT05TVF9IQVNIO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy90aGUgc3ltYm9scyBpcyBpbWFnaW5hcnkgaWZcclxuICAgICAgICAvLzEuIG4qaVxyXG4gICAgICAgIC8vMi4gYStiKmlcclxuICAgICAgICAvLzMuIGEqaVxyXG4gICAgICAgIGlzSW1hZ2luYXJ5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaW1hZ2luYXJ5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sc1t4XS5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSByZWFsIHBhcnQgb2YgYSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlYWxwYXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5pbWFnaW5hcnkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgZWxzZSBpZih0aGlzLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCB4LnJlYWxwYXJ0KCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBpbWFnaW5hcnkgcGFydCBvZiBhIHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW1hZ3BhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gUyAmJiB0aGlzLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCh0aGlzLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCB4LmltYWdwYXJ0KCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IENCKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaXBWYXIoU2V0dGluZ3MuSU1BR0lOQVJZKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0ludGVnZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNDb25zdGFudCgpICYmIHRoaXMubXVsdGlwbGllci5pc0ludGVnZXIoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzTGluZWFyOiBmdW5jdGlvbiAod3J0KSB7XHJcbiAgICAgICAgICAgIGlmKHdydCkge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy52YWx1ZSA9PT0gd3J0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3dlci5lcXVhbHMoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzQ29tcG9zaXRlKCkgJiYgdGhpcy5wb3dlci5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLnN5bWJvbHNbeF0uaXNMaW5lYXIod3J0KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gQ0IgJiYgdGhpcy5zeW1ib2xzW3dydF0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sc1t3cnRdLmlzTGluZWFyKHdydCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucG93ZXIuZXF1YWxzKDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhIHN5bWJvbCBoYXMgYSBmdW5jdGlvbiBieSBhIHNwZWNpZmllZCBuYW1lIG9yIHdpdGhpbiBhIHNwZWNpZmllZCBsaXN0XHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IG5hbWVzXHJcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29udGFpbnNGdW5jdGlvbjogZnVuY3Rpb24gKG5hbWVzKSB7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBuYW1lcyA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICBuYW1lcyA9IFtuYW1lc107XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IEZOICYmIG5hbWVzLmluZGV4T2YodGhpcy5mbmFtZSkgIT09IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9sc1t4XS5jb250YWluc0Z1bmN0aW9uKG5hbWVzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbXVsdGlwbHlQb3dlcjogZnVuY3Rpb24gKHAyKSB7XHJcbiAgICAgICAgICAgIC8vbGVhdmUgb3V0IDFcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTiAmJiB0aGlzLm11bHRpcGxpZXIuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICB2YXIgcDEgPSB0aGlzLnBvd2VyO1xyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCAhPT0gRVggJiYgcDIuZ3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gcDIubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IE4gJiYgIXAuaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnQoUCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3dlciA9IHAxLmVxdWFscygxKSA/IHAuY2xvbmUoKSA6IHAxLm11bHRpcGx5KHApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IFAgJiYgaXNJbnQodGhpcy5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL2JyaW5nIGl0IGJhY2sgdG8gYW4gTlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLnBvdyh0aGlzLnZhbHVlLCB0aGlzLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0KE4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCAhPT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwMSA9IG5ldyBTeW1ib2wocDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmVydChFWCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvd2VyID0gXy5tdWx0aXBseShwMSwgcDIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldFBvd2VyOiBmdW5jdGlvbiAocCwgcmV0YWluU2lnbikge1xyXG4gICAgICAgICAgICAvL2xlYXZlIG91dCAxXHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IE4gJiYgdGhpcy5tdWx0aXBsaWVyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gRVggJiYgIWlzU3ltYm9sKHApKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwID0gdGhpcy5wcmV2aW91c0dyb3VwO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJldmlvdXNHcm91cDtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBuZXcgRnJhYyh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gQ09OU1RfSEFTSDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvd2VyID0gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc1N5bWJvbGljID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZihpc1N5bWJvbChwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHAuZ3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wIHNob3VsZCBiZSB0aGUgbXVsdGlwbGllciBpbnN0ZWFkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm11bHRpcGxpZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTeW1ib2xpYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gaXNTeW1ib2xpYyA/IEVYIDogUDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG93ZXIgPSBwO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTiAmJiBncm91cClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnQoZ3JvdXAsIHJldGFpblNpZ24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0byBzZWUgaWYgc3ltYm9sIGlzIGxvY2F0ZWQgaW4gdGhlIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaXNJbnZlcnNlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IEVYKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnBvd2VyLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3dlciA8IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYWtlIGEgZHVwbGljYXRlIG9mIGEgc3ltYm9sIGJ5IGNvcHlpbmcgYSBwcmVkZWZpbmVkIGxpc3Qgb2YgaXRlbXMuXHJcbiAgICAgICAgICogVGhlIG5hbWUgJ2NvcHknIHdvdWxkIHByb2JhYmx5IGJlIGEgbW9yZSBhcHByb3ByaWF0ZSBuYW1lLlxyXG4gICAgICAgICAqIHRvIGEgbmV3IHN5bWJvbFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBjXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgdmFyIGNsb25lID0gYyB8fCBuZXcgU3ltYm9sKDApLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vbGlzdCBvZiBwcm9wZXJ0aWVzIGV4Y2x1ZGluZyBwb3dlciBhcyB0aGlzIG1heSBiZSBhIHN5bWJvbCBhbmQgd291bGQgYWxzbyBuZWVkIHRvIGJlIGEgY2xvbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJywgJ2dyb3VwJywgJ2xlbmd0aCcsICdwcmV2aW91c0dyb3VwJywgJ2ltYWdpbmFyeScsICdmbmFtZScsICdhcmdzJywgJ2lzSW5maW5pdHknLCAnc2NpZW50aWZpYyddLFxyXG4gICAgICAgICAgICAgICAgICAgIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aCwgaTtcclxuICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5zeW1ib2xzID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUuc3ltYm9sc1t4XSA9IHRoaXMuc3ltYm9sc1t4XS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXNbcHJvcGVydGllc1tpXV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lW3Byb3BlcnRpZXNbaV1dID0gdGhpc1twcm9wZXJ0aWVzW2ldXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY2xvbmUucG93ZXIgPSB0aGlzLnBvd2VyLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGNsb25lLm11bHRpcGxpZXIgPSB0aGlzLm11bHRpcGxpZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy9hZGQgYmFjayB0aGUgZmxhZyB0byB0cmFjayBpZiB0aGlzIHN5bWJvbCBpcyBhIGNvbnZlcnNpb24gc3ltYm9sXHJcbiAgICAgICAgICAgIGlmKHRoaXMuaXNDb252ZXJzaW9uKVxyXG4gICAgICAgICAgICAgICAgY2xvbmUuaXNDb252ZXJzaW9uID0gdGhpcy5pc0NvbnZlcnNpb247XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmlzVW5pdClcclxuICAgICAgICAgICAgICAgIGNsb25lLmlzVW5pdCA9IHRoaXMuaXNVbml0O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSBzeW1ib2wgbXVsdGlwbGllciB0byBvbmUuXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBrZWVwU2lnbiBLZWVwIHRoZSBtdWx0aXBsaWVyIGFzIG5lZ2F0aXZlIGlmIHRoZSBtdWx0aXBsaWVyIGlzIG5lZ2F0aXZlIGFuZCBrZWVwU2lnbiBpcyB0cnVlXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0b1VuaXRNdWx0aXBsaWVyOiBmdW5jdGlvbiAoa2VlcFNpZ24pIHtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyLm51bSA9IG5ldyBiaWdJbnQodGhpcy5tdWx0aXBsaWVyLm51bS5pc05lZ2F0aXZlKCkgJiYga2VlcFNpZ24gPyAtMSA6IDEpO1xyXG4gICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIuZGVuID0gbmV3IGJpZ0ludCgxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIFN5bWJvbCdzIHBvd2VyIHRvIG9uZS5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgaXQncyBhbHJlYWR5IGxpbmVhclxyXG4gICAgICAgICAgICBpZih0aGlzLnBvd2VyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRQb3dlcihuZXcgRnJhYygxKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgdGhlIHN1Yi1zeW1ib2xzLiBJZiBubyBzdWItc3ltYm9scyBleGlzdCB0aGVuIGl0J3MgY2FsbGVkIG9uIGl0c2VsZlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAgICAgICAgICogQEBwYXJhbSB7Qm9vbGVhbn0gZGVlcCBJZiB0cnVlIGl0IHdpbGwgaXR0ZXJhdGUgb3ZlciB0aGUgc3ViLXN5bWJvbHMgdGhlaXIgc3ltYm9scyBhcyB3ZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKGZuLCBkZWVwKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgIGZuLmNhbGwodGhpcywgdGhpcywgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IHRoaXMuc3ltYm9sc1t4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW0uZ3JvdXAgPT09IFBMICYmIGRlZXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB5IGluIHN5bS5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHgsIHN5bS5zeW1ib2xzW3ldLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuLmNhbGwodGhpcywgc3ltLCB4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBudW1lcmljIHZhbHVlIHRvIGJlIHJldHVybmVkIGZvciBKYXZhc2NyaXB0LiBJdCB3aWxsIHRyeSB0b1xyXG4gICAgICAgICAqIHJldHVybiBhIG51bWJlciBhcyBmYXIgYSBwb3NzaWJsZSBidXQgaW4gY2FzZSBvZiBhIHB1cmUgc3ltYm9saWNcclxuICAgICAgICAgKiBzeW1ib2wgaXQgd2lsbCBqdXN0IHJldHVybiBpdHMgdGV4dCByZXByZXNlbnRhdGlvblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd8TnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gTilcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGxpZXIudmFsdWVPZigpO1xyXG4gICAgICAgICAgICBlbHNlIGlmKHRoaXMucG93ZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5tdWx0aXBsaWVyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0KHRoaXMsICdkZWNpbWFscycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgc3ltYm9scyBoYXMgYSBwYXJ0aWN1bGFyIHZhcmlhYmxlIHdpdGhpbiBpdC5cclxuICAgICAgICAgKiBQYXNzIGluIHRydWUgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIGluY2x1ZGUgdGhlIHBvd2VyIG9mIGV4cG9uZW50aWFsc1xyXG4gICAgICAgICAqIHdoaWNoIGFyZW4ndCBjaGVjayBieSBkZWZhdWx0LlxyXG4gICAgICAgICAqIEBleGFtcGxlIHZhciBzID0gXy5wYXJzZSgneCt5K3onKTsgcy5jb250YWlucygneScpO1xyXG4gICAgICAgICAqIC8vcmV0dXJucyB0cnVlXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IHZhcmlhYmxlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBhbGxcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjb250YWluczogZnVuY3Rpb24gKHZhcmlhYmxlLCBhbGwpIHtcclxuICAgICAgICAgICAgLy9jb250YWlucyBleHBlY3RzIGEgc3RyaW5nXHJcbiAgICAgICAgICAgIHZhcmlhYmxlID0gU3RyaW5nKHZhcmlhYmxlKTtcclxuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgICAgICBpZih0aGlzLnZhbHVlID09PSB2YXJpYWJsZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBpZih0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiB0aGlzLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnN5bWJvbHNbeF0uY29udGFpbnModmFyaWFibGUsIGFsbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGcgPT09IEZOIHx8IHRoaXMucHJldmlvdXNHcm91cCA9PT0gRk4pIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmFyZ3NbaV0uY29udGFpbnModmFyaWFibGUsIGFsbCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihnID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgLy9leGl0IG9ubHkgaWYgaXQgZG9lc1xyXG4gICAgICAgICAgICAgICAgaWYoYWxsICYmIHRoaXMucG93ZXIuY29udGFpbnModmFyaWFibGUsIGFsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMudmFsdWUgPT09IHZhcmlhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHZhcmlhYmxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTmVnYXRlcyBhIHN5bWJvbHNcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBDUCB8fCB0aGlzLmdyb3VwID09PSBQTClcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnZlcnRzIGEgc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBwb3dlcl9vbmx5XHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBhbGxcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpbnZlcnQ6IGZ1bmN0aW9uIChwb3dlcl9vbmx5LCBhbGwpIHtcclxuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgaWYoIXBvd2VyX29ubHkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSB0aGlzLm11bHRpcGxpZXIuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSByZXN0XHJcbiAgICAgICAgICAgIGlmKGlzU3ltYm9sKHRoaXMucG93ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvd2VyLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYodGhpcy5ncm91cCA9PT0gQ0IgJiYgYWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5pbnZlcnQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5wb3dlciAmJiB0aGlzLmdyb3VwICE9PSBOKVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG93ZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTeW1ib2xzIG9mIGdyb3VwIENQIG9yIFBMIG1heSBoYXZlIHRoZSBtdWx0aXBsaWVyIGJlaW5nIGNhcnJpZWQgYnlcclxuICAgICAgICAgKiB0aGUgdG9wIGxldmVsIHN5bWJvbCBhdCBhbnkgZ2l2ZW4gdGltZSBlLmcuIDIqKHgreSt6KS4gVGhpcyBpc1xyXG4gICAgICAgICAqIGNvbnZlbmllbnQgaW4gbWFueSBjYXNlcywgaG93ZXZlciBpbiBzb21lIGNhc2VzIHRoZSBtdWx0aXBsaWVyIG5lZWRzXHJcbiAgICAgICAgICogdG8gYmUgY2FycmllZCBpbmRpdmlkdWFsbHkgZS5nLiAyKngrMip5KzIqei5cclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkaXN0cmlidXRlcyB0aGUgbXVsdGlwbGllciBvdmVyIHRoZSBlbnRpcmUgc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBhbGxcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGRpc3RyaWJ1dGVNdWx0aXBsaWVyOiBmdW5jdGlvbiAoYWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBpc19vbmUgPSBhbGwgPyB0aGlzLnBvd2VyLmFic0VxdWFscygxKSA6IHRoaXMucG93ZXIuZXF1YWxzKDEpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnN5bWJvbHMgJiYgaXNfb25lICYmIHRoaXMuZ3JvdXAgIT09IENCICYmICF0aGlzLm11bHRpcGxpZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnN5bWJvbHNbeF07XHJcbiAgICAgICAgICAgICAgICAgICAgcy5tdWx0aXBsaWVyID0gcy5tdWx0aXBsaWVyLm11bHRpcGx5KHRoaXMubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2QgZXhwYW5kcyB0aGUgZXhwb25lbnQgb3ZlciB0aGUgZW50aXJlIHN5bWJvbCBqdXN0IGxpa2VcclxuICAgICAgICAgKiBkaXN0cmlidXRlTXVsdGlwbGllclxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGlzdHJpYnV0ZUV4cG9uZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnBvd2VyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gdGhpcy5zeW1ib2xzW3hdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHMuZ3JvdXAgPT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucG93ZXIgPSBfLm11bHRpcGx5KHMucG93ZXIsIG5ldyBTeW1ib2wocCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW1ib2xzW3hdLnBvd2VyID0gdGhpcy5zeW1ib2xzW3hdLnBvd2VyLm11bHRpcGx5KHApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYXR0ZW1wdCB0byB1cC1jb252ZXJ0IG9yIGRvd24tY29udmVydCBvbmUgc3ltYm9sXHJcbiAgICAgICAgICogZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlci4gTm90IGFsbCBzeW1ib2xzIGFyZSBjb252ZXJ0aWJsZSBmcm9tIG9uZVxyXG4gICAgICAgICAqIGdyb3VwIHRvIGFub3RoZXIgaG93ZXZlci4gSW4gdGhhdCBjYXNlIHRoZSBzeW1ib2wgd2lsbCByZW1haW5cclxuICAgICAgICAgKiB1bmNoYW5nZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGdyb3VwXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGltYWdpbmFyeVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIChncm91cCwgaW1hZ2luYXJ5KSB7XHJcbiAgICAgICAgICAgIGlmKGdyb3VwID4gRk4pIHtcclxuICAgICAgICAgICAgICAgIC8vbWFrZSBhIGNsb25lIG9mIHRoaXMgc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNwID0gdGhpcy5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vYXR0YWNoIGEgc3ltYm9scyBvYmplY3QgYW5kIHVwZ3JhZGUgdGhlIGdyb3VwXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbHMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3N5bWJvbCBvZiBncm91cCBDQiBob2xkIHN5bWJvbHMgYm91bmQgdG9nZXRoZXIgdGhyb3VnaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYmVjYXVzZSBvZiBjb21tdXRhdGl2aXR5IHRoaXMgbXVsdGlwbGllciBjYW4gdGVjaG5pY2FsbHkgYmUgYW55d2hlcmUgd2l0aGluIHRoZSBncm91cFxyXG4gICAgICAgICAgICAgICAgICAgIC8vdG8ga2VlcCB0cmFjayBvZiBpdCBob3dldmVyIGl0J3MgZWFzaWVyIHRvIGFsd2F5cyBoYXZlIHRoZSB0b3AgbGV2ZWwgY2FycnkgaXRcclxuICAgICAgICAgICAgICAgICAgICBjcC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IHRoZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNwLmFyZ3MgPSB0aGlzLmFyZ3M7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXJncztcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5mbmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3RoZSBzeW1ib2wgbWF5IG9yaWdpbmF0ZSBmcm9tIHRoZSBzeW1ib2wgaSBidXQgdGhpcyBwcm9wZXJ0eSBubyBsb25nZXIgaG9sZHMgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgLy9hZnRlciBjb3B5aW5nXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmlzSW1nU3ltYm9sKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmlzSW1nU3ltYm9sO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgIC8vYXR0YWNoIGEgY2xvbmUgb2YgdGhpcyBzeW1ib2wgdG8gdGhlIHN5bWJvbHMgb2JqZWN0IHVzaW5nIGl0cyBwcm9wZXIga2V5XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbHNbY3Aua2V5Rm9yR3JvdXAoZ3JvdXApXSA9IGNwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwO1xyXG4gICAgICAgICAgICAgICAgLy9vYmplY3RzIGJ5IGRlZmF1bHQgZG9uJ3QgaGF2ZSBhIGxlbmd0aCBwcm9wZXJ0eS4gSG93ZXZlciwgaW4gb3JkZXIgdG8ga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAvL29mIHN1Yi1zeW1ib2xzIHdlIGhhdmUgdG8gaW1wbGltZW50IG91ciBvd24uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihncm91cCA9PT0gRVgpIHtcclxuICAgICAgICAgICAgICAgIC8vMV54IGlzIGp1c3Qgb25lIHNvIGNoZWNrIGFuZCBtYWtlIHN1cmVcclxuICAgICAgICAgICAgICAgIGlmKCEodGhpcy5ncm91cCA9PT0gTiAmJiB0aGlzLm11bHRpcGxpZXIuZXF1YWxzKDEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgIT09IEVYKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzR3JvdXAgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubXVsdGlwbGllci5udW0udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b1VuaXRNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBoYXNoIHRvIHJlZmxlY3QgdGhlIGFjY3VyYXRlIGhhc2hcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0ZXh0KHRoaXMsICdoYXNoJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBFWDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBOKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHRoaXMubXVsdGlwbGllci50b0RlY2ltYWwoKTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuc3ltYm9scylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBuZXcgU3ltYm9sKHRoaXMuZ3JvdXAgPT09IFAgPyBtICogTWF0aC5wb3codGhpcy52YWx1ZSwgdGhpcy5wb3dlcikgOiBtKS5jbG9uZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBQICYmIHRoaXMuZ3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBpbWFnaW5hcnkgPyB0aGlzLm11bHRpcGxpZXIubnVtLnRvU3RyaW5nKCkgOiBNYXRoLmFicyh0aGlzLm11bHRpcGxpZXIubnVtLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b1VuaXRNdWx0aXBsaWVyKCFpbWFnaW5hcnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cCA9IFA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBvbmUgb2YgdGhlIHByaW5jaXBhbCBtZXRob2RzIHRvIG1ha2UgaXQgYWxsIHBvc3NpYmxlLlxyXG4gICAgICAgICAqIEl0IHBlcmZvcm1zIGNsZWFudXAgYW5kIHByZXAgb3BlcmF0aW9ucyB3aGVuZXZlciBhIHN5bWJvbHMgaXNcclxuICAgICAgICAgKiBpbnNlcnRlZC4gSWYgdGhlIHN5bWJvbHMgcmVzdWx0cyBpbiBhIDEgaW4gYSBDQiAobXVsdGlwbGljYXRpb24pXHJcbiAgICAgICAgICogZ3JvdXAgZm9yIGluc3RhbmNlIGl0IHdpbGwgcmVtb3ZlIHRoZSByZWR1bmRhbnQgc3ltYm9sLiBTaW1pbGFybHlcclxuICAgICAgICAgKiBpbiBhIHN5bWJvbCBvZiBncm91cCBQTCBvciBDUCAoc3ltYm9scyBnbHVlZCBieSBtdWx0aXBsaWNhdGlvbikgaXRcclxuICAgICAgICAgKiB3aWxsIHJlbW92ZSBhbnkgZGFuZ2xpbmcgemVyb2VzIGZyb20gdGhlIHN5bWJvbC4gSXQgd2lsbCBhbHNvXHJcbiAgICAgICAgICogdXAtY29udmVydCBvciBkb3duLWNvbnZlcnQgYSBzeW1ib2wgaWYgaXQgZGV0ZWN0cyB0aGF0IGl0J3NcclxuICAgICAgICAgKiBpbmNvcnJlY3RseSBncm91cGVkLiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCB0aGlzIG1ldGhvZCBpcyBub3RcclxuICAgICAgICAgKiBjYWxsZWQgZGlyZWN0bHkgYnV0IHJhdGhlciBieSB0aGUgJ2F0dGFjaCcgbWV0aG9kIGZvciBhZGRpdGlvbiBncm91cHNcclxuICAgICAgICAgKiBhbmQgdGhlICdjb21iaW5lJyBtZXRob2QgZm9yIG11bHRpcGxpY2F0aW9uIGdyb3Vwcy5cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluc2VydDogZnVuY3Rpb24gKHN5bWJvbCwgYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIC8vdGhpcyBjaGVjayBjYW4gYmUgcmVtb3ZlZCBidXQgc2F2ZXMgYSBsb3Qgb2YgYWdncmF2YXRpb24gd2hlbiB0cnlpbmcgdG8gaHVudCBkb3duXHJcbiAgICAgICAgICAgIC8vYSBidWcuIElmIGxlZnQsIHlvdSB3aWxsIGluc3RhbnRseSBrbm93IHRoYXQgdGhlIGVycm9yIGNhbiBvbmx5IGJlIGJldHdlZW4gMiBzeW1ib2xzLlxyXG4gICAgICAgICAgICBpZighaXNTeW1ib2woc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIGVycignT2JqZWN0ICcgKyBzeW1ib2wgKyAnIGlzIG5vdCBvZiB0eXBlIFN5bWJvbCEnKTtcclxuICAgICAgICAgICAgaWYodGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPiBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBzeW1ib2wua2V5Rm9yR3JvdXAoZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZyA9IGtleSBpbiB0aGlzLnN5bWJvbHMgPyB0aGlzLnN5bWJvbHNba2V5XSA6IGZhbHNlOyAvL2NoZWNrIGlmIHRoZXJlJ3MgYWxyZWFkeSBhIHN5bWJvbCB0aGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFjdGlvbiA9PT0gJ2FkZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV4aXN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGVtIHRvZ2V0aGVyIHVzaW5nIHRoZSBwYXJzZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sc1toYXNoXSA9IF8uYWRkKGV4aXN0aW5nLCBzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgYWRkaXRpb24gcmVzdWx0ZWQgaW4gYSB6ZXJvIG11bHRpcGxpZXIgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnN5bWJvbHNbaGFzaF0ubXVsdGlwbGllci5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zeW1ib2xzW2hhc2hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmVydChOKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gbmV3IEZyYWMoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW1ib2xzW2tleV0gPSBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIHRoaXMgaXMgb2YgZ3JvdXAgUCBhbmQgdW53cmFwIGJlZm9yZSBpbnNlcnRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBQICYmIGlzSW50KHN5bWJvbC5wb3dlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbC5jb252ZXJ0KE4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RyYW5zZmVyIHRoZSBtdWx0aXBsaWVyIHRvIHRoZSB1cHBlciBzeW1ib2wgYnV0IG9ubHkgaWYgdGhlIHN5bWJvbCBudW1lcmljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCAhPT0gRVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGllciA9IHRoaXMubXVsdGlwbGllci5tdWx0aXBseShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnBhcmVucyA9IHN5bWJvbC5tdWx0aXBsaWVyLmxlc3NUaGFuKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gdGhpcy5tdWx0aXBsaWVyLm11bHRpcGx5KHN5bWJvbC5tdWx0aXBsaWVyLmNsb25lKCkuYWJzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnRvVW5pdE11bHRpcGxpZXIodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGV4aXN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBiZWNhdXNlIHRoZSBzeW1ib2wgbWF5IGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gXy5tdWx0aXBseShyZW1vdmUodGhpcy5zeW1ib2xzLCBrZXkpLCBzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGllciA9IHRoaXMubXVsdGlwbGllci5tdWx0aXBseShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbCgxKTsgLy90aGUgZGlydHkgd29yayBnZXRzIGRvbmUgZG93biB0aGUgbGluZSB3aGVuIGl0IGRldGVjdHMgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NsZWFuIHVwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZG9uJ3QgaW5zZXJ0IHRoZSBzeW1ib2wgaWYgaXQncyAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFzeW1ib2wuaXNPbmUodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sc1trZXldID0gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5tdWx0aXBsaWVyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZ2F0ZSgpOyAvL3B1dCBiYWNrIHRoZSBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2xlYW4gdXBcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0KE4pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBoYXNoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5ncm91cCA9PT0gQ1AgfHwgdGhpcy5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIYXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vdGhlIGluc2VydCBtZXRob2QgZm9yIGFkZGl0aW9uXHJcbiAgICAgICAgYXR0YWNoOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKGlzQXJyYXkoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydChzeW1ib2xbaV0sICdhZGQnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc2VydChzeW1ib2wsICdhZGQnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vdGhlIGluc2VydCBtZXRob2QgZm9yIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgY29tYmluZTogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICBpZihpc0FycmF5KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzeW1ib2wubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoc3ltYm9sW2ldLCAnbXVsdGlwbHknKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc2VydChzeW1ib2wsICdtdWx0aXBseScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBhbnkgbWFqb3IgXCJzdXJnZXJ5XCIgb24gYSBzeW1ib2wuXHJcbiAgICAgICAgICogSXQgdXBkYXRlcyB0aGUgaGFzaCBvZiB0aGUgc3ltYm9sIGZvciBleGFtcGxlIGlmIHRoZSBmbmFtZSBvZiBhXHJcbiAgICAgICAgICogZnVuY3Rpb24gaGFzIGNoYW5nZWQgaXQgd2lsbCB1cGRhdGUgdGhlIGhhc2ggb2YgdGhlIHN5bWJvbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1cGRhdGVIYXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IE4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLmFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX3BhcmVucyA9IHRoaXMuZm5hbWUgPT09IFBBUkVOVEhFU0lTO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMgKz0gKGkgPT09IDAgPyAnJyA6ICcsJykgKyB0ZXh0KGFyZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuX25hbWUgPSBpc19wYXJlbnMgPyAnJyA6IHRoaXMuZm5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gZm5fbmFtZSArIChpc19wYXJlbnMgPyBjb250ZW50cyA6IGluQnJhY2tldHMoY29udGVudHMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKCEodGhpcy5ncm91cCA9PT0gUyB8fCB0aGlzLmdyb3VwID09PSBQTCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0ZXh0KHRoaXMsICdoYXNoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHRoaXMgZnVuY3Rpb24gZGVmaW5lcyBob3cgZXZlcnkgZ3JvdXAgaW4gc3RvcmVkIHdpdGhpbiBhIGdyb3VwIG9mXHJcbiAgICAgICAgICogaGlnaGVyIG9yZGVyIHRoaW5rIG9mIGl0IGFzIHRoZSBzd2l0Y2hib2FyZCBmb3IgdGhlIGxpYnJhcnkuIEl0XHJcbiAgICAgICAgICogZGVmaW5lcyB0aGUgaGFzaGVzIGZvciBzeW1ib2xzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBncm91cFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGtleUZvckdyb3VwOiBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIGcgPSB0aGlzLmdyb3VwO1xyXG4gICAgICAgICAgICB2YXIga2V5O1xyXG5cclxuICAgICAgICAgICAgaWYoZyA9PT0gTikge1xyXG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IFMgfHwgZyA9PT0gUCkge1xyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPT09IFBMKVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucG93ZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICBpZihncm91cCA9PT0gUEwpXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wb3dlci50b0RlY2ltYWwoKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0ZXh0KHRoaXMsICdoYXNoJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihnID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgb3JkZXIgaXMgcmV2ZXJzZWQgdGhlbiB3ZSdsbCBhc3N1bWUgbXVsdGlwbGljYXRpb25cclxuICAgICAgICAgICAgICAgIC8vVE9ETzogcG9zc2libGUgZnV0dXJlIGRpbGVtbWFcclxuICAgICAgICAgICAgICAgIGlmKGdyb3VwID09PSBDQilcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0ZXh0KHRoaXMsICdoYXNoJyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMucG93ZXIuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gaW5CcmFja2V0cyh0ZXh0KHRoaXMsICdoYXNoJykpICsgU2V0dGluZ3MuUE9XRVJfT1BFUkFUT1IgKyB0aGlzLnBvd2VyLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihncm91cCA9PT0gUEwpXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5wb3dlci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gQ1ApIHtcclxuICAgICAgICAgICAgICAgIGlmKGdyb3VwID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRleHQodGhpcywgJ2hhc2gnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGdyb3VwID09PSBQTClcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBvd2VyLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihnID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPT09IFBMKVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRoaXMucG93ZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdGV4dCh0aGlzLCAnaGFzaCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZyA9PT0gRVgpIHtcclxuICAgICAgICAgICAgICAgIGlmKGdyb3VwID09PSBQTClcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSB0ZXh0KHRoaXMucG93ZXIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHRleHQodGhpcywgJ2hhc2gnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN5bWJvbHMgYXJlIHR5cGljYWxseSBzdG9yZWQgaW4gYW4gb2JqZWN0IHdoaWNoIHdvcmtzIGZpbmUgZm9yIG1vc3RcclxuICAgICAgICAgKiBjYXNlcyBidXQgcHJlc2VudHMgYSBwcm9ibGVtIHdoZW4gdGhlIG9yZGVyIG9mIHRoZSBzeW1ib2xzIG1ha2VzXHJcbiAgICAgICAgICogYSBkaWZmZXJlbmNlLiBUaGlzIGZ1bmN0aW9uIHNpbXBseSBjb2xsZWN0cyBhbGwgdGhlIHN5bWJvbHMgYW5kXHJcbiAgICAgICAgICogcmV0dXJucyB0aGVtIGFzIGFuIGFycmF5LiBJZiBhIGZ1bmN0aW9uIGlzIHN1cHBsaWVkIHRoZW4gdGhhdFxyXG4gICAgICAgICAqIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSBzeW1ib2wgY29udGFpbmVkIHdpdGhpbiB0aGUgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRfZm5cclxuICAgICAgICAgKiBAQHBhcmFtIHtCb29sZWFufSBleHBhbmRfc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbGxlY3RTeW1ib2xzOiBmdW5jdGlvbiAoZm4sIG9wdCwgc29ydF9mbiwgZXhwYW5kX3N5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgY29sbGVjdGVkID0gW107XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLnN5bWJvbHMpXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0ZWQucHVzaCh0aGlzKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gdGhpcy5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHRoaXMuc3ltYm9sc1t4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZihleHBhbmRfc3ltYm9sICYmIChzeW1ib2wuZ3JvdXAgPT09IFBMIHx8IHN5bWJvbC5ncm91cCA9PT0gQ1ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZCA9IGNvbGxlY3RlZC5jb25jYXQoc3ltYm9sLmNvbGxlY3RTeW1ib2xzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RlZC5wdXNoKGZuID8gZm4oc3ltYm9sLCBvcHQpIDogc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzb3J0X2ZuID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgc29ydF9mbiA9IHVuZGVmaW5lZDsgLy9XVEYgRmlyZWZveD8gU2VyaW91c2x5P1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RlZC5zb3J0KHNvcnRfZm4pOy8vc29ydCBob3BlZnVsbHkgZ2l2ZXMgdXMgc29tZSBzb3J0IG9mIGNvbnNpc3RlbmN5XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsYXRleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGF0ZXg6IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIExhVGVYLmxhdGV4KHRoaXMsIG9wdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIGEgc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGV4dDogZnVuY3Rpb24gKG9wdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dCh0aGlzLCBvcHRpb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gMS4gZS5nLiB4XjAgb3IgMSA6KVxyXG4gICAgICAgICAqIEBAcGFyYW0ge2Jvb2x9IGFicyBDb21wYXJlcyB0aGUgYWJzb2x1dGUgdmFsdWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBpc09uZTogZnVuY3Rpb24gKGFicykge1xyXG4gICAgICAgICAgICB2YXIgZiA9IGFicyA/ICdhYnNFcXVhbHMnIDogJ2VxdWFscyc7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZ3JvdXAgPT09IE4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsaWVyW2ZdKDEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wb3dlci5lcXVhbHMoMCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0NvbXBvc2l0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgcGcgPSB0aGlzLnByZXZpb3VzR3JvdXA7XHJcbiAgICAgICAgICAgIHJldHVybiBnID09PSBDUCB8fCBnID09PSBQTCB8fCBwZyA9PT0gUEwgfHwgcGcgPT09IENQO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNDb21iaW5hdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgcGcgPSB0aGlzLnByZXZpb3VzR3JvdXA7XHJcbiAgICAgICAgICAgIHJldHVybiBnID09PSBDQiB8fCBwZyA9PT0gQ0I7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsZXNzVGhhbjogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGllci5sZXNzVGhhbihuKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdyZWF0ZXJUaGFuOiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICBpZighaXNTeW1ib2wobikpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgU3ltYm9sKG4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCB0ZWxsIGZvciBzdXJlIGlmIGEgaXMgZ3JlYXRlciB0aGFuIGJlIGlmIHRoZXkncmUgbm90IGJvdGggbnVtYmVyc1xyXG4gICAgICAgICAgICBpZighdGhpcy5pc0NvbnN0YW50KHRydWUpIHx8ICFuLmlzQ29uc3RhbnQodHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGllci5ncmVhdGVyVGhhbihuLm11bHRpcGxpZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0J3MgdGhlIGRlbm9taW5hdG9yIG9mIHRoZSBzeW1ib2wgaWYgdGhlIHN5bWJvbCBpcyBvZiBjbGFzcyBDQiAobXVsdGlwbGljYXRpb24pXHJcbiAgICAgICAgICogd2l0aCBvdGhlciBjbGFzc2VzIHRoZSBzeW1ib2wgaXMgZWl0aGVyIHRoZSBkZW5vbWluYXRvciBvciBub3QuXHJcbiAgICAgICAgICogVGFrZSB4Xi0xK3heLTIuIElmIHRoZSBzeW1ib2wgd2FzIHRvIGJlIG1peGVkIHN1Y2ggYXMgeCt4Xi0yIHRoZW4gdGhlIHN5bWJvbCBkb2Vzbid0IGhhdmUgaGF2ZSBhbiBleGNsdXNpdmVcclxuICAgICAgICAgKiBkZW5vbWluYXRvciBhbmQgaGFzIHRvIGJlIGZvdW5kIGJ5IGxvb2tpbmcgYXQgdGhlIGFjdHVhbCBzeW1ib2xzIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0RGVub206IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJldHZhbCwgc3ltYm9sO1xyXG4gICAgICAgICAgICBzeW1ib2wgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vZS5nLiAxLyh4Kih4KzEpKVxyXG4gICAgICAgICAgICBpZih0aGlzLmdyb3VwID09PSBDQiAmJiB0aGlzLnBvd2VyLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gXy5leHBhbmQoc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgIC8vaWYgdGhlIHN5bWJvbCBhbHJlYWR5IGlzIHRoZSBkZW5vbWluYXRvci4uLiBET05FISEhXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSBfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyLmRlbik7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsLnBvd2VyLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShkLCByZXR2YWwpOyAvL3B1dCBiYWNrIHRoZSBjb2VmZlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZShzeW1ib2wubXVsdGlwbGllci5kZW4pO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHN5bWJvbC5zeW1ib2xzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5zeW1ib2xzW3hdLnBvd2VyIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIHN5bWJvbC5zeW1ib2xzW3hdLmNsb25lKCkuaW52ZXJ0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIuZGVuKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldE51bTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsLCBzeW1ib2w7XHJcbiAgICAgICAgICAgIHN5bWJvbCA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy9lLmcuIDEvKHgqKHgrMSkpXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IgJiYgc3ltYm9sLnBvd2VyLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gXy5leHBhbmQoc3ltYm9sKTtcclxuICAgICAgICAgICAgLy9pZiB0aGUgc3ltYm9sIGFscmVhZHkgaXMgdGhlIGRlbm9taW5hdG9yLi4uIERPTkUhISFcclxuICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyLmdyZWF0ZXJUaGFuKDApICYmIHN5bWJvbC5ncm91cCAhPT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoXy5wYXJzZShzeW1ib2wubXVsdGlwbGllci5udW0pLCBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIubnVtKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoeC5wb3dlciA+IDAgfHwgeC5ncm91cCA9PT0gRVggJiYgeC5wb3dlci5tdWx0aXBsaWVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgeC5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIubnVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4vL1BhcnNlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy9Vc2VzIG1vZGlmaWVkIFNodW50aW5nLXlhcmQgYWxnb3JpdGhtLiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NodW50aW5nLXlhcmRfYWxnb3JpdGhtXHJcbiAgICBmdW5jdGlvbiBQYXJzZXIoKSB7XHJcbiAgICAgICAgLy9Qb2ludCB0byB0aGUgbG9jYWwgcGFyc2VyIGluc3RlYWQgb2YgdGhlIGdsb2JhbCBvbmVcclxuICAgICAgICB2YXIgXyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGJpbiA9IHt9O1xyXG4gICAgICAgIHZhciBwcmVwcm9jZXNzb3JzID0ge25hbWVzOiBbXSwgYWN0aW9uczogW119O1xyXG5cclxuLy9QYXJzZXIuY2xhc3NlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICBmdW5jdGlvbiBTbGljZSh1cHBlciwgbG93ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHVwcGVyO1xyXG4gICAgICAgICAgICB0aGlzLmVuZCA9IGxvd2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgU2xpY2UucHJvdG90eXBlLmlzQ29uc3RhbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmlzQ29uc3RhbnQoKSAmJiB0aGlzLmVuZC5pc0NvbnN0YW50KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTbGljZS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQodGhpcy5zdGFydCkgKyAnOicgKyB0ZXh0KHRoaXMuZW5kKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGFzcyB1c2VkIHRvIGNvbGxlY3QgYXJndW1lbnRzIGZvciBmdW5jdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7UGFyc2VyLkNvbGxlY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2goZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8ucHJldHR5X3ByaW50KHRoaXMuZWxlbWVudHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29sbGVjdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIGlmKGUpXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmFwcGVuZChlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gVG9rZW4obm9kZSwgbm9kZV90eXBlLCBjb2x1bW4pIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlID0gbm9kZV90eXBlO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbm9kZTtcclxuICAgICAgICAgICAgaWYoY29sdW1uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbiArIDE7XHJcbiAgICAgICAgICAgIGlmKG5vZGVfdHlwZSA9PT0gVG9rZW4uT1BFUkFUT1IpIHtcclxuICAgICAgICAgICAgICAgIC8vY29weSBldmVyeXRoaW5nIG92ZXIgZnJvbSB0aGUgb3BlcmF0b3JcclxuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRvciA9IG9wZXJhdG9yc1tub2RlXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBvcGVyYXRvcilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW3hdID0gb3BlcmF0b3JbeF07XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYobm9kZV90eXBlID09PSBUb2tlbi5GVU5DVElPTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVjZWRlbmNlID0gVG9rZW4uTUFYX1BSRUNFREVOQ0U7IC8vbGVhdmUgZW5vdWdoIHJvb25cclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdEFzc29jID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRva2VuLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pc19wcmVmaXgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2AnICsgdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL3NvbWUgY29uc3RhbnRzXHJcbiAgICAgICAgVG9rZW4uT1BFUkFUT1IgPSAnT1BFUkFUT1InO1xyXG4gICAgICAgIFRva2VuLlZBUklBQkxFX09SX0xJVEVSQUwgPSAnVkFSSUFCTEVfT1JfTElURVJBTCc7XHJcbiAgICAgICAgVG9rZW4uRlVOQ1RJT04gPSAnRlVOQ1RJT04nO1xyXG4gICAgICAgIFRva2VuLlVOSVQgPSAnVU5JVCc7XHJcbiAgICAgICAgVG9rZW4uS0VZV09SRCA9ICdLRVlXT1JEJztcclxuICAgICAgICBUb2tlbi5NQVhfUFJFQ0VERU5DRSA9IDk5OTtcclxuICAgICAgICAvL2NyZWF0ZSBsaW5rIHRvIGNsYXNzZXNcclxuICAgICAgICB0aGlzLmNsYXNzZXMgPSB7XHJcbiAgICAgICAgICAgIENvbGxlY3Rpb246IENvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgIFNsaWNlOiBTbGljZSxcclxuICAgICAgICAgICAgVG9rZW46IFRva2VuXHJcbiAgICAgICAgfTtcclxuLy9QYXJzZXIubW9kdWxlcyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAvL29iamVjdCBmb3IgZnVuY3Rpb25zIHdoaWNoIGhhbmRsZSBjb21wbGV4IG51bWJlclxyXG4gICAgICAgIHZhciBjb21wbGV4ID0ge1xyXG4gICAgICAgICAgICBwcmVjOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNvczogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZSwgaW07XHJcbiAgICAgICAgICAgICAgICByZSA9IF8ucGFyc2UoTWF0aC5jb3MocikgKiBNYXRoLmNvc2goaSkpO1xyXG4gICAgICAgICAgICAgICAgaW0gPSBfLnBhcnNlKE1hdGguc2luKHIpICogTWF0aC5zaW5oKGkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN1YnRyYWN0KHJlLCBfLm11bHRpcGx5KGltLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2luOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlLCBpbTtcclxuICAgICAgICAgICAgICAgIHJlID0gXy5wYXJzZShNYXRoLnNpbihyKSAqIE1hdGguY29zaChpKSk7XHJcbiAgICAgICAgICAgICAgICBpbSA9IF8ucGFyc2UoTWF0aC5jb3MocikgKiBNYXRoLnNpbmgoaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QocmUsIF8ubXVsdGlwbHkoaW0sIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0YW46IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmUsIGltO1xyXG4gICAgICAgICAgICAgICAgcmUgPSBfLnBhcnNlKE1hdGguc2luKDIgKiByKSAvIChNYXRoLmNvcygyICogcikgKyBNYXRoLmNvc2goMiAqIGkpKSk7XHJcbiAgICAgICAgICAgICAgICBpbSA9IF8ucGFyc2UoTWF0aC5zaW5oKDIgKiBpKSAvIChNYXRoLmNvcygyICogcikgKyBNYXRoLmNvc2goMiAqIGkpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQocmUsIF8ubXVsdGlwbHkoaW0sIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZWM6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMucmVtb3ZlRGVuKHRoaXMuY29zKHIsIGkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN1YnRyYWN0KHRbMF0sIF8ubXVsdGlwbHkodFsxXSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNzYzogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5yZW1vdmVEZW4odGhpcy5zaW4ociwgaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKHRbMF0sIF8ubXVsdGlwbHkodFsxXSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvdDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5yZW1vdmVEZW4odGhpcy50YW4ociwgaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QodFswXSwgXy5tdWx0aXBseSh0WzFdLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNvczogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wsIHNxLCBhLCBiLCBjLCBzcXVhcmVkO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gdGhpcy5mcm9tQXJyYXkoW3IsIGldKTtcclxuICAgICAgICAgICAgICAgIHNxdWFyZWQgPSBfLnBvdyhzeW1ib2wuY2xvbmUoKSwgbmV3IFN5bWJvbCgyKSk7XHJcbiAgICAgICAgICAgICAgICBzcSA9IF8uZXhwYW5kKHNxdWFyZWQpOyAvL3oqelxyXG4gICAgICAgICAgICAgICAgYSA9IF8ubXVsdGlwbHkoc3FydChfLnN1YnRyYWN0KG5ldyBTeW1ib2woMSksIHNxKSksIFN5bWJvbC5pbWFnaW5hcnkoKSk7XHJcbiAgICAgICAgICAgICAgICBiID0gXy5leHBhbmQoXy5hZGQoc3ltYm9sLmNsb25lKCksIGEpKTtcclxuICAgICAgICAgICAgICAgIGMgPSBsb2coYik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5leHBhbmQoXy5tdWx0aXBseShTeW1ib2wuaW1hZ2luYXJ5KCkubmVnYXRlKCksIGMpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXNpbjogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN1YnRyYWN0KF8ucGFyc2UoJ3BpLzInKSwgdGhpcy5hY29zKHIsIGkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXRhbjogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpIGFuZCAtaVxyXG4gICAgICAgICAgICAgICAgaWYoci5lcXVhbHMoMCkgJiYgKGkuZXF1YWxzKDEpIHx8IGkuZXF1YWxzKC0xKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGNvcHkgV29sZnJhbSBBbHBoYSBmb3Igbm93LiBUaGUgcGFyZW50aGVzaXMgXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoYCR7U3ltYm9sLmluZmluaXR5KCl9KiR7U2V0dGluZ3MuSU1BR0lOQVJZfSoke2l9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgYywgc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gY29tcGxleC5mcm9tQXJyYXkoW3IsIGldKTtcclxuICAgICAgICAgICAgICAgIGEgPSBfLmV4cGFuZChfLm11bHRpcGx5KFN5bWJvbC5pbWFnaW5hcnkoKSwgc3ltYm9sLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgIGIgPSBsb2coXy5leHBhbmQoXy5zdWJ0cmFjdChuZXcgU3ltYm9sKDEpLCBhLmNsb25lKCkpKSk7XHJcbiAgICAgICAgICAgICAgICBjID0gbG9nKF8uZXhwYW5kKF8uYWRkKG5ldyBTeW1ib2woMSksIGEuY2xvbmUoKSkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmV4cGFuZChfLm11bHRpcGx5KF8uZGl2aWRlKFN5bWJvbC5pbWFnaW5hcnkoKSwgbmV3IFN5bWJvbCgyKSksIF8uc3VidHJhY3QoYiwgYykpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXNlYzogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5yZW1vdmVEZW4oW3IsIGldKTtcclxuICAgICAgICAgICAgICAgIGRbMV0ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY29zLmFwcGx5KHRoaXMsIGQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3NjOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLnJlbW92ZURlbihbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgZFsxXS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFzaW4uYXBwbHkodGhpcywgZCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjb3Q6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMucmVtb3ZlRGVuKFtyLCBpXSk7XHJcbiAgICAgICAgICAgICAgICBkWzFdLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRhbi5hcHBseSh0aGlzLCBkKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy9IeXBlcmJvbGljIHRyaWdcclxuICAgICAgICAgICAgY29zaDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZSwgaW07XHJcbiAgICAgICAgICAgICAgICByZSA9IF8ucGFyc2UoTWF0aC5jb3NoKHIpICogTWF0aC5jb3MoaSkpO1xyXG4gICAgICAgICAgICAgICAgaW0gPSBfLnBhcnNlKE1hdGguc2luaChyKSAqIE1hdGguc2luKGkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChyZSwgXy5tdWx0aXBseShpbSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNpbmg6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmUsIGltO1xyXG4gICAgICAgICAgICAgICAgcmUgPSBfLnBhcnNlKE1hdGguc2luaChyKSAqIE1hdGguY29zKGkpKTtcclxuICAgICAgICAgICAgICAgIGltID0gXy5wYXJzZShNYXRoLmNvc2gocikgKiBNYXRoLnNpbihpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQocmUsIF8ubXVsdGlwbHkoaW0sIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0YW5oOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlLCBpbTtcclxuICAgICAgICAgICAgICAgIHJlID0gXy5wYXJzZShNYXRoLnNpbmgoMiAqIHIpIC8gKE1hdGguY29zKDIgKiBpKSArIE1hdGguY29zaCgyICogcikpKTtcclxuICAgICAgICAgICAgICAgIGltID0gXy5wYXJzZShNYXRoLnNpbigyICogaSkgLyAoTWF0aC5jb3MoMiAqIGkpICsgTWF0aC5jb3NoKDIgKiByKSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QocmUsIF8ubXVsdGlwbHkoaW0sIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZWNoOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnJlbW92ZURlbih0aGlzLmNvc2gociwgaSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QodFswXSwgXy5tdWx0aXBseSh0WzFdLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3NjaDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5yZW1vdmVEZW4odGhpcy5zaW5oKHIsIGkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN1YnRyYWN0KHRbMF0sIF8ubXVsdGlwbHkodFsxXSwgU3ltYm9sLmltYWdpbmFyeSgpKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvdGg6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMucmVtb3ZlRGVuKHRoaXMudGFuaChyLCBpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQodFswXSwgXy5tdWx0aXBseSh0WzFdLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNvc2g6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgejtcclxuICAgICAgICAgICAgICAgIHogPSB0aGlzLmZyb21BcnJheShbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgYSA9IHNxcnQoXy5hZGQoei5jbG9uZSgpLCBuZXcgU3ltYm9sKDEpKSk7XHJcbiAgICAgICAgICAgICAgICBiID0gc3FydChfLnN1YnRyYWN0KHouY2xvbmUoKSwgbmV3IFN5bWJvbCgxKSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uZXhwYW5kKGxvZyhfLmFkZCh6LCBfLmV4cGFuZChfLm11bHRpcGx5KGEsIGIpKSkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXNpbmg6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgejtcclxuICAgICAgICAgICAgICAgIHogPSB0aGlzLmZyb21BcnJheShbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgYSA9IHNxcnQoXy5hZGQobmV3IFN5bWJvbCgxKSwgXy5leHBhbmQoXy5wb3coei5jbG9uZSgpLCBuZXcgU3ltYm9sKDIpKSkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmV4cGFuZChsb2coXy5hZGQoeiwgYSkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXRhbmg6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSwgYiwgejtcclxuICAgICAgICAgICAgICAgIHogPSB0aGlzLmZyb21BcnJheShbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgYSA9IGxvZyhfLmFkZCh6LmNsb25lKCksIG5ldyBTeW1ib2woMSkpKTtcclxuICAgICAgICAgICAgICAgIGIgPSBsb2coXy5zdWJ0cmFjdChuZXcgU3ltYm9sKDEpLCB6KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5leHBhbmQoXy5kaXZpZGUoXy5zdWJ0cmFjdChhLCBiKSwgbmV3IFN5bWJvbCgyKSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhc2VjaDogZnVuY3Rpb24gKHIsIGkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy5yZW1vdmVEZW4oW3IsIGldKTtcclxuICAgICAgICAgICAgICAgIHRbMV0ubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY29zaC5hcHBseSh0aGlzLCB0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNzY2g6IGZ1bmN0aW9uIChyLCBpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMucmVtb3ZlRGVuKFtyLCBpXSk7XHJcbiAgICAgICAgICAgICAgICB0WzFdLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNpbmguYXBwbHkodGhpcywgdCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjb3RoOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnJlbW92ZURlbihbciwgaV0pO1xyXG4gICAgICAgICAgICAgICAgdFsxXS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0YW5oLmFwcGx5KHRoaXMsIHQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzcXJ0OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmUsIGltLCBoLCBhLCBkO1xyXG4gICAgICAgICAgICAgICAgcmUgPSBzeW1ib2wucmVhbHBhcnQoKTtcclxuICAgICAgICAgICAgICAgIGltID0gc3ltYm9sLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICBoID0gU3ltYm9sLmh5cChyZSwgaW0pO1xyXG4gICAgICAgICAgICAgICAgYSA9IF8uYWRkKHJlLmNsb25lKCksIGgpO1xyXG4gICAgICAgICAgICAgICAgZCA9IHNxcnQoXy5tdWx0aXBseShuZXcgU3ltYm9sKDIpLCBhLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChfLmRpdmlkZShhLmNsb25lKCksIGQuY2xvbmUoKSksIF8ubXVsdGlwbHkoXy5kaXZpZGUoaW0sIGQpLCBTeW1ib2wuaW1hZ2luYXJ5KCkpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbG9nOiBmdW5jdGlvbiAociwgaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlLCBpbSwgcGhpO1xyXG4gICAgICAgICAgICAgICAgcmUgPSBsb2coU3ltYm9sLmh5cChyLCBpKSk7XHJcbiAgICAgICAgICAgICAgICBwaGkgPSBTZXR0aW5ncy5VU0VfQklHID8gU3ltYm9sKGJpZ0RlYy5hdGFuMihpLm11bHRpcGxpZXIudG9EZWNpbWFsKCksIHIubXVsdGlwbGllci50b0RlY2ltYWwoKSkpIDogTWF0aC5hdGFuMihpLCByKTtcclxuICAgICAgICAgICAgICAgIGltID0gXy5wYXJzZShwaGkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKHJlLCBfLm11bHRpcGx5KFN5bWJvbC5pbWFnaW5hcnkoKSwgaW0pKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJmKHN5bWJvbCwgbikge1xyXG4gICAgICAgICAgICAgICAgLy9EbyBub3RoaW5nIGZvciBub3cuIFJldmlzaXQgdGhpcyBpbiB0aGUgZnV0dXJlLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2VyZicsIFtzeW1ib2xdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBuID0gbiB8fCAzMDtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGZ1bmN0aW9uIChSLCBJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSwgYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfLnBhcnNlKGJpZ0RlYy5leHAoYmlnRGVjKGkpLnRvUG93ZXIoMikubmVnKCkuZGl2aWRlZEJ5KGJpZ0RlYyhuKS5wb3coMikucGx1cyhiaWdEZWMoUikudG9Qb3dlcigyKS50aW1lcyg0KSkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gXy5wYXJzZShmb3JtYXQoJzIqKHsxfSktZV4oLSgyKnswfSp7MX0qezJ9KSkqKDIqezF9KmNvc2goezJ9KnszfSktezB9KnszfSpzaW5oKHszfSp7Mn0pKScsIFNldHRpbmdzLklNQUdJTkFSWSwgUiwgSSwgaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBfLm11bHRpcGx5KGEsIGIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShyZXR2YWwsIG5ldyBTeW1ib2woMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHZhciByZSwgaW0sIGEsIGIsIGMsIGs7XHJcbiAgICAgICAgICAgICAgICByZSA9IHN5bWJvbC5yZWFscGFydCgpO1xyXG4gICAgICAgICAgICAgICAgaW0gPSBzeW1ib2wuaW1hZ3BhcnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBrID0gXy5wYXJzZShmb3JtYXQoJyhlXigtezB9XjIpKS9waScsIHJlKSk7XHJcbiAgICAgICAgICAgICAgICBhID0gXy5wYXJzZShmb3JtYXQoJygxLWVeKC0oMip7MH0qezF9KnsyfSkpKS8oMip7MX0pJywgU2V0dGluZ3MuSU1BR0lOQVJZLCByZSwgaW0pKTtcclxuICAgICAgICAgICAgICAgIGIgPSBmKHJlLnRvU3RyaW5nKCksIGltLnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChfLnBhcnNlKE1hdGgyLmVyZihyZS50b1N0cmluZygpKSksIF8ubXVsdGlwbHkoaywgXy5hZGQoYSwgYikpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcmVtb3ZlRGVuOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVuLCByLCBpLCByZSwgaW07XHJcbiAgICAgICAgICAgICAgICBpZihpc0FycmF5KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByID0gc3ltYm9sWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBzeW1ib2xbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByID0gc3ltYm9sLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IHN5bWJvbC5pbWFncGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlbiA9IE1hdGgucG93KHIsIDIpICsgTWF0aC5wb3coaSwgMik7XHJcbiAgICAgICAgICAgICAgICByZSA9IF8ucGFyc2UociAvIGRlbik7XHJcbiAgICAgICAgICAgICAgICBpbSA9IF8ucGFyc2UoaSAvIGRlbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3JlLCBpbV07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZyb21BcnJheTogZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKGFyclswXSwgXy5tdWx0aXBseShTeW1ib2wuaW1hZ2luYXJ5KCksIGFyclsxXSkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24gKHN5bWJvbCwgZikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlLCBpbSwgc2lnbjtcclxuXHJcbiAgICAgICAgICAgICAgICBzaWduID0gc3ltYm9sLnBvd2VyLnNpZ24oKTtcclxuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGl0IGZyb20gdW5kZXIgdGhlIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wucG93ZXIgPSBzeW1ib2wucG93ZXIuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICAvL2V4cGFuZFxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLnBvd2VyLmdyZWF0ZXJUaGFuKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8uZXhwYW5kKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgZGVub21pbmF0b3JcclxuICAgICAgICAgICAgICAgIGlmKHNpZ24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB0aGlzLnJlbW92ZURlbihzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlID0gZFswXTtcclxuICAgICAgICAgICAgICAgICAgICBpbSA9IGRbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZSA9IHN5bWJvbC5yZWFscGFydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGltID0gc3ltYm9sLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYocmUuaXNDb25zdGFudCgnYWxsJykgJiYgaW0uaXNDb25zdGFudCgnYWxsJykpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZl0uY2FsbCh0aGlzLCByZSwgaW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKGYsIFtzeW1ib2xdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9vYmplY3QgZm9yIGZ1bmN0aW9ucyB3aGljaCBoYW5kbGUgdHJpZ1xyXG4gICAgICAgIHZhciB0cmlnID0gdGhpcy50cmlnID0ge1xyXG4gICAgICAgICAgICAvL2NvbnRhaW5lciBmb3IgdHJpZ29ub21ldHJpYyBmdW5jdGlvblxyXG4gICAgICAgICAgICBjb3M6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoJ3BpJykgJiYgc3ltYm9sLm11bHRpcGxpZXIuZGVuLmVxdWFscygyKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKG5ldyBTeW1ib2woU2V0dGluZ3MuUEkgLyAyKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuVVNFX0JJRykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woYmlnRGVjLmNvcyhzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmNvcyhzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ2NvcycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gZ2V0UXVhZHJhbnQoc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gc3ltYm9sLm11bHRpcGxpZXIuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IG07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzUGkoKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGZvciAxIG9yIC0xIGZvciBtdWx0aXBsZXMgb2YgcGlcclxuICAgICAgICAgICAgICAgICAgICBpZihpc0ludChtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKGV2ZW4obSkgPyAxIDogLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBOdW1iZXIobS5udW0pLCBkID0gTnVtYmVyKG0uZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZCA9PT0gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnMS8yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoJzEvc3FydCgyKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09PSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCdzcXJ0KDMpLzInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2NvcycsIFtzeW1ib2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYyAmJiAocSA9PT0gMiB8fCBxID09PSAzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIXJldHZhbClcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdjb3MnLCBbc3ltYm9sXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2luOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbCAlIE1hdGguUEkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfQklHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChiaWdEZWMuc2luKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguc2luKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ3NpbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gZ2V0UXVhZHJhbnQoc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduID0gc3ltYm9sLm11bHRpcGxpZXIuc2lnbigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gc3ltYm9sLm11bHRpcGxpZXIuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IG07XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKCdwaScpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5pc1BpKCkgJiYgc3ltYm9sLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBmb3IgMCBmb3IgbXVsdGlwbGVzIG9mIHBpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNJbnQobSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbS5udW0sIGQgPSBtLmRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZCA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoJ3NxcnQoMykvMicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnMS9zcXJ0KDIpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnMS8yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KG5ldyBTeW1ib2woc2lnbiksIF8uc3ltZnVuY3Rpb24oJ3NpbicsIFtzeW1ib2xdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKCFyZXR2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShuZXcgU3ltYm9sKHNpZ24pLCBfLnN5bWZ1bmN0aW9uKCdzaW4nLCBbc3ltYm9sXSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGMgJiYgKHEgPT09IDMgfHwgcSA9PT0gNCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRhbjogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sICUgTWF0aC5QSSA9PT0gMCAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfQklHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChiaWdEZWMudGFuKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGgudGFuKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ3RhbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gZ2V0UXVhZHJhbnQoc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gc3ltYm9sLm11bHRpcGxpZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIgPSBtO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc1BpKCkgJiYgc3ltYm9sLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiAwIGZvciBhbGwgbXVsdGlwbGVzIG9mIHBpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNJbnQobSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbS5udW0sIGQgPSBtLmRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZCA9PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKCd0YW4gaXMgdW5kZWZpbmVkIGZvciAnICsgc3ltYm9sLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnc3FydCgzKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnMS9zcXJ0KDMpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCd0YW4nLCBbc3ltYm9sXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKCFyZXR2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbigndGFuJywgW3N5bWJvbF0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGMgJiYgKHEgPT09IDIgfHwgcSA9PT0gNCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlYzogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfQklHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChuZXcgYmlnRGVjKDEpLmRpdmlkZWRCeShiaWdEZWMuY29zKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoMi5zZWMoc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnc2VjJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcxL2Nvcyh7MH0pJywgc3ltYm9sKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gZ2V0UXVhZHJhbnQoc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gc3ltYm9sLm11bHRpcGxpZXIuYWJzKCk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IG07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzUGkoKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGZvciAxIG9yIC0xIGZvciBtdWx0aXBsZXMgb2YgcGlcclxuICAgICAgICAgICAgICAgICAgICBpZihpc0ludChtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKGV2ZW4obSkgPyAxIDogLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBtLm51bSwgZCA9IG0uZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkID09IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJ3NlYyBpcyB1bmRlZmluZWQgZm9yICcgKyBzeW1ib2wudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoJ3NxcnQoMiknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCcyL3NxcnQoMyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ3NlYycsIFtzeW1ib2xdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYyAmJiAocSA9PT0gMiB8fCBxID09PSAzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoIXJldHZhbClcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdzZWMnLCBbc3ltYm9sXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3NjOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlVTRV9CSUcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKG5ldyBiaWdEZWMoMSkuZGl2aWRlZEJ5KGJpZ0RlYy5zaW4oc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGgyLmNzYyhzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdjc2MnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJzEvc2luKHswfSknLCBzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBnZXRRdWFkcmFudChzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ24gPSBzeW1ib2wubXVsdGlwbGllci5zaWduKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0gPSBzeW1ib2wubXVsdGlwbGllci5hYnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IG07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzUGkoKSAmJiBzeW1ib2wuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIGZvciAwIGZvciBtdWx0aXBsZXMgb2YgcGlcclxuICAgICAgICAgICAgICAgICAgICBpZihpc0ludChtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJ2NzYyBpcyB1bmRlZmluZWQgZm9yICcgKyBzeW1ib2wudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG0ubnVtLCBkID0gbS5kZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGQgPT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBhcnNlKCcyL3NxcnQoMyknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoJ3NxcnQoMiknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZCA9PSA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShuZXcgU3ltYm9sKHNpZ24pLCBfLnN5bWZ1bmN0aW9uKCdjc2MnLCBbc3ltYm9sXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZighcmV0dmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkobmV3IFN5bWJvbChzaWduKSwgXy5zeW1mdW5jdGlvbignY3NjJywgW3N5bWJvbF0pKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihjICYmIChxID09PSAzIHx8IHEgPT09IDQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbC5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb3Q6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbCAlIChNYXRoLlBJLzIpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlVTRV9CSUcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKG5ldyBiaWdEZWMoMSkuZGl2aWRlZEJ5KGJpZ0RlYy50YW4oc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGgyLmNvdChzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdjb3QnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJzEvdGFuKHswfSknLCBzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGdldFF1YWRyYW50KHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IHN5bWJvbC5tdWx0aXBsaWVyO1xyXG5cclxuICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyID0gbTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNQaSgpICYmIHN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gMCBmb3IgYWxsIG11bHRpcGxlcyBvZiBwaVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzSW50KG0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignY290IGlzIHVuZGVmaW5lZCBmb3IgJyArIHN5bWJvbC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gbS5udW0sIGQgPSBtLmRlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZCA9PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UoJzEvc3FydCgzKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkID09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGQgPT0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnc3FydCgzKScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignY290JywgW3N5bWJvbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZighcmV0dmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2NvdCcsIFtzeW1ib2xdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihjICYmIChxID09PSAyIHx8IHEgPT09IDQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbC5uZWdhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY29zOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB2YWx1ZXMgaW4gdGhlIGNvbXBsZXggZG9tYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ndCgxKSB8fCBzeW1ib2wubHQoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHN5bWJvbC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZChldmFsdWF0ZShgcGkvMi1hc2luKCR7eH0pYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBiaWcgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfQklHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChiaWdEZWMuYWNvcyhzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmFjb3Moc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYWNvcycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2Fjb3MnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhc2luOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB2YWx1ZXMgaW4gdGhlIGNvbXBsZXggZG9tYWluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ndCgxKSB8fCBzeW1ib2wubHQoLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IFNldHRpbmdzLklNQUdJTkFSWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kKGV2YWx1YXRlKGAke2l9KmxvZyhzcXJ0KDEtJHt4fV4yKS0ke2l9KiR7eH0pYCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBiaWcgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfQklHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChiaWdEZWMuYXNpbihzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmFzaW4oc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYXNpbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2FzaW4nLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdGFuOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBiaWcgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5VU0VfQklHKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChiaWdEZWMuYXRhbihzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmF0YW4oc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYXRhbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdhdGFuJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmVxdWFscygtMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wYXJzZSgnLXBpLzQnKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdhdGFuJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFzZWM6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE91dE9mRnVuY3Rpb25Eb21haW5FcnJvcignSW5wdXQgaXMgb3V0IG9mIHRoZSBkb21haW4gb2Ygc2VjIScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmlnLmFjb3Moc3ltYm9sLmludmVydCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYXNlYycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdhc2VjJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNzYzogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJpZy5hc2luKHN5bWJvbC5pbnZlcnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYWNzYycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2Fjc2MnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY290OiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgXy5hZGQoXy5wYXJzZSgncGkvMicpLCB0cmlnLmF0YW4oc3ltYm9sKS5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYWNvdCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2Fjb3QnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdGFuMjogZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIGlmKGEuZXF1YWxzKDApICYmIGIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignYXRhbjIgaXMgdW5kZWZpbmVkIGZvciAwLCAwJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIGEuaXNDb25zdGFudCgpICYmIGIuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5hdGFuMihhLCBiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignYXRhbjInLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL29iamVjdCBmb3IgZnVuY3Rpb25zIHdoaWNoIGhhbmRsZSBoeXBlcmJvbGljIHRyaWdcclxuICAgICAgICB2YXIgdHJpZ2ggPSB0aGlzLnRyaWdoID0ge1xyXG4gICAgICAgICAgICAvL2NvbnRhaW5lciBmb3IgaHlwZXJib2xpYyB0cmlnIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGNvc2g6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmNvc2goc3ltYm9sLnZhbHVlT2YoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ2Nvc2gnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2Nvc2gnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzaW5oOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5zaW5oKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdzaW5oJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdzaW5oJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGFuaDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGgudGFuaChzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAndGFuaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsID0gXy5zeW1mdW5jdGlvbigndGFuaCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlY2g6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguc2VjaChzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0ltYWdpbmFyeSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ3NlY2gnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcxL2Nvc2goezB9KScsIHN5bWJvbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdzZWNoJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY3NjaDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGguY3NjaChzeW1ib2wudmFsdWVPZigpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnY3NjaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJzEvc2luaCh7MH0pJywgc3ltYm9sKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2NzY2gnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb3RoOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5jb3RoKHN5bWJvbC52YWx1ZU9mKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdjb3RoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnMS90YW5oKHswfSknLCBzeW1ib2wpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsID0gXy5zeW1mdW5jdGlvbignY290aCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFjb3NoOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYWNvc2gnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGV2YWx1YXRlKF8ucGFyc2UoZm9ybWF0KFNldHRpbmdzLkxPRyArICcoKHswfSkrc3FydCgoezB9KV4yLTEpKScsIHN5bWJvbC50b1N0cmluZygpKSkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2Fjb3NoJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFzaW5oOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYXNpbmgnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGV2YWx1YXRlKF8ucGFyc2UoZm9ybWF0KFNldHRpbmdzLkxPRyArICcoKHswfSkrc3FydCgoezB9KV4yKzEpKScsIHN5bWJvbC50b1N0cmluZygpKSkpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oJ2FzaW5oJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0YW5oOiBmdW5jdGlvbiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIHN5bWJvbC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGNvbXBsZXguZXZhbHVhdGUoc3ltYm9sLCAnYXRhbmgnKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZXZhbHVhdGUoXy5wYXJzZShmb3JtYXQoJygxLzIpKicgKyBTZXR0aW5ncy5MT0cgKyAnKCgxKyh7MH0pKS8oMS0oezB9KSkpJywgc3ltYm9sLnRvU3RyaW5nKCkpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignYXRhbmgnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXNlY2g6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhc2VjaCcpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gZXZhbHVhdGUobG9nKF8uYWRkKHN5bWJvbC5jbG9uZSgpLmludmVydCgpLCBzcXJ0KF8uc3VidHJhY3QoXy5wb3coc3ltYm9sLCBuZXcgU3ltYm9sKC0yKSksIG5ldyBTeW1ib2woMSkpKSkpKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdhc2VjaCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3NjaDogZnVuY3Rpb24gKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUiAmJiBzeW1ib2wuaXNJbWFnaW5hcnkoKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgJ2Fjc2NoJyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUilcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBldmFsdWF0ZShfLnBhcnNlKGZvcm1hdChTZXR0aW5ncy5MT0cgKyAnKCgxK3NxcnQoMSsoezB9KV4yKSkvKHswfSkpJywgc3ltYm9sLnRvU3RyaW5nKCkpKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbignYWNzY2gnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWNvdGg6IGZ1bmN0aW9uIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgc3ltYm9sLmlzSW1hZ2luYXJ5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gY29tcGxleC5ldmFsdWF0ZShzeW1ib2wsICdhY290aCcpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBTeW1ib2wuaW5maW5pdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGV2YWx1YXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZGl2aWRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKF8uZGl2aWRlKF8uYWRkKHN5bWJvbC5jbG9uZSgpLCBuZXcgU3ltYm9sKDEpKSwgXy5zdWJ0cmFjdChzeW1ib2wuY2xvbmUoKSwgbmV3IFN5bWJvbCgxKSkpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTeW1ib2woMikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdhY290aCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL2xpc3Qgb2Ygc3VwcG9ydGVkIHVuaXRzXHJcbiAgICAgICAgdGhpcy51bml0cyA9IHt9O1xyXG4gICAgICAgIC8vbGlzdCBhbGwgdGhlIHN1cHBvcnRlZCBvcGVyYXRvcnNcclxuICAgICAgICB2YXIgb3BlcmF0b3JzID0ge1xyXG4gICAgICAgICAgICAnXFxcXCc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDgsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ1xcXFwnLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnc2xhc2gnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7IC8vYnlwYXNzIHRoZSBzbGFzaFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnISEnOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiA3LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICchIScsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdkZmFjdG9yaWFsJyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKFNldHRpbmdzLkRPVUJMRUZBQ1RPUklBTCwgW2VdKTsgLy93cmFwIGl0IGluIGEgZmFjdG9yaWFsIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICchJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogNyxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnIScsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdmYWN0b3JpYWwnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhY3RvcmlhbChlKTsgLy93cmFwIGl0IGluIGEgZmFjdG9yaWFsIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdeJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogNixcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnXicsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdwb3cnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcqKic6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDYsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJyoqJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3BvdycsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJyUnOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiA0LFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICclJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3BlcmNlbnQnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvdmVybG9hZGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxvYWRBY3Rpb246ICdtb2QnLFxyXG4gICAgICAgICAgICAgICAgb3ZlcmxvYWRMZWZ0QXNzb2M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZSh4LCBuZXcgU3ltYm9sKDEwMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnKic6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDQsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJyonLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbXVsdGlwbHknLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLyc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDQsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJy8nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnZGl2aWRlJyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogZmFsc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJysnOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAzLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICcrJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2FkZCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdwbHVzJzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMyxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAncGx1cycsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdhZGQnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLSc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDMsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJy0nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnc3VidHJhY3QnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnPSc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDIsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJz0nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnZXF1YWxzJyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogZmFsc2VcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJz09Jzoge1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogMSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnPT0nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnZXEnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnPCc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDEsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJzwnLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbHQnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnPD0nOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICc8PScsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdsdGUnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnPic6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDEsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJz4nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnZ3QnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnPT4nOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAxLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICc9PicsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdndGUnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnLCc6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDAsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJywnLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnY29tbWEnLFxyXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnOic6IHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDAsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJywnLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnYXNzaWduJyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2ZWN0b3JGbjogJ3NsaWNlJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnOj0nOiB7XHJcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlOiAwLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICcsJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2Z1bmN0aW9uX2Fzc2lnbicsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgcG9zdGZpeDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBsZWZ0QXNzb2M6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9icmFja2V0c1xyXG4gICAgICAgIHZhciBicmFja2V0cyA9IHtcclxuICAgICAgICAgICAgJygnOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAncm91bmQnLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDEsXHJcbiAgICAgICAgICAgICAgICBpc19vcGVuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaXNfY2xvc2U6IGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcpJzoge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3JvdW5kJyxcclxuICAgICAgICAgICAgICAgIGlkOiAyLFxyXG4gICAgICAgICAgICAgICAgaXNfb3BlbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc19jbG9zZTogdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnWyc6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzcXVhcmUnLFxyXG4gICAgICAgICAgICAgICAgaWQ6IDMsXHJcbiAgICAgICAgICAgICAgICBpc19vcGVuOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaXNfY2xvc2U6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbWFwc190bzogJ3ZlY3RvcidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ10nOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3F1YXJlJyxcclxuICAgICAgICAgICAgICAgIGlkOiA0LFxyXG4gICAgICAgICAgICAgICAgaXNfb3BlbjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBpc19jbG9zZTogdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAneyc6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdjdXJseScsXHJcbiAgICAgICAgICAgICAgICBpZDogNSxcclxuICAgICAgICAgICAgICAgIGlzX29wZW46IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpc19jbG9zZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBtYXBzX3RvOiAnU2V0J1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnfSc6IHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdjdXJseScsXHJcbiAgICAgICAgICAgICAgICBpZDogNixcclxuICAgICAgICAgICAgICAgIGlzX29wZW46IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNfY2xvc2U6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU3VwcG9ydGVkIGZ1bmN0aW9ucy5cclxuICAgICAgICAvLyBGb3JtYXQ6IGZ1bmN0aW9uX25hbWU6IFttYXBwZWRfZnVuY3Rpb24sIG51bWJlcl9vZl9wYXJhbWV0ZXJzXVxyXG4gICAgICAgIHZhciBmdW5jdGlvbnMgPSB0aGlzLmZ1bmN0aW9ucyA9IHtcclxuICAgICAgICAgICAgJ2Nvcyc6IFt0cmlnLmNvcywgMV0sXHJcbiAgICAgICAgICAgICdzaW4nOiBbdHJpZy5zaW4sIDFdLFxyXG4gICAgICAgICAgICAndGFuJzogW3RyaWcudGFuLCAxXSxcclxuICAgICAgICAgICAgJ3NlYyc6IFt0cmlnLnNlYywgMV0sXHJcbiAgICAgICAgICAgICdjc2MnOiBbdHJpZy5jc2MsIDFdLFxyXG4gICAgICAgICAgICAnY290JzogW3RyaWcuY290LCAxXSxcclxuICAgICAgICAgICAgJ2Fjb3MnOiBbdHJpZy5hY29zLCAxXSxcclxuICAgICAgICAgICAgJ2FzaW4nOiBbdHJpZy5hc2luLCAxXSxcclxuICAgICAgICAgICAgJ2F0YW4nOiBbdHJpZy5hdGFuLCAxXSxcclxuICAgICAgICAgICAgJ2FyY2Nvcyc6IFt0cmlnLmFjb3MsIDFdLFxyXG4gICAgICAgICAgICAnYXJjc2luJzogW3RyaWcuYXNpbiwgMV0sXHJcbiAgICAgICAgICAgICdhcmN0YW4nOiBbdHJpZy5hdGFuLCAxXSxcclxuICAgICAgICAgICAgJ2FzZWMnOiBbdHJpZy5hc2VjLCAxXSxcclxuICAgICAgICAgICAgJ2Fjc2MnOiBbdHJpZy5hY3NjLCAxXSxcclxuICAgICAgICAgICAgJ2Fjb3QnOiBbdHJpZy5hY290LCAxXSxcclxuICAgICAgICAgICAgJ2F0YW4yJzogW3RyaWcuYXRhbjIsIDJdLFxyXG4gICAgICAgICAgICAnYWNvdGgnOiBbdHJpZ2guYWNvdGgsIDFdLFxyXG4gICAgICAgICAgICAnYXNlY2gnOiBbdHJpZ2guYXNlY2gsIDFdLFxyXG4gICAgICAgICAgICAnYWNzY2gnOiBbdHJpZ2guYWNzY2gsIDFdLFxyXG4gICAgICAgICAgICAnc2luaCc6IFt0cmlnaC5zaW5oLCAxXSxcclxuICAgICAgICAgICAgJ2Nvc2gnOiBbdHJpZ2guY29zaCwgMV0sXHJcbiAgICAgICAgICAgICd0YW5oJzogW3RyaWdoLnRhbmgsIDFdLFxyXG4gICAgICAgICAgICAnYXNpbmgnOiBbdHJpZ2guYXNpbmgsIDFdLFxyXG4gICAgICAgICAgICAnc2VjaCc6IFt0cmlnaC5zZWNoLCAxXSxcclxuICAgICAgICAgICAgJ2NzY2gnOiBbdHJpZ2guY3NjaCwgMV0sXHJcbiAgICAgICAgICAgICdjb3RoJzogW3RyaWdoLmNvdGgsIDFdLFxyXG4gICAgICAgICAgICAnYWNvc2gnOiBbdHJpZ2guYWNvc2gsIDFdLFxyXG4gICAgICAgICAgICAnYXRhbmgnOiBbdHJpZ2guYXRhbmgsIDFdLFxyXG4gICAgICAgICAgICAnbG9nMTAnOiBbLCAxXSxcclxuICAgICAgICAgICAgJ2V4cCc6IFtleHAsIDFdLFxyXG4gICAgICAgICAgICAncmFkaWFucyc6IFtyYWRpYW5zLCAxXSxcclxuICAgICAgICAgICAgJ2RlZ3JlZXMnOiBbZGVncmVlcywgMV0sXHJcbiAgICAgICAgICAgICdtaW4nOiBbbWluLCAtMV0sXHJcbiAgICAgICAgICAgICdtYXgnOiBbbWF4LCAtMV0sXHJcbiAgICAgICAgICAgICdlcmYnOiBbLCAxXSxcclxuICAgICAgICAgICAgJ2Zsb29yJzogWywgMV0sXHJcbiAgICAgICAgICAgICdjZWlsJzogWywgMV0sXHJcbiAgICAgICAgICAgICd0cnVuYyc6IFssIDFdLFxyXG4gICAgICAgICAgICAnU2knOiBbLCAxXSxcclxuICAgICAgICAgICAgJ3N0ZXAnOiBbLCAxXSxcclxuICAgICAgICAgICAgJ3JlY3QnOiBbLCAxXSxcclxuICAgICAgICAgICAgJ3NpbmMnOiBbc2luYywgMV0sXHJcbiAgICAgICAgICAgICd0cmknOiBbLCAxXSxcclxuICAgICAgICAgICAgJ3NpZ24nOiBbc2lnbiwgMV0sXHJcbiAgICAgICAgICAgICdDaSc6IFssIDFdLFxyXG4gICAgICAgICAgICAnRWknOiBbLCAxXSxcclxuICAgICAgICAgICAgJ1NoaSc6IFssIDFdLFxyXG4gICAgICAgICAgICAnQ2hpJzogWywgMV0sXHJcbiAgICAgICAgICAgICdMaSc6IFssIDFdLFxyXG4gICAgICAgICAgICAnZmliJzogWywgMV0sXHJcbiAgICAgICAgICAgICdmYWN0JzogW2ZhY3RvcmlhbCwgMV0sXHJcbiAgICAgICAgICAgICdmYWN0b3JpYWwnOiBbZmFjdG9yaWFsLCAxXSxcclxuICAgICAgICAgICAgJ2NvbnRpbnVlZF9mcmFjdGlvbic6IFtjb250aW51ZWRfZnJhY3Rpb24sIFsxLCAyXV0sXHJcbiAgICAgICAgICAgICdkZmFjdG9yaWFsJzogWywgMV0sXHJcbiAgICAgICAgICAgICdnYW1tYV9pbmNvbXBsZXRlJzogWywgWzEsIDJdXSxcclxuICAgICAgICAgICAgJ3JvdW5kJzogW3JvdW5kLCBbMSwgMl1dLFxyXG4gICAgICAgICAgICAnc2NpZW50aWZpYyc6IFtzY2llbnRpZmljLCBbMSwgMl1dLFxyXG4gICAgICAgICAgICAnbW9kJzogW21vZCwgMl0sXHJcbiAgICAgICAgICAgICdwZmFjdG9yJzogW3BmYWN0b3IsIDFdLFxyXG4gICAgICAgICAgICAndmVjdG9yJzogW3ZlY3RvciwgLTFdLFxyXG4gICAgICAgICAgICAnbWF0cml4JzogW21hdHJpeCwgLTFdLFxyXG4gICAgICAgICAgICAnU2V0JzogW3NldCwgLTFdLFxyXG4gICAgICAgICAgICAnaW1hdHJpeCc6IFtpbWF0cml4LCAtMV0sXHJcbiAgICAgICAgICAgICdwYXJlbnMnOiBbcGFyZW5zLCAtMV0sXHJcbiAgICAgICAgICAgICdzcXJ0JzogW3NxcnQsIDFdLFxyXG4gICAgICAgICAgICAnY2JydCc6IFtjYnJ0LCAxXSxcclxuICAgICAgICAgICAgJ250aHJvb3QnOiBbbnRocm9vdCwgMl0sXHJcbiAgICAgICAgICAgICdsb2cnOiBbbG9nLCBbMSwgMl1dLFxyXG4gICAgICAgICAgICAnZXhwYW5kJzogW2V4cGFuZGFsbCwgMV0sXHJcbiAgICAgICAgICAgICdhYnMnOiBbYWJzLCAxXSxcclxuICAgICAgICAgICAgJ2ludmVydCc6IFtpbnZlcnQsIDFdLFxyXG4gICAgICAgICAgICAnZGV0ZXJtaW5hbnQnOiBbZGV0ZXJtaW5hbnQsIDFdLFxyXG4gICAgICAgICAgICAnc2l6ZSc6IFtzaXplLCAxXSxcclxuICAgICAgICAgICAgJ3RyYW5zcG9zZSc6IFt0cmFuc3Bvc2UsIDFdLFxyXG4gICAgICAgICAgICAnZG90JzogW2RvdCwgMl0sXHJcbiAgICAgICAgICAgICdjcm9zcyc6IFtjcm9zcywgMl0sXHJcbiAgICAgICAgICAgICd2ZWNnZXQnOiBbdmVjZ2V0LCAyXSxcclxuICAgICAgICAgICAgJ3ZlY3NldCc6IFt2ZWNzZXQsIDNdLFxyXG4gICAgICAgICAgICAndmVjdHJpbSc6IFt2ZWN0cmltLCBbMSwgMl1dLFxyXG4gICAgICAgICAgICAnbWF0Z2V0JzogW21hdGdldCwgM10sXHJcbiAgICAgICAgICAgICdtYXRzZXQnOiBbbWF0c2V0LCA0XSxcclxuICAgICAgICAgICAgJ21hdGdldHJvdyc6IFttYXRnZXRyb3csIDJdLFxyXG4gICAgICAgICAgICAnbWF0c2V0cm93JzogW21hdHNldHJvdywgM10sXHJcbiAgICAgICAgICAgICdtYXRnZXRjb2wnOiBbbWF0Z2V0Y29sLCAyXSxcclxuICAgICAgICAgICAgJ21hdHNldGNvbCc6IFttYXRzZXRjb2wsIDNdLFxyXG4gICAgICAgICAgICAncmF0aW9uYWxpemUnOiBbcmF0aW9uYWxpemUsIDFdLFxyXG4gICAgICAgICAgICAnSUYnOiBbSUYsIDNdLFxyXG4gICAgICAgICAgICAnaXNfaW4nOiBbaXNfaW4sIDJdLFxyXG4gICAgICAgICAgICAvL2ltYWdpbmFyeSBzdXBwb3J0XHJcbiAgICAgICAgICAgICdyZWFscGFydCc6IFtyZWFscGFydCwgMV0sXHJcbiAgICAgICAgICAgICdpbWFncGFydCc6IFtpbWFncGFydCwgMV0sXHJcbiAgICAgICAgICAgICdjb25qdWdhdGUnOiBbY29uanVnYXRlLCAxXSxcclxuICAgICAgICAgICAgJ2FyZyc6IFthcmcsIDFdLFxyXG4gICAgICAgICAgICAncG9sYXJmb3JtJzogW3BvbGFyZm9ybSwgMV0sXHJcbiAgICAgICAgICAgICdyZWN0Zm9ybSc6IFtyZWN0Zm9ybSwgMV0sXHJcbiAgICAgICAgICAgICdzb3J0JzogW3NvcnQsIFsxLCAyXV0sXHJcbiAgICAgICAgICAgICdpbnRlZ2VyX3BhcnQnOiBbLCAxXSxcclxuICAgICAgICAgICAgJ3VuaW9uJzogW3VuaW9uLCAyXSxcclxuICAgICAgICAgICAgJ2NvbnRhaW5zJzogW2NvbnRhaW5zLCAyXSxcclxuICAgICAgICAgICAgJ2ludGVyc2VjdGlvbic6IFtpbnRlcnNlY3Rpb24sIDJdLFxyXG4gICAgICAgICAgICAnZGlmZmVyZW5jZSc6IFtkaWZmZXJlbmNlLCAyXSxcclxuICAgICAgICAgICAgJ2ludGVyc2VjdHMnOiBbaW50ZXJzZWN0cywgMl0sXHJcbiAgICAgICAgICAgICdpc19zdWJzZXQnOiBbaXNfc3Vic2V0LCAyXSxcclxuICAgICAgICAgICAgLy9zeXN0ZW0gc3VwcG9ydFxyXG4gICAgICAgICAgICAncHJpbnQnOiBbcHJpbnQsIC0xXVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vZXJyb3IgaGFuZGxlclxyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnI7XHJcbiAgICAgICAgLy90aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29tYiB0aHJvdWdoIHRoZSBmdW5jdGlvbiBtb2R1bGVzIGFuZCBmaW5kIGEgZnVuY3Rpb24gZ2l2ZW4gaXRzIG5hbWVcclxuICAgICAgICB2YXIgZmluZEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZuYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBmbW9kdWxlcyA9IFNldHRpbmdzLkZVTkNUSU9OX01PRFVMRVMsXHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IGZtb2R1bGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZtb2R1bGUgPSBmbW9kdWxlc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKGZuYW1lIGluIGZtb2R1bGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZtb2R1bGVbZm5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycignVGhlIGZ1bmN0aW9uICcgKyBmbmFtZSArICcgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGdpdmVzIHRoZSBhYmlsaXR5IHRvIG92ZXJyaWRlIG9wZXJhdG9ycyB3aXRoIG5ldyBtZXRob2RzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aGljaFxyXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdpdGhfd2hhdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3ZlcnJpZGUgPSBmdW5jdGlvbiAod2hpY2gsIHdpdGhfd2hhdCkge1xyXG4gICAgICAgICAgICBpZighYmluW3doaWNoXSlcclxuICAgICAgICAgICAgICAgIGJpblt3aGljaF0gPSBbXTtcclxuICAgICAgICAgICAgYmluW3doaWNoXS5wdXNoKHRoaXNbd2hpY2hdKTtcclxuICAgICAgICAgICAgdGhpc1t3aGljaF0gPSB3aXRoX3doYXQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzdG9yZXMgYSBwcmV2aW91c2x5IG92ZXJyaWRkZW4gb3BlcmF0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2hhdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVzdG9yZSA9IGZ1bmN0aW9uICh3aGF0KSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXNbd2hhdF0pXHJcbiAgICAgICAgICAgICAgICB0aGlzW3doYXRdID0gYmluW3doYXRdLnBvcCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHN1cHBvc2VkIHRvIGJlaGF2ZSBzaW1pbGFybHkgdG8gdGhlIG92ZXJyaWRlIG1ldGhvZCBidXQgaXQgZG9lcyBub3Qgb3ZlcnJpZGVcclxuICAgICAgICAgKiB0aGUgZXhpc3RpbmcgZnVuY3Rpb24gcmF0aGVyIGl0IG9ubHkgZXh0ZW5kcyBpdFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB3aGF0XHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd2l0aF93aGF0XHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZV9jYWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5leHRlbmQgPSBmdW5jdGlvbiAod2hhdCwgd2l0aF93aGF0LCBmb3JjZV9jYWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBfID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZCA9IHRoaXNbd2hhdF07XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBleHRlbmRlZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygd2l0aF93aGF0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IHRoaXNbd2hhdF07XHJcbiAgICAgICAgICAgICAgICB0aGlzW3doYXRdID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihpc1N5bWJvbChhKSAmJiBpc1N5bWJvbChiKSAmJiAhZm9yY2VfY2FsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYuY2FsbChfLCBhLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aXRoX3doYXQuY2FsbChfLCBhLCBiLCBmKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmF0ZXMgbGlicmFyeSdzIHJlcHJlc2VudGF0aW9uIG9mIGEgZnVuY3Rpb24uIEl0J3MgYSBmYW5jeSB3YXkgb2Ygc2F5aW5nIGEgc3ltYm9sIHdpdGhcclxuICAgICAgICAgKiBhIGZldyBleHRyYXMuIFRoZSBtb3N0IGltcG9ydGFudCB0aGluZyBpcyB0aGF0IHRoYXQgaXQgZ2l2ZXMgYSBmbmFtZSBhbmRcclxuICAgICAgICAgKiBhbiBhcmdzIHByb3BlcnR5IHRvIHRoZSBzeW1ib2xzIGluIGFkZGl0aW9uIHRvIGNoYW5naW5nIGl0cyBncm91cCB0byBGTlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbl9uYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN5bWZ1bmN0aW9uID0gZnVuY3Rpb24gKGZuX25hbWUsIHBhcmFtcykge1xyXG4gICAgICAgICAgICAvL2NhbGwgdGhlIHByb3BlciBmdW5jdGlvbiBhbmQgcmV0dXJuIHRoZSByZXN1bHQ7XHJcbiAgICAgICAgICAgIHZhciBmID0gbmV3IFN5bWJvbChmbl9uYW1lKTtcclxuICAgICAgICAgICAgZi5ncm91cCA9IEZOO1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtdLnNsaWNlLmNhbGwocGFyYW1zKTsvL2Vuc3VyZSBhbiBhcnJheVxyXG4gICAgICAgICAgICBmLmFyZ3MgPSBwYXJhbXM7XHJcbiAgICAgICAgICAgIGYuZm5hbWUgPSBmbl9uYW1lID09PSBQQVJFTlRIRVNJUyA/ICcnIDogZm5fbmFtZTtcclxuICAgICAgICAgICAgZi51cGRhdGVIYXNoKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGludGVybmFsIGZ1bmN0aW9uIGNhbGwgZm9yIHRoZSBQYXJzZXIuIFRoaXMgd2lsbCBlaXRoZXIgdHJpZ2dlciBhIHJlYWxcclxuICAgICAgICAgKiBmdW5jdGlvbiBjYWxsIGlmIGl0IGNhbiBkbyBzbyBvciBqdXN0IHJldHVybiBhIHN5bWJvbGljIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxyXG4gICAgICAgICAqIGZ1bmN0aW9uIHVzaW5nIHN5bWZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBmbl9uYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJnc1xyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBhbGxvd2VkX2FyZ3NcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FsbGZ1bmN0aW9uID0gZnVuY3Rpb24gKGZuX25hbWUsIGFyZ3MsIGFsbG93ZWRfYXJncykge1xyXG4gICAgICAgICAgICB2YXIgZm5fc2V0dGluZ3MgPSBmdW5jdGlvbnNbZm5fbmFtZV07XHJcblxyXG4gICAgICAgICAgICBpZighZm5fc2V0dGluZ3MpXHJcbiAgICAgICAgICAgICAgICBlcnIoJ05lcmRhbWVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBmdW5jdGlvbiAnICsgZm5fbmFtZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbnVtX2FsbG93ZWRfYXJncyA9IGZuX3NldHRpbmdzWzFdIHx8IGFsbG93ZWRfYXJncywgLy9nZXQgdGhlIG51bWJlciBvZiBhbGxvd2VkIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gZm5fc2V0dGluZ3NbMF0sIC8vZ2V0IHRoZSBtYXBwZWQgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICByZXR2YWw7XHJcbiAgICAgICAgICAgIC8vV2Ugd2FudCB0byBiZSBhYmxlIHRvIGNhbGwgYXBwbHkgb24gdGhlIGFyZ3VtZW50cyBvciBjcmVhdGUgYSBzeW1mdW5jdGlvbi4gQm90aCByZXF1aXJlXHJcbiAgICAgICAgICAgIC8vYW4gYXJyYXkgc28gbWFrZSBzdXJlIHRvIHdyYXAgdGhlIGFyZ3VtZW50IGluIGFuIGFycmF5LlxyXG4gICAgICAgICAgICBpZighKGFyZ3MgaW5zdGFuY2VvZiBBcnJheSkpXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJncyAhPT0gdW5kZWZpbmVkID8gW2FyZ3NdIDogW107XHJcblxyXG4gICAgICAgICAgICBpZihudW1fYWxsb3dlZF9hcmdzICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzX2FycmF5ID0gaXNBcnJheShudW1fYWxsb3dlZF9hcmdzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluX2FyZ3MgPSBpc19hcnJheSA/IG51bV9hbGxvd2VkX2FyZ3NbMF0gOiBudW1fYWxsb3dlZF9hcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhfYXJncyA9IGlzX2FycmF5ID8gbnVtX2FsbG93ZWRfYXJnc1sxXSA6IG51bV9hbGxvd2VkX2FyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bV9hcmdzID0gYXJncy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yX21zZyA9IGZuX25hbWUgKyAnIHJlcXVpcmVzIGEgezB9IG9mIHsxfSBhcmd1bWVudHMuIHsyfSBwcm92aWRlZCEnO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKG51bV9hcmdzIDwgbWluX2FyZ3MpXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyKGZvcm1hdChlcnJvcl9tc2csICdtaW5pbXVtJywgbWluX2FyZ3MsIG51bV9hcmdzKSk7XHJcbiAgICAgICAgICAgICAgICBpZihudW1fYXJncyA+IG1heF9hcmdzKVxyXG4gICAgICAgICAgICAgICAgICAgIGVycihmb3JtYXQoZXJyb3JfbXNnLCAnbWF4aW11bScsIG1heF9hcmdzLCBudW1fYXJncykpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBUaGUgZm9sbG93aW5nIGFyZSB2ZXJ5IGltcG9ydGFudCB0byB0aGUgaG93IG5lcmRhbWVyIGNvbnN0cnVjdHMgZnVuY3Rpb25zIVxyXG4gICAgICAgICAgICAgKiBBc3N1bXB0aW9uIDEgLSBpZiBmbiBpcyB1bmRlZmluZWQgdGhlbiBoYW5kbGluZyBvZiB0aGUgZnVuY3Rpb24gaXMgcHVyZWx5IG51bWVyaWMuIFRoaXNcclxuICAgICAgICAgICAgICogICAgIGVuYWJsZXMgdXMgdG8gcmV1c2UgTWF0aCwgTWF0aDIsIC4uLiwgYW55IGZ1bmN0aW9uIGZyb20gU2V0dGluZ3MuRlVOQ1RJT05TX01PRFVMRVMgZW50cnlcclxuICAgICAgICAgICAgICogQXNzdW1wdGlvbiAyIC0gaWYgZm4gaXMgZGVmaW5lZCB0aGVuIHRoYXQgZnVuY3Rpb24gdGFrZXMgY2FyZSBvZiBFVkVSWVRISU5HIGluY2x1ZGluZyBzeW1ib2xpY3NcclxuICAgICAgICAgICAgICogQXNzdW1wdGlvbiAzIC0gaWYgdGhlIHVzZXIgY2FsbHMgc3ltYm9saWNzIG9uIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbnVtZXJpYyB2YWx1ZSB0aGVuXHJcbiAgICAgICAgICAgICAqICAgICB0aGV5IGFyZSBleHBlY3RpbmcgYSBzeW1ib2xpYyBvdXRwdXQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvL2NoZWNrIGlmIGFyZ3VtZW50cyBhcmUgYWxsIG51bWVyc1xyXG4gICAgICAgICAgICB2YXIgbnVtZXJpY0FyZ3MgPSBhbGxOdW1iZXJzKGFyZ3MpO1xyXG4gICAgICAgICAgICAvL0JpZyBudW1iZXIgc3VwcG9ydC4gQ2hlY2sgaWYgQmlnIG51bWJlciBpcyByZXF1ZXN0ZWQgYW5kIHRoZSBhcmd1bWVudHMgYXJlIGFsbCBudW1lcmljIGFuZCwgbm90IGltYWdpbmFyeVxyXG4vLyAgICAgICAgICAgIGlmIChTZXR0aW5ncy5VU0VfQklHICYmIG51bWVyaWNBcmdzKSB7XHJcbi8vICAgICAgICAgICAgICAgIHJldHZhbCA9IEJpZ1tmbl9uYW1lXS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xyXG4vLyAgICAgICAgICAgIH1cclxuLy8gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYoIWZuKSB7XHJcbiAgICAgICAgICAgICAgICAvL1JlbWVtYmVyIGFzc3VtcHRpb24gMS4gTm8gZnVuY3Rpb24gZGVmaW5lZCBzbyBpdCBNVVNUIGJlIG51bWVyaWMgaW4gbmF0dXJlXHJcbiAgICAgICAgICAgICAgICBmbiA9IGZpbmRGdW5jdGlvbihmbl9uYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUiAmJiBudW1lcmljQXJncylcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBiaWdDb252ZXJ0KGZuLmFwcGx5KGZuLCBhcmdzKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5zeW1mdW5jdGlvbihmbl9uYW1lLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vUmVtZW1iZXIgYXNzdW1wdGlvbiAyLiBUaGUgZnVuY3Rpb24gaXMgZGVmaW5lZCBzbyBpdCBNVVNUIGhhbmRsZSBhbGwgYXNwZWN0cyBpbmNsdWRpbmcgbnVtZXJpYyB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IGZuLmFwcGx5KGZuX3NldHRpbmdzWzJdLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZCBhIHJlZ2V4IGJhc2VkIG9uIHRoZSBvcGVyYXRvcnMgY3VycmVudGx5IGxvYWRlZC4gVGhlc2Ugb3BlcmF0b3JzIGFyZSB0byBiZSBpZ25vcmVkIHdoZW5cclxuICAgICAgICAgKiBzdWJzdGl0dXRpbmcgc3BhY2VzIGZvciBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3BlcmF0b3JfZmlsdGVyX3JlZ2V4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy93ZSBvbmx5IHdhbnQgdGhlIG9wZXJhdG9ycyB3aGljaCBhcmUgc2luZ3VsYXIgc2luY2UgdGhvc2UgYXJlIHRoZSBvbmVzXHJcbiAgICAgICAgICAgIC8vdGhhdCBuZXJkYW1lciB1c2VzIGFueXdheVxyXG4gICAgICAgICAgICB2YXIgb3N0ciA9ICdeXFxcXCcgKyBPYmplY3Qua2V5cyhvcGVyYXRvcnMpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgaWYoeC5sZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICAgIH0pLmpvaW4oJ1xcXFwnKTtcclxuICAgICAgICAgICAgLy9jcmVhdGUgYSByZWdleCB3aGljaCBjYXB0dXJlcyBhbGwgc3BhY2VzIGJldHdlZW4gY2hhcmFjdGVycyBleGNlcHQgdGhvc2VcclxuICAgICAgICAgICAgLy9oYXZlIGFuIG9wZXJhdG9yIG9uIG9uZSBlbmRcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJyhbJyArIG9zdHIgKyAnXSlcXFxccysoWycgKyBvc3RyICsgJ10pJyk7XHJcbiAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVwbGFjZXMgbmVyZGFtZXIuc2V0T3BlcmF0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3BlcmF0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNoaWZ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zZXRPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvciwgYWN0aW9uLCBzaGlmdCkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9wZXJhdG9yLm9wZXJhdG9yOyAvL3Rha2UgdGhlIG5hbWUgdG8gYmUgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICBvcGVyYXRvcnNbbmFtZV0gPSBvcGVyYXRvcjtcclxuICAgICAgICAgICAgaWYoYWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgdGhpc1tvcGVyYXRvci5hY3Rpb25dID0gYWN0aW9uO1xyXG4gICAgICAgICAgICAvL21ha2UgdGhlIHBhcnNlciBhd2FyZSBvZiB0aGUgb3BlcmF0b3JcclxuICAgICAgICAgICAgX1tuYW1lXSA9IG9wZXJhdG9yLm9wZXJhdGlvbjtcclxuICAgICAgICAgICAgLy9tYWtlIHRoZSBhY3Rpb24gYXZhaWxhYmxlIHRvIHRoZSBwYXJzZXIgaWYgaW5maXhcclxuICAgICAgICAgICAgaWYoIW9wZXJhdG9yLmFjdGlvbiAmJiAhKG9wZXJhdG9yLnByZWZpeCB8fCBvcGVyYXRvci5wb3N0aWYpKSB7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvci5hY3Rpb24gPSBuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vaWYgdGhpcyBvcGVyYXRvciBpcyBleGNsdXNpdmUgdGhlbiBhbGwgc3VjY2Vzc2l2ZSBvcGVyYXRvcnMgc2hvdWxkIGJlIHNoaWZ0ZWRcclxuICAgICAgICAgICAgaWYoc2hpZnQgPT09ICdvdmVyJyB8fCBzaGlmdCA9PT0gJ3VuZGVyJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZWNlZGVuY2UgPSBvcGVyYXRvci5wcmVjZWRlbmNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBvcGVyYXRvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG9wZXJhdG9yc1t4XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gc2hpZnQgPT09ICdvdmVyJyA/IG8ucHJlY2VkZW5jZSA+PSBwcmVjZWRlbmNlIDogby5wcmVjZWRlbmNlID4gcHJlY2VkZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjb25kaXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG8ucHJlY2VkZW5jZSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBhbiBvcGVyZXJhdG9yIGJ5IGl0cyBzeW1ib2xcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3BlcmF0b3JcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ2V0T3BlcmF0b3IgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yc1tvcGVyYXRvcl07XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5hbGlhc09wZXJhdG9yID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gb3BlcmF0b3JzW29dO1xyXG4gICAgICAgICAgICAvL2NvcHkgZXZlcnl0aGluZyBvdmVyIHRvIHRoZSBuZXcgb3BlcmF0b3JcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0W3hdID0gb3BlcmF0b3JbeF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy91cGRhdGUgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICB0Lm9wZXJhdG9yID0gbjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0T3BlcmF0b3IodCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBvcGVyYXRvcnMuIENhdXRpb24hIENhbiBicmVhayBwYXJzZXIhXHJcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdldE9wZXJhdG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy93aWxsIHJlcGxhY2UgdGhpcyB3aXRoIHNvbWUgY2xvbmluZyBhY3Rpb24gaW4gdGhlIGZ1dHVyZVxyXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3JzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0QnJhY2tldHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBicmFja2V0cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUHJlZm9ybXMgcHJlcHJvY2Vzc2luZyBvbiB0aGUgc3RyaW5nLiBVc2VmdWwgZm9yIG1ha2luZyBlYXJseSBtb2RpZmljYXRpb24gYmVmb3JlXHJcbiAgICAgICAgICogc2VuZGluZyB0byB0aGUgcGFyc2VyXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgcHJlcGFyZV9leHByZXNzaW9uID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogU2luY2UgdmFyaWFibGVzIGNhbm5vdCBzdGFydCB3aXRoIGEgbnVtYmVyLCB0aGUgYXNzdW1wdGlvbiBpcyBtYWRlIHRoYXQgd2hlbiB0aGlzIG9jY3VycyB0aGVcclxuICAgICAgICAgICAgICogdXNlciBpbnRlbnRzIGZvciB0aGlzIHRvIGJlIGEgY29lZmZpY2llbnQuIFRoZSBtdWx0aXBsaWNhdGlvbiBzeW1ib2wgaW4gdGhlbiBhZGRlZC4gVGhlIHNhbWUgZ29lcyBmb3JcclxuICAgICAgICAgICAgICogYSBzaWRlLWJ5LXNpZGUgY2xvc2UgYW5kIG9wZW4gcGFyZW50aGVzaXNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGUgPSBTdHJpbmcoZSk7XHJcbiAgICAgICAgICAgIC8vYXBwbHkgcHJlcHJvY2Vzc29yc1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJlcHJvY2Vzc29ycy5hY3Rpb25zLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgZSA9IHByZXByb2Nlc3NvcnMuYWN0aW9uc1tpXS5jYWxsKHRoaXMsIGUpO1xyXG5cclxuICAgICAgICAgICAgLy9lID0gZS5zcGxpdCgnICcpLmpvaW4oJycpOy8vc3RyaXAgZW1wdHkgc3BhY2VzXHJcbiAgICAgICAgICAgIC8vcmVwbGFjZSBtdWx0aXBsZSBzcGFjZXMgd2l0aCBvbmUgc3BhY2VcclxuICAgICAgICAgICAgZSA9IGUucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xyXG5cclxuICAgICAgICAgICAgLy9vbmx5IGV2ZW4gYm90aGVyIHRvIGNoZWNrIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgZS4gVGhpcyByZWdleCBpcyBwYWluZnVsbHkgc2xvdyBhbmQgbWlnaHQgbmVlZCBhIGJldHRlciBzb2x1dGlvbi4gZS5nLiBoYW5ncyBvbiAoMC4wNi8zNjUwKSleKDM2NSlcclxuICAgICAgICAgICAgaWYoL2UvZ2kudGVzdChlKSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGUucmVwbGFjZSgvXFwtKlxcZCtcXC4qXFxkKmVcXCs/XFwtP1xcZCsvZ2ksIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjaWVudGlmaWNUb0RlY2ltYWwoeCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3JlcGxhY2Ugc2NpZW50aWZpYyBudW1iZXJzXHJcblxyXG4gICAgICAgICAgICAvL2FsbG93IG9taXNzaW9uIG9mIG11bHRpcGxpY2F0aW9uIGFmdGVyIGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAgICBlID0gZS5yZXBsYWNlKFNldHRpbmdzLklNUExJRURfTVVMVElQTElDQVRJT05fUkVHRVgsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHIgPSBhcmd1bWVudHNbNF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwMSA9IGFyZ3VtZW50c1sxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAyID0gYXJndW1lbnRzWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGFyZ3VtZW50c1szXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBzdHIuY2hhckF0KHN0YXJ0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAnKic7XHJcbiAgICAgICAgICAgICAgICBpZighZmlyc3QubWF0Y2goL1tcXCtcXC1cXC9cXCpdLykpXHJcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gc3RyLmNoYXJBdChzdGFydCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYoYmVmb3JlLm1hdGNoKC9bYS16XS9pKSlcclxuICAgICAgICAgICAgICAgICAgICBkID0gJyc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXAxICsgZCArIGdyb3VwMjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFthLXowLTlfXSspL2dpLCBmdW5jdGlvbiAobWF0Y2gsIGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuVVNFX01VTFRJQ0hBUkFDVEVSX1ZBUlMgPT09IGZhbHNlICYmICEoYSBpbiBmdW5jdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighaXNOYU4oYSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5zcGxpdCgnJykuam9pbignKicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hbGxvdyBvbWlzc2lvbiBvZiBtdWx0aXBsaWNhdGlvbiBzaWduIGJldHdlZW4gYnJhY2tldHNcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwpXFwoL2csICcpKignKSB8fCAnMCc7XHJcbiAgICAgICAgICAgIC8vcmVwbGFjZSB4KHgrYSkgd2l0aCB4Kih4K2EpXHJcbiAgICAgICAgICAgIHdoaWxlKHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlX29yZyA9IGU7IC8vc3RvcmUgdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgICAgICAgICBlID0gZS5yZXBsYWNlKC8oW2EtejAtOV9dKykoXFwoKXwoXFwpKShbYS16MC05XSspL2dpLCBmdW5jdGlvbiAobWF0Y2gsIGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZzEgPSBhIHx8IGMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnMiA9IGIgfHwgZDtcclxuICAgICAgICAgICAgICAgICAgICBpZihnMSBpbiBmdW5jdGlvbnMpIC8vY3JlYXRlIGEgcGFzc3Rocm91Z2ggZm9yIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZzEgKyBnMjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZzEgKyAnKicgKyBnMjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgb3JpZ2luYWwgZXF1YWxzIHRoZSByZXBsYWNlIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgIGlmKGVfb3JnID09PSBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9kZWxheSBzZXR0aW5nIG9mIGNvbnN0YW50cyB1bnRpbCBTZXR0aW5ncyBpcyByZWFkeVxyXG4gICAgICAgIHRoaXMuaW5pdENvbnN0YW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5DT05TVEFOVFMgPSB7XHJcbiAgICAgICAgICAgICAgICBFOiBuZXcgU3ltYm9sKFNldHRpbmdzLkUpLFxyXG4gICAgICAgICAgICAgICAgUEk6IG5ldyBTeW1ib2woU2V0dGluZ3MuUEkpXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIERlYnVnZ2luZyBtZXRob2QgdXNlZCB0byBiZXR0ZXIgdmlzdWFsaXplIHZlY3RvciBhbmQgYXJyYXlzXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJldHR5X3ByaW50ID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShvKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSBvLm1hcCh4ID0+IF8ucHJldHR5X3ByaW50KHgpKS5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgaWYoby50eXBlID09PSAndmVjdG9yJylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlY3RvcjwnICsgcyArICc+JztcclxuICAgICAgICAgICAgICAgIHJldHVybiAnKCcgKyBzICsgJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnBlZWtlcnMgPSB7XHJcbiAgICAgICAgICAgIHByZV9vcGVyYXRvcjogW10sXHJcbiAgICAgICAgICAgIHBvc3Rfb3BlcmF0b3I6IFtdLFxyXG4gICAgICAgICAgICBwcmVfZnVuY3Rpb246IFtdLFxyXG4gICAgICAgICAgICBwb3N0X2Z1bmN0aW9uOiBbXVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuY2FsbFBlZWtlcnMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICBpZihTZXR0aW5ncy5jYWxsUGVla2Vycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBlZWtlcnMgPSB0aGlzLnBlZWtlcnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSB0aGUgZmlyc3QgaXRlbXMgYW5kIHN0cmluZ2lmeVxyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMyQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKS5tYXAoc3RyaW5naWZ5KTtcclxuICAgICAgICAgICAgICAgIC8vY2FsbCBlYWNoIG9uZSBvZiB0aGUgcGVla2Vyc1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBlZWtlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwZWVrZXJzW2ldLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFRva2VuaXplcyB0aGUgc3RyaW5nXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7VG9rZW5bXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRva2VuaXplID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgLy9jYXN0IHRvIFN0cmluZ1xyXG4gICAgICAgICAgICBlID0gU3RyaW5nKGUpO1xyXG4gICAgICAgICAgICAvL3JlbW92ZSBtdWx0aXBsZSB3aGl0ZSBzcGFjZXMgYW5kIHNwYWNlcyBhdCBiZWdpbm5pbmcgYW5kIGVuZCBvZiBzdHJpbmdcclxuICAgICAgICAgICAgZSA9IGUudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcclxuICAgICAgICAgICAgLy9yZW1vdmUgc3BhY2VzIGJlZm9yZSBhbmQgYWZ0ZXIgYnJhY2tldHNcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIGJyYWNrZXRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKGJyYWNrZXRzW3hdLmlzX2Nsb3NlID8gJ1xcXFxzK1xcXFwnICsgeCA6ICdcXFxcJyArIHggKyAnXFxcXHMrJywgJ2cnKTtcclxuICAgICAgICAgICAgICAgIGUgPSBlLnJlcGxhY2UocmVnZXgsIHgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sID0gMDsgLy90aGUgY29sdW1uIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIHZhciBMID0gZS5sZW5ndGg7IC8vZXhwcmVzc2lvbiBsZW5ndGhcclxuICAgICAgICAgICAgdmFyIGxwb3MgPSAwOyAvL21hcmtzIGJlZ2lubmluZyBvZiBuZXh0IHRva2VuXHJcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSBbXTsgLy90aGUgdG9rZW5zIGNvbnRhaW5lclxyXG4gICAgICAgICAgICB2YXIgc2NvcGVzID0gW3Rva2Vuc107IC8vaW5pdGlhdGUgd2l0aCB0aGUgdG9rZW5zIGFzIHRoZSBoaWdoZXN0IHNjb3BlXHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBzY29wZXNbMF07IC8vdGhlIHRhcmdldCB0byB3aGljaCB0aGUgdG9rZW5zIGFyZSBhZGRlZC4gVGhpcyBjYW4gc3dpbmcgdXAgb3IgZG93blxyXG4gICAgICAgICAgICB2YXIgZGVwdGggPSAwO1xyXG4gICAgICAgICAgICB2YXIgb3Blbl9icmFja2V0cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgaGFzX3NwYWNlID0gZmFsc2U7IC8vbWFya3MgaWYgYW4gb3BlbiBzcGFjZSBjaGFyYWN0ZXIgd2FzIGZvdW5kXHJcbiAgICAgICAgICAgIHZhciBTUEFDRSA9ICcgJztcclxuICAgICAgICAgICAgdmFyIEVNUFRZX1NUUklORyA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgQ09NTUEgPSAnLCc7XHJcbiAgICAgICAgICAgIHZhciBNSU5VUyA9ICctJztcclxuICAgICAgICAgICAgdmFyIE1VTFQgPSAnKic7XHJcbiAgICAgICAgICAgIC8vUG9zc2libGUgc291cmNlIG9mIGJ1Zy4gUmV2aWV3XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAvL2dldHMgdGhlIG5leHQgc3BhY2VcclxuICAgICAgICAgICAgIHZhciBuZXh0X3NwYWNlID0gZnVuY3Rpb24oZnJvbSkge1xyXG4gICAgICAgICAgICAgZm9yKHZhciBpPWZyb207IGk8TDsgaSsrKSB7XHJcbiAgICAgICAgICAgICBpZihlLmNoYXJBdChpKSA9PT0gJyAnKVxyXG4gICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICBcclxuICAgICAgICAgICAgIHJldHVybiBMOyAvL2Fzc3VtZSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgaW5zdGVhZFxyXG4gICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgc2NvcGUgdG8gdG9rZW5zXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzY29wZV90eXBlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7aW50fSBjb2x1bW5cclxuICAgICAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBhZGRTY29wZSA9IGZ1bmN0aW9uIChzY29wZV90eXBlLCBjb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdfc2NvcGUgPSBbXTsgLy9jcmVhdGUgYSBuZXcgc2NvcGVcclxuICAgICAgICAgICAgICAgIGlmKHNjb3BlX3R5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld19zY29wZS50eXBlID0gc2NvcGVfdHlwZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ld19zY29wZS5jb2x1bW4gPSBjb2x1bW47IC8vbWFyayB0aGUgY29sdW1uIG9mIHRoZSBzY29wZVxyXG4gICAgICAgICAgICAgICAgc2NvcGVzLnB1c2gobmV3X3Njb3BlKTsgLy9hZGQgaXQgdG8gdGhlIGxpc3Qgb2Ygc2NvcGVzXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXdfc2NvcGUpOyAvL2FkZCBpdCB0byB0aGUgdG9rZW5zIGxpc3Qgc2luY2Ugbm93IGl0J3MgYSBzY29wZVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gbmV3X3Njb3BlOyAvL3BvaW50IHRvIGl0XHJcbiAgICAgICAgICAgICAgICBkZXB0aCsrOyAvL2dvIGRvd24gb25lIGluIHNjb3BlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHb2VzIHVwIGluIHNjb3BlIGJ5IG9uZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGdvVXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZXMucG9wKCk7IC8vcmVtb3ZlIHRoZSBzY29wZSBmcm9tIHRoZSBzY29wZXMgc3RhY2tcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHNjb3Blc1stLWRlcHRoXTsgLy9wb2ludCB0aGUgYWJvdmUgc2NvcGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4dHJhY3RzIGFsbCB0aGUgb3BlcmF0b3JzIGZyb20gdGhlIGV4cHJlc3Npb24gc3RyaW5nIHN0YXJ0aW5nIGF0IHBvc3Rpb24gc3RhcnRfYXRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0X2F0XHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgZ2V0X29wZXJhdG9yX3N0ciA9IGZ1bmN0aW9uIChzdGFydF9hdCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRfYXQgPSBzdGFydF9hdCAhPT0gdW5kZWZpbmVkID8gc3RhcnRfYXQgOiBjb2w7XHJcbiAgICAgICAgICAgICAgICAvL21hcmsgdGhlIGVuZCBvZiB0aGUgb3BlcmF0b3IgYXMgdGhlIHN0YXJ0IHNpbmNlIHdlJ3JlIGp1c3QgZ29pbmdcclxuICAgICAgICAgICAgICAgIC8vdG8gYmUgd2Fsa2luZyBhbG9uZyB0aGUgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gc3RhcnRfYXQgKyAxO1xyXG4gICAgICAgICAgICAgICAgLy9qdXN0IGtlZXAgbW92aW5nIGFsb25nXHJcbiAgICAgICAgICAgICAgICB3aGlsZShlLmNoYXJBdChlbmQrKykgaW4gb3BlcmF0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3JlbWVtYmVyIHRoYXQgd2Ugc3RhcnRlZCBhdCBvbmUgcG9zaXRpb24gYWhlYWQuIFRoZSBiZWdpbm5pbmcgb3BlcmF0b3IgaXMgd2hhdCB0cmlnZ2VyZWRcclxuICAgICAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gdGhlIGZpcnN0IHBsYWNlLiBTdHJpbmcuQ2hhckF0IGlzIHplcm8gYmFzZWQgc28gd2Ugbm93XHJcbiAgICAgICAgICAgICAgICAvL2hhdmUgdG8gY29ycmVjdCB0d28gcGxhY2VzLiBUaGUgaW5pdGlhbCBpbmNyZW1lbnQgKyB0aGUgZXh0cmErKyBhdCB0aGUgZW5kIG9mIGVuZCBkdXJpbmdcclxuICAgICAgICAgICAgICAgIC8vdGhlIGxhc3QgaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuc3Vic3RyaW5nKHN0YXJ0X2F0LCBlbmQgLSAxKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJyZWFrcyBvcGVyYXRvciB1cCBpbiB0byBzZXZlcmFsIGRpZmZlcmVudCBvcGVyYXRvcnMgYXMgZGVmaW5lZCBpbiBvcGVyYXRvcnNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yX3N0clxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgY2h1bmtpZnkgPSBmdW5jdGlvbiAob3BlcmF0b3Jfc3RyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBjb2wgLSBvcGVyYXRvcl9zdHIubGVuZ3RoOyAvL3N0YXJ0IG9mIG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICB2YXIgX29wZXJhdG9ycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gb3BlcmF0b3Jfc3RyLmNoYXJBdCgwKTtcclxuICAgICAgICAgICAgICAgIC8vZ3JhYiB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBjaHVua3MgYnV0IHN0YXJ0IGF0IDIgc2luY2Ugd2UgYWxyZWFkeSBrbm93XHJcbiAgICAgICAgICAgICAgICAvL3RoYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBhbiBvcGVyYXRvclxyXG5cclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDEsIEwgPSBvcGVyYXRvcl9zdHIubGVuZ3RoOyBpIDwgTDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gb3BlcmF0b3Jfc3RyLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IG9wZXJhdG9yICsgY2g7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9zaW5jZSB0aGUgb3BlcmF0b3Igbm93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBsYXN0IG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy93YXMgdGhlIGxhcmdlc3QgcG9zc2libGUgY29tYmluYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIShvIGluIG9wZXJhdG9ycykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX29wZXJhdG9ycy5wdXNoKG5ldyBUb2tlbihvcGVyYXRvciwgVG9rZW4uT1BFUkFUT1IsIHN0YXJ0ICsgaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gbzsvL25vdyB0aGUgb3BlcmF0b3IgaXMgdGhlIGxhcmdlciBjaHVua1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9hZGQgdGhlIGxhc3Qgb3BlcmF0b3JcclxuICAgICAgICAgICAgICAgIF9vcGVyYXRvcnMucHVzaChuZXcgVG9rZW4ob3BlcmF0b3IsIFRva2VuLk9QRVJBVE9SLCBzdGFydCArIGkpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfb3BlcmF0b3JzO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElzIHVzZWQgdG8gYWRkIGEgdG9rZW4gdG8gdGhlIHRva2VucyBhcnJheS4gTWFrZXMgc3VyZSB0aGF0IG5vIGVtcHR5IHRva2VuIGlzIGFkZGVkXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7aW50fSBhdFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5cclxuICAgICAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBhZGRfdG9rZW4gPSBmdW5jdGlvbiAoYXQsIHRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAvL2dyYWIgdGhlIHRva2VuIGlmIHdlJ3JlIG5vdCBzdXBwbGllZCBvbmVcclxuICAgICAgICAgICAgICAgIGlmKHRva2VuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBlLnN1YnN0cmluZyhscG9zLCBhdCk7XHJcbiAgICAgICAgICAgICAgICAvL29ubHkgYWRkIGl0IGlmIGl0J3Mgbm90IGFuIGVtcHR5IHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgaWYodG9rZW4gaW4gXy51bml0cylcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVG9rZW4odG9rZW4sIFRva2VuLlVOSVQsIGxwb3MpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4gIT09ICcnKVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUb2tlbih0b2tlbiwgVG9rZW4uVkFSSUFCTEVfT1JfTElURVJBTCwgbHBvcykpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGZ1bmN0aW9uIHRvIHRoZSBvdXRwdXRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGZcclxuICAgICAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBhZGRfZnVuY3Rpb24gPSBmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRva2VuKGYsIFRva2VuLkZVTkNUSU9OLCBscG9zKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUb2tlbnMgYXJlIGZvdW5kIGJldHdlZW4gb3BlcmF0b3JzIHNvIHRoaXMgbWFya3MgdGhlIGxvY2F0aW9uIG9mIHdoZXJlIHRoZSBsYXN0IHRva2VuIHdhcyBmb3VuZFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludH0gcG9zaXRpb25cclxuICAgICAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBzZXRfbGFzdF9wb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgbHBvcyA9IHBvc2l0aW9uICsgMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZW4gYSBvcGVyYXRvciBpcyBmb3VuZCBhbmQgYWRkZWQsIGVzcGVjaWFsbHkgYSBjb21ibyBvcGVyYXRvciwgdGhlbiB0aGUgY29sdW1uIGxvY2F0aW9uXHJcbiAgICAgICAgICAgICAqIGhhcyB0byBiZSBhZGp1c3RlZCB0byB0aGUgZW5kIG9mIHRoZSBvcGVyYXRvclxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGFkanVzdF9jb2x1bW5fcG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBscG9zID0gbHBvcyArIG9wZXJhdG9yX3N0ci5sZW5ndGggLSAyO1xyXG4gICAgICAgICAgICAgICAgY29sID0gbHBvcyAtIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvcig7IGNvbCA8IEw7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBlLmNoYXJBdChjb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYoY2ggaW4gb3BlcmF0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkX3Rva2VuKGNvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pcyB0aGUgbGFzdCB0b2tlbiBudW1lcmljP1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0X3Rva2VuX2lzX251bWVyaWMgPSB0YXJnZXRbMF0gJiYgaXNOdW1iZXIodGFyZ2V0WzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2lzIHRoaXMgY2hhcmFjdGVyIG11bHRpcGxpY2F0aW9uP1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc19tdWx0aXBsaWNhdGlvbiA9IGxhc3RfdG9rZW5faXNfbnVtZXJpYyAmJiBjaCA9PT0gTVVMVDtcclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHdlJ3JlIGluIGEgbmV3IHNjb3BlIHRoZW4gZ28gdXAgYnkgb25lIGJ1dCBpZiB0aGUgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAvL2lzIHJpZ2h0IGJlZm9yIGFuIG9wZXJhdG9yIHRoZW4gaXQgbWFrZXMgbm8gc2Vuc2UgdG8gZ28gdXAgaW4gc2NvcGVcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNpZGVyIHNpbiAteC4gVGhlIGxhc3QgcG9zaXRpb24gPSBjdXJyZW50IHBvc2l0aW9uIGF0IHRoZSBtaW51cyBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzIG1lYW5zIHRoYXQgd2UncmUgZ29pbmcgZm9yIHNpbih4KSAteCB3aGljaCBpcyB3cm9uZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vSWdub3JlIGNvbW1hIHNpbmNlIGNvbW1hIGlzIHN0aWxsIHBhcnQgb2YgdGhlIGV4aXN0aW5nIHNjb3BlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc19zcGFjZSAmJiBscG9zIDwgY29sICYmICEoY2ggPT09IENPTU1BIHx8IGlzX211bHRpcGxpY2F0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNfc3BhY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ29VcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL21hcmsgdGhlIGxhc3QgcG9zaXRpb24gdGhhdCBhXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0X2xhc3RfcG9zaXRpb24oY29sICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yX3N0ciA9IGdldF9vcGVyYXRvcl9zdHIoY29sKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0X2NvbHVtbl9wb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoLmFwcGx5KHRhcmdldCwgY2h1bmtpZnkob3BlcmF0b3Jfc3RyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNoIGluIGJyYWNrZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJyYWNrZXQgPSBicmFja2V0c1tjaF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGJyYWNrZXQuaXNfb3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21hcmsgdGhlIGJyYWNrZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3Blbl9icmFja2V0cy5wdXNoKFticmFja2V0LCBscG9zXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gZS5zdWJzdHJpbmcobHBvcywgY29sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZiBpbiBmdW5jdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF9mdW5jdGlvbihmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGYgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc3VtZSBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBBZGQgdGhlIG11bHRpcGxpY2F0aW9uIHRvIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVG9rZW4oZiwgVG9rZW4uVkFSSUFCTEVfT1JfTElURVJBTCwgbHBvcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ28gZG93biBvbmUgaW4gc2NvcGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU2NvcGUoYnJhY2tldC5tYXBzX3RvLCBjb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGJyYWNrZXQuaXNfY2xvc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgdGhlIG1hdGNoaW5nIGJyYWNrZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhaXIgPSBvcGVuX2JyYWNrZXRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Rocm93IGVycm9ycyBhY2NvcmRpbmdseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21pc3Npbmcgb3BlbiBicmFja2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFwYWlyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcml0eUVycm9yKCdNaXNzaW5nIG9wZW4gYnJhY2tldCBmb3IgYnJhY2tldCBhdDogJyArIChjb2wgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW5jb3JyZWN0IHBhaXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihwYWlyWzBdLmlkICE9PSBicmFja2V0LmlkIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJpdHlFcnJvcignUGFyaXR5IGVycm9yJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9rZW4oY29sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ29VcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzZXRfbGFzdF9wb3NpdGlvbihjb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihjaCA9PT0gU1BBQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldiA9IGUuc3Vic3RyaW5nKGxwb3MsIGNvbCk7IC8vbG9vayBiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG54dCA9IGUuY2hhckF0KGNvbCArIDEpOyAvL2xvb2sgZm9yd2FyZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc19zcGFjZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJldiBpbiBvcGVyYXRvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUb2tlbihwcmV2LCBUb2tlbi5PUEVSQVRPUiwgY29sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRfdG9rZW4odW5kZWZpbmVkLCBwcmV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UncmUgYXQgdGhlIGNsb3Npbmcgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvVXAoKTsgLy9nbyB1cCBpbiBzY29wZSBpZiB3ZSdyZSBhdCBhIHNwYWNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hc3N1bWUgbXVsdGlwbGljYXRpb24gaWYgaXQncyBub3QgYW4gb3BlcmF0b3IgZXhjZXB0IGZvciBtaW51c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzX29wZXJhdG9yID0gbnh0IGluIG9wZXJhdG9ycztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigoaXNfb3BlcmF0b3IgJiYgb3BlcmF0b3JzW254dF0udmFsdWUgPT09IE1JTlVTKSB8fCAhaXNfb3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVG9rZW4oTVVMVCwgVG9rZW4uT1BFUkFUT1IsIGNvbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc19zcGFjZSA9IGZhbHNlOyAvL3JlbW92ZSB0aGUgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UncmUgYXQgdGhlIGNsb3Npbmcgc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiBpdCdzIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBlLnN1YnN0cmluZyhscG9zLCBjb2wpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZiBpbiBmdW5jdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlcmUncyBubyBuZWVkIHRvIGdvIHVwIGluIHNjb3BlIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhbiBvcGVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzX3NwYWNlID0gdHJ1ZTsgLy9tYXJrIHRoYXQgYSBzcGFjZSB3YXMgZm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF9mdW5jdGlvbihmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNjb3BlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmIGluIG9wZXJhdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRva2VuKGYsIFRva2VuLk9QRVJBVE9SLCBjb2wpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZF90b2tlbih1bmRlZmluZWQsIGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wZWVrIGFoZWFkIHRvIHRoZSBuZXh0IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG54dCA9IGUuY2hhckF0KGNvbCArIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgaXQncyBhIG51bWJlciB0aGVuIGFkZCB0aGUgbXVsdGlwbGljYXRpb24gb3BlcmF0b3IgdG8gdGhlIHN0YWNrIGJ1dCBtYWtlIHN1cmUgdGhhdCB0aGUgbmV4dCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaXMgbm90IGFuIG9wZXJhdG9yXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocHJldiAhPT0gRU1QVFlfU1RSSU5HICYmIG54dCAhPT0gRU1QVFlfU1RSSU5HICYmICEocHJldiBpbiBvcGVyYXRvcnMpICYmICEobnh0IGluIG9wZXJhdG9ycykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRva2VuKE1VTFQsIFRva2VuLk9QRVJBVE9SLCBjb2wpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1Bvc3NpYmxlIHNvdXJjZSBvZiBidWcuIFJldmlld1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy9zcGFjZSBjYW4gbWVhbiBtdWx0aXBsaWNhdGlvbiBzbyBhZGQgdGhlIHN5bWJvbCBpZiB0aGUgaXMgZW5jb3VudGVyZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKC9cXGQrfFxcZCtcXC4/XFxkKmVbXFwrXFwtXSpcXGQrL2kudGVzdChmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBlLmNoYXJBdChjb2wrMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dF9pc19vcGVyYXRvciA9IG5leHQgaW4gb3BlcmF0b3JzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5zID0gbmV4dF9zcGFjZShjb2wrMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dF93b3JkID0gZS5zdWJzdHJpbmcoY29sKzEsIG5zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgY2FuIGVpdGhlciBiZSBhIHByZWZpeCBvcGVyYXRvciBvciBubyBvcGVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYoKG5leHRfaXNfb3BlcmF0b3IgJiYgb3BlcmF0b3JzW25leHRdLnByZWZpeCkgfHwgIShuZXh0X2lzX29wZXJhdG9yIHx8IG5leHRfd29yZCBpbiBvcGVyYXRvcnMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRva2VuKCcqJywgVG9rZW4uT1BFUkFUT1IsIGNvbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0X2xhc3RfcG9zaXRpb24oY29sKTsgLy9tYXJrIHRoaXMgbG9jYXRpb25cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NoZWNrIHRoYXQgYWxsIGJyYWNrZXRzIHdlcmUgY2xvc2VkXHJcbiAgICAgICAgICAgIGlmKG9wZW5fYnJhY2tldHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG9wZW5fYnJhY2tldHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyaXR5RXJyb3IoJ01pc3NpbmcgY2xvc2VkIGJyYWNrZXQgZm9yIGJyYWNrZXQgYXQgJyArIChiWzFdICsgMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vYWRkIHRoZSBsYXN0IHRva2VuXHJcbiAgICAgICAgICAgIGFkZF90b2tlbihjb2wpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUHV0cyB0b2tlbiBhcnJheSBpbiBSZXZlcnNlIFBvbGlzaCBOb3RhdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7VG9rZW5bXX0gdG9rZW5zXHJcbiAgICAgICAgICogQHJldHVybnMge1Rva2VuW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b1JQTiA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcclxuICAgICAgICAgICAgdmFyIGZuID0gdG9rZW5zLnR5cGU7XHJcbiAgICAgICAgICAgIHZhciBsID0gdG9rZW5zLmxlbmd0aCwgaTtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHByZWZpeGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBjb2xsYXBzZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGRlc3RpbmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSh0YXJnZXQubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLnB1c2godGFyZ2V0LnBvcCgpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy9tYXJrIGFsbCB0aGUgcHJlZml4ZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBzdGFja1xyXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKHRva2VuLnR5cGUgIT09IFRva2VuLk9QRVJBVE9SKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgaWYoIXRva2VuLnByZWZpeClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0b3JFcnJvcignTm90IGEgcHJlZml4IG9wZXJhdG9yJyk7XHJcbiAgICAgICAgICAgICAgICB0b2tlbi5pc19wcmVmaXggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9iZWdpbiB3aXRoIHJlbWFpbmluZyB0b2tlbnNcclxuICAgICAgICAgICAgZm9yKDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0b2tlbnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZihlLnR5cGUgPT09IFRva2VuLk9QRVJBVE9SKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yID0gZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgdGhlIG9wdGlvbiBmb3IgdGhlIG9wZXJhdG9yIGJlaW5nIG92ZXJsb2FkZWRcclxuICAgICAgICAgICAgICAgICAgICBpZihvcGVyYXRvci5vdmVybG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdG9rZW5zW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGZvbGxvd2VkIGJ5IGEgbnVtYmVyIG9yIHZhcmlhYmxlIHRoZW4gd2UgYXNzdW1lIGl0J3Mgbm90IGEgcG9zdGZpeCBvcGVyYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihuZXh0ICYmIG5leHQudHlwZSA9PT0gVG9rZW4uVkFSSUFCTEVfT1JfTElURVJBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IucG9zdGZpeCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vdmVycmlkZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgb3ZlcmxvYWQgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmFjdGlvbiA9IG9wZXJhdG9yLm92ZXJsb2FkQWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IubGVmdEFzc29jID0gb3BlcmF0b3Iub3ZlcmxvYWRMZWZ0QXNzb2M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIHN0YWNrIGlzIG5vdCBlbXB0eVxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmICh0aGVyZSBpcyBhbiBvcGVyYXRvciBhdCB0aGUgdG9wIG9mIHRoZSBvcGVyYXRvciBzdGFjayB3aXRoIGdyZWF0ZXIgcHJlY2VkZW5jZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9vciAodGhlIG9wZXJhdG9yIGF0IHRoZSB0b3Agb2YgdGhlIG9wZXJhdG9yIHN0YWNrIGhhcyBlcXVhbCBwcmVjZWRlbmNlIGFuZCBpcyBsZWZ0IGFzc29jaWF0aXZlKSkgfiB3aWtpcGVkaWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgIXByZWZpeGVzLmxlbmd0aCBtYWtlcyBzdXJlIHRoYXQgdGhlIG9wZXJhdG9yIG9uIHN0YWNrIGlzbid0IHByZW1hdHVyZWx5IHRha2VuIGZyb210IGhlIHN0YWNrLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighKGxhc3QucHJlY2VkZW5jZSA+IG9wZXJhdG9yLnByZWNlZGVuY2UgfHwgIW9wZXJhdG9yLmxlZnRBc3NvYyAmJiBsYXN0LnByZWNlZGVuY2UgPT09IG9wZXJhdG9yLnByZWNlZGVuY2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0YWNrLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2hhbmdlIHRoZSBiZWhhdmlvciBvZiB0aGUgb3BlcmF0b3IgaWYgaXQncyBhIHZlY3RvciBhbmQgd2UndmUgYmVlbiBhc2tlZCB0byBkbyBzb1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKChmbiA9PT0gJ3ZlY3RvcicgfHwgZm4gPT09ICdzZXQnKSAmJiAndmVjdG9yRm4nIGluIG9wZXJhdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvci5hY3Rpb24gPSBvcGVyYXRvci52ZWN0b3JGbjtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIG9wZXJhdG9yIGlzIGEgcG9zdGZpeCBvcGVyYXRvciB0aGVuIHdlJ3JlIHJlYWR5IHRvIGdvIHNpbmNlIGl0IGJlbG9uZ3NcclxuICAgICAgICAgICAgICAgICAgICAvL3RvIHRoZSBwcmVjZWRpbmcgdG9rZW4uIEhvd2V2ZXIgdGhlIG91dHB1dCBjYW5ub3QgYmUgZW1wdHkuIEl0IG11c3QgaGF2ZSBlaXRoZXJcclxuICAgICAgICAgICAgICAgICAgICAvL2FuIG9wZXJhdG9yIG9yIGEgdmFyaWFibGUvbGl0ZXJhbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wZXJhdG9yLnBvc3RmaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdG9rZW5zW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXByZXZpb3VzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdG9yRXJyb3IoXCJVbmV4cGVjdGVkIHByZWZpeCBvcGVyYXRvciAnXCIgKyBlLnZhbHVlICsgXCInISBhdCBcIiArIGUuY29sdW1uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihwcmV2aW91cy50eXBlID09PSBUb2tlbi5PUEVSQVRPUikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hIHBvc3RmaXggY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgYSBwb3N0Zml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighcHJldmlvdXMucG9zdGZpeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0b3JFcnJvcihcIlVuZXhwZWN0ZWQgcHJlZml4IG9wZXJhdG9yICdcIiArIHByZXZpb3VzLnZhbHVlICsgXCInISBhdCBcIiArIHByZXZpb3VzLmNvbHVtbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgbXVzdCBiZSBhdCBhbiBpbmZpeCBzbyBwb2ludCB0aGUgb3BlcmF0b3IgdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBmaXJzdCBvbmUgaXMgYW4gaW5maXggb3BlcmF0b3IgYWxsIG90aGVycyBoYXZlIHRvIGJlIHByZWZpeCBvcGVyYXRvcnMgc28ganVtcCB0byB0aGUgZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRva2Vuc1tpICsgMV07IC8vdGFrZSBhIGxvb2sgYWhlYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0X2lzX29wZXJhdG9yID0gbmV4dCA/IG5leHQudHlwZSA9PT0gVG9rZW4uT1BFUkFUT1IgOiBmYWxzZTsgLy9jaGVjayBpZiBpdCdzIGFuIG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihuZXh0X2lzX29wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIG5vdCBhIHByZWZpeCBvcGVyYXRvciB0aGVuIGl0IG5vdCBpbiB0aGUgcmlnaHQgcGxhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighbmV4dC5wcmVmaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdG9yRXJyb3IoJ0EgcHJlZml4IG9wZXJhdG9yIHdhcyBleHBlY3RlZCBhdCAnICsgbmV4dC5jb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21hcmsgaXQgYXMgYSBjb25maXJtZWQgcHJlZml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5pc19wcmVmaXggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIGl0IHRvIHRoZSBwcmVmaXhlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeGVzLnB1c2gobmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKG5leHRfaXNfb3BlcmF0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3MgYSBwcmVmaXggaXQgc2hvdWxkIGJlIG9uIGEgc3BlY2lhbCBzdGFjayBjYWxsZWQgcHJlZml4ZXNcclxuICAgICAgICAgICAgICAgICAgICAvL3dlIGRvIHRoaXMgdG8gaG9sZCBvbiB0byBwcmVmaXhlcyBiZWNhdXNlIG9mIGxlZnQgYXNzb2NpYXRpdmUgb3BlcmF0b3JzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhleSBiZWxvbmcgdG8gdGhlIHZhcmlhYmxlL2xpdGVyYWwgYnV0IGlmIHBsYWNlZCBvbiBlaXRoZXIgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vciBvdXRwdXQgdGhlcmUncyBubyB3YXkgb2Yga25vd2luZyB0aGlzLiBJIG1pZ2h0IGJlIHdyb25nIHNvIEkgd2VsY29tZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vYW55IGRpc2N1c3Npb24gYWJvdXQgdGhpcy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3BlcmF0b3IuaXNfcHJlZml4KSAvL0FERCBBTEwgRVhDRVBUSU9OUyBGT1IgQURESU5HIFRPIFBSRUZJWCBTVEFDSyBIRVJFLiAhISFcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ZXMucHVzaChvcGVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG9wZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAvL21vdmUgdGhlIHByZWZpeGVzIHRvIHRoZSBzdGFja1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKHByZWZpeGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihvcGVyYXRvci5sZWZ0QXNzb2MgfHwgIW9wZXJhdG9yLmxlZnRBc3NvYyAmJiBwcmVmaXhlc1twcmVmaXhlcy5sZW5ndGggLSAxXS5wcmVjZWRlbmNlID49IG9wZXJhdG9yLnByZWNlZGVuY2UpIC8vcmV2aXNpdCBmb3IgY29tbWFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHByZWZpeGVzLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihlLnR5cGUgPT09IFRva2VuLlZBUklBQkxFX09SX0xJVEVSQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL21vdmUgcHJlZml4ZXMgdG8gc3RhY2sgYXQgYmVnaW5uaW5nIG9mIHNjb3BlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYob3V0cHV0Lmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2UocHJlZml4ZXMsIHN0YWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2RvbmUgd2l0aCB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0X29uX3N0YWNrID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGVuIG1vdmUgYWxsIHRoZSBwcmVmaXhlcyB0byB0aGUgb3V0cHV0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIWxhc3Rfb25fc3RhY2sgfHwgIWxhc3Rfb25fc3RhY2subGVmdEFzc29jKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzZShwcmVmaXhlcywgb3V0cHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZS50eXBlID09PSBUb2tlbi5GVU5DVElPTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGUudHlwZSA9PT0gVG9rZW4uVU5JVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaXQncyBhIHVuaXQgaXQgYmVsb25ncyBvbiB0aGUgc3RhY2sgc2luY2UgaXQncyB0aWVkIHRvIHRoZSBwcmV2aW91cyB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9pZiBpdCdzIGFuIGFkZGl0b25hbCBzY29wZSB0aGVuIHB1dCB0aGF0IGludG8gUlBOIGZvcm1cclxuICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh0aGlzLnRvUlBOKGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihlLnR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG5ldyBUb2tlbihlLnR5cGUsIFRva2VuLkZVTkNUSU9OLCBlLmNvbHVtbikpOyAvL3NpbmNlIGl0J3MgaGlkZGVuIGl0IG5lZWRzIG5vIGNvbHVtblxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NvbGxhcHNlIHRoZSByZW1haW5kZXIgb2YgdGhlIHN0YWNrIGFuZCBwcmVmaXhlcyB0byBvdXRwdXRcclxuICAgICAgICAgICAgY29sbGFwc2Uoc3RhY2ssIG91dHB1dCk7XHJcbiAgICAgICAgICAgIGNvbGxhcHNlKHByZWZpeGVzLCBvdXRwdXQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUGFyc2VzIHRoZSB0b2tlbnNcclxuICAgICAgICAgKiBAcGFyYW0ge1Rva2Vuc1tdfSBycG5cclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc3Vic3RpdHV0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJzZVJQTiA9IGZ1bmN0aW9uIChycG4sIHN1YnN0aXR1dGlvbnMpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vZGVmYXVsdCBzdWJzdGl0dXRpb25zXHJcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zID0gc3Vic3RpdHV0aW9ucyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIC8vcHJlcGFyZSB0aGUgc3Vic3RpdHV0aW9ucy5cclxuICAgICAgICAgICAgICAgIC8vd2UgZmlyc3QgcGFyc2UgdGhlbSBvdXQgYXMtaXNcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeCBpbiBzdWJzdGl0dXRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnNbeF0gPSBfLnBhcnNlKHN1YnN0aXR1dGlvbnNbeF0sIHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0FsdGhvdWdoIHRlY2huaWNhbGx5IGNvbnN0YW50cyxcclxuICAgICAgICAgICAgICAgIC8vcGkgYW5kIGUgYXJlIG9ubHkgYXZhaWxhYmxlIHdoZW4gZXZhbHVhdGluZyB0aGUgZXhwcmVzc2lvbiBzbyBhZGQgdG8gdGhlIHN1YnMuXHJcbiAgICAgICAgICAgICAgICAvL0RvaW5nIHRoaXMgYXZvaWRzIHJvdW5kaW5nIGVycm9yc1xyXG4gICAgICAgICAgICAgICAgLy9saW5rIGUgYW5kIHBpXHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3VzZSB0aGUgdmFsdWUgcHJvdmlkZWQgaWYgdGhlIGluZGl2aWR1YWwgZm9yIHNvbWUgc3RyYW5nZSByZWFzb24gcHJlZmVycyB0aGlzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vb25lIHJlYXNvbiBjb3VsZCBiZSB0byBzdWIgZSBidXQgbm90IHBpIG9yIHZpY2UgdmVyc2FcclxuICAgICAgICAgICAgICAgICAgICBpZighKCdlJyBpbiBzdWJzdGl0dXRpb25zKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5lID0gbmV3IFN5bWJvbChTZXR0aW5ncy5FKTtcclxuICAgICAgICAgICAgICAgICAgICBpZigoISgncGknIGluIHN1YnN0aXR1dGlvbnMpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5waSA9IG5ldyBTeW1ib2woU2V0dGluZ3MuUEkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBRID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gcnBuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gcnBuW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0FycmF5cyBpbmRpY2F0ZSBhIG5ldyBzY29wZSBzbyBwYXJzZSB0aGF0IG91dFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMucGFyc2VSUE4oZSwgc3Vic3RpdHV0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGUudHlwZSA9PT0gVG9rZW4uT1BFUkFUT1IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGUuaXNfcHJlZml4IHx8IGUucG9zdGZpeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jlc29sdmUgdGhlIG9wZXJhdGlvbiBhc3NvY2F0ZWQgd2l0aCB0aGUgcHJlZml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGUub3BlcmF0aW9uKFEucG9wKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UaHJvdyBhbiBlcnJvciBpZiB0aGUgUkggdmFsdWUgaXMgZW1wdHkuIFRoaXMgY2Fubm90IGJlIGEgcG9zdGZpeCBzaW5jZSB3ZSBhbHJlYWR5IGNoZWNrZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRvckVycm9yKGUgKyAnIGlzIG5vdCBhIHZhbGlkIHBvc3RmaXggb3BlcmF0b3IgYXQgJyArIGUuY29sdW1uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2NvbW1hID0gZS5hY3Rpb24gPT09ICdjb21tYSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb252ZXJ0IFNldHMgdG8gVmVjdG9ycyBvbiBhbGwgb3BlcmF0aW9ucyBhdCB0aGlzIHBvaW50LiBTZXRzIGFyZSBvbmx5IHJlY29nbml6ZWQgZnVuY3Rpb25zIG9yIGluZGl2aWR1YWxseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEgaW5zdGFuY2VvZiBTZXQgJiYgIWlzX2NvbW1hKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gVmVjdG9yLmZyb21TZXQoYSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIgaW5zdGFuY2VvZiBTZXQgJiYgIWlzX2NvbW1hKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gVmVjdG9yLmZyb21TZXQoYik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsbCBhbGwgdGhlIHByZS1vcGVyYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxQZWVrZXJzKCdwcmVfb3BlcmF0b3InLCBhLCBiLCBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFucyA9IF9bZS5hY3Rpb25dKGEsIGIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGwgYWxsIHRoZSBwcmUtb3BlcmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsUGVla2VycygncG9zdF9vcGVyYXRvcicsIGFucywgYSwgYiwgZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFEucHVzaChhbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZS50eXBlID09PSBUb2tlbi5GVU5DVElPTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGFyZ3MucGFyZW50OyAvL21ha2UgYSBub3RlIG9mIHRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCEoYXJncyBpbnN0YW5jZW9mIENvbGxlY3Rpb24pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBDb2xsZWN0aW9uLmNyZWF0ZShhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIHJldHVybiB2YWx1ZSBtYXkgYmUgYSB2ZWN0b3IuIElmIGl0IGlzIHRoZW4gd2UgY2hlY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vUSB0byBzZWUgaWYgdGhlcmUncyBhbm90aGVyIHZlY3RvciBvbiB0aGUgc3RhY2suIElmIGl0IGlzIHRoZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgY2hlY2sgaWYgaGFzIGVsZW1lbnRzLiBJZiBpdCBkb2VzIHRoZW4gd2Uga25vdyB0aGF0IHdlJ3JlIGRlYWxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2l0aCBhbiBcImdldHRlclwiIG9iamVjdCBhbmQgcmV0dXJuIHRoZSByZXF1ZXN0ZWQgdmFsdWVzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYWxsIHRoZSBmdW5jdGlvbi4gVGhpcyBpcyB0aGUgXy5jYWxsZnVuY3Rpb24gbWV0aG9kIGluIG5lcmRhbWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGwgdGhlIGZ1bmN0aW9uLiBUaGlzIGlzIHRoZSBfLmNhbGxmdW5jdGlvbiBtZXRob2QgaW4gbmVyZGFtZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbl9uYW1lID0gZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbl9hcmdzID0gYXJncy5nZXRJdGVtcygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FsbCB0aGUgcHJlLWZ1bmN0aW9uIHBlZWtlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFBlZWtlcnMoJ3ByZV9mdW5jdGlvbicsIGZuX25hbWUsIGZuX2FyZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBfLmNhbGxmdW5jdGlvbihmbl9uYW1lLCBmbl9hcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGwgdGhlIHBvc3QtZnVuY3Rpb24gcGVla2Vyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsUGVla2VycygncG9zdF9mdW5jdGlvbicsIHJldCwgZm5fbmFtZSwgZm5fYXJncyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBRW1EubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHJwbltpICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dF9pc19jb21tYSA9IG5leHQgJiYgbmV4dC50eXBlID09PSBUb2tlbi5PUEVSQVRPUiAmJiBuZXh0LnZhbHVlID09PSAnLCc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIW5leHRfaXNfY29tbWEgJiYgcmV0IGluc3RhbmNlb2YgVmVjdG9yICYmIGxhc3QgJiYgbGFzdC5lbGVtZW50cyAmJiAhKGxhc3QgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHF1ZXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBRLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyID0gcmV0LmVsZW1lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgaXQncyBzeW1ib2xpYy4gSWYgc28gcHV0IGl0IGJhY2sgYW5kIGFkZCB0aGUgaXRlbSB0byB0aGUgc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighZ2V0dGVyLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmdldHRlciA9IGdldHRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRLnB1c2gocmV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihnZXR0ZXIgaW5zdGFuY2VvZiBTbGljZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGl0J3MgYSBTbGljZSByZXR1cm4gdGhlIHNsaWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFEucHVzaChWZWN0b3IuZnJvbUFycmF5KGl0ZW0uZWxlbWVudHMuc2xpY2UoZ2V0dGVyLnN0YXJ0LCBnZXR0ZXIuZW5kKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gTnVtYmVyKGdldHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbCA9IGl0ZW0uZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N1cHBvcnQgZm9yIG5lZ2F0aXZlIGluZGljZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbCArIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2l0IGl0J3Mgc3RpbGwgb3V0IG9mIGJvdW5kc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpbmRleCA8IDAgfHwgaW5kZXggPj0gaWwpIC8vaW5kZXggc2hvdWxkIG5vIGxvbmdlciBiZSBuZWdhdGl2ZSBzaW5jZSBpdCdzIGJlZW4gcmVzZXQgYWJvdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmFuZ2UgZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBPdXRPZlJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZSAnICsgKGUuY29sdW1uICsgMSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBpdGVtLmVsZW1lbnRzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jeWNsaWMgYnV0IHdlIG5lZWQgdG8gbWFyayB0aGlzIGZvciBmdXR1cmUgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZ2V0dGVyID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gaXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFEucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2V4dGVuZCB0aGUgcGFyZW50IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBRLnB1c2gocmV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViYmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBlLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHYgaW4gU2V0dGluZ3MuQUxJQVNFUylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gXy5wYXJzZShTZXR0aW5ncy5BTElBU0VTW2VdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd3JhcCBpdCBpbiBhIHN5bWJvbCBpZiBuZWVkIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGUudHlwZSA9PT0gVG9rZW4uVkFSSUFCTEVfT1JfTElURVJBTClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3IFN5bWJvbCh2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZS50eXBlID09PSBUb2tlbi5VTklUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyBTeW1ib2wodik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5pc1VuaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdWJzdGl0dXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0Fsd2F5cyBjb25zdGFudHMgZmlyc3QuIFRoaXMgYXZvaWRzIHRoZSBiZWluZyBvdmVycmlkZGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2IGluIF8uQ09OU1RBTlRTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViYmVkID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3IFN5bWJvbChfLkNPTlNUQU5UU1t2XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgc3Vic3RpdHV0aW9ucy4gVGhpcyBhbGxvd3MgZGVjbGFyZWQgdmFyaWFibGUgdG8gYmUgb3ZlcnJpZGRlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiB0aGUgdmFsdWVzIG1hdGNoIHRvIGF2b2lkIGVyYXNpbmcgdGhlIG11bHRpcGxpZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0V4YW1wbGU6L2UgPSAzKmEuIHN1YnN0dXRpdGluZyBhIGZvciBhIHdpbGwgd2lwZSBvdXQgdGhlIG11bHRpcGxpZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHYgaW4gc3Vic3RpdHV0aW9ucyAmJiB2ICE9PSBzdWJzdGl0dXRpb25zW3ZdLnRvU3RyaW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJiZWQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBzdWJzdGl0dXRpb25zW3ZdLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL25leHQgZGVjbGFyZSB2YXJpYWJsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodiBpbiBWQVJTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViYmVkID0gZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gVkFSU1t2XS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIG5vdGF0aW9uIG9mIHdoYXQgaXQgd2FzIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ViYmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3ViYmVkID0gc3ViYmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFEucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gUVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihbJ3VuZGVmaW5lZCcsICdzdHJpbmcnLCAnbnVtYmVyJ10uaW5kZXhPZih0eXBlb2YgcmV0dmFsKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZFRva2VuRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4hJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJldGhyb3dFcnJvcnMgPSBbT3V0T2ZGdW5jdGlvbkRvbWFpbkVycm9yXTtcclxuICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgY2VydGFpbiBlcnJvcnMgaW4gdGhlIHNhbWUgY2xhc3MgdG8gcHJlc2VydmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgcmV0aHJvd0Vycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZXJyb3IgaW5zdGFuY2VvZiBFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKGVycm9yLm1lc3NhZ2UgKyAnOiAnICsgZS5jb2x1bW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGVycm9yLm1lc3NhZ2UgKyAnOiAnICsgZS5jb2x1bW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBtZXRob2QgdGhhdCB0cmlnZ2VycyB0aGUgcGFyc2luZyBvZiB0aGUgc3RyaW5nLiBJdCBnZW5lcmF0ZXMgYSBwYXJzZSB0cmVlIGJ1dCBwcm9jZXNzZXNcclxuICAgICAgICAgKiBpdCByaWdodCBhd2F5LiBUaGUgb3BlcmF0b3IgZnVuY3Rpb25zIGFyZSBjYWxsZWQgd2hlbiB0aGVpciByZXNwZWN0aXZlIG9wZXJhdG9ycyBhcmUgcmVhY2hlZC4gRm9yIGluc3RhbmNlXHJcbiAgICAgICAgICogKyB3aXRoIGNhdXNlIHRoaXMuYWRkIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBsZWZ0IGFuZCByaWdodCBoYW5kIHZhbHVlcy4gSXQgd29ya3MgYnkgd2Fsa2luZyBhbG9uZyBlYWNoXHJcbiAgICAgICAgICogY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgYW5kIHBsYWNpbmcgdGhlIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgYW5kIHZhbHVlcyBvbiB0aGUgb3V0cHV0LiBXaGVuIGFuIG9wZXJhdG9yXHJcbiAgICAgICAgICogaGF2aW5nIGEgbG93ZXIgb3JkZXIgdGhhbiB0aGUgbGFzdCBpcyByZWFjaGVkIHRoZW4gdGhlIHN0YWNrIGlzIHByb2Nlc3NlZCBmcm9tIHRoZSBsYXN0IG9wZXJhdG9yIG9uIHRoZVxyXG4gICAgICAgICAqIHN0YWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlblxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBOb2RlKHRva2VuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHRva2VuLnR5cGU7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0b2tlbi52YWx1ZTtcclxuICAgICAgICAgICAgLy90aGUgaW5jb21pbmcgdG9rZW4gbWF5IGFscmVhZHkgYmUgYSBOb2RlIHR5cGVcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gdG9rZW4ubGVmdDtcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHRva2VuLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0ID8gdGhpcy5sZWZ0LnRvU3RyaW5nKCkgKyAnLS0tJyA6ICcnO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0ID8gJy0tLScgKyB0aGlzLnJpZ2h0LnRvU3RyaW5nKCkgOiAnJztcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnQgKyAnKCcgKyB0aGlzLnZhbHVlICsgJyknICsgcmlnaHQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgTm9kZS5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24gKGRlcHRoLCBpbmRlbnQpIHtcclxuICAgICAgICAgICAgZGVwdGggPSBkZXB0aCB8fCAwO1xyXG4gICAgICAgICAgICBpbmRlbnQgPSB0eXBlb2YgaW5kZW50ID09PSAndW5kZWZpbmVkJyA/IDQgOiBpbmRlbnQ7XHJcbiAgICAgICAgICAgIHZhciB0YWIgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcgJy5yZXBlYXQoaW5kZW50ICogbik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0ID8gdGFiKGRlcHRoICsgMSkgKyAnPGxpPlxcbicgKyB0aGlzLmxlZnQudG9IVE1MKGRlcHRoICsgMiwgaW5kZW50KSArIHRhYihkZXB0aCArIDEpICsgJzwvbGk+IFxcbicgOiAnJztcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yaWdodCA/IHRhYihkZXB0aCArIDEpICsgJzxsaT5cXG4nICsgdGhpcy5yaWdodC50b0hUTUwoZGVwdGggKyAyLCBpbmRlbnQpICsgdGFiKGRlcHRoICsgMSkgKyAnPC9saT5cXG4nIDogJyc7XHJcbiAgICAgICAgICAgIHZhciBodG1sID0gdGFiKGRlcHRoKSArICc8ZGl2IGNsYXNzPVwiJyArIHRoaXMudHlwZS50b0xvd2VyQ2FzZSgpICsgJ1wiPjxzcGFuPicgKyB0aGlzLnZhbHVlICsgJzwvc3Bhbj48L2Rpdj4nICsgdGFiKGRlcHRoKSArICdcXG4nO1xyXG4gICAgICAgICAgICBpZihsZWZ0IHx8IHJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBodG1sICs9IHRhYihkZXB0aCkgKyAnPHVsPlxcbicgKyBsZWZ0ICsgcmlnaHQgKyB0YWIoZGVwdGgpICsgJzwvdWw+XFxuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBodG1sICs9ICcnO1xyXG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLnRyZWUgPSBmdW5jdGlvbiAodG9rZW5zKSB7XHJcbiAgICAgICAgICAgIHZhciBRID0gW107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gdG9rZW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgLy9BcnJheXMgaW5kaWNhdGUgYSBuZXcgc2NvcGUgc28gcGFyc2UgdGhhdCBvdXRcclxuICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gdGhpcy50cmVlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgaXQncyBhIGNvbW1hIHRoZW4gaXQncyBqdXN0IGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGUudHlwZSA9PT0gVG9rZW4uT1BFUkFUT1IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihlLmlzX3ByZWZpeCB8fCBlLnBvc3RmaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9wcmVmaXhlcyBnbyB0byB0aGUgbGVmdCwgcG9zdGZpeCB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gZS5pc19wcmVmaXggPyAnbGVmdCcgOiAncmlnaHQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgTm9kZShlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVtsb2NhdGlvbl0gPSBsYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBRLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gbmV3IE5vZGUoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmlnaHQgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLmxlZnQgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBRLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihlLnR5cGUgPT09IFRva2VuLkZVTkNUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyBOb2RlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnJpZ2h0ID0gYXJncztcclxuICAgICAgICAgICAgICAgICAgICBpZihlLnZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIFEgaGFzIGEgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3QgPSBRW1EubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGxhc3QucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbGFzdC5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QucmlnaHQgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChuZXcgTm9kZShlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBRWzBdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uIChlLCBzdWJzdGl0dXRpb25zKSB7XHJcbiAgICAgICAgICAgIGUgPSBwcmVwYXJlX2V4cHJlc3Npb24oZSk7XHJcbiAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMgPSBzdWJzdGl0dXRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICAvL3RocmVlIHBhc3NlcyBidXQgZWFzaWVyIHRvIGRlYnVnXHJcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSB0aGlzLnRva2VuaXplKGUpO1xyXG4gICAgICAgICAgICB2YXIgcnBuID0gdGhpcy50b1JQTih0b2tlbnMpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJQTihycG4sIHN1YnN0aXR1dGlvbnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVE9ETzogU3dpdGNoIHRvIFBhcnNlci50b2tlbml6ZSBmb3IgdGhpcyBtZXRob2RcclxuICAgICAgICAgKiBSZWFkcyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIFN5bWJvbHMgYW5kIG9wZXJhdG9yc1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uX3N0cmluZ1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRvT2JqZWN0ID0gZnVuY3Rpb24gKGV4cHJlc3Npb25fc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmplY3RpZnkgPSBmdW5jdGlvbiAodG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRva2VuLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRva2VuLnR5cGUgPT09IFRva2VuLlZBUklBQkxFX09SX0xJVEVSQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gobmV3IFN5bWJvbCh2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udHlwZSA9PT0gVG9rZW4uRlVOQ1RJT04pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9qdW1wIGFoZWFkIHNpbmNlIHRoZSBuZXh0IG9iamVjdCBhcmUgdGhlIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY3JlYXRlIGEgc3ltYm9saWMgZnVuY3Rpb24gYW5kIHN0aWNrIGl0IG9uIG91dHB1dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IF8uc3ltZnVuY3Rpb24odiwgb2JqZWN0aWZ5KHRva2Vuc1tpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmLmlzQ29udmVyc2lvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnR5cGUgPT09IFRva2VuLk9QRVJBVE9SKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob2JqZWN0aWZ5KHRva2VuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RpZnkoXy50b2tlbml6ZShleHByZXNzaW9uX3N0cmluZykpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEEgaGVscGVyIG1ldGhvZCBmb3IgdG9UZVhcclxuICAgICAgICB2YXIgY2h1bmtBdENvbW1hcyA9IGZ1bmN0aW9uIChhcnIpIHtcclxuICAgICAgICAgICAgdmFyIGosIGsgPSAwLCBjaHVua3MgPSBbW11dO1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwLCBsID0gYXJyLmxlbmd0aDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYoYXJyW2pdID09PSAnLCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBrKys7XHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzW2tdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaHVua3Nba10ucHVzaChhcnJbal0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjaHVua3M7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSGVscGVyIG1ldGhvZCBmb3IgdG9UZVhcclxuICAgICAgICB2YXIgcmVtX2JyYWNrZXRzID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXFxcbGVmdFxcKCguKylcXFxccmlnaHRcXCkkL2csIGZ1bmN0aW9uIChzdHIsIGEpIHtcclxuICAgICAgICAgICAgICAgIGlmKGEpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgcmVtb3ZlX3JlZHVuZGFudF9wb3dlcnMgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBmaWx0ZXJlZCBhcnJheVxyXG4gICAgICAgICAgICB2YXIgbmFyciA9IFtdO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUoYXJyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIGZyb250XHJcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGFyci5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBhcnJbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF9pc19hcnJheSA9IGlzQXJyYXkobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF9pc19taW51cyA9IG5leHQgPT09ICctJztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgcmVkdW5kYW50IHBsdXNzZXMgXHJcbiAgICAgICAgICAgICAgICBpZihlID09PSAnXicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihuZXh0ID09PSAnKycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYobmV4dF9pc19hcnJheSAmJiBuZXh0WzBdID09PSAnKycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHJlZHVuZGFudCBwYXJlbnRoZXNlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5leHRfaXNfYXJyYXkgJiYgbmV4dC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnVuc2hpZnQoYXJyLnNoaWZ0KClbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGEgbmVnYXRpdmUgcG93ZXJcclxuICAgICAgICAgICAgICAgIGlmKGUgPT09ICdeJyAmJiAobmV4dF9pc19hcnJheSAmJiBuZXh0WzBdID09PSAnLScgfHwgbmV4dF9pc19taW51cykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzbzpcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIFJlbW92ZSBpdCBmcm9tIHRoZSBuZXcgYXJyYXksIHBsYWNlIGEgb25lIGFuZCBhIGRpdmlzaW9uIHNpZ24gaW4gdGhhdCBhcnJheSBhbmQgcHV0IGl0IGJhY2tcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IG5hcnIucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBzb21ldGhpbmcgbXVsdGlwbGllZCBieVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBuYXJyW25hcnIubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlZm9yZV9sYXN0ID0gJzEnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihiZWZvcmUgPT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXJyLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSB3ZSBqdXN0IHBvcCBpdC4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZV9sYXN0ID0gbmFyci5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1wbGllZCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNBcnJheShiZWZvcmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZV9sYXN0ID0gbmFyci5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5hcnIucHVzaChiZWZvcmVfbGFzdCwgJy8nLCBsYXN0LCBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduIGZyb20gdGhlIHBvd2VyIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5leHRfaXNfYXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXkgc28gd2UgZG9uJ3QgZW5kIHVwIHdpdGggcmVkdW5kYW50IHBhcmVudGhlc2VzIGlmIHdlIGNhblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5leHRfaXNfYXJyYXkgJiYgbmV4dC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFyci5wdXNoKGFyci5zaGlmdCgpWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuYXJyLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuYXJyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBDb252ZXJ0IGV4cHJlc3Npb24gb3Igb2JqZWN0IHRvIExhVGVYXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb25fb3Jfb2JqXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b1RlWCA9IGZ1bmN0aW9uIChleHByZXNzaW9uX29yX29iaiwgb3B0KSB7XHJcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICAgICAgLy8gQWRkIGRlY2ltYWwgb3B0aW9uIGFzIHBlciBpc3N1ZSAjNTc5LiBDb25zaWRlciBwYXNzaW5nIGFuIG9iamVjdCB0byBMYXRleC5sYXRleCBhcyBvcHRpb24gaW5zdGVhZCBvZiBzdHJpbmdcclxuICAgICAgICAgICAgdmFyIGRlY2ltYWxzID0gb3B0LmRlY2ltYWxzID09PSB0cnVlID8gJ2RlY2ltYWxzJyA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIHZhciBvYmogPSB0eXBlb2YgZXhwcmVzc2lvbl9vcl9vYmogPT09ICdzdHJpbmcnID8gdGhpcy50b09iamVjdChleHByZXNzaW9uX29yX29iaikgOiBleHByZXNzaW9uX29yX29iaixcclxuICAgICAgICAgICAgICAgICAgICBUZVggPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBjZG90ID0gdHlwZW9mIG9wdC5jZG90ID09PSAndW5kZWZpbmVkJyA/ICdcXFxcY2RvdCcgOiBvcHQuY2RvdDsgLy9zZXQgb21pdCBjZG90IHRvIHRydWUgYnkgZGVmYXVsdFxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG5lZ2F0aXZlIHBvd2VycyBhcyBwZXIgaXNzdWUgIzU3MFxyXG4gICAgICAgICAgICBvYmogPSByZW1vdmVfcmVkdW5kYW50X3Bvd2VycyhvYmopO1xyXG5cclxuICAgICAgICAgICAgaWYoaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9iaiA9IFtdLCBhLCBiO1xyXG4gICAgICAgICAgICAgICAgLy9maXJzdCBoYW5kbGUgXlxyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBvYmpbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG9ialtpICsgMV0gPT09ICdeJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gb2JqW2kgKyAyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9iai5wdXNoKExhVGVYLmJyYWNlcyh0aGlzLnRvVGVYKFthXSkpICsgJ14nICsgTGFUZVguYnJhY2VzKHRoaXMudG9UZVgoW2JdKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2JqLnB1c2goYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2JqID0gbm9iajtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gb2JqW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgKiB0byBjZG90XHJcbiAgICAgICAgICAgICAgICBpZihlID09PSAnKicpIHtcclxuICAgICAgICAgICAgICAgICAgICBlID0gY2RvdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihpc1N5bWJvbChlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGUuZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbmFtZSA9IGUuZm5hbWUsIGY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmbmFtZSA9PT0gU1FSVClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAnXFxcXHNxcnQnICsgTGFUZVguYnJhY2VzKHRoaXMudG9UZVgoZS5hcmdzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IEFCUylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBMYVRlWC5icmFja2V0cyh0aGlzLnRvVGVYKGUuYXJncyksICdhYnMnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gUEFSRU5USEVTSVMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gTGFUZVguYnJhY2tldHModGhpcy50b1RlWChlLmFyZ3MpLCAncGFyZW5zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IFNldHRpbmdzLkxPRzEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gJ1xcXFwnICsgU2V0dGluZ3MuTE9HMTBfTEFURVggKyAnXFxcXGxlZnQoICcgKyB0aGlzLnRvVGVYKGUuYXJncykgKyAnXFxcXHJpZ2h0KSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2ludGVncmF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJldHJpdmUgW0V4cHJlc3Npb24sIHhdICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtzID0gY2h1bmtBdENvbW1hcyhlLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQnVpbGQgVGVYICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwciA9IExhVGVYLmJyYWNlcyh0aGlzLnRvVGVYKGNodW5rc1swXSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCA9IHRoaXMudG9UZVgoY2h1bmtzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSAnXFxcXGludCAnICsgZXhwciArICdcXFxcLCBkJyArIGR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdkZWZpbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtzID0gY2h1bmtBdENvbW1hcyhlLmFyZ3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByID0gTGFUZVguYnJhY2VzKHRoaXMudG9UZVgoY2h1bmtzWzBdKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gdGhpcy50b1RlWChjaHVua3NbM10pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYiA9IHRoaXMudG9UZVgoY2h1bmtzWzFdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWIgPSB0aGlzLnRvVGVYKGNodW5rc1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gJ1xcXFxpbnRcXFxcbGltaXRzX3snICsgbGIgKyAnfV57JyArIHViICsgJ30gJyArIGV4cHIgKyAnXFxcXCwgZCcgKyBkeDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2RpZmYnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2h1bmtzID0gY2h1bmtBdENvbW1hcyhlLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gJycsIGV4cHIgPSBMYVRlWC5icmFjZXModGhpcy50b1RlWChjaHVua3NbMF0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEhhbmRsZSBjYXNlczogb25lIGFyZ3VtZW50IHByb3ZpZGVkLCB3ZSBuZWVkIHRvIGd1ZXNzIHRoZSB2YXJpYWJsZSwgYW5kIGFzc3VtZSBuID0gMSAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGogPSAwOyBqIDwgY2h1bmtzWzBdLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNodW5rc1swXVtqXS5ncm91cCA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFycy5wdXNoKGNodW5rc1swXVtqXS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFycy5zb3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHggPSB2YXJzLmxlbmd0aCA+IDAgPyAoJ1xcXFxmcmFje2R9e2QgJyArIHZhcnNbMF0gKyAnfScpIDogJ1xcXFxmcmFje2R9e2QgeH0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgdHdvIGFyZ3VtZW50cywgd2UgaGF2ZSBleHByZXNzaW9uIGFuZCB2YXJpYWJsZSwgd2UgYXNzdW1lIG4gPSAxICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNodW5rcy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCA9ICdcXFxcZnJhY3tkfXtkICcgKyBjaHVua3NbMV0gKyAnfSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB3ZSBoYXZlIG1vcmUgdGhhbiAyIGFyZ3VtZW50cywgd2UgYXNzdW1lIHdlJ3ZlIGdvdCBldmVyeXRoaW5nICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeCA9ICdcXFxcZnJhY3tkXnsnICsgY2h1bmtzWzJdICsgJ319e2QgJyArIHRoaXMudG9UZVgoY2h1bmtzWzFdKSArICdeeycgKyBjaHVua3NbMl0gKyAnfX0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBkeCArICdcXFxcbGVmdCgnICsgZXhwciArICdcXFxccmlnaHQpJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ3N1bScgfHwgZm5hbWUgPT09ICdwcm9kdWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BsaXQgZS5hcmdzIGludG8gNCBwYXJ0cyBiYXNlZCBvbiBsb2NhdGlvbnMgb2YgLCBzeW1ib2xzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ1NwbGl0ID0gW1tdLCBbXSwgW10sIFtdXSwgaiA9IDAsIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBlLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihlLmFyZ3NbaV0gPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdTcGxpdFtqXS5wdXNoKGUuYXJnc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuIGJ1aWxkIFRlWCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gKGZuYW1lID09PSAnc3VtJyA/ICdcXFxcc3VtXycgOiAnXFxcXHByb2RfJykgKyBMYVRlWC5icmFjZXModGhpcy50b1RlWChhcmdTcGxpdFsxXSkgKyAnID0gJyArIHRoaXMudG9UZVgoYXJnU3BsaXRbMl0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgKz0gJ14nICsgTGFUZVguYnJhY2VzKHRoaXMudG9UZVgoYXJnU3BsaXRbM10pKSArIExhVGVYLmJyYWNlcyh0aGlzLnRvVGVYKGFyZ1NwbGl0WzBdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2xpbWl0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBjaHVua0F0Q29tbWFzKGUuYXJncykubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8udG9UZVgoeC5qb2luKCcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8udG9UZVgoU3RyaW5nKHgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9ICdcXFxcbGltXycgKyBMYVRlWC5icmFjZXMoYXJnc1sxXSArICdcXFxcdG8gJyArIGFyZ3NbMl0pICsgJyAnICsgTGFUZVguYnJhY2VzKGFyZ3NbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IEZBQ1RPUklBTCB8fCBmbmFtZSA9PT0gRE9VQkxFRkFDVE9SSUFMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IHRoaXMudG9UZVgoZS5hcmdzKSArIChmbmFtZSA9PT0gRkFDVE9SSUFMID8gJyEnIDogJyEhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBMYVRlWC5sYXRleChlLCBkZWNpbWFscyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2YgPSAnXFxcXG1hdGhybScrTGFUZVguYnJhY2VzKGZuYW1lLnJlcGxhY2UoL18vZywgJ1xcXFxfJykpICsgTGFUZVguYnJhY2tldHModGhpcy50b1RlWChlLmFyZ3MpLCAncGFyZW5zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRlWC5wdXNoKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVGVYLnB1c2goTGFUZVgubGF0ZXgoZSwgZGVjaW1hbHMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzQXJyYXkoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBUZVgucHVzaChMYVRlWC5icmFja2V0cyh0aGlzLnRvVGVYKGUpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihlID09PSAnLycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRlWC5wdXNoKExhVGVYLmZyYWMocmVtX2JyYWNrZXRzKFRlWC5wb3AoKSksIHJlbV9icmFja2V0cyh0aGlzLnRvVGVYKFtvYmpbKytpXV0pKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgVGVYLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBUZVguam9pbignICcpO1xyXG4gICAgICAgIH07XHJcblxyXG4vL1BhcnNlci5mdW5jdGlvbnMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAvKiBBbHRob3VnaCBwYXJlbnMgaXMgbm90IGEgXCJyZWFsXCIgZnVuY3Rpb24gaXQgaXMgaW1wb3J0YW50IGluIHNvbWUgY2FzZXMgd2hlbiB0aGVcclxuICAgICAgICAgKiBzeW1ib2wgbXVzdCBjYXJyeSBwYXJlbnRoZXNpcy4gT25jZSBzZXQgeW91IGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXQgaXQgYW55bW9yZVxyXG4gICAgICAgICAqIGFzIHRoZSBwYXJzZXIgd2lsbCBnZXQgcmlkIG9mIGl0IGF0IHRoZSBmaXJzdCBvcHBvcnR1bml0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHBhcmVucyhzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdwYXJlbnMnLCBbc3ltYm9sXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBhYnMoc3ltYm9sKSB7XHJcblxyXG4gICAgICAgICAgICAvL3wt4oiefCA9IOKInlxyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbC5pbmZpbml0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5tdWx0aXBsaWVyLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNJbWFnaW5hcnkoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlID0gc3ltYm9sLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW0gPSBzeW1ib2wuaW1hZ3BhcnQoKTtcclxuICAgICAgICAgICAgICAgIGlmKHJlLmlzQ29uc3RhbnQoKSAmJiBpbS5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNxcnQoXy5hZGQoXy5wb3cocmUsIG5ldyBTeW1ib2woMikpLCBfLnBvdyhpbSwgbmV3IFN5bWJvbCgyKSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGlzTnVtZXJpY1N5bWJvbChzeW1ib2wpIHx8IGV2ZW4oc3ltYm9sLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtcy5wdXNoKHgubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHZhciBnY2QgPSBNYXRoMi5RR0NELmFwcGx5KG51bGwsIG1zKTtcclxuICAgICAgICAgICAgICAgIGlmKGdjZC5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyID0gc3ltYm9sLm11bHRpcGxpZXIubXVsdGlwbHkobmV3IEZyYWMoLTEpKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jb252ZXJ0IHxuKnh8IHRvIG4qfHh8XHJcbiAgICAgICAgICAgIHZhciBtID0gXy5wYXJzZShzeW1ib2wubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgIHN5bWJvbC50b1VuaXRNdWx0aXBsaWVyKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShtLCBfLnN5bWZ1bmN0aW9uKEFCUywgW3N5bWJvbF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZhY3RvcmlhbCBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJuIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZmFjdG9yaWFsKHN5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG4gICAgICAgICAgICBpZihpc1ZlY3RvcihzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgViA9IG5ldyBWZWN0b3IoKTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pIHN0YXJ0IGF0IG9uZS5cclxuICAgICAgICAgICAgICAgICAgICBWLnNldChpIC0gMSwgZmFjdG9yaWFsKHgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoaXNNYXRyaXgoc3ltYm9sKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vaSBzdGFydCBhdCBvbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgZmFjdG9yaWFsKHgpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoU2V0dGluZ3MuUEFSU0UyTlVNQkVSICYmIHN5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmKGlzSW50KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBNYXRoMi5iaWdmYWN0b3JpYWwoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IE1hdGgyLmdhbW1hKHN5bWJvbC5tdWx0aXBsaWVyLmFkZChuZXcgRnJhYygxKSkudG9EZWNpbWFsKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IGJpZ0NvbnZlcnQocmV0dmFsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVuID0gc3ltYm9sLmdldERlbm9tKCk7XHJcbiAgICAgICAgICAgICAgICBpZihkZW4uZXF1YWxzKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bSA9IHN5bWJvbC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSwgYiwgYywgbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXN5bWJvbC5tdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gXy5hZGQobnVtLCBuZXcgU3ltYm9sKDEpKS5tdWx0aXBsaWVyLmRpdmlkZShuZXcgRnJhYygyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBNYXRoMi5iaWdmYWN0b3JpYWwobmV3IEZyYWMoMikubXVsdGlwbHkobikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gXy5wb3cobmV3IFN5bWJvbCg0KSwgbmV3IFN5bWJvbChuKSkubXVsdGlwbGllci5tdWx0aXBseShNYXRoMi5iaWdmYWN0b3JpYWwobikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IF8uc3VidHJhY3QobnVtLm5lZ2F0ZSgpLCBuZXcgU3ltYm9sKDEpKS5tdWx0aXBsaWVyLmRpdmlkZShuZXcgRnJhYygyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfLnBvdyhuZXcgU3ltYm9sKC00KSwgbmV3IFN5bWJvbChuKSkubXVsdGlwbGllci5tdWx0aXBseShNYXRoMi5iaWdmYWN0b3JpYWwobikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gTWF0aDIuYmlnZmFjdG9yaWFsKG5ldyBGcmFjKDIpLm11bHRpcGx5KG4pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IGEuZGl2aWRlKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KF8ucGFyc2UoJ3NxcnQocGkpJyksIG5ldyBTeW1ib2woYykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKEZBQ1RPUklBTCwgW3N5bWJvbF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY29udGludWVkIGZyYWN0aW9uIG9mIGEgbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBuXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZWRfZnJhY3Rpb24oc3ltYm9sLCBuKSB7XHJcbiAgICAgICAgICAgIHZhciBfc3ltYm9sID0gZXZhbHVhdGUoc3ltYm9sKTtcclxuICAgICAgICAgICAgaWYoX3N5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZiA9IE1hdGgyLmNvbnRpbnVlZEZyYWN0aW9uKF9zeW1ib2wsIG4pO1xyXG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IHRoZSBmcmFjdGlvbnMgYXJyYXkgdG8gYSBuZXcgVmVjdG9yXHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhY3Rpb25zID0gVmVjdG9yLmZyb21BcnJheShjZi5mcmFjdGlvbnMubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woeCk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjdG9yLmZyb21BcnJheShbbmV3IFN5bWJvbChjZi5zaWduKSwgbmV3IFN5bWJvbChjZi53aG9sZSksIGZyYWN0aW9uc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdjb250aW51ZWRfZnJhY3Rpb24nLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBlcnJvciBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGVyZihzeW1ib2wpIHtcclxuICAgICAgICAgICAgdmFyIF9zeW1ib2wgPSBldmFsdWF0ZShzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgaWYoX3N5bWJvbC5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoMi5lcmYoX3N5bWJvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihfc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmVyZihzeW1ib2wpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdlcmYnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1vZCBmdW5jdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2wxXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbDJcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG1vZChzeW1ib2wxLCBzeW1ib2wyKSB7XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbDEuaXNDb25zdGFudCgpICYmIHN5bWJvbDIuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIHJldHZhbC5tdWx0aXBsaWVyID0gcmV0dmFsLm11bHRpcGxpZXIubXVsdGlwbHkoc3ltYm9sMS5tdWx0aXBsaWVyLm1vZChzeW1ib2wyLm11bHRpcGxpZXIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy90cnkgdG8gc2VlIGlmIGRpdmlzaW9uIGhhcyByZW1haW5kZXIgb2YgemVyb1xyXG4gICAgICAgICAgICB2YXIgciA9IF8uZGl2aWRlKHN5bWJvbDEuY2xvbmUoKSwgc3ltYm9sMi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgaWYoaXNJbnQocikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ21vZCcsIFtzeW1ib2wxLCBzeW1ib2wyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgYnJhbmdoaW5nIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjb25kaXRpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJRihjb25kaXRpb24sIGEsIGIpIHtcclxuICAgICAgICAgICAgaWYodHlwZW9mIGNvbmRpdGlvbiAhPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICAgICAgICAgICAgaWYoaXNOdW1lcmljU3ltYm9sKGNvbmRpdGlvbikpXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uID0gISFOdW1iZXIoY29uZGl0aW9uKTtcclxuICAgICAgICAgICAgaWYoY29uZGl0aW9uKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7TWF0cml4fFZlY3RvcnxTZXR8Q29sbGVjdGlvbn0gb2JqXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGl0ZW1cclxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBpc19pbihvYmosIGl0ZW0pIHtcclxuICAgICAgICAgICAgaWYoaXNNYXRyaXgob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IG9iai5yb3dzKCk7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwLCBsMiA9IG9iai5jb2xzKCk7IGogPCBsMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gb2JqLmVsZW1lbnRzW2ldW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlbGVtZW50LmVxdWFscyhpdGVtKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKG9iai5lbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IG9iai5lbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihvYmouZWxlbWVudHNbaV0uZXF1YWxzKGl0ZW0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHN5bWJvbGljIGV4dGVuc2lvbiBmb3Igc2luY1xyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHNpbmMoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUikge1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGgyLnNpbmMoc3ltYm9sKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wYXJzZShmb3JtYXQoJ3Npbih7MH0pLyh7MH0pJywgc3ltYm9sKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ3NpbmMnLCBbc3ltYm9sXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHN5bWJvbGljIGV4dGVuc2lvbiBmb3IgZXhwLiBUaGlzIHdpbGwgYXV0by1jb252ZXJ0IGFsbCBpbnN0YW5jZXMgb2YgZXhwKHgpIHRvIGVeeC5cclxuICAgICAgICAgKiBUaGFua3MgQCBIYXBweXBpZzM3NVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGV4cChzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmZuYW1lID09PSBTZXR0aW5ncy5MT0cgJiYgc3ltYm9sLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnBvdyhzeW1ib2wuYXJnc1swXSwgU3ltYm9sLmNyZWF0ZShzeW1ib2wubXVsdGlwbGllcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKGZvcm1hdCgnZV4oezB9KScsIHN5bWJvbCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdmFsdWUgZGVncmVlcyB0byByYWRpYW5zXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcmFkaWFucyhzeW1ib2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcoezB9KSpwaS8xODAnLCBzeW1ib2wpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHZhbHVlIGZyb20gcmFkaWFucyB0byBkZWdyZWVzXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZGVncmVlcyhzeW1ib2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZm9ybWF0KCcoezB9KSoxODAvcGknLCBzeW1ib2wpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG5yb290cyhzeW1ib2wpIHtcclxuICAgICAgICAgICAgdmFyIGEsIGI7XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gRk4gJiYgc3ltYm9sLmZuYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgYSA9IFN5bWJvbC51bndyYXBQQVJFTlMoXy5wYXJzZShzeW1ib2wpLnRvTGluZWFyKCkpO1xyXG4gICAgICAgICAgICAgICAgYiA9IF8ucGFyc2Uoc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gUCkge1xyXG4gICAgICAgICAgICAgICAgYSA9IF8ucGFyc2Uoc3ltYm9sLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGIgPSBfLnBhcnNlKHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGEgJiYgYiAmJiBhLmdyb3VwID09PSBOICYmIGIuZ3JvdXAgPT09IE4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfcm9vdHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IFN5bWJvbC50b1BvbGFyRm9ybUFycmF5KHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IF8ucGFyc2UoYSkuYWJzKCkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVfTW9pdnJlJTI3c19mb3JtdWxhXHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IGFyZyhhKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBiLm11bHRpcGxpZXIuZGVuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGIubXVsdGlwbGllci5udW0udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybXVsYSA9IFwiKCh7MH0pXih7MX0pKihjb3MoezN9KSsoezJ9KSpzaW4oezN9KSkpXih7NH0pXCI7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBldmFsdWF0ZShfLnBhcnNlKGZvcm1hdChcIigoezB9KSsyKnBpKih7MX0pKS8oezJ9KVwiLCB4LCBpLCBuKSkpLm11bHRpcGxpZXIudG9EZWNpbWFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jvb3RzLnB1c2goZXZhbHVhdGUoXy5wYXJzZShmb3JtYXQoZm9ybXVsYSwgciwgbiwgU2V0dGluZ3MuSU1BR0lOQVJZLCB0LCBwKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3IuZnJvbUFycmF5KF9yb290cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuaXNDb25zdGFudCh0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBzeW1ib2wuc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBldmFsdWF0ZShzeW1ib2wuYWJzKCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBfLnNxcnQoeCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIF9yb290cyA9IFtyb290LmNsb25lKCksIHJvb3QubmVnYXRlKCldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHNpZ24gPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIF9yb290cyA9IF9yb290cy5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkoeCwgU3ltYm9sLmltYWdpbmFyeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9yb290cyA9IFtfLnBhcnNlKHN5bWJvbCldO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLmZyb21BcnJheShfcm9vdHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmF0aW9uYWxpemVzIGEgc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcmF0aW9uYWxpemUoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbXBvc2l0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgIHZhciBudW0sIGRlbiwgcmV0bnVtLCByZXRkZW4sIGEsIGIsIG4sIGQ7XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wuZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IHguZ2V0TnVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVuID0geC5nZXREZW5vbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldG51bSA9IHJldHZhbC5nZXROdW0oKTtcclxuICAgICAgICAgICAgICAgICAgICByZXRkZW4gPSByZXR2YWwuZ2V0RGVub20oKTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gXy5tdWx0aXBseShkZW4sIHJldG51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IF8ubXVsdGlwbHkobnVtLCByZXRkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBfLmV4cGFuZChfLmFkZChhLCBiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZCA9IF8ubXVsdGlwbHkocmV0ZGVuLCBkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKG4sIGQpO1xyXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNxdWFyZSByb290IGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gc3FydChzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoIWlzU3ltYm9sKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IF8ucGFyc2Uoc3ltYm9sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBmb3IgRVhcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oU1FSVCwgW3N5bWJvbF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZm5hbWUgPT09ICcnICYmIHN5bWJvbC5wb3dlci5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuYXJnc1swXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpc19uZWdhdGl2ZSA9IHN5bWJvbC5tdWx0aXBsaWVyLnNpZ24oKSA8IDA7XHJcblxyXG4gICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc0NvbnN0YW50KCkgJiYgIWlzX25lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woYmlnRGVjLnNxcnQoc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxleC5zcXJ0KHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5ncm91cCA9PT0gUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdzcXJ0JywgW3N5bWJvbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgaW1nLCByZXR2YWwsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNDb25zdGFudCA9IHN5bWJvbC5pc0NvbnN0YW50KCk7XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZ3JvdXAgPT09IENCICYmIHN5bWJvbC5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHNxcnQoU3ltYm9sKHN5bWJvbC5tdWx0aXBsaWVyKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHMgaW4gc3ltYm9sLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHN5bWJvbC5zeW1ib2xzW3NdO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBfLm11bHRpcGx5KG0sIHNxcnQoeCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiB0aGUgc3ltYm9sIGlzIGFscmVhZHkgc3FydCB0aGVuIGl0J3MgdGhhdCBzeW1ib2xeKDEvNCkgYW5kIHdlIGNhbiB1bndyYXAgaXRcclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZm5hbWUgPT09IFNRUlQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgbXMgPSBzeW1ib2wubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgIHMuc2V0UG93ZXIoc3ltYm9sLnBvd2VyLm11bHRpcGx5KG5ldyBGcmFjKDAuMjUpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzO1xyXG4gICAgICAgICAgICAgICAgLy9ncmFiIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICBpZighbXMuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkoc3FydChfLnBhcnNlKG1zKSksIHJldHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9pZiB0aGUgc3ltYm9sIGlzIGEgZnJhY3Rpb24gdGhlbiB3ZSBkb24ndCBrZWVwIGNhbiB1bndyYXAgaXQuIEZvciBpbnN0YW5jZVxyXG4gICAgICAgICAgICAvL25vIG5lZWQgdG8ga2VlcCBzcXJ0KHheKDEvMykpXHJcbiAgICAgICAgICAgIGVsc2UgaWYoIXN5bWJvbC5wb3dlci5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnNldFBvd2VyKHN5bWJvbC5wb3dlci5tdWx0aXBseShuZXcgRnJhYygwLjUpKSk7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzeW1ib2w7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wubXVsdGlwbGllciA8IDAgJiYgc3ltYm9sLmdyb3VwID09PSBTKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSBfLnBhcnNlKHN5bWJvbCkudG9Vbml0TXVsdGlwbGllcigpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShfLnN5bWZ1bmN0aW9uKFNldHRpbmdzLlNRUlQsIFtiXSksIHNxcnQoYSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vUmVsYXRlZCB0byBpc3N1ZSAjNDAxLiBTaW5jZSBzcXJ0KGEpKnNxcnQoYl4tMSkgcmVsYXRlcyBpbiBpc3N1ZXMsIHdlJ2xsIGNoYW5nZSB0aGUgZm9ybVxyXG4gICAgICAgICAgICAgICAgLy90byBzcXJ0KGEpKnNxcnQoYileMSBmb3IgYmV0dGVyIHNpbXBsaWZpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAvL3RoZSBzaWduIG9mIHRoZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBzeW1ib2wucG93ZXIuc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhlIHNpZ25cclxuICAgICAgICAgICAgICAgIHN5bWJvbC5wb3dlciA9IHN5bWJvbC5wb3dlci5hYnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBzeW1ib2xzIGlzIGltYWdhcnkgdGhlbiB3ZSBwbGFjZSBpbiB0aGUgaW1hZ2luYXJ5IHBhcnQuIFdlJ2xsIHJldHVybiBpdFxyXG4gICAgICAgICAgICAgICAgLy9hcyBhIHByb2R1Y3RcclxuICAgICAgICAgICAgICAgIGlmKGlzQ29uc3RhbnQgJiYgc3ltYm9sLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBTeW1ib2wuaW1hZ2luYXJ5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLm11bHRpcGxpZXIgPSBzeW1ib2wubXVsdGlwbGllci5hYnMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcSA9IHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxYSA9IE1hdGguYWJzKHEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gTWF0aC5zcXJ0KHFhKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgbTtcclxuICAgICAgICAgICAgICAgIC8vaXQncyBhIHBlcmZlY3Qgc3F1YXJlIHNvIHRha2UgdGhlIHNxdWFyZVxyXG4gICAgICAgICAgICAgICAgaWYoaXNJbnQodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gbmV3IFN5bWJvbCh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNJbnQocSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9ycyA9IE1hdGgyLmlmYWN0b3IocSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR3ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHggaW4gZmFjdG9ycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGZhY3RvcnNbeF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm4gPSAobiAtIChuICUgMikpOyAvL2dldCBvdXQgdGhlIHdob2xlIG51bWJlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm4pIHsgLy9pZiB0aGVyZSBpcyBhIHdob2xlIG51bWJlciAuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gTWF0aC5wb3coeCwgbm4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHcgKj0gTWF0aC5wb3coeCwgbm4gLyAyKTsgLy9hZGQgdG8gdG90YWwgd2hvbGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxIC89IHc7IC8vcmVkdWNlIHRoZSBudW1iZXIgYnkgdGhlIHdob2xlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBfLm11bHRpcGx5KF8uc3ltZnVuY3Rpb24oU1FSVCwgW25ldyBTeW1ib2wocSldKSwgbmV3IFN5bWJvbCh0dykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZWR1Y2UgdGhlIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3IgdXNpbmcgcHJpbWUgZmFjdG9yaXphdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gW25ldyBTeW1ib2woc3ltYm9sLm11bHRpcGxpZXIubnVtKSwgbmV3IFN5bWJvbChzeW1ib2wubXVsdGlwbGllci5kZW4pXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IFtuZXcgU3ltYm9sKDEpLCBuZXcgU3ltYm9sKDEpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3EgPSBbbmV3IFN5bWJvbCgxKSwgbmV3IFN5bWJvbCgxKV07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBwcmltZSBmYWN0b3JzIGFuZCBsb29wIHRocm91Z2ggZWFjaC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGZhY3RvcihuKS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gU3ltYm9sLnVud3JhcFBBUkVOUyh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0geC5jbG9uZSgpLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IE51bWJlcih4LnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vV2UnbGwgY29uc2lkZXIgaXQgc2FmZSB0byB1c2UgdGhlIG5hdGl2ZSBOdW1iZXIgc2luY2UgMl4xMDAwIGlzIGFscmVhZHkgYSBwcmV0dHkgaHVnZSBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW0gPSBwICUgMjsgLy9nZXQgdGhlIHJlbWFpbmRlci4gVGhpcyB3aWxsIGJlIDEgaWYgMyBzaW5jZSBzcXJ0KG5eMikgPSBuIHdoZXJlIG4gaXMgcG9zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKHAgLSByZW0pIC8gMjsgLy9nZXQgdGhlIHdob2xlIG51bWJlcnMgb2Ygbi8yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2ldID0gXy5tdWx0aXBseShyW2ldLCBfLnBvdyhiLCBuZXcgU3ltYm9sKHcpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcVtpXSA9IF8ubXVsdGlwbHkoc3FbaV0sIHNxcnQoXy5wb3coYiwgbmV3IFN5bWJvbChyZW0pKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IF8uZGl2aWRlKF8ubXVsdGlwbHkoclswXSwgc3FbMF0pLCBfLm11bHRpcGx5KHJbMV0sIHNxWzFdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vc3RyaXAgdGhlIG11bHRpcGxpZXIgc2luY2Ugd2UgYWxyZWFkeSB0b29rIHRoZSBzcXJ0XHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wudG9Vbml0TXVsdGlwbGllcih0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vaWYgdGhlIHN5bWJvbCBpcyBvbmUganVzdCByZXR1cm4gb25lIGFuZCBub3QgdGhlIHNxcnQgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5pc09uZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihldmVuKHN5bWJvbC5wb3dlci50b1N0cmluZygpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vanVzdCByYWlzZSBpdCB0byB0aGUgMS8yXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5wb3coc3ltYm9sLmNsb25lKCksIG5ldyBTeW1ib2woMC41KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKFNRUlQsIFtzeW1ib2xdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL3B1dCBiYWNrIHRoZSBzaWduIHRoYXQgd2FzIHJlbW92ZWQgZWFybGllclxyXG4gICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLnBvd2VyLm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKG0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShtLCByZXR2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGltZylcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KGltZywgcmV0dmFsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoaXNfbmVnYXRpdmUgJiYgU2V0dGluZ3MuUEFSU0UyTlVNQkVSKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UocmV0dmFsKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3ViZSByb290IGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gY2JydChzeW1ib2wpIHtcclxuICAgICAgICAgICAgaWYoIXN5bWJvbC5pc0NvbnN0YW50KHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBuID0gc3ltYm9sLnBvd2VyIC8gMztcclxuICAgICAgICAgICAgICAgIC8vdGFrZSB0aGUgY3ViZSByb290IG9mIHRoZSBtdWx0cGxpZXJcclxuICAgICAgICAgICAgICAgIHZhciBtID0gXy5wb3coXy5wYXJzZShzeW1ib2wubXVsdGlwbGllciksIG5ldyBTeW1ib2woMSAvIDMpKTtcclxuICAgICAgICAgICAgICAgIC8vc3RyaXAgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgIHZhciBzeW0gPSBzeW1ib2wudG9Vbml0TXVsdGlwbGllcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vc2ltcGxpZnkgdGhlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICBpZihpc0ludChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucG93KHN5bS50b0xpbmVhcigpLCBfLnBhcnNlKG4pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHN5bS5ncm91cCA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ubXVsdGlwbHkocmV0dmFsLCBjYnJ0KHgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdjYnJ0JywgW3N5bV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShtLCByZXR2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudGhyb290KHN5bWJvbCwgbmV3IFN5bWJvbCgzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzY2llbnRpZmljKHN5bWJvbCwgc2lnZmlncykge1xyXG4gICAgICAgICAgICAvL0p1c3Qgc2V0IHRoZSBmbGFnIGFuZCBrZWVwIGl0IG1vdmluZy4gU3ltYm9sLnRvU3RyaW5nIHdpbGwgZGVhbCB3aXRoIGhvdyB0b1xyXG4gICAgICAgICAgICAvL2Rpc3BsYXkgdGhpc1xyXG4gICAgICAgICAgICBzeW1ib2wuc2NpZW50aWZpYyA9IHNpZ2ZpZ3MgfHwgMTA7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBudW0gLSB0aGUgbnVtYmVyIGJlaW5nIHJhaXNlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBwIC0gdGhlIGV4cG9uZW50XHJcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSBwcmVjIC0gdGhlIHByZWNpc2lvbiB3YW50ZWRcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2x9IGFzYmlnIC0gdHJ1ZSBpZiBhIGJpZ0RlY2ltYWwgaXMgd2FudGVkXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBudGhyb290KG51bSwgcCwgcHJlYywgYXNiaWcpIHtcclxuICAgICAgICAgICAgLy9jbG9uZSBwIGFuZCBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgIHAgPSBldmFsdWF0ZShfLnBhcnNlKHApKTtcclxuXHJcbiAgICAgICAgICAgIC8vY2Fubm90IGNhbGN1bGF0ZSBpZiBwID0gMC4gbnRocm9vdCgwLCAwKSA9PiAwXigxLzApID0+IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICBpZihwLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKCdVbmFibGUgdG8gY2FsY3VsYXRlIG50aHJvb3RzIG9mIHplcm8nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9TdG9wIGNvbXB1dGF0aW9uIGlmIGl0IG5lZ2F0aXZlIGFuZCBldmVuIHNpbmNlIHdlIGhhdmUgYW4gaW1hZ2luYXJ5IHJlc3VsdFxyXG4gICAgICAgICAgICBpZihudW0gPCAwICYmIGV2ZW4ocCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxjdWxhdGUgbnRocm9vdCBvZiBuZWdhdGl2ZSBudW1iZXIgZm9yIGV2ZW4gcG93ZXJzJyk7XHJcblxyXG4gICAgICAgICAgICAvL3JldHVybiBub24gbnVtZXJpYyB2YWx1ZXMgdW5ldmFsdWF0ZWRcclxuICAgICAgICAgICAgaWYoIW51bS5pc0NvbnN0YW50KHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignbnRocm9vdCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZXZhbHVhdGUgbnVtZXJpYyB2YWx1ZXNcclxuICAgICAgICAgICAgaWYobnVtLmdyb3VwICE9PSBOKSB7XHJcbiAgICAgICAgICAgICAgICBudW0gPSBldmFsdWF0ZShudW0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2RlZmF1bHQgaXMgdG8gcmV0dXJuIGEgYmlnIHZhbHVlXHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBhc2JpZyA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICBhc2JpZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBwcmVjID0gcHJlYyB8fCAyNTtcclxuXHJcbiAgICAgICAgICAgIHZhciBzaWduID0gbnVtLnNpZ24oKTtcclxuICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgdmFyIGFucztcclxuXHJcbiAgICAgICAgICAgIGlmKHNpZ24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBudW0gPSBhYnMobnVtKTsgLy9yZW1vdmUgdGhlIHNpZ25cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoaXNJbnQobnVtKSAmJiBwLmlzQ29uc3RhbnQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKG51bSA8IDE4NDQ2NzQ0MDczNzA5NTUxNjE2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8yXjY0XHJcbiAgICAgICAgICAgICAgICAgICAgYW5zID0gRnJhYy5jcmVhdGUoTWF0aC5wb3cobnVtLCAxIC8gcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5zID0gTWF0aDIubnRocm9vdChudW0sIHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICBpZihhc2JpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woYW5zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IG5ldyBTeW1ib2woYW5zLnRvRGVjaW1hbChwcmVjKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkobmV3IFN5bWJvbChzaWduKSwgcmV0dmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGZhY3RvcihzeW1ib2wpIHtcclxuICAgICAgICAgICAgLy9GaXggaXNzdWUgIzQ1OCB8IG5lcmRhbWVyKFwic3FydCgxLSgzLjMzMzMzMzM1NTA1MjA5MjZlLTcpXjIpXCIpLmV2YWx1YXRlKCkudGV4dCgpXHJcbiAgICAgICAgICAgIC8vTW9yZSBCaWcgTnVtYmVyIGlzc3VlcyA+OihcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyZWF0ZXJUaGFuKDkuOTk5OTk5OTk5OTk4ODkxZSs0MSkgfHwgc3ltYm9sLmVxdWFscygtMSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAvL0ZpeCBpc3N1ZSAjMjk4XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5lcXVhbHMoTWF0aC5QSSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLlBJKTtcclxuICAgICAgICAgICAgLy9ldmFsdWF0ZSB0aGUgc3ltYm9sIHRvIG1lcmdlIGNvbnN0YW50c1xyXG4gICAgICAgICAgICBzeW1ib2wgPSBldmFsdWF0ZShzeW1ib2wuY2xvbmUoKSk7XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIHZhciBtID0gc3ltYm9sLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBpZihpc0ludChtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3JzID0gTWF0aDIuaWZhY3RvcihtKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGZhY3RvciBpbiBmYWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gZmFjdG9yc1tmYWN0b3JdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgXy5zeW1mdW5jdGlvbigncGFyZW5zJywgW25ldyBTeW1ib2woZmFjdG9yKS5zZXRQb3dlcihuZXcgRnJhYyhwKSldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBwZmFjdG9yKG5ldyBTeW1ib2woc3ltYm9sLm11bHRpcGxpZXIubnVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBwZmFjdG9yKG5ldyBTeW1ib2woc3ltYm9sLm11bHRpcGxpZXIuZGVuKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShfLnN5bWZ1bmN0aW9uKCdwYXJlbnMnLCBbbl0pLCBfLnN5bWZ1bmN0aW9uKCdwYXJlbnMnLCBbZF0pLmludmVydCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnN5bWZ1bmN0aW9uKCdwZmFjdG9yJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHZhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCdzIHRoZSByZWFsIHBhcnQgb2YgYSBjb21wbGV4IG51bWJlci4gUmV0dXJuIG51bWJlciBpZiByZWFsXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhbHBhcnQoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2wucmVhbHBhcnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCdzIHRoZSBpbWFnaW5hcnkgcGFydCBvZiBhIGNvbXBsZXggbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaW1hZ3BhcnQoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2wuaW1hZ3BhcnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXB1dGVzIHRoZSBjb25qdWdhdGUgb2YgYSBjb21wbGV4IG51bWJlclxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvbmp1Z2F0ZShzeW1ib2wpIHtcclxuICAgICAgICAgICAgdmFyIHJlID0gc3ltYm9sLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgIHZhciBpbSA9IHN5bWJvbC5pbWFncGFydCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5hZGQocmUsIF8ubXVsdGlwbHkoaW0ubmVnYXRlKCksIFN5bWJvbC5pbWFnaW5hcnkoKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYXJ1Z21lbnQgb2YgYSBjb21wbGV4IG51bWJlclxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGFyZyhzeW1ib2wpIHtcclxuICAgICAgICAgICAgdmFyIHJlID0gc3ltYm9sLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgIHZhciBpbSA9IHN5bWJvbC5pbWFncGFydCgpO1xyXG4gICAgICAgICAgICBpZihyZS5pc0NvbnN0YW50KCkgJiYgaW0uaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5hdGFuMihpbSwgcmUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ2F0YW4yJywgW2ltLCByZV0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgYXJ1Z21lbnQgb2YgYSBjb21wbGV4IG51bWJlclxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBzeW1ib2xcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGFyZyhzeW1ib2wpIHtcclxuICAgICAgICAgICAgdmFyIHJlID0gc3ltYm9sLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgIHZhciBpbSA9IHN5bWJvbC5pbWFncGFydCgpO1xyXG4gICAgICAgICAgICBpZihyZS5pc0NvbnN0YW50KCkgJiYgaW0uaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZihpbS5lcXVhbHMoMCkgJiYgcmUuZXF1YWxzKC0xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKCdwaScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihpbS5lcXVhbHMoMSkgJiYgcmUuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoJ3BpLzInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaW0uZXF1YWxzKDEpICYmIHJlLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKCdwaS80Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmF0YW4yKGltLCByZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdhdGFuMicsIFtpbSwgcmVdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBvbGFyZm9ybSBvZiBhIGNvbXBsZXggbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcG9sYXJmb3JtKHN5bWJvbCkge1xyXG4gICAgICAgICAgICB2YXIgcCwgciwgZSwgdGhldGE7XHJcbiAgICAgICAgICAgIHAgPSBTeW1ib2wudG9Qb2xhckZvcm1BcnJheShzeW1ib2wpO1xyXG4gICAgICAgICAgICB0aGV0YSA9IHBbMV07XHJcbiAgICAgICAgICAgIHIgPSBwWzBdO1xyXG4gICAgICAgICAgICBlID0gXy5wYXJzZShmb3JtYXQoJ2VeKHswfSooezF9KSknLCBTZXR0aW5ncy5JTUFHSU5BUlksIHRoZXRhKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KHIsIGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVjdGFuZ3VsYXIgZm9ybSBvZiBhIGNvbXBsZXggbnVtYmVyLiBEb2VzIG5vdCB3b3JrIGZvciBzeW1ib2xpYyBjb2VmZmljaWVudHNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gc3ltYm9sXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiByZWN0Zm9ybShzeW1ib2wpIHtcclxuICAgICAgICAgICAgLy9UT0RPOiBlXigoaSpwaSkvNClcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gc3ltYm9sLmNsb25lKCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiwgcCwgcSwgcywgaCwgZCwgbjtcclxuICAgICAgICAgICAgICAgIGYgPSBkZWNvbXBvc2VfZm4oc3ltYm9sLCAnZScsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcCA9IF8uZGl2aWRlKGYueC5wb3dlciwgU3ltYm9sLmltYWdpbmFyeSgpKTtcclxuICAgICAgICAgICAgICAgIHEgPSBldmFsdWF0ZSh0cmlnLnRhbihwKSk7XHJcbiAgICAgICAgICAgICAgICBzID0gXy5wb3coZi5hLCBuZXcgU3ltYm9sKDIpKTtcclxuICAgICAgICAgICAgICAgIGQgPSBxLmdldERlbm9tKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHEuZ2V0TnVtKCk7XHJcbiAgICAgICAgICAgICAgICBoID0gU3ltYm9sLmh5cChuLCBkKTtcclxuICAgICAgICAgICAgICAgIC8vY2hlY2tcclxuICAgICAgICAgICAgICAgIGlmKGguZXF1YWxzKGYuYSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQoZCwgXy5tdWx0aXBseShTeW1ib2wuaW1hZ2luYXJ5KCksIG4pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHN5bU1pbk1heChmLCBhcmdzKSB7XHJcbiAgICAgICAgICAgIGFyZ3MubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICB4Lm51bVZhbCA9IGV2YWx1YXRlKHgpLm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgbCwgYSwgYiwgYV92YWwsIGJfdmFsO1xyXG4gICAgICAgICAgICB3aGlsZSh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBsID0gYXJncy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBpZihsIDwgMilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgIGEgPSBhcmdzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYiA9IGFyZ3NbbCAtIDJdO1xyXG4gICAgICAgICAgICAgICAgaWYoZiA9PT0gJ21pbicgPyBhLm51bVZhbCA8IGIubnVtVmFsIDogYS5udW1WYWwgPiBiLm51bVZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIG1heGltdW0gb2YgYSBzZXQgb2YgbnVtYmVyc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWF4KCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgaWYoYWxsU2FtZShhcmdzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xyXG4gICAgICAgICAgICBpZihhbGxOdW1iZXJzKGFyZ3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5tYXguYXBwbHkobnVsbCwgYXJncykpO1xyXG4gICAgICAgICAgICBpZihTZXR0aW5ncy5TWU1CT0xJQ19NSU5fTUFYICYmIGFsbENvbnN0YW50cyhhcmdzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1NaW5NYXgoJ21heCcsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignbWF4JywgYXJncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIG1pbmltdW0gb2YgYSBzZXQgb2YgbnVtYmVyc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gbWluKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgaWYoYWxsU2FtZShhcmdzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzWzBdO1xyXG4gICAgICAgICAgICBpZihhbGxOdW1iZXJzKGFyZ3MpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTWF0aC5taW4uYXBwbHkobnVsbCwgYXJncykpO1xyXG4gICAgICAgICAgICBpZihTZXR0aW5ncy5TWU1CT0xJQ19NSU5fTUFYICYmIGFsbENvbnN0YW50cyhhcmdzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1NaW5NYXgoJ21pbicsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignbWluJywgYXJncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIGEgbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHhcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3ltYm9sfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xyXG4gICAgICAgICAgICBpZih4LmlzQ29uc3RhbnQodHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLnNpZ24oZXZhbHVhdGUoeCkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ3NpZ24nLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc29ydChzeW1ib2wsIG9wdCkge1xyXG4gICAgICAgICAgICBvcHQgPSBvcHQgPyBvcHQudG9TdHJpbmcoKSA6ICdhc2MnO1xyXG4gICAgICAgICAgICB2YXIgZ2V0dmFsID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmKGUuZ3JvdXAgPT09IE4pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgIGlmKGUuZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZS5mbmFtZSA9PT0gJycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXR2YWwoZS5hcmdzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZS5mbmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGUuZ3JvdXAgPT09IFMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUucG93ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBzeW1ib2xzID0gaXNWZWN0b3Ioc3ltYm9sKSA/IHN5bWJvbC5lbGVtZW50cyA6IHN5bWJvbC5jb2xsZWN0U3ltYm9scygpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihzeW1ib2xzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdmFsID0gZ2V0dmFsKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidmFsID0gZ2V0dmFsKGIpO1xyXG4gICAgICAgICAgICAgICAgaWYob3B0ID09PSAnZGVzYycpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ2YWwgLSBhdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWwgLSBidmFsO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG9nIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiYXNlXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBsb2coc3ltYm9sLCBiYXNlKSB7XHJcblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5mbmFtZSA9PT0gU1FSVCAmJiBzeW1ib2wubXVsdGlwbGllci5lcXVhbHMoMSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uZGl2aWRlKGxvZyhzeW1ib2wuYXJnc1swXSksIG5ldyBTeW1ib2woMikpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5wb3dlci5zaWduKCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4aXQgZWFybHlcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vbG9nKDApIGlzIHVuZGVmaW5lZCBzbyBjb21wbGFpblxyXG4gICAgICAgICAgICBpZihzeW1ib2wuZXF1YWxzKDApKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoU2V0dGluZ3MuTE9HICsgJygwKSBpcyB1bmRlZmluZWQhJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZGVhbCB3aXRoIGltYWdpbmFyeSB2YWx1ZXNcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV4LmV2YWx1YXRlKHN5bWJvbCwgU2V0dGluZ3MuTE9HKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc3ltYm9sLmlzQ29uc3RhbnQoKSAmJiB0eXBlb2YgYmFzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgYmFzZS5pc0NvbnN0YW50KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb2dfc3ltID0gTWF0aC5sb2coc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIHZhciBsb2dfYmFzZSA9IE1hdGgubG9nKGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbChsb2dfc3ltIC8gbG9nX2Jhc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmdyb3VwID09PSBFWCAmJiBzeW1ib2wucG93ZXIubXVsdGlwbGllci5sZXNzVGhhbigwKSB8fCBzeW1ib2wucG93ZXIudG9TdHJpbmcoKSA9PT0gJy0xJykge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLnBvd2VyLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgLy9tb3ZlIHRoZSBuZWdhdGl2ZSBvdXRzaWRlIGJ1dCBrZWVwIHRoZSBwb3NpdGl2ZSBpbnNpZGUgOilcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IGxvZyhzeW1ib2wpLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLnZhbHVlID09PSAnZScgJiYgc3ltYm9sLm11bHRpcGxpZXIuZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHN5bWJvbC5wb3dlcjtcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IGlzU3ltYm9sKHApID8gcCA6IG5ldyBTeW1ib2wocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IEZOICYmIHN5bWJvbC5mbmFtZSA9PT0gJ2V4cCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wubXVsdGlwbGllci5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShzLCBuZXcgU3ltYm9sKHN5bWJvbC5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oU2V0dGluZ3MuTE9HLCBbc3ltYm9sXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgaXNOdW1lcmljU3ltYm9sKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGZvciBzYWZldHkuXHJcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBfLnBhcnNlKHN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGltZ19wYXJ0O1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLm11bHRpcGxpZXIubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW1nX3BhcnQgPSBfLm11bHRpcGx5KG5ldyBTeW1ib2woTWF0aC5QSSksIG5ldyBTeW1ib2woJ2knKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbChNYXRoLmxvZyhzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGltZ19wYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5hZGQocmV0dmFsLCBpbWdfcGFydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHM7XHJcbiAgICAgICAgICAgICAgICBpZighc3ltYm9sLnBvd2VyLmVxdWFscygxKSAmJiAhc3ltYm9sLmNvbnRhaW5zKCdlJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gc3ltYm9sLmdyb3VwID09PSBFWCA/IHN5bWJvbC5wb3dlciA6IG5ldyBTeW1ib2woc3ltYm9sLnBvd2VyKTtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wudG9MaW5lYXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vbG9nKGEsYSkgPSAxIHNpbmNlIHRoZSBiYXNlIGlzIGFsbG93ZWQgdG8gYmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIC8vVGhpcyB3YXMgcG9pbnRlZCBvdXQgYnkgSGFwcHlwaWczNzUgaW4gaXNzdWUgIzI4MFxyXG4gICAgICAgICAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYWxsU2FtZShhcmd1bWVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8uc3ltZnVuY3Rpb24oU2V0dGluZ3MuTE9HLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShzLCByZXR2YWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm91bmQgYSBudW1iZXIgdXAgdG8gcyBkZWNpbWFsIHBsYWNlc1xyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHMgLSB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiByb3VuZCh4LCBzKSB7XHJcbiAgICAgICAgICAgIHZhciBzSXNDb25zdGFudCA9IHMgJiYgcy5pc0NvbnN0YW50KCkgfHwgdHlwZW9mIHMgPT09ICd1bmRlZmluZWQnO1xyXG4gICAgICAgICAgICBpZih4LmlzQ29uc3RhbnQoKSAmJiBzSXNDb25zdGFudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYsIGUsIGV4cCwgcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgdiA9IHg7XHJcbiAgICAgICAgICAgICAgICAvL3JvdW5kIHRoZSBjb2VmZmljaWVudCBvZiB0aGVuIG51bWJlciBidXQgbm90IHRoZSBhY3R1YWwgZGVjaW1hbCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgLy93ZSBrbm93IHRoaXMgYmVjYXVzZSBhIG5lZ2F0aXZlIG51bWJlciB3YXMgcGFzc2VkXHJcbiAgICAgICAgICAgICAgICBpZihzICYmIHMubGVzc1RoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gYWJzKHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29udmVydCB0aGUgbnVtYmVyIHRvIGV4cG9uZW50aWFsIGZvcm1cclxuICAgICAgICAgICAgICAgICAgICBlID0gTnVtYmVyKHgpLnRvRXhwb25lbnRpYWwoKS50b1N0cmluZygpLnNwbGl0KCdlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9wb2ludCB2IHRvIHRoZSBjb2VmZmljaWVudCBvZiB0aGVuIG51bWJlclxyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBlWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBleHBvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICBleHAgPSBlWzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9yb3VuZCB0aGUgbnVtYmVyIHRvIHRoZSByZXF1ZXN0ZWQgcHJlY2lzaW9uXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKG5yb3VuZCh2LCBOdW1iZXIocyB8fCAwKSkpO1xyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGVyZSdzIGEgZXhwb25lbnQgdGhlbiBwdXQgaXQgYmFja1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubXVsdGlwbHkocmV0dmFsLCBfLnBvdyhuZXcgU3ltYm9sKDEwKSwgbmV3IFN5bWJvbChleHAgfHwgMCkpKVxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ3JvdW5kJywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHF1YWRyYW50IG9mIHRoZSB0cmlnIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtGcmFjfSBtXHJcbiAgICAgICAgICogQHJldHVybnMge0ludH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBnZXRRdWFkcmFudChtKSB7XHJcbiAgICAgICAgICAgIHZhciB2ID0gbSAlIDIsIHF1YWRyYW50O1xyXG5cclxuICAgICAgICAgICAgaWYodiA8IDApXHJcbiAgICAgICAgICAgICAgICB2ID0gMiArIHY7IC8vcHV0IGl0IGluIHRlcm1zIG9mIHBpXHJcblxyXG4gICAgICAgICAgICBpZih2ID49IDAgJiYgdiA8PSAwLjUpXHJcbiAgICAgICAgICAgICAgICBxdWFkcmFudCA9IDE7XHJcbiAgICAgICAgICAgIGVsc2UgaWYodiA+IDAuNSAmJiB2IDw9IDEpXHJcbiAgICAgICAgICAgICAgICBxdWFkcmFudCA9IDI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYodiA+IDEgJiYgdiA8PSAxLjUpXHJcbiAgICAgICAgICAgICAgICBxdWFkcmFudCA9IDM7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHF1YWRyYW50ID0gNDtcclxuICAgICAgICAgICAgcmV0dXJuIHF1YWRyYW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBTZXJ2ZXMgYXMgYSBicmlkZ2UgYmV0d2VlbiBudW1iZXJzIGFuZCBiaWdOdW1iZXJzXHJcbiAgICAgICAgICogQHBhcmFtIHtGcmFjfE51bWJlcn0gblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gYmlnQ29udmVydChuKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc0Zpbml0ZShuKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24obik7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBTeW1ib2woU3RyaW5nKE1hdGguYWJzKG4pKSk7XHJcbiAgICAgICAgICAgICAgICByLm11bHRpcGxpZXIgPSByLm11bHRpcGxpZXIubXVsdGlwbHkobmV3IEZyYWMoc2lnbikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoaXNTeW1ib2wobikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICAgICAgaWYodHlwZW9mIG4gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBGcmFjLnNpbXBsZShuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbmV3IEZyYWMobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzeW1ib2wgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICBzeW1ib2wubXVsdGlwbGllciA9IG47XHJcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2xlYW4oc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBmdW5jdGlvbnMgd2l0aCBudW1lcmljIHZhbHVlc1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgZGVub21pbmF0b3Igd2l0aGluIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0cmlnIHNpbXBsaWZpY2F0aW9uc1xyXG4gICAgICAgICAgICB2YXIgZyA9IHN5bWJvbC5ncm91cCwgcmV0dmFsO1xyXG4gICAgICAgICAgICAvL05vdyBsZXQncyBnZXQgdG8gd29ya1xyXG4gICAgICAgICAgICBpZihnID09PSBDUCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHN5bWJvbC5nZXROdW0oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuID0gc3ltYm9sLmdldERlbm9tKCkgfHwgbmV3IFN5bWJvbCgxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IE51bWJlcihzeW1ib2wucG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3IgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnMocCkgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZW4uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih4Lmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gXy5tdWx0aXBseShmYWN0b3IsIGNsZWFuKHguZ2V0RGVub20oKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoeC5wb3dlci5sZXNzVGhhbigwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gXy5tdWx0aXBseShmYWN0b3IsIGNsZWFuKHguY2xvbmUoKS50b1VuaXRNdWx0aXBsaWVyKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X2RlbiA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ub3cgZGl2aWRlIG91dCB0aGUgZmFjdG9yIGFuZCBhZGQgdG8gbmV3IGRlblxyXG4gICAgICAgICAgICAgICAgICAgIGRlbi5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19kZW4gPSBfLmFkZChfLmRpdmlkZSh4LCBmYWN0b3IuY2xvbmUoKSksIG5ld19kZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3IuaW52ZXJ0KCk7IC8vaW52ZXJ0IHNvIGl0IGNhbiBiZSBhZGRlZCB0byB0aGUgdG9wXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19udW07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobnVtLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X251bSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bS5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfbnVtID0gXy5hZGQoXy5tdWx0aXBseShjbGVhbih4KSwgZmFjdG9yLmNsb25lKCkpLCBuZXdfbnVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X251bSA9IF8ubXVsdGlwbHkoZmFjdG9yLCBudW0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLmRpdmlkZShuZXdfbnVtLCBuZXdfZGVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KHJldHZhbCwgXy5jbGVhbih4KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGcgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuYXJncy5sZW5ndGggPT09IDEgJiYgc3ltYm9sLmFyZ3NbMF0uaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGJsb2NrKCdQQVJTRTJOVU1CRVInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKCFyZXR2YWwpXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBzeW1ib2w7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB3cmFwcGVyIGZvciB0aGUgZXhwYW5kIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IHN5bWJvbFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZXhwYW5kYWxsKHN5bWJvbCwgb3B0KSB7XHJcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRfZGVub21pbmF0b3I6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBleHBhbmRfZnVuY3Rpb25zOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBleHBhbmQoc3ltYm9sLCBvcHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFeHBhbmRzIGEgc3ltYm9sXHJcbiAgICAgICAgICogQHBhcmFtIHN5bWJvbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIE9sZCBleHBhbmRcclxuICAgICAgICBmdW5jdGlvbiBleHBhbmQoc3ltYm9sLCBvcHQpIHtcclxuICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmQoeCwgb3B0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcclxuICAgICAgICAgICAgLy9kZWFsIHdpdGggcGFyZW50aGVzaXNcclxuICAgICAgICAgICAgaWYoc3ltYm9sLmdyb3VwID09PSBGTiAmJiBzeW1ib2wuZm5hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGV4cGFuZChzeW1ib2wuYXJnc1swXSwgb3B0KTtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gZXhwYW5kKF8ucG93KGYsIF8ucGFyc2Uoc3ltYm9sLnBvd2VyKSksIG9wdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tdWx0aXBseShfLnBhcnNlKHN5bWJvbC5tdWx0aXBsaWVyKSwgeCkuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBXZSBjYW4gZXhwYW5kIHRoZXNlIGdyb3VwcyBzbyBubyBuZWVkIHRvIHdhc3RlIHRpbWUuIEp1c3QgcmV0dXJuIGFuZCBiZSBkb25lLlxyXG4gICAgICAgICAgICBpZihbTiwgUCwgU10uaW5kZXhPZihzeW1ib2wuZ3JvdXApICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDsgLy9ub3RoaW5nIHRvIGRvXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHN5bWJvbC5jbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHVwIGEgdHJ5LWNhdGNoIGJsb2NrLiBJZiBhbnl0aGluZyBnb2VzIHdyb25nIHRoZW4gd2Ugc2ltcGx5IHJldHVybiB0aGUgb3JpZ2luYWwgc3ltYm9sXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgcG93ZXIgYW5kIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgIHZhciBtID0gc3ltYm9sLm11bHRpcGxpZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gTnVtYmVyKHN5bWJvbC5wb3dlcik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gc3ltYm9sO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSAoYStiKV4yIHwgKHgreF4yKV4yXHJcbiAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb21wb3NpdGUoKSAmJiBpc0ludChzeW1ib2wucG93ZXIpICYmIHN5bWJvbC5wb3dlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHAgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIHRoZSBleHByZXNzaW9uIG9mIGl0J3MgbXVsdGlwbGllciBhbmQgcG93ZXIuIFdlJ2xsIGNhbGwgaXQgZi4gVGhlIHBvd2VyIHdpbGwgYmUgcCBhbmQgdGhlIG11bHRpcGxpZXIgbS5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IG5ldyBTeW1ib2woMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBfLmFkZChmLCBleHBhbmQoXy5wYXJzZSh4KSwgb3B0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZCA9IF8ucGFyc2UoZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSBtaXgoZXhwYW5kZWQsIGYsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KF8ucGFyc2UobSksIGV4cGFuZGVkKS5kaXN0cmlidXRlTXVsdGlwbGllcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IEZOICYmIG9wdC5leHBhbmRfZnVuY3Rpb25zID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFeHBhbmQgZnVuY3Rpb24gdGhlIGFyZ3VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5hcmdzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGV4cGFuZCh4LCBvcHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQdXQgYmFjayB0aGUgcG93ZXIgYW5kIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLnBvdyhfLnN5bWZ1bmN0aW9uKHN5bWJvbC5mbmFtZSwgYXJncyksIF8ucGFyc2Uoc3ltYm9sLnBvd2VyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIF8ucGFyc2Uoc3ltYm9sLm11bHRpcGxpZXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkgJiYgaXNJbnQoc3ltYm9sLnBvd2VyKSAmJiBzeW1ib2wucG93ZXIgPCAwICYmIG9wdC5leHBhbmRfZGVub21pbmF0b3IgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnZlcnQgaXQuIEV4cGFuZCBpdCBhbmQgdGhlbiByZS1pbnZlcnQgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGV4cGFuZChzeW1ib2wsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsLmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzeW1ib2wuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmsgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2gocy5ncm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUEw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENCOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBGTjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIChhK2IpKGMrZCkuIFRoZSByZXN1bHQgd2lsbCBiZSAoYSpjK2EqZCkrKGIqYytiKmQpLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHN0YXJ0IGJ5IG1vdmluZyBjb2xsZWN0aW5nIHRoZSBzeW1ib2xzLiBXZSB3YW50IG90aGVycz5GTj5DQj5QTD5DUFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW1ib2xzID0gc3ltYm9sLmNvbGxlY3RTeW1ib2xzKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmFuayhiKSAtIHJhbmsoYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc3RyaWJ1dGUgdGhlIHBvd2VyIHRvIGVhY2ggc3ltYm9sIGFuZCBleHBhbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IF8ucG93KHMsIF8ucGFyc2UocCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gZXhwYW5kKHgsIG9wdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBzeW1ib2xzLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3Qgc3ltYm9scyBpc24ndCBhIGNvbXBvc2l0ZSB0aGVuIHdlJ3JlIGRvbmVcclxuICAgICAgICAgICAgICAgICAgICBpZihmLmlzQ29tcG9zaXRlKCkgJiYgZi5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IG1peChmLCBzLCBvcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGYgaXMgb2YgZ3JvdXAgUEwgb3IgQ1AgdGhlbiB3ZSBjYW4gZXhwYW5kIHNvbWUgbW9yZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihmLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGYucG93ZXIgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IGV4cGFuZChfLnBvdyhmLCBfLnBhcnNlKGYucG93ZXIpKSwgb3B0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1dCBiYWNrIHRoZSBtdWx0aXBsaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBfLm11bHRpcGx5KF8ucGFyc2UobSksIGYpLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIGV4cGFuZGVkIGF0IHRoaXMgcG9pbnQgc28gaWYgaXQncyBzdGlsbCBhIENCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGp1c3QgcmV0dXJuIHRoZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgbXVsdGlwbHkgYmFjayBpbiB0aGUgZXhwYW5kZWQgZm9ybSBvZiBlYWNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGJhY2sgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gXy5tdWx0aXBseShyZXR2YWwsIF8ucGFyc2UobSkpLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGV4aXN0cyBzb2xlbHkgYXMgYSBxdWljayBmaXggZm9yIHNxcnQoMTEpKnNxcnQoMzMpIG5vdCBzaW1wbGlmeWluZy5cclxuICAgICAgICAgICAgICAgICAgICBpZihyZXR2YWwuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IF8ucGFyc2UocmV0dmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UganVzdCByZXR1cm4gdGhlIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBGaW5hbCBjbGVhbnVwIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2goZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGlkZW50aXR5IG1hdHJpeCBvZiBueG5cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gblxyXG4gICAgICAgICAqIEByZXR1cm5zIHtNYXRyaXh9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaW1hdHJpeChuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRyaXguaWRlbnRpdHkobik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXRyaWV2ZXMgYW5kIGl0ZW0gZnJvbSBhIHZlY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yfSB2ZWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICAgICAgICAgKiBAcmV0dXJucyB7VmVjdG9yfFN5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiB2ZWNnZXQodmVjdG9yLCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZihpbmRleC5pc0NvbnN0YW50KCkgJiYgaXNJbnQoaW5kZXgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlY3Rvci5lbGVtZW50c1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCd2ZWNnZXQnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gYSB2ZWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3Rvcn0gdmVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRvbGVyYW5jZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtWZWN0b3J9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gdmVjdHJpbSh2ZWN0b3IsIHRvbGVyYW5jZSkge1xyXG4gICAgICAgICAgICB0b2xlcmFuY2UgPSB0eXBlb2YgdG9sZXJhbmNlID09PSAndW5kZWZpbmVkJyA/IDFlLTE0IDogdG9sZXJhbmNlO1xyXG5cclxuICAgICAgICAgICAgdmVjdG9yID0gdmVjdG9yLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICB0b2xlcmFuY2UgPSBOdW1iZXIodG9sZXJhbmNlKTtcclxuICAgICAgICAgICAgLy9wbGFjZSBhbGdlYnJhaWMgc29sdXRpb25zIGZpcnN0XHJcbiAgICAgICAgICAgIHZlY3Rvci5lbGVtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5ncm91cCAtIGEuZ3JvdXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvL2RlcGVuZGluZyBvbiB0aGUgc3RhcnQgcG9pbnQgd2UgbWF5IGhhdmUgZHVwbGljYXRlcyBzbyB3ZSBuZWVkIHRvIGNsZWFuIHRob3NlIHVwIGEgYml0LlxyXG4gICAgICAgICAgICAvL3N0YXJ0IGJ5IGNyZWF0aW5nIGFuIG9iamVjdCB3aXRoIHRoZSBzb2x1dGlvbiBhbmQgdGhlIG51bWVyaWMgdmFsdWUuIFRoaXMgd2F5IHdlIGRvbid0IGRlc3Ryb3kgYWxnZWJyYWljIHZhbHVlc1xyXG4gICAgICAgICAgICB2ZWN0b3IuZWxlbWVudHMgPSByZW1vdmVEdXBsaWNhdGVzKHZlY3Rvci5lbGVtZW50cywgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gTnVtYmVyKF8uc3VidHJhY3QoZXZhbHVhdGUoYSksIGV2YWx1YXRlKGIpKS5hYnMoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA8PSB0b2xlcmFuY2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBhIHZhbHVlIGZvciBhIHZlY3RvciBhdCBhIGdpdmVuIGluZGV4XHJcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3J9IHZlY3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtWZWN0b3J9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gdmVjc2V0KHZlY3RvciwgaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmKCFpbmRleC5pc0NvbnN0YW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oJ3ZlY3NldCcsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIHZlY3Rvci5lbGVtZW50c1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1hdGdldChtYXRyaXgsIGksIGopIHtcclxuICAgICAgICAgICAgaWYoaS5pc0NvbnN0YW50KCkgJiYgai5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0cml4LmVsZW1lbnRzW2ldW2pdO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignbWF0Z2V0JywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1hdGdldHJvdyhtYXRyaXgsIGkpIHtcclxuICAgICAgICAgICAgaWYoaS5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdHJpeChtYXRyaXguZWxlbWVudHNbaV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignbWF0Z2V0cm93JywgYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1hdHNldHJvdyhtYXRyaXgsIGksIHgpIHtcclxuICAgICAgICAgICAgLy9oYW5kbGUgc3ltYm9saWNzXHJcbiAgICAgICAgICAgIGlmKCFpLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdtYXRzZXRyb3cnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBpZihtYXRyaXguZWxlbWVudHNbaV0ubGVuZ3RoICE9PSB4LmVsZW1lbnRzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEaW1lbnNpb25FcnJvcignTWF0cml4IHJvdyBtdXN0IG1hdGNoIHJvdyBkaW1lbnNpb25zIScpO1xyXG4gICAgICAgICAgICB2YXIgTSA9IG1hdHJpeC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBNLmVsZW1lbnRzW2ldID0geC5jbG9uZSgpLmVsZW1lbnRzO1xyXG4gICAgICAgICAgICByZXR1cm4gTTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG1hdGdldGNvbChtYXRyaXgsIGNvbF9pbmRleCkge1xyXG4gICAgICAgICAgICAvL2hhbmRsZSBzeW1ib2xpY3NcclxuICAgICAgICAgICAgaWYoIWNvbF9pbmRleC5pc0NvbnN0YW50KCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5zeW1mdW5jdGlvbignbWF0Z2V0Y29sJywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgY29sX2luZGV4ID0gTnVtYmVyKGNvbF9pbmRleCk7XHJcbiAgICAgICAgICAgIHZhciBNID0gTWF0cml4LmZyb21BcnJheShbXSk7XHJcbiAgICAgICAgICAgIG1hdHJpeC5lYWNoKGZ1bmN0aW9uICh4LCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICBpZihqID09PSBjb2xfaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBNLmVsZW1lbnRzLnB1c2goW3guY2xvbmUoKV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIE07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBtYXRzZXRjb2wobWF0cml4LCBqLCBjb2wpIHtcclxuICAgICAgICAgICAgLy9oYW5kbGUgc3ltYm9saWNzXHJcbiAgICAgICAgICAgIGlmKCFqLmlzQ29uc3RhbnQoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfLnN5bWZ1bmN0aW9uKCdtYXRzZXRjb2wnLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICBqID0gTnVtYmVyKGopO1xyXG4gICAgICAgICAgICBpZihtYXRyaXgucm93cygpICE9PSBjb2wuZWxlbWVudHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERpbWVuc2lvbkVycm9yKCdNYXRyaXggY29sdW1ucyBtdXN0IG1hdGNoIG51bWJlciBvZiBjb2x1bW5zIScpO1xyXG4gICAgICAgICAgICBjb2wuZWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgbWF0cml4LnNldChpIC0gMSwgaiwgeC5lbGVtZW50c1swXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWF0c2V0KG1hdHJpeCwgaSwgaiwgdmFsdWUpIHtcclxuICAgICAgICAgICAgbWF0cml4LmVsZW1lbnRzW2ldW2pdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL3RoZSBjb25zdHJ1Y3RvciBmb3IgdmVjdG9yc1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlY3RvcigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGhlIGNvbnN0cnVjdG9yIGZvciBtYXRyaWNlc1xyXG4gICAgICAgIGZ1bmN0aW9uIG1hdHJpeCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdHJpeC5mcm9tQXJyYXkoYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdGhlIGNvbnN0cnVjdG9yIGZvciBzZXRzXHJcbiAgICAgICAgZnVuY3Rpb24gc2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2V0LmZyb21BcnJheShhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKGlzTWF0cml4KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2wuZGV0ZXJtaW5hbnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2l6ZShzeW1ib2wpIHtcclxuICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgaWYoaXNNYXRyaXgoc3ltYm9sKSlcclxuICAgICAgICAgICAgICAgIHJldHZhbCA9IFtuZXcgU3ltYm9sKHN5bWJvbC5jb2xzKCkpLCBuZXcgU3ltYm9sKHN5bWJvbC5yb3dzKCkpXTtcclxuICAgICAgICAgICAgZWxzZSBpZihpc1ZlY3RvcihzeW1ib2wpIHx8IGlzU2V0KHN5bWJvbCkpXHJcbiAgICAgICAgICAgICAgICByZXR2YWwgPSBuZXcgU3ltYm9sKHN5bWJvbC5lbGVtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBlcnIoJ3NpemUgZXhwZWN0cyBhIG1hdHJpeCBvciBhIHZlY3RvcicpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZG90KHZlYzEsIHZlYzIpIHtcclxuICAgICAgICAgICAgaWYoaXNWZWN0b3IodmVjMSkgJiYgaXNWZWN0b3IodmVjMikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjMS5kb3QodmVjMik7XHJcbiAgICAgICAgICAgIGVycignZnVuY3Rpb24gZG90IGV4cGVjdHMgMiB2ZWN0b3JzJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjcm9zcyh2ZWMxLCB2ZWMyKSB7XHJcbiAgICAgICAgICAgIGlmKGlzVmVjdG9yKHZlYzEpICYmIGlzVmVjdG9yKHZlYzIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlYzEuY3Jvc3ModmVjMik7XHJcbiAgICAgICAgICAgIGVycignZnVuY3Rpb24gY3Jvc3MgZXhwZWN0cyAyIHZlY3RvcnMnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRyYW5zcG9zZShtYXQpIHtcclxuICAgICAgICAgICAgaWYoaXNNYXRyaXgobWF0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXQudHJhbnNwb3NlKCk7XHJcbiAgICAgICAgICAgIGVycignZnVuY3Rpb24gdHJhbnNwb3NlIGV4cGVjdHMgYSBtYXRyaXgnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGludmVydChtYXQpIHtcclxuICAgICAgICAgICAgaWYoaXNNYXRyaXgobWF0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXQuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgIGVycignaW52ZXJ0IGV4cGVjdHMgYSBtYXRyaXgnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vYmFzaWMgc2V0IGZ1bmN0aW9uc1xyXG4gICAgICAgIGZ1bmN0aW9uIHVuaW9uKHNldDEsIHNldDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldDEudW5pb24oc2V0Mik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0MSwgc2V0Mikge1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0MS5pbnRlcnNlY3Rpb24oc2V0Mik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBjb250YWlucyhzZXQxLCBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXQxLmNvbnRhaW5zKGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZGlmZmVyZW5jZShzZXQxLCBzZXQyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXQxLmRpZmZlcmVuY2Uoc2V0Mik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbnRlcnNlY3RzKHNldDEsIHNldDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTnVtYmVyKHNldDEuaW50ZXJzZWN0cyhzZXQyKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaXNfc3Vic2V0KHNldDEsIHNldDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woTnVtYmVyKHNldDEuaXNfc3Vic2V0KHNldDIpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBwcmludCgpIHtcclxuICAgICAgICAgICAgYXJndW1lbnRzMkFycmF5KGFyZ3VtZW50cykubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh4LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRlc3RTUVJUKHN5bWJvbCkge1xyXG4gICAgICAgICAgICAvL3dyYXAgdGhlIHN5bWJvbCBpbiBzcXJ0LiBUaGlzIGVsaW1pbmF0ZXMgb25lIG1vcmUgY2hlY2sgZG93biB0aGUgbGluZS5cclxuICAgICAgICAgICAgaWYoIWlzU3ltYm9sKHN5bWJvbC5wb3dlcikgJiYgc3ltYm9sLnBvd2VyLmFic0VxdWFscygwLjUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IHN5bWJvbC5wb3dlci5zaWduKCk7XHJcbiAgICAgICAgICAgICAgICAvL2Rvbid0IGRldmlkZSB0aGUgcG93ZXIgZGlyZWN0bHkuIE5vdGljZSB0aGUgdXNlIG9mIHRvU3RyaW5nLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAvL3RvIHVzZSBhIGJpZ051bWJlciBsaWJyYXJ5IGluIHRoZSBmdXR1cmVcclxuICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBzcXJ0KHN5bWJvbC5ncm91cCA9PT0gUCA/IG5ldyBTeW1ib2woc3ltYm9sLnZhbHVlKSA6IHN5bWJvbC50b0xpbmVhcigpKTtcclxuICAgICAgICAgICAgICAgIC8vcGxhY2UgYmFjayB0aGUgc2lnbiBvZiB0aGUgcG93ZXJcclxuICAgICAgICAgICAgICAgIGlmKHNpZ24gPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbC5pbnZlcnQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vdHJ5IHRvIHJlZHVjZSBhIHN5bWJvbCBieSBwdWxsaW5nIGl0cyBwb3dlclxyXG4gICAgICAgIGZ1bmN0aW9uIHRlc3RQb3coc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gUCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBzeW1ib2wudmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZjdCA9IHByaW1lRmFjdG9ycyh2KVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3NhZmV0eVxyXG4gICAgICAgICAgICAgICAgaWYoIWZjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1VuYWJsZSB0byBjb21wdXRlIHByaW1lIGZhY3RvcnMuIFRoaXMgc2hvdWxkIG5vdCBoYXBwZW4uIFBsZWFzZSByZXZpZXcgYW5kIHJlcG9ydC4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBuID0gbmV3IEZyYWMoTWF0aC5sb2codikgLyBNYXRoLmxvZyhmY3QpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IG4ubXVsdGlwbHkoc3ltYm9sLnBvd2VyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3dlIGRvbid0IHdhbnQgYSBtb3JlIGNvbXBsZXggbnVtYmVyIHRoYW4gYmVmb3JlXHJcbiAgICAgICAgICAgICAgICBpZihwLmRlbiA+IHN5bWJvbC5wb3dlci5kZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihpc0ludChwKSlcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBTeW1ib2woTWF0aC5wb3coZmN0LCBwKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbmV3IFN5bWJvbChmY3QpLnNldFBvd2VyKHApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9MaW5rIHRoZSBmdW5jdGlvbnMgdG8gdGhlIHBhcnNlIHNvIHRoZXkncmUgYXZhaWxhYmxlIG91dHNpZGUgb2YgdGhlIGxpYnJhcnkuXHJcbiAgICAgICAgLy9UaGlzIGlzIHN0cmljdGx5IGZvciBjb252ZW5pZW5jZSBhbmQgbWF5IGJlIGRlcHJlY2F0ZWQuXHJcbiAgICAgICAgdGhpcy5leHBhbmQgPSBleHBhbmQ7XHJcbiAgICAgICAgdGhpcy5yb3VuZCA9IHJvdW5kO1xyXG4gICAgICAgIHRoaXMuY2xlYW4gPSBjbGVhbjtcclxuICAgICAgICB0aGlzLnNxcnQgPSBzcXJ0O1xyXG4gICAgICAgIHRoaXMuY2JydCA9IGNicnQ7XHJcbiAgICAgICAgdGhpcy5hYnMgPSBhYnM7XHJcbiAgICAgICAgdGhpcy5sb2cgPSBsb2c7XHJcbiAgICAgICAgdGhpcy5yYXRpb25hbGl6ZSA9IHJhdGlvbmFsaXplO1xyXG4gICAgICAgIHRoaXMubnRocm9vdCA9IG50aHJvb3Q7XHJcbiAgICAgICAgdGhpcy5hcmcgPSBhcmc7XHJcbiAgICAgICAgdGhpcy5jb25qdWdhdGUgPSBjb25qdWdhdGU7XHJcbiAgICAgICAgdGhpcy5pbWFncGFydCA9IGltYWdwYXJ0O1xyXG4gICAgICAgIHRoaXMucmVhbHBhcnQgPSByZWFscGFydDtcclxuXHJcbiAgICAgICAgLy9UT0RPOlxyXG4gICAgICAgIC8vVXRpbGl6ZSB0aGUgZnVuY3Rpb24gYmVsb3cgaW5zdGVhZCBvZiB0aGUgbGlua2VkIGZ1bmN0aW9uXHJcbiAgICAgICAgdGhpcy5nZXRGdW5jdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbnNbbmFtZV1bMF07XHJcbiAgICAgICAgfTtcclxuXHJcbi8vUGFyc2VyLm1ldGhvZHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgICAgdGhpcy5hZGRQcmVwcm9jZXNzb3IgPSBmdW5jdGlvbiAobmFtZSwgYWN0aW9uLCBvcmRlciwgc2hpZnRfY2VsbHMpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWVzID0gcHJlcHJvY2Vzc29ycy5uYW1lcztcclxuICAgICAgICAgICAgdmFyIGFjdGlvbnMgPSBwcmVwcm9jZXNzb3JzLmFjdGlvbnM7XHJcbiAgICAgICAgICAgIGlmKCh0eXBlb2YgYWN0aW9uICE9PSAnZnVuY3Rpb24nKSkgLy90aGUgcGVyc29uIHByb2JhYmx5IGZvcmdvdCB0byBzcGVjaWZ5IGEgbmFtZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFByZXByb2Nlc3NvckVycm9yKCdJbmNvcnJlY3QgcGFyYW1ldGVycy4gRnVuY3Rpb24gZXhwZWN0ZWQhJyk7XHJcbiAgICAgICAgICAgIGlmKCFvcmRlcikge1xyXG4gICAgICAgICAgICAgICAgbmFtZXMucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYoc2hpZnRfY2VsbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lcy5zcGxpY2Uob3JkZXIsIDAsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnMuc3BsaWNlKG9yZGVyLCAwLCBhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNbb3JkZXJdID0gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zW29yZGVyXSA9IGFjdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0UHJlcHJvY2Vzc29ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHByZXByb2Nlc3NvcnMgPSB7fTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IHByZXByb2Nlc3NvcnMubmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByZXByb2Nlc3NvcnMubmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBwcmVwcm9jZXNzb3JzW25hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiBpLFxyXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogcHJlcHJvY2Vzc29ycy5hY3Rpb25zW2ldXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcmVwcm9jZXNzb3JzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMucmVtb3ZlUHJlcHJvY2Vzc29yID0gZnVuY3Rpb24gKG5hbWUsIHNoaWZ0X2NlbGxzKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gcHJlcHJvY2Vzc29ycy5uYW1lcy5pbmRleE9mKG5hbWUpO1xyXG4gICAgICAgICAgICBpZihzaGlmdF9jZWxscykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHByZXByb2Nlc3NvcnMubmFtZXMsIGkpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHByZXByb2Nlc3NvcnMuYWN0aW9ucywgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcmVwcm9jZXNzb3JzLm5hbWVzW2ldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcHJlcHJvY2Vzc29ycy5hY3Rpb25zW2ldID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy9UaGUgbG9hZGVyIGZvciBmdW5jdGlvbnMgd2hpY2ggYXJlIG5vdCBwYXJ0IG9mIE1hdGgyXHJcbiAgICAgICAgdGhpcy5tYXBwZWRfZnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWJzID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gdGhpcy5wYXJhbXM7XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzW3BhcmFtc1tpXV0gPSBTdHJpbmcoYXJndW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UodGhpcy5ib2R5LCBzdWJzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgdHdvIHN5bWJvbHNcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBhSXNTeW1ib2wgPSBpc1N5bWJvbChhKSxcclxuICAgICAgICAgICAgICAgICAgICBiSXNTeW1ib2wgPSBpc1N5bWJvbChiKTtcclxuICAgICAgICAgICAgLy93ZSdyZSBkZWFsaW5nIHdpdGggdHdvIHN5bWJvbHNcclxuICAgICAgICAgICAgaWYoYUlzU3ltYm9sICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgLy9mb3J3YXJkIHRoZSBhZGRpbmcgb2Ygc3ltYm9scyB3aXRoIHVuaXRzIHRvIHRoZSBVbml0IG1vZHVsZVxyXG4gICAgICAgICAgICAgICAgaWYoYS51bml0IHx8IGIudW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLlVuaXQuYWRkKGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly93d3cuZW5jeWNsb3BlZGlhb2ZtYXRoLm9yZy9pbmRleC5waHAvSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIGlmKGEuaXNJbmZpbml0eSB8fCBiLmlzSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5lZyA9IGEubXVsdGlwbGllci5sZXNzVGhhbigwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJuZWcgPSBiLm11bHRpcGxpZXIubGVzc1RoYW4oMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEuaXNJbmZpbml0eSAmJiBiLmlzSW5maW5pdHkgJiYgYW5lZyAhPT0gYm5lZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJygnICsgYSArICcpKygnICsgYiArICcpIGlzIG5vdCBkZWZpbmVkIScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZiA9IFN5bWJvbC5pbmZpbml0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGJuZWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZi5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGEuaXNDb21wb3NpdGUoKSAmJiBhLmlzTGluZWFyKCkgJiYgYi5pc0NvbXBvc2l0ZSgpICYmIGIuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBiLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGZvciBpc3N1ZSAjNjA2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYi5sZW5ndGggPiBhLmxlbmd0aCAmJiBhLmdyb3VwID09PSBiLmdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthLCBiXSA9IFtiLCBhXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vbm8gbmVlZCB0byB3YXN0ZSB0aW1lIG9uIHplcm9lc1xyXG4gICAgICAgICAgICAgICAgaWYoYS5tdWx0aXBsaWVyLmVxdWFscygwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICAgICAgICAgIGlmKGIubXVsdGlwbGllci5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYS5pc0NvbnN0YW50KCkgJiYgYi5pc0NvbnN0YW50KCkgJiYgU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTeW1ib2woYS5tdWx0aXBsaWVyLmFkZChiLm11bHRpcGxpZXIpLnRvRGVjaW1hbChTZXR0aW5ncy5QUkVDSVNJT04pKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBnMSA9IGEuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gYi5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXAgPSBhLnBvd2VyLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJwID0gYi5wb3dlci50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vYWx3YXlzIGtlZXAgdGhlIGdyZWF0ZXIgZ3JvdXAgb24gdGhlIGxlZnQuXHJcbiAgICAgICAgICAgICAgICBpZihnMSA8IGcyIHx8IChnMSA9PT0gZzIgJiYgYXAgPiBicCAmJiBicCA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGIsIGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qbm90ZSB0byBzZWxmOiBQbGVhc2UgZG9uJ3QgZm9yZ2V0IGFib3V0IHRoaXMgZGlsZW1tYSBldmVyIGFnYWluLiBJbiB0aGlzIG1vZGVsIFBMIGFuZCBDQiBnb2VzIGNyYXp5XHJcbiAgICAgICAgICAgICAgICAgKiBiZWNhdXNlIGl0IGRvZXNuJ3Qga25vdyB3aGljaCBvbmUgdG8gcHJpb3JpdGl6ZS4gKi9cclxuICAgICAgICAgICAgICAgIC8vY29ycmVjdGlvbiB0byBQTCBkaWxlbW1hXHJcbiAgICAgICAgICAgICAgICBpZihnMSA9PT0gQ0IgJiYgZzIgPT09IFBMICYmIGEudmFsdWUgPT09IGIudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3N3YXBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZzEgPSBhLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGcyID0gYi5ncm91cDtcclxuICAgICAgICAgICAgICAgICAgICBhcCA9IGEucG93ZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicCA9IGIucG93ZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcG93RVEgPSBhcCA9PT0gYnAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gYS52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSBiLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhSXNDb21wb3NpdGUgPSBhLmlzQ29tcG9zaXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJJc0NvbXBvc2l0ZSA9IGIuaXNDb21wb3NpdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaDEsIGgyLCByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYUlzQ29tcG9zaXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIGgxID0gdGV4dChhLCAnaGFzaCcpO1xyXG4gICAgICAgICAgICAgICAgaWYoYklzQ29tcG9zaXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIGgyID0gdGV4dChiLCAnaGFzaCcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGcxID09PSBDUCAmJiBnMiA9PT0gQ1AgJiYgYi5pc0xpbmVhcigpICYmICFhLmlzTGluZWFyKCkgJiYgaDEgIT09IGgyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGIsIGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vUEwgJiBQTCBzaG91bGQgY29tcGFyZSBoYXNoZXMgYW5kIG5vdCB2YWx1ZXMgZS5nLiBjb21wYXJlIHgreF4yIHdpdGggeCt4XjMgYW5kIG5vdCB4IHdpdGggeFxyXG4gICAgICAgICAgICAgICAgaWYoZzEgPT09IFBMICYmIGcyID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYxID0gaDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdjIgPSBoMjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgUE4gPSBnMSA9PT0gUCAmJiBnMiA9PT0gTixcclxuICAgICAgICAgICAgICAgICAgICAgICAgUE5FUSA9IGEudmFsdWUgPT09IGIubXVsdGlwbGllci50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxFUSA9ICh2MSA9PT0gdjIgfHwgaDEgPT09IGgyICYmIGgxICE9PSB1bmRlZmluZWQgfHwgKFBOICYmIFBORVEpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2VxdWFsIHZhbHVlcywgZXF1YWwgcG93ZXJzXHJcbiAgICAgICAgICAgICAgICBpZih2YWxFUSAmJiBwb3dFUSAmJiBnMSA9PT0gZzIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSB0byBjb252ZXJ0IE4gdG8gc29tZXRoaW5nIFAgY2FuIHdvcmsgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKFBOKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYi5jb252ZXJ0KFApOy8vQ0xcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGUgUExcclxuICAgICAgICAgICAgICAgICAgICBpZihnMSA9PT0gUEwgJiYgKGcyID09PSBTIHx8IGcyID09PSBQKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmRpc3RyaWJ1dGVNdWx0aXBsaWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGEuYXR0YWNoKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYTsvL0NMXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEubXVsdGlwbGllci5pc09uZSgpICYmIGIubXVsdGlwbGllci5pc09uZSgpICYmIGcxID09PSBDUCAmJiBhLmlzTGluZWFyKCkgJiYgYi5pc0xpbmVhcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHMgaW4gYi5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBiLnN5bWJvbHNbc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmF0dGFjaCh4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlwbGllciA9IHJlc3VsdC5tdWx0aXBsaWVyLmFkZChiLm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vZXF1YWwgdmFsdWVzIHVuZXZlbiBwb3dlcnNcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodmFsRVEgJiYgZzEgIT09IFBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9icmVhayB0aGUgdGllIGZvciBlLmcuICh4KzEpKygoeCsxKV4yKyh4KzEpXjMpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZzEgPT09IENQICYmIGcyID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmluc2VydChhLCAnYWRkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBTeW1ib2wuc2hlbGwoUEwpLmF0dGFjaChbYSwgYl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZSB0aGUgaGFzaFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBnMSA9PT0gUEwgPyBoMSA6IHYxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYUlzQ29tcG9zaXRlICYmIGEuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW5JdGVyYXRlID0gZzEgPT09IGcyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90aFBMID0gZzEgPT09IFBMICYmIGcyID09PSBQTDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy93ZSBjYW4gb25seSBpdGVyYXRlIGdyb3VwIFBMIGlmIHRoZXkgdmFsdWVzIG1hdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYm90aFBMKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5JdGVyYXRlID0gYS52YWx1ZSA9PT0gYi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvL2Rpc3RyaWJ1dGUgdGhlIG11bHRpcGxpZXIgb3ZlciB0aGUgZW50aXJlIHN5bWJvbFxyXG4gICAgICAgICAgICAgICAgICAgIGEuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYi5pc0NvbXBvc2l0ZSgpICYmIGIuaXNMaW5lYXIoKSAmJiBjYW5JdGVyYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9DTFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHMgaW4gYi5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGIuc3ltYm9sc1tzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuYXR0YWNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vaGFuZGxlIGNhc2VzIGxpa2UgMiooeCt4XjIpXjIrMiooeCt4XjIpXjMrNCooeCt4XjIpXjJcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGJvdGhQTCAmJiBhLnZhbHVlICE9PSBoMiB8fCBnMSA9PT0gUEwgJiYgIXZhbEVRKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN5bWJvbC5zaGVsbChDUCkuYXR0YWNoKFthLCBiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC51cGRhdGVIYXNoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYS5hdHRhY2goYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZzEgPT09IEZOICYmIGEuZm5hbWUgPT09IFNRUlQgJiYgZzIgIT09IEVYICYmIGIucG93ZXIuZXF1YWxzKDAuNSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBiLm11bHRpcGxpZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHNxcnQoYi50b1VuaXRNdWx0aXBsaWVyKCkudG9MaW5lYXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIubXVsdGlwbGllciA9IG07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vZml4IGZvciBpc3N1ZSAjMyBhbmQgIzE1OVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEubGVuZ3RoID09PSAyICYmIGIubGVuZ3RoID09PSAyICYmIGV2ZW4oYS5wb3dlcikgJiYgZXZlbihiLnBvd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLmFkZChleHBhbmQoYSksIGV4cGFuZChiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBTeW1ib2wuc2hlbGwoQ1ApLmF0dGFjaChbYSwgYl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudXBkYXRlSGFzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQubXVsdGlwbGllci5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL21ha2Ugc3VyZSB0byByZW1vdmUgdW5uZWNlc3Nhcnkgd3JhcHNcclxuICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHJlc3VsdC5tdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0T2JqZWN0KHJlc3VsdC5zeW1ib2xzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlwbGllciA9IHJlc3VsdC5tdWx0aXBsaWVyLm11bHRpcGx5KG0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL2tlZXAgc3ltYm9scyB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgICAgIGlmKGJJc1N5bWJvbCAmJiAhYUlzU3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0OyAvL3N3YXBcclxuICAgICAgICAgICAgICAgICAgICB0ID0gYklzU3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIGJJc1N5bWJvbCA9IGFJc1N5bWJvbDtcclxuICAgICAgICAgICAgICAgICAgICBhSXNTeW1ib2wgPSB0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiSXNNYXRyaXggPSBpc01hdHJpeChiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihhSXNTeW1ib2wgJiYgYklzTWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5lYWNoRWxlbWVudChmdW5jdGlvbiAoZSwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBfLmFkZChhLmNsb25lKCksIGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IE1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzTWF0cml4KGEpICYmIGJJc01hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYS5hZGQoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYUlzU3ltYm9sICYmIGlzVmVjdG9yKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuZWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5lbGVtZW50c1tpXSA9IF8uYWRkKGEuY2xvbmUoKSwgYi5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNWZWN0b3IoYSkgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuZWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmVsZW1lbnRzW2ldID0gXy5hZGQoYS5lbGVtZW50c1tpXSwgYi5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzVmVjdG9yKGEpICYmIGlzTWF0cml4KGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyeSB0byBjb252ZXJ0IGEgdG8gYSBtYXRyaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmFkZChiLCBhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzTWF0cml4KGEpICYmIGlzVmVjdG9yKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihiLmVsZW1lbnRzLmxlbmd0aCA9PT0gYS5yb3dzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKSwgbCA9IGEuY29scygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuZWFjaChmdW5jdGlvbiAoZSwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKF8uYWRkKGEuZWxlbWVudHNbaSAtIDFdW2pdLmNsb25lKCksIGUuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0uZWxlbWVudHMucHVzaChyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycignRGltZW5zaW9ucyBtdXN0IG1hdGNoIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBwYXJzZXIgZmluZHMgdGhlIC0gb3BlcmF0b3IuIE5vdCB0aGUgcHJlZml4IG9wZXJhdG9yLiBTZWUgdGhpcy5hZGRcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGFJc1N5bWJvbCA9IGFJc1N5bWJvbCA9IGlzU3ltYm9sKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJJc1N5bWJvbCA9IGlzU3ltYm9sKGIpLCB0O1xyXG5cclxuICAgICAgICAgICAgaWYoYUlzU3ltYm9sICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYoYS51bml0IHx8IGIudW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLlVuaXQuc3VidHJhY3QoYSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoYSwgYi5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZihiSXNTeW1ib2wgJiYgaXNWZWN0b3IoYSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiID0gYS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uc3VidHJhY3QoeCwgYi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYUlzU3ltYm9sICYmIGlzVmVjdG9yKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGIubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnN1YnRyYWN0KGEuY2xvbmUoKSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzVmVjdG9yKGEpICYmIGlzVmVjdG9yKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYS5kaW1lbnNpb25zKCkgPT09IGIuZGltZW5zaW9ucygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYS5zdWJ0cmFjdChiKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZXJyb3IoJ1VuYWJsZSB0byBzdWJ0cmFjdCB2ZWN0b3JzLiBEaW1lbnNpb25zIGRvIG5vdCBtYXRjaC4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNNYXRyaXgoYSkgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihiLmVsZW1lbnRzLmxlbmd0aCA9PT0gYS5yb3dzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCksIGwgPSBhLmNvbHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5lYWNoKGZ1bmN0aW9uIChlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goXy5zdWJ0cmFjdChhLmVsZW1lbnRzW2kgLSAxXVtqXS5jbG9uZSgpLCBlLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0uZWxlbWVudHMucHVzaChyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyKCdEaW1lbnNpb25zIG11c3QgbWF0Y2ghJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzVmVjdG9yKGEpICYmIGlzTWF0cml4KGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBiLmNsb25lKCkubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKE0sIGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihpc01hdHJpeChhKSAmJiBpc01hdHJpeChiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBhLnN1YnRyYWN0KGIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihpc01hdHJpeChhKSAmJiBiSXNTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBhLmVhY2goZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgXy5zdWJ0cmFjdCh4LCBiLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gTTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYUlzU3ltYm9sICYmIGlzTWF0cml4KGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5lYWNoKGZ1bmN0aW9uICh4LCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE0uc2V0KGksIGosIF8uc3VidHJhY3QoYS5jbG9uZSgpLCB4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IE07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgcGFyc2VyIGZpbmRzIHRoZSAqIG9wZXJhdG9yLiBTZWUgdGhpcy5hZGRcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgdmFyIGFJc1N5bWJvbCA9IGlzU3ltYm9sKGEpLFxyXG4gICAgICAgICAgICAgICAgICAgIGJJc1N5bWJvbCA9IGlzU3ltYm9sKGIpO1xyXG4gICAgICAgICAgICAvL3dlJ3JlIGRlYWxpbmcgd2l0aCBmdW5jdGlvbiBhc3NpZ25tZW50IGhlcmVcclxuICAgICAgICAgICAgaWYoYUlzU3ltYm9sICYmIGIgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBiLmVsZW1lbnRzLnB1c2goYSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhSXNTeW1ib2wgJiYgYklzU3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAvL2lmIGl0IGhhcyBhIHVuaXQgdGhlbiBhZGQgaXQgYW5kIHJldHVybiBpdCByaWdodCBhd2F5LlxyXG4gICAgICAgICAgICAgICAgaWYoYi5pc1VuaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gYS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEudW5pdCA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy9pZiBpdCBoYXMgdW5pdHMgdGhlbiBqdXN0IGZvcndhcmQgdGhhdCBwcm9ibGVtIHRvIHRoZSB1bml0IG1vZHVsZVxyXG4gICAgICAgICAgICAgICAgaWYoYS51bml0IHx8IGIudW5pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLlVuaXQubXVsdGlwbHkoYSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9oYW5kbGUgSW5maW50eVxyXG4gICAgICAgICAgICAgICAgaWYoYS5pc0luZmluaXR5IHx8IGIuaXNJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEuZXF1YWxzKDApIHx8IGIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoYSArICcqJyArIGIgKyAnIGlzIHVuZGVmaW5lZCEnKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3gvaW5maW5pdHlcclxuICAgICAgICAgICAgICAgICAgICBpZihiLnBvd2VyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFhLmlzSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKCdJbmZpbml0eS9JbmZpbml0eSBpcyBub3QgZGVmaW5lZCEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBhLm11bHRpcGxpZXIubXVsdGlwbHkoYi5tdWx0aXBsaWVyKS5zaWduKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmYgPSBTeW1ib2wuaW5maW5pdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhLmlzQ29uc3RhbnQoKSB8fCBiLmlzQ29uc3RhbnQoKSB8fCAoYS5pc0luZmluaXR5ICYmIGIuaXNJbmZpbml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmYubmVnYXRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5mO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vdGhlIHF1aWNraWVzXHJcbiAgICAgICAgICAgICAgICBpZihhLmlzQ29uc3RhbnQoKSAmJiBiLmlzQ29uc3RhbnQoKSAmJiBTZXR0aW5ncy5QQVJTRTJOVU1CRVIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG5ldyBiaWdEZWMoYS5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKS50aW1lcyhuZXcgYmlnRGVjKGIubXVsdGlwbGllci50b0RlY2ltYWwoKSkpLnRvRml4ZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dmFsID0gbmV3IFN5bWJvbCh0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vZG9uJ3Qgd2FzdGUgdGltZVxyXG4gICAgICAgICAgICAgICAgaWYoYS5pc09uZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGIuaXNPbmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYS5tdWx0aXBsaWVyLmVxdWFscygwKSB8fCBiLm11bHRpcGxpZXIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGIuZ3JvdXAgPiBhLmdyb3VwICYmICEoYi5ncm91cCA9PT0gQ1ApKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGIsIGEpO1xyXG4gICAgICAgICAgICAgICAgLy9jb3JyZWN0aW9uIGZvciBQTC9DQiBkaWxlbW1hXHJcbiAgICAgICAgICAgICAgICBpZihhLmdyb3VwID09PSBDQiAmJiBiLmdyb3VwID09PSBQTCAmJiBhLnZhbHVlID09PSBiLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBhO1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0Oy8vc3dhcFxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBnMSA9IGEuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGcyID0gYi5ncm91cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm51bSA9IGIubXVsdGlwbGllci5udW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJkZW4gPSBiLm11bHRpcGxpZXIuZGVuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGcxID09PSBGTiAmJiBhLmZuYW1lID09PSBTUVJUICYmICFiLmlzQ29uc3RhbnQoKSAmJiBhLmFyZ3NbMF0udmFsdWUgPT09IGIudmFsdWUgJiYgIWEuYXJnc1swXS5tdWx0aXBsaWVyLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy91bndyYXAgc3FydFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhX3BvdyA9IGEucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFfbXVsdGlwbGllciA9IF8ucGFyc2UoYS5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBhID0gXy5tdWx0aXBseShhX211bHRpcGxpZXIsIGEuYXJnc1swXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBhLnNldFBvd2VyKG5ldyBGcmFjKDAuNSkubXVsdGlwbHkoYV9wb3cpKTtcclxuICAgICAgICAgICAgICAgICAgICBnMSA9IGEuZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3NpbXBsaWZ5IG4vc3FydChuKS4gQmVpbmcgdmVyeSBzcGVjaWZpY1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihnMSA9PT0gRk4gJiYgYS5mbmFtZSA9PT0gU1FSVCAmJiBhLm11bHRpcGxpZXIuZXF1YWxzKDEpICYmIGEucG93ZXIuZXF1YWxzKC0xKSAmJiBiLmlzQ29uc3RhbnQoKSAmJiBhLmFyZ3NbMF0uZXF1YWxzKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IF8uc3ltZnVuY3Rpb24oU1FSVCwgW2IuY2xvbmUoKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciB2MSA9IGEudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYyID0gYi52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbiA9IG5ldyBGcmFjKGEuc2lnbigpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zaW5jZSBQIGlzIGp1c3QgYSBtb3JwaGVkIHZlcnNpb24gb2YgTiB3ZSBuZWVkIHRvIHNlZSBpZiB0aGV5IHJlbGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBPTk4gPSAoZzEgPT09IFAgJiYgZzIgPT09IE4gJiYgYi5tdWx0aXBsaWVyLmVxdWFscyhhLnZhbHVlKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZG9uJ3QgbXVsdGlwbHkgdGhlIG11bHRpcGxpZXIgb2YgYiBzaW5jZSB0aGF0J3MgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgbSA9IE9OTiA/IG5ldyBGcmFjKDEpLm11bHRpcGx5KGEubXVsdGlwbGllcikuYWJzKCkgOiBhLm11bHRpcGxpZXIubXVsdGlwbHkoYi5tdWx0aXBsaWVyKS5hYnMoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYS5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIGIgPSBiLmNsb25lKCkudG9Vbml0TXVsdGlwbGllcih0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2Z1cnRoZXIgc2ltcGxpZmljYXRpb24gb2Ygc3FydFxyXG4gICAgICAgICAgICAgICAgaWYoZzEgPT09IEZOICYmIGcyID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1ID0gYS5hcmdzWzBdLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBiLmFyZ3NbMF0uY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihhLmZuYW1lID09PSBTUVJUICYmIGIuZm5hbWUgPT09IFNRUlQgJiYgYS5pc0xpbmVhcigpICYmIGIuaXNMaW5lYXIoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBfLmRpdmlkZSh1LCB2KS5pbnZlcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocS5ndCgxKSAmJiBpc0ludChxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iIGNvbnRhaW5zIGEgZmFjdG9yIGEgd2hpY2ggY2FuIGJlIG1vdmVkIHRvIGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ubXVsdGlwbHkoYS5hcmdzWzBdLmNsb25lKCksIHNxcnQocS5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvL3NpbXBsaWZ5IGZhY3RvcmlhbCBidXQgb25seSBpZlxyXG4gICAgICAgICAgICAgICAgICAgIC8vMSAtIEl0J3MgZGl2aXNpb24gc28gYiB3aWxsIGhhdmUgYSBuZWdhdGl2ZSBwb3dlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vMiAtIFdlJ3JlIG5vdCBkZWFsaW5nIHdpdGggZmFjdG9yaWFscyBvZiBudW1iZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhLmZuYW1lID09PSBGQUNUT1JJQUwgJiYgYi5mbmFtZSA9PT0gRkFDVE9SSUFMICYmICF1LmlzQ29uc3RhbnQoKSAmJiAhdi5pc0NvbnN0YW50KCkgJiYgYi5wb3dlciA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hc3N1bWUgdGhhdCBuID0gcG9zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBfLnN1YnRyYWN0KHUuY2xvbmUoKSwgdi5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgaXQncyBub3QgbnVtZXJpYyB0aGVuIHdlIGRvbid0IGtub3cgaWYgd2UgY2FuIHNpbXBsaWZ5IHNvIGp1c3QgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGQuaXNDb25zdGFudCgpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90aGVyZSB3aWxsIG5ldmVyIGJlIGEgY2FzZSB3aGVyZSBkID09IDAgc2luY2UgdGhpcyB3aWxsIGFscmVhZHkgaGF2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iZWVuIGhhbmRsZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gbmV3IFN5bWJvbCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBkIGlzIG5lZ2F0aXZlIHRoZW4gdGhlIG51bWVyYXRvciBpcyBsYXJnZXIgc28gZXhwYW5kIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBuID0gTWF0aC5hYnMoZCk7IGkgPD0gbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gXy5hZGQodS5jbG9uZSgpLCBuZXcgU3ltYm9sKGkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IF8ubXVsdGlwbHkodCwgcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLm11bHRpcGx5KF8ucG93KHUsIG5ldyBTeW1ib2woYS5wb3dlcikpLCBfLnBvdyh0LCBuZXcgU3ltYm9sKGIucG93ZXIpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9PdGhlcndpc2UgdGhlIGRlbm9taW5hdG9yIGlzIGxhcmdlciBzbyBleHBhbmQgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIG4gPSBNYXRoLmFicyhkKTsgaSA8PSBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfLmFkZCh2LmNsb25lKCksIG5ldyBTeW1ib2woaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gXy5tdWx0aXBseSh0LCBzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ubXVsdGlwbHkoXy5wb3codCwgbmV3IFN5bWJvbChhLnBvd2VyKSksIF8ucG93KHYsIG5ldyBTeW1ib2woYi5wb3dlcikpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgYm90aCBhcmUgUEwgdGhlbiB0aGVpciBoYXNoZXMgaGF2ZSB0byBtYXRjaFxyXG4gICAgICAgICAgICAgICAgaWYodjEgPT09IHYyICYmIGcxID09PSBQTCAmJiBnMSA9PT0gZzIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2MSA9IGEudGV4dCgnaGFzaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYyID0gYi50ZXh0KCdoYXNoJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zYW1lIGlzc3VlIHdpdGggKHheMisxKV54Kih4XjIrMSlcclxuICAgICAgICAgICAgICAgIC8vRVggbmVlZHMgYW4gZXhjZXB0aW9uIHdoZW4gbXVsdGlwbHlpbmcgYmVjYXVzZSBpdCBuZWVkcyB0byByZWNvZ25pemVcclxuICAgICAgICAgICAgICAgIC8vdGhhdCAoeCt4XjIpXnggaGFzIHRoZSBzYW1lIGhhc2ggYXMgKHgreF4yKS4gVGhlIGxhdHRlciBpcyBrZXB0IGFzIHhcclxuICAgICAgICAgICAgICAgIGlmKGcyID09PSBFWCAmJiBiLnByZXZpb3VzR3JvdXAgPT09IFBMICYmIGcxID09PSBQTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYxID0gdGV4dChhLCAnaGFzaCcsIEVYKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZigodjEgPT09IHYyIHx8IE9OTikgJiYgIShnMSA9PT0gUEwgJiYgKGcyID09PSBTIHx8IGcyID09PSBQIHx8IGcyID09PSBGTikpICYmICEoZzEgPT09IFBMICYmIGcyID09PSBDQikpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcDEgPSBhLnBvd2VyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBiLnBvd2VyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTeW1ib2xQMSA9IGlzU3ltYm9sKHAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzU3ltYm9sUDIgPSBpc1N5bWJvbChwMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b0VYID0gKGlzU3ltYm9sUDEgfHwgaXNTeW1ib2xQMik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiB0aGlzIG5lZWRzIGNsZWFuaW5nIHVwXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZzEgPT09IFBMICYmIGcyICE9PSBQTCAmJiBiLnByZXZpb3VzR3JvdXAgIT09IFBMICYmIHAxLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgU3ltYm9sKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLmVhY2goZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uYWRkKHJlc3VsdCwgXy5tdWx0aXBseSh4LCBiLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGUgcG93ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wb3dlciA9IHRvRVggPyBfLmFkZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGlzU3ltYm9sKHAxKSkgPyBuZXcgU3ltYm9sKHAxKSA6IHAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoaXNTeW1ib2wocDIpKSA/IG5ldyBTeW1ib2wocDIpIDogcDJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIDogKGcxID09PSBOIC8qZG9uJ3QgYWRkIHBvd2VycyBmb3IgTiovID8gcDEgOiBwMS5hZGQocDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZWxpbWluYXRlIHplcm8gcG93ZXIgdmFsdWVzIGFuZCBjb252ZXJ0IHRoZW0gdG8gbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQucG93ZXIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbnZlcnQoTik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Byb3Blcmx5IGNvbnZlcnQgdG8gRVhcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodG9FWClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb252ZXJ0KEVYKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGFrZSBjYXJlIG9mIGltYWdpbmFyaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEuaW1hZ2luYXJ5ICYmIGIuaW1hZ2luYXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNFdmVuID0gZXZlbihyZXN1bHQucG93ZXIgJSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzRXZlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jbGVhbnVwOiB0aGlzIGNhdXNlcyB0aGUgTGFUZVggZ2VuZXJhdG9yIHRvIGdldCBjb25mdXNlZCBhcyB0byBob3cgdG8gcmVuZGVyIHRoZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVzdWx0Lmdyb3VwICE9PSBFWCAmJiByZXN1bHQucHJldmlvdXNHcm91cClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcmV2aW91c0dyb3VwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBzaWduIGZvciBiIGlzIGZsb2F0aW5nIGFyb3VuZC4gUmVtZW1iZXIgd2UgYXJlIGFzc3VtaW5nIHRoYXQgdGhlIG9kZCB2YXJpYWJsZSB3aWxsIGNhcnJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIHNpZ24gYnV0IHRoaXMgaXNuJ3QgdHJ1ZSBpZiB0aGV5J3JlIGVxdWFscyBzeW1ib2xzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBsaWVyID0gcmVzdWx0Lm11bHRpcGxpZXIubXVsdGlwbHkoYi5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGcxID09PSBDQiAmJiBhLmlzTGluZWFyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihnMiA9PT0gQ0IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuZGlzdHJpYnV0ZUV4cG9uZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZzIgPT09IENCICYmIGIuaXNMaW5lYXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHMgaW4gYi5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGIuc3ltYm9sc1tzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb21iaW5lKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBsaWVyID0gcmVzdWx0Lm11bHRpcGxpZXIubXVsdGlwbHkoYi5tdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb21iaW5lKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG11bHRpcGxpZXIgd2FzIGFscmVhZHkgaGFuZGxlZCBzbyBub3RoaW5nIGxlZnQgdG8gZG9cclxuICAgICAgICAgICAgICAgICAgICBpZihnMSAhPT0gTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihnMSA9PT0gQ0IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXN0cmlidXRlRXhwb25lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jb21iaW5lKGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoIWIuaXNPbmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJtID0gYi5tdWx0aXBsaWVyLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN5bWJvbC5zaGVsbChDQikuY29tYmluZShbcmVzdWx0LCBiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyYW5zZmVyIHRoZSBtdWx0aXBsaWVyIHRvIHRoZSBvdXRzaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlwbGllciA9IHJlc3VsdC5tdWx0aXBsaWVyLm11bHRpcGx5KGJtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYi5jbG9uZSgpLnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYocmVzdWx0Lmdyb3VwID09PSBQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ1YgPSBNYXRoLmxvZyhyZXN1bHQudmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbjEgPSBNYXRoLmxvZyhibnVtKSAvIGxvZ1YsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuMiA9IE1hdGgubG9nKGJkZW4pIC8gbG9nVixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5kaXYgPSBtLm51bSAvIGJudW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZGl2ID0gbS5kZW4gLyBiZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vd2UgZG9uJ3Qgd2FudCB0byBkaXZpZGUgYnkgemVybyBubyBkbyB3ZT8gU3RyYW5nZSB0aGluZ3MgaGFwcGVuLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG4xICE9PSAwICYmIGlzSW50KG4xKSAmJiBpc0ludChuZGl2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucG93ZXIgPSByZXN1bHQucG93ZXIuYWRkKG5ldyBGcmFjKG4xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ubnVtIC89IGJudW07IC8vQmlnSW50PyBLZWVwIHRoYXQgaW4gbWluZCBmb3IgdGhlIGZ1dHVyZS5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobjIgIT09IDAgJiYgaXNJbnQobjIpICYmIGlzSW50KGRkaXYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wb3dlciA9IHJlc3VsdC5wb3dlci5zdWJ0cmFjdChuZXcgRnJhYyhuMikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtLmRlbiAvPSBiZGVuOyAvL0JpZ0ludD8gS2VlcCB0aGF0IGluIG1pbmQgZm9yIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vdW5wYWNrIENCIGlmIGxlbmd0aCBpcyBvbmx5IG9uZVxyXG4gICAgICAgICAgICAgICAgaWYocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gcmVzdWx0Lm11bHRpcGxpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90cmFuc2ZlciB0aGUgbXVsdGlwbGllclxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZpcnN0T2JqZWN0KHJlc3VsdC5zeW1ib2xzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQubXVsdGlwbGllciA9IHJlc3VsdC5tdWx0aXBsaWVyLm11bHRpcGx5KHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vcmVkdWNlIHNxdWFyZSByb290XHJcbiAgICAgICAgICAgICAgICB2YXIgcHMgPSByZXN1bHQucG93ZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmKGV2ZW4ocHMpICYmIHJlc3VsdC5mbmFtZSA9PT0gU1FSVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ3JhYiB0aGUgc2lnbiBvZiB0aGUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9IHNpZ24gKiByZXN1bHQuc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcmVzdWx0LnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ubXVsdGlwbHkobmV3IFN5bWJvbChtKSwgXy5wb3cocmVzdWx0LCBuZXcgU3ltYm9sKHAuZGl2aWRlKG5ldyBGcmFjKDIpKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZsaXAgaXQgYmFjayB0byB0aGUgY29ycmVjdCBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc2lnbiA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZWdhdGUoKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm11bHRpcGxpZXIgPSByZXN1bHQubXVsdGlwbGllci5tdWx0aXBseShtKS5tdWx0aXBseShzaWduKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihyZXN1bHQuZ3JvdXAgPT09IENQICYmIHJlc3VsdC5pc0ltYWdpbmFyeSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZGlzdHJpYnV0ZU11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2JhY2sgY29udmVydCBncm91cCBQIHRvIGEgc2ltcGxlciBncm91cCBOIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICBpZihyZXN1bHQuZ3JvdXAgPT09IFAgJiYgaXNJbnQocmVzdWx0LnBvd2VyLnRvRGVjaW1hbCgpKSlcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29udmVydChOKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8qKioqKiogTWF0cmljZXMgJiBWZWN0b3IgKioqKiovL1xyXG4gICAgICAgICAgICAgICAgaWYoYklzU3ltYm9sICYmICFhSXNTeW1ib2wpIHsgLy9rZWVwIHN5bWJvbHMgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHQ7IC8vc3dhcFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSBiSXNTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgYklzU3ltYm9sID0gYUlzU3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIGFJc1N5bWJvbCA9IHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGlzTWF0cml4QiA9IGlzTWF0cml4KGIpLCBpc01hdHJpeEEgPSBpc01hdHJpeChhKTtcclxuICAgICAgICAgICAgICAgIGlmKGFJc1N5bWJvbCAmJiBpc01hdHJpeEIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBiLmVhY2hFbGVtZW50KGZ1bmN0aW9uIChlLCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE0uc2V0KGksIGosIF8ubXVsdGlwbHkoYS5jbG9uZSgpLCBlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGIgPSBNO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNNYXRyaXhBICYmIGlzTWF0cml4Qikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYS5tdWx0aXBseShiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhSXNTeW1ib2wgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5lYWNoKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmVsZW1lbnRzW2ldID0gXy5tdWx0aXBseShhLmNsb25lKCksIGIuZWxlbWVudHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKGEpICYmIGlzVmVjdG9yKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmVhY2goZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5lbGVtZW50c1tpXSA9IF8ubXVsdGlwbHkoYS5lbGVtZW50c1tpXSwgYi5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzVmVjdG9yKGEpICYmIGlzTWF0cml4KGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RyeSB0byBjb252ZXJ0IGEgdG8gYSBtYXRyaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGIsIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoaXNNYXRyaXgoYSkgJiYgaXNWZWN0b3IoYikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIuZWxlbWVudHMubGVuZ3RoID09PSBhLnJvd3MoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpLCBsID0gYS5jb2xzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5lYWNoKGZ1bmN0aW9uIChlLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goXy5tdWx0aXBseShhLmVsZW1lbnRzW2kgLSAxXVtqXS5jbG9uZSgpLCBlLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNLmVsZW1lbnRzLnB1c2gocm93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIoJ0RpbWVuc2lvbnMgbXVzdCBtYXRjaCEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgcGFyc2VyIGZpbmRzIHRoZSAvIG9wZXJhdG9yLiBTZWUgdGhpcy5hZGRcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYVxyXG4gICAgICAgICAqIEBwYXJhbSB7U3ltYm9sfSBiXHJcbiAgICAgICAgICogQHJldHVybnMge1N5bWJvbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRpdmlkZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBhSXNTeW1ib2wgPSBpc1N5bWJvbChhKSxcclxuICAgICAgICAgICAgICAgICAgICBiSXNTeW1ib2wgPSBpc1N5bWJvbChiKTtcclxuXHJcbiAgICAgICAgICAgIGlmKGFJc1N5bWJvbCAmJiBiSXNTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIC8vZm9yd2FyZCB0byBVbml0IGRpdmlzaW9uXHJcbiAgICAgICAgICAgICAgICBpZihhLnVuaXQgfHwgYi51bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uVW5pdC5kaXZpZGUoYSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgaWYoYi5lcXVhbHMoMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERpdmlzaW9uQnlaZXJvKCdEaXZpc2lvbiBieSB6ZXJvIG5vdCBhbGxvd2VkIScpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGEuaXNDb25zdGFudCgpICYmIGIuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5tdWx0aXBsaWVyID0gcmVzdWx0Lm11bHRpcGxpZXIuZGl2aWRlKGIubXVsdGlwbGllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiLmludmVydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ubXVsdGlwbHkoYSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8qKioqKioqIFZlY3RvcnMgJiBNYXRyaWNlcyAqKioqKioqKiovL1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzVmVjdG9yQSA9IGlzVmVjdG9yKGEpLCBpc1ZlY3RvckIgPSBpc1ZlY3RvcihiKTtcclxuICAgICAgICAgICAgICAgIGlmKGFJc1N5bWJvbCAmJiBpc1ZlY3RvckIpIHtcclxuICAgICAgICAgICAgICAgICAgICBiID0gYi5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKGEuY2xvbmUoKSwgeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzVmVjdG9yQSAmJiBiSXNTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBiID0gYS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uZGl2aWRlKHgsIGIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzVmVjdG9yQSAmJiBpc1ZlY3RvckIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihhLmRpbWVuc2lvbnMoKSA9PT0gYi5kaW1lbnNpb25zKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGIubWFwKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoYS5lbGVtZW50c1stLWldLCB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignQ2Fubm90IGRpdmlkZSB2ZWN0b3JzLiBEaW1lbnNpb25zIGRvIG5vdCBtYXRjaCEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc01hdHJpeEEgPSBpc01hdHJpeChhKSwgaXNNYXRyaXhCID0gaXNNYXRyaXgoYik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXNNYXRyaXhBICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYS5lYWNoRWxlbWVudChmdW5jdGlvbiAoeCwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgXy5kaXZpZGUoeCwgYi5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gTTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhSXNTeW1ib2wgJiYgaXNNYXRyaXhCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLmVhY2hFbGVtZW50KGZ1bmN0aW9uICh4LCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBfLmRpdmlkZShhLmNsb25lKCksIHgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBNO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzTWF0cml4QSAmJiBpc01hdHJpeEIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEucm93cygpID09PSBiLnJvd3MoKSAmJiBhLmNvbHMoKSA9PT0gYi5jb2xzKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZWFjaEVsZW1lbnQoZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNLnNldChpLCBqLCBfLmRpdmlkZSh4LCBiLmVsZW1lbnRzW2ldW2pdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBNO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignRGltZW5zaW9ucyBkbyBub3QgbWF0Y2ghJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpc01hdHJpeEEgJiYgaXNWZWN0b3JCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGEuY29scygpID09PSBiLmRpbWVuc2lvbnMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLmVhY2hFbGVtZW50KGZ1bmN0aW9uICh4LCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgXy5kaXZpZGUoeCwgYi5lbGVtZW50c1tpXS5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBNO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lcnJvcignVW5hYmxlIHRvIGRpdmlkZSBtYXRyaXggYnkgdmVjdG9yLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHBhcnNlciBmaW5kcyB0aGUgXiBvcGVyYXRvci4gU2VlIHRoaXMuYWRkXHJcbiAgICAgICAgICogQHBhcmFtIHtTeW1ib2x9IGFcclxuICAgICAgICAgKiBAcGFyYW0ge1N5bWJvbH0gYlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtTeW1ib2x9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb3cgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgYUlzU3ltYm9sID0gaXNTeW1ib2woYSksXHJcbiAgICAgICAgICAgICAgICAgICAgYklzU3ltYm9sID0gaXNTeW1ib2woYik7XHJcbiAgICAgICAgICAgIGlmKGFJc1N5bWJvbCAmJiBiSXNTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgIC8vaXQgaGFzIHVuaXRzIHRoZW4gaXQncyB0aGUgVW5pdCBtb2R1bGUncyBwcm9ibGVtXHJcbiAgICAgICAgICAgICAgICBpZihhLnVuaXQgfHwgYi51bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uVW5pdC5wb3coYSwgYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhYnNcclxuICAgICAgICAgICAgICAgIGlmKGEuZ3JvdXAgPT09IEZOICYmIGEuZm5hbWUgPT09IEFCUyAmJiBldmVuKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBhLm11bHRpcGxpZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmFpc2VkID0gXy5wb3coYS5hcmdzWzBdLCBiKTtcclxuICAgICAgICAgICAgICAgICAgICByYWlzZWQubXVsdGlwbGllciA9IG07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJhaXNlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGluZmluaXR5XHJcbiAgICAgICAgICAgICAgICBpZihhLmlzSW5maW5pdHkgfHwgYi5pc0luZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYS5pc0luZmluaXR5ICYmIGIuaXNJbmZpbml0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKCcoJyArIGEgKyAnKV4oJyArIGIgKyAnKSBpcyB1bmRlZmluZWQhJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGEuaXNDb25zdGFudCgpICYmIGIuaXNJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhLmVxdWFscygwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYi5sZXNzVGhhbigwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJzBeSW5maW5pdHkgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5lcXVhbHMoMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5kZWZpbmVkRXJyb3IoJzFeJyArIGIudG9TdHJpbmcoKSArICcgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FeLW9vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIubGVzc1RoYW4oMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hXm9vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFhLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbC5pbmZpbml0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYS5pc0luZmluaXR5ICYmIGIuaXNDb25zdGFudCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIuZXF1YWxzKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZEVycm9yKGEgKyAnXjAgaXMgdW5kZWZpbmVkIScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihiLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfLm11bHRpcGx5KFN5bWJvbC5pbmZpbml0eSgpLCBfLnBvdyhuZXcgU3ltYm9sKGEuc2lnbigpKSwgYi5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhSXNaZXJvID0gYS5lcXVhbHMoMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYklzWmVybyA9IGIuZXF1YWxzKDApO1xyXG4gICAgICAgICAgICAgICAgaWYoYUlzWmVybyAmJiBiSXNaZXJvKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignMF4wIGlzIHVuZGVmaW5lZCEnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gMCByaWdodCBhd2F5IGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICBpZihhSXNaZXJvICYmIGIuaXNDb25zdGFudCgpICYmIGIubXVsdGlwbGllci5ncmVhdGVyVGhhbigwKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihiSXNaZXJvKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiSXNDb25zdGFudCA9IGIuaXNDb25zdGFudCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhSXNDb25zdGFudCA9IGEuaXNDb25zdGFudCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiSXNJbnQgPSBiLmlzSW50ZWdlcigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtID0gYS5tdWx0aXBsaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhLmNsb25lKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMF4wLCAxLzAsIGV0Yy4gQ29tcGxhaW4uXHJcbiAgICAgICAgICAgICAgICBpZihhSXNDb25zdGFudCAmJiBiSXNDb25zdGFudCAmJiBhLmVxdWFscygwKSAmJiBiLmxlc3NUaGFuKDApKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbmRlZmluZWRFcnJvcignRGl2aXNpb24gYnkgemVybyBpcyBub3QgYWxsb3dlZCEnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGltYWdpbmFyeSBudW1iZXJzIHJpZ2h0IGF3YXlcclxuICAgICAgICAgICAgICAgIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUiAmJiBhSXNDb25zdGFudCAmJiBiSXNDb25zdGFudCAmJiBhLnNpZ24oKSA8IDAgJiYgZXZlbkZyYWN0aW9uKGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGssIHJlLCBpbTtcclxuICAgICAgICAgICAgICAgICAgICBrID0gTWF0aC5QSSAqIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmUgPSBuZXcgU3ltYm9sKE1hdGguY29zKGspKTtcclxuICAgICAgICAgICAgICAgICAgICBpbSA9IF8ubXVsdGlwbHkoU3ltYm9sLmltYWdpbmFyeSgpLCBuZXcgU3ltYm9sKE1hdGguc2luKGspKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uYWRkKHJlLCBpbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW1hZ2luYXJ5IG51bWJlciB1bmRlciBuZWdhdGl2ZSBudGhyb290IG9yIHRvIHRoZSBuXHJcbiAgICAgICAgICAgICAgICBpZihTZXR0aW5ncy5QQVJTRTJOVU1CRVIgJiYgYS5pc0ltYWdpbmFyeSgpICYmIGJJc0NvbnN0YW50ICYmIGlzSW50KGIpICYmICFiLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlLCBpbSwgciwgdGhldGEsIG5yZSwgbmltLCBwaGk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmUgPSBhLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW0gPSBhLmltYWdwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocmUuaXNDb25zdGFudCgnYWxsJykgJiYgaW0uaXNDb25zdGFudCgnYWxsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGhpID0gU2V0dGluZ3MuVVNFX0JJRyA/IFN5bWJvbChiaWdEZWMuYXRhbjIoaS5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpLCByLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpLnRpbWVzKGIudG9TdHJpbmcoKSkpIDogTWF0aC5hdGFuMihpbSwgcmUpICogYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhldGEgPSBuZXcgU3ltYm9sKHBoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBfLnBvdyhTeW1ib2wuaHlwKHJlLCBpbSksIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBucmUgPSBfLm11bHRpcGx5KHIuY2xvbmUoKSwgXy50cmlnLmNvcyh0aGV0YS5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pbSA9IF8ubXVsdGlwbHkociwgXy50cmlnLnNpbih0aGV0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQobnJlLCBfLm11bHRpcGx5KFN5bWJvbC5pbWFnaW5hcnkoKSwgbmltKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRha2UgY2FyZSBvZiB0aGUgc3ltYm9saWMgcGFydFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnRvVW5pdE11bHRpcGxpZXIoKTtcclxuICAgICAgICAgICAgICAgIC8vc2ltcGlmbHkgc3FydFxyXG4gICAgICAgICAgICAgICAgaWYocmVzdWx0Lmdyb3VwID09PSBGTiAmJiByZXN1bHQuZm5hbWUgPT09IFNRUlQgJiYgIWJJc0NvbnN0YW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByZXN1bHQuYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBzLm11bHRpcGx5UG93ZXIobmV3IFN5bWJvbCgwLjUpKTtcclxuICAgICAgICAgICAgICAgICAgICBzLm11bHRpcGxpZXIubXVsdGlwbHkocmVzdWx0Lm11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMubXVsdGlwbHlQb3dlcihiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ24gPSBtLnNpZ24oKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2hhbmRsZSBjYXNlcyBzdWNoIGFzICgtYV4zKV4oMS80KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGV2ZW5GcmFjdGlvbihiKSAmJiBzaWduIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2FwZXJvb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBwdXQgdGhlIHNpZ24gYmFjayBvbiB0aGUgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCBpdCBpbiBicmFja2V0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLnN5bWZ1bmN0aW9uKFBBUkVOVEhFU0lTLCBbcmVzdWx0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHNpZ24gYmFjayB0aGUgZXh0ZXJpb3IgYW5kIGxldCBuZXJkYW1lciBoYW5kbGUgdGhlIHJlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm11bHRpcGx5UG93ZXIoYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoYUlzQ29uc3RhbnQgJiYgYklzQ29uc3RhbnQgJiYgU2V0dGluZ3MuUEFSU0UyTlVNQkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgdGhlIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICBpZihzaWduIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihiLm11bHRpcGxpZXIuZGVuLmVxdWFscygyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2Uga25vdyB0aGF0IHRoZSBudW1lcmF0b3IgaGFzIHRvIGJlIG9kZCBhbmQgdGhlcmVmb3JlIGl0J3MgaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBTeW1ib2woU2V0dGluZ3MuSU1BR0lOQVJZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpc0ludChiLm11bHRpcGxpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihldmVuKGIubXVsdGlwbGllcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBTeW1ib2woMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBTeW1ib2woLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoIWV2ZW4oYi5tdWx0aXBsaWVyLmRlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBuZXcgU3ltYm9sKE1hdGgucG93KHNpZ24sIGIubXVsdGlwbGllci5udW0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBfLnBvdyhfLnN5bWZ1bmN0aW9uKFBBUkVOVEhFU0lTLCBbbmV3IFN5bWJvbChzaWduKV0pLCBiLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgU3ltYm9sKE1hdGgucG93KGEubXVsdGlwbGllci50b0RlY2ltYWwoKSwgYi5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzdWx0ID0gbmV3IFN5bWJvbChNYXRoMi5iaWdwb3coYS5tdWx0aXBsaWVyLCBiLm11bHRpcGxpZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICAvL3B1dCB0aGUgYmFjayBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYylcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShyZXN1bHQsIGMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihiSXNJbnQgJiYgIW0uZXF1YWxzKDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFic19iID0gYi5hYnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcm92aWRlIGZhbGwgYmFjayB0byBKUyB1bnRpbCBiaWcgbnVtYmVyIGltcGxlbWVudGF0aW9uIGlzIGltcHJvdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYWJzX2IuZ3QoU2V0dGluZ3MuTUFYX0VYUCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYi5zaWduKCkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2wuaW5maW5pdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gYi5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2duID0gTWF0aC5zaWduKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gTWF0aC5hYnMocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gbmV3IEZyYWMoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubnVtID0gbS5udW0ucG93KHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmRlbiA9IG0uZGVuLnBvdyhwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2duIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIuaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbXVsdGlwbHlpbmcgaXMganVzdGlmaWVkIHNpbmNlIGFmdGVyIG11bGx0aXBseVBvd2VyIGlmIGl0IHdhcyBvZiBncm91cCBQIGl0IHdpbGwgbm93IGJlIG9mIGdyb3VwIE5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm11bHRpcGxpZXIgPSByZXN1bHQubXVsdGlwbGllci5tdWx0aXBseShtdWx0aXBsaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2lnbiA9IGEuc2lnbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGIuaXNDb25zdGFudCgpICYmIGEuaXNDb25zdGFudCgpICYmICFiLm11bHRpcGxpZXIuZGVuLmVxdWFscygxKSAmJiBzaWduIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGtub3cgdGhlIHNpZ24gaXMgbmVnYXRpdmUgc28gaWYgdGhlIGRlbm9taW5hdG9yIGZvciBiID09IDIgdGhlbiBpdCdzIGlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYi5tdWx0aXBsaWVyLmRlbi5lcXVhbHMoMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbmV3IFN5bWJvbChTZXR0aW5ncy5JTUFHSU5BUlkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5uZWdhdGUoKTsvL3JlbW92ZSB0aGUgc2lnblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgcG93ZXIgaXMgbmVnYXRpdmUgdGhlbiBpIGlzIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihiLmxlc3NUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLm5lZ2F0ZSgpOy8vcmVtb3ZlIHRoZSBzaWduIGZyb20gdGhlIHBvd2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3B1bGwgdGhlIHBvd2VyIG5vcm1hbGx5IGFuZCBwdXQgYmFjayB0aGUgaW1hZ2luYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLm11bHRpcGx5KF8ucG93KGEsIGIpLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYSA9IGEuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFhLm11bHRpcGxpZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLnBvdyhfLnN5bWZ1bmN0aW9uKFBBUkVOVEhFU0lTLCBbbmV3IFN5bWJvbChzaWduKV0pLCBiLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gXy5wb3cobmV3IFN5bWJvbChhYS5tdWx0aXBsaWVyLm51bSksIGIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBfLnBvdyhuZXcgU3ltYm9sKGFhLm11bHRpcGxpZXIuZGVuKSwgYi5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gXy5kaXZpZGUoX2EsIF9iKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8ubXVsdGlwbHkocmVzdWx0LCByKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKFNldHRpbmdzLlBBUlNFMk5VTUJFUiAmJiBiLmlzSW1hZ2luYXJ5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy80XihpICsgMikgPSBlXigtICgyIC0gNCBpKSDPgCBuICsgKDIgKyBpKSBsb2coNCkpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmUgPSBiLnJlYWxwYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbSA9IGIuaW1hZ3BhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIuZ3JvdXAgPT09IENQICYmIGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXggPSBfLnBvdyhhLmNsb25lKCksIHJlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4aSA9IF8ubXVsdGlwbHkoXy5tdWx0aXBseShleC5jbG9uZSgpLCB0cmlnLnNpbihpbS5jbG9uZSgpKSksIFN5bWJvbC5pbWFnaW5hcnkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGEgPSBfLm11bHRpcGx5KHRyaWcuY29zKGltKSwgZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5hZGQoeGksIHhhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFhID0gYS5jbG9uZSgpLnRvTGluZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhMSA9IF8ucG93KGFhLmNsb25lKCksIHJlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ19hID0gbG9nKGFhLmNsb25lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYjEgPSB0cmlnLmNvcyhfLm11bHRpcGx5KGltLmNsb25lKCksIGxvZ19hKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjMSA9IF8ubXVsdGlwbHkodHJpZy5zaW4oXy5tdWx0aXBseShpbSwgbG9nKGFhKSkpLCBTeW1ib2wuaW1hZ2luYXJ5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfLm11bHRpcGx5KGExLCBfLmFkZChiMSwgYzEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5leHBhbmQoXy5wYXJzZShyZXN1bHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgIH0gICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2IgaXMgYSBzeW1ib2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5lZ19udW0gPSBhLmdyb3VwID09PSBOICYmIHNpZ24gPCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtID0gdGVzdFNRUlQobmV3IFN5bWJvbChuZWdfbnVtID8gbS5udW0gOiBNYXRoLmFicyhtLm51bSkpLnNldFBvd2VyKGIuY2xvbmUoKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuID0gdGVzdFNRUlQobmV3IFN5bWJvbChtLmRlbikuc2V0UG93ZXIoYi5jbG9uZSgpKS5pbnZlcnQoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2VsaW1pbmF0ZSBpbWFnaW5hcnkgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYS5pbWFnaW5hcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGJJc0ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzLCBwLCBuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBNYXRoLnNpZ24oYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGFicyhiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gcCAlIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFN5bWJvbChldmVuKG4pID8gLTEgOiBTZXR0aW5ncy5JTUFHSU5BUlkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG4gPT09IDAgfHwgcyA8IDAgJiYgKG4gPT09IDEpIHx8IHMgPiAwICYmIChuID09PSAzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hc3N1bWUgaSA9IHNxcnQoLTEpIC0+ICgtMSleKDEvMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnIgPSBiLm11bHRpcGxpZXIubXVsdGlwbHkoRnJhYy5xdWljaygxLCAyKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZW5vbWluYXRvciBkZW5vdGVzIHRoZSBwb3dlciBzbyByYWlzZSB0byBpdC4gSXQgd2lsbCB0dXJuIHBvc2l0aXZlIGl0IHJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0biA9IE1hdGgucG93KC0xLCBuci5udW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGV2ZW4obnIuZGVuKSA/IG5ldyBTeW1ib2woLTEpLnNldFBvd2VyKG5yLCB0cnVlKSA6IG5ldyBTeW1ib2wodG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZW5zdXJlIHRoYXQgdGhlIHNpZ24gaXMgY2FycmllZCBieSB0aGUgc3ltYm9sIGFuZCBub3QgdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIGVuYWJsZXMgdXMgdG8gY2hlY2sgZG93biB0aGUgbGluZSBpZiB0aGUgbXVsdGlwbGllciBjYW4gaW5kZWVkIGJlIHRyYW5zZmVycmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNpZ24gPCAwICYmICFuZWdfbnVtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm5lZ2F0ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXRhaW4gdGhlIGFic29sdXRlIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGJJc0NvbnN0YW50ICYmIGEuZ3JvdXAgIT09IEVYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnIgPSBldmVuKGIubXVsdGlwbGllci5kZW4pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVucCA9IGV2ZW4oYS5wb3dlciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSByZXN1bHQucG93ZXIudG9EZWNpbWFsKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW5ucCA9IGV2ZW4obik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihldmVuciAmJiBldmVucCAmJiAhZXZlbm5wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobiA9PT0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5zeW1mdW5jdGlvbihBQlMsIFtyZXN1bHRdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKCFpc0ludChuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHJlc3VsdC5wb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5zeW1mdW5jdGlvbihBQlMsIFtyZXN1bHQudG9MaW5lYXIoKV0pLnNldFBvd2VyKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShfLnN5bWZ1bmN0aW9uKEFCUywgW3Jlc3VsdC5jbG9uZSgpLnRvTGluZWFyKCldKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2xvbmUoKS5zZXRQb3dlcihuZXcgRnJhYyhuIC0gMSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9xdWljayB3b3JrYXJvdW5kLiBSZXZpc2l0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoU2V0dGluZ3MuUE9TSVRJVkVfTVVMVElQTElFUlMgJiYgcmVzdWx0LmZuYW1lID09PSBBQlMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbXVsdGlwbHkgb3V0IHNxcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYi5lcXVhbHMoMikgJiYgcmVzdWx0Lmdyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQgPSBuZXcgU3ltYm9sKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVhY2goZnVuY3Rpb24gKHN5bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQgPSBfLm11bHRpcGx5KF9yZXN1bHQsIF8ucG93KHN5bSwgYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRlc3RTUVJUKHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgbXVsdGlwbHkgdW50aWwgd2UndmUgdGVzdGVkIHRoZSByZW1haW5pbmcgc3ltYm9sXHJcbiAgICAgICAgICAgICAgICBpZihudW0gJiYgZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5tdWx0aXBseShyZXN1bHQsIHRlc3RQb3coXy5tdWx0aXBseShudW0sIGRlbikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZWR1Y2Ugc3F1YXJlIHJvb3RcclxuICAgICAgICAgICAgICAgIGlmKHJlc3VsdC5mbmFtZSA9PT0gU1FSVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0VYID0gcmVzdWx0Lmdyb3VwID09PSBFWDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGlzRVggPyByZXN1bHQucG93ZXIubXVsdGlwbGllci50b1N0cmluZygpIDogcmVzdWx0LnBvd2VyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZXZlbih0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHQgPSBpc0VYID8gXy5kaXZpZGUocmVzdWx0LnBvd2VyLCBuZXcgU3ltYm9sKDIpKSA6IG5ldyBTeW1ib2wocmVzdWx0LnBvd2VyLmRpdmlkZShuZXcgRnJhYygyKSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSByZXN1bHQubXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXy5wb3cocmVzdWx0LmFyZ3NbMF0sIHB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lm11bHRpcGxpZXIgPSByZXN1bHQubXVsdGlwbGllci5tdWx0aXBseShtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlY3QgRXVsZXIncyBpZGVudGl0eVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZighU2V0dGluZ3MuSUdOT1JFX0UgJiYgcmVzdWx0LmlzRSgpICYmIHJlc3VsdC5ncm91cCA9PT0gRVggJiYgcmVzdWx0LnBvd2VyLmNvbnRhaW5zKCdwaScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHJlc3VsdC5wb3dlci5jb250YWlucyhTZXR0aW5ncy5JTUFHSU5BUlkpICYmIGIuZ3JvdXAgPT09IENCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gYi5zdHJpcFZhcihTZXR0aW5ncy5JTUFHSU5BUlkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uYWRkKHRyaWcuY29zKHRoZXRhKSwgXy5tdWx0aXBseShTeW1ib2wuaW1hZ2luYXJ5KCksIHRyaWcuc2luKHRoZXRhKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZihpc1ZlY3RvcihhKSAmJiBiSXNTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gYS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8ucG93KHgsIGIuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzTWF0cml4KGEpICYmIGJJc1N5bWJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGEuZWFjaEVsZW1lbnQoZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgXy5wb3coeCwgYi5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IE07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFJc1N5bWJvbCAmJiBpc01hdHJpeChiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuZWFjaEVsZW1lbnQoZnVuY3Rpb24gKHgsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgXy5wb3coYS5jbG9uZSgpLCB4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IE07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gR2V0cyBjYWxsZWQgd2hlbiB0aGUgcGFyc2VyIGZpbmRzIHRoZSAsIG9wZXJhdG9yLlxyXG4gICAgICAgIC8vIENvbW1hcyByZXR1cm4gYSBDb2xsZWN0b3Igb2JqZWN0IHdoaWNoIGlzIHJvdWdobHkgYW4gYXJyYXlcclxuICAgICAgICB0aGlzLmNvbW1hID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYoIShhIGluc3RhbmNlb2YgQ29sbGVjdGlvbikpXHJcbiAgICAgICAgICAgICAgICBhID0gQ29sbGVjdGlvbi5jcmVhdGUoYSk7XHJcbiAgICAgICAgICAgIGEuYXBwZW5kKGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIExpbmsgdG8gbW9kdWx1c1xyXG4gICAgICAgIHRoaXMubW9kID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZChhLCBiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFVzZWQgdG8gc2xpY2UgZWxlbWVudHMgZnJvbSBhcnJheXNcclxuICAgICAgICB0aGlzLnNsaWNlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbGljZShhLCBiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFRoZSBlcXVhbGl0eSBzZXR0ZXJcclxuICAgICAgICB0aGlzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIC8vIEVxdWFsaXR5IGNhbiBvbmx5IGJlIHNldCBmb3IgZ3JvdXAgUyBzbyBjb21wbGFpbiBpdCdzIG5vdFxyXG4gICAgICAgICAgICBpZihhLmdyb3VwICE9PSBTICYmICFhLmlzTGluZWFyKCkpXHJcbiAgICAgICAgICAgICAgICBlcnIoJ0Nhbm5vdCBzZXQgZXF1YWxpdHkgZm9yICcgKyBhLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBWQVJTW2EudmFsdWVdID0gYi5jbG9uZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFBlcmNlbnRcclxuICAgICAgICB0aGlzLnBlcmNlbnQgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXy5kaXZpZGUoYSwgbmV3IFN5bWJvbCgxMDApKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIFNldCB2YXJpYWJsZVxyXG4gICAgICAgIHRoaXMuYXNzaWduID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgaWYoYSBpbnN0YW5jZW9mIENvbGxlY3Rpb24gJiYgYiBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGEuZWxlbWVudHMubWFwKGZ1bmN0aW9uICh4LCBpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8uYXNzaWduKHgsIGIuZWxlbWVudHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjdG9yLmZyb21BcnJheShiLmVsZW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXQncyByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCBpbnN0ZWFkLiBUaGUgY3VycmVudCBpdGVtIGNhbiBiZSBkaXNjYXJkZWRcclxuICAgICAgICAgICAgICAgIHZhciBlID0gYS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBlLmVsZW1lbnRzW2UuZ2V0dGVyXSA9IGI7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZS5nZXR0ZXI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoYS5ncm91cCAhPT0gUylcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOZXJkYW1lclZhbHVlRXJyb3IoJ0Nhbm5vdCBjb21wbGV0ZSBvcGVyYXRpb24uIEluY29ycmVjdCBMSCB2YWx1ZSBmb3IgJyArIGEpO1xyXG4gICAgICAgICAgICBWQVJTW2EudmFsdWVdID0gYjtcclxuICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmZ1bmN0aW9uX2Fzc2lnbiA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHZhciBmID0gYS5lbGVtZW50cy5wb3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHNldEZ1bmN0aW9uKGYsIGEuZWxlbWVudHMsIGIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gcXVpY2tseSBjb252ZXJ0IGJvb2xzIHRvIFN5bWJvbHNcclxuICAgICAgICB2YXIgYm9vbDJTeW1ib2wgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbCh4ID09PSB0cnVlID8gMSA6IDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9jaGVjayBmb3IgZXF1YWxpdHlcclxuICAgICAgICB0aGlzLmVxID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2wyU3ltYm9sKGEuZXF1YWxzKGIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vY2hlY2tzIGZvciBncmVhdGVyIHRoYW5cclxuICAgICAgICB0aGlzLmd0ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2wyU3ltYm9sKGEuZ3QoYikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9jaGVja3MgZm9yIGdyZWF0ZXIgdGhhbiBlcXVhbFxyXG4gICAgICAgIHRoaXMuZ3RlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2wyU3ltYm9sKGEuZ3RlKGIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vY2hlY2tzIGZvciBsZXNzIHRoYW5cclxuICAgICAgICB0aGlzLmx0ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2wyU3ltYm9sKGEubHQoYikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy9jaGVja3MgZm9yIGxlc3MgdGhhbiBlcXVhbFxyXG4gICAgICAgIHRoaXMubHRlID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJvb2wyU3ltYm9sKGEubHRlKGIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHdyYXBzIHRoZSBmYWN0b3JpYWxcclxuICAgICAgICB0aGlzLmZhY3RvcmlhbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWZ1bmN0aW9uKEZBQ1RPUklBTCwgW2FdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHdyYXBzIHRoZSBkb3VibGUgZmFjdG9yaWFsXHJcbiAgICAgICAgdGhpcy5kZmFjdG9yaWFsID0gZnVuY3Rpb24gKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ltZnVuY3Rpb24oRE9VQkxFRkFDVE9SSUFMLCBbYV0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICA7XHJcblxyXG4gICAgLyogXCJTVEFUSUNcIiAqL1xyXG4gICAgLy8gY29udmVydHMgYSBudW1iZXIgdG8gYSBmcmFjdGlvbi5cclxuICAgIHZhciBGcmFjdGlvbiA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gYSBmcmFjdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSAtIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRlbm9taW5hdG9yIGFuZCB0aGUgbnVtZXJhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29udmVydDogZnVuY3Rpb24gKHZhbHVlLCBvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciBmcmFjO1xyXG4gICAgICAgICAgICBpZih2YWx1ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZnJhYyA9IFswLCAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKHZhbHVlIDwgMWUtNiB8fCB2YWx1ZSA+IDFlMjApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcWMgPSB0aGlzLnF1aWNrQ29udmVyc2lvbihOdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihxY1sxXSA8PSAxZTIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gdmFsdWUgLyBhYnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWMgPSB0aGlzLmZ1bGxDb252ZXJzaW9uKGFicy50b0ZpeGVkKChxY1sxXSArICcnKS5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWNbMF0gPSBmcmFjWzBdICogc2lnbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWMgPSBxYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFjID0gdGhpcy5mdWxsQ29udmVyc2lvbih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZyYWM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgZnJhY3Rpb24gaXMgdG9vIHNtYWxsIG9yIHRvbyBsYXJnZSB0aGlzIGdldHMgY2FsbGVkIGluc3RlYWQgb2YgZnVsbENvbnZlcnNpb24gbWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRlY1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBhbiBhcnJheSBjb250YWluaW5nIHRoZSBkZW5vbWluYXRvciBhbmQgdGhlIG51bWVyYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHF1aWNrQ29udmVyc2lvbjogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJpcFNpZ24gPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXRlbHkgY29udmVydCB0byBhIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHMgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IHMudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgc2lnbiA9ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbmQgc3RvcmUgdGhlIHNpZ25cclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHMuY2hhckF0KDApO1xyXG4gICAgICAgICAgICAgICAgaWYoc3RhcnQgPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cigxLCBzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbiA9ICctJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoc3RhcnQgPT09ICcrJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgcmVtb3ZlIHRoZSBwbHVzIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICBzID0gcy5zdWJzdHIoMSwgcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lnbjogc2lnbixcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb252ZXJ0KHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGVseSBjb252ZXJ0IHRvIGEgZGVjaW1hbFxyXG4gICAgICAgICAgICAgICAgaWYoU2NpZW50aWZpYy5pc1NjaWVudGlmaWModmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzY2llbnRpZmljVG9EZWNpbWFsKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCB0aGUgdmFsdWUgaW50byB0aGUgc2lnbiBhbmQgdGhlIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB2YXIgbnBhcnRzID0gc3RyaXBTaWduKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCBpdCBhdCB0aGUgZGVjaW1hbC4gV2UnbGwgcmVmZXIgdG8gaXQgYXMgdGhlIGNvZWZmaWVudCBwYXJ0c1xyXG4gICAgICAgICAgICAgICAgdmFyIGNwYXJ0cyA9IG5wYXJ0cy52YWx1ZS5zcGxpdCgnLicpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgdGhlIGVudGlyZSBudW1iZXIgYnkgcmVtb3ZpbmcgbGVhZGluZyB6ZXJvIGFuZCBhZGRpbmcgdGhlIGRlY2ltYWwgcGFydFxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3b3VsZCBiZSB0ZWggc2FtZSBhcyBtb3ZpbmcgdGhlIGRlY2ltYWwgcG9pbnQgdG8gdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgdmFyIG51bTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRlYWxpbmcgd2l0aCBpbnRlZ2Vyc1xyXG4gICAgICAgICAgICAgICAgaWYoY3BhcnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IGNwYXJ0c1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IGNwYXJ0c1swXSArIGNwYXJ0c1sxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBuID0gY3BhcnRzWzFdID8gY3BhcnRzWzFdLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcGFkZGluZyBmb3IgdGhlIHplcm9zXHJcbiAgICAgICAgICAgICAgICB2YXIgZGVuID0gYDEkeycwJy5yZXBlYXQobil9YDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihudW0gIT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IG51bS5yZXBsYWNlKC9eMCsvLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW25wYXJ0cy5zaWduICsgbnVtLCBkZW5dO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY29udmVydCh2YWx1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIGEgZnJhY3Rpb24uIFRoaXMgbWV0aG9kIGdldHMgY2FsbGVkIGJ5IGNvbnZlcnRcclxuICAgICAgICAgKiBodHRwOi8vbWF0aGZvcnVtLm9yZy9saWJyYXJ5L2RybWF0aC92aWV3LzYxNzcyLmh0bWxcclxuICAgICAgICAgKiBEZWNpbWFsIFRvIEZyYWN0aW9uIENvbnZlcnNpb24gLSBBIFNpbXBsZXIgVmVyc2lvblxyXG4gICAgICAgICAqIERyIFBldGVyc29uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRlY1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gLSBhbiBhcnJheSBjb250YWluaW5nIHRoZSBkZW5vbWluYXRvciBhbmQgdGhlIG51bWVyYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bGxDb252ZXJzaW9uOiBmdW5jdGlvbiAoZGVjKSB7XHJcbiAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIHlvdSBjYW4gYWRqdXN0IHRoZSBlcHNpbG9uIHRvIGEgbGFyZ2VyIG51bWJlciBpZiB5b3UgZG9uJ3QgbmVlZCB2ZXJ5IGhpZ2ggcHJlY2lzaW9uXHJcbiAgICAgICAgICAgIHZhciBuMSA9IDAsIGQxID0gMSwgbjIgPSAxLCBkMiA9IDAsIG4gPSAwLCBxID0gZGVjLCBlcHNpbG9uID0gMWUtMTY7XHJcbiAgICAgICAgICAgIHdoaWxlKCFkb25lKSB7XHJcbiAgICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgICBpZihuID4gMTAwMDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhID0gTWF0aC5mbG9vcihxKTtcclxuICAgICAgICAgICAgICAgIHZhciBudW0gPSBuMSArIGEgKiBuMjtcclxuICAgICAgICAgICAgICAgIHZhciBkZW4gPSBkMSArIGEgKiBkMjtcclxuICAgICAgICAgICAgICAgIHZhciBlID0gKHEgLSBhKTtcclxuICAgICAgICAgICAgICAgIGlmKGUgPCBlcHNpbG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBxID0gMSAvIGU7XHJcbiAgICAgICAgICAgICAgICBuMSA9IG4yO1xyXG4gICAgICAgICAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICAgICAgICAgIG4yID0gbnVtO1xyXG4gICAgICAgICAgICAgICAgZDIgPSBkZW47XHJcbiAgICAgICAgICAgICAgICBpZihNYXRoLmFicyhudW0gLyBkZW4gLSBkZWMpIDwgZXBzaWxvbiB8fCBuID4gMzApIHtcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW251bSwgZGVuXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy9EZXBlbmRzIG9uIEZyYWN0aW9uXHJcblxyXG4gICAgLy9UaGUgbGF0ZXggZ2VuZXJhdG9yXHJcbiAgICB2YXIgTGFUZVggPSB7XHJcbiAgICAgICAgcGFyc2VyOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBwYXJzZXIgYW5kIHN0cmlwIGl0IGZyb20gZXZlcnl0aGluZyBleGNlcHQgdGhlIGl0ZW1zIHRoYXQgeW91IG5lZWRcclxuICAgICAgICAgICAgdmFyIGtlZXAgPSBbJ2NsYXNzZXMnLCAnc2V0T3BlcmF0b3InLCAnZ2V0T3BlcmF0b3JzJywgJ2dldEJyYWNrZXRzJywgJ3Rva2VuaXplJywgJ3RvUlBOJywgJ3RyZWUnLCAndW5pdHMnXTtcclxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoKTtcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIHBhcnNlcikge1xyXG4gICAgICAgICAgICAgICAgaWYoa2VlcC5pbmRleE9mKHgpID09PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyc2VyW3hdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGRlY2xhcmUgdGhlIG9wZXJhdG9yc1xyXG4gICAgICAgICAgICBwYXJzZXIuc2V0T3BlcmF0b3Ioe1xyXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZTogOCxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnXFxcXCcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdzbGFzaCcsXHJcbiAgICAgICAgICAgICAgICBwcmVmaXg6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwb3N0Zml4OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGxlZnRBc3NvYzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTsgLy8gYnlwYXNzIHRoZSBzbGFzaFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcGFyc2VyLnNldE9wZXJhdG9yKHtcclxuICAgICAgICAgICAgICAgIHByZWNlZGVuY2U6IDgsXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogJ1xcXFwsJyxcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3NsYXNoX2NvbW1hJyxcclxuICAgICAgICAgICAgICAgIHByZWZpeDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHBvc3RmaXg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgbGVmdEFzc29jOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlOyAvLyBieXBhc3MgdGhlIHNsYXNoXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBoYXZlIGJyYWNlcyBub3QgbWFwIHRvIGFueXRoaW5nLiBXZSB3YW50IHRoZW0gdG8gYmUgcmV0dXJuIGFzLWlzXHJcbiAgICAgICAgICAgIHZhciBicmFja2V0cyA9IHBhcnNlci5nZXRCcmFja2V0cygpO1xyXG4gICAgICAgICAgICBicmFja2V0c1sneyddLm1hcHNfdG8gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXI7XHJcbiAgICAgICAgfSkoKSxcclxuICAgICAgICBzcGFjZTogJ34nLFxyXG4gICAgICAgIGRvdDogJyBcXFxcY2RvdCAnLFxyXG4gICAgICAgIC8vIGdyYWIgYSBsaXN0IG9mIHN1cHBvcnRlZCBmdW5jdGlvbnMgYnV0IHJlbW92ZSB0aGUgZXhjbHVkZWQgb25lcyBmb3VuZCBpbiBleGNsRk5cclxuXHJcbiAgICAgICAgbGF0ZXg6IGZ1bmN0aW9uIChzeW1ib2wsIG9wdGlvbikge1xyXG4gICAgICAgICAgICAvLyBpdCBtaWdodCBiZSBhbiBhcnJheVxyXG4gICAgICAgICAgICBpZihzeW1ib2wuY2xvbmUpIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHN5bWJvbC5jbG9uZSgpOyAvLyBsZWF2ZSBvcmlnaW5hbCBhcy1pc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHN5bWJvbCBpbnN0YW5jZW9mIF8uY2xhc3Nlcy5Db2xsZWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLmVsZW1lbnRzO1xyXG5cclxuICAgICAgICAgICAgaWYoaXNBcnJheShzeW1ib2wpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgTGFUZVhBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBzeW1ib2xbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIHdheSBJIGNhbiBnZW5lcmF0ZSBMYVRlWCBvbiBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmKCFpc1N5bWJvbChzeW0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW0gPSBfLnBhcnNlKHN5bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgTGFUZVhBcnJheS5wdXNoKHRoaXMubGF0ZXgoc3ltLCBvcHRpb24pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJyYWNrZXRzKExhVGVYQXJyYXkuam9pbignLCAnKSwgJ3NxdWFyZScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmKGlzTWF0cml4KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBUZVggPSAnXFxcXGJlZ2lue3BtYXRyaXh9XFxuJztcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzeW1ib2wuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm93VGVYID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gc3ltYm9sLmVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBlLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd1RlWC5wdXNoKHRoaXMubGF0ZXgoZVtqXSwgb3B0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFRlWCArPSByb3dUZVguam9pbignICYgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaSA8IHN5bWJvbC5lbGVtZW50cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRlWCArPSAnXFxcXFxcXFxcXG4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFRlWCArPSAnXFxcXGVuZHtwbWF0cml4fSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVGVYO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmKGlzVmVjdG9yKHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBUZVggPSAnXFxcXGxlZnRbJztcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzeW1ib2wuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBUZVggKz0gdGhpcy5sYXRleChzeW1ib2wuZWxlbWVudHNbaV0sIG9wdGlvbikgKyAnICcgKyAoaSAhPT0gc3ltYm9sLmVsZW1lbnRzLmxlbmd0aCAtIDEgPyAnLFxcXFwsJyA6ICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFRlWCArPSAnXFxcXHJpZ2h0XSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVGVYO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlbHNlIGlmKGlzU2V0KHN5bWJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBUZVggPSAnXFxcXHsnO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHN5bWJvbC5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIFRlWCArPSB0aGlzLmxhdGV4KHN5bWJvbC5lbGVtZW50c1tpXSwgb3B0aW9uKSArICcgJyArIChpICE9PSBzeW1ib2wuZWxlbWVudHMubGVuZ3RoIC0gMSA/ICcsXFxcXCwnIDogJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgVGVYICs9ICdcXFxcfSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVGVYO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wuY2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkZWNpbWFsID0gKG9wdGlvbiA9PT0gJ2RlY2ltYWwnIHx8IG9wdGlvbiA9PT0gJ2RlY2ltYWxzJyksXHJcbiAgICAgICAgICAgICAgICAgICAgcG93ZXIgPSBzeW1ib2wucG93ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0ID0gaXNOZWdhdGl2ZShwb3dlciksXHJcbiAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmUgPSBzeW1ib2wubXVsdGlwbGllci5sZXNzVGhhbigwKTtcclxuXHJcbiAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCA9PT0gUCAmJiBkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHN5bWJvbC5tdWx0aXBsaWVyLnRvRGVjaW1hbCgpICogTWF0aC5wb3coc3ltYm9sLnZhbHVlLCBzeW1ib2wucG93ZXIudG9EZWNpbWFsKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN5bWJvbC5tdWx0aXBsaWVyID0gc3ltYm9sLm11bHRpcGxpZXIuYWJzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgd2FudHMgdGhlIHJlc3VsdCBpbiBkZWNpbWFsIGZvcm1hdCB0aGVuIHJldHVybiBpdCBhcyBzdWNoIGJ5IHBsYWNpbmcgaXQgYXQgdGhlIHRvcCBwYXJ0XHJcbiAgICAgICAgICAgICAgICB2YXIgbV9hcnJheTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihkZWNpbWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBTdHJpbmcoc3ltYm9sLm11bHRpcGxpZXIudG9EZWNpbWFsKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKFN0cmluZyhtKSA9PT0gJzEnICYmICFkZWNpbWFsKSBtID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgbV9hcnJheSA9IFttLCAnJ107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtX2FycmF5ID0gW3N5bWJvbC5tdWx0aXBsaWVyLm51bSwgc3ltYm9sLm11bHRpcGxpZXIuZGVuXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgdmFsdWUgYXMgYSB0d28gcGFydCBhcnJheVxyXG4gICAgICAgICAgICAgICAgdmFyIHZfYXJyYXkgPSB0aGlzLnZhbHVlKHN5bWJvbCwgaW52ZXJ0LCBvcHRpb24sIG5lZ2F0aXZlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcDtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2UgaXQgYWxsIHBvc2l0aXZlIHNpbmNlIHdlIGtub3cgd2hldGhlciB0byBwdXNoIHRoZSBwb3dlciB0byB0aGUgbnVtZXJhdG9yIG9yIGRlbm9taW5hdG9yIGFscmVhZHkuXHJcbiAgICAgICAgICAgICAgICBpZihpbnZlcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgcG93ZXIubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgcG93ZXIgaXMgc2ltcGxlIHNpbmNlIGl0IHJlcXVpcmVzIG5vIGFkZGl0aW9uYWwgZm9ybWF0dGluZy4gV2UgY2FuIGdldCBpdCB0byBhXHJcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcgcmlnaHQgYXdheS4gcGFzcyBpbiB0cnVlIHRvIG5lZ2xlY3QgdW5pdCBwb3dlcnNcclxuICAgICAgICAgICAgICAgIGlmKGRlY2ltYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBwID0gaXNTeW1ib2wocG93ZXIpID8gTGFUZVgubGF0ZXgocG93ZXIsIG9wdGlvbikgOiBTdHJpbmcocG93ZXIudG9EZWNpbWFsKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFN0cmluZyhwKSA9PT0gJzEnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGxhdGV4IHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGlzU3ltYm9sKHBvd2VyKSlcclxuICAgICAgICAgICAgICAgICAgICBwID0gdGhpcy5sYXRleChwb3dlciwgb3B0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8vIGdldCBpdCBhcyBhIGZyYWN0aW9uXHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuZm9ybWF0RnJhYyhwb3dlciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhpcyBhcnJheSB0byBzcGVjaWZ5IGlmIHRoZSBwb3dlciBpcyBnZXR0aW5nIGF0dGFjaGVkIHRvIHRoZSB0b3Agb3IgdGhlIGJvdHRvbVxyXG4gICAgICAgICAgICAgICAgdmFyIHBfYXJyYXkgPSBbJycsICcnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RpY2sgaXQgdG8gdGhlIHRvcCBvciB0aGUgYm90dG9tLiBJZiBpdCdzIG5lZ2F0aXZlIHRoZW4gdGhlIHBvd2VyIGdldHMgcGxhY2VkIG9uIHRoZSBib3R0b21cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbnZlcnQgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIHBfYXJyYXlbaW5kZXhdID0gcDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZ3JvdXAgUCBhbmQgZGVjaW1hbFxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHZhbCA9IChuZWdhdGl2ZSA/ICctJyA6ICcnKSArIHRoaXMuc2V0KG1fYXJyYXksIHZfYXJyYXksIHBfYXJyYXksIHN5bWJvbC5ncm91cCA9PT0gQ0IpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWwucmVwbGFjZSgvXFwrXFwtL2dpLCAnLScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gZ3JlZWsgbWFwcGluZ1xyXG4gICAgICAgIGdyZWVrOiB7XHJcbiAgICAgICAgICAgIGFscGhhOiAnXFxcXGFscGhhJyxcclxuICAgICAgICAgICAgYmV0YTogJ1xcXFxiZXRhJyxcclxuICAgICAgICAgICAgZ2FtbWE6ICdcXFxcZ2FtbWEnLFxyXG4gICAgICAgICAgICBkZWx0YTogJ1xcXFxkZWx0YScsXHJcbiAgICAgICAgICAgIGVwc2lsb246ICdcXFxcZXBzaWxvbicsXHJcbiAgICAgICAgICAgIHpldGE6ICdcXFxcemV0YScsXHJcbiAgICAgICAgICAgIGV0YTogJ1xcXFxldGEnLFxyXG4gICAgICAgICAgICB0aGV0YTogJ1xcXFx0aGV0YScsXHJcbiAgICAgICAgICAgIGlvdGE6ICdcXFxcaW90YScsXHJcbiAgICAgICAgICAgIGthcHBhOiAnXFxcXGthcHBhJyxcclxuICAgICAgICAgICAgbGFtYmRhOiAnXFxcXGxhbWJkYScsXHJcbiAgICAgICAgICAgIG11OiAnXFxcXG11JyxcclxuICAgICAgICAgICAgbnU6ICdcXFxcbnUnLFxyXG4gICAgICAgICAgICB4aTogJ1xcXFx4aScsXHJcbiAgICAgICAgICAgIG9tbmlrcm9uOiAnXFxcXG9tbmlrcm9uJyxcclxuICAgICAgICAgICAgcGk6ICdcXFxccGknLFxyXG4gICAgICAgICAgICByaG86ICdcXFxccmhvJyxcclxuICAgICAgICAgICAgc2lnbWE6ICdcXFxcc2lnbWEnLFxyXG4gICAgICAgICAgICB0YXU6ICdcXFxcdGF1JyxcclxuICAgICAgICAgICAgdXBzaWxvbjogJ1xcXFx1cHNpbG9uJyxcclxuICAgICAgICAgICAgcGhpOiAnXFxcXHBoaScsXHJcbiAgICAgICAgICAgIGNoaTogJ1xcXFxjaGknLFxyXG4gICAgICAgICAgICBwc2k6ICdcXFxccHNpJyxcclxuICAgICAgICAgICAgb21lZ2E6ICdcXFxcb21lZ2EnLFxyXG4gICAgICAgICAgICBHYW1tYTogJ1xcXFxHYW1tYScsXHJcbiAgICAgICAgICAgIERlbHRhOiAnXFxcXERlbHRhJyxcclxuICAgICAgICAgICAgRXBzaWxvbjogJ1xcXFxFcHNpbG9uJyxcclxuICAgICAgICAgICAgVGhldGE6ICdcXFxcVGhldGEnLFxyXG4gICAgICAgICAgICBMYW1iZGE6ICdcXFxcTGFtYmRhJyxcclxuICAgICAgICAgICAgWGk6ICdcXFxcWGknLFxyXG4gICAgICAgICAgICBQaTogJ1xcXFxQaScsXHJcbiAgICAgICAgICAgIFNpZ21hOiAnXFxcXFNpZ21hJyxcclxuICAgICAgICAgICAgUGhpOiAnXFxcXFBoaScsXHJcbiAgICAgICAgICAgIFBzaTogJ1xcXFxQc2knLFxyXG4gICAgICAgICAgICBPbWVnYTogJ1xcXFxPbWVnYSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN5bWJvbHM6IHtcclxuICAgICAgICAgICAgYXJjY29zOiAnXFxcXGFyY2NvcycsXHJcbiAgICAgICAgICAgIGNvczogJ1xcXFxjb3MnLFxyXG4gICAgICAgICAgICBjc2M6ICdcXFxcY3NjJyxcclxuICAgICAgICAgICAgZXhwOiAnXFxcXGV4cCcsXHJcbiAgICAgICAgICAgIGtlcjogJ1xcXFxrZXInLFxyXG4gICAgICAgICAgICBsaW1zdXA6ICdcXFxcbGltc3VwJyxcclxuICAgICAgICAgICAgbWluOiAnXFxcXG1pbicsXHJcbiAgICAgICAgICAgIHNpbmg6ICdcXFxcc2luaCcsXHJcbiAgICAgICAgICAgIGFyY3NpbjogJ1xcXFxhcmNzaW4nLFxyXG4gICAgICAgICAgICBjb3NoOiAnXFxcXGNvc2gnLFxyXG4gICAgICAgICAgICBkZWc6ICdcXFxcZGVnJyxcclxuICAgICAgICAgICAgZ2NkOiAnXFxcXGdjZCcsXHJcbiAgICAgICAgICAgIGxnOiAnXFxcXGxnJyxcclxuICAgICAgICAgICAgbG46ICdcXFxcbG4nLFxyXG4gICAgICAgICAgICBQcjogJ1xcXFxQcicsXHJcbiAgICAgICAgICAgIHNxcnQ6ICdcXFxcc3FydCcsXHJcbiAgICAgICAgICAgIHN1cDogJ1xcXFxzdXAnLFxyXG4gICAgICAgICAgICBhcmN0YW46ICdcXFxcYXJjdGFuJyxcclxuICAgICAgICAgICAgY290OiAnXFxcXGNvdCcsXHJcbiAgICAgICAgICAgIGRldDogJ1xcXFxkZXQnLFxyXG4gICAgICAgICAgICBob206ICdcXFxcaG9tJyxcclxuICAgICAgICAgICAgbGltOiAnXFxcXGxpbScsXHJcbiAgICAgICAgICAgIGxvZzogJ1xcXFxsb2cnLFxyXG4gICAgICAgICAgICBMTjogJ1xcXFxMTicsXHJcbiAgICAgICAgICAgIHNlYzogJ1xcXFxzZWMnLFxyXG4gICAgICAgICAgICB0YW46ICdcXFxcdGFuJyxcclxuICAgICAgICAgICAgYXJnOiAnXFxcXGFyZycsXHJcbiAgICAgICAgICAgIGNvdGg6ICdcXFxcY290aCcsXHJcbiAgICAgICAgICAgIGRpbTogJ1xcXFxkaW0nLFxyXG4gICAgICAgICAgICBpbmY6ICdcXFxcaW5mJyxcclxuICAgICAgICAgICAgbGltaW5mOiAnXFxcXGxpbWluZicsXHJcbiAgICAgICAgICAgIG1heDogJ1xcXFxtYXgnLFxyXG4gICAgICAgICAgICBzaW46ICdcXFxcc2luJyxcclxuICAgICAgICAgICAgdGFuaDogJ1xcXFx0YW5oJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gZ2V0IHRoZSByYXcgdmFsdWUgb2YgdGhlIHN5bWJvbCBhcyBhbiBhcnJheVxyXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc3ltYm9sLCBpbnZlcnRlZCwgb3B0aW9uLCBuZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBzeW1ib2wuZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNHcm91cCA9IHN5bWJvbC5wcmV2aW91c0dyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBbJycsICcnXSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGludmVydGVkID8gMSA6IDA7XHJcbiAgICAgICAgICAgIC8qaWYoZ3JvdXAgPT09IE4pIC8vIGRvIG5vdGhpbmcgc2luY2Ugd2Ugd2FudCB0byByZXR1cm4gdG9wICYgYm90dG9tIGJsYW5rOyAqL1xyXG4gICAgICAgICAgICBpZihzeW1ib2wuaXNJbmZpbml0eSkge1xyXG4gICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXGluZnR5JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBTIHx8IGdyb3VwID09PSBQIHx8IHByZXZpb3VzR3JvdXAgPT09IFMgfHwgcHJldmlvdXNHcm91cCA9PT0gUCB8fCBwcmV2aW91c0dyb3VwID09PSBOKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmZvcm1hdFN1YnNjcmlwdHMoc3ltYm9sLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmKHZhbHVlLnJlcGxhY2UpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oLispXyQvLCAnJDFcXFxcXycpO1xyXG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgaXQgc28gd2UgY2FuIGNoZWNrIGZvciBpbnN0YW5jZXMgb2YgYWxwaGEgYXMgd2VsbCBhcyBhbHBoYV9iXHJcbiAgICAgICAgICAgICAgICB2YXIgdF92YXJyYXkgPSBTdHJpbmcodmFsdWUpLnNwbGl0KCdfJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JlZWsgPSB0aGlzLmdyZWVrW3RfdmFycmF5WzBdXTtcclxuICAgICAgICAgICAgICAgIGlmKGdyZWVrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdF92YXJyYXlbMF0gPSBncmVlaztcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRfdmFycmF5LmpvaW4oJ18nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSB0aGlzLnN5bWJvbHNbdF92YXJyYXlbMF1dO1xyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdF92YXJyYXlbMF0gPSBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0X3ZhcnJheS5qb2luKCdfJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2W2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IEZOIHx8IHByZXZpb3VzR3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm5hbWUgPSBzeW1ib2wuZm5hbWU7XHJcbiAgICAgICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBhcmd1bWVudHNcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzeW1ib2wuYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmcgPSBzeW1ib2wuYXJnc1tpXSwgaXRlbTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgYXJnID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGFyZztcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMubGF0ZXgoYXJnLCBvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGZuYW1lID09PSBTUVJUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXHNxcnQnICsgdGhpcy5icmFjZXMoaW5wdXQuam9pbignLCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IEFCUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gdGhpcy5icmFja2V0cyhpbnB1dC5qb2luKCcsJyksICdhYnMnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IFBBUkVOVEhFU0lTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSB0aGlzLmJyYWNrZXRzKGlucHV0LmpvaW4oJywnKSwgJ3BhcmVucycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2xpbWl0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gJyBcXFxcbGltXFxcXGxpbWl0c197JyArIGlucHV0WzFdICsgJyBcXFxcdG8gJyArIGlucHV0WzJdICsgJ30gJyArIGlucHV0WzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2ludGVncmF0ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcaW50JyArIHRoaXMuYnJhY2VzKGlucHV0WzBdKSArIHRoaXMuYnJhY2VzKCdkJyArIGlucHV0WzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdkZWZpbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXGludFxcXFxsaW1pdHNfJyArIHRoaXMuYnJhY2VzKGlucHV0WzFdKSArICdeJyArIHRoaXMuYnJhY2VzKGlucHV0WzJdKSArICcgJyArIGlucHV0WzBdICsgJyBkJyArIGlucHV0WzNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gRkFDVE9SSUFMIHx8IGZuYW1lID09PSBET1VCTEVGQUNUT1JJQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnID0gc3ltYm9sLmFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXJnLnBvd2VyLmVxdWFscygxKSAmJiAoYXJnLmlzQ29tcG9zaXRlKCkgfHwgYXJnLmlzQ29tYmluYXRpb24oKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRbMF0gPSB0aGlzLmJyYWNrZXRzKGlucHV0WzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSBpbnB1dFswXSArIChmbmFtZSA9PT0gRkFDVE9SSUFMID8gJyEnIDogJyEhJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnZmxvb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXGxlZnQgXFxcXGxmbG9vcicgKyB0aGlzLmJyYWNlcyhpbnB1dFswXSkgKyAnXFxcXHJpZ2h0IFxcXFxyZmxvb3InO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihmbmFtZSA9PT0gJ2NlaWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXGxlZnQgXFxcXGxjZWlsJyArIHRoaXMuYnJhY2VzKGlucHV0WzBdKSArICdcXFxccmlnaHQgXFxcXHJjZWlsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNhcHR1cmUgbG9nKGEsIGIpXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSBTZXR0aW5ncy5MT0cgJiYgaW5wdXQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gJ1xcXFxtYXRocm0nICsgdGhpcy5icmFjZXMoU2V0dGluZ3MuTE9HKSArICdfJyArIHRoaXMuYnJhY2VzKGlucHV0WzFdKSArIHRoaXMuYnJhY2tldHMoaW5wdXRbMF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2FwdHVyZSBsb2coYSwgYilcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09IFNldHRpbmdzLkxPRzEwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXG1hdGhybScgKyB0aGlzLmJyYWNlcyhTZXR0aW5ncy5MT0cpICsgJ18nICsgdGhpcy5icmFjZXMoMTApICsgdGhpcy5icmFja2V0cyhpbnB1dFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnc3VtJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5wdXRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gaW5wdXRbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gaW5wdXRbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gaW5wdXRbM107XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXHN1bVxcXFxsaW1pdHNfeycgKyB0aGlzLmJyYWNlcyhiKSArICc9JyArIHRoaXMuYnJhY2VzKGMpICsgJ31eJyArIHRoaXMuYnJhY2VzKGQpICsgJyAnICsgdGhpcy5icmFjZXMoYSkgKyAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdwcm9kdWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5wdXRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gaW5wdXRbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gaW5wdXRbMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gaW5wdXRbM107XHJcbiAgICAgICAgICAgICAgICAgICAgdltpbmRleF0gPSAnXFxcXHByb2RcXFxcbGltaXRzX3snICsgdGhpcy5icmFjZXMoYikgKyAnPScgKyB0aGlzLmJyYWNlcyhjKSArICd9XicgKyB0aGlzLmJyYWNlcyhkKSArICcgJyArIHRoaXMuYnJhY2VzKGEpICsgJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnbnRocm9vdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcc3FydFsnICsgaW5wdXRbMV0gKyAnXScgKyB0aGlzLmJyYWNlcyhpbnB1dFswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGZuYW1lID09PSAnbW9kJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZbaW5kZXhdID0gaW5wdXRbMF0gKyAnIFxcXFxibW9kICcgKyBpbnB1dFsxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdyZWFscGFydCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcb3BlcmF0b3JuYW1le1JlfScgKyB0aGlzLmJyYWNrZXRzKGlucHV0WzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZm5hbWUgPT09ICdpbWFncGFydCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9ICdcXFxcb3BlcmF0b3JuYW1le0ltfScgKyB0aGlzLmJyYWNrZXRzKGlucHV0WzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZm5hbWUgIT09ICcnID8gJ1xcXFxtYXRocm0nICsgdGhpcy5icmFjZXMoZm5hbWUucmVwbGFjZSgvXy9nLCAnXFxcXF8nKSkgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBpZihzeW1ib2wuaXNDb252ZXJzaW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9IG5hbWUgKyB0aGlzLmJyYWNrZXRzKGlucHV0LmpvaW4oJycpLCAncGFyZW5zJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2W2luZGV4XSA9IG5hbWUgKyB0aGlzLmJyYWNrZXRzKGlucHV0LmpvaW4oJywnKSwgJ3BhcmVucycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYoc3ltYm9sLmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0ZWQgPSBzeW1ib2wuY29sbGVjdFN5bWJvbHMoKS5zb3J0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cCA9PT0gQ1AgfHwgcHJldmlvdXNHcm91cCA9PT0gQ1AgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGIuZ3JvdXAgLSBhLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4ID0gaXNTeW1ib2woYS5wb3dlcikgPyAtMSA6IGEucG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGlzU3ltYm9sKGIucG93ZXIpID8gLTEgOiBiLnBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkgLSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBjb2xsZWN0ZWQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbHMucHVzaChMYVRlWC5sYXRleChjb2xsZWN0ZWRbaV0sIG9wdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3ltYm9scy5qb2luKCcrJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdltpbmRleF0gPSAhKHN5bWJvbC5pc0xpbmVhcigpICYmIHN5bWJvbC5tdWx0aXBsaWVyLmVxdWFscygxKSkgfHwgbmVnYXRpdmUgPyB0aGlzLmJyYWNrZXRzKHZhbHVlLCAncGFyZW5zJykgOiB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBDQiB8fCBwcmV2aW91c0dyb3VwID09PSBFWCB8fCBwcmV2aW91c0dyb3VwID09PSBDQikge1xyXG4gICAgICAgICAgICAgICAgaWYoZ3JvdXAgPT09IENCKVxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbC5kaXN0cmlidXRlRXhwb25lbnQoKTtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxtb3N0IGZlZWxzIGEgbGl0dGxlIGxpa2UgY2hlYXRpbmcgYnV0IEkgbmVlZCB0byBrbm93IGlmIEkgc2hvdWxkIGJlIHdyYXBwaW5nIHRoZSBzeW1ib2xcclxuICAgICAgICAgICAgICAgIC8vIGluIGJyYWNrZXRzIG9yIG5vdC4gV2UnbGwgZG8gdGhpcyBieSBjaGVja2luZyB0aGUgdmFsdWUgb2YgdGhlIG51bWVyYXRvciBhbmQgdGhlbiBjb21wYXJpbmcgaXRcclxuICAgICAgICAgICAgICAgIC8vIHRvIHdoZXRoZXIgdGhlIHN5bWJvbCB2YWx1ZSBpcyBcInNpbXBsZVwiIG9yIG5vdC5cclxuICAgICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1lcmF0b3IgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgcHJvZmlsZVxyXG4gICAgICAgICAgICAgICAgdmFyIGRlbl9tYXAgPSBbXSwgbnVtX21hcCA9IFtdLCBudW1fYyA9IDAsIGRlbl9jID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBzZXRCcmFja2V0cyA9IGZ1bmN0aW9uIChjb250YWluZXIsIG1hcCwgY291bnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvdW50ZXIgPiAxICYmIG1hcC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gbWFwLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IG1hcFtpXSwgaXRlbSA9IGNvbnRhaW5lcltpZHhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoISgvXlxcXFxsZWZ0XFwoLitcXFxccmlnaHRcXClcXF5cXHsuK1xcfSQvZy50ZXN0KGl0ZW0pIHx8IC9eXFxcXGxlZnRcXCguK1xcXFxyaWdodFxcKSQvZy50ZXN0KGl0ZW0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcltpZHhdID0gTGFUZVguYnJhY2tldHMoaXRlbSwgJ3BhcmVucycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGxhdGV4IGZvciBlYWNoIG9mIHRoZW1cclxuICAgICAgICAgICAgICAgIHN5bWJvbC5lYWNoKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRGVub20gPSBpc05lZ2F0aXZlKHgucG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFUZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGlzRGVub20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFUZXggPSBMYVRlWC5sYXRleCh4LmludmVydCgpLCBvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5fYysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih4LmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5tdWx0aXBsaWVyLmRlbiAhPSAxICYmIE1hdGguYWJzKHgucG93ZXIpID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFUZXggPSBMYVRlWC5icmFja2V0cyhsYVRleCwgJ3BhcmVucycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuX21hcC5wdXNoKGRlbm9taW5hdG9yLmxlbmd0aCk7IC8vIG1ha2UgYSBub3RlIG9mIHdoZXJlIHRoZSBjb21wb3NpdGUgd2FzIGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yLnB1c2gobGFUZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFUZXggPSBMYVRlWC5sYXRleCh4LCBvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1fYysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih4LmlzQ29tcG9zaXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5tdWx0aXBsaWVyLm51bSAhPSAxICYmIE1hdGguYWJzKHgucG93ZXIpID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFUZXggPSBMYVRlWC5icmFja2V0cyhsYVRleCwgJ3BhcmVucycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtX21hcC5wdXNoKG51bWVyYXRvci5sZW5ndGgpOyAgIC8vIG1ha2UgYSBub3RlIG9mIHdoZXJlIHRoZSBjb21wb3NpdGUgd2FzIGZvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtZXJhdG9yLnB1c2gobGFUZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGJyYWNrZXRzXHJcbiAgICAgICAgICAgICAgICBzZXRCcmFja2V0cyhudW1lcmF0b3IsIG51bV9tYXAsIG51bV9jKTtcclxuICAgICAgICAgICAgICAgIHZbMF0gPSBudW1lcmF0b3Iuam9pbih0aGlzLmRvdCk7IC8vIGNvbGxhcHNlIHRoZSBudW1lcmF0b3IgaW50byBvbmUgc3RyaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgc2V0QnJhY2tldHMoZGVub21pbmF0b3IsIGRlbl9tYXAsIGRlbl9jKTtcclxuICAgICAgICAgICAgICAgIHZbMV0gPSBkZW5vbWluYXRvci5qb2luKHRoaXMuZG90KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHY7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtLCB2LCBwLCBjb21iaW5lX3Bvd2VyKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0JyYWNrZXRlZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gL15cXFxcbGVmdFxcKC4rXFxcXHJpZ2h0XFwpJC8udGVzdCh2KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gZm9ybWF0IHRoZSBwb3dlciBpZiBpdCBleGlzdHNcclxuICAgICAgICAgICAgaWYocClcclxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLmZvcm1hdFAocCk7XHJcbiAgICAgICAgICAgIC8vIGdyb3VwIENCIHdpbGwgaGF2ZSB0byBiZSB3cmFwcGVkIHNpbmNlIHRoZSBwb3dlciBhcHBsaWVzIHRvIGJvdGggaXQncyBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yXHJcbiAgICAgICAgICAgIGlmKGNvbWJpbmVfcG93ZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBPU1NJQkxFIEJVRzogSWYgcG93ZXJzIGZvciBncm91cCBDQiBmb3JtYXQgd3JvbmcsIGludmVzdGlnYXRlIHRoaXMgc2luY2UgSSBtaWdodCBoYXZlIG92ZXJsb29rZWQgc29tZXRoaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgYXNzdW1wdGlvbiBpcyB0aGF0IGluIGV2ZXJ5IGNhc2UgdGhlIGRlbm9uaW1hdG9yIHNob3VsZCBiZSBlbXB0eSB3aGVuIGRlYWxpbmcgd2l0aCBDQi4gSSBjYW4ndCB0aGlua1xyXG4gICAgICAgICAgICAgICAgLy8gb2YgYSBjYXNlIHdoZXJlIHRoaXMgaXNuJ3QgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgdmFyIHRwID0gcFswXTtcclxuICAgICAgICAgICAgICAgIHBbMF0gPSAnJzsgLy8gdGVtcG9yYXJpbHkgbWFrZSBwIGJsYW5rXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIG1lcmdlIHYgYW5kIHAuIE5vdCB0aGF0IHYgTVVTVCBiZSBmaXJzdCBzaW5jZSB0aGUgb3JkZXIgbWF0dGVyc1xyXG4gICAgICAgICAgICB2ID0gdGhpcy5tZXJnZSh2LCBwKTtcclxuICAgICAgICAgICAgdmFyIG1uID0gbVswXSwgbWQgPSBtWzFdLCB2biA9IHZbMF0sIHZkID0gdlsxXTtcclxuICAgICAgICAgICAgLy8gZmlsdGVyc1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdG9wIGhhcyBhIHZhcmlhYmxlIGJ1dCB0aGUgbnVtZXJhdG9yIGlzIG9uZSBkcm9wIGl0XHJcbiAgICAgICAgICAgIGlmKHZuICYmIE51bWJlcihtbikgPT09IDEpXHJcbiAgICAgICAgICAgICAgICBtbiA9ICcnO1xyXG4gICAgICAgICAgICAvLyBpZiBkZW5vbWluYXRvciBpcyAxIGRyb3AgaXQgYWx3YXlzXHJcbiAgICAgICAgICAgIGlmKE51bWJlcihtZCkgPT09IDEpXHJcbiAgICAgICAgICAgICAgICBtZCA9ICcnO1xyXG4gICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSB0b3AgcG9ydGlvbiBidXQgY2hlY2sgdGhhdCBpdCdzIG5vdCBhbHJlYWR5IGJyYWNrZXRlZC4gSWYgaXQgaXMgdGhlbiBsZWF2ZSBvdXQgdGhlIGNkb3RcclxuICAgICAgICAgICAgdmFyIHRvcCA9IHRoaXMuam9pbihtbiwgdm4sICFpc0JyYWNrZXRlZCh2bikgPyB0aGlzLmRvdCA6ICcnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIGJvdHRvbSBwb3J0aW9uIGJ1dCBjaGVjayB0aGF0IGl0J3Mgbm90IGFscmVhZHkgYnJhY2tldGVkLiBJZiBpdCBpcyB0aGVuIGxlYXZlIG91dCB0aGUgY2RvdFxyXG4gICAgICAgICAgICB2YXIgYm90dG9tID0gdGhpcy5qb2luKG1kLCB2ZCwgIWlzQnJhY2tldGVkKHZkKSA/IHRoaXMuZG90IDogJycpO1xyXG4gICAgICAgICAgICAvLyBmb3JtYXQgdGhlIHBvd2VyIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICAvLyBtYWtlIGl0IGEgZnJhY3Rpb24gaWYgYm90aCB0b3AgYW5kIGJvdHRvbSBleGlzdHNcclxuICAgICAgICAgICAgaWYodG9wICYmIGJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYWMgPSB0aGlzLmZyYWModG9wLCBib3R0b20pO1xyXG4gICAgICAgICAgICAgICAgaWYoY29tYmluZV9wb3dlciAmJiB0cClcclxuICAgICAgICAgICAgICAgICAgICBmcmFjID0gdGhpcy5icmFja2V0cyhmcmFjKSArIHRwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIG9ubHkgdGhlIHRvcCBleGlzdHMgc28gcmV0dXJuIHRoYXRcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvcDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICB2YXIgciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgcltpXSA9IGFbaV0gKyBiW2ldO1xyXG4gICAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIGpvaW5zIHRvZ2V0aGVyIHR3byBzdHJpbmdzIGlmIGJvdGggZXhpc3RcclxuICAgICAgICBqb2luOiBmdW5jdGlvbiAobiwgZCwgZ2x1ZSkge1xyXG4gICAgICAgICAgICBpZighbiAmJiAhZClcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgaWYobiAmJiAhZClcclxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgICAgICBpZihkICYmICFuKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgICAgIHJldHVybiBuICsgZ2x1ZSArIGQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGFjZXMgc3Vic2NyaXB0cyBpbiBicmFjZXMgZm9yIHByb3BlciBmb3JtYXR0aW5nXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZcclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZvcm1hdFN1YnNjcmlwdHM6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIC8vIFNwbGl0IGl0IGF0IHRoZSB1bmRlcnNjb3JlXHJcbiAgICAgICAgICAgIHZhciBhcnIgPSB2LnRvU3RyaW5nKCkuc3BsaXQoJ18nKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gJyc7XHJcblxyXG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgYWxsIGVudHJpZXMgZXhjZXB0IHRoZSBmaXJzdCBvbmVcclxuICAgICAgICAgICAgd2hpbGUoYXJyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdyYXAgYWxsIGluIGJyYWNlcyBleGNlcHQgZm9yIHRoZSBsYXN0IG9uZVxyXG4gICAgICAgICAgICAgICAgaWYoYXJyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ18nICsgdGhpcy5icmFjZXMoYXJyLnBvcCgpICsgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhcnJbMF0gKyBuYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZm9ybWF0UDogZnVuY3Rpb24gKHBfYXJyYXkpIHtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwX2FycmF5W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYocClcclxuICAgICAgICAgICAgICAgICAgICBwX2FycmF5W2ldID0gJ14nICsgdGhpcy5icmFjZXMocCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBfYXJyYXk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBmb3JtYXRzIHRoZSBmcmFjdGlvbnMgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtGcmFjfSBmXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sfSBpc19wb3dcclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3JtYXRGcmFjOiBmdW5jdGlvbiAoZiwgaXNfcG93KSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gZi5udW0udG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgICAgICBkID0gZi5kZW4udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBoYXZlIHheMVxyXG4gICAgICAgICAgICBpZihpc19wb3cgJiYgbiA9PT0gJzEnICYmIGQgPT09ICcxJylcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBoYXZlIHgvMVxyXG4gICAgICAgICAgICBpZihkID09PSAnMScpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJhYyhuLCBkKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyYWM6IGZ1bmN0aW9uIChuLCBkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnXFxcXGZyYWMnICsgdGhpcy5icmFjZXMobikgKyB0aGlzLmJyYWNlcyhkKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJyYWNlczogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd7JyArIGUgKyAnfSc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBicmFja2V0czogZnVuY3Rpb24gKGUsIHR5cCkge1xyXG4gICAgICAgICAgICB0eXAgPSB0eXAgfHwgJ3BhcmVucyc7XHJcbiAgICAgICAgICAgIHZhciBicmFja2V0VHlwZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnM6IFsnKCcsICcpJ10sXHJcbiAgICAgICAgICAgICAgICBzcXVhcmU6IFsnWycsICddJ10sXHJcbiAgICAgICAgICAgICAgICBicmFjZTogWyd7JywgJ30nXSxcclxuICAgICAgICAgICAgICAgIGFiczogWyd8JywgJ3wnXSxcclxuICAgICAgICAgICAgICAgIGFuZ2xlOiBbJ1xcXFxsYW5nbGUnLCAnXFxcXHJhbmdsZSddXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBicmFja2V0ID0gYnJhY2tldFR5cGVzW3R5cF07XHJcbiAgICAgICAgICAgIHJldHVybiAnXFxcXGxlZnQnICsgYnJhY2tldFswXSArIGUgKyAnXFxcXHJpZ2h0JyArIGJyYWNrZXRbMV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGV4dHJlbmVvdXMgdG9rZW5zXHJcbiAgICAgICAgICogQHBhcmFtIHtUb2tlbnNbXX0gdG9rZW5zXHJcbiAgICAgICAgICogQHJldHVybnMge1Rva2Vuc1tdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZpbHRlclRva2VuczogZnVuY3Rpb24gKHRva2Vucykge1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgb3ZlciB0aGUgdHlwZSBvZiB0aGUgc2NvcGVcclxuICAgICAgICAgICAgaWYoaXNBcnJheSh0b2tlbnMpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZC50eXBlID0gdG9rZW5zLnR5cGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHRoZSBpdGVtcyB0aGF0IG5lZWQgdG8gYmUgZGlzcG9zZWRcclxuICAgICAgICAgICAgdmFyIGQgPSBbJ1xcXFwnLCAnbGVmdCcsICdyaWdodCcsICdiaWcnLCAnQmlnJywgJ2xhcmdlJywgJ0xhcmdlJ107XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dF90b2tlbiA9IHRva2Vuc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICBpZih0b2tlbi52YWx1ZSA9PT0gJ1xcXFwnICYmIG5leHRfdG9rZW4udmFsdWUgPT09ICdcXFxcJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihpc0FycmF5KHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goTGFUZVguZmlsdGVyVG9rZW5zKHRva2VuKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGQuaW5kZXhPZih0b2tlbi52YWx1ZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBQYXJzZXMgdG9rZW5zIGZyb20gTGFUZVggc3RyaW5nLiBEb2VzIG5vdCBkbyBhbnkgZXJyb3IgY2hlY2tpbmdcclxuICAgICAgICAgKiBAcGFyYW0ge1Rva2Vuc1tdfSBycG5cclxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAocmF3X3Rva2Vucykge1xyXG4gICAgICAgICAgICB2YXIgaSwgbDtcclxuICAgICAgICAgICAgdmFyIHJldHZhbCA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5maWx0ZXJUb2tlbnMocmF3X3Rva2Vucyk7XHJcbiAgICAgICAgICAgIHZhciByZXBsYWNlID0ge1xyXG4gICAgICAgICAgICAgICAgJ2Nkb3QnOiAnJyxcclxuICAgICAgICAgICAgICAgICd0aW1lcyc6ICcnLFxyXG4gICAgICAgICAgICAgICAgJ2luZnR5JzogJ0luZmluaXR5J1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG5leHQgdG9rZW5cclxuICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1sodHlwZW9mIG4gPT09ICd1bmRlZmluZWQnID8gKytpIDogaSArPSBuKV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBwYXJzZV9uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIExhVGVYLnBhcnNlKG5leHQoKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmKHRva2VuIGluIHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVt0b2tlbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBIHF1aXJrIHdpdGggaW1wbGljaXQgbXVsdGlwbGljYXRpb24gZm9yY2VzIHVzIHRvIGNoZWNrIGZvciAqXHJcbiAgICAgICAgICAgICAgICBpZih0b2tlbiA9PT0gJyonICYmIHRva2Vuc1tpICsgMV0udmFsdWUgPT09ICcmJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQoMik7IC8vIHNraXAgdGhpcyBhbmQgdGhlICZcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJywnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHRva2VuID09PSAnJicpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcsJzsgLy8gU2tpcCB0aGUgKlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgZW5kIG9mIGEgcm93LCByZXR1cm4gdGhlIHJvdyBzZXBhcmF0b3JcclxuICAgICAgICAgICAgICAgIGlmKHRva2VuID09PSAnXFxcXCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ10sWyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBzdGFydCBwYXJzaW5nIHRoZSB0b2tlbnNcclxuICAgICAgICAgICAgZm9yKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gZnJhY3Rpb25zXHJcbiAgICAgICAgICAgICAgICBpZih0b2tlbi52YWx1ZSA9PT0gJ2ZyYWMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2UgYW5kIHdyYXAgaXQgaW4gYnJhY2tldHNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IHBhcnNlX25leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHBhcnNlX25leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgKz0gbiArICcvJyArIGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnZhbHVlIGluIExhVGVYLnN5bWJvbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0b2tlbi52YWx1ZSA9PT0gU1FSVCAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICd2ZWN0b3InICYmIHRva2Vuc1tpICsgMl0udHlwZSA9PT0gJ1NldCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBwYXJzZV9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHByID0gcGFyc2VfbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgKz0gKGV4cHIgKyAnXicgKyBpbkJyYWNrZXRzKCcxLycgKyBiYXNlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgKz0gdG9rZW4udmFsdWUgKyBwYXJzZV9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih0b2tlbi52YWx1ZSA9PT0gJ2ludCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHBhcnNlX25leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBjb21tYVxyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHZhcmlhYmxlIG9mIGludGVncmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbmV4dCgpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGR4ID0gZ2V0KGR4LnN1YnN0cmluZygxLCBkeC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR2YWwgKz0gJ2ludGVncmF0ZScgKyBpbkJyYWNrZXRzKGYgKyAnLCcgKyBkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnZhbHVlID09PSAnaW50XycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHBhcnNlX25leHQoKTsgLy8gbG93ZXJcclxuICAgICAgICAgICAgICAgICAgICBpKys7IC8vIHNraXAgdGhlIF5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IG5leHQoKS52YWx1ZTsgLy8gdXBwZXJcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBpbiBicmFja2V0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IHBhcnNlX25leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBwYXJzZV9uZXh0KCk7IC8vIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSB2YXJpYWJsZSBvZiBpbnRlZ3JhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IG5leHQoKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBjb21tYVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkeCA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IG5leHQoKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgJ2QnLCBza2lwXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR4ID09PSAnZGlmZmVyZW50aWFsRCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IG5leHQoKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR4ID09PSAnbWF0aHJtJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBtYXRocm17ZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBuZXh0KCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSAnZGVmaW50JyArIGluQnJhY2tldHMoZiArICcsJyArIGwgKyAnLCcgKyB1ICsgJywnICsgZHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih0b2tlbi52YWx1ZSAmJiB0b2tlbi52YWx1ZS5zdGFydHNXaXRoKCdpbnRfJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgbCA9IHBhcnNlX25leHQoKTsgLy8gbG93ZXJcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IHRva2VuLnZhbHVlLnJlcGxhY2UoJ2ludF8nLCAnJylcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndXBwZXJub3cnKVxyXG4gICAgICAgICAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0aGUgXlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1ID0gbmV4dCgpLnZhbHVlOyAvLyB1cHBlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGluIGJyYWNrZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1ID0gcGFyc2VfbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IHBhcnNlX25leHQoKTsgLy8gZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIHZhcmlhYmxlIG9mIGludGVncmF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbmV4dCgpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIGNvbW1hXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR4ID09PSAnLCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbmV4dCgpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAnZCcsIHNraXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHggPT09ICdkaWZmZXJlbnRpYWxEJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbmV4dCgpLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHggPT09ICdtYXRocm0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNraXAgdGhlIG1hdGhybXtkfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IG5leHQoKS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsICs9ICdkZWZpbnQnICsgaW5CcmFja2V0cyhmICsgJywnICsgbCArICcsJyArIHUgKyAnLCcgKyBkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnZhbHVlID09PSAnbWF0aHJtJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gdG9rZW5zWysraV1bMF0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dmFsICs9IGYgKyBwYXJzZV9uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzdW0gYW5kIHByb2R1Y3RcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW4udmFsdWUgPT09ICdzdW1fJyB8fCB0b2tlbi52YWx1ZSA9PT0gJ3Byb2RfJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHRva2VuLnZhbHVlID09PSAnc3VtXycgPyAnc3VtJyA6ICdwcm9kdWN0JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0aGUgY2FyZXRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gcGFyc2VfbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gcGFyc2VfbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSBmbiArIGluQnJhY2tldHMoW2YsIGdldChueHRbMF0pLCBnZXQobnh0WzJdKSwgZ2V0KGVuZCldLmpvaW4oJywnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnZhbHVlID09PSAnbGltXycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gbmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSAnbGltaXQnICsgaW5CcmFja2V0cyhbcGFyc2VfbmV4dCgpLCBnZXQobnh0WzBdKSwgZ2V0KG54dFsyXSldLmpvaW4oJywnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnZhbHVlID09PSAnYmVnaW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG54dCA9IG5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG54dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBueHRbMF0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHYgPT09ICdtYXRyaXgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBhIG1hdHJpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsICs9ICdtYXRyaXgoWyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHRva2VuLnZhbHVlID09PSAnZW5kJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBueHQgPSBuZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoQXJyYXkuaXNBcnJheShueHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gbnh0WzBdLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2ID09PSAnbWF0cml4Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGEgbWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgKz0gJ10pJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSBnZXQoTGFUZVgucGFyc2UodG9rZW4pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCArPSBnZXQodG9rZW4udmFsdWUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW5CcmFja2V0cyhyZXR2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbi8vVmVjdG9yID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICBmdW5jdGlvbiBWZWN0b3Iodikge1xyXG4gICAgICAgIGlmKGlzVmVjdG9yKHYpKVxyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gdi5pdGVtcy5zbGljZSgwKTtcclxuICAgICAgICBlbHNlIGlmKGlzQXJyYXkodikpXHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSB2LnNsaWNlKDApO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBwcmUtZmlsbGVkIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IG5cclxuICAgICAqIEBwYXJhbSB7dHlwZX0gdmFsXHJcbiAgICAgKiBAcmV0dXJucyB7dW5yZXNvbHZlZH1cclxuICAgICAqL1xyXG4gICAgVmVjdG9yLmFycmF5UHJlZmlsbCA9IGZ1bmN0aW9uIChuLCB2YWwpIHtcclxuICAgICAgICB2YXIgYSA9IFtdO1xyXG4gICAgICAgIHZhbCA9IHZhbCB8fCAwO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgIGFbaV0gPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIGE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIHZlY3RvciBmcm9tIGFuZCBhcnJheVxyXG4gICAgICogQHBhcmFtIHt0eXBlfSBhXHJcbiAgICAgKiBAcmV0dXJucyB7dW5yZXNvbHZlZH1cclxuICAgICAqL1xyXG4gICAgVmVjdG9yLmZyb21BcnJheSA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdmFyIHYgPSBuZXcgVmVjdG9yKCk7XHJcbiAgICAgICAgdi5lbGVtZW50cyA9IGE7XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBhIFNldCB0byBhIFZlY3RvclxyXG4gICAgICogQHBhcmFtIHtTZXR9IHNldFxyXG4gICAgICogQHJldHVybnMge1ZlY3Rvcn1cclxuICAgICAqL1xyXG4gICAgVmVjdG9yLmZyb21TZXQgPSBmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIFZlY3Rvci5mcm9tQXJyYXkoc2V0LmVsZW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgLy9Qb3J0ZWQgZnJvbSBTeWx2ZXN0ZXIuanNcclxuICAgIFZlY3Rvci5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgY3VzdG9tOiB0cnVlLFxyXG4gICAgICAgIC8vIFJldHVybnMgZWxlbWVudCBpIG9mIHRoZSB2ZWN0b3JcclxuICAgICAgICBlOiBmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGkgPCAxIHx8IGkgPiB0aGlzLmVsZW1lbnRzLmxlbmd0aCkgPyBudWxsIDogdGhpcy5lbGVtZW50c1tpIC0gMV07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaSwgdmFsKSB7XHJcbiAgICAgICAgICAgIGlmKCFpc1N5bWJvbCh2YWwpKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gbmV3IFN5bWJvbCh2YWwpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldID0gdmFsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGUgdmVjdG9yIGhhc1xyXG4gICAgICAgIGRpbWVuc2lvbnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIG1vZHVsdXMgKCdsZW5ndGgnKSBvZiB0aGUgdmVjdG9yXHJcbiAgICAgICAgbW9kdWx1czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2soJ1NBRkUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5wb3coKHRoaXMuZG90KHRoaXMuY2xvbmUoKSkpLCBuZXcgU3ltYm9sKDAuNSkpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBlcXVhbCB0byB0aGUgYXJndW1lbnRcclxuICAgICAgICBlcWw6IGZ1bmN0aW9uICh2ZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIFYgPSB2ZWN0b3IuZWxlbWVudHMgfHwgdmVjdG9yO1xyXG4gICAgICAgICAgICBpZihuICE9PSBWLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGlmKE1hdGguYWJzKF8uc3VidHJhY3QodGhpcy5lbGVtZW50c1tuIC0gMV0sIFZbbiAtIDFdKS52YWx1ZU9mKCkpID4gUFJFQ0lTSU9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKC0tbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgdmVjdG9yXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIFYgPSBuZXcgVmVjdG9yKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvL1J1bGU6IGFsbCBpdGVtcyB3aXRoaW4gdGhlIHZlY3RvciBtdXN0IGhhdmUgYSBjbG9uZSBtZXRob2QuXHJcbiAgICAgICAgICAgICAgICBWLmVsZW1lbnRzLnB1c2godGhpcy5lbGVtZW50c1tpXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLmdldHRlcikge1xyXG4gICAgICAgICAgICAgICAgVi5nZXR0ZXIgPSB0aGlzLmdldHRlci5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBWO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIE1hcHMgdGhlIHZlY3RvciB0byBhbm90aGVyIHZlY3RvciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uXHJcbiAgICAgICAgbWFwOiBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChmbih4LCBpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoZWxlbWVudHMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIENhbGxzIHRoZSBpdGVyYXRvciBmb3IgZWFjaCBlbGVtZW50IG9mIHRoZSB2ZWN0b3IgaW4gdHVyblxyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBrID0gbiwgaTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaSA9IGsgLSBuO1xyXG4gICAgICAgICAgICAgICAgZm4odGhpcy5lbGVtZW50c1tpXSwgaSArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKC0tbik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyBhIG5ldyB2ZWN0b3IgY3JlYXRlZCBieSBub3JtYWxpemluZyB0aGUgcmVjZWl2ZXJcclxuICAgICAgICB0b1VuaXRWZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrKCdTQUZFJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLm1vZHVsdXMoKTtcclxuICAgICAgICAgICAgICAgIGlmKHIudmFsdWVPZigpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmRpdmlkZSh4LCByKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHZlY3RvciBhbmQgdGhlIGFyZ3VtZW50IChhbHNvIGEgdmVjdG9yKVxyXG4gICAgICAgIGFuZ2xlRnJvbTogZnVuY3Rpb24gKHZlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2soJ1NBRkUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgViA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYobiAhPT0gVi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkb3QgPSBuZXcgU3ltYm9sKDApLCBtb2QxID0gbmV3IFN5bWJvbCgwKSwgbW9kMiA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgICAgICAvLyBXb3JrIHRoaW5ncyBvdXQgaW4gcGFyYWxsZWwgdG8gc2F2ZSB0aW1lXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb3QgPSBfLmFkZChkb3QsIF8ubXVsdGlwbHkoeCwgVltpIC0gMV0pKTtcclxuICAgICAgICAgICAgICAgICAgICBtb2QxID0gXy5hZGQobW9kMSwgXy5tdWx0aXBseSh4LCB4KSk7Ly8gd2lsbCBub3QgY29uZmxpY3QgaW4gc2FmZSBibG9ja1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZDIgPSBfLmFkZChtb2QyLCBfLm11bHRpcGx5KFZbaSAtIDFdLCBWW2kgLSAxXSkpOy8vIHdpbGwgbm90IGNvbmZsaWN0IGluIHNhZmUgYmxvY2tcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbW9kMSA9IF8ucG93KG1vZDEsIG5ldyBTeW1ib2woMC41KSk7XHJcbiAgICAgICAgICAgICAgICBtb2QyID0gXy5wb3cobW9kMiwgbmV3IFN5bWJvbCgwLjUpKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9kdWN0ID0gXy5tdWx0aXBseShtb2QxLCBtb2QyKTtcclxuICAgICAgICAgICAgICAgIGlmKHByb2R1Y3QudmFsdWVPZigpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBfLmRpdmlkZShkb3QsIHByb2R1Y3QpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRoZXRhX3ZhbCA9IHRoZXRhLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIGlmKHRoZXRhX3ZhbCA8IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhldGEgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHRoZXRhX3ZhbCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGV0YSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN5bWJvbChNYXRoLmFjb3ModGhldGEpKTtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSB2ZWN0b3IgaXMgcGFyYWxsZWwgdG8gdGhlIGFyZ3VtZW50XHJcbiAgICAgICAgaXNQYXJhbGxlbFRvOiBmdW5jdGlvbiAodmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHRoaXMuYW5nbGVGcm9tKHZlY3RvcikudmFsdWVPZigpO1xyXG4gICAgICAgICAgICByZXR1cm4gKGFuZ2xlID09PSBudWxsKSA/IG51bGwgOiAoYW5nbGUgPD0gUFJFQ0lTSU9OKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSB2ZWN0b3IgaXMgYW50aXBhcmFsbGVsIHRvIHRoZSBhcmd1bWVudFxyXG4gICAgICAgIGlzQW50aXBhcmFsbGVsVG86IGZ1bmN0aW9uICh2ZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZUZyb20odmVjdG9yKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYW5nbGUgPT09IG51bGwpID8gbnVsbCA6IChNYXRoLmFicyhhbmdsZSAtIE1hdGguUEkpIDw9IFBSRUNJU0lPTik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGFyZ3VtZW50XHJcbiAgICAgICAgaXNQZXJwZW5kaWN1bGFyVG86IGZ1bmN0aW9uICh2ZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGRvdCA9IHRoaXMuZG90KHZlY3Rvcik7XHJcbiAgICAgICAgICAgIHJldHVybiAoZG90ID09PSBudWxsKSA/IG51bGwgOiAoTWF0aC5hYnMoZG90KSA8PSBQUkVDSVNJT04pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhZGRpbmcgdGhlIGFyZ3VtZW50IHRvIHRoZSB2ZWN0b3JcclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uICh2ZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrKCdTQUZFJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIFYgPSB2ZWN0b3IuZWxlbWVudHMgfHwgdmVjdG9yO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5lbGVtZW50cy5sZW5ndGggIT09IFYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKHgsIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5hZGQoeCwgVltpIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW5nIHRoZSBhcmd1bWVudCBmcm9tIHRoZSB2ZWN0b3JcclxuICAgICAgICBzdWJ0cmFjdDogZnVuY3Rpb24gKHZlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2soJ1NBRkUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgViA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPT0gVi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoeCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLnN1YnRyYWN0KHgsIFZbaSAtIDFdKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBtdWx0aXBseWluZyB0aGUgZWxlbWVudHMgb2YgdGhlIHZlY3RvciBieSB0aGUgYXJndW1lbnRcclxuICAgICAgICBtdWx0aXBseTogZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5jbG9uZSgpICogay5jbG9uZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB4OiBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShrKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBzY2FsYXIgcHJvZHVjdCBvZiB0aGUgdmVjdG9yIHdpdGggdGhlIGFyZ3VtZW50XHJcbiAgICAgICAgLy8gQm90aCB2ZWN0b3JzIG11c3QgaGF2ZSBlcXVhbCBkaW1lbnNpb25hbGl0eVxyXG4gICAgICAgIGRvdDogZnVuY3Rpb24gKHZlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2soJ1NBRkUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgViA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvZHVjdCA9IG5ldyBTeW1ib2woMCksIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmKG4gIT09IFYubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZHVjdCA9IF8uYWRkKHByb2R1Y3QsIF8ubXVsdGlwbHkodGhpcy5lbGVtZW50c1tuIC0gMV0sIFZbbiAtIDFdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSgtLW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUmV0dXJucyB0aGUgdmVjdG9yIHByb2R1Y3Qgb2YgdGhlIHZlY3RvciB3aXRoIHRoZSBhcmd1bWVudFxyXG4gICAgICAgIC8vIEJvdGggdmVjdG9ycyBtdXN0IGhhdmUgZGltZW5zaW9uYWxpdHkgM1xyXG4gICAgICAgIGNyb3NzOiBmdW5jdGlvbiAodmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBCID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcclxuICAgICAgICAgICAgaWYodGhpcy5lbGVtZW50cy5sZW5ndGggIT09IDMgfHwgQi5sZW5ndGggIT09IDMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBBID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrKCdTQUZFJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoW1xyXG4gICAgICAgICAgICAgICAgICAgIF8uc3VidHJhY3QoXy5tdWx0aXBseShBWzFdLCBCWzJdKSwgXy5tdWx0aXBseShBWzJdLCBCWzFdKSksXHJcbiAgICAgICAgICAgICAgICAgICAgXy5zdWJ0cmFjdChfLm11bHRpcGx5KEFbMl0sIEJbMF0pLCBfLm11bHRpcGx5KEFbMF0sIEJbMl0pKSxcclxuICAgICAgICAgICAgICAgICAgICBfLnN1YnRyYWN0KF8ubXVsdGlwbHkoQVswXSwgQlsxXSksIF8ubXVsdGlwbHkoQVsxXSwgQlswXSkpXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBSZXR1cm5zIHRoZSAoYWJzb2x1dGUpIGxhcmdlc3QgZWxlbWVudCBvZiB0aGUgdmVjdG9yXHJcbiAgICAgICAgbWF4OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gMCwgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBrID0gbiwgaTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaSA9IGsgLSBuO1xyXG4gICAgICAgICAgICAgICAgaWYoTWF0aC5hYnModGhpcy5lbGVtZW50c1tpXS52YWx1ZU9mKCkpID4gTWF0aC5hYnMobS52YWx1ZU9mKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHRoaXMuZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoLS1uKTtcclxuICAgICAgICAgICAgcmV0dXJuIG07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBtYWduaXR1ZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG1hZ25pdHVkZSA9IG5ldyBTeW1ib2woMCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgbWFnbml0dWRlID0gXy5hZGQobWFnbml0dWRlLCBfLnBvdyhlLCBuZXcgU3ltYm9sKDIpKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gXy5zcXJ0KG1hZ25pdHVkZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgbWF0Y2ggZm91bmRcclxuICAgICAgICBpbmRleE9mOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBudWxsLCBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGsgPSBuLCBpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpID0gayAtIG47XHJcbiAgICAgICAgICAgICAgICBpZihpbmRleCA9PT0gbnVsbCAmJiB0aGlzLmVsZW1lbnRzW2ldLnZhbHVlT2YoKSA9PT0geC52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKC0tbik7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0KHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGF0ZXg6IGZ1bmN0aW9uIChvcHRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHRleCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGV4LnB1c2goTGFUZVgubGF0ZXguY2FsbChMYVRlWCwgdGhpcy5lbGVtZW50c1tpXSwgb3B0aW9uKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICdbJyArIHRleC5qb2luKCcsICcpICsgJ10nO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4vL01hdHJpeCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgZnVuY3Rpb24gTWF0cml4KCkge1xyXG4gICAgICAgIHZhciBtID0gYXJndW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgbCA9IG0ubGVuZ3RoLCBpLCBlbCA9IFtdO1xyXG4gICAgICAgIGlmKGlzTWF0cml4KG0pKSB7IC8vIGlmIGl0J3MgYSBtYXRyaXggdGhlbiBtYWtlIGEgY2xvbmVcclxuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5wdXNoKG1baV0uc2xpY2UoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcm93LCBsdywgcmw7XHJcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcm93ID0gbVtpXTtcclxuICAgICAgICAgICAgICAgIGlmKGlzVmVjdG9yKHJvdykpXHJcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gcm93LmVsZW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgaWYoIWlzQXJyYXkocm93KSlcclxuICAgICAgICAgICAgICAgICAgICByb3cgPSBbcm93XTtcclxuICAgICAgICAgICAgICAgIHJsID0gcm93Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmKGx3ICYmIGx3ICE9PSBybClcclxuICAgICAgICAgICAgICAgICAgICBlcnIoJ1VuYWJsZSB0byBjcmVhdGUgTWF0cml4LiBSb3cgZGltZW5zaW9ucyBkbyBub3QgbWF0Y2ghJyk7XHJcbiAgICAgICAgICAgICAgICBlbC5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgICAgICBsdyA9IHJsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbDtcclxuICAgIH1cclxuICAgIE1hdHJpeC5pZGVudGl0eSA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdmFyIG0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBtLmVsZW1lbnRzLnB1c2goW10pO1xyXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBtLnNldChpLCBqLCBpID09PSBqID8gbmV3IFN5bWJvbCgxKSA6IG5ldyBTeW1ib2woMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfTtcclxuICAgIE1hdHJpeC5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gRihhcmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRyaXguYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEYucHJvdG90eXBlID0gTWF0cml4LnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBGKGFycik7XHJcbiAgICB9O1xyXG4gICAgTWF0cml4Lnplcm9NYXRyaXggPSBmdW5jdGlvbiAocm93cywgY29scykge1xyXG4gICAgICAgIHZhciBtID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcclxuICAgICAgICAgICAgbS5lbGVtZW50cy5wdXNoKFZlY3Rvci5hcnJheVByZWZpbGwoY29scywgbmV3IFN5bWJvbCgwKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH07XHJcbiAgICBNYXRyaXgucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8vIG5lZWRzIGJlIHRydWUgdG8gbGV0IHRoZSBwYXJzZXIga25vdyBub3QgdG8gdHJ5IHRvIGNhc3QgaXQgdG8gYSBzeW1ib2xcclxuICAgICAgICBjdXN0b206IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAocm93LCBjb2x1bW4pIHtcclxuICAgICAgICAgICAgaWYoIXRoaXMuZWxlbWVudHNbcm93XSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW3Jvd11bY29sdW1uXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1hcDogZnVuY3Rpb24gKGYsIHJhd192YWx1ZXMpIHtcclxuICAgICAgICAgICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoZSwgaSwgaikge1xyXG4gICAgICAgICAgICAgICAgTS5zZXQoaSwgaiwgZi5jYWxsKE0sIGUpLCByYXdfdmFsdWVzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBNO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocm93LCBjb2x1bW4sIHZhbHVlLCByYXcpIHtcclxuICAgICAgICAgICAgaWYoIXRoaXMuZWxlbWVudHNbcm93XSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbcm93XSA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW3Jvd11bY29sdW1uXSA9IHJhdyA/IHZhbHVlIDogKGlzU3ltYm9sKHZhbHVlKSA/IHZhbHVlIDogbmV3IFN5bWJvbCh2YWx1ZSkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29sczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1swXS5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3dzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdzogZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICAgICAgaWYoIW4gfHwgbiA+IHRoaXMuY29scygpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1tuIC0gMV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb2w6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgICAgIHZhciBuciA9IHRoaXMucm93cygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IFtdO1xyXG4gICAgICAgICAgICBpZihuID4gdGhpcy5jb2xzKCkgfHwgIW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbnI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29sLnB1c2godGhpcy5lbGVtZW50c1tpXVtuIC0gMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb2w7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlYWNoRWxlbWVudDogZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgICAgIHZhciBuciA9IHRoaXMucm93cygpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5jID0gdGhpcy5jb2xzKCksIGksIGo7XHJcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IG5yOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IG5jOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHRoaXMsIHRoaXMuZWxlbWVudHNbaV1bal0sIGksIGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBwb3J0ZWQgZnJvbSBTeWx2ZXN0ZXIuanNcclxuICAgICAgICBkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZighdGhpcy5pc1NxdWFyZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgTSA9IHRoaXMudG9SaWdodFRyaWFuZ3VsYXIoKTtcclxuICAgICAgICAgICAgdmFyIGRldCA9IE0uZWxlbWVudHNbMF1bMF0sIG4gPSBNLmVsZW1lbnRzLmxlbmd0aCAtIDEsIGsgPSBuLCBpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBpID0gayAtIG4gKyAxO1xyXG4gICAgICAgICAgICAgICAgZGV0ID0gXy5tdWx0aXBseShkZXQsIE0uZWxlbWVudHNbaV1baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKC0tbik7XHJcbiAgICAgICAgICAgIHJldHVybiBkZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc1NxdWFyZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGggPT09IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNTaW5ndWxhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1NxdWFyZSgpICYmIHRoaXMuZGV0ZXJtaW5hbnQoKSA9PT0gMDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGF1Z21lbnQ6IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5yb3dzKCksIHJyID0gbS5yb3dzKCk7XHJcbiAgICAgICAgICAgIGlmKHIgIT09IHJyKVxyXG4gICAgICAgICAgICAgICAgZXJyKFwiQ2Fubm90IGF1Z21lbnQgbWF0cml4LiBSb3dzIGRvbid0IG1hdGNoLlwiKTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IHRoaXMuZWxlbWVudHNbaV0uY29uY2F0KG0uZWxlbWVudHNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5yb3dzKCksIGMgPSB0aGlzLmNvbHMoKSxcclxuICAgICAgICAgICAgICAgICAgICBtID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBtLmVsZW1lbnRzW2ldID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgYzsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHRoaXMuZWxlbWVudHNbaV1bal07XHJcbiAgICAgICAgICAgICAgICAgICAgbS5lbGVtZW50c1tpXVtqXSA9IGlzU3ltYm9sKHN5bWJvbCkgPyBzeW1ib2wuY2xvbmUoKSA6IHN5bWJvbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIHBvcnRlZCBmcm9tIFN5bHZlc3Rlci5qc1xyXG4gICAgICAgIGludmVydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZighdGhpcy5pc1NxdWFyZSgpKVxyXG4gICAgICAgICAgICAgICAgZXJyKCdNYXRyaXggaXMgbm90IHNxdWFyZSEnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrKCdTQUZFJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5pID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGtpID0gbmksIGksIGo7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW1hdHJpeCA9IE1hdHJpeC5pZGVudGl0eShuaSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgTSA9IHRoaXMuYXVnbWVudChpbWF0cml4KS50b1JpZ2h0VHJpYW5ndWxhcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5wLCBrcCA9IE0uZWxlbWVudHNbMF0ubGVuZ3RoLCBwLCBlbHMsIGRpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJzZV9lbGVtZW50cyA9IFtdLCBuZXdfZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIC8vIE1hdHJpeCBpcyBub24tc2luZ3VsYXIgc28gdGhlcmUgd2lsbCBiZSBubyB6ZXJvcyBvbiB0aGUgZGlhZ29uYWxcclxuICAgICAgICAgICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggcm93cyBmcm9tIGxhc3QgdG8gZmlyc3RcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBpID0gbmkgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0LCBub3JtYWxpc2UgZGlhZ29uYWwgZWxlbWVudHMgdG8gMVxyXG4gICAgICAgICAgICAgICAgICAgIGVscyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5wID0ga3A7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZV9lbGVtZW50c1tpXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdmlzb3IgPSBNLmVsZW1lbnRzW2ldW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19lbGVtZW50ID0gXy5kaXZpZGUoTS5lbGVtZW50c1tpXVtwXSwgZGl2aXNvci5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzLnB1c2gobmV3X2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHVmZmxlIG9mIHRoZSBjdXJyZW50IHJvdyBvZiB0aGUgcmlnaHQgaGFuZCBzaWRlIGludG8gdGhlIHJlc3VsdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgYXMgaXQgd2lsbCBub3QgYmUgbW9kaWZpZWQgYnkgbGF0ZXIgcnVucyB0aHJvdWdoIHRoaXMgbG9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwID49IGtpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlX2VsZW1lbnRzW2ldLnB1c2gobmV3X2VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKC0tbnApO1xyXG4gICAgICAgICAgICAgICAgICAgIE0uZWxlbWVudHNbaV0gPSBlbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgc3VidHJhY3QgdGhpcyByb3cgZnJvbSB0aG9zZSBhYm92ZSBpdCB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdpdmUgdGhlIGlkZW50aXR5IG1hdHJpeCBvbiB0aGUgbGVmdCBoYW5kIHNpZGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IoaiA9IDA7IGogPCBpOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5wID0ga3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzLnB1c2goXy5zdWJ0cmFjdChNLmVsZW1lbnRzW2pdW3BdLmNsb25lKCksIF8ubXVsdGlwbHkoTS5lbGVtZW50c1tpXVtwXS5jbG9uZSgpLCBNLmVsZW1lbnRzW2pdW2ldLmNsb25lKCkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoLS1ucCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE0uZWxlbWVudHNbal0gPSBlbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUoLS1uaSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0cml4LmZyb21BcnJheShpbnZlcnNlX2VsZW1lbnRzKTtcclxuICAgICAgICAgICAgfSwgdW5kZWZpbmVkLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIHBvcnRlZCBmcm9tIFN5bHZlc3Rlci5qc1xyXG4gICAgICAgIHRvUmlnaHRUcmlhbmd1bGFyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9jaygnU0FGRScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBNID0gdGhpcy5jbG9uZSgpLCBlbHMsIGZlbCwgbmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGsgPSBuLCBpLCBucCwga3AgPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCwgcDtcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBpID0gayAtIG47XHJcbiAgICAgICAgICAgICAgICAgICAgZmVsID0gTS5lbGVtZW50c1tpXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZihmZWwudmFsdWVPZigpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWwgPSBNLmVsZW1lbnRzW2pdW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobmVsICYmIG5lbC52YWx1ZU9mKCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBucCA9IGtwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVscy5wdXNoKF8uYWRkKE0uZWxlbWVudHNbaV1bcF0uY2xvbmUoKSwgTS5lbGVtZW50c1tqXVtwXS5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKC0tbnApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE0uZWxlbWVudHNbaV0gPSBlbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZlbCA9IE0uZWxlbWVudHNbaV1baV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmVsLnZhbHVlT2YoKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IF8uZGl2aWRlKE0uZWxlbWVudHNbal1baV0uY2xvbmUoKSwgTS5lbGVtZW50c1tpXVtpXS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVscyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50cyB3aXRoIGNvbHVtbiBudW1iZXJzIHVwIHRvIGFuIGluY2x1ZGluZyB0aGUgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHJvdyB0aGF0IHdlJ3JlIHN1YnRyYWN0aW5nIGNhbiBzYWZlbHkgYmUgc2V0IHN0cmFpZ2h0IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gemVybywgc2luY2UgdGhhdCdzIHRoZSBwb2ludCBvZiB0aGlzIHJvdXRpbmUgYW5kIGl0IGF2b2lkcyBoYXZpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBsb29wIG92ZXIgYW5kIGNvcnJlY3Qgcm91bmRpbmcgZXJyb3JzIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzLnB1c2gocCA8PSBpID8gbmV3IFN5bWJvbCgwKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnN1YnRyYWN0KE0uZWxlbWVudHNbal1bcF0uY2xvbmUoKSwgXy5tdWx0aXBseShNLmVsZW1lbnRzW2ldW3BdLmNsb25lKCksIG11bHRpcGxpZXIuY2xvbmUoKSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKC0tbnApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTS5lbGVtZW50c1tqXSA9IGVscztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlKC0tbik7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE07XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgY29scyA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKSwgbmkgPSBjb2xzLCBpLCBuaiwgajtcclxuXHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGkgPSBjb2xzIC0gbmk7XHJcbiAgICAgICAgICAgICAgICBNLmVsZW1lbnRzW2ldID0gW107XHJcbiAgICAgICAgICAgICAgICBuaiA9IHJvd3M7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgaiA9IHJvd3MgLSBuajtcclxuICAgICAgICAgICAgICAgICAgICBNLmVsZW1lbnRzW2ldW2pdID0gdGhpcy5lbGVtZW50c1tqXVtpXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUoLS1uaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUoLS1uaSk7XHJcbiAgICAgICAgICAgIHJldHVybiBNO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBtYXRyaXggY2FuIG11bHRpcGx5IHRoZSBhcmd1bWVudCBmcm9tIHRoZSBsZWZ0XHJcbiAgICAgICAgY2FuTXVsdGlwbHlGcm9tTGVmdDogZnVuY3Rpb24gKG1hdHJpeCkge1xyXG4gICAgICAgICAgICB2YXIgbCA9IGlzTWF0cml4KG1hdHJpeCkgPyBtYXRyaXguZWxlbWVudHMubGVuZ3RoIDogbWF0cml4Lmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gdGhpcy5jb2x1bW5zIHNob3VsZCBlcXVhbCBtYXRyaXgucm93c1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoID09PSBsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNhbWVTaXplOiBmdW5jdGlvbiAobWF0cml4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd3MoKSA9PT0gbWF0cml4LnJvd3MoKSAmJiB0aGlzLmNvbHMoKSA9PT0gbWF0cml4LmNvbHMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG11bHRpcGx5OiBmdW5jdGlvbiAobWF0cml4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBibG9jaygnU0FGRScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBNID0gbWF0cml4LmVsZW1lbnRzIHx8IG1hdHJpeDtcclxuICAgICAgICAgICAgICAgIGlmKCF0aGlzLmNhbk11bHRpcGx5RnJvbUxlZnQoTSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnNhbWVTaXplKG1hdHJpeCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIE1NID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMucm93cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IF8ubXVsdGlwbHkobmV3IFZlY3Rvcih0aGlzLmVsZW1lbnRzW2ldKSwgbmV3IFZlY3RvcihtYXRyaXguZWxlbWVudHNbaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1NLmVsZW1lbnRzW2ldID0gZS5lbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTU07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG5pID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGtpID0gbmksIGksIG5qLCBraiA9IE1bMF0ubGVuZ3RoLCBqO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbHMgPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCwgZWxlbWVudHMgPSBbXSwgc3VtLCBuYywgYztcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBpID0ga2kgLSBuaTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tpXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5qID0ga2o7XHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqID0ga2ogLSBuajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gbmV3IFN5bWJvbCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmMgPSBjb2xzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gY29scyAtIG5jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gXy5hZGQoc3VtLCBfLm11bHRpcGx5KHRoaXMuZWxlbWVudHNbaV1bY10sIE1bY11bal0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSgtLW5jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbaV1bal0gPSBzdW07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKC0tbmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUoLS1uaSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0cml4LmZyb21BcnJheShlbGVtZW50cyk7XHJcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgdGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChtYXRyaXgsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHZhciBNID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgICAgICBpZih0aGlzLnNhbWVTaXplKG1hdHJpeCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWFjaEVsZW1lbnQoZnVuY3Rpb24gKGUsIGksIGopIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXy5hZGQoZS5jbG9uZSgpLCBtYXRyaXguZWxlbWVudHNbaV1bal0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2suY2FsbChNLCByZXN1bHQsIGUsIG1hdHJpeC5lbGVtZW50c1tpXVtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIE0uc2V0KGksIGosIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHN1YnRyYWN0OiBmdW5jdGlvbiAobWF0cml4LCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICB2YXIgTSA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICAgICAgaWYodGhpcy5zYW1lU2l6ZShtYXRyaXgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2hFbGVtZW50KGZ1bmN0aW9uIChlLCBpLCBqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF8uc3VidHJhY3QoZS5jbG9uZSgpLCBtYXRyaXguZWxlbWVudHNbaV1bal0uY2xvbmUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2suY2FsbChNLCByZXN1bHQsIGUsIG1hdHJpeC5lbGVtZW50c1tpXVtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIE0uc2V0KGksIGosIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gTTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1ZlY3RvcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLnJvd3MoKSA9PT0gMSB8fCB0aGlzLmNvbHMoKSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBuZXcgVmVjdG9yKCk7XHJcbiAgICAgICAgICAgICAgICB2LmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChuZXdsaW5lLCB0b19kZWNpbWFsKSB7XHJcbiAgICAgICAgICAgIHZhciBsID0gdGhpcy5yb3dzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IFtdO1xyXG4gICAgICAgICAgICBuZXdsaW5lID0gbmV3bGluZSA9PT0gdW5kZWZpbmVkID8gJ1xcbicgOiBuZXdsaW5lO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzLnB1c2goJ1snICsgdGhpcy5lbGVtZW50c1tpXS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRvX2RlY2ltYWwgPyB4Lm11bHRpcGxpZXIudG9EZWNpbWFsKCkgOiB4LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggIT09IHVuZGVmaW5lZCA/IHYgOiAnJztcclxuICAgICAgICAgICAgICAgIH0pLmpvaW4oJywnKSArICddJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICdtYXRyaXgnICsgaW5CcmFja2V0cyhzLmpvaW4oJywnKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbWF0cml4KCcgKyB0aGlzLmVsZW1lbnRzLnRvU3RyaW5nKCcnKSArICcpJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhdGV4OiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2xzID0gdGhpcy5jb2xzKCksIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCgnXFxcXGJlZ2lue3ZtYXRyaXh9ezB9XFxcXGVuZHt2bWF0cml4fScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXggPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgcm93IGluIGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd190ZXggPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd190ZXgucHVzaChMYVRlWC5sYXRleC5jYWxsKExhVGVYLCBlbGVtZW50c1tyb3ddW2ldLCBvcHRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4LnB1c2gocm93X3RleC5qb2luKCcgJiAnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4LmpvaW4oJyBcXFxcY3IgJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBhbGlhc2VzXHJcbiAgICBNYXRyaXgucHJvdG90eXBlLmVhY2ggPSBNYXRyaXgucHJvdG90eXBlLmVhY2hFbGVtZW50O1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBTZXQoc2V0KSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBvYmplY3QgaXNuJ3QgYW4gYXJyYXksIGNvbnZlcnQgaXQgdG8gb25lLlxyXG4gICAgICAgIGlmKCFpc1ZlY3RvcihzZXQpKVxyXG4gICAgICAgICAgICBzZXQgPSBWZWN0b3IuZnJvbUFycmF5KGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIGlmKHNldCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBzZXQuZWxlbWVudHM7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgIGZ1bmN0aW9uIEYoYXJncykge1xyXG4gICAgICAgICAgICByZXR1cm4gU2V0LmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBGLnByb3RvdHlwZSA9IFNldC5wcm90b3R5cGU7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgRihhcnIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTZXQucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgaWYoIXRoaXMuY29udGFpbnMoeCkpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2goeC5jbG9uZSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoeC5lcXVhbHMoZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGYuY2FsbCh0aGlzLCBlLCBzZXQsIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIHNldC5hZGQoZS5jbG9uZSgpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bmlvbjogZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICB2YXIgX3VuaW9uID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgICAgICBzZXQuZWFjaChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgX3VuaW9uLmFkZChlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX3VuaW9uO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlmZmVyZW5jZTogZnVuY3Rpb24gKHNldCkge1xyXG4gICAgICAgICAgICB2YXIgZGlmZiA9IHRoaXMuY2xvbmUoKTtcclxuICAgICAgICAgICAgc2V0LmVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGRpZmYucmVtb3ZlKGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoZS5lcXVhbHMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUodGhpcy5lbGVtZW50cywgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfaW50ZXJzZWN0aW9uID0gbmV3IFNldCgpO1xyXG4gICAgICAgICAgICB2YXIgQSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHNldC5lYWNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZihBLmNvbnRhaW5zKGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ludGVyc2VjdGlvbi5hZGQoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIF9pbnRlcnNlY3Rpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbiAoc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdGlvbihzZXQpLmVsZW1lbnRzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc19zdWJzZXQ6IGZ1bmN0aW9uIChzZXQpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gc2V0LmVsZW1lbnRzO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZighdGhpcy5jb250YWlucyhlbGVtZW50c1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3snICsgdGhpcy5lbGVtZW50cy5qb2luKCcsJykgKyAnfSc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbi8vYnVpbGQgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICB2YXIgQnVpbGQgPSB7XHJcbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7XHJcbiAgICAgICAgICAgIF9yZW5hbWU6IHtcclxuICAgICAgICAgICAgICAgICdNYXRoMi5mYWN0b3JpYWwnOiAnZmFjdG9yaWFsJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmYWN0b3JpYWw6IHtcclxuICAgICAgICAgICAgICAgICdNYXRoMi5nYW1tYSc6IE1hdGgyLmdhbW1hXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdhbW1hX2luY29tcGxldGU6IHtcclxuICAgICAgICAgICAgICAgICdNYXRoMi5mYWN0b3JpYWwnOiBNYXRoMi5mYWN0b3JpYWxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgTGk6IHtcclxuICAgICAgICAgICAgICAgICdNYXRoMi5FaSc6IE1hdGgyLkVpLFxyXG4gICAgICAgICAgICAgICAgJ01hdGgyLmJpZ0xvZyc6IE1hdGgyLmJpZ0xvZyxcclxuICAgICAgICAgICAgICAgICdGcmFjJzogRnJhY1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBDaToge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLmZhY3RvcmlhbCc6IE1hdGgyLmZhY3RvcmlhbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBFaToge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLmZhY3RvcmlhbCc6IE1hdGgyLmZhY3RvcmlhbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBTaToge1xyXG4gICAgICAgICAgICAgICAgJ01hdGgyLmZhY3RvcmlhbCc6IE1hdGgyLmZhY3RvcmlhbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBTaGk6IHtcclxuICAgICAgICAgICAgICAgICdNYXRoMi5mYWN0b3JpYWwnOiBNYXRoMi5mYWN0b3JpYWxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgQ2hpOiB7XHJcbiAgICAgICAgICAgICAgICAnaXNJbnQnOiBpc0ludCxcclxuICAgICAgICAgICAgICAgICducm91bmQnOiBucm91bmQsXHJcbiAgICAgICAgICAgICAgICAnTWF0aDIubnVtX2ludGVncmF0ZSc6IE1hdGgyLm51bV9pbnRlZ3JhdGVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmFjdG9yOiB7XHJcbiAgICAgICAgICAgICAgICAnTWF0aDIuaWZhY3Rvcic6IE1hdGgyLmlmYWN0b3IsXHJcbiAgICAgICAgICAgICAgICAnU3ltYm9sJzogU3ltYm9sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG51bV9pbnRlZ3JhdGU6IHtcclxuICAgICAgICAgICAgICAgICdNYXRoMi5zaW1wc29uJzogTWF0aDIuc2ltcHNvbixcclxuICAgICAgICAgICAgICAgICducm91bmQnOiBucm91bmRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZmliOiB7XHJcbiAgICAgICAgICAgICAgICAnZXZlbic6IGV2ZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyogU29tZSBmdW5jdGlvbnMgbmVlZCB0byBiZSBtYWRlIG51bWVyaWMgc2FmZS4gQnVpbGQgY2hlY2tzIGlmIHRoZXJlJ3MgYVxyXG4gICAgICAgICAqIHJlZm9ybWF0IG9wdGlvbiBhbmQgY2FsbHMgdGhhdCBpbnN0ZWFkIHdoZW4gY29tcGlsaW5nIHRoZSBmdW5jdGlvbiBzdHJpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVmb3JtYXQ6IHtcclxuICAgICAgICAgICAgLy8gdGhpcyBzaW1wbHkgZXh0ZW5kcyB0aGUgYnVpbGQgZnVuY3Rpb25cclxuICAgICAgICAgICAgZGlmZjogZnVuY3Rpb24gKHN5bWJvbCwgZGVwcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHYgPSBzeW1ib2wuYXJnc1sxXS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGYgPSAndmFyIGYgPSAnICsgQnVpbGQuYnVpbGQoc3ltYm9sLmFyZ3NbMF0udG9TdHJpbmcoKSwgW3ZdKSArICc7JztcclxuICAgICAgICAgICAgICAgIGRlcHNbMV0gKz0gJ3ZhciBkaWZmID0gJyArIE1hdGgyLmRpZmYudG9TdHJpbmcoKSArICc7JztcclxuICAgICAgICAgICAgICAgIGRlcHNbMV0gKz0gZjtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkaWZmKGYpKCcgKyB2ICsgJyknLCBkZXBzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0UHJvcGVyTmFtZTogZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICAgICAgdmFyIG1hcCA9IHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlZF9mcmFjdGlvbjogJ2NvbnRpbnVlZEZyYWN0aW9uJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwW2ZdIHx8IGY7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBhc3N1bWVzIHRoYXQgZGVwZW5kZW5jZXMgYXJlIGF0IG1heCAyIGxldmVsc1xyXG4gICAgICAgIGNvbXBpbGVEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uIChmLCBkZXBzKSB7XHJcbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIHByZWRlZmluZWQgZGVwZW5kaWVuY2VzXHJcbiAgICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBCdWlsZC5kZXBlbmRlbmNpZXNbZl07XHJcblxyXG4gICAgICAgICAgICAvLyB0aGUgZGVwZW5kZW5jeSBzdHJpbmdcclxuICAgICAgICAgICAgdmFyIGRlcF9zdHJpbmcgPSBkZXBzICYmIGRlcHNbMV0gPyBkZXBzWzFdIDogJyc7XHJcblxyXG4gICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb25zIHRvIGJlIHJlcGxhY2VkXHJcbiAgICAgICAgICAgIHZhciByZXBsYWNlbWVudHMgPSBkZXBzICYmIGRlcHNbMF0gPyBkZXBzWzBdIDoge307XHJcblxyXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlbSBhbmQgYWRkIHRoZW0gdG8gdGhlIGxpc3RcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlcGVuZGVuY2llc1t4XSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IHguc3BsaXQoJy4nKTsgLy9NYXRoLmYgYmVjb21lcyBmXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZnVuY3Rpb24gaXNuJ3QgcGFydCBvZiBhbiBvYmplY3QgdGhlbiByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgZGVwX3N0cmluZyArPSAndmFyICcgKyAoY29tcG9uZW50cy5sZW5ndGggPiAxID8gY29tcG9uZW50c1sxXSA6IGNvbXBvbmVudHNbMF0pICsgJz0nICsgZGVwZW5kZW5jaWVzW3hdICsgJzsnO1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzW3hdID0gY29tcG9uZW50cy5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtyZXBsYWNlbWVudHMsIGRlcF9zdHJpbmddO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0QXJnc0RlcHM6IGZ1bmN0aW9uIChzeW1ib2wsIGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHN5bWJvbC5hcmdzO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sLmFyZ3NbaV0uZWFjaChmdW5jdGlvbiAoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHguZ3JvdXAgPT09IEZOKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBCdWlsZC5jb21waWxlRGVwZW5kZW5jaWVzKHguZm5hbWUsIGRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYnVpbGQ6IGZ1bmN0aW9uIChzeW1ib2wsIGFyZ19hcnJheSkge1xyXG4gICAgICAgICAgICBzeW1ib2wgPSBibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2Uoc3ltYm9sKTtcclxuICAgICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gdmFyaWFibGVzKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIHZhciBzdXBwbGVtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBmdGV4dCA9IGZ1bmN0aW9uIChzeW1ib2wsIHhwb3J0cykge1xyXG4gICAgICAgICAgICAgICAgLy9GaXggZm9yICM1NDUgLSBQYXJlbnRoZXNlcyBjb25mdXNlIGJ1aWxkLlxyXG4gICAgICAgICAgICAgICAgaWYoc3ltYm9sLmZuYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IFN5bWJvbC51bndyYXBQQVJFTlMoc3ltYm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHhwb3J0cyA9IHhwb3J0cyB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBjID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gc3ltYm9sLmdyb3VwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSAnJztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZnRleHRfY29tcGxleCA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gZ3JvdXAgPT09IENCID8gJyonIDogJysnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4IGluIHN5bWJvbC5zeW1ib2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBzeW1ib2wuc3ltYm9sc1t4XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdCA9IGZ0ZXh0KHN5bSwgeHBvcnRzKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd3JhcCBpdCBpbiBicmFja2V0cyBpZiBpdCdzIGdyb3VwIFBMIG9yIENQXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN5bS5pc0NvbXBvc2l0ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnQgPSBpbkJyYWNrZXRzKGZ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MucHVzaChmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR2YWwgPSBjYy5qb2luKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbCAmJiAhc3ltYm9sLm11bHRpcGxpZXIuZXF1YWxzKDEpID8gaW5CcmFja2V0cyhyZXR2YWwpIDogcmV0dmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdGV4dF9mdW5jdGlvbiA9IGZ1bmN0aW9uIChibikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGJuIGluIE1hdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dmFsID0gJ01hdGguJyArIGJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm4gPSBCdWlsZC5nZXRQcm9wZXJOYW1lKGJuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihzdXBwbGVtZW50cy5pbmRleE9mKGJuKSA9PT0gLTEpIHsgLy8gbWFrZSBzdXJlIHlvdSdyZSBub3QgYWRkaW5nIHRoZSBmdW5jdGlvbiB0d2ljZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL01hdGgyIGZ1bmN0aW9ucyBhcmVuJ3QgcGFydCBvZiB0aGUgc3RhbmRhcmQgamF2YXNjcmlwdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL01hdGggbGlicmFyeSBhbmQgbXVzdCBiZSBleHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeHBvcnRzLnB1c2goJ3ZhciAnICsgYm4gKyAnID0gJyArIE1hdGgyW2JuXS50b1N0cmluZygpICsgJzsgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBsZW1lbnRzLnB1c2goYm4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR2YWwgPSBibjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHZhbCA9IHJldHZhbCArIGluQnJhY2tldHMoc3ltYm9sLmFyZ3MubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ0ZXh0KHgsIHhwb3J0cylbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCcsJykpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIG11bHRpcGxpZXJcclxuICAgICAgICAgICAgICAgIGlmKGdyb3VwID09PSBOKVxyXG4gICAgICAgICAgICAgICAgICAgIGMucHVzaChzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHN5bWJvbC5tdWx0aXBsaWVyLmVxdWFscygtMSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gJy0nO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZighc3ltYm9sLm11bHRpcGxpZXIuZXF1YWxzKDEpKVxyXG4gICAgICAgICAgICAgICAgICAgIGMucHVzaChzeW1ib2wubXVsdGlwbGllci50b0RlY2ltYWwoKSk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWVcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihncm91cCA9PT0gUyB8fCBncm91cCA9PT0gUClcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN5bWJvbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoZ3JvdXAgPT09IEZOKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gQnVpbGQuY29tcGlsZURlcGVuZGVuY2llcyhzeW1ib2wuZm5hbWUsIGRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gQnVpbGQuZ2V0QXJnc0RlcHMoc3ltYm9sLCBkZXBlbmRlbmNpZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKEJ1aWxkLnJlZm9ybWF0W3N5bWJvbC5mbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBCdWlsZC5yZWZvcm1hdFtzeW1ib2wuZm5hbWVdKHN5bWJvbCwgZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gY29tcG9uZW50c1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb21wb25lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmdGV4dF9mdW5jdGlvbihzeW1ib2wuZm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGdyb3VwID09PSBFWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZyA9IHN5bWJvbC5wcmV2aW91c0dyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHBnID09PSBOIHx8IHBnID09PSBTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN5bWJvbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHBnID09PSBGTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZ0ZXh0X2Z1bmN0aW9uKHN5bWJvbC5mbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IEJ1aWxkLmNvbXBpbGVEZXBlbmRlbmNpZXMoc3ltYm9sLmZuYW1lLCBkZXBlbmRlbmNpZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBCdWlsZC5nZXRBcmdzRGVwcyhzeW1ib2wsIGRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmdGV4dF9jb21wbGV4KHN5bWJvbC5wcmV2aW91c0dyb3VwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZnRleHRfY29tcGxleChzeW1ib2wuZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKHN5bWJvbC5ncm91cCAhPT0gTiAmJiAhc3ltYm9sLnBvd2VyLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3cgPSBmdGV4dChfLnBhcnNlKHN5bWJvbC5wb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhwb3J0cy5wdXNoKHBvd1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnTWF0aC5wb3cnICsgaW5CcmFja2V0cyh2YWx1ZSArICcsJyArIHBvd1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgYy5wdXNoKHByZWZpeCArIHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Muam9pbignKicpLCB4cG9ydHMuam9pbignJykucmVwbGFjZSgvXFxuK1xccysvZywgJyAnKV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmKGFyZ19hcnJheSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRml4IGZvciBpc3N1ZSAjNTQ2XHJcbiAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIGFyZ3VtZW50IGNoZWNraW5nIHNpbmNlIGl0J3MgYSBiaXQgcHJlc3VtcHR1b3VzLlxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgZih4KSA9IDU7IElmIEkgZXhwbGljaXRlbHkgcGFzcyBpbiBhbiBhcmd1bWVudCBhcnJheSBjb250YWluIHggXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoZWNrIHdpbGwgZmFpbCBhbmQgY29tcGxhaW4gc2luY2UgdGhlIGZ1bmN0aW9uIGRvZXNuJ3QgY29udGFpbiB4LlxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTtcclxuICAgICAgICAgICAgICAgICBpZiAoYXJnX2FycmF5LmluZGV4T2YoYXJnKSA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgZXJyKGFyZyArICcgbm90IGZvdW5kIGluIGFyZ3VtZW50IGFycmF5Jyk7XHJcbiAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJnX2FycmF5O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgZl9hcnJheSA9IGZ0ZXh0KHN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBtYWtlIGFsbCB0aGUgc3Vic3RpdHV0aW9ucztcclxuICAgICAgICAgICAgZm9yKHZhciB4IGluIGRlcGVuZGVuY2llc1swXSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFsaWFzID0gZGVwZW5kZW5jaWVzWzBdW3hdO1xyXG4gICAgICAgICAgICAgICAgZl9hcnJheVsxXSA9IGZfYXJyYXlbMV0ucmVwbGFjZSh4LCBhbGlhcyk7XHJcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXNbMV0gPSBkZXBlbmRlbmNpZXNbMV0ucmVwbGFjZSh4LCBhbGlhcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBmID0gbmV3IEZ1bmN0aW9uKGFyZ3MsIChkZXBlbmRlbmNpZXNbMV0gfHwgJycpICsgZl9hcnJheVsxXSArICcgcmV0dXJuICcgKyBmX2FycmF5WzBdICsgJzsnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuLy9maW5hbGl6ZSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8qIEZJTkFMSVpFICovXHJcbiAgICAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJlc2VydmVOYW1lcyhfLkNPTlNUQU5UUyk7XHJcbiAgICAgICAgcmVzZXJ2ZU5hbWVzKF8uZnVuY3Rpb25zKTtcclxuICAgICAgICBfLmluaXRDb25zdGFudHMoKTtcclxuICAgICAgICAvL2J1ZyBmaXggZm9yIGVycm9yIGJ1dCBuZWVkcyB0byBiZSByZXZpc2l0ZWRcclxuICAgICAgICBpZighXy5lcnJvcilcclxuICAgICAgICAgICAgXy5lcnJvciA9IGVycjtcclxuXHJcbiAgICAgICAgLy9TdG9yZSB0aGUgbG9nIGFuZCBsb2cxMCBmdW5jdGlvbnNcclxuICAgICAgICBTZXR0aW5ncy5MT0dfRk5TID0ge1xyXG4gICAgICAgICAgICBsb2c6IF8uZnVuY3Rpb25zWydsb2cnXSxcclxuICAgICAgICAgICAgbG9nMTA6IF8uZnVuY3Rpb25zWydsb2cxMCddXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8qIEVORCBGSU5BTElaRSAqL1xyXG5cclxuLy9Db3JlID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIHZhciBVdGlscyA9IHtcclxuICAgICAgICBhbGxTYW1lOiBhbGxTYW1lLFxyXG4gICAgICAgIGFsbE51bWVyaWM6IGFsbE51bWVyaWMsXHJcbiAgICAgICAgYXJndW1lbnRzMkFycmF5OiBhcmd1bWVudHMyQXJyYXksXHJcbiAgICAgICAgYXJyYXlBZGRTbGljZXM6IGFycmF5QWRkU2xpY2VzLFxyXG4gICAgICAgIGFycmF5Q2xvbmU6IGFycmF5Q2xvbmUsXHJcbiAgICAgICAgYXJyYXlNYXg6IGFycmF5TWF4LFxyXG4gICAgICAgIGFycmF5TWluOiBhcnJheU1pbixcclxuICAgICAgICBhcnJheUVxdWFsOiBhcnJheUVxdWFsLFxyXG4gICAgICAgIGFycmF5VW5pcXVlOiBhcnJheVVuaXF1ZSxcclxuICAgICAgICBhcnJheUdldFZhcmlhYmxlczogYXJyYXlHZXRWYXJpYWJsZXMsXHJcbiAgICAgICAgYXJyYXlTdW06IGFycmF5U3VtLFxyXG4gICAgICAgIGJsb2NrOiBibG9jayxcclxuICAgICAgICBidWlsZDogQnVpbGQuYnVpbGQsXHJcbiAgICAgICAgY2xlYXJVOiBjbGVhclUsXHJcbiAgICAgICAgY29tYm9Tb3J0OiBjb21ib1NvcnQsXHJcbiAgICAgICAgY29tcGFyZTogY29tcGFyZSxcclxuICAgICAgICBjb252ZXJ0VG9WZWN0b3I6IGNvbnZlcnRUb1ZlY3RvcixcclxuICAgICAgICBjdXN0b21FcnJvcjogY3VzdG9tRXJyb3IsXHJcbiAgICAgICAgY3VzdG9tVHlwZTogY3VzdG9tVHlwZSxcclxuICAgICAgICBkZWNvbXBvc2VfZm46IGRlY29tcG9zZV9mbixcclxuICAgICAgICBlYWNoOiBlYWNoLFxyXG4gICAgICAgIGV2YWx1YXRlOiBldmFsdWF0ZSxcclxuICAgICAgICBldmVuOiBldmVuLFxyXG4gICAgICAgIGV2ZW5GcmFjdGlvbjogZXZlbkZyYWN0aW9uLFxyXG4gICAgICAgIGZpbGxIb2xlczogZmlsbEhvbGVzLFxyXG4gICAgICAgIGZpcnN0T2JqZWN0OiBmaXJzdE9iamVjdCxcclxuICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcclxuICAgICAgICBnZW5lcmF0ZVByaW1lczogZ2VuZXJhdGVQcmltZXMsXHJcbiAgICAgICAgZ2V0Q29lZmZzOiBnZXRDb2VmZnMsXHJcbiAgICAgICAgZ2V0VTogZ2V0VSxcclxuICAgICAgICBpbXBvcnRGdW5jdGlvbnM6IGltcG9ydEZ1bmN0aW9ucyxcclxuICAgICAgICBpbkJyYWNrZXRzOiBpbkJyYWNrZXRzLFxyXG4gICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXHJcbiAgICAgICAgaXNFeHByZXNzaW9uOiBpc0V4cHJlc3Npb24sXHJcbiAgICAgICAgaXNGcmFjdGlvbjogaXNGcmFjdGlvbixcclxuICAgICAgICBpc0ludDogaXNJbnQsXHJcbiAgICAgICAgaXNNYXRyaXg6IGlzTWF0cml4LFxyXG4gICAgICAgIGlzTmVnYXRpdmU6IGlzTmVnYXRpdmUsXHJcbiAgICAgICAgaXNOdW1lcmljU3ltYm9sOiBpc051bWVyaWNTeW1ib2wsXHJcbiAgICAgICAgaXNQcmltZTogaXNQcmltZSxcclxuICAgICAgICBpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxyXG4gICAgICAgIGlzU3ltYm9sOiBpc1N5bWJvbCxcclxuICAgICAgICBpc1ZhcmlhYmxlU3ltYm9sOiBpc1ZhcmlhYmxlU3ltYm9sLFxyXG4gICAgICAgIGlzVmVjdG9yOiBpc1ZlY3RvcixcclxuICAgICAgICBrZXlzOiBrZXlzLFxyXG4gICAgICAgIGtub3duVmFyaWFibGU6IGtub3duVmFyaWFibGUsXHJcbiAgICAgICAgbnJvb3RzOiBucm9vdHMsXHJcbiAgICAgICAgcmVtb3ZlOiByZW1vdmUsXHJcbiAgICAgICAgcmVzZXJ2ZU5hbWVzOiByZXNlcnZlTmFtZXMsXHJcbiAgICAgICAgcmFuZ2U6IHJhbmdlLFxyXG4gICAgICAgIHJvdW5kOiBucm91bmQsXHJcbiAgICAgICAgc2FtZVNpZ246IHNhbWVTaWduLFxyXG4gICAgICAgIHNjaWVudGlmaWNUb0RlY2ltYWw6IHNjaWVudGlmaWNUb0RlY2ltYWwsXHJcbiAgICAgICAgc2VwYXJhdGU6IHNlcGFyYXRlLFxyXG4gICAgICAgIHN0cmluZ1JlcGxhY2U6IHN0cmluZ1JlcGxhY2UsXHJcbiAgICAgICAgdGV4dDogdGV4dCxcclxuICAgICAgICB2YWxpZGF0ZU5hbWU6IHZhbGlkYXRlTmFtZSxcclxuICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcclxuICAgICAgICB3YXJuOiB3YXJuXHJcbiAgICB9O1xyXG5cclxuICAgIC8vVGhpcyBjb250YWlucyBhbGwgdGhlIHBhcnRzIG9mIG5lcmRhbWVyIGFuZCBlbmFibGVzIG5lcmRhbWVyJ3MgaW50ZXJuYWwgZnVuY3Rpb25zXHJcbiAgICAvL3RvIGJlIHVzZWQuXHJcbiAgICB2YXIgQyA9IHtcclxuICAgICAgICBncm91cHM6IEdyb3VwcyxcclxuICAgICAgICBTeW1ib2w6IFN5bWJvbCxcclxuICAgICAgICBFeHByZXNzaW9uOiBFeHByZXNzaW9uLFxyXG4gICAgICAgIEZyYWM6IEZyYWMsXHJcbiAgICAgICAgVmVjdG9yOiBWZWN0b3IsXHJcbiAgICAgICAgTWF0cml4OiBNYXRyaXgsXHJcbiAgICAgICAgUGFyc2VyOiBQYXJzZXIsXHJcbiAgICAgICAgU2NpZW50aWZpYzogU2NpZW50aWZpYyxcclxuICAgICAgICBGcmFjdGlvbjogRnJhY3Rpb24sXHJcbiAgICAgICAgTWF0aDI6IE1hdGgyLFxyXG4gICAgICAgIExhVGVYOiBMYVRlWCxcclxuICAgICAgICBVdGlsczogVXRpbHMsXHJcbiAgICAgICAgUEFSU0VSOiBfLFxyXG4gICAgICAgIFBBUkVOVEhFU0lTOiBQQVJFTlRIRVNJUyxcclxuICAgICAgICBTZXR0aW5nczogU2V0dGluZ3MsXHJcbiAgICAgICAgZXJyOiBlcnIsXHJcbiAgICAgICAgYmlnSW50OiBiaWdJbnQsXHJcbiAgICAgICAgYmlnRGVjOiBiaWdEZWMsXHJcbiAgICAgICAgZXhjZXB0aW9uczogZXhjZXB0aW9uc1xyXG4gICAgfTtcclxuXHJcbi8vbGliRXhwb3J0cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiB0aGUgZXhwcmVzc2lvbiB0byBiZSBldmFsdWF0ZWRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzIHRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgdmFyaWFibGUgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGxvY2F0aW9uIGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGVxdWF0aW9uIGxpc3QgdG9cclxuICAgICAqIGluc2VydCB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb25cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gYWRkaXRpb25hbCBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7RXhwcmVzc2lvbn1cclxuICAgICAqL1xyXG4gICAgdmFyIGxpYkV4cG9ydHMgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgc3Vicywgb3B0aW9uLCBsb2NhdGlvbikge1xyXG4gICAgICAgIC8vIEluaXRpYXRlIHRoZSBudW1lciBmbGFnXHJcbiAgICAgICAgdmFyIG51bWVyID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIElzIHRoZSB1c2VyIGRlY2xhcmluZyBhIGZ1bmN0aW9uP1xyXG4gICAgICAgIHZhciBmbmRlYyA9IC9eKFthLXpfXVthLXpcXGRcXF9dKilcXCgoW2Etel8sXFxzXSopXFwpOj0oLispJC9naS5leGVjKGV4cHJlc3Npb24pO1xyXG4gICAgICAgIGlmKGZuZGVjKVxyXG4gICAgICAgICAgICByZXR1cm4gbmVyZGFtZXIuc2V0RnVuY3Rpb24oZm5kZWNbMV0sIGZuZGVjWzJdLnNwbGl0KCcsJyksIGZuZGVjWzNdKTtcclxuXHJcbiAgICAgICAgLy8gdmFyIHZhcmlhYmxlLCBmbiwgYXJncztcclxuICAgICAgICAvLyBDb252ZXJ0IGFueSBleHByZXNzaW9uIHBhc3NlZCBpbiB0byBhIHN0cmluZ1xyXG4gICAgICAgIGlmKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBFeHByZXNzaW9uKVxyXG4gICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGl0IHRvIGFuIGFycmF5IGZvciBzaW1wbGljaXR5XHJcbiAgICAgICAgaWYoIWlzQXJyYXkob3B0aW9uKSkge1xyXG4gICAgICAgICAgICBvcHRpb24gPSB0eXBlb2Ygb3B0aW9uID09PSAndW5kZWZpbmVkJyA/IFtdIDogW29wdGlvbl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcHRpb24uZm9yRWFjaChmdW5jdGlvbiAobykge1xyXG4gICAgICAgICAgICAvLyBUdXJuIG9uIHRoZSBudW1lciBmbGFnIGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICBpZihvID09PSAnbnVtZXInKSB7XHJcbiAgICAgICAgICAgICAgICBudW1lciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV3JhcCBpdCBpbiBhIGZ1bmN0aW9uIGlmIHJlcXVlc3RlZC4gVGhpcyBvbmx5IGhvbGRzIHRydWUgZm9yXHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyB0aGF0IHRha2UgYSBzaW5nbGUgYXJndW1lbnQgd2hpY2ggaXMgdGhlIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgdmFyIGYgPSBfLmZ1bmN0aW9uc1tvcHRpb25dO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgZnVuY3Rpb24gYW5kIGl0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50LCB0aGVuIHdyYXBcclxuICAgICAgICAgICAgLy8gdGhlIGV4cHJlc3Npb24gaW4gaXRcclxuICAgICAgICAgICAgaWYoZiAmJiBmWzFdID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gYCR7b30oJHtleHByZXNzaW9ufSlgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHZhciBlID0gYmxvY2soJ1BBUlNFMk5VTUJFUicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF8ucGFyc2UoZXhwcmVzc2lvbiwgc3Vicyk7XHJcbiAgICAgICAgfSwgbnVtZXIgfHwgU2V0dGluZ3MuUEFSU0UyTlVNQkVSKTtcclxuXHJcbiAgICAgICAgaWYobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgRVhQUkVTU0lPTlNbbG9jYXRpb24gLSAxXSA9IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBFWFBSRVNTSU9OUy5wdXNoKGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgZXhwcmVzc2lvbiBpbnRvIHJwbiBmb3JtXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxyXG4gICAgICogQHJldHVybnMge1Rva2VuW119XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMucnBuID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcclxuICAgICAgICByZXR1cm4gXy50b2tlbml6ZShfLnRvUlBOKGV4cHJlc3Npb24pKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgTGFUZVggZnJvbSBleHByZXNzaW9uIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuY29udmVydFRvTGFUZVggPSBmdW5jdGlvbiAoZSwgb3B0KSB7XHJcbiAgICAgICAgcmV0dXJuIF8udG9UZVgoZSwgb3B0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBsYXRleCB0byB0ZXh0IC0gVmVyeSB2ZXJ5IHZlcnkgYmFzaWMgYXQgdGhlIG1vbWVudFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuY29udmVydEZyb21MYVRlWCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgdmFyIHR4dCA9IExhVGVYLnBhcnNlKF8udG9rZW5pemUoZSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihfLnBhcnNlKHR4dCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdmVyc2lvbiBvZiBuZXJkYW1lciBvciBhIGxvYWRlZCBhZGQtb25cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRfb24gLSBUaGUgYWRkLW9uIGJlaW5nIGNoZWNrZWRcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHJldHVybnMgdGhlIHZlcnNpb24gb2YgbmVyZGFtZXJcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy52ZXJzaW9uID0gZnVuY3Rpb24gKGFkZF9vbikge1xyXG4gICAgICAgIGlmKGFkZF9vbikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENbYWRkX29uXS52ZXJzaW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIG1vZHVsZSBuYW1lZCBcIiArIGFkZF9vbiArIFwiIGZvdW5kIVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZXJzaW9uO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBuZXJkYW1lciBnZW5lcmF0ZWQgd2FybmluZ3NcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5nZXRXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gV0FSTklOR1M7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb25zdGFudCBUaGUgbmFtZSBvZiB0aGUgY29uc3RhbnQgdG8gYmUgc2V0XHJcbiAgICAgKiBAcGFyYW0ge21peGVkfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGNvbnN0YW50XHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXJkYW1lciBvYmplY3RcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5zZXRDb25zdGFudCA9IGZ1bmN0aW9uIChjb25zdGFudCwgdmFsdWUpIHtcclxuICAgICAgICB2YWxpZGF0ZU5hbWUoY29uc3RhbnQpO1xyXG4gICAgICAgIGlmKCFpc1Jlc2VydmVkKGNvbnN0YW50KSkge1xyXG4gICAgICAgICAgICAvL2ZpeCBmb3IgaXNzdWUgIzEyN1xyXG4gICAgICAgICAgICBpZih2YWx1ZSA9PT0gJ2RlbGV0ZScgfHwgdmFsdWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgXy5DT05TVEFOVFNbY29uc3RhbnRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOZXJkYW1lclR5cGVFcnJvcignQ29uc3RhbnQgbXVzdCBiZSBhIG51bWJlciEnKTtcclxuICAgICAgICAgICAgICAgIF8uQ09OU1RBTlRTW2NvbnN0YW50XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgcHJldmlvdXNseSBzZXQgY29uc3RhbnRcclxuICAgICAqIEBwYXJhbSB7dHlwZX0gY29uc3RhbnRcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuZ2V0Q29uc3RhbnQgPSBmdW5jdGlvbiAoY29uc3RhbnQpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKF8uY29uc3RhbnRbY29uc3RhbnRdKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNfYXJyYXkgQSBsaXN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlciBuYW1lIG9mIHRoZSBmdW5jdGlvbnNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBib2R5IFRoZSBib2R5IG9mIHRoZSBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiBzdWNjZWVkZWQgYW5kIGZhbGxzIG9uIGZhaWxcclxuICAgICAqIEBleGFtcGxlIG5lcmRhbWVyLnNldEZ1bmN0aW9uKCdmJyxbJ3gnXSwgJ3heMisyJyk7XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuc2V0RnVuY3Rpb24gPSBzZXRGdW5jdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Q30gRXhwb3J0cyB0aGUgbmVyZGFtZXIgY29yZSBmdW5jdGlvbnMgYW5kIG9iamVjdHNcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5nZXRDb3JlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBDO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLmdldEV4cHJlc3Npb24gPSBsaWJFeHBvcnRzLmdldEVxdWF0aW9uID0gRXhwcmVzc2lvbi5nZXRFeHByZXNzaW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNBcnJheSBUaGUgcmV0dXJuZWQgbmFtZXMgYXJlIHJldHVybmVkIGFzIGFuIGFycmF5IGlmIHRoaXMgaXMgc2V0IHRvIHRydWU7XHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfEFycmF5fVxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLnJlc2VydmVkID0gZnVuY3Rpb24gKGFzQXJyYXkpIHtcclxuICAgICAgICBpZihhc0FycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSRVNFUlZFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJFU0VSVkVELmpvaW4oJywgJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZXF1YXRpb25fbnVtYmVyIHRoZSBudW1iZXIgb2YgdGhlIGVxdWF0aW9uIHRvIGNsZWFyLlxyXG4gICAgICogSWYgJ2FsbCcgaXMgc3VwcGxpZWQgdGhlbiBhbGwgZXF1YXRpb25zIGFyZSBjbGVhcmVkXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGtlZXBfRVhQUkVTU0lPTlNfZml4ZWQgdXNlIHRydWUgaWYgeW91IGRvbid0IHdhbnQgdG8ga2VlcCBFWFBSRVNTSU9OUyBsZW5ndGggZml4ZWRcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5lcmRhbWVyIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gKGVxdWF0aW9uX251bWJlciwga2VlcF9FWFBSRVNTSU9OU19maXhlZCkge1xyXG4gICAgICAgIGlmKGVxdWF0aW9uX251bWJlciA9PT0gJ2FsbCcpIHtcclxuICAgICAgICAgICAgRVhQUkVTU0lPTlMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihlcXVhdGlvbl9udW1iZXIgPT09ICdsYXN0Jykge1xyXG4gICAgICAgICAgICBFWFBSRVNTSU9OUy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihlcXVhdGlvbl9udW1iZXIgPT09ICdmaXJzdCcpIHtcclxuICAgICAgICAgICAgRVhQUkVTU0lPTlMuc2hpZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9ICFlcXVhdGlvbl9udW1iZXIgPyBFWFBSRVNTSU9OUy5sZW5ndGggOiBlcXVhdGlvbl9udW1iZXIgLSAxO1xyXG4gICAgICAgICAgICBrZWVwX0VYUFJFU1NJT05TX2ZpeGVkID09PSB0cnVlID8gRVhQUkVTU0lPTlNbaW5kZXhdID0gdW5kZWZpbmVkIDogcmVtb3ZlKEVYUFJFU1NJT05TLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsaWFzIGZvciBuZXJkYW1lci5jbGVhcignYWxsJylcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCdhbGwnKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhc09iamVjdFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhc0xhVGVYXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gb3B0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuZXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoYXNPYmplY3QsIGFzTGFUZVgsIG9wdGlvbikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBhc09iamVjdCA/IHt9IDogW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IEVYUFJFU1NJT05TLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBlcSA9IGFzTGFUZVggPyBMYVRlWC5sYXRleChFWFBSRVNTSU9OU1tpXSwgb3B0aW9uKSA6IHRleHQoRVhQUkVTU0lPTlNbaV0sIG9wdGlvbik7XHJcbiAgICAgICAgICAgIGFzT2JqZWN0ID8gcmVzdWx0W2kgKyAxXSA9IGVxIDogcmVzdWx0LnB1c2goZXEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvL3RoZSBtZXRob2QgZm9yIHJlZ2lzdGVyaW5nIG1vZHVsZXNcclxuICAgIGxpYkV4cG9ydHMucmVnaXN0ZXIgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgdmFyIGNvcmUgPSB0aGlzLmdldENvcmUoKTtcclxuXHJcbiAgICAgICAgaWYoaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmKG9iailcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKG9ialtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihvYmogJiYgU2V0dGluZ3MuZXhjbHVkZS5pbmRleE9mKG9iai5uYW1lKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy9tYWtlIHN1cmUgYWxsIHRoZSBkZXBlbmRlbmNpZXMgYXJlIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICBpZihvYmouZGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb2JqLmRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBpZighY29yZVtvYmouZGVwZW5kZW5jaWVzW2ldXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnezB9IHJlcXVpcmVzIHsxfSB0byBiZSBsb2FkZWQhJywgb2JqLm5hbWUsIG9iai5kZXBlbmRlbmNpZXNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2lmIG5vIHBhcmVudCBvYmplY3QgaXMgcHJvdmlkZWQgdGhlbiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBhbiBhZGRyZXNzIGFuZCBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRfb2JqID0gb2JqLnBhcmVudCxcclxuICAgICAgICAgICAgICAgICAgICBmbiA9IG9iai5idWlsZC5jYWxsKGNvcmUpOyAvL2NhbGwgY29uc3RydWN0b3IgdG8gZ2V0IGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGlmKHBhcmVudF9vYmopIHtcclxuICAgICAgICAgICAgICAgIGlmKCFjb3JlW3BhcmVudF9vYmpdKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvcmVbb2JqLnBhcmVudF0gPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmVmX29iaiA9IHBhcmVudF9vYmogPT09ICduZXJkYW1lcicgPyB0aGlzIDogY29yZVtwYXJlbnRfb2JqXTtcclxuICAgICAgICAgICAgICAgIC8vYXR0YWNoIHRoZSBmdW5jdGlvbiB0byB0aGUgY29yZVxyXG4gICAgICAgICAgICAgICAgcmVmX29ialtvYmoubmFtZV0gPSBmbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvYmoudmlzaWJsZSlcclxuICAgICAgICAgICAgICAgIF8uZnVuY3Rpb25zW29iai5uYW1lXSA9IFtmbiwgb2JqLm51bWFyZ3NdOyAvL21ha2UgdGhlIGZ1bmN0aW9uIGF2YWlsYWJsZVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdmFyaWFibGUgbmFtZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHZhbGlkYXRlcyBpZiB0aGUgcHJvZmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgdmFyaWFibGUgbmFtZVxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLnZhbGlkYXRlTmFtZSA9IHZhbGlkYXRlTmFtZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YXJuYW1lIHZhcmlhYmxlIG5hbWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB2YWxpZGF0ZXMgaWYgdGhlIHByb2ZpZGVkIHN0cmluZyBpcyBhIHZhbGlkIHZhcmlhYmxlIG5hbWVcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy52YWxpZFZhck5hbWUgPSBmdW5jdGlvbiAodmFybmFtZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlTmFtZSh2YXJuYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIFJFU0VSVkVELmluZGV4T2YodmFybmFtZSkgPT09IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZnVuY3Rpb25zIGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgbmVyZGFtZXJcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5zdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGtleXMoXy5mdW5jdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIGVxdWF0aW9ucy9leHByZXNzaW9ucyBjdXJyZW50bHkgbG9hZGVkXHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMubnVtRXF1YXRpb25zID0gbGliRXhwb3J0cy5udW1FeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gRVhQUkVTU0lPTlMubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIC8qIEVORCBFWFBPUlRTICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHYgdmFyaWFibGUgdG8gYmUgc2V0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIHZhbHVlIG9mIHZhcmlhYmxlLiBUaGlzIGNhbiBiZSBhIHZhcmlhYmxlIGV4cHJlc3Npb24gb3IgbnVtYmVyXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXJkYW1lciBvYmplY3RcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5zZXRWYXIgPSBmdW5jdGlvbiAodiwgdmFsKSB7XHJcbiAgICAgICAgdmFsaWRhdGVOYW1lKHYpO1xyXG4gICAgICAgIC8vY2hlY2sgaWYgaXQncyBub3QgYWxyZWFkeSBhIGNvbnN0YW50XHJcbiAgICAgICAgaWYodiBpbiBfLkNPTlNUQU5UUylcclxuICAgICAgICAgICAgZXJyKCdDYW5ub3Qgc2V0IHZhbHVlIGZvciBjb25zdGFudCAnICsgdik7XHJcbiAgICAgICAgaWYodmFsID09PSAnZGVsZXRlJyB8fCB2YWwgPT09ICcnKVxyXG4gICAgICAgICAgICBkZWxldGUgVkFSU1t2XTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgVkFSU1t2XSA9IGlzU3ltYm9sKHZhbCkgPyB2YWwgOiBfLnBhcnNlKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgc2V0IHZhcmlhYmxlXHJcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHZcclxuICAgICAqIEByZXR1cm5zIHt2YXJpZXN9XHJcbiAgICAgKi9cclxuICAgIGxpYkV4cG9ydHMuZ2V0VmFyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gVkFSU1t2XTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFyIHRoZSB2YXJpYWJsZXMgZnJvbSB0aGUgVkFSUyBvYmplY3RcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5lcmRhbWVyIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmNsZWFyVmFycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBWQVJTID0ge307XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxvYWRlclxyXG4gICAgICogQHJldHVybnMge25lcmRhbWVyfVxyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XHJcbiAgICAgICAgbG9hZGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dCAtIG91dHB1dCBmb3JtYXQuIENhbiBiZSAnb2JqZWN0JyAoanVzdCByZXR1cm5zIHRoZSBWQVJTIG9iamVjdCksICd0ZXh0JyBvciAnbGF0ZXgnLiBEZWZhdWx0OiAndGV4dCdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBvcHRpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHZhcmlhYmxlc1xyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmdldFZhcnMgPSBmdW5jdGlvbiAob3V0cHV0LCBvcHRpb24pIHtcclxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQgfHwgJ3RleHQnO1xyXG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSB7fTtcclxuICAgICAgICBpZihvdXRwdXQgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB2YXJpYWJsZXMgPSBWQVJTO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IodmFyIHYgaW4gVkFSUykge1xyXG4gICAgICAgICAgICAgICAgaWYob3V0cHV0ID09PSAnbGF0ZXgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzW3ZdID0gVkFSU1t2XS5sYXRleChvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihvdXRwdXQgPT09ICd0ZXh0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc1t2XSA9IFZBUlNbdl0udGV4dChvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YXJpYWJsZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB2YWx1ZSBvZiBhIHNldHRpbmdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXR0aW5nIFRoZSBzZXR0aW5nIHRvIGJlIGNoYW5nZWRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5zZXQgPSBmdW5jdGlvbiAoc2V0dGluZywgdmFsdWUpIHtcclxuICAgICAgICAvL2N1cnJlbnQgb3B0aW9uczpcclxuICAgICAgICAvL1BBUlNFMk5VTUJFUiwgc3VwcHJlc3NfZXJyb3JzXHJcbiAgICAgICAgaWYodHlwZW9mIHNldHRpbmcgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICBmb3IodmFyIHggaW4gc2V0dGluZykge1xyXG4gICAgICAgICAgICAgICAgbGliRXhwb3J0cy5zZXQoeCwgc2V0dGluZ1t4XSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRpc2FsbG93ZWQgPSBbJ1NBRkUnXTtcclxuICAgICAgICBpZihkaXNhbGxvd2VkLmluZGV4T2Yoc2V0dGluZykgIT09IC0xKVxyXG4gICAgICAgICAgICBlcnIoJ0Nhbm5vdCBtb2RpZnkgc2V0dGluZzogJyArIHNldHRpbmcpO1xyXG5cclxuICAgICAgICBpZihzZXR0aW5nID09PSAnUFJFQ0lTSU9OJykge1xyXG4gICAgICAgICAgICBiaWdEZWMuc2V0KHtwcmVjaXNpb246IHZhbHVlfSk7XHJcbiAgICAgICAgICAgIFNldHRpbmdzLlBSRUNJU0lPTiA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgLy8gQXZvaWQgdGhhdCBuZXJkYW1lciBwdXRzIG91dCBnYXJiYWdlIGFmdGVyIDIxIGRlY2ltYWwgcGxhY2VcclxuICAgICAgICAgICAgaWYodmFsdWUgPiAyMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ1VTRV9CSUcnLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKHNldHRpbmcgPT09ICdVU0VfTE4nICYmIHZhbHVlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vc2V0IGxvZyBhcyBMTlxyXG4gICAgICAgICAgICBTZXR0aW5ncy5MT0cgPSAnTE4nO1xyXG4gICAgICAgICAgICAvL3NldCBsb2cxMCBhcyBsb2dcclxuICAgICAgICAgICAgU2V0dGluZ3MuTE9HMTAgPSAnbG9nJztcclxuICAgICAgICAgICAgLy9wb2ludCB0aGUgZnVuY3Rpb25zIGluIHRoZSByaWdodCBkaXJlY3Rpb25cclxuICAgICAgICAgICAgXy5mdW5jdGlvbnNbJ2xvZyddID0gU2V0dGluZ3MuTE9HX0ZOUy5sb2cxMDsgLy9sb2cgaXMgbm93IGxvZzEwXHJcbiAgICAgICAgICAgIC8vdGhlIGxvZzEwIGZ1bmN0aW9uIG11c3QgYmUgZXhwbGljaXRseSBzZXRcclxuICAgICAgICAgICAgXy5mdW5jdGlvbnNbJ2xvZyddWzBdID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICAgICAgICAgIGlmKHguaXNDb25zdGFudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3ltYm9sKE1hdGgubG9nMTAoeCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uc3ltZnVuY3Rpb24oU2V0dGluZ3MuTE9HMTAsIFt4XSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIF8uZnVuY3Rpb25zWydMTiddID0gU2V0dGluZ3MuTE9HX0ZOUy5sb2c7IC8vTE4gaXMgbm93IGxvZ1xyXG5cclxuICAgICAgICAgICAgLy9yZW1vdmUgbG9nMTBcclxuICAgICAgICAgICAgZGVsZXRlIF8uZnVuY3Rpb25zWydsb2cxMCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIFNldHRpbmdzW3NldHRpbmddID0gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiBhIHNldHRpbmdcclxuICAgICAqIEBwYXJhbSB7dHlwZX0gc2V0dGluZ1xyXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgbGliRXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAoc2V0dGluZykge1xyXG4gICAgICAgIHJldHVybiBTZXR0aW5nc1tzZXR0aW5nXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9ucyBtYWtlcyBpbnRlcm5hbCBmdW5jdGlvbnMgYXZhaWxhYmxlIGV4dGVybmFsbHlcclxuICAgICAqIEBwYXJhbSB7Ym9vbH0gb3ZlcnJpZGUgT3ZlcnJpZGUgdGhlIGZ1bmN0aW9ucyB3aGVuIGNhbGxpbmcgYXBpIGlmIGl0IGV4aXN0c1xyXG4gICAgICovXHJcbiAgICBsaWJFeHBvcnRzLmFwaSA9IGZ1bmN0aW9uIChvdmVycmlkZSkge1xyXG4gICAgICAgIC8vTWFwIGludGVybmFsIGZ1bmN0aW9ucyB0byBleHRlcm5hbCBvbmVzXHJcbiAgICAgICAgdmFyIGxpbmtlciA9IGZ1bmN0aW9uIChmbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gXy5wYXJzZShhcmdzW2ldKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbihibG9jaygnUEFSU0UyTlVNQkVSJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfLmNhbGxmdW5jdGlvbihmbmFtZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvL3BlcmZvcm0gdGhlIG1hcHBpbmdcclxuICAgICAgICBmb3IodmFyIHggaW4gXy5mdW5jdGlvbnMpXHJcbiAgICAgICAgICAgIGlmKCEoeCBpbiBsaWJFeHBvcnRzKSB8fCBvdmVycmlkZSlcclxuICAgICAgICAgICAgICAgIGxpYkV4cG9ydHNbeF0gPSBsaW5rZXIoeCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGxpYkV4cG9ydHMucmVwbGFjZUZ1bmN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBudW1fYXJncykge1xyXG4gICAgICAgIHZhciBleGlzdGluZyA9IF8uZnVuY3Rpb25zW25hbWVdO1xyXG4gICAgICAgIHZhciBuZXdfbnVtX2FyZ3MgPSB0eXBlb2YgbnVtX2FyZ3MgPT09ICd1bmRlZmluZWQnID8gZXhpc3RpbmdbMV0gOiBudW1fYXJncztcclxuICAgICAgICBfLmZ1bmN0aW9uc1tuYW1lXSA9IFtmbi5jYWxsKHVuZGVmaW5lZCwgZXhpc3RpbmdbMF0sIEMpLCBuZXdfbnVtX2FyZ3NdO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLnNldE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yLCBzaGlmdCkge1xyXG4gICAgICAgIF8uc2V0T3BlcmF0b3Iob3BlcmF0b3IsIHNoaWZ0KTtcclxuICAgIH07XHJcblxyXG4gICAgbGliRXhwb3J0cy5nZXRPcGVyYXRvciA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBfLmdldE9wZXJhdG9yKG9wZXJhdG9yKTtcclxuICAgIH07XHJcblxyXG4gICAgbGliRXhwb3J0cy5hbGlhc09wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yLCB3aXRoT3BlcmF0b3IpIHtcclxuICAgICAgICBfLmFsaWFzT3BlcmF0b3Iob3BlcmF0b3IsIHdpdGhPcGVyYXRvcik7XHJcbiAgICB9O1xyXG5cclxuICAgIGxpYkV4cG9ydHMudHJlZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF8udHJlZShfLnRvUlBOKF8udG9rZW5pemUoZXhwcmVzc2lvbikpKTtcclxuICAgIH07XHJcblxyXG4gICAgbGliRXhwb3J0cy5odG1sVHJlZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBpbmRlbnQpIHtcclxuICAgICAgICB2YXIgdHJlZSA9IHRoaXMudHJlZShleHByZXNzaW9uKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwidHJlZVwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8dWw+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgICAgICA8bGk+XFxuJyArXHJcbiAgICAgICAgICAgICAgICB0cmVlLnRvSFRNTCgzLCBpbmRlbnQpICsgJ1xcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICAgICAgPC9saT5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPC91bD5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLmFkZFBlZWtlciA9IGZ1bmN0aW9uIChuYW1lLCBmKSB7XHJcbiAgICAgICAgaWYoXy5wZWVrZXJzW25hbWVdKVxyXG4gICAgICAgICAgICBfLnBlZWtlcnNbbmFtZV0ucHVzaChmKTtcclxuICAgIH07XHJcblxyXG4gICAgbGliRXhwb3J0cy5yZW1vdmVQZWVrZXIgPSBmdW5jdGlvbiAobmFtZSwgZikge1xyXG4gICAgICAgIHJlbW92ZShfLnBlZWtlcnNbbmFtZV0sIGYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGUpLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfLnBhcnNlKHgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBsaWJFeHBvcnRzLmFwaSgpO1xyXG5cclxuICAgIHJldHVybiBsaWJFeHBvcnRzOyAvL0RvbmVcclxuLy9pbXBvcnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxufSkoe1xyXG4gICAgLy9odHRwczovL2dpdGh1Yi5jb20vcGV0ZXJvbHNvbi9CaWdJbnRlZ2VyLmpzXHJcbiAgICBiaWdJbnQ6IChmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBiaWdJbnQ9ZnVuY3Rpb24odW5kZWZpbmVkKXtcInVzZSBzdHJpY3RcIjt2YXIgQkFTRT0xZTcsTE9HX0JBU0U9NyxNQVhfSU5UPTkwMDcxOTkyNTQ3NDA5OTIsTUFYX0lOVF9BUlI9c21hbGxUb0FycmF5KE1BWF9JTlQpLExPR19NQVhfSU5UPU1hdGgubG9nKE1BWF9JTlQpO2Z1bmN0aW9uIEludGVnZXIodixyYWRpeCl7aWYodHlwZW9mIHY9PT1cInVuZGVmaW5lZFwiKXJldHVybiBJbnRlZ2VyWzBdO2lmKHR5cGVvZiByYWRpeCE9PVwidW5kZWZpbmVkXCIpcmV0dXJuK3JhZGl4PT09MTA/cGFyc2VWYWx1ZSh2KTpwYXJzZUJhc2UodixyYWRpeCk7cmV0dXJuIHBhcnNlVmFsdWUodil9ZnVuY3Rpb24gQmlnSW50ZWdlcih2YWx1ZSxzaWduKXt0aGlzLnZhbHVlPXZhbHVlO3RoaXMuc2lnbj1zaWduO3RoaXMuaXNTbWFsbD1mYWxzZX1CaWdJbnRlZ2VyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtmdW5jdGlvbiBTbWFsbEludGVnZXIodmFsdWUpe3RoaXMudmFsdWU9dmFsdWU7dGhpcy5zaWduPXZhbHVlPDA7dGhpcy5pc1NtYWxsPXRydWV9U21hbGxJbnRlZ2VyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtmdW5jdGlvbiBpc1ByZWNpc2Uobil7cmV0dXJuLU1BWF9JTlQ8biYmbjxNQVhfSU5UfWZ1bmN0aW9uIHNtYWxsVG9BcnJheShuKXtpZihuPDFlNylyZXR1cm5bbl07aWYobjwxZTE0KXJldHVybltuJTFlNyxNYXRoLmZsb29yKG4vMWU3KV07cmV0dXJuW24lMWU3LE1hdGguZmxvb3Iobi8xZTcpJTFlNyxNYXRoLmZsb29yKG4vMWUxNCldfWZ1bmN0aW9uIGFycmF5VG9TbWFsbChhcnIpe3RyaW0oYXJyKTt2YXIgbGVuZ3RoPWFyci5sZW5ndGg7aWYobGVuZ3RoPDQmJmNvbXBhcmVBYnMoYXJyLE1BWF9JTlRfQVJSKTwwKXtzd2l0Y2gobGVuZ3RoKXtjYXNlIDA6cmV0dXJuIDA7Y2FzZSAxOnJldHVybiBhcnJbMF07Y2FzZSAyOnJldHVybiBhcnJbMF0rYXJyWzFdKkJBU0U7ZGVmYXVsdDpyZXR1cm4gYXJyWzBdKyhhcnJbMV0rYXJyWzJdKkJBU0UpKkJBU0V9fXJldHVybiBhcnJ9ZnVuY3Rpb24gdHJpbSh2KXt2YXIgaT12Lmxlbmd0aDt3aGlsZSh2Wy0taV09PT0wKTt2Lmxlbmd0aD1pKzF9ZnVuY3Rpb24gY3JlYXRlQXJyYXkobGVuZ3RoKXt2YXIgeD1uZXcgQXJyYXkobGVuZ3RoKTt2YXIgaT0tMTt3aGlsZSgrK2k8bGVuZ3RoKXt4W2ldPTB9cmV0dXJuIHh9ZnVuY3Rpb24gdHJ1bmNhdGUobil7aWYobj4wKXJldHVybiBNYXRoLmZsb29yKG4pO3JldHVybiBNYXRoLmNlaWwobil9ZnVuY3Rpb24gYWRkKGEsYil7dmFyIGxfYT1hLmxlbmd0aCxsX2I9Yi5sZW5ndGgscj1uZXcgQXJyYXkobF9hKSxjYXJyeT0wLGJhc2U9QkFTRSxzdW0saTtmb3IoaT0wO2k8bF9iO2krKyl7c3VtPWFbaV0rYltpXStjYXJyeTtjYXJyeT1zdW0+PWJhc2U/MTowO3JbaV09c3VtLWNhcnJ5KmJhc2V9d2hpbGUoaTxsX2Epe3N1bT1hW2ldK2NhcnJ5O2NhcnJ5PXN1bT09PWJhc2U/MTowO3JbaSsrXT1zdW0tY2FycnkqYmFzZX1pZihjYXJyeT4wKXIucHVzaChjYXJyeSk7cmV0dXJuIHJ9ZnVuY3Rpb24gYWRkQW55KGEsYil7aWYoYS5sZW5ndGg+PWIubGVuZ3RoKXJldHVybiBhZGQoYSxiKTtyZXR1cm4gYWRkKGIsYSl9ZnVuY3Rpb24gYWRkU21hbGwoYSxjYXJyeSl7dmFyIGw9YS5sZW5ndGgscj1uZXcgQXJyYXkobCksYmFzZT1CQVNFLHN1bSxpO2ZvcihpPTA7aTxsO2krKyl7c3VtPWFbaV0tYmFzZStjYXJyeTtjYXJyeT1NYXRoLmZsb29yKHN1bS9iYXNlKTtyW2ldPXN1bS1jYXJyeSpiYXNlO2NhcnJ5Kz0xfXdoaWxlKGNhcnJ5PjApe3JbaSsrXT1jYXJyeSViYXNlO2NhcnJ5PU1hdGguZmxvb3IoY2FycnkvYmFzZSl9cmV0dXJuIHJ9QmlnSW50ZWdlci5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodik7aWYodGhpcy5zaWduIT09bi5zaWduKXtyZXR1cm4gdGhpcy5zdWJ0cmFjdChuLm5lZ2F0ZSgpKX12YXIgYT10aGlzLnZhbHVlLGI9bi52YWx1ZTtpZihuLmlzU21hbGwpe3JldHVybiBuZXcgQmlnSW50ZWdlcihhZGRTbWFsbChhLE1hdGguYWJzKGIpKSx0aGlzLnNpZ24pfXJldHVybiBuZXcgQmlnSW50ZWdlcihhZGRBbnkoYSxiKSx0aGlzLnNpZ24pfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5wbHVzPUJpZ0ludGVnZXIucHJvdG90eXBlLmFkZDtTbWFsbEludGVnZXIucHJvdG90eXBlLmFkZD1mdW5jdGlvbih2KXt2YXIgbj1wYXJzZVZhbHVlKHYpO3ZhciBhPXRoaXMudmFsdWU7aWYoYTwwIT09bi5zaWduKXtyZXR1cm4gdGhpcy5zdWJ0cmFjdChuLm5lZ2F0ZSgpKX12YXIgYj1uLnZhbHVlO2lmKG4uaXNTbWFsbCl7aWYoaXNQcmVjaXNlKGErYikpcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYStiKTtiPXNtYWxsVG9BcnJheShNYXRoLmFicyhiKSl9cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGIsTWF0aC5hYnMoYSkpLGE8MCl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUucGx1cz1TbWFsbEludGVnZXIucHJvdG90eXBlLmFkZDtmdW5jdGlvbiBzdWJ0cmFjdChhLGIpe3ZhciBhX2w9YS5sZW5ndGgsYl9sPWIubGVuZ3RoLHI9bmV3IEFycmF5KGFfbCksYm9ycm93PTAsYmFzZT1CQVNFLGksZGlmZmVyZW5jZTtmb3IoaT0wO2k8Yl9sO2krKyl7ZGlmZmVyZW5jZT1hW2ldLWJvcnJvdy1iW2ldO2lmKGRpZmZlcmVuY2U8MCl7ZGlmZmVyZW5jZSs9YmFzZTtib3Jyb3c9MX1lbHNlIGJvcnJvdz0wO3JbaV09ZGlmZmVyZW5jZX1mb3IoaT1iX2w7aTxhX2w7aSsrKXtkaWZmZXJlbmNlPWFbaV0tYm9ycm93O2lmKGRpZmZlcmVuY2U8MClkaWZmZXJlbmNlKz1iYXNlO2Vsc2V7cltpKytdPWRpZmZlcmVuY2U7YnJlYWt9cltpXT1kaWZmZXJlbmNlfWZvcig7aTxhX2w7aSsrKXtyW2ldPWFbaV19dHJpbShyKTtyZXR1cm4gcn1mdW5jdGlvbiBzdWJ0cmFjdEFueShhLGIsc2lnbil7dmFyIHZhbHVlO2lmKGNvbXBhcmVBYnMoYSxiKT49MCl7dmFsdWU9c3VidHJhY3QoYSxiKX1lbHNle3ZhbHVlPXN1YnRyYWN0KGIsYSk7c2lnbj0hc2lnbn12YWx1ZT1hcnJheVRvU21hbGwodmFsdWUpO2lmKHR5cGVvZiB2YWx1ZT09PVwibnVtYmVyXCIpe2lmKHNpZ24pdmFsdWU9LXZhbHVlO3JldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKX1yZXR1cm4gbmV3IEJpZ0ludGVnZXIodmFsdWUsc2lnbil9ZnVuY3Rpb24gc3VidHJhY3RTbWFsbChhLGIsc2lnbil7dmFyIGw9YS5sZW5ndGgscj1uZXcgQXJyYXkobCksY2Fycnk9LWIsYmFzZT1CQVNFLGksZGlmZmVyZW5jZTtmb3IoaT0wO2k8bDtpKyspe2RpZmZlcmVuY2U9YVtpXStjYXJyeTtjYXJyeT1NYXRoLmZsb29yKGRpZmZlcmVuY2UvYmFzZSk7ZGlmZmVyZW5jZSU9YmFzZTtyW2ldPWRpZmZlcmVuY2U8MD9kaWZmZXJlbmNlK2Jhc2U6ZGlmZmVyZW5jZX1yPWFycmF5VG9TbWFsbChyKTtpZih0eXBlb2Ygcj09PVwibnVtYmVyXCIpe2lmKHNpZ24pcj0tcjtyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihyKX1yZXR1cm4gbmV3IEJpZ0ludGVnZXIocixzaWduKX1CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbih2KXt2YXIgbj1wYXJzZVZhbHVlKHYpO2lmKHRoaXMuc2lnbiE9PW4uc2lnbil7cmV0dXJuIHRoaXMuYWRkKG4ubmVnYXRlKCkpfXZhciBhPXRoaXMudmFsdWUsYj1uLnZhbHVlO2lmKG4uaXNTbWFsbClyZXR1cm4gc3VidHJhY3RTbWFsbChhLE1hdGguYWJzKGIpLHRoaXMuc2lnbik7cmV0dXJuIHN1YnRyYWN0QW55KGEsYix0aGlzLnNpZ24pfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5taW51cz1CaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodik7dmFyIGE9dGhpcy52YWx1ZTtpZihhPDAhPT1uLnNpZ24pe3JldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKX12YXIgYj1uLnZhbHVlO2lmKG4uaXNTbWFsbCl7cmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYS1iKX1yZXR1cm4gc3VidHJhY3RTbWFsbChiLE1hdGguYWJzKGEpLGE+PTApfTtTbWFsbEludGVnZXIucHJvdG90eXBlLm1pbnVzPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuc3VidHJhY3Q7QmlnSW50ZWdlci5wcm90b3R5cGUubmVnYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsIXRoaXMuc2lnbil9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubmVnYXRlPWZ1bmN0aW9uKCl7dmFyIHNpZ249dGhpcy5zaWduO3ZhciBzbWFsbD1uZXcgU21hbGxJbnRlZ2VyKC10aGlzLnZhbHVlKTtzbWFsbC5zaWduPSFzaWduO3JldHVybiBzbWFsbH07QmlnSW50ZWdlci5wcm90b3R5cGUuYWJzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsZmFsc2UpfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiBuZXcgU21hbGxJbnRlZ2VyKE1hdGguYWJzKHRoaXMudmFsdWUpKX07ZnVuY3Rpb24gbXVsdGlwbHlMb25nKGEsYil7dmFyIGFfbD1hLmxlbmd0aCxiX2w9Yi5sZW5ndGgsbD1hX2wrYl9sLHI9Y3JlYXRlQXJyYXkobCksYmFzZT1CQVNFLHByb2R1Y3QsY2FycnksaSxhX2ksYl9qO2ZvcihpPTA7aTxhX2w7KytpKXthX2k9YVtpXTtmb3IodmFyIGo9MDtqPGJfbDsrK2ope2Jfaj1iW2pdO3Byb2R1Y3Q9YV9pKmJfaityW2kral07Y2Fycnk9TWF0aC5mbG9vcihwcm9kdWN0L2Jhc2UpO3JbaStqXT1wcm9kdWN0LWNhcnJ5KmJhc2U7cltpK2orMV0rPWNhcnJ5fX10cmltKHIpO3JldHVybiByfWZ1bmN0aW9uIG11bHRpcGx5U21hbGwoYSxiKXt2YXIgbD1hLmxlbmd0aCxyPW5ldyBBcnJheShsKSxiYXNlPUJBU0UsY2Fycnk9MCxwcm9kdWN0LGk7Zm9yKGk9MDtpPGw7aSsrKXtwcm9kdWN0PWFbaV0qYitjYXJyeTtjYXJyeT1NYXRoLmZsb29yKHByb2R1Y3QvYmFzZSk7cltpXT1wcm9kdWN0LWNhcnJ5KmJhc2V9d2hpbGUoY2Fycnk+MCl7cltpKytdPWNhcnJ5JWJhc2U7Y2Fycnk9TWF0aC5mbG9vcihjYXJyeS9iYXNlKX1yZXR1cm4gcn1mdW5jdGlvbiBzaGlmdExlZnQoeCxuKXt2YXIgcj1bXTt3aGlsZShuLS0gPjApci5wdXNoKDApO3JldHVybiByLmNvbmNhdCh4KX1mdW5jdGlvbiBtdWx0aXBseUthcmF0c3ViYSh4LHkpe3ZhciBuPU1hdGgubWF4KHgubGVuZ3RoLHkubGVuZ3RoKTtpZihuPD0zMClyZXR1cm4gbXVsdGlwbHlMb25nKHgseSk7bj1NYXRoLmNlaWwobi8yKTt2YXIgYj14LnNsaWNlKG4pLGE9eC5zbGljZSgwLG4pLGQ9eS5zbGljZShuKSxjPXkuc2xpY2UoMCxuKTt2YXIgYWM9bXVsdGlwbHlLYXJhdHN1YmEoYSxjKSxiZD1tdWx0aXBseUthcmF0c3ViYShiLGQpLGFiY2Q9bXVsdGlwbHlLYXJhdHN1YmEoYWRkQW55KGEsYiksYWRkQW55KGMsZCkpO3ZhciBwcm9kdWN0PWFkZEFueShhZGRBbnkoYWMsc2hpZnRMZWZ0KHN1YnRyYWN0KHN1YnRyYWN0KGFiY2QsYWMpLGJkKSxuKSksc2hpZnRMZWZ0KGJkLDIqbikpO3RyaW0ocHJvZHVjdCk7cmV0dXJuIHByb2R1Y3R9ZnVuY3Rpb24gdXNlS2FyYXRzdWJhKGwxLGwyKXtyZXR1cm4tLjAxMipsMS0uMDEyKmwyKzE1ZS02KmwxKmwyPjB9QmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odil7dmFyIG49cGFyc2VWYWx1ZSh2KSxhPXRoaXMudmFsdWUsYj1uLnZhbHVlLHNpZ249dGhpcy5zaWduIT09bi5zaWduLGFicztpZihuLmlzU21hbGwpe2lmKGI9PT0wKXJldHVybiBJbnRlZ2VyWzBdO2lmKGI9PT0xKXJldHVybiB0aGlzO2lmKGI9PT0tMSlyZXR1cm4gdGhpcy5uZWdhdGUoKTthYnM9TWF0aC5hYnMoYik7aWYoYWJzPEJBU0Upe3JldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGEsYWJzKSxzaWduKX1iPXNtYWxsVG9BcnJheShhYnMpfWlmKHVzZUthcmF0c3ViYShhLmxlbmd0aCxiLmxlbmd0aCkpcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5S2FyYXRzdWJhKGEsYiksc2lnbik7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhhLGIpLHNpZ24pfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS50aW1lcz1CaWdJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtmdW5jdGlvbiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoYSxiLHNpZ24pe2lmKGE8QkFTRSl7cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5U21hbGwoYixhKSxzaWduKX1yZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlMb25nKGIsc21hbGxUb0FycmF5KGEpKSxzaWduKX1TbWFsbEludGVnZXIucHJvdG90eXBlLl9tdWx0aXBseUJ5U21hbGw9ZnVuY3Rpb24oYSl7aWYoaXNQcmVjaXNlKGEudmFsdWUqdGhpcy52YWx1ZSkpe3JldHVybiBuZXcgU21hbGxJbnRlZ2VyKGEudmFsdWUqdGhpcy52YWx1ZSl9cmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSxzbWFsbFRvQXJyYXkoTWF0aC5hYnModGhpcy52YWx1ZSkpLHRoaXMuc2lnbiE9PWEuc2lnbil9O0JpZ0ludGVnZXIucHJvdG90eXBlLl9tdWx0aXBseUJ5U21hbGw9ZnVuY3Rpb24oYSl7aWYoYS52YWx1ZT09PTApcmV0dXJuIEludGVnZXJbMF07aWYoYS52YWx1ZT09PTEpcmV0dXJuIHRoaXM7aWYoYS52YWx1ZT09PS0xKXJldHVybiB0aGlzLm5lZ2F0ZSgpO3JldHVybiBtdWx0aXBseVNtYWxsQW5kQXJyYXkoTWF0aC5hYnMoYS52YWx1ZSksdGhpcy52YWx1ZSx0aGlzLnNpZ24hPT1hLnNpZ24pfTtTbWFsbEludGVnZXIucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKHYpe3JldHVybiBwYXJzZVZhbHVlKHYpLl9tdWx0aXBseUJ5U21hbGwodGhpcyl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUudGltZXM9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5tdWx0aXBseTtmdW5jdGlvbiBzcXVhcmUoYSl7dmFyIGw9YS5sZW5ndGgscj1jcmVhdGVBcnJheShsK2wpLGJhc2U9QkFTRSxwcm9kdWN0LGNhcnJ5LGksYV9pLGFfajtmb3IoaT0wO2k8bDtpKyspe2FfaT1hW2ldO2NhcnJ5PTAtYV9pKmFfaTtmb3IodmFyIGo9aTtqPGw7aisrKXthX2o9YVtqXTtwcm9kdWN0PTIqKGFfaSphX2opK3JbaStqXStjYXJyeTtjYXJyeT1NYXRoLmZsb29yKHByb2R1Y3QvYmFzZSk7cltpK2pdPXByb2R1Y3QtY2FycnkqYmFzZX1yW2krbF09Y2Fycnl9dHJpbShyKTtyZXR1cm4gcn1CaWdJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3F1YXJlKHRoaXMudmFsdWUpLGZhbHNlKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24oKXt2YXIgdmFsdWU9dGhpcy52YWx1ZSp0aGlzLnZhbHVlO2lmKGlzUHJlY2lzZSh2YWx1ZSkpcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodmFsdWUpO3JldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUoc21hbGxUb0FycmF5KE1hdGguYWJzKHRoaXMudmFsdWUpKSksZmFsc2UpfTtmdW5jdGlvbiBkaXZNb2QxKGEsYil7dmFyIGFfbD1hLmxlbmd0aCxiX2w9Yi5sZW5ndGgsYmFzZT1CQVNFLHJlc3VsdD1jcmVhdGVBcnJheShiLmxlbmd0aCksZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0PWJbYl9sLTFdLGxhbWJkYT1NYXRoLmNlaWwoYmFzZS8oMipkaXZpc29yTW9zdFNpZ25pZmljYW50RGlnaXQpKSxyZW1haW5kZXI9bXVsdGlwbHlTbWFsbChhLGxhbWJkYSksZGl2aXNvcj1tdWx0aXBseVNtYWxsKGIsbGFtYmRhKSxxdW90aWVudERpZ2l0LHNoaWZ0LGNhcnJ5LGJvcnJvdyxpLGwscTtpZihyZW1haW5kZXIubGVuZ3RoPD1hX2wpcmVtYWluZGVyLnB1c2goMCk7ZGl2aXNvci5wdXNoKDApO2Rpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdD1kaXZpc29yW2JfbC0xXTtmb3Ioc2hpZnQ9YV9sLWJfbDtzaGlmdD49MDtzaGlmdC0tKXtxdW90aWVudERpZ2l0PWJhc2UtMTtpZihyZW1haW5kZXJbc2hpZnQrYl9sXSE9PWRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCl7cXVvdGllbnREaWdpdD1NYXRoLmZsb29yKChyZW1haW5kZXJbc2hpZnQrYl9sXSpiYXNlK3JlbWFpbmRlcltzaGlmdCtiX2wtMV0pL2Rpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCl9Y2Fycnk9MDtib3Jyb3c9MDtsPWRpdmlzb3IubGVuZ3RoO2ZvcihpPTA7aTxsO2krKyl7Y2FycnkrPXF1b3RpZW50RGlnaXQqZGl2aXNvcltpXTtxPU1hdGguZmxvb3IoY2FycnkvYmFzZSk7Ym9ycm93Kz1yZW1haW5kZXJbc2hpZnQraV0tKGNhcnJ5LXEqYmFzZSk7Y2Fycnk9cTtpZihib3Jyb3c8MCl7cmVtYWluZGVyW3NoaWZ0K2ldPWJvcnJvdytiYXNlO2JvcnJvdz0tMX1lbHNle3JlbWFpbmRlcltzaGlmdCtpXT1ib3Jyb3c7Ym9ycm93PTB9fXdoaWxlKGJvcnJvdyE9PTApe3F1b3RpZW50RGlnaXQtPTE7Y2Fycnk9MDtmb3IoaT0wO2k8bDtpKyspe2NhcnJ5Kz1yZW1haW5kZXJbc2hpZnQraV0tYmFzZStkaXZpc29yW2ldO2lmKGNhcnJ5PDApe3JlbWFpbmRlcltzaGlmdCtpXT1jYXJyeStiYXNlO2NhcnJ5PTB9ZWxzZXtyZW1haW5kZXJbc2hpZnQraV09Y2Fycnk7Y2Fycnk9MX19Ym9ycm93Kz1jYXJyeX1yZXN1bHRbc2hpZnRdPXF1b3RpZW50RGlnaXR9cmVtYWluZGVyPWRpdk1vZFNtYWxsKHJlbWFpbmRlcixsYW1iZGEpWzBdO3JldHVyblthcnJheVRvU21hbGwocmVzdWx0KSxhcnJheVRvU21hbGwocmVtYWluZGVyKV19ZnVuY3Rpb24gZGl2TW9kMihhLGIpe3ZhciBhX2w9YS5sZW5ndGgsYl9sPWIubGVuZ3RoLHJlc3VsdD1bXSxwYXJ0PVtdLGJhc2U9QkFTRSxndWVzcyx4bGVuLGhpZ2h4LGhpZ2h5LGNoZWNrO3doaWxlKGFfbCl7cGFydC51bnNoaWZ0KGFbLS1hX2xdKTt0cmltKHBhcnQpO2lmKGNvbXBhcmVBYnMocGFydCxiKTwwKXtyZXN1bHQucHVzaCgwKTtjb250aW51ZX14bGVuPXBhcnQubGVuZ3RoO2hpZ2h4PXBhcnRbeGxlbi0xXSpiYXNlK3BhcnRbeGxlbi0yXTtoaWdoeT1iW2JfbC0xXSpiYXNlK2JbYl9sLTJdO2lmKHhsZW4+Yl9sKXtoaWdoeD0oaGlnaHgrMSkqYmFzZX1ndWVzcz1NYXRoLmNlaWwoaGlnaHgvaGlnaHkpO2Rve2NoZWNrPW11bHRpcGx5U21hbGwoYixndWVzcyk7aWYoY29tcGFyZUFicyhjaGVjayxwYXJ0KTw9MClicmVhaztndWVzcy0tfXdoaWxlKGd1ZXNzKTtyZXN1bHQucHVzaChndWVzcyk7cGFydD1zdWJ0cmFjdChwYXJ0LGNoZWNrKX1yZXN1bHQucmV2ZXJzZSgpO3JldHVyblthcnJheVRvU21hbGwocmVzdWx0KSxhcnJheVRvU21hbGwocGFydCldfWZ1bmN0aW9uIGRpdk1vZFNtYWxsKHZhbHVlLGxhbWJkYSl7dmFyIGxlbmd0aD12YWx1ZS5sZW5ndGgscXVvdGllbnQ9Y3JlYXRlQXJyYXkobGVuZ3RoKSxiYXNlPUJBU0UsaSxxLHJlbWFpbmRlcixkaXZpc29yO3JlbWFpbmRlcj0wO2ZvcihpPWxlbmd0aC0xO2k+PTA7LS1pKXtkaXZpc29yPXJlbWFpbmRlcipiYXNlK3ZhbHVlW2ldO3E9dHJ1bmNhdGUoZGl2aXNvci9sYW1iZGEpO3JlbWFpbmRlcj1kaXZpc29yLXEqbGFtYmRhO3F1b3RpZW50W2ldPXF8MH1yZXR1cm5bcXVvdGllbnQscmVtYWluZGVyfDBdfWZ1bmN0aW9uIGRpdk1vZEFueShzZWxmLHYpe3ZhciB2YWx1ZSxuPXBhcnNlVmFsdWUodik7dmFyIGE9c2VsZi52YWx1ZSxiPW4udmFsdWU7dmFyIHF1b3RpZW50O2lmKGI9PT0wKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXZpZGUgYnkgemVyb1wiKTtpZihzZWxmLmlzU21hbGwpe2lmKG4uaXNTbWFsbCl7cmV0dXJuW25ldyBTbWFsbEludGVnZXIodHJ1bmNhdGUoYS9iKSksbmV3IFNtYWxsSW50ZWdlcihhJWIpXX1yZXR1cm5bSW50ZWdlclswXSxzZWxmXX1pZihuLmlzU21hbGwpe2lmKGI9PT0xKXJldHVybltzZWxmLEludGVnZXJbMF1dO2lmKGI9PS0xKXJldHVybltzZWxmLm5lZ2F0ZSgpLEludGVnZXJbMF1dO3ZhciBhYnM9TWF0aC5hYnMoYik7aWYoYWJzPEJBU0Upe3ZhbHVlPWRpdk1vZFNtYWxsKGEsYWJzKTtxdW90aWVudD1hcnJheVRvU21hbGwodmFsdWVbMF0pO3ZhciByZW1haW5kZXI9dmFsdWVbMV07aWYoc2VsZi5zaWduKXJlbWFpbmRlcj0tcmVtYWluZGVyO2lmKHR5cGVvZiBxdW90aWVudD09PVwibnVtYmVyXCIpe2lmKHNlbGYuc2lnbiE9PW4uc2lnbilxdW90aWVudD0tcXVvdGllbnQ7cmV0dXJuW25ldyBTbWFsbEludGVnZXIocXVvdGllbnQpLG5ldyBTbWFsbEludGVnZXIocmVtYWluZGVyKV19cmV0dXJuW25ldyBCaWdJbnRlZ2VyKHF1b3RpZW50LHNlbGYuc2lnbiE9PW4uc2lnbiksbmV3IFNtYWxsSW50ZWdlcihyZW1haW5kZXIpXX1iPXNtYWxsVG9BcnJheShhYnMpfXZhciBjb21wYXJpc29uPWNvbXBhcmVBYnMoYSxiKTtpZihjb21wYXJpc29uPT09LTEpcmV0dXJuW0ludGVnZXJbMF0sc2VsZl07aWYoY29tcGFyaXNvbj09PTApcmV0dXJuW0ludGVnZXJbc2VsZi5zaWduPT09bi5zaWduPzE6LTFdLEludGVnZXJbMF1dO2lmKGEubGVuZ3RoK2IubGVuZ3RoPD0yMDApdmFsdWU9ZGl2TW9kMShhLGIpO2Vsc2UgdmFsdWU9ZGl2TW9kMihhLGIpO3F1b3RpZW50PXZhbHVlWzBdO3ZhciBxU2lnbj1zZWxmLnNpZ24hPT1uLnNpZ24sbW9kPXZhbHVlWzFdLG1TaWduPXNlbGYuc2lnbjtpZih0eXBlb2YgcXVvdGllbnQ9PT1cIm51bWJlclwiKXtpZihxU2lnbilxdW90aWVudD0tcXVvdGllbnQ7cXVvdGllbnQ9bmV3IFNtYWxsSW50ZWdlcihxdW90aWVudCl9ZWxzZSBxdW90aWVudD1uZXcgQmlnSW50ZWdlcihxdW90aWVudCxxU2lnbik7aWYodHlwZW9mIG1vZD09PVwibnVtYmVyXCIpe2lmKG1TaWduKW1vZD0tbW9kO21vZD1uZXcgU21hbGxJbnRlZ2VyKG1vZCl9ZWxzZSBtb2Q9bmV3IEJpZ0ludGVnZXIobW9kLG1TaWduKTtyZXR1cm5bcXVvdGllbnQsbW9kXX1CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2Q9ZnVuY3Rpb24odil7dmFyIHJlc3VsdD1kaXZNb2RBbnkodGhpcyx2KTtyZXR1cm57cXVvdGllbnQ6cmVzdWx0WzBdLHJlbWFpbmRlcjpyZXN1bHRbMV19fTtTbWFsbEludGVnZXIucHJvdG90eXBlLmRpdm1vZD1CaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2Q7QmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlPWZ1bmN0aW9uKHYpe3JldHVybiBkaXZNb2RBbnkodGhpcyx2KVswXX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5vdmVyPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlPUJpZ0ludGVnZXIucHJvdG90eXBlLm92ZXI9QmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlO0JpZ0ludGVnZXIucHJvdG90eXBlLm1vZD1mdW5jdGlvbih2KXtyZXR1cm4gZGl2TW9kQW55KHRoaXMsdilbMV19O1NtYWxsSW50ZWdlci5wcm90b3R5cGUucmVtYWluZGVyPVNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kPUJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlcj1CaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2Q7QmlnSW50ZWdlci5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodiksYT10aGlzLnZhbHVlLGI9bi52YWx1ZSx2YWx1ZSx4LHk7aWYoYj09PTApcmV0dXJuIEludGVnZXJbMV07aWYoYT09PTApcmV0dXJuIEludGVnZXJbMF07aWYoYT09PTEpcmV0dXJuIEludGVnZXJbMV07aWYoYT09PS0xKXJldHVybiBuLmlzRXZlbigpP0ludGVnZXJbMV06SW50ZWdlclstMV07aWYobi5zaWduKXtyZXR1cm4gSW50ZWdlclswXX1pZighbi5pc1NtYWxsKXRocm93IG5ldyBFcnJvcihcIlRoZSBleHBvbmVudCBcIituLnRvU3RyaW5nKCkrXCIgaXMgdG9vIGxhcmdlLlwiKTtpZih0aGlzLmlzU21hbGwpe2lmKGlzUHJlY2lzZSh2YWx1ZT1NYXRoLnBvdyhhLGIpKSlyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZSh2YWx1ZSkpfXg9dGhpczt5PUludGVnZXJbMV07d2hpbGUodHJ1ZSl7aWYoYiYxPT09MSl7eT15LnRpbWVzKHgpOy0tYn1pZihiPT09MClicmVhaztiLz0yO3g9eC5zcXVhcmUoKX1yZXR1cm4geX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wb3c9QmlnSW50ZWdlci5wcm90b3R5cGUucG93O0JpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdz1mdW5jdGlvbihleHAsbW9kKXtleHA9cGFyc2VWYWx1ZShleHApO21vZD1wYXJzZVZhbHVlKG1vZCk7aWYobW9kLmlzWmVybygpKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0YWtlIG1vZFBvdyB3aXRoIG1vZHVsdXMgMFwiKTt2YXIgcj1JbnRlZ2VyWzFdLGJhc2U9dGhpcy5tb2QobW9kKTt3aGlsZShleHAuaXNQb3NpdGl2ZSgpKXtpZihiYXNlLmlzWmVybygpKXJldHVybiBJbnRlZ2VyWzBdO2lmKGV4cC5pc09kZCgpKXI9ci5tdWx0aXBseShiYXNlKS5tb2QobW9kKTtleHA9ZXhwLmRpdmlkZSgyKTtiYXNlPWJhc2Uuc3F1YXJlKCkubW9kKG1vZCl9cmV0dXJuIHJ9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kUG93PUJpZ0ludGVnZXIucHJvdG90eXBlLm1vZFBvdztmdW5jdGlvbiBjb21wYXJlQWJzKGEsYil7aWYoYS5sZW5ndGghPT1iLmxlbmd0aCl7cmV0dXJuIGEubGVuZ3RoPmIubGVuZ3RoPzE6LTF9Zm9yKHZhciBpPWEubGVuZ3RoLTE7aT49MDtpLS0pe2lmKGFbaV0hPT1iW2ldKXJldHVybiBhW2ldPmJbaV0/MTotMX1yZXR1cm4gMH1CaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzPWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodiksYT10aGlzLnZhbHVlLGI9bi52YWx1ZTtpZihuLmlzU21hbGwpcmV0dXJuIDE7cmV0dXJuIGNvbXBhcmVBYnMoYSxiKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlQWJzPWZ1bmN0aW9uKHYpe3ZhciBuPXBhcnNlVmFsdWUodiksYT1NYXRoLmFicyh0aGlzLnZhbHVlKSxiPW4udmFsdWU7aWYobi5pc1NtYWxsKXtiPU1hdGguYWJzKGIpO3JldHVybiBhPT09Yj8wOmE+Yj8xOi0xfXJldHVybi0xfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKHYpe2lmKHY9PT1JbmZpbml0eSl7cmV0dXJuLTF9aWYodj09PS1JbmZpbml0eSl7cmV0dXJuIDF9dmFyIG49cGFyc2VWYWx1ZSh2KSxhPXRoaXMudmFsdWUsYj1uLnZhbHVlO2lmKHRoaXMuc2lnbiE9PW4uc2lnbil7cmV0dXJuIG4uc2lnbj8xOi0xfWlmKG4uaXNTbWFsbCl7cmV0dXJuIHRoaXMuc2lnbj8tMToxfXJldHVybiBjb21wYXJlQWJzKGEsYikqKHRoaXMuc2lnbj8tMToxKX07QmlnSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvPUJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uKHYpe2lmKHY9PT1JbmZpbml0eSl7cmV0dXJuLTF9aWYodj09PS1JbmZpbml0eSl7cmV0dXJuIDF9dmFyIG49cGFyc2VWYWx1ZSh2KSxhPXRoaXMudmFsdWUsYj1uLnZhbHVlO2lmKG4uaXNTbWFsbCl7cmV0dXJuIGE9PWI/MDphPmI/MTotMX1pZihhPDAhPT1uLnNpZ24pe3JldHVybiBhPDA/LTE6MX1yZXR1cm4gYTwwPzE6LTF9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvPVNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24odil7cmV0dXJuIHRoaXMuY29tcGFyZSh2KT09PTB9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuZXE9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5lcXVhbHM9QmlnSW50ZWdlci5wcm90b3R5cGUuZXE9QmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzO0JpZ0ludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscz1mdW5jdGlvbih2KXtyZXR1cm4gdGhpcy5jb21wYXJlKHYpIT09MH07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5uZXE9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3RFcXVhbHM9QmlnSW50ZWdlci5wcm90b3R5cGUubmVxPUJpZ0ludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscztCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHYpe3JldHVybiB0aGlzLmNvbXBhcmUodik+MH07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ndD1TbWFsbEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXI9QmlnSW50ZWdlci5wcm90b3R5cGUuZ3Q9QmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlcjtCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXI9ZnVuY3Rpb24odil7cmV0dXJuIHRoaXMuY29tcGFyZSh2KTwwfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmx0PVNtYWxsSW50ZWdlci5wcm90b3R5cGUubGVzc2VyPUJpZ0ludGVnZXIucHJvdG90eXBlLmx0PUJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3NlcjtCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM9ZnVuY3Rpb24odil7cmV0dXJuIHRoaXMuY29tcGFyZSh2KT49MH07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5nZXE9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHM9QmlnSW50ZWdlci5wcm90b3R5cGUuZ2VxPUJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXJPckVxdWFscztCaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscz1mdW5jdGlvbih2KXtyZXR1cm4gdGhpcy5jb21wYXJlKHYpPD0wfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmxlcT1TbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzPUJpZ0ludGVnZXIucHJvdG90eXBlLmxlcT1CaWdJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXJPckVxdWFscztCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0V2ZW49ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy52YWx1ZVswXSYxKT09PTB9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMudmFsdWUmMSk9PT0wfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc09kZD1mdW5jdGlvbigpe3JldHVybih0aGlzLnZhbHVlWzBdJjEpPT09MX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc09kZD1mdW5jdGlvbigpe3JldHVybih0aGlzLnZhbHVlJjEpPT09MX07QmlnSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiF0aGlzLnNpZ259O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlPjB9O0JpZ0ludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaWdufTtTbWFsbEludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZTwwfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQ9ZnVuY3Rpb24oKXtyZXR1cm4gZmFsc2V9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNVbml0PWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYWJzKHRoaXMudmFsdWUpPT09MX07QmlnSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuIGZhbHNlfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlPT09MH07QmlnSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeT1mdW5jdGlvbih2KXt2YXIgbj1wYXJzZVZhbHVlKHYpO3ZhciB2YWx1ZT1uLnZhbHVlO2lmKHZhbHVlPT09MClyZXR1cm4gZmFsc2U7aWYodmFsdWU9PT0xKXJldHVybiB0cnVlO2lmKHZhbHVlPT09MilyZXR1cm4gdGhpcy5pc0V2ZW4oKTtyZXR1cm4gdGhpcy5tb2QobikuZXF1YWxzKEludGVnZXJbMF0pfTtTbWFsbEludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnk9QmlnSW50ZWdlci5wcm90b3R5cGUuaXNEaXZpc2libGVCeTtmdW5jdGlvbiBpc0Jhc2ljUHJpbWUodil7dmFyIG49di5hYnMoKTtpZihuLmlzVW5pdCgpKXJldHVybiBmYWxzZTtpZihuLmVxdWFscygyKXx8bi5lcXVhbHMoMyl8fG4uZXF1YWxzKDUpKXJldHVybiB0cnVlO2lmKG4uaXNFdmVuKCl8fG4uaXNEaXZpc2libGVCeSgzKXx8bi5pc0RpdmlzaWJsZUJ5KDUpKXJldHVybiBmYWxzZTtpZihuLmxlc3Nlcig0OSkpcmV0dXJuIHRydWV9ZnVuY3Rpb24gbWlsbGVyUmFiaW5UZXN0KG4sYSl7dmFyIG5QcmV2PW4ucHJldigpLGI9blByZXYscj0wLGQsdCxpLHg7d2hpbGUoYi5pc0V2ZW4oKSliPWIuZGl2aWRlKDIpLHIrKztuZXh0OmZvcihpPTA7aTxhLmxlbmd0aDtpKyspe2lmKG4ubGVzc2VyKGFbaV0pKWNvbnRpbnVlO3g9YmlnSW50KGFbaV0pLm1vZFBvdyhiLG4pO2lmKHguZXF1YWxzKEludGVnZXJbMV0pfHx4LmVxdWFscyhuUHJldikpY29udGludWU7Zm9yKGQ9ci0xO2QhPTA7ZC0tKXt4PXguc3F1YXJlKCkubW9kKG4pO2lmKHguaXNVbml0KCkpcmV0dXJuIGZhbHNlO2lmKHguZXF1YWxzKG5QcmV2KSljb250aW51ZSBuZXh0fXJldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1CaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lPWZ1bmN0aW9uKHN0cmljdCl7dmFyIGlzUHJpbWU9aXNCYXNpY1ByaW1lKHRoaXMpO2lmKGlzUHJpbWUhPT11bmRlZmluZWQpcmV0dXJuIGlzUHJpbWU7dmFyIG49dGhpcy5hYnMoKTt2YXIgYml0cz1uLmJpdExlbmd0aCgpO2lmKGJpdHM8PTY0KXJldHVybiBtaWxsZXJSYWJpblRlc3QobixbMiwzMjUsOTM3NSwyODE3OCw0NTA3NzUsOTc4MDUwNCwxNzk1MjY1MDIyXSk7dmFyIGxvZ049TWF0aC5sb2coMikqYml0czt2YXIgdD1NYXRoLmNlaWwoc3RyaWN0PT09dHJ1ZT8yKk1hdGgucG93KGxvZ04sMik6bG9nTik7Zm9yKHZhciBhPVtdLGk9MDtpPHQ7aSsrKXthLnB1c2goYmlnSW50KGkrMikpfXJldHVybiBtaWxsZXJSYWJpblRlc3QobixhKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lPUJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJpbWU7QmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lPWZ1bmN0aW9uKGl0ZXJhdGlvbnMpe3ZhciBpc1ByaW1lPWlzQmFzaWNQcmltZSh0aGlzKTtpZihpc1ByaW1lIT09dW5kZWZpbmVkKXJldHVybiBpc1ByaW1lO3ZhciBuPXRoaXMuYWJzKCk7dmFyIHQ9aXRlcmF0aW9ucz09PXVuZGVmaW5lZD81Oml0ZXJhdGlvbnM7Zm9yKHZhciBhPVtdLGk9MDtpPHQ7aSsrKXthLnB1c2goYmlnSW50LnJhbmRCZXR3ZWVuKDIsbi5taW51cygyKSkpfXJldHVybiBtaWxsZXJSYWJpblRlc3QobixhKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWU9QmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcm9iYWJsZVByaW1lO0JpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludj1mdW5jdGlvbihuKXt2YXIgdD1iaWdJbnQuemVybyxuZXdUPWJpZ0ludC5vbmUscj1wYXJzZVZhbHVlKG4pLG5ld1I9dGhpcy5hYnMoKSxxLGxhc3RULGxhc3RSO3doaWxlKCFuZXdSLmVxdWFscyhiaWdJbnQuemVybykpe3E9ci5kaXZpZGUobmV3Uik7bGFzdFQ9dDtsYXN0Uj1yO3Q9bmV3VDtyPW5ld1I7bmV3VD1sYXN0VC5zdWJ0cmFjdChxLm11bHRpcGx5KG5ld1QpKTtuZXdSPWxhc3RSLnN1YnRyYWN0KHEubXVsdGlwbHkobmV3UikpfWlmKCFyLmVxdWFscygxKSl0aHJvdyBuZXcgRXJyb3IodGhpcy50b1N0cmluZygpK1wiIGFuZCBcIituLnRvU3RyaW5nKCkrXCIgYXJlIG5vdCBjby1wcmltZVwiKTtpZih0LmNvbXBhcmUoMCk9PT0tMSl7dD10LmFkZChuKX1pZih0aGlzLmlzTmVnYXRpdmUoKSl7cmV0dXJuIHQubmVnYXRlKCl9cmV0dXJuIHR9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kSW52PUJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludjtCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHZhbHVlPXRoaXMudmFsdWU7aWYodGhpcy5zaWduKXtyZXR1cm4gc3VidHJhY3RTbWFsbCh2YWx1ZSwxLHRoaXMuc2lnbil9cmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKHZhbHVlLDEpLHRoaXMuc2lnbil9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe3ZhciB2YWx1ZT10aGlzLnZhbHVlO2lmKHZhbHVlKzE8TUFYX0lOVClyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSsxKTtyZXR1cm4gbmV3IEJpZ0ludGVnZXIoTUFYX0lOVF9BUlIsZmFsc2UpfTtCaWdJbnRlZ2VyLnByb3RvdHlwZS5wcmV2PWZ1bmN0aW9uKCl7dmFyIHZhbHVlPXRoaXMudmFsdWU7aWYodGhpcy5zaWduKXtyZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwodmFsdWUsMSksdHJ1ZSl9cmV0dXJuIHN1YnRyYWN0U21hbGwodmFsdWUsMSx0aGlzLnNpZ24pfTtTbWFsbEludGVnZXIucHJvdG90eXBlLnByZXY9ZnVuY3Rpb24oKXt2YXIgdmFsdWU9dGhpcy52YWx1ZTtpZih2YWx1ZS0xPi1NQVhfSU5UKXJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlLTEpO3JldHVybiBuZXcgQmlnSW50ZWdlcihNQVhfSU5UX0FSUix0cnVlKX07dmFyIHBvd2Vyc09mVHdvPVsxXTt3aGlsZSgyKnBvd2Vyc09mVHdvW3Bvd2Vyc09mVHdvLmxlbmd0aC0xXTw9QkFTRSlwb3dlcnNPZlR3by5wdXNoKDIqcG93ZXJzT2ZUd29bcG93ZXJzT2ZUd28ubGVuZ3RoLTFdKTt2YXIgcG93ZXJzMkxlbmd0aD1wb3dlcnNPZlR3by5sZW5ndGgsaGlnaGVzdFBvd2VyMj1wb3dlcnNPZlR3b1twb3dlcnMyTGVuZ3RoLTFdO2Z1bmN0aW9uIHNoaWZ0X2lzU21hbGwobil7cmV0dXJuKHR5cGVvZiBuPT09XCJudW1iZXJcInx8dHlwZW9mIG49PT1cInN0cmluZ1wiKSYmK01hdGguYWJzKG4pPD1CQVNFfHxuIGluc3RhbmNlb2YgQmlnSW50ZWdlciYmbi52YWx1ZS5sZW5ndGg8PTF9QmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0PWZ1bmN0aW9uKG4pe2lmKCFzaGlmdF9pc1NtYWxsKG4pKXt0aHJvdyBuZXcgRXJyb3IoU3RyaW5nKG4pK1wiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpfW49K247aWYobjwwKXJldHVybiB0aGlzLnNoaWZ0UmlnaHQoLW4pO3ZhciByZXN1bHQ9dGhpcztpZihyZXN1bHQuaXNaZXJvKCkpcmV0dXJuIHJlc3VsdDt3aGlsZShuPj1wb3dlcnMyTGVuZ3RoKXtyZXN1bHQ9cmVzdWx0Lm11bHRpcGx5KGhpZ2hlc3RQb3dlcjIpO24tPXBvd2VyczJMZW5ndGgtMX1yZXR1cm4gcmVzdWx0Lm11bHRpcGx5KHBvd2Vyc09mVHdvW25dKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQ9QmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0O0JpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQ9ZnVuY3Rpb24obil7dmFyIHJlbVF1bztpZighc2hpZnRfaXNTbWFsbChuKSl7dGhyb3cgbmV3IEVycm9yKFN0cmluZyhuKStcIiBpcyB0b28gbGFyZ2UgZm9yIHNoaWZ0aW5nLlwiKX1uPStuO2lmKG48MClyZXR1cm4gdGhpcy5zaGlmdExlZnQoLW4pO3ZhciByZXN1bHQ9dGhpczt3aGlsZShuPj1wb3dlcnMyTGVuZ3RoKXtpZihyZXN1bHQuaXNaZXJvKCl8fHJlc3VsdC5pc05lZ2F0aXZlKCkmJnJlc3VsdC5pc1VuaXQoKSlyZXR1cm4gcmVzdWx0O3JlbVF1bz1kaXZNb2RBbnkocmVzdWx0LGhpZ2hlc3RQb3dlcjIpO3Jlc3VsdD1yZW1RdW9bMV0uaXNOZWdhdGl2ZSgpP3JlbVF1b1swXS5wcmV2KCk6cmVtUXVvWzBdO24tPXBvd2VyczJMZW5ndGgtMX1yZW1RdW89ZGl2TW9kQW55KHJlc3VsdCxwb3dlcnNPZlR3b1tuXSk7cmV0dXJuIHJlbVF1b1sxXS5pc05lZ2F0aXZlKCk/cmVtUXVvWzBdLnByZXYoKTpyZW1RdW9bMF19O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodD1CaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdFJpZ2h0O2Z1bmN0aW9uIGJpdHdpc2UoeCx5LGZuKXt5PXBhcnNlVmFsdWUoeSk7dmFyIHhTaWduPXguaXNOZWdhdGl2ZSgpLHlTaWduPXkuaXNOZWdhdGl2ZSgpO3ZhciB4UmVtPXhTaWduP3gubm90KCk6eCx5UmVtPXlTaWduP3kubm90KCk6eTt2YXIgeERpZ2l0PTAseURpZ2l0PTA7dmFyIHhEaXZNb2Q9bnVsbCx5RGl2TW9kPW51bGw7dmFyIHJlc3VsdD1bXTt3aGlsZSgheFJlbS5pc1plcm8oKXx8IXlSZW0uaXNaZXJvKCkpe3hEaXZNb2Q9ZGl2TW9kQW55KHhSZW0saGlnaGVzdFBvd2VyMik7eERpZ2l0PXhEaXZNb2RbMV0udG9KU051bWJlcigpO2lmKHhTaWduKXt4RGlnaXQ9aGlnaGVzdFBvd2VyMi0xLXhEaWdpdH15RGl2TW9kPWRpdk1vZEFueSh5UmVtLGhpZ2hlc3RQb3dlcjIpO3lEaWdpdD15RGl2TW9kWzFdLnRvSlNOdW1iZXIoKTtpZih5U2lnbil7eURpZ2l0PWhpZ2hlc3RQb3dlcjItMS15RGlnaXR9eFJlbT14RGl2TW9kWzBdO3lSZW09eURpdk1vZFswXTtyZXN1bHQucHVzaChmbih4RGlnaXQseURpZ2l0KSl9dmFyIHN1bT1mbih4U2lnbj8xOjAseVNpZ24/MTowKSE9PTA/YmlnSW50KC0xKTpiaWdJbnQoMCk7Zm9yKHZhciBpPXJlc3VsdC5sZW5ndGgtMTtpPj0wO2ktPTEpe3N1bT1zdW0ubXVsdGlwbHkoaGlnaGVzdFBvd2VyMikuYWRkKGJpZ0ludChyZXN1bHRbaV0pKX1yZXR1cm4gc3VtfUJpZ0ludGVnZXIucHJvdG90eXBlLm5vdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5lZ2F0ZSgpLnByZXYoKX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3Q9QmlnSW50ZWdlci5wcm90b3R5cGUubm90O0JpZ0ludGVnZXIucHJvdG90eXBlLmFuZD1mdW5jdGlvbihuKXtyZXR1cm4gYml0d2lzZSh0aGlzLG4sZnVuY3Rpb24oYSxiKXtyZXR1cm4gYSZifSl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuYW5kPUJpZ0ludGVnZXIucHJvdG90eXBlLmFuZDtCaWdJbnRlZ2VyLnByb3RvdHlwZS5vcj1mdW5jdGlvbihuKXtyZXR1cm4gYml0d2lzZSh0aGlzLG4sZnVuY3Rpb24oYSxiKXtyZXR1cm4gYXxifSl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUub3I9QmlnSW50ZWdlci5wcm90b3R5cGUub3I7QmlnSW50ZWdlci5wcm90b3R5cGUueG9yPWZ1bmN0aW9uKG4pe3JldHVybiBiaXR3aXNlKHRoaXMsbixmdW5jdGlvbihhLGIpe3JldHVybiBhXmJ9KX07U21hbGxJbnRlZ2VyLnByb3RvdHlwZS54b3I9QmlnSW50ZWdlci5wcm90b3R5cGUueG9yO3ZhciBMT0JNQVNLX0k9MTw8MzAsTE9CTUFTS19CST0oQkFTRSYtQkFTRSkqKEJBU0UmLUJBU0UpfExPQk1BU0tfSTtmdW5jdGlvbiByb3VnaExPQihuKXt2YXIgdj1uLnZhbHVlLHg9dHlwZW9mIHY9PT1cIm51bWJlclwiP3Z8TE9CTUFTS19JOnZbMF0rdlsxXSpCQVNFfExPQk1BU0tfQkk7cmV0dXJuIHgmLXh9ZnVuY3Rpb24gaW50ZWdlckxvZ2FyaXRobSh2YWx1ZSxiYXNlKXtpZihiYXNlLmNvbXBhcmVUbyh2YWx1ZSk8PTApe3ZhciB0bXA9aW50ZWdlckxvZ2FyaXRobSh2YWx1ZSxiYXNlLnNxdWFyZShiYXNlKSk7dmFyIHA9dG1wLnA7dmFyIGU9dG1wLmU7dmFyIHQ9cC5tdWx0aXBseShiYXNlKTtyZXR1cm4gdC5jb21wYXJlVG8odmFsdWUpPD0wP3twOnQsZTplKjIrMX06e3A6cCxlOmUqMn19cmV0dXJue3A6YmlnSW50KDEpLGU6MH19QmlnSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoPWZ1bmN0aW9uKCl7dmFyIG49dGhpcztpZihuLmNvbXBhcmVUbyhiaWdJbnQoMCkpPDApe249bi5uZWdhdGUoKS5zdWJ0cmFjdChiaWdJbnQoMSkpfWlmKG4uY29tcGFyZVRvKGJpZ0ludCgwKSk9PT0wKXtyZXR1cm4gYmlnSW50KDApfXJldHVybiBiaWdJbnQoaW50ZWdlckxvZ2FyaXRobShuLGJpZ0ludCgyKSkuZSkuYWRkKGJpZ0ludCgxKSl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUuYml0TGVuZ3RoPUJpZ0ludGVnZXIucHJvdG90eXBlLmJpdExlbmd0aDtmdW5jdGlvbiBtYXgoYSxiKXthPXBhcnNlVmFsdWUoYSk7Yj1wYXJzZVZhbHVlKGIpO3JldHVybiBhLmdyZWF0ZXIoYik/YTpifWZ1bmN0aW9uIG1pbihhLGIpe2E9cGFyc2VWYWx1ZShhKTtiPXBhcnNlVmFsdWUoYik7cmV0dXJuIGEubGVzc2VyKGIpP2E6Yn1mdW5jdGlvbiBnY2QoYSxiKXthPXBhcnNlVmFsdWUoYSkuYWJzKCk7Yj1wYXJzZVZhbHVlKGIpLmFicygpO2lmKGEuZXF1YWxzKGIpKXJldHVybiBhO2lmKGEuaXNaZXJvKCkpcmV0dXJuIGI7aWYoYi5pc1plcm8oKSlyZXR1cm4gYTt2YXIgYz1JbnRlZ2VyWzFdLGQsdDt3aGlsZShhLmlzRXZlbigpJiZiLmlzRXZlbigpKXtkPU1hdGgubWluKHJvdWdoTE9CKGEpLHJvdWdoTE9CKGIpKTthPWEuZGl2aWRlKGQpO2I9Yi5kaXZpZGUoZCk7Yz1jLm11bHRpcGx5KGQpfXdoaWxlKGEuaXNFdmVuKCkpe2E9YS5kaXZpZGUocm91Z2hMT0IoYSkpfWRve3doaWxlKGIuaXNFdmVuKCkpe2I9Yi5kaXZpZGUocm91Z2hMT0IoYikpfWlmKGEuZ3JlYXRlcihiKSl7dD1iO2I9YTthPXR9Yj1iLnN1YnRyYWN0KGEpfXdoaWxlKCFiLmlzWmVybygpKTtyZXR1cm4gYy5pc1VuaXQoKT9hOmEubXVsdGlwbHkoYyl9ZnVuY3Rpb24gbGNtKGEsYil7YT1wYXJzZVZhbHVlKGEpLmFicygpO2I9cGFyc2VWYWx1ZShiKS5hYnMoKTtyZXR1cm4gYS5kaXZpZGUoZ2NkKGEsYikpLm11bHRpcGx5KGIpfWZ1bmN0aW9uIHJhbmRCZXR3ZWVuKGEsYil7YT1wYXJzZVZhbHVlKGEpO2I9cGFyc2VWYWx1ZShiKTt2YXIgbG93PW1pbihhLGIpLGhpZ2g9bWF4KGEsYik7dmFyIHJhbmdlPWhpZ2guc3VidHJhY3QobG93KS5hZGQoMSk7aWYocmFuZ2UuaXNTbWFsbClyZXR1cm4gbG93LmFkZChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqcmFuZ2UpKTt2YXIgbGVuZ3RoPXJhbmdlLnZhbHVlLmxlbmd0aC0xO3ZhciByZXN1bHQ9W10scmVzdHJpY3RlZD10cnVlO2Zvcih2YXIgaT1sZW5ndGg7aT49MDtpLS0pe3ZhciB0b3A9cmVzdHJpY3RlZD9yYW5nZS52YWx1ZVtpXTpCQVNFO3ZhciBkaWdpdD10cnVuY2F0ZShNYXRoLnJhbmRvbSgpKnRvcCk7cmVzdWx0LnVuc2hpZnQoZGlnaXQpO2lmKGRpZ2l0PHRvcClyZXN0cmljdGVkPWZhbHNlfXJlc3VsdD1hcnJheVRvU21hbGwocmVzdWx0KTtyZXR1cm4gbG93LmFkZCh0eXBlb2YgcmVzdWx0PT09XCJudW1iZXJcIj9uZXcgU21hbGxJbnRlZ2VyKHJlc3VsdCk6bmV3IEJpZ0ludGVnZXIocmVzdWx0LGZhbHNlKSl9dmFyIHBhcnNlQmFzZT1mdW5jdGlvbih0ZXh0LGJhc2Upe3ZhciBsZW5ndGg9dGV4dC5sZW5ndGg7dmFyIGk7dmFyIGFic0Jhc2U9TWF0aC5hYnMoYmFzZSk7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXt2YXIgYz10ZXh0W2ldLnRvTG93ZXJDYXNlKCk7aWYoYz09PVwiLVwiKWNvbnRpbnVlO2lmKC9bYS16MC05XS8udGVzdChjKSl7aWYoL1swLTldLy50ZXN0KGMpJiYrYz49YWJzQmFzZSl7aWYoYz09PVwiMVwiJiZhYnNCYXNlPT09MSljb250aW51ZTt0aHJvdyBuZXcgRXJyb3IoYytcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiK2Jhc2UrXCIuXCIpfWVsc2UgaWYoYy5jaGFyQ29kZUF0KDApLTg3Pj1hYnNCYXNlKXt0aHJvdyBuZXcgRXJyb3IoYytcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiK2Jhc2UrXCIuXCIpfX19aWYoMjw9YmFzZSYmYmFzZTw9MzYpe2lmKGxlbmd0aDw9TE9HX01BWF9JTlQvTWF0aC5sb2coYmFzZSkpe3ZhciByZXN1bHQ9cGFyc2VJbnQodGV4dCxiYXNlKTtpZihpc05hTihyZXN1bHQpKXt0aHJvdyBuZXcgRXJyb3IoYytcIiBpcyBub3QgYSB2YWxpZCBkaWdpdCBpbiBiYXNlIFwiK2Jhc2UrXCIuXCIpfXJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHBhcnNlSW50KHRleHQsYmFzZSkpfX1iYXNlPXBhcnNlVmFsdWUoYmFzZSk7dmFyIGRpZ2l0cz1bXTt2YXIgaXNOZWdhdGl2ZT10ZXh0WzBdPT09XCItXCI7Zm9yKGk9aXNOZWdhdGl2ZT8xOjA7aTx0ZXh0Lmxlbmd0aDtpKyspe3ZhciBjPXRleHRbaV0udG9Mb3dlckNhc2UoKSxjaGFyQ29kZT1jLmNoYXJDb2RlQXQoMCk7aWYoNDg8PWNoYXJDb2RlJiZjaGFyQ29kZTw9NTcpZGlnaXRzLnB1c2gocGFyc2VWYWx1ZShjKSk7ZWxzZSBpZig5Nzw9Y2hhckNvZGUmJmNoYXJDb2RlPD0xMjIpZGlnaXRzLnB1c2gocGFyc2VWYWx1ZShjLmNoYXJDb2RlQXQoMCktODcpKTtlbHNlIGlmKGM9PT1cIjxcIil7dmFyIHN0YXJ0PWk7ZG97aSsrfXdoaWxlKHRleHRbaV0hPT1cIj5cIik7ZGlnaXRzLnB1c2gocGFyc2VWYWx1ZSh0ZXh0LnNsaWNlKHN0YXJ0KzEsaSkpKX1lbHNlIHRocm93IG5ldyBFcnJvcihjK1wiIGlzIG5vdCBhIHZhbGlkIGNoYXJhY3RlclwiKX1yZXR1cm4gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cyxiYXNlLGlzTmVnYXRpdmUpfTtmdW5jdGlvbiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLGJhc2UsaXNOZWdhdGl2ZSl7dmFyIHZhbD1JbnRlZ2VyWzBdLHBvdz1JbnRlZ2VyWzFdLGk7Zm9yKGk9ZGlnaXRzLmxlbmd0aC0xO2k+PTA7aS0tKXt2YWw9dmFsLmFkZChkaWdpdHNbaV0udGltZXMocG93KSk7cG93PXBvdy50aW1lcyhiYXNlKX1yZXR1cm4gaXNOZWdhdGl2ZT92YWwubmVnYXRlKCk6dmFsfWZ1bmN0aW9uIHN0cmluZ2lmeShkaWdpdCl7aWYoZGlnaXQ8PTM1KXtyZXR1cm5cIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLmNoYXJBdChkaWdpdCl9cmV0dXJuXCI8XCIrZGlnaXQrXCI+XCJ9ZnVuY3Rpb24gdG9CYXNlKG4sYmFzZSl7YmFzZT1iaWdJbnQoYmFzZSk7aWYoYmFzZS5pc1plcm8oKSl7aWYobi5pc1plcm8oKSlyZXR1cm57dmFsdWU6WzBdLGlzTmVnYXRpdmU6ZmFsc2V9O3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5vbnplcm8gbnVtYmVycyB0byBiYXNlIDAuXCIpfWlmKGJhc2UuZXF1YWxzKC0xKSl7aWYobi5pc1plcm8oKSlyZXR1cm57dmFsdWU6WzBdLGlzTmVnYXRpdmU6ZmFsc2V9O2lmKG4uaXNOZWdhdGl2ZSgpKXJldHVybnt2YWx1ZTpbXS5jb25jYXQuYXBwbHkoW10sQXJyYXkuYXBwbHkobnVsbCxBcnJheSgtbikpLm1hcChBcnJheS5wcm90b3R5cGUudmFsdWVPZixbMSwwXSkpLGlzTmVnYXRpdmU6ZmFsc2V9O3ZhciBhcnI9QXJyYXkuYXBwbHkobnVsbCxBcnJheSgrbi0xKSkubWFwKEFycmF5LnByb3RvdHlwZS52YWx1ZU9mLFswLDFdKTthcnIudW5zaGlmdChbMV0pO3JldHVybnt2YWx1ZTpbXS5jb25jYXQuYXBwbHkoW10sYXJyKSxpc05lZ2F0aXZlOmZhbHNlfX12YXIgbmVnPWZhbHNlO2lmKG4uaXNOZWdhdGl2ZSgpJiZiYXNlLmlzUG9zaXRpdmUoKSl7bmVnPXRydWU7bj1uLmFicygpfWlmKGJhc2UuZXF1YWxzKDEpKXtpZihuLmlzWmVybygpKXJldHVybnt2YWx1ZTpbMF0saXNOZWdhdGl2ZTpmYWxzZX07cmV0dXJue3ZhbHVlOkFycmF5LmFwcGx5KG51bGwsQXJyYXkoK24pKS5tYXAoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLDEpLGlzTmVnYXRpdmU6bmVnfX12YXIgb3V0PVtdO3ZhciBsZWZ0PW4sZGl2bW9kO3doaWxlKGxlZnQuaXNOZWdhdGl2ZSgpfHxsZWZ0LmNvbXBhcmVBYnMoYmFzZSk+PTApe2Rpdm1vZD1sZWZ0LmRpdm1vZChiYXNlKTtsZWZ0PWRpdm1vZC5xdW90aWVudDt2YXIgZGlnaXQ9ZGl2bW9kLnJlbWFpbmRlcjtpZihkaWdpdC5pc05lZ2F0aXZlKCkpe2RpZ2l0PWJhc2UubWludXMoZGlnaXQpLmFicygpO2xlZnQ9bGVmdC5uZXh0KCl9b3V0LnB1c2goZGlnaXQudG9KU051bWJlcigpKX1vdXQucHVzaChsZWZ0LnRvSlNOdW1iZXIoKSk7cmV0dXJue3ZhbHVlOm91dC5yZXZlcnNlKCksaXNOZWdhdGl2ZTpuZWd9fWZ1bmN0aW9uIHRvQmFzZVN0cmluZyhuLGJhc2Upe3ZhciBhcnI9dG9CYXNlKG4sYmFzZSk7cmV0dXJuKGFyci5pc05lZ2F0aXZlP1wiLVwiOlwiXCIpK2Fyci52YWx1ZS5tYXAoc3RyaW5naWZ5KS5qb2luKFwiXCIpfUJpZ0ludGVnZXIucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24ocmFkaXgpe3JldHVybiB0b0Jhc2UodGhpcyxyYWRpeCl9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbihyYWRpeCl7cmV0dXJuIHRvQmFzZSh0aGlzLHJhZGl4KX07QmlnSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24ocmFkaXgpe2lmKHJhZGl4PT09dW5kZWZpbmVkKXJhZGl4PTEwO2lmKHJhZGl4IT09MTApcmV0dXJuIHRvQmFzZVN0cmluZyh0aGlzLHJhZGl4KTt2YXIgdj10aGlzLnZhbHVlLGw9di5sZW5ndGgsc3RyPVN0cmluZyh2Wy0tbF0pLHplcm9zPVwiMDAwMDAwMFwiLGRpZ2l0O3doaWxlKC0tbD49MCl7ZGlnaXQ9U3RyaW5nKHZbbF0pO3N0cis9emVyb3Muc2xpY2UoZGlnaXQubGVuZ3RoKStkaWdpdH12YXIgc2lnbj10aGlzLnNpZ24/XCItXCI6XCJcIjtyZXR1cm4gc2lnbitzdHJ9O1NtYWxsSW50ZWdlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24ocmFkaXgpe2lmKHJhZGl4PT09dW5kZWZpbmVkKXJhZGl4PTEwO2lmKHJhZGl4IT0xMClyZXR1cm4gdG9CYXNlU3RyaW5nKHRoaXMscmFkaXgpO3JldHVybiBTdHJpbmcodGhpcy52YWx1ZSl9O0JpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNPTj1TbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvU3RyaW5nKCl9O0JpZ0ludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gcGFyc2VJbnQodGhpcy50b1N0cmluZygpLDEwKX07QmlnSW50ZWdlci5wcm90b3R5cGUudG9KU051bWJlcj1CaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1NtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfTtTbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXI9U21hbGxJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO2Z1bmN0aW9uIHBhcnNlU3RyaW5nVmFsdWUodil7aWYoaXNQcmVjaXNlKCt2KSl7dmFyIHg9K3Y7aWYoeD09PXRydW5jYXRlKHgpKXJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHgpO3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIrdil9dmFyIHNpZ249dlswXT09PVwiLVwiO2lmKHNpZ24pdj12LnNsaWNlKDEpO3ZhciBzcGxpdD12LnNwbGl0KC9lL2kpO2lmKHNwbGl0Lmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIrc3BsaXQuam9pbihcImVcIikpO2lmKHNwbGl0Lmxlbmd0aD09PTIpe3ZhciBleHA9c3BsaXRbMV07aWYoZXhwWzBdPT09XCIrXCIpZXhwPWV4cC5zbGljZSgxKTtleHA9K2V4cDtpZihleHAhPT10cnVuY2F0ZShleHApfHwhaXNQcmVjaXNlKGV4cCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIitleHArXCIgaXMgbm90IGEgdmFsaWQgZXhwb25lbnQuXCIpO3ZhciB0ZXh0PXNwbGl0WzBdO3ZhciBkZWNpbWFsUGxhY2U9dGV4dC5pbmRleE9mKFwiLlwiKTtpZihkZWNpbWFsUGxhY2U+PTApe2V4cC09dGV4dC5sZW5ndGgtZGVjaW1hbFBsYWNlLTE7dGV4dD10ZXh0LnNsaWNlKDAsZGVjaW1hbFBsYWNlKSt0ZXh0LnNsaWNlKGRlY2ltYWxQbGFjZSsxKX1pZihleHA8MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBuZWdhdGl2ZSBleHBvbmVudCBwYXJ0IGZvciBpbnRlZ2Vyc1wiKTt0ZXh0Kz1uZXcgQXJyYXkoZXhwKzEpLmpvaW4oXCIwXCIpO3Y9dGV4dH12YXIgaXNWYWxpZD0vXihbMC05XVswLTldKikkLy50ZXN0KHYpO2lmKCFpc1ZhbGlkKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW50ZWdlcjogXCIrdik7dmFyIHI9W10sbWF4PXYubGVuZ3RoLGw9TE9HX0JBU0UsbWluPW1heC1sO3doaWxlKG1heD4wKXtyLnB1c2goK3Yuc2xpY2UobWluLG1heCkpO21pbi09bDtpZihtaW48MCltaW49MDttYXgtPWx9dHJpbShyKTtyZXR1cm4gbmV3IEJpZ0ludGVnZXIocixzaWduKX1mdW5jdGlvbiBwYXJzZU51bWJlclZhbHVlKHYpe2lmKGlzUHJlY2lzZSh2KSl7aWYodiE9PXRydW5jYXRlKHYpKXRocm93IG5ldyBFcnJvcih2K1wiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKTtyZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2KX1yZXR1cm4gcGFyc2VTdHJpbmdWYWx1ZSh2LnRvU3RyaW5nKCkpfWZ1bmN0aW9uIHBhcnNlVmFsdWUodil7aWYodHlwZW9mIHY9PT1cIm51bWJlclwiKXtyZXR1cm4gcGFyc2VOdW1iZXJWYWx1ZSh2KX1pZih0eXBlb2Ygdj09PVwic3RyaW5nXCIpe3JldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYpfXJldHVybiB2fWZvcih2YXIgaT0wO2k8MWUzO2krKyl7SW50ZWdlcltpXT1uZXcgU21hbGxJbnRlZ2VyKGkpO2lmKGk+MClJbnRlZ2VyWy1pXT1uZXcgU21hbGxJbnRlZ2VyKC1pKX1JbnRlZ2VyLm9uZT1JbnRlZ2VyWzFdO0ludGVnZXIuemVybz1JbnRlZ2VyWzBdO0ludGVnZXIubWludXNPbmU9SW50ZWdlclstMV07SW50ZWdlci5tYXg9bWF4O0ludGVnZXIubWluPW1pbjtJbnRlZ2VyLmdjZD1nY2Q7SW50ZWdlci5sY209bGNtO0ludGVnZXIuaXNJbnN0YW5jZT1mdW5jdGlvbih4KXtyZXR1cm4geCBpbnN0YW5jZW9mIEJpZ0ludGVnZXJ8fHggaW5zdGFuY2VvZiBTbWFsbEludGVnZXJ9O0ludGVnZXIucmFuZEJldHdlZW49cmFuZEJldHdlZW47SW50ZWdlci5mcm9tQXJyYXk9ZnVuY3Rpb24oZGlnaXRzLGJhc2UsaXNOZWdhdGl2ZSl7cmV0dXJuIHBhcnNlQmFzZUZyb21BcnJheShkaWdpdHMubWFwKHBhcnNlVmFsdWUpLHBhcnNlVmFsdWUoYmFzZXx8MTApLGlzTmVnYXRpdmUpfTtyZXR1cm4gSW50ZWdlcn0oKTtpZih0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIiYmbW9kdWxlLmhhc093blByb3BlcnR5KFwiZXhwb3J0c1wiKSl7bW9kdWxlLmV4cG9ydHM9YmlnSW50fWlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShcImJpZy1pbnRlZ2VyXCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gYmlnSW50fSl9XHJcbiAgICAgICAgcmV0dXJuIGJpZ0ludDtcclxuICAgIH0pKCksXHJcbiAgICAvKlxyXG4gICAgICogIGRlY2ltYWwuanMgdjEwLjIuMVxyXG4gICAgICogIEFuIGFyYml0cmFyeS1wcmVjaXNpb24gRGVjaW1hbCB0eXBlIGZvciBKYXZhU2NyaXB0LlxyXG4gICAgICogIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2RlY2ltYWwuanNcclxuICAgICAqICBDb3B5cmlnaHQgKGMpIDIwMjAgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICAgICAqICBNSVQgTGljZW5jZVxyXG4gICAgICovXHJcbiAgICBiaWdEZWM6IGZ1bmN0aW9uKG4pe1widXNlIHN0cmljdFwiO3ZhciBlLGksdCxyLHM9OWUxNSxvPTFlOSx1PVwiMDEyMzQ1Njc4OWFiY2RlZlwiLGM9XCIyLjMwMjU4NTA5Mjk5NDA0NTY4NDAxNzk5MTQ1NDY4NDM2NDIwNzYwMTEwMTQ4ODYyODc3Mjk3NjAzMzMyNzkwMDk2NzU3MjYwOTY3NzM1MjQ4MDIzNTk5NzIwNTA4OTU5ODI5ODM0MTk2Nzc4NDA0MjI4NjI0ODYzMzQwOTUyNTQ2NTA4MjgwNjc1NjY2NjI4NzM2OTA5ODc4MTY4OTQ4MjkwNzIwODMyNTU1NDY4MDg0Mzc5OTg5NDgyNjIzMzE5ODUyODM5MzUwNTMwODk2NTM3NzczMjYyODg0NjE2MzM2NjIyMjI4NzY5ODIxOTg4Njc0NjU0MzY2NzQ3NDQwNDI0MzI3NDM2NTE1NTA0ODkzNDMxNDkzOTM5MTQ3OTYxOTQwNDQwMDIyMjEwNTEwMTcxNDE3NDgwMDM2ODgwODQwMTI2NDcwODA2ODU1Njc3NDMyMTYyMjgzNTUyMjAxMTQ4MDQ2NjM3MTU2NTkxMjEzNzM0NTA3NDc4NTY5NDc2ODM0NjM2MTY3OTIxMDE4MDY0NDUwNzA2NDgwMDAyNzc1MDI2ODQ5MTY3NDY1NTA1ODY4NTY5MzU2NzM0MjA2NzA1ODExMzY0MjkyMjQ1NTQ0MDU3NTg5MjU3MjQyMDgyNDEzMTQ2OTU2ODkwMTY3NTg5NDAyNTY3NzYzMTEzNTY5MTkyOTIwMzMzNzY1ODcxNDE2NjAyMzAxMDU3MDMwODk2MzQ1NzIwNzU0NDAzNzA4NDc0Njk5NDAxNjgyNjkyODI4MDg0ODExODQyODkzMTQ4NDg1MjQ5NDg2NDQ4NzE5Mjc4MDk2NzYyNzEyNzU3NzUzOTcwMjc2Njg2MDU5NTI0OTY3MTY2NzQxODM0ODU3MDQ0MjI1MDcxOTc5NjUwMDQ3MTQ5NTEwNTA0OTIyMTQ3NzY1Njc2MzY5Mzg2NjI5NzY5Nzk1MjIxMTA3MTgyNjQ1NDk3MzQ3NzI2NjI0MjU3MDk0MjkzMjI1ODI3OTg1MDI1ODU1MDk3ODUyNjUzODMyMDc2MDY3MjYzMTcxNjQzMDk1MDU5OTUwODc4MDc1MjM3MTAzMzMxMDExOTc4NTc1NDczMzE1NDE0MjE4MDg0Mjc1NDM4NjM1OTE3NzgxMTcwNTQzMDk4Mjc0ODIzODUwNDU2NDgwMTkwOTU2MTAyOTkyOTE4MjQzMTgyMzc1MjUzNTc3MDk3NTA1Mzk1NjUxODc2OTc1MTAzNzQ5NzA4ODg2OTIxODAyMDUxODkzMzk1MDcyMzg1MzkyMDUxNDQ2MzQxOTcyNjUyODcyODY5NjUxMTA4NjI1NzE0OTIxOTg4NDk5Nzg3NDg4NzM3NzEzNDU2ODYyMDkxNjcwNThcIixmPVwiMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5XCIsYT17cHJlY2lzaW9uOjIwLHJvdW5kaW5nOjQsbW9kdWxvOjEsdG9FeHBOZWc6LTcsdG9FeHBQb3M6MjEsbWluRTotcyxtYXhFOnMsY3J5cHRvOiExfSxoPSEwLGQ9XCJbRGVjaW1hbEVycm9yXSBcIixsPWQrXCJJbnZhbGlkIGFyZ3VtZW50OiBcIixwPWQrXCJQcmVjaXNpb24gbGltaXQgZXhjZWVkZWRcIixnPWQrXCJjcnlwdG8gdW5hdmFpbGFibGVcIixtPU1hdGguZmxvb3Isdz1NYXRoLnBvdyx2PS9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pLE49L14weChbMC05YS1mXSsoXFwuWzAtOWEtZl0qKT98XFwuWzAtOWEtZl0rKShwWystXT9cXGQrKT8kL2ksYj0vXjBvKFswLTddKyhcXC5bMC03XSopP3xcXC5bMC03XSspKHBbKy1dP1xcZCspPyQvaSxFPS9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSx4PTFlNyx5PTcsTT1jLmxlbmd0aC0xLHE9Zi5sZW5ndGgtMSxPPXtuYW1lOlwiW29iamVjdCBEZWNpbWFsXVwifTtmdW5jdGlvbiBEKG4pe3ZhciBlLGksdCxyPW4ubGVuZ3RoLTEscz1cIlwiLG89blswXTtpZihyPjApe2ZvcihzKz1vLGU9MTtlPHI7ZSsrKXQ9bltlXStcIlwiLChpPXktdC5sZW5ndGgpJiYocys9ayhpKSkscys9dDtvPW5bZV0sKGk9eS0odD1vK1wiXCIpLmxlbmd0aCkmJihzKz1rKGkpKX1lbHNlIGlmKDA9PT1vKXJldHVyblwiMFwiO2Zvcig7byUxMD09MDspby89MTA7cmV0dXJuIHMrb31mdW5jdGlvbiBGKG4sZSxpKXtpZihuIT09fn5ufHxuPGV8fG4+aSl0aHJvdyBFcnJvcihsK24pfWZ1bmN0aW9uIEEobixlLGksdCl7dmFyIHIscyxvLHU7Zm9yKHM9blswXTtzPj0xMDtzLz0xMCktLWU7cmV0dXJuLS1lPDA/KGUrPXkscj0wKToocj1NYXRoLmNlaWwoKGUrMSkveSksZSU9eSkscz13KDEwLHktZSksdT1uW3JdJXN8MCxudWxsPT10P2U8Mz8oMD09ZT91PXUvMTAwfDA6MT09ZSYmKHU9dS8xMHwwKSxvPWk8NCYmOTk5OTk9PXV8fGk+MyYmNDk5OTk9PXV8fDVlND09dXx8MD09dSk6bz0oaTw0JiZ1KzE9PXN8fGk+MyYmdSsxPT1zLzIpJiYobltyKzFdL3MvMTAwfDApPT13KDEwLGUtMiktMXx8KHU9PXMvMnx8MD09dSkmJjA9PShuW3IrMV0vcy8xMDB8MCk6ZTw0PygwPT1lP3U9dS8xZTN8MDoxPT1lP3U9dS8xMDB8MDoyPT1lJiYodT11LzEwfDApLG89KHR8fGk8NCkmJjk5OTk9PXV8fCF0JiZpPjMmJjQ5OTk9PXUpOm89KCh0fHxpPDQpJiZ1KzE9PXN8fCF0JiZpPjMmJnUrMT09cy8yKSYmKG5bcisxXS9zLzFlM3wwKT09dygxMCxlLTMpLTEsb31mdW5jdGlvbiBTKG4sZSxpKXtmb3IodmFyIHQscixzPVswXSxvPTAsYz1uLmxlbmd0aDtvPGM7KXtmb3Iocj1zLmxlbmd0aDtyLS07KXNbcl0qPWU7Zm9yKHNbMF0rPXUuaW5kZXhPZihuLmNoYXJBdChvKyspKSx0PTA7dDxzLmxlbmd0aDt0Kyspc1t0XT5pLTEmJih2b2lkIDA9PT1zW3QrMV0mJihzW3QrMV09MCksc1t0KzFdKz1zW3RdL2l8MCxzW3RdJT1pKX1yZXR1cm4gcy5yZXZlcnNlKCl9Ty5hYnNvbHV0ZVZhbHVlPU8uYWJzPWZ1bmN0aW9uKCl7dmFyIG49bmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7cmV0dXJuIG4uczwwJiYobi5zPTEpLFAobil9LE8uY2VpbD1mdW5jdGlvbigpe3JldHVybiBQKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLHRoaXMuZSsxLDIpfSxPLmNvbXBhcmVkVG89Ty5jbXA9ZnVuY3Rpb24obil7dmFyIGUsaSx0LHIscz10aGlzLG89cy5kLHU9KG49bmV3IHMuY29uc3RydWN0b3IobikpLmQsYz1zLnMsZj1uLnM7aWYoIW98fCF1KXJldHVybiBjJiZmP2MhPT1mP2M6bz09PXU/MDohb15jPDA/MTotMTpOYU47aWYoIW9bMF18fCF1WzBdKXJldHVybiBvWzBdP2M6dVswXT8tZjowO2lmKGMhPT1mKXJldHVybiBjO2lmKHMuZSE9PW4uZSlyZXR1cm4gcy5lPm4uZV5jPDA/MTotMTtmb3IoZT0wLGk9KHQ9by5sZW5ndGgpPChyPXUubGVuZ3RoKT90OnI7ZTxpOysrZSlpZihvW2VdIT09dVtlXSlyZXR1cm4gb1tlXT51W2VdXmM8MD8xOi0xO3JldHVybiB0PT09cj8wOnQ+cl5jPDA/MTotMX0sTy5jb3NpbmU9Ty5jb3M9ZnVuY3Rpb24oKXt2YXIgbixlLGk9dGhpcyx0PWkuY29uc3RydWN0b3I7cmV0dXJuIGkuZD9pLmRbMF0/KG49dC5wcmVjaXNpb24sZT10LnJvdW5kaW5nLHQucHJlY2lzaW9uPW4rTWF0aC5tYXgoaS5lLGkuc2QoKSkreSx0LnJvdW5kaW5nPTEsaT1mdW5jdGlvbihuLGUpe3ZhciBpLHQscj1lLmQubGVuZ3RoO3I8MzI/KGk9TWF0aC5jZWlsKHIvMyksdD0oMS96KDQsaSkpLnRvU3RyaW5nKCkpOihpPTE2LHQ9XCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCIpO24ucHJlY2lzaW9uKz1pLGU9SihuLDEsZS50aW1lcyh0KSxuZXcgbigxKSk7Zm9yKHZhciBzPWk7cy0tOyl7dmFyIG89ZS50aW1lcyhlKTtlPW8udGltZXMobykubWludXMobykudGltZXMoOCkucGx1cygxKX1yZXR1cm4gbi5wcmVjaXNpb24tPWksZX0odCxHKHQsaSkpLHQucHJlY2lzaW9uPW4sdC5yb3VuZGluZz1lLFAoMj09cnx8Mz09cj9pLm5lZygpOmksbixlLCEwKSk6bmV3IHQoMSk6bmV3IHQoTmFOKX0sTy5jdWJlUm9vdD1PLmNicnQ9ZnVuY3Rpb24oKXt2YXIgbixlLGksdCxyLHMsbyx1LGMsZixhPXRoaXMsZD1hLmNvbnN0cnVjdG9yO2lmKCFhLmlzRmluaXRlKCl8fGEuaXNaZXJvKCkpcmV0dXJuIG5ldyBkKGEpO2ZvcihoPSExLChzPWEucyp3KGEucyphLDEvMykpJiZNYXRoLmFicyhzKSE9MS8wP3Q9bmV3IGQocy50b1N0cmluZygpKTooaT1EKGEuZCksKHM9KChuPWEuZSktaS5sZW5ndGgrMSklMykmJihpKz0xPT1zfHwtMj09cz9cIjBcIjpcIjAwXCIpLHM9dyhpLDEvMyksbj1tKChuKzEpLzMpLShuJTM9PShuPDA/LTE6MikpLCh0PW5ldyBkKGk9cz09MS8wP1wiNWVcIituOihpPXMudG9FeHBvbmVudGlhbCgpKS5zbGljZSgwLGkuaW5kZXhPZihcImVcIikrMSkrbikpLnM9YS5zKSxvPShuPWQucHJlY2lzaW9uKSszOzspaWYoZj0oYz0odT10KS50aW1lcyh1KS50aW1lcyh1KSkucGx1cyhhKSx0PVooZi5wbHVzKGEpLnRpbWVzKHUpLGYucGx1cyhjKSxvKzIsMSksRCh1LmQpLnNsaWNlKDAsbyk9PT0oaT1EKHQuZCkpLnNsaWNlKDAsbykpe2lmKFwiOTk5OVwiIT0oaT1pLnNsaWNlKG8tMyxvKzEpKSYmKHJ8fFwiNDk5OVwiIT1pKSl7K2kmJigraS5zbGljZSgxKXx8XCI1XCIhPWkuY2hhckF0KDApKXx8KFAodCxuKzEsMSksZT0hdC50aW1lcyh0KS50aW1lcyh0KS5lcShhKSk7YnJlYWt9aWYoIXImJihQKHUsbisxLDApLHUudGltZXModSkudGltZXModSkuZXEoYSkpKXt0PXU7YnJlYWt9bys9NCxyPTF9cmV0dXJuIGg9ITAsUCh0LG4sZC5yb3VuZGluZyxlKX0sTy5kZWNpbWFsUGxhY2VzPU8uZHA9ZnVuY3Rpb24oKXt2YXIgbixlPXRoaXMuZCxpPU5hTjtpZihlKXtpZihpPSgobj1lLmxlbmd0aC0xKS1tKHRoaXMuZS95KSkqeSxuPWVbbl0pZm9yKDtuJTEwPT0wO24vPTEwKWktLTtpPDAmJihpPTApfXJldHVybiBpfSxPLmRpdmlkZWRCeT1PLmRpdj1mdW5jdGlvbihuKXtyZXR1cm4gWih0aGlzLG5ldyB0aGlzLmNvbnN0cnVjdG9yKG4pKX0sTy5kaXZpZGVkVG9JbnRlZ2VyQnk9Ty5kaXZUb0ludD1mdW5jdGlvbihuKXt2YXIgZT10aGlzLmNvbnN0cnVjdG9yO3JldHVybiBQKFoodGhpcyxuZXcgZShuKSwwLDEsMSksZS5wcmVjaXNpb24sZS5yb3VuZGluZyl9LE8uZXF1YWxzPU8uZXE9ZnVuY3Rpb24obil7cmV0dXJuIDA9PT10aGlzLmNtcChuKX0sTy5mbG9vcj1mdW5jdGlvbigpe3JldHVybiBQKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLHRoaXMuZSsxLDMpfSxPLmdyZWF0ZXJUaGFuPU8uZ3Q9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuY21wKG4pPjB9LE8uZ3JlYXRlclRoYW5PckVxdWFsVG89Ty5ndGU9ZnVuY3Rpb24obil7dmFyIGU9dGhpcy5jbXAobik7cmV0dXJuIDE9PWV8fDA9PT1lfSxPLmh5cGVyYm9saWNDb3NpbmU9Ty5jb3NoPWZ1bmN0aW9uKCl7dmFyIG4sZSxpLHQscixzPXRoaXMsbz1zLmNvbnN0cnVjdG9yLHU9bmV3IG8oMSk7aWYoIXMuaXNGaW5pdGUoKSlyZXR1cm4gbmV3IG8ocy5zPzEvMDpOYU4pO2lmKHMuaXNaZXJvKCkpcmV0dXJuIHU7aT1vLnByZWNpc2lvbix0PW8ucm91bmRpbmcsby5wcmVjaXNpb249aStNYXRoLm1heChzLmUscy5zZCgpKSs0LG8ucm91bmRpbmc9MSwocj1zLmQubGVuZ3RoKTwzMj9lPSgxL3ooNCxuPU1hdGguY2VpbChyLzMpKSkudG9TdHJpbmcoKToobj0xNixlPVwiMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMFwiKSxzPUoobywxLHMudGltZXMoZSksbmV3IG8oMSksITApO2Zvcih2YXIgYyxmPW4sYT1uZXcgbyg4KTtmLS07KWM9cy50aW1lcyhzKSxzPXUubWludXMoYy50aW1lcyhhLm1pbnVzKGMudGltZXMoYSkpKSk7cmV0dXJuIFAocyxvLnByZWNpc2lvbj1pLG8ucm91bmRpbmc9dCwhMCl9LE8uaHlwZXJib2xpY1NpbmU9Ty5zaW5oPWZ1bmN0aW9uKCl7dmFyIG4sZSxpLHQscj10aGlzLHM9ci5jb25zdHJ1Y3RvcjtpZighci5pc0Zpbml0ZSgpfHxyLmlzWmVybygpKXJldHVybiBuZXcgcyhyKTtpZihlPXMucHJlY2lzaW9uLGk9cy5yb3VuZGluZyxzLnByZWNpc2lvbj1lK01hdGgubWF4KHIuZSxyLnNkKCkpKzQscy5yb3VuZGluZz0xLCh0PXIuZC5sZW5ndGgpPDMpcj1KKHMsMixyLHIsITApO2Vsc2V7bj0obj0xLjQqTWF0aC5zcXJ0KHQpKT4xNj8xNjowfG4scj1KKHMsMixyPXIudGltZXMoMS96KDUsbikpLHIsITApO2Zvcih2YXIgbyx1PW5ldyBzKDUpLGM9bmV3IHMoMTYpLGY9bmV3IHMoMjApO24tLTspbz1yLnRpbWVzKHIpLHI9ci50aW1lcyh1LnBsdXMoby50aW1lcyhjLnRpbWVzKG8pLnBsdXMoZikpKSl9cmV0dXJuIHMucHJlY2lzaW9uPWUscy5yb3VuZGluZz1pLFAocixlLGksITApfSxPLmh5cGVyYm9saWNUYW5nZW50PU8udGFuaD1mdW5jdGlvbigpe3ZhciBuLGUsaT10aGlzLHQ9aS5jb25zdHJ1Y3RvcjtyZXR1cm4gaS5pc0Zpbml0ZSgpP2kuaXNaZXJvKCk/bmV3IHQoaSk6KG49dC5wcmVjaXNpb24sZT10LnJvdW5kaW5nLHQucHJlY2lzaW9uPW4rNyx0LnJvdW5kaW5nPTEsWihpLnNpbmgoKSxpLmNvc2goKSx0LnByZWNpc2lvbj1uLHQucm91bmRpbmc9ZSkpOm5ldyB0KGkucyl9LE8uaW52ZXJzZUNvc2luZT1PLmFjb3M9ZnVuY3Rpb24oKXt2YXIgbixlPXRoaXMsaT1lLmNvbnN0cnVjdG9yLHQ9ZS5hYnMoKS5jbXAoMSkscj1pLnByZWNpc2lvbixzPWkucm91bmRpbmc7cmV0dXJuLTEhPT10PzA9PT10P2UuaXNOZWcoKT9VKGkscixzKTpuZXcgaSgwKTpuZXcgaShOYU4pOmUuaXNaZXJvKCk/VShpLHIrNCxzKS50aW1lcyguNSk6KGkucHJlY2lzaW9uPXIrNixpLnJvdW5kaW5nPTEsZT1lLmFzaW4oKSxuPVUoaSxyKzQscykudGltZXMoLjUpLGkucHJlY2lzaW9uPXIsaS5yb3VuZGluZz1zLG4ubWludXMoZSkpfSxPLmludmVyc2VIeXBlcmJvbGljQ29zaW5lPU8uYWNvc2g9ZnVuY3Rpb24oKXt2YXIgbixlLGk9dGhpcyx0PWkuY29uc3RydWN0b3I7cmV0dXJuIGkubHRlKDEpP25ldyB0KGkuZXEoMSk/MDpOYU4pOmkuaXNGaW5pdGUoKT8obj10LnByZWNpc2lvbixlPXQucm91bmRpbmcsdC5wcmVjaXNpb249bitNYXRoLm1heChNYXRoLmFicyhpLmUpLGkuc2QoKSkrNCx0LnJvdW5kaW5nPTEsaD0hMSxpPWkudGltZXMoaSkubWludXMoMSkuc3FydCgpLnBsdXMoaSksaD0hMCx0LnByZWNpc2lvbj1uLHQucm91bmRpbmc9ZSxpLmxuKCkpOm5ldyB0KGkpfSxPLmludmVyc2VIeXBlcmJvbGljU2luZT1PLmFzaW5oPWZ1bmN0aW9uKCl7dmFyIG4sZSxpPXRoaXMsdD1pLmNvbnN0cnVjdG9yO3JldHVybiFpLmlzRmluaXRlKCl8fGkuaXNaZXJvKCk/bmV3IHQoaSk6KG49dC5wcmVjaXNpb24sZT10LnJvdW5kaW5nLHQucHJlY2lzaW9uPW4rMipNYXRoLm1heChNYXRoLmFicyhpLmUpLGkuc2QoKSkrNix0LnJvdW5kaW5nPTEsaD0hMSxpPWkudGltZXMoaSkucGx1cygxKS5zcXJ0KCkucGx1cyhpKSxoPSEwLHQucHJlY2lzaW9uPW4sdC5yb3VuZGluZz1lLGkubG4oKSl9LE8uaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50PU8uYXRhbmg9ZnVuY3Rpb24oKXt2YXIgbixlLGksdCxyPXRoaXMscz1yLmNvbnN0cnVjdG9yO3JldHVybiByLmlzRmluaXRlKCk/ci5lPj0wP25ldyBzKHIuYWJzKCkuZXEoMSk/ci5zLzA6ci5pc1plcm8oKT9yOk5hTik6KG49cy5wcmVjaXNpb24sZT1zLnJvdW5kaW5nLHQ9ci5zZCgpLE1hdGgubWF4KHQsbik8Miotci5lLTE/UChuZXcgcyhyKSxuLGUsITApOihzLnByZWNpc2lvbj1pPXQtci5lLHI9WihyLnBsdXMoMSksbmV3IHMoMSkubWludXMociksaStuLDEpLHMucHJlY2lzaW9uPW4rNCxzLnJvdW5kaW5nPTEscj1yLmxuKCkscy5wcmVjaXNpb249bixzLnJvdW5kaW5nPWUsci50aW1lcyguNSkpKTpuZXcgcyhOYU4pfSxPLmludmVyc2VTaW5lPU8uYXNpbj1mdW5jdGlvbigpe3ZhciBuLGUsaSx0LHI9dGhpcyxzPXIuY29uc3RydWN0b3I7cmV0dXJuIHIuaXNaZXJvKCk/bmV3IHMocik6KGU9ci5hYnMoKS5jbXAoMSksaT1zLnByZWNpc2lvbix0PXMucm91bmRpbmcsLTEhPT1lPzA9PT1lPygobj1VKHMsaSs0LHQpLnRpbWVzKC41KSkucz1yLnMsbik6bmV3IHMoTmFOKToocy5wcmVjaXNpb249aSs2LHMucm91bmRpbmc9MSxyPXIuZGl2KG5ldyBzKDEpLm1pbnVzKHIudGltZXMocikpLnNxcnQoKS5wbHVzKDEpKS5hdGFuKCkscy5wcmVjaXNpb249aSxzLnJvdW5kaW5nPXQsci50aW1lcygyKSkpfSxPLmludmVyc2VUYW5nZW50PU8uYXRhbj1mdW5jdGlvbigpe3ZhciBuLGUsaSx0LHIscyxvLHUsYyxmPXRoaXMsYT1mLmNvbnN0cnVjdG9yLGQ9YS5wcmVjaXNpb24sbD1hLnJvdW5kaW5nO2lmKGYuaXNGaW5pdGUoKSl7aWYoZi5pc1plcm8oKSlyZXR1cm4gbmV3IGEoZik7aWYoZi5hYnMoKS5lcSgxKSYmZCs0PD1xKXJldHVybihvPVUoYSxkKzQsbCkudGltZXMoLjI1KSkucz1mLnMsb31lbHNle2lmKCFmLnMpcmV0dXJuIG5ldyBhKE5hTik7aWYoZCs0PD1xKXJldHVybihvPVUoYSxkKzQsbCkudGltZXMoLjUpKS5zPWYucyxvfWZvcihhLnByZWNpc2lvbj11PWQrMTAsYS5yb3VuZGluZz0xLG49aT1NYXRoLm1pbigyOCx1L3krMnwwKTtuOy0tbilmPWYuZGl2KGYudGltZXMoZikucGx1cygxKS5zcXJ0KCkucGx1cygxKSk7Zm9yKGg9ITEsZT1NYXRoLmNlaWwodS95KSx0PTEsYz1mLnRpbWVzKGYpLG89bmV3IGEoZikscj1mOy0xIT09bjspaWYocj1yLnRpbWVzKGMpLHM9by5taW51cyhyLmRpdih0Kz0yKSkscj1yLnRpbWVzKGMpLHZvaWQgMCE9PShvPXMucGx1cyhyLmRpdih0Kz0yKSkpLmRbZV0pZm9yKG49ZTtvLmRbbl09PT1zLmRbbl0mJm4tLTspO3JldHVybiBpJiYobz1vLnRpbWVzKDI8PGktMSkpLGg9ITAsUChvLGEucHJlY2lzaW9uPWQsYS5yb3VuZGluZz1sLCEwKX0sTy5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5kfSxPLmlzSW50ZWdlcj1PLmlzSW50PWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmQmJm0odGhpcy5lL3kpPnRoaXMuZC5sZW5ndGgtMn0sTy5pc05hTj1mdW5jdGlvbigpe3JldHVybiF0aGlzLnN9LE8uaXNOZWdhdGl2ZT1PLmlzTmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuczwwfSxPLmlzUG9zaXRpdmU9Ty5pc1Bvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnM+MH0sTy5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuZCYmMD09PXRoaXMuZFswXX0sTy5sZXNzVGhhbj1PLmx0PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmNtcChuKTwwfSxPLmxlc3NUaGFuT3JFcXVhbFRvPU8ubHRlPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmNtcChuKTwxfSxPLmxvZ2FyaXRobT1PLmxvZz1mdW5jdGlvbihuKXt2YXIgZSxpLHQscixzLG8sdSxjLGY9dGhpcy5jb25zdHJ1Y3RvcixhPWYucHJlY2lzaW9uLGQ9Zi5yb3VuZGluZztpZihudWxsPT1uKW49bmV3IGYoMTApLGU9ITA7ZWxzZXtpZihpPShuPW5ldyBmKG4pKS5kLG4uczwwfHwhaXx8IWlbMF18fG4uZXEoMSkpcmV0dXJuIG5ldyBmKE5hTik7ZT1uLmVxKDEwKX1pZihpPXRoaXMuZCx0aGlzLnM8MHx8IWl8fCFpWzBdfHx0aGlzLmVxKDEpKXJldHVybiBuZXcgZihpJiYhaVswXT8tMS8wOjEhPXRoaXMucz9OYU46aT8wOjEvMCk7aWYoZSlpZihpLmxlbmd0aD4xKXM9ITA7ZWxzZXtmb3Iocj1pWzBdO3IlMTA9PTA7KXIvPTEwO3M9MSE9PXJ9aWYoaD0hMSxvPVYodGhpcyx1PWErNSksdD1lP1QoZix1KzEwKTpWKG4sdSksQSgoYz1aKG8sdCx1LDEpKS5kLHI9YSxkKSlkb3tpZihvPVYodGhpcyx1Kz0xMCksdD1lP1QoZix1KzEwKTpWKG4sdSksYz1aKG8sdCx1LDEpLCFzKXsrRChjLmQpLnNsaWNlKHIrMSxyKzE1KSsxPT0xZTE0JiYoYz1QKGMsYSsxLDApKTticmVha319d2hpbGUoQShjLmQscis9MTAsZCkpO3JldHVybiBoPSEwLFAoYyxhLGQpfSxPLm1pbnVzPU8uc3ViPWZ1bmN0aW9uKG4pe3ZhciBlLGksdCxyLHMsbyx1LGMsZixhLGQsbCxwPXRoaXMsZz1wLmNvbnN0cnVjdG9yO2lmKG49bmV3IGcobiksIXAuZHx8IW4uZClyZXR1cm4gcC5zJiZuLnM/cC5kP24ucz0tbi5zOm49bmV3IGcobi5kfHxwLnMhPT1uLnM/cDpOYU4pOm49bmV3IGcoTmFOKSxuO2lmKHAucyE9bi5zKXJldHVybiBuLnM9LW4ucyxwLnBsdXMobik7aWYoZj1wLmQsbD1uLmQsdT1nLnByZWNpc2lvbixjPWcucm91bmRpbmcsIWZbMF18fCFsWzBdKXtpZihsWzBdKW4ucz0tbi5zO2Vsc2V7aWYoIWZbMF0pcmV0dXJuIG5ldyBnKDM9PT1jPy0wOjApO249bmV3IGcocCl9cmV0dXJuIGg/UChuLHUsYyk6bn1pZihpPW0obi5lL3kpLGE9bShwLmUveSksZj1mLnNsaWNlKCkscz1hLWkpe2ZvcigoZD1zPDApPyhlPWYscz0tcyxvPWwubGVuZ3RoKTooZT1sLGk9YSxvPWYubGVuZ3RoKSxzPih0PU1hdGgubWF4KE1hdGguY2VpbCh1L3kpLG8pKzIpJiYocz10LGUubGVuZ3RoPTEpLGUucmV2ZXJzZSgpLHQ9czt0LS07KWUucHVzaCgwKTtlLnJldmVyc2UoKX1lbHNle2ZvcigoZD0odD1mLmxlbmd0aCk8KG89bC5sZW5ndGgpKSYmKG89dCksdD0wO3Q8bzt0KyspaWYoZlt0XSE9bFt0XSl7ZD1mW3RdPGxbdF07YnJlYWt9cz0wfWZvcihkJiYoZT1mLGY9bCxsPWUsbi5zPS1uLnMpLG89Zi5sZW5ndGgsdD1sLmxlbmd0aC1vO3Q+MDstLXQpZltvKytdPTA7Zm9yKHQ9bC5sZW5ndGg7dD5zOyl7aWYoZlstLXRdPGxbdF0pe2ZvcihyPXQ7ciYmMD09PWZbLS1yXTspZltyXT14LTE7LS1mW3JdLGZbdF0rPXh9Zlt0XS09bFt0XX1mb3IoOzA9PT1mWy0tb107KWYucG9wKCk7Zm9yKDswPT09ZlswXTtmLnNoaWZ0KCkpLS1pO3JldHVybiBmWzBdPyhuLmQ9ZixuLmU9TChmLGkpLGg/UChuLHUsYyk6bik6bmV3IGcoMz09PWM/LTA6MCl9LE8ubW9kdWxvPU8ubW9kPWZ1bmN0aW9uKG4pe3ZhciBlLGk9dGhpcyx0PWkuY29uc3RydWN0b3I7cmV0dXJuIG49bmV3IHQobiksIWkuZHx8IW4uc3x8bi5kJiYhbi5kWzBdP25ldyB0KE5hTik6IW4uZHx8aS5kJiYhaS5kWzBdP1AobmV3IHQoaSksdC5wcmVjaXNpb24sdC5yb3VuZGluZyk6KGg9ITEsOT09dC5tb2R1bG8/KGU9WihpLG4uYWJzKCksMCwzLDEpKS5zKj1uLnM6ZT1aKGksbiwwLHQubW9kdWxvLDEpLGU9ZS50aW1lcyhuKSxoPSEwLGkubWludXMoZSkpfSxPLm5hdHVyYWxFeHBvbmVudGlhbD1PLmV4cD1mdW5jdGlvbigpe3JldHVybiBCKHRoaXMpfSxPLm5hdHVyYWxMb2dhcml0aG09Ty5sbj1mdW5jdGlvbigpe3JldHVybiBWKHRoaXMpfSxPLm5lZ2F0ZWQ9Ty5uZWc9ZnVuY3Rpb24oKXt2YXIgbj1uZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtyZXR1cm4gbi5zPS1uLnMsUChuKX0sTy5wbHVzPU8uYWRkPWZ1bmN0aW9uKG4pe3ZhciBlLGksdCxyLHMsbyx1LGMsZixhLGQ9dGhpcyxsPWQuY29uc3RydWN0b3I7aWYobj1uZXcgbChuKSwhZC5kfHwhbi5kKXJldHVybiBkLnMmJm4ucz9kLmR8fChuPW5ldyBsKG4uZHx8ZC5zPT09bi5zP2Q6TmFOKSk6bj1uZXcgbChOYU4pLG47aWYoZC5zIT1uLnMpcmV0dXJuIG4ucz0tbi5zLGQubWludXMobik7aWYoZj1kLmQsYT1uLmQsdT1sLnByZWNpc2lvbixjPWwucm91bmRpbmcsIWZbMF18fCFhWzBdKXJldHVybiBhWzBdfHwobj1uZXcgbChkKSksaD9QKG4sdSxjKTpuO2lmKHM9bShkLmUveSksdD1tKG4uZS95KSxmPWYuc2xpY2UoKSxyPXMtdCl7Zm9yKHI8MD8oaT1mLHI9LXIsbz1hLmxlbmd0aCk6KGk9YSx0PXMsbz1mLmxlbmd0aCkscj4obz0ocz1NYXRoLmNlaWwodS95KSk+bz9zKzE6bysxKSYmKHI9byxpLmxlbmd0aD0xKSxpLnJldmVyc2UoKTtyLS07KWkucHVzaCgwKTtpLnJldmVyc2UoKX1mb3IoKG89Zi5sZW5ndGgpLShyPWEubGVuZ3RoKTwwJiYocj1vLGk9YSxhPWYsZj1pKSxlPTA7cjspZT0oZlstLXJdPWZbcl0rYVtyXStlKS94fDAsZltyXSU9eDtmb3IoZSYmKGYudW5zaGlmdChlKSwrK3QpLG89Zi5sZW5ndGg7MD09ZlstLW9dOylmLnBvcCgpO3JldHVybiBuLmQ9ZixuLmU9TChmLHQpLGg/UChuLHUsYyk6bn0sTy5wcmVjaXNpb249Ty5zZD1mdW5jdGlvbihuKXt2YXIgZSxpPXRoaXM7aWYodm9pZCAwIT09biYmbiE9PSEhbiYmMSE9PW4mJjAhPT1uKXRocm93IEVycm9yKGwrbik7cmV0dXJuIGkuZD8oZT1fKGkuZCksbiYmaS5lKzE+ZSYmKGU9aS5lKzEpKTplPU5hTixlfSxPLnJvdW5kPWZ1bmN0aW9uKCl7dmFyIG49dGhpcyxlPW4uY29uc3RydWN0b3I7cmV0dXJuIFAobmV3IGUobiksbi5lKzEsZS5yb3VuZGluZyl9LE8uc2luZT1PLnNpbj1mdW5jdGlvbigpe3ZhciBuLGUsaT10aGlzLHQ9aS5jb25zdHJ1Y3RvcjtyZXR1cm4gaS5pc0Zpbml0ZSgpP2kuaXNaZXJvKCk/bmV3IHQoaSk6KG49dC5wcmVjaXNpb24sZT10LnJvdW5kaW5nLHQucHJlY2lzaW9uPW4rTWF0aC5tYXgoaS5lLGkuc2QoKSkreSx0LnJvdW5kaW5nPTEsaT1mdW5jdGlvbihuLGUpe3ZhciBpLHQ9ZS5kLmxlbmd0aDtpZih0PDMpcmV0dXJuIEoobiwyLGUsZSk7aT0oaT0xLjQqTWF0aC5zcXJ0KHQpKT4xNj8xNjowfGksZT1lLnRpbWVzKDEveig1LGkpKSxlPUoobiwyLGUsZSk7Zm9yKHZhciByLHM9bmV3IG4oNSksbz1uZXcgbigxNiksdT1uZXcgbigyMCk7aS0tOylyPWUudGltZXMoZSksZT1lLnRpbWVzKHMucGx1cyhyLnRpbWVzKG8udGltZXMocikubWludXModSkpKSk7cmV0dXJuIGV9KHQsRyh0LGkpKSx0LnByZWNpc2lvbj1uLHQucm91bmRpbmc9ZSxQKHI+Mj9pLm5lZygpOmksbixlLCEwKSk6bmV3IHQoTmFOKX0sTy5zcXVhcmVSb290PU8uc3FydD1mdW5jdGlvbigpe3ZhciBuLGUsaSx0LHIscyxvPXRoaXMsdT1vLmQsYz1vLmUsZj1vLnMsYT1vLmNvbnN0cnVjdG9yO2lmKDEhPT1mfHwhdXx8IXVbMF0pcmV0dXJuIG5ldyBhKCFmfHxmPDAmJighdXx8dVswXSk/TmFOOnU/bzoxLzApO2ZvcihoPSExLDA9PShmPU1hdGguc3FydCgrbykpfHxmPT0xLzA/KCgoZT1EKHUpKS5sZW5ndGgrYyklMj09MCYmKGUrPVwiMFwiKSxmPU1hdGguc3FydChlKSxjPW0oKGMrMSkvMiktKGM8MHx8YyUyKSx0PW5ldyBhKGU9Zj09MS8wP1wiNWVcIitjOihlPWYudG9FeHBvbmVudGlhbCgpKS5zbGljZSgwLGUuaW5kZXhPZihcImVcIikrMSkrYykpOnQ9bmV3IGEoZi50b1N0cmluZygpKSxpPShjPWEucHJlY2lzaW9uKSszOzspaWYodD0ocz10KS5wbHVzKFoobyxzLGkrMiwxKSkudGltZXMoLjUpLEQocy5kKS5zbGljZSgwLGkpPT09KGU9RCh0LmQpKS5zbGljZSgwLGkpKXtpZihcIjk5OTlcIiE9KGU9ZS5zbGljZShpLTMsaSsxKSkmJihyfHxcIjQ5OTlcIiE9ZSkpeytlJiYoK2Uuc2xpY2UoMSl8fFwiNVwiIT1lLmNoYXJBdCgwKSl8fChQKHQsYysxLDEpLG49IXQudGltZXModCkuZXEobykpO2JyZWFrfWlmKCFyJiYoUChzLGMrMSwwKSxzLnRpbWVzKHMpLmVxKG8pKSl7dD1zO2JyZWFrfWkrPTQscj0xfXJldHVybiBoPSEwLFAodCxjLGEucm91bmRpbmcsbil9LE8udGFuZ2VudD1PLnRhbj1mdW5jdGlvbigpe3ZhciBuLGUsaT10aGlzLHQ9aS5jb25zdHJ1Y3RvcjtyZXR1cm4gaS5pc0Zpbml0ZSgpP2kuaXNaZXJvKCk/bmV3IHQoaSk6KG49dC5wcmVjaXNpb24sZT10LnJvdW5kaW5nLHQucHJlY2lzaW9uPW4rMTAsdC5yb3VuZGluZz0xLChpPWkuc2luKCkpLnM9MSxpPVooaSxuZXcgdCgxKS5taW51cyhpLnRpbWVzKGkpKS5zcXJ0KCksbisxMCwwKSx0LnByZWNpc2lvbj1uLHQucm91bmRpbmc9ZSxQKDI9PXJ8fDQ9PXI/aS5uZWcoKTppLG4sZSwhMCkpOm5ldyB0KE5hTil9LE8udGltZXM9Ty5tdWw9ZnVuY3Rpb24obil7dmFyIGUsaSx0LHIscyxvLHUsYyxmLGE9dGhpcyxkPWEuY29uc3RydWN0b3IsbD1hLmQscD0obj1uZXcgZChuKSkuZDtpZihuLnMqPWEucywhKGwmJmxbMF0mJnAmJnBbMF0pKXJldHVybiBuZXcgZCghbi5zfHxsJiYhbFswXSYmIXB8fHAmJiFwWzBdJiYhbD9OYU46bCYmcD8wKm4uczpuLnMvMCk7Zm9yKGk9bShhLmUveSkrbShuLmUveSksKGM9bC5sZW5ndGgpPChmPXAubGVuZ3RoKSYmKHM9bCxsPXAscD1zLG89YyxjPWYsZj1vKSxzPVtdLHQ9bz1jK2Y7dC0tOylzLnB1c2goMCk7Zm9yKHQ9ZjstLXQ+PTA7KXtmb3IoZT0wLHI9Yyt0O3I+dDspdT1zW3JdK3BbdF0qbFtyLXQtMV0rZSxzW3ItLV09dSV4fDAsZT11L3h8MDtzW3JdPShzW3JdK2UpJXh8MH1mb3IoOyFzWy0tb107KXMucG9wKCk7cmV0dXJuIGU/KytpOnMuc2hpZnQoKSxuLmQ9cyxuLmU9TChzLGkpLGg/UChuLGQucHJlY2lzaW9uLGQucm91bmRpbmcpOm59LE8udG9CaW5hcnk9ZnVuY3Rpb24obixlKXtyZXR1cm4gSyh0aGlzLDIsbixlKX0sTy50b0RlY2ltYWxQbGFjZXM9Ty50b0RQPWZ1bmN0aW9uKG4sZSl7dmFyIGk9dGhpcyx0PWkuY29uc3RydWN0b3I7cmV0dXJuIGk9bmV3IHQoaSksdm9pZCAwPT09bj9pOihGKG4sMCxvKSx2b2lkIDA9PT1lP2U9dC5yb3VuZGluZzpGKGUsMCw4KSxQKGksbitpLmUrMSxlKSl9LE8udG9FeHBvbmVudGlhbD1mdW5jdGlvbihuLGUpe3ZhciBpLHQ9dGhpcyxyPXQuY29uc3RydWN0b3I7cmV0dXJuIHZvaWQgMD09PW4/aT1SKHQsITApOihGKG4sMCxvKSx2b2lkIDA9PT1lP2U9ci5yb3VuZGluZzpGKGUsMCw4KSxpPVIodD1QKG5ldyByKHQpLG4rMSxlKSwhMCxuKzEpKSx0LmlzTmVnKCkmJiF0LmlzWmVybygpP1wiLVwiK2k6aX0sTy50b0ZpeGVkPWZ1bmN0aW9uKG4sZSl7dmFyIGksdCxyPXRoaXMscz1yLmNvbnN0cnVjdG9yO3JldHVybiB2b2lkIDA9PT1uP2k9UihyKTooRihuLDAsbyksdm9pZCAwPT09ZT9lPXMucm91bmRpbmc6RihlLDAsOCksaT1SKHQ9UChuZXcgcyhyKSxuK3IuZSsxLGUpLCExLG4rdC5lKzEpKSxyLmlzTmVnKCkmJiFyLmlzWmVybygpP1wiLVwiK2k6aX0sTy50b0ZyYWN0aW9uPWZ1bmN0aW9uKG4pe3ZhciBlLGksdCxyLHMsbyx1LGMsZixhLGQscCxnPXRoaXMsbT1nLmQsdj1nLmNvbnN0cnVjdG9yO2lmKCFtKXJldHVybiBuZXcgdihnKTtpZihmPWk9bmV3IHYoMSksdD1jPW5ldyB2KDApLG89KHM9KGU9bmV3IHYodCkpLmU9XyhtKS1nLmUtMSkleSxlLmRbMF09dygxMCxvPDA/eStvOm8pLG51bGw9PW4pbj1zPjA/ZTpmO2Vsc2V7aWYoISh1PW5ldyB2KG4pKS5pc0ludCgpfHx1Lmx0KGYpKXRocm93IEVycm9yKGwrdSk7bj11Lmd0KGUpP3M+MD9lOmY6dX1mb3IoaD0hMSx1PW5ldyB2KEQobSkpLGE9di5wcmVjaXNpb24sdi5wcmVjaXNpb249cz1tLmxlbmd0aCp5KjI7ZD1aKHUsZSwwLDEsMSksMSE9KHI9aS5wbHVzKGQudGltZXModCkpKS5jbXAobik7KWk9dCx0PXIscj1mLGY9Yy5wbHVzKGQudGltZXMocikpLGM9cixyPWUsZT11Lm1pbnVzKGQudGltZXMocikpLHU9cjtyZXR1cm4gcj1aKG4ubWludXMoaSksdCwwLDEsMSksYz1jLnBsdXMoci50aW1lcyhmKSksaT1pLnBsdXMoci50aW1lcyh0KSksYy5zPWYucz1nLnMscD1aKGYsdCxzLDEpLm1pbnVzKGcpLmFicygpLmNtcChaKGMsaSxzLDEpLm1pbnVzKGcpLmFicygpKTwxP1tmLHRdOltjLGldLHYucHJlY2lzaW9uPWEsaD0hMCxwfSxPLnRvSGV4YWRlY2ltYWw9Ty50b0hleD1mdW5jdGlvbihuLGUpe3JldHVybiBLKHRoaXMsMTYsbixlKX0sTy50b05lYXJlc3Q9ZnVuY3Rpb24obixlKXt2YXIgaT10aGlzLHQ9aS5jb25zdHJ1Y3RvcjtpZihpPW5ldyB0KGkpLG51bGw9PW4pe2lmKCFpLmQpcmV0dXJuIGk7bj1uZXcgdCgxKSxlPXQucm91bmRpbmd9ZWxzZXtpZihuPW5ldyB0KG4pLHZvaWQgMD09PWU/ZT10LnJvdW5kaW5nOkYoZSwwLDgpLCFpLmQpcmV0dXJuIG4ucz9pOm47aWYoIW4uZClyZXR1cm4gbi5zJiYobi5zPWkucyksbn1yZXR1cm4gbi5kWzBdPyhoPSExLGk9WihpLG4sMCxlLDEpLnRpbWVzKG4pLGg9ITAsUChpKSk6KG4ucz1pLnMsaT1uKSxpfSxPLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuK3RoaXN9LE8udG9PY3RhbD1mdW5jdGlvbihuLGUpe3JldHVybiBLKHRoaXMsOCxuLGUpfSxPLnRvUG93ZXI9Ty5wb3c9ZnVuY3Rpb24obil7dmFyIGUsaSx0LHIscyxvLHU9dGhpcyxjPXUuY29uc3RydWN0b3IsZj0rKG49bmV3IGMobikpO2lmKCEodS5kJiZuLmQmJnUuZFswXSYmbi5kWzBdKSlyZXR1cm4gbmV3IGModygrdSxmKSk7aWYoKHU9bmV3IGModSkpLmVxKDEpKXJldHVybiB1O2lmKHQ9Yy5wcmVjaXNpb24scz1jLnJvdW5kaW5nLG4uZXEoMSkpcmV0dXJuIFAodSx0LHMpO2lmKChlPW0obi5lL3kpKT49bi5kLmxlbmd0aC0xJiYoaT1mPDA/LWY6Zik8PTkwMDcxOTkyNTQ3NDA5OTEpcmV0dXJuIHI9QyhjLHUsaSx0KSxuLnM8MD9uZXcgYygxKS5kaXYocik6UChyLHQscyk7aWYoKG89dS5zKTwwKXtpZihlPG4uZC5sZW5ndGgtMSlyZXR1cm4gbmV3IGMoTmFOKTtpZigwPT0oMSZuLmRbZV0pJiYobz0xKSwwPT11LmUmJjE9PXUuZFswXSYmMT09dS5kLmxlbmd0aClyZXR1cm4gdS5zPW8sdX1yZXR1cm4oZT0wIT0oaT13KCt1LGYpKSYmaXNGaW5pdGUoaSk/bmV3IGMoaStcIlwiKS5lOm0oZiooTWF0aC5sb2coXCIwLlwiK0QodS5kKSkvTWF0aC5MTjEwK3UuZSsxKSkpPmMubWF4RSsxfHxlPGMubWluRS0xP25ldyBjKGU+MD9vLzA6MCk6KGg9ITEsYy5yb3VuZGluZz11LnM9MSxpPU1hdGgubWluKDEyLChlK1wiXCIpLmxlbmd0aCksKHI9QihuLnRpbWVzKFYodSx0K2kpKSx0KSkuZCYmQSgocj1QKHIsdCs1LDEpKS5kLHQscykmJihlPXQrMTAsK0QoKHI9UChCKG4udGltZXMoVih1LGUraSkpLGUpLGUrNSwxKSkuZCkuc2xpY2UodCsxLHQrMTUpKzE9PTFlMTQmJihyPVAocix0KzEsMCkpKSxyLnM9byxoPSEwLGMucm91bmRpbmc9cyxQKHIsdCxzKSl9LE8udG9QcmVjaXNpb249ZnVuY3Rpb24obixlKXt2YXIgaSx0PXRoaXMscj10LmNvbnN0cnVjdG9yO3JldHVybiB2b2lkIDA9PT1uP2k9Uih0LHQuZTw9ci50b0V4cE5lZ3x8dC5lPj1yLnRvRXhwUG9zKTooRihuLDEsbyksdm9pZCAwPT09ZT9lPXIucm91bmRpbmc6RihlLDAsOCksaT1SKHQ9UChuZXcgcih0KSxuLGUpLG48PXQuZXx8dC5lPD1yLnRvRXhwTmVnLG4pKSx0LmlzTmVnKCkmJiF0LmlzWmVybygpP1wiLVwiK2k6aX0sTy50b1NpZ25pZmljYW50RGlnaXRzPU8udG9TRD1mdW5jdGlvbihuLGUpe3ZhciBpPXRoaXMuY29uc3RydWN0b3I7cmV0dXJuIHZvaWQgMD09PW4/KG49aS5wcmVjaXNpb24sZT1pLnJvdW5kaW5nKTooRihuLDEsbyksdm9pZCAwPT09ZT9lPWkucm91bmRpbmc6RihlLDAsOCkpLFAobmV3IGkodGhpcyksbixlKX0sTy50b1N0cmluZz1mdW5jdGlvbigpe3ZhciBuPXRoaXMsZT1uLmNvbnN0cnVjdG9yLGk9UihuLG4uZTw9ZS50b0V4cE5lZ3x8bi5lPj1lLnRvRXhwUG9zKTtyZXR1cm4gbi5pc05lZygpJiYhbi5pc1plcm8oKT9cIi1cIitpOml9LE8udHJ1bmNhdGVkPU8udHJ1bmM9ZnVuY3Rpb24oKXtyZXR1cm4gUChuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSx0aGlzLmUrMSwxKX0sTy52YWx1ZU9mPU8udG9KU09OPWZ1bmN0aW9uKCl7dmFyIG49dGhpcyxlPW4uY29uc3RydWN0b3IsaT1SKG4sbi5lPD1lLnRvRXhwTmVnfHxuLmU+PWUudG9FeHBQb3MpO3JldHVybiBuLmlzTmVnKCk/XCItXCIraTppfTt2YXIgWj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixlLGkpe3ZhciB0LHI9MCxzPW4ubGVuZ3RoO2ZvcihuPW4uc2xpY2UoKTtzLS07KXQ9bltzXSplK3IsbltzXT10JWl8MCxyPXQvaXwwO3JldHVybiByJiZuLnVuc2hpZnQociksbn1mdW5jdGlvbiBlKG4sZSxpLHQpe3ZhciByLHM7aWYoaSE9dClzPWk+dD8xOi0xO2Vsc2UgZm9yKHI9cz0wO3I8aTtyKyspaWYobltyXSE9ZVtyXSl7cz1uW3JdPmVbcl0/MTotMTticmVha31yZXR1cm4gc31mdW5jdGlvbiB0KG4sZSxpLHQpe2Zvcih2YXIgcj0wO2ktLTspbltpXS09cixyPW5baV08ZVtpXT8xOjAsbltpXT1yKnQrbltpXS1lW2ldO2Zvcig7IW5bMF0mJm4ubGVuZ3RoPjE7KW4uc2hpZnQoKX1yZXR1cm4gZnVuY3Rpb24ocixzLG8sdSxjLGYpe3ZhciBhLGgsZCxsLHAsZyx3LHYsTixiLEUsTSxxLE8sRCxGLEEsUyxaLFIsTD1yLmNvbnN0cnVjdG9yLFQ9ci5zPT1zLnM/MTotMSxVPXIuZCxfPXMuZDtpZighKFUmJlVbMF0mJl8mJl9bMF0pKXJldHVybiBuZXcgTChyLnMmJnMucyYmKFU/IV98fFVbMF0hPV9bMF06Xyk/VSYmMD09VVswXXx8IV8/MCpUOlQvMDpOYU4pO2ZvcihmPyhwPTEsaD1yLmUtcy5lKTooZj14LHA9eSxoPW0oci5lL3ApLW0ocy5lL3ApKSxaPV8ubGVuZ3RoLEE9VS5sZW5ndGgsYj0oTj1uZXcgTChUKSkuZD1bXSxkPTA7X1tkXT09KFVbZF18fDApO2QrKyk7aWYoX1tkXT4oVVtkXXx8MCkmJmgtLSxudWxsPT1vPyhPPW89TC5wcmVjaXNpb24sdT1MLnJvdW5kaW5nKTpPPWM/bysoci5lLXMuZSkrMTpvLE88MCliLnB1c2goMSksZz0hMDtlbHNle2lmKE89Ty9wKzJ8MCxkPTAsMT09Wil7Zm9yKGw9MCxfPV9bMF0sTysrOyhkPEF8fGwpJiZPLS07ZCsrKUQ9bCpmKyhVW2RdfHwwKSxiW2RdPUQvX3wwLGw9RCVffDA7Zz1sfHxkPEF9ZWxzZXtmb3IoKGw9Zi8oX1swXSsxKXwwKT4xJiYoXz1uKF8sbCxmKSxVPW4oVSxsLGYpLFo9Xy5sZW5ndGgsQT1VLmxlbmd0aCksRj1aLE09KEU9VS5zbGljZSgwLFopKS5sZW5ndGg7TTxaOylFW00rK109MDsoUj1fLnNsaWNlKCkpLnVuc2hpZnQoMCksUz1fWzBdLF9bMV0+PWYvMiYmKytTO2Rve2w9MCwoYT1lKF8sRSxaLE0pKTwwPyhxPUVbMF0sWiE9TSYmKHE9cSpmKyhFWzFdfHwwKSksKGw9cS9TfDApPjE/KGw+PWYmJihsPWYtMSksMT09KGE9ZSh3PW4oXyxsLGYpLEUsdj13Lmxlbmd0aCxNPUUubGVuZ3RoKSkmJihsLS0sdCh3LFo8dj9SOl8sdixmKSkpOigwPT1sJiYoYT1sPTEpLHc9Xy5zbGljZSgpKSwodj13Lmxlbmd0aCk8TSYmdy51bnNoaWZ0KDApLHQoRSx3LE0sZiksLTE9PWEmJihhPWUoXyxFLFosTT1FLmxlbmd0aCkpPDEmJihsKyssdChFLFo8TT9SOl8sTSxmKSksTT1FLmxlbmd0aCk6MD09PWEmJihsKyssRT1bMF0pLGJbZCsrXT1sLGEmJkVbMF0/RVtNKytdPVVbRl18fDA6KEU9W1VbRl1dLE09MSl9d2hpbGUoKEYrKzxBfHx2b2lkIDAhPT1FWzBdKSYmTy0tKTtnPXZvaWQgMCE9PUVbMF19YlswXXx8Yi5zaGlmdCgpfWlmKDE9PXApTi5lPWgsaT1nO2Vsc2V7Zm9yKGQ9MSxsPWJbMF07bD49MTA7bC89MTApZCsrO04uZT1kK2gqcC0xLFAoTixjP28rTi5lKzE6byx1LGcpfXJldHVybiBOfX0oKTtmdW5jdGlvbiBQKG4sZSxpLHQpe3ZhciByLHMsbyx1LGMsZixhLGQsbCxwPW4uY29uc3RydWN0b3I7bjppZihudWxsIT1lKXtpZighKGQ9bi5kKSlyZXR1cm4gbjtmb3Iocj0xLHU9ZFswXTt1Pj0xMDt1Lz0xMClyKys7aWYoKHM9ZS1yKTwwKXMrPXksbz1lLGM9KGE9ZFtsPTBdKS93KDEwLHItby0xKSUxMHwwO2Vsc2UgaWYoKGw9TWF0aC5jZWlsKChzKzEpL3kpKT49KHU9ZC5sZW5ndGgpKXtpZighdClicmVhayBuO2Zvcig7dSsrPD1sOylkLnB1c2goMCk7YT1jPTAscj0xLG89KHMlPXkpLXkrMX1lbHNle2ZvcihhPXU9ZFtsXSxyPTE7dT49MTA7dS89MTApcisrO2M9KG89KHMlPXkpLXkrcik8MD8wOmEvdygxMCxyLW8tMSklMTB8MH1pZih0PXR8fGU8MHx8dm9pZCAwIT09ZFtsKzFdfHwobzwwP2E6YSV3KDEwLHItby0xKSksZj1pPDQ/KGN8fHQpJiYoMD09aXx8aT09KG4uczwwPzM6MikpOmM+NXx8NT09YyYmKDQ9PWl8fHR8fDY9PWkmJihzPjA/bz4wP2EvdygxMCxyLW8pOjA6ZFtsLTFdKSUxMCYxfHxpPT0obi5zPDA/ODo3KSksZTwxfHwhZFswXSlyZXR1cm4gZC5sZW5ndGg9MCxmPyhlLT1uLmUrMSxkWzBdPXcoMTAsKHktZSV5KSV5KSxuLmU9LWV8fDApOmRbMF09bi5lPTAsbjtpZigwPT1zPyhkLmxlbmd0aD1sLHU9MSxsLS0pOihkLmxlbmd0aD1sKzEsdT13KDEwLHktcyksZFtsXT1vPjA/KGEvdygxMCxyLW8pJXcoMTAsbyl8MCkqdTowKSxmKWZvcig7Oyl7aWYoMD09bCl7Zm9yKHM9MSxvPWRbMF07bz49MTA7by89MTApcysrO2ZvcihvPWRbMF0rPXUsdT0xO28+PTEwO28vPTEwKXUrKztzIT11JiYobi5lKyssZFswXT09eCYmKGRbMF09MSkpO2JyZWFrfWlmKGRbbF0rPXUsZFtsXSE9eClicmVhaztkW2wtLV09MCx1PTF9Zm9yKHM9ZC5sZW5ndGg7MD09PWRbLS1zXTspZC5wb3AoKX1yZXR1cm4gaCYmKG4uZT5wLm1heEU/KG4uZD1udWxsLG4uZT1OYU4pOm4uZTxwLm1pbkUmJihuLmU9MCxuLmQ9WzBdKSksbn1mdW5jdGlvbiBSKG4sZSxpKXtpZighbi5pc0Zpbml0ZSgpKXJldHVybiBqKG4pO3ZhciB0LHI9bi5lLHM9RChuLmQpLG89cy5sZW5ndGg7cmV0dXJuIGU/KGkmJih0PWktbyk+MD9zPXMuY2hhckF0KDApK1wiLlwiK3Muc2xpY2UoMSkrayh0KTpvPjEmJihzPXMuY2hhckF0KDApK1wiLlwiK3Muc2xpY2UoMSkpLHM9cysobi5lPDA/XCJlXCI6XCJlK1wiKStuLmUpOnI8MD8ocz1cIjAuXCIraygtci0xKStzLGkmJih0PWktbyk+MCYmKHMrPWsodCkpKTpyPj1vPyhzKz1rKHIrMS1vKSxpJiYodD1pLXItMSk+MCYmKHM9cytcIi5cIitrKHQpKSk6KCh0PXIrMSk8byYmKHM9cy5zbGljZSgwLHQpK1wiLlwiK3Muc2xpY2UodCkpLGkmJih0PWktbyk+MCYmKHIrMT09PW8mJihzKz1cIi5cIikscys9ayh0KSkpLHN9ZnVuY3Rpb24gTChuLGUpe3ZhciBpPW5bMF07Zm9yKGUqPXk7aT49MTA7aS89MTApZSsrO3JldHVybiBlfWZ1bmN0aW9uIFQobixlLGkpe2lmKGU+TSl0aHJvdyBoPSEwLGkmJihuLnByZWNpc2lvbj1pKSxFcnJvcihwKTtyZXR1cm4gUChuZXcgbihjKSxlLDEsITApfWZ1bmN0aW9uIFUobixlLGkpe2lmKGU+cSl0aHJvdyBFcnJvcihwKTtyZXR1cm4gUChuZXcgbihmKSxlLGksITApfWZ1bmN0aW9uIF8obil7dmFyIGU9bi5sZW5ndGgtMSxpPWUqeSsxO2lmKGU9bltlXSl7Zm9yKDtlJTEwPT0wO2UvPTEwKWktLTtmb3IoZT1uWzBdO2U+PTEwO2UvPTEwKWkrK31yZXR1cm4gaX1mdW5jdGlvbiBrKG4pe2Zvcih2YXIgZT1cIlwiO24tLTspZSs9XCIwXCI7cmV0dXJuIGV9ZnVuY3Rpb24gQyhuLGUsaSx0KXt2YXIgcixzPW5ldyBuKDEpLG89TWF0aC5jZWlsKHQveSs0KTtmb3IoaD0hMTs7KXtpZihpJTImJlEoKHM9cy50aW1lcyhlKSkuZCxvKSYmKHI9ITApLDA9PT0oaT1tKGkvMikpKXtpPXMuZC5sZW5ndGgtMSxyJiYwPT09cy5kW2ldJiYrK3MuZFtpXTticmVha31RKChlPWUudGltZXMoZSkpLmQsbyl9cmV0dXJuIGg9ITAsc31mdW5jdGlvbiBJKG4pe3JldHVybiAxJm4uZFtuLmQubGVuZ3RoLTFdfWZ1bmN0aW9uIEgobixlLGkpe2Zvcih2YXIgdCxyPW5ldyBuKGVbMF0pLHM9MDsrK3M8ZS5sZW5ndGg7KXtpZighKHQ9bmV3IG4oZVtzXSkpLnMpe3I9dDticmVha31yW2ldKHQpJiYocj10KX1yZXR1cm4gcn1mdW5jdGlvbiBCKG4sZSl7dmFyIGksdCxyLHMsbyx1LGMsZj0wLGE9MCxkPTAsbD1uLmNvbnN0cnVjdG9yLHA9bC5yb3VuZGluZyxnPWwucHJlY2lzaW9uO2lmKCFuLmR8fCFuLmRbMF18fG4uZT4xNylyZXR1cm4gbmV3IGwobi5kP24uZFswXT9uLnM8MD8wOjEvMDoxOm4ucz9uLnM8MD8wOm46TmFOKTtmb3IobnVsbD09ZT8oaD0hMSxjPWcpOmM9ZSx1PW5ldyBsKC4wMzEyNSk7bi5lPi0yOyluPW4udGltZXModSksZCs9NTtmb3IoYys9dD1NYXRoLmxvZyh3KDIsZCkpL01hdGguTE4xMCoyKzV8MCxpPXM9bz1uZXcgbCgxKSxsLnByZWNpc2lvbj1jOzspe2lmKHM9UChzLnRpbWVzKG4pLGMsMSksaT1pLnRpbWVzKCsrYSksRCgodT1vLnBsdXMoWihzLGksYywxKSkpLmQpLnNsaWNlKDAsYyk9PT1EKG8uZCkuc2xpY2UoMCxjKSl7Zm9yKHI9ZDtyLS07KW89UChvLnRpbWVzKG8pLGMsMSk7aWYobnVsbCE9ZSlyZXR1cm4gbC5wcmVjaXNpb249ZyxvO2lmKCEoZjwzJiZBKG8uZCxjLXQscCxmKSkpcmV0dXJuIFAobyxsLnByZWNpc2lvbj1nLHAsaD0hMCk7bC5wcmVjaXNpb249Yys9MTAsaT1zPXU9bmV3IGwoMSksYT0wLGYrK31vPXV9fWZ1bmN0aW9uIFYobixlKXt2YXIgaSx0LHIscyxvLHUsYyxmLGEsZCxsLHA9MSxnPW4sbT1nLmQsdz1nLmNvbnN0cnVjdG9yLHY9dy5yb3VuZGluZyxOPXcucHJlY2lzaW9uO2lmKGcuczwwfHwhbXx8IW1bMF18fCFnLmUmJjE9PW1bMF0mJjE9PW0ubGVuZ3RoKXJldHVybiBuZXcgdyhtJiYhbVswXT8tMS8wOjEhPWcucz9OYU46bT8wOmcpO2lmKG51bGw9PWU/KGg9ITEsYT1OKTphPWUsdy5wcmVjaXNpb249YSs9MTAsdD0oaT1EKG0pKS5jaGFyQXQoMCksIShNYXRoLmFicyhzPWcuZSk8MTVlMTQpKXJldHVybiBmPVQodyxhKzIsTikudGltZXMocytcIlwiKSxnPVYobmV3IHcodCtcIi5cIitpLnNsaWNlKDEpKSxhLTEwKS5wbHVzKGYpLHcucHJlY2lzaW9uPU4sbnVsbD09ZT9QKGcsTix2LGg9ITApOmc7Zm9yKDt0PDcmJjEhPXR8fDE9PXQmJmkuY2hhckF0KDEpPjM7KXQ9KGk9RCgoZz1nLnRpbWVzKG4pKS5kKSkuY2hhckF0KDApLHArKztmb3Iocz1nLmUsdD4xPyhnPW5ldyB3KFwiMC5cIitpKSxzKyspOmc9bmV3IHcodCtcIi5cIitpLnNsaWNlKDEpKSxkPWcsYz1vPWc9WihnLm1pbnVzKDEpLGcucGx1cygxKSxhLDEpLGw9UChnLnRpbWVzKGcpLGEsMSkscj0zOzspe2lmKG89UChvLnRpbWVzKGwpLGEsMSksRCgoZj1jLnBsdXMoWihvLG5ldyB3KHIpLGEsMSkpKS5kKS5zbGljZSgwLGEpPT09RChjLmQpLnNsaWNlKDAsYSkpe2lmKGM9Yy50aW1lcygyKSwwIT09cyYmKGM9Yy5wbHVzKFQodyxhKzIsTikudGltZXMocytcIlwiKSkpLGM9WihjLG5ldyB3KHApLGEsMSksbnVsbCE9ZSlyZXR1cm4gdy5wcmVjaXNpb249TixjO2lmKCFBKGMuZCxhLTEwLHYsdSkpcmV0dXJuIFAoYyx3LnByZWNpc2lvbj1OLHYsaD0hMCk7dy5wcmVjaXNpb249YSs9MTAsZj1vPWc9WihkLm1pbnVzKDEpLGQucGx1cygxKSxhLDEpLGw9UChnLnRpbWVzKGcpLGEsMSkscj11PTF9Yz1mLHIrPTJ9fWZ1bmN0aW9uIGoobil7cmV0dXJuIFN0cmluZyhuLnMqbi5zLzApfWZ1bmN0aW9uICQobixlKXt2YXIgaSx0LHI7Zm9yKChpPWUuaW5kZXhPZihcIi5cIikpPi0xJiYoZT1lLnJlcGxhY2UoXCIuXCIsXCJcIikpLCh0PWUuc2VhcmNoKC9lL2kpKT4wPyhpPDAmJihpPXQpLGkrPStlLnNsaWNlKHQrMSksZT1lLnN1YnN0cmluZygwLHQpKTppPDAmJihpPWUubGVuZ3RoKSx0PTA7NDg9PT1lLmNoYXJDb2RlQXQodCk7dCsrKTtmb3Iocj1lLmxlbmd0aDs0OD09PWUuY2hhckNvZGVBdChyLTEpOy0tcik7aWYoZT1lLnNsaWNlKHQscikpe2lmKHItPXQsbi5lPWk9aS10LTEsbi5kPVtdLHQ9KGkrMSkleSxpPDAmJih0Kz15KSx0PHIpe2Zvcih0JiZuLmQucHVzaCgrZS5zbGljZSgwLHQpKSxyLT15O3Q8cjspbi5kLnB1c2goK2Uuc2xpY2UodCx0Kz15KSk7ZT1lLnNsaWNlKHQpLHQ9eS1lLmxlbmd0aH1lbHNlIHQtPXI7Zm9yKDt0LS07KWUrPVwiMFwiO24uZC5wdXNoKCtlKSxoJiYobi5lPm4uY29uc3RydWN0b3IubWF4RT8obi5kPW51bGwsbi5lPU5hTik6bi5lPG4uY29uc3RydWN0b3IubWluRSYmKG4uZT0wLG4uZD1bMF0pKX1lbHNlIG4uZT0wLG4uZD1bMF07cmV0dXJuIG59ZnVuY3Rpb24gVyhuLGkpe3ZhciB0LHIscyxvLHUsYyxmLGEsZDtpZihcIkluZmluaXR5XCI9PT1pfHxcIk5hTlwiPT09aSlyZXR1cm4raXx8KG4ucz1OYU4pLG4uZT1OYU4sbi5kPW51bGwsbjtpZihOLnRlc3QoaSkpdD0xNixpPWkudG9Mb3dlckNhc2UoKTtlbHNlIGlmKHYudGVzdChpKSl0PTI7ZWxzZXtpZighYi50ZXN0KGkpKXRocm93IEVycm9yKGwraSk7dD04fWZvcigobz1pLnNlYXJjaCgvcC9pKSk+MD8oZj0raS5zbGljZShvKzEpLGk9aS5zdWJzdHJpbmcoMixvKSk6aT1pLnNsaWNlKDIpLHU9KG89aS5pbmRleE9mKFwiLlwiKSk+PTAscj1uLmNvbnN0cnVjdG9yLHUmJihvPShjPShpPWkucmVwbGFjZShcIi5cIixcIlwiKSkubGVuZ3RoKS1vLHM9QyhyLG5ldyByKHQpLG8sMipvKSksbz1kPShhPVMoaSx0LHgpKS5sZW5ndGgtMTswPT09YVtvXTstLW8pYS5wb3AoKTtyZXR1cm4gbzwwP25ldyByKDAqbi5zKToobi5lPUwoYSxkKSxuLmQ9YSxoPSExLHUmJihuPVoobixzLDQqYykpLGYmJihuPW4udGltZXMoTWF0aC5hYnMoZik8NTQ/dygyLGYpOmUucG93KDIsZikpKSxoPSEwLG4pfWZ1bmN0aW9uIEoobixlLGksdCxyKXt2YXIgcyxvLHUsYyxmPW4ucHJlY2lzaW9uLGE9TWF0aC5jZWlsKGYveSk7Zm9yKGg9ITEsYz1pLnRpbWVzKGkpLHU9bmV3IG4odCk7Oyl7aWYobz1aKHUudGltZXMoYyksbmV3IG4oZSsrKmUrKyksZiwxKSx1PXI/dC5wbHVzKG8pOnQubWludXMobyksdD1aKG8udGltZXMoYyksbmV3IG4oZSsrKmUrKyksZiwxKSx2b2lkIDAhPT0obz11LnBsdXModCkpLmRbYV0pe2ZvcihzPWE7by5kW3NdPT09dS5kW3NdJiZzLS07KTtpZigtMT09cylicmVha31zPXUsdT10LHQ9byxvPXMsMH1yZXR1cm4gaD0hMCxvLmQubGVuZ3RoPWErMSxvfWZ1bmN0aW9uIHoobixlKXtmb3IodmFyIGk9bjstLWU7KWkqPW47cmV0dXJuIGl9ZnVuY3Rpb24gRyhuLGUpe3ZhciBpLHQ9ZS5zPDAscz1VKG4sbi5wcmVjaXNpb24sMSksbz1zLnRpbWVzKC41KTtpZigoZT1lLmFicygpKS5sdGUobykpcmV0dXJuIHI9dD80OjEsZTtpZigoaT1lLmRpdlRvSW50KHMpKS5pc1plcm8oKSlyPXQ/MzoyO2Vsc2V7aWYoKGU9ZS5taW51cyhpLnRpbWVzKHMpKSkubHRlKG8pKXJldHVybiByPUkoaSk/dD8yOjM6dD80OjEsZTtyPUkoaSk/dD8xOjQ6dD8zOjJ9cmV0dXJuIGUubWludXMocykuYWJzKCl9ZnVuY3Rpb24gSyhuLGUsdCxyKXt2YXIgcyxjLGYsYSxoLGQsbCxwLGcsbT1uLmNvbnN0cnVjdG9yLHc9dm9pZCAwIT09dDtpZih3PyhGKHQsMSxvKSx2b2lkIDA9PT1yP3I9bS5yb3VuZGluZzpGKHIsMCw4KSk6KHQ9bS5wcmVjaXNpb24scj1tLnJvdW5kaW5nKSxuLmlzRmluaXRlKCkpe2Zvcih3PyhzPTIsMTY9PWU/dD00KnQtMzo4PT1lJiYodD0zKnQtMikpOnM9ZSwoZj0obD1SKG4pKS5pbmRleE9mKFwiLlwiKSk+PTAmJihsPWwucmVwbGFjZShcIi5cIixcIlwiKSwoZz1uZXcgbSgxKSkuZT1sLmxlbmd0aC1mLGcuZD1TKFIoZyksMTAscyksZy5lPWcuZC5sZW5ndGgpLGM9aD0ocD1TKGwsMTAscykpLmxlbmd0aDswPT1wWy0taF07KXAucG9wKCk7aWYocFswXSl7aWYoZjwwP2MtLTooKG49bmV3IG0obikpLmQ9cCxuLmU9YyxwPShuPVoobixnLHQsciwwLHMpKS5kLGM9bi5lLGQ9aSksZj1wW3RdLGE9cy8yLGQ9ZHx8dm9pZCAwIT09cFt0KzFdLGQ9cjw0Pyh2b2lkIDAhPT1mfHxkKSYmKDA9PT1yfHxyPT09KG4uczwwPzM6MikpOmY+YXx8Zj09PWEmJig0PT09cnx8ZHx8Nj09PXImJjEmcFt0LTFdfHxyPT09KG4uczwwPzg6NykpLHAubGVuZ3RoPXQsZClmb3IoOysrcFstLXRdPnMtMTspcFt0XT0wLHR8fCgrK2MscC51bnNoaWZ0KDEpKTtmb3IoaD1wLmxlbmd0aDshcFtoLTFdOy0taCk7Zm9yKGY9MCxsPVwiXCI7ZjxoO2YrKylsKz11LmNoYXJBdChwW2ZdKTtpZih3KXtpZihoPjEpaWYoMTY9PWV8fDg9PWUpe2ZvcihmPTE2PT1lPzQ6MywtLWg7aCVmO2grKylsKz1cIjBcIjtmb3IoaD0ocD1TKGwscyxlKSkubGVuZ3RoOyFwW2gtMV07LS1oKTtmb3IoZj0xLGw9XCIxLlwiO2Y8aDtmKyspbCs9dS5jaGFyQXQocFtmXSl9ZWxzZSBsPWwuY2hhckF0KDApK1wiLlwiK2wuc2xpY2UoMSk7bD1sKyhjPDA/XCJwXCI6XCJwK1wiKStjfWVsc2UgaWYoYzwwKXtmb3IoOysrYzspbD1cIjBcIitsO2w9XCIwLlwiK2x9ZWxzZSBpZigrK2M+aClmb3IoYy09aDtjLS07KWwrPVwiMFwiO2Vsc2UgYzxoJiYobD1sLnNsaWNlKDAsYykrXCIuXCIrbC5zbGljZShjKSl9ZWxzZSBsPXc/XCIwcCswXCI6XCIwXCI7bD0oMTY9PWU/XCIweFwiOjI9PWU/XCIwYlwiOjg9PWU/XCIwb1wiOlwiXCIpK2x9ZWxzZSBsPWoobik7cmV0dXJuIG4uczwwP1wiLVwiK2w6bH1mdW5jdGlvbiBRKG4sZSl7aWYobi5sZW5ndGg+ZSlyZXR1cm4gbi5sZW5ndGg9ZSwhMH1mdW5jdGlvbiBYKG4pe3JldHVybiBuZXcgdGhpcyhuKS5hYnMoKX1mdW5jdGlvbiBZKG4pe3JldHVybiBuZXcgdGhpcyhuKS5hY29zKCl9ZnVuY3Rpb24gbm4obil7cmV0dXJuIG5ldyB0aGlzKG4pLmFjb3NoKCl9ZnVuY3Rpb24gZW4obixlKXtyZXR1cm4gbmV3IHRoaXMobikucGx1cyhlKX1mdW5jdGlvbiB0bihuKXtyZXR1cm4gbmV3IHRoaXMobikuYXNpbigpfWZ1bmN0aW9uIHJuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5hc2luaCgpfWZ1bmN0aW9uIHNuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5hdGFuKCl9ZnVuY3Rpb24gb24obil7cmV0dXJuIG5ldyB0aGlzKG4pLmF0YW5oKCl9ZnVuY3Rpb24gdW4obixlKXtuPW5ldyB0aGlzKG4pLGU9bmV3IHRoaXMoZSk7dmFyIGksdD10aGlzLnByZWNpc2lvbixyPXRoaXMucm91bmRpbmcscz10KzQ7cmV0dXJuIG4ucyYmZS5zP24uZHx8ZS5kPyFlLmR8fG4uaXNaZXJvKCk/KGk9ZS5zPDA/VSh0aGlzLHQscik6bmV3IHRoaXMoMCkpLnM9bi5zOiFuLmR8fGUuaXNaZXJvKCk/KGk9VSh0aGlzLHMsMSkudGltZXMoLjUpKS5zPW4uczplLnM8MD8odGhpcy5wcmVjaXNpb249cyx0aGlzLnJvdW5kaW5nPTEsaT10aGlzLmF0YW4oWihuLGUscywxKSksZT1VKHRoaXMscywxKSx0aGlzLnByZWNpc2lvbj10LHRoaXMucm91bmRpbmc9cixpPW4uczwwP2kubWludXMoZSk6aS5wbHVzKGUpKTppPXRoaXMuYXRhbihaKG4sZSxzLDEpKTooaT1VKHRoaXMscywxKS50aW1lcyhlLnM+MD8uMjU6Ljc1KSkucz1uLnM6aT1uZXcgdGhpcyhOYU4pLGl9ZnVuY3Rpb24gY24obil7cmV0dXJuIG5ldyB0aGlzKG4pLmNicnQoKX1mdW5jdGlvbiBmbihuKXtyZXR1cm4gUChuPW5ldyB0aGlzKG4pLG4uZSsxLDIpfWZ1bmN0aW9uIGFuKG4pe2lmKCFufHxcIm9iamVjdFwiIT10eXBlb2Ygbil0aHJvdyBFcnJvcihkK1wiT2JqZWN0IGV4cGVjdGVkXCIpO3ZhciBlLGksdCxyPSEwPT09bi5kZWZhdWx0cyx1PVtcInByZWNpc2lvblwiLDEsbyxcInJvdW5kaW5nXCIsMCw4LFwidG9FeHBOZWdcIiwtcywwLFwidG9FeHBQb3NcIiwwLHMsXCJtYXhFXCIsMCxzLFwibWluRVwiLC1zLDAsXCJtb2R1bG9cIiwwLDldO2ZvcihlPTA7ZTx1Lmxlbmd0aDtlKz0zKWlmKGk9dVtlXSxyJiYodGhpc1tpXT1hW2ldKSx2b2lkIDAhPT0odD1uW2ldKSl7aWYoIShtKHQpPT09dCYmdD49dVtlKzFdJiZ0PD11W2UrMl0pKXRocm93IEVycm9yKGwraStcIjogXCIrdCk7dGhpc1tpXT10fWlmKGk9XCJjcnlwdG9cIixyJiYodGhpc1tpXT1hW2ldKSx2b2lkIDAhPT0odD1uW2ldKSl7aWYoITAhPT10JiYhMSE9PXQmJjAhPT10JiYxIT09dCl0aHJvdyBFcnJvcihsK2krXCI6IFwiK3QpO2lmKHQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjcnlwdG98fCFjcnlwdG98fCFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzJiYhY3J5cHRvLnJhbmRvbUJ5dGVzKXRocm93IEVycm9yKGcpO3RoaXNbaV09ITB9ZWxzZSB0aGlzW2ldPSExfXJldHVybiB0aGlzfWZ1bmN0aW9uIGhuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5jb3MoKX1mdW5jdGlvbiBkbihuKXtyZXR1cm4gbmV3IHRoaXMobikuY29zaCgpfWZ1bmN0aW9uIGxuKG4sZSl7cmV0dXJuIG5ldyB0aGlzKG4pLmRpdihlKX1mdW5jdGlvbiBwbihuKXtyZXR1cm4gbmV3IHRoaXMobikuZXhwKCl9ZnVuY3Rpb24gZ24obil7cmV0dXJuIFAobj1uZXcgdGhpcyhuKSxuLmUrMSwzKX1mdW5jdGlvbiBtbigpe3ZhciBuLGUsaT1uZXcgdGhpcygwKTtmb3IoaD0hMSxuPTA7bjxhcmd1bWVudHMubGVuZ3RoOylpZigoZT1uZXcgdGhpcyhhcmd1bWVudHNbbisrXSkpLmQpaS5kJiYoaT1pLnBsdXMoZS50aW1lcyhlKSkpO2Vsc2V7aWYoZS5zKXJldHVybiBoPSEwLG5ldyB0aGlzKDEvMCk7aT1lfXJldHVybiBoPSEwLGkuc3FydCgpfWZ1bmN0aW9uIHduKG4pe3JldHVybiBuIGluc3RhbmNlb2YgZXx8biYmXCJbb2JqZWN0IERlY2ltYWxdXCI9PT1uLm5hbWV8fCExfWZ1bmN0aW9uIHZuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5sbigpfWZ1bmN0aW9uIE5uKG4sZSl7cmV0dXJuIG5ldyB0aGlzKG4pLmxvZyhlKX1mdW5jdGlvbiBibihuKXtyZXR1cm4gbmV3IHRoaXMobikubG9nKDIpfWZ1bmN0aW9uIEVuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5sb2coMTApfWZ1bmN0aW9uIHhuKCl7cmV0dXJuIEgodGhpcyxhcmd1bWVudHMsXCJsdFwiKX1mdW5jdGlvbiB5bigpe3JldHVybiBIKHRoaXMsYXJndW1lbnRzLFwiZ3RcIil9ZnVuY3Rpb24gTW4obixlKXtyZXR1cm4gbmV3IHRoaXMobikubW9kKGUpfWZ1bmN0aW9uIHFuKG4sZSl7cmV0dXJuIG5ldyB0aGlzKG4pLm11bChlKX1mdW5jdGlvbiBPbihuLGUpe3JldHVybiBuZXcgdGhpcyhuKS5wb3coZSl9ZnVuY3Rpb24gRG4obil7dmFyIGUsaSx0LHIscz0wLHU9bmV3IHRoaXMoMSksYz1bXTtpZih2b2lkIDA9PT1uP249dGhpcy5wcmVjaXNpb246RihuLDEsbyksdD1NYXRoLmNlaWwobi95KSx0aGlzLmNyeXB0bylpZihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKWZvcihlPWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KHQpKTtzPHQ7KShyPWVbc10pPj00MjllNz9lW3NdPWNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTpjW3MrK109ciUxZTc7ZWxzZXtpZighY3J5cHRvLnJhbmRvbUJ5dGVzKXRocm93IEVycm9yKGcpO2ZvcihlPWNyeXB0by5yYW5kb21CeXRlcyh0Kj00KTtzPHQ7KShyPWVbc10rKGVbcysxXTw8OCkrKGVbcysyXTw8MTYpKygoMTI3JmVbcyszXSk8PDI0KSk+PTIxNGU3P2NyeXB0by5yYW5kb21CeXRlcyg0KS5jb3B5KGUscyk6KGMucHVzaChyJTFlNykscys9NCk7cz10LzR9ZWxzZSBmb3IoO3M8dDspY1tzKytdPTFlNypNYXRoLnJhbmRvbSgpfDA7Zm9yKHQ9Y1stLXNdLG4lPXksdCYmbiYmKHI9dygxMCx5LW4pLGNbc109KHQvcnwwKSpyKTswPT09Y1tzXTtzLS0pYy5wb3AoKTtpZihzPDApaT0wLGM9WzBdO2Vsc2V7Zm9yKGk9LTE7MD09PWNbMF07aS09eSljLnNoaWZ0KCk7Zm9yKHQ9MSxyPWNbMF07cj49MTA7ci89MTApdCsrO3Q8eSYmKGktPXktdCl9cmV0dXJuIHUuZT1pLHUuZD1jLHV9ZnVuY3Rpb24gRm4obil7cmV0dXJuIFAobj1uZXcgdGhpcyhuKSxuLmUrMSx0aGlzLnJvdW5kaW5nKX1mdW5jdGlvbiBBbihuKXtyZXR1cm4obj1uZXcgdGhpcyhuKSkuZD9uLmRbMF0/bi5zOjAqbi5zOm4uc3x8TmFOfWZ1bmN0aW9uIFNuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5zaW4oKX1mdW5jdGlvbiBabihuKXtyZXR1cm4gbmV3IHRoaXMobikuc2luaCgpfWZ1bmN0aW9uIFBuKG4pe3JldHVybiBuZXcgdGhpcyhuKS5zcXJ0KCl9ZnVuY3Rpb24gUm4obixlKXtyZXR1cm4gbmV3IHRoaXMobikuc3ViKGUpfWZ1bmN0aW9uIExuKG4pe3JldHVybiBuZXcgdGhpcyhuKS50YW4oKX1mdW5jdGlvbiBUbihuKXtyZXR1cm4gbmV3IHRoaXMobikudGFuaCgpfWZ1bmN0aW9uIFVuKG4pe3JldHVybiBQKG49bmV3IHRoaXMobiksbi5lKzEsMSl9cmV0dXJuKGU9ZnVuY3Rpb24gbihlKXt2YXIgaSx0LHI7ZnVuY3Rpb24gcyhuKXt2YXIgZSxpLHQscj10aGlzO2lmKCEociBpbnN0YW5jZW9mIHMpKXJldHVybiBuZXcgcyhuKTtpZihyLmNvbnN0cnVjdG9yPXMsbiBpbnN0YW5jZW9mIHMpcmV0dXJuIHIucz1uLnMsdm9pZChoPyFuLmR8fG4uZT5zLm1heEU/KHIuZT1OYU4sci5kPW51bGwpOm4uZTxzLm1pbkU/KHIuZT0wLHIuZD1bMF0pOihyLmU9bi5lLHIuZD1uLmQuc2xpY2UoKSk6KHIuZT1uLmUsci5kPW4uZD9uLmQuc2xpY2UoKTpuLmQpKTtpZihcIm51bWJlclwiPT0odD10eXBlb2Ygbikpe2lmKDA9PT1uKXJldHVybiByLnM9MS9uPDA/LTE6MSxyLmU9MCx2b2lkKHIuZD1bMF0pO2lmKG48MD8obj0tbixyLnM9LTEpOnIucz0xLG49PT1+fm4mJm48MWU3KXtmb3IoZT0wLGk9bjtpPj0xMDtpLz0xMCllKys7cmV0dXJuIHZvaWQoaD9lPnMubWF4RT8oci5lPU5hTixyLmQ9bnVsbCk6ZTxzLm1pbkU/KHIuZT0wLHIuZD1bMF0pOihyLmU9ZSxyLmQ9W25dKTooci5lPWUsci5kPVtuXSkpfXJldHVybiAwKm4hPTA/KG58fChyLnM9TmFOKSxyLmU9TmFOLHZvaWQoci5kPW51bGwpKTokKHIsbi50b1N0cmluZygpKX1pZihcInN0cmluZ1wiIT09dCl0aHJvdyBFcnJvcihsK24pO3JldHVybiA0NT09PShpPW4uY2hhckNvZGVBdCgwKSk/KG49bi5zbGljZSgxKSxyLnM9LTEpOig0Mz09PWkmJihuPW4uc2xpY2UoMSkpLHIucz0xKSxFLnRlc3Qobik/JChyLG4pOlcocixuKX1pZihzLnByb3RvdHlwZT1PLHMuUk9VTkRfVVA9MCxzLlJPVU5EX0RPV049MSxzLlJPVU5EX0NFSUw9MixzLlJPVU5EX0ZMT09SPTMscy5ST1VORF9IQUxGX1VQPTQscy5ST1VORF9IQUxGX0RPV049NSxzLlJPVU5EX0hBTEZfRVZFTj02LHMuUk9VTkRfSEFMRl9DRUlMPTcscy5ST1VORF9IQUxGX0ZMT09SPTgscy5FVUNMSUQ9OSxzLmNvbmZpZz1zLnNldD1hbixzLmNsb25lPW4scy5pc0RlY2ltYWw9d24scy5hYnM9WCxzLmFjb3M9WSxzLmFjb3NoPW5uLHMuYWRkPWVuLHMuYXNpbj10bixzLmFzaW5oPXJuLHMuYXRhbj1zbixzLmF0YW5oPW9uLHMuYXRhbjI9dW4scy5jYnJ0PWNuLHMuY2VpbD1mbixzLmNvcz1obixzLmNvc2g9ZG4scy5kaXY9bG4scy5leHA9cG4scy5mbG9vcj1nbixzLmh5cG90PW1uLHMubG49dm4scy5sb2c9Tm4scy5sb2cxMD1FbixzLmxvZzI9Ym4scy5tYXg9eG4scy5taW49eW4scy5tb2Q9TW4scy5tdWw9cW4scy5wb3c9T24scy5yYW5kb209RG4scy5yb3VuZD1GbixzLnNpZ249QW4scy5zaW49U24scy5zaW5oPVpuLHMuc3FydD1QbixzLnN1Yj1SbixzLnRhbj1MbixzLnRhbmg9VG4scy50cnVuYz1Vbix2b2lkIDA9PT1lJiYoZT17fSksZSYmITAhPT1lLmRlZmF1bHRzKWZvcihyPVtcInByZWNpc2lvblwiLFwicm91bmRpbmdcIixcInRvRXhwTmVnXCIsXCJ0b0V4cFBvc1wiLFwibWF4RVwiLFwibWluRVwiLFwibW9kdWxvXCIsXCJjcnlwdG9cIl0saT0wO2k8ci5sZW5ndGg7KWUuaGFzT3duUHJvcGVydHkodD1yW2krK10pfHwoZVt0XT10aGlzW3RdKTtyZXR1cm4gcy5jb25maWcoZSksc30oYSkpLmRlZmF1bHQ9ZS5EZWNpbWFsPWUsYz1uZXcgZShjKSxmPW5ldyBlKGYpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gZX0pOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzPyhcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3ImJihPW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV09Ty50b1N0cmluZyxPW1N5bWJvbC50b1N0cmluZ1RhZ109XCJEZWNpbWFsXCIpLG1vZHVsZS5leHBvcnRzPWUpOihufHwobj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZiYmc2VsZi5zZWxmPT1zZWxmP3NlbGY6d2luZG93KSx0PW4uRGVjaW1hbCxlLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gbi5EZWNpbWFsPXQsZX0sbi5EZWNpbWFsPWUpLGV9KHRoaXMpXHJcbi8vICAgIGJpZ0RlYzogcmVxdWlyZSgnZGVjaW1hbC5qcycpXHJcbn0pO1xyXG5cclxuaWYoKHR5cGVvZiBtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBuZXJkYW1lcjtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/nerdamer/nerdamer.core.js\n");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./src/style.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGUuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZhbmlsbGEtaW50ZWdyYXRpb24tMmQvLi9zcmMvc3R5bGUuY3NzPzcxNjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFwaSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/style.css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZhbmlsbGEtaW50ZWdyYXRpb24tMmQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/MmRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ \"./src/style.css\");\n/* harmony import */ var _slika_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slika.png */ \"./src/slika.png\");\n\r\n\r\n\r\nlet nerdamer = __webpack_require__(/*! nerdamer */ \"./node_modules/nerdamer/nerdamer.core.js\");\r\n// Load additional modules. These are not required.\r\n__webpack_require__(/*! nerdamer/Algebra */ \"./node_modules/nerdamer/Algebra.js\");\r\n__webpack_require__(/*! nerdamer/Calculus */ \"./node_modules/nerdamer/Calculus.js\");\r\n__webpack_require__(/*! nerdamer/Solve */ \"./node_modules/nerdamer/Solve.js\");\r\n__webpack_require__(/*! nerdamer/Extra */ \"./node_modules/nerdamer/Extra.js\");\r\n\r\n/**\r\n * Getting the elements from the DOM.\r\n */\r\nlet ctx = document.getElementById('myChart').getContext('2d');\r\nlet length = document.getElementById('length');\r\nlet force_n = document.getElementById('force_n');\r\nlet area = document.getElementById('area');\r\nlet force_F = document.getElementById('force_F');\r\nlet number_el = document.getElementById('number_el');\r\nlet submit = document.getElementById('submit');\r\nlet form = document.getElementById(\"container__input--form\");\r\n\r\nform.addEventListener('submit', (e) => handleSubmit(e));\r\n\r\nlet parameters = [length.value, force_n.value, area.value, force_F.value, number_el.value];\r\n\r\nfunction handleSubmit(e) {\r\n    e.preventDefault();\r\n\r\n    console.log(length.value);\r\n\r\n    if(number_el.value <= 8 && number_el.value >= 0 && number_el.value % 2 == 0) {\r\n        calculate(length.value, force_n.value, area.value, force_F.value, number_el.value);\r\n    } else {\r\n        alert(\"Oops, you went out of bounds for this calculator!\")\r\n    }\r\n}\r\n\r\n/**\r\n * Define the variables.\r\n */\r\nlet L_ = 1;\r\nlet n1_ = 4000;\r\nlet A1_ = 4 * 10 ** -4;\r\nlet F_ = 1000;\r\nlet elements_ = 4;\r\n\r\ncalculate(L_, n1_, A1_, F_, elements_);\r\n\r\n/**\r\n * Calculate function.\r\n */\r\nfunction calculate(L, n1, A1, F, elements) {\r\n    length.value = L;\r\n    force_n.value = n1;\r\n    area.value = A1;\r\n    force_F.value = F;\r\n    number_el.value = elements;\r\n\r\n    let c = document.getElementsByClassName('container__chart')[0].children; \r\n\r\n    let Ej = 200 * 10 ** 9;\r\n\r\n    let n = parseInt(elements) + 1;\r\n    let h = L / (elements / 2);\r\n\r\n    let Ke = (Ej*A1/h);\r\n\r\n    let Ke_matrix = [1, -1, -1, 1];\r\n    Ke_matrix = Ke_matrix.map((value) => value * Ke)\r\n\r\n    /**\r\n     * Function for creating matrix with all zeros.\r\n     */\r\n    function zeros(num) {\r\n        let arr = [];\r\n        for(let i = 0; i < num; i++) {\r\n            arr.push(0);\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    /**\r\n     * Function for creating 2D matrix.\r\n     */\r\n    function create2DMatrix(i, j = i) {\r\n        let arr = [];\r\n        for(let x = 0; x < i; x++){\r\n            arr[x] = [];    \r\n            for(let y = 0; y < j; y++){ \r\n                arr[x][y] = 0;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    let K = [];\r\n    K = create2DMatrix(n);\r\n    let Ff = zeros(n);\r\n    let Fn = zeros(n);\r\n\r\n    /**\r\n     * Function for adding one matrix diagonally to another matrix.\r\n     */\r\n    Ke_matrix.forEach(function (value) {\r\n        for(let i = 0; i < elements; i++) {\r\n            K[0][0] = value;\r\n            K[i][i] = 2*value;\r\n            K[i+1][i] = -value;\r\n            K[i][i+1] = -value;\r\n            K[i+1][i+1] = value;\r\n            K[elements-1][elements-1] = 2*value;\r\n\r\n            Fn[0] =  n1 * h / 2;\r\n            Fn[i] =  2 * n1 * h / 2;\r\n            Fn[elements] =  n1 * h / 2; \r\n            /* console.log(Fn); */\r\n        }\r\n    })\r\n\r\n    let U = [];\r\n\r\n    for(let i = 0; i < n; i++) {\r\n        let j = i + 1;\r\n        U[i] = \"u\" + j;\r\n    }\r\n\r\n    U[0] = 0;\r\n    Ff[0] = \"Ra\";\r\n    Ff[Ff.length - 1] = -F;\r\n    Ff[elements / 2] = F;\r\n\r\n    function addMatrix(a,b) {\r\n        for(let i = 0; i < a.length; i++) {\r\n            a[i] += \"+\" + b[i]\r\n        }\r\n\r\n        return a;\r\n    }\r\n    console.log(Fn);\r\n    let addForces = addMatrix(Ff, Fn);\r\n    console.log(addForces);\r\n    \r\n    /**\r\n     * Function for calculating the dot product between matrix and vector.\r\n     */\r\n    function dotProduct(matrix, vector) {\r\n        let arr = [];\r\n        let equation = \"\";\r\n        for(let j = 0; j < matrix.length; j++) {\r\n            for(let i = 0; i < vector.length; i++) {\r\n                equation += `(${matrix[i][j]})*${vector[i]}+`;\r\n            }\r\n            equation = equation.slice(0, -1);\r\n            arr[j] = equation;\r\n            equation = \"\";\r\n        }\r\n\r\n        return arr;\r\n    }\r\n\r\n    let dottedProduct = dotProduct(K, U);\r\n\r\n    let equations=[];\r\n    for(let i = 0; i < dottedProduct.length;i++) {\r\n        equations[i] = dottedProduct[i] + \"=\" + addForces[i];\r\n    }\r\n    equations.forEach(el => console.log(el));\r\n\r\n\r\n    let dataSolutions = nerdamer.solveEquations(equations);\r\n\r\n    function range(start, end, step) {\r\n        let x = [];\r\n        let j = (end-start) / step;\r\n        for(let i = 0; i<=j; i++) {\r\n            x.push(i*step);\r\n        }\r\n        return x;\r\n    }\r\n\r\n    let xRange = range(0, 2* L, h);\r\n\r\n\r\n    let solutions = [];\r\n    solutions = dataSolutions.map((value, index) => value[1])\r\n\r\n    Ke_matrix = Ke_matrix.map((value) => value * Ke)\r\n\r\n    solutions[0] = 0;\r\n    console.log(solutions);\r\n\r\n    /**\r\n     * Function defining chart config.\r\n     */\r\n    const data = {\r\n        labels: xRange,\r\n        datasets: [{\r\n            label: 'u[x] Pomik v odvisnosti od razdalje',\r\n            fill: false,\r\n            backgroundColor: 'rgb(255, 99, 132)',\r\n            borderColor: 'rgb(255, 99, 132)',\r\n            data: solutions,\r\n            tension: 0.0,\r\n        }]\r\n    };\r\n\r\n    // </block:setup>\r\n    \r\n    // <block:config:0>\r\n    const config = {\r\n        type: 'line',\r\n        data,\r\n        options: {\r\n            scales: {\r\n                yAxes: [{\r\n                    scaleLabel: {\r\n                        display: true,\r\n                        labelString: 'Pomik u [m]',\r\n                        fontSize: 20,\r\n                    },\r\n                    \r\n                }],\r\n                xAxes: [{\r\n                    scaleLabel: {\r\n                        display: true,\r\n                        labelString: 'Razdalja nosilca x [m]',\r\n                        fontSize: 20,\r\n                    }\r\n                }]\r\n            }   \r\n        },\r\n    };\r\n    // </block:config>\r\n    let myChart = document.getElementById('myChart');\r\n\r\n    let myChart2 = new Chart(myChart, config);\r\n    /* console.log(myChart); */\r\n}\r\n\r\nlet img = document.createElement(\"img\");\r\nimg.src = _slika_png__WEBPACK_IMPORTED_MODULE_1__;\r\n\r\nlet src = document.getElementById(\"slika\");\r\nsrc.appendChild(img);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZhbmlsbGEtaW50ZWdyYXRpb24tMmQvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3NzIGZyb20gXCIuL3N0eWxlLmNzc1wiO1xyXG5pbXBvcnQgc2xpa2EgZnJvbSBcIi4vc2xpa2EucG5nXCI7XHJcblxyXG5sZXQgbmVyZGFtZXIgPSByZXF1aXJlKCduZXJkYW1lcicpO1xyXG4vLyBMb2FkIGFkZGl0aW9uYWwgbW9kdWxlcy4gVGhlc2UgYXJlIG5vdCByZXF1aXJlZC5cclxucmVxdWlyZSgnbmVyZGFtZXIvQWxnZWJyYScpO1xyXG5yZXF1aXJlKCduZXJkYW1lci9DYWxjdWx1cycpO1xyXG5yZXF1aXJlKCduZXJkYW1lci9Tb2x2ZScpO1xyXG5yZXF1aXJlKCduZXJkYW1lci9FeHRyYScpO1xyXG5cclxuLyoqXHJcbiAqIEdldHRpbmcgdGhlIGVsZW1lbnRzIGZyb20gdGhlIERPTS5cclxuICovXHJcbmxldCBjdHggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbXlDaGFydCcpLmdldENvbnRleHQoJzJkJyk7XHJcbmxldCBsZW5ndGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGVuZ3RoJyk7XHJcbmxldCBmb3JjZV9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvcmNlX24nKTtcclxubGV0IGFyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXJlYScpO1xyXG5sZXQgZm9yY2VfRiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3JjZV9GJyk7XHJcbmxldCBudW1iZXJfZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbnVtYmVyX2VsJyk7XHJcbmxldCBzdWJtaXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3VibWl0Jyk7XHJcbmxldCBmb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb250YWluZXJfX2lucHV0LS1mb3JtXCIpO1xyXG5cclxuZm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCAoZSkgPT4gaGFuZGxlU3VibWl0KGUpKTtcclxuXHJcbmxldCBwYXJhbWV0ZXJzID0gW2xlbmd0aC52YWx1ZSwgZm9yY2Vfbi52YWx1ZSwgYXJlYS52YWx1ZSwgZm9yY2VfRi52YWx1ZSwgbnVtYmVyX2VsLnZhbHVlXTtcclxuXHJcbmZ1bmN0aW9uIGhhbmRsZVN1Ym1pdChlKSB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgY29uc29sZS5sb2cobGVuZ3RoLnZhbHVlKTtcclxuXHJcbiAgICBpZihudW1iZXJfZWwudmFsdWUgPD0gOCAmJiBudW1iZXJfZWwudmFsdWUgPj0gMCAmJiBudW1iZXJfZWwudmFsdWUgJSAyID09IDApIHtcclxuICAgICAgICBjYWxjdWxhdGUobGVuZ3RoLnZhbHVlLCBmb3JjZV9uLnZhbHVlLCBhcmVhLnZhbHVlLCBmb3JjZV9GLnZhbHVlLCBudW1iZXJfZWwudmFsdWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBhbGVydChcIk9vcHMsIHlvdSB3ZW50IG91dCBvZiBib3VuZHMgZm9yIHRoaXMgY2FsY3VsYXRvciFcIilcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmluZSB0aGUgdmFyaWFibGVzLlxyXG4gKi9cclxubGV0IExfID0gMTtcclxubGV0IG4xXyA9IDQwMDA7XHJcbmxldCBBMV8gPSA0ICogMTAgKiogLTQ7XHJcbmxldCBGXyA9IDEwMDA7XHJcbmxldCBlbGVtZW50c18gPSA0O1xyXG5cclxuY2FsY3VsYXRlKExfLCBuMV8sIEExXywgRl8sIGVsZW1lbnRzXyk7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlIGZ1bmN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlKEwsIG4xLCBBMSwgRiwgZWxlbWVudHMpIHtcclxuICAgIGxlbmd0aC52YWx1ZSA9IEw7XHJcbiAgICBmb3JjZV9uLnZhbHVlID0gbjE7XHJcbiAgICBhcmVhLnZhbHVlID0gQTE7XHJcbiAgICBmb3JjZV9GLnZhbHVlID0gRjtcclxuICAgIG51bWJlcl9lbC52YWx1ZSA9IGVsZW1lbnRzO1xyXG5cclxuICAgIGxldCBjID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY29udGFpbmVyX19jaGFydCcpWzBdLmNoaWxkcmVuOyBcclxuXHJcbiAgICBsZXQgRWogPSAyMDAgKiAxMCAqKiA5O1xyXG5cclxuICAgIGxldCBuID0gcGFyc2VJbnQoZWxlbWVudHMpICsgMTtcclxuICAgIGxldCBoID0gTCAvIChlbGVtZW50cyAvIDIpO1xyXG5cclxuICAgIGxldCBLZSA9IChFaipBMS9oKTtcclxuXHJcbiAgICBsZXQgS2VfbWF0cml4ID0gWzEsIC0xLCAtMSwgMV07XHJcbiAgICBLZV9tYXRyaXggPSBLZV9tYXRyaXgubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKiBLZSlcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIGZvciBjcmVhdGluZyBtYXRyaXggd2l0aCBhbGwgemVyb3MuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHplcm9zKG51bSkge1xyXG4gICAgICAgIGxldCBhcnIgPSBbXTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyLnB1c2goMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiBmb3IgY3JlYXRpbmcgMkQgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjcmVhdGUyRE1hdHJpeChpLCBqID0gaSkge1xyXG4gICAgICAgIGxldCBhcnIgPSBbXTtcclxuICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgaTsgeCsrKXtcclxuICAgICAgICAgICAgYXJyW3hdID0gW107ICAgIFxyXG4gICAgICAgICAgICBmb3IobGV0IHkgPSAwOyB5IDwgajsgeSsrKXsgXHJcbiAgICAgICAgICAgICAgICBhcnJbeF1beV0gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IEsgPSBbXTtcclxuICAgIEsgPSBjcmVhdGUyRE1hdHJpeChuKTtcclxuICAgIGxldCBGZiA9IHplcm9zKG4pO1xyXG4gICAgbGV0IEZuID0gemVyb3Mobik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiBmb3IgYWRkaW5nIG9uZSBtYXRyaXggZGlhZ29uYWxseSB0byBhbm90aGVyIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgS2VfbWF0cml4LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgS1swXVswXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBLW2ldW2ldID0gMip2YWx1ZTtcclxuICAgICAgICAgICAgS1tpKzFdW2ldID0gLXZhbHVlO1xyXG4gICAgICAgICAgICBLW2ldW2krMV0gPSAtdmFsdWU7XHJcbiAgICAgICAgICAgIEtbaSsxXVtpKzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIEtbZWxlbWVudHMtMV1bZWxlbWVudHMtMV0gPSAyKnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgRm5bMF0gPSAgbjEgKiBoIC8gMjtcclxuICAgICAgICAgICAgRm5baV0gPSAgMiAqIG4xICogaCAvIDI7XHJcbiAgICAgICAgICAgIEZuW2VsZW1lbnRzXSA9ICBuMSAqIGggLyAyOyBcclxuICAgICAgICAgICAgLyogY29uc29sZS5sb2coRm4pOyAqL1xyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgbGV0IFUgPSBbXTtcclxuXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGogPSBpICsgMTtcclxuICAgICAgICBVW2ldID0gXCJ1XCIgKyBqO1xyXG4gICAgfVxyXG5cclxuICAgIFVbMF0gPSAwO1xyXG4gICAgRmZbMF0gPSBcIlJhXCI7XHJcbiAgICBGZltGZi5sZW5ndGggLSAxXSA9IC1GO1xyXG4gICAgRmZbZWxlbWVudHMgLyAyXSA9IEY7XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkTWF0cml4KGEsYikge1xyXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFbaV0gKz0gXCIrXCIgKyBiW2ldXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYTtcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKEZuKTtcclxuICAgIGxldCBhZGRGb3JjZXMgPSBhZGRNYXRyaXgoRmYsIEZuKTtcclxuICAgIGNvbnNvbGUubG9nKGFkZEZvcmNlcyk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIHRoZSBkb3QgcHJvZHVjdCBiZXR3ZWVuIG1hdHJpeCBhbmQgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb3RQcm9kdWN0KG1hdHJpeCwgdmVjdG9yKSB7XHJcbiAgICAgICAgbGV0IGFyciA9IFtdO1xyXG4gICAgICAgIGxldCBlcXVhdGlvbiA9IFwiXCI7XHJcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IG1hdHJpeC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmVjdG9yLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBlcXVhdGlvbiArPSBgKCR7bWF0cml4W2ldW2pdfSkqJHt2ZWN0b3JbaV19K2A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXF1YXRpb24gPSBlcXVhdGlvbi5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgICAgIGFycltqXSA9IGVxdWF0aW9uO1xyXG4gICAgICAgICAgICBlcXVhdGlvbiA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBkb3R0ZWRQcm9kdWN0ID0gZG90UHJvZHVjdChLLCBVKTtcclxuXHJcbiAgICBsZXQgZXF1YXRpb25zPVtdO1xyXG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGRvdHRlZFByb2R1Y3QubGVuZ3RoO2krKykge1xyXG4gICAgICAgIGVxdWF0aW9uc1tpXSA9IGRvdHRlZFByb2R1Y3RbaV0gKyBcIj1cIiArIGFkZEZvcmNlc1tpXTtcclxuICAgIH1cclxuICAgIGVxdWF0aW9ucy5mb3JFYWNoKGVsID0+IGNvbnNvbGUubG9nKGVsKSk7XHJcblxyXG5cclxuICAgIGxldCBkYXRhU29sdXRpb25zID0gbmVyZGFtZXIuc29sdmVFcXVhdGlvbnMoZXF1YXRpb25zKTtcclxuXHJcbiAgICBmdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XHJcbiAgICAgICAgbGV0IHggPSBbXTtcclxuICAgICAgICBsZXQgaiA9IChlbmQtc3RhcnQpIC8gc3RlcDtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpPD1qOyBpKyspIHtcclxuICAgICAgICAgICAgeC5wdXNoKGkqc3RlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCB4UmFuZ2UgPSByYW5nZSgwLCAyKiBMLCBoKTtcclxuXHJcblxyXG4gICAgbGV0IHNvbHV0aW9ucyA9IFtdO1xyXG4gICAgc29sdXRpb25zID0gZGF0YVNvbHV0aW9ucy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWVbMV0pXHJcblxyXG4gICAgS2VfbWF0cml4ID0gS2VfbWF0cml4Lm1hcCgodmFsdWUpID0+IHZhbHVlICogS2UpXHJcblxyXG4gICAgc29sdXRpb25zWzBdID0gMDtcclxuICAgIGNvbnNvbGUubG9nKHNvbHV0aW9ucyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiBkZWZpbmluZyBjaGFydCBjb25maWcuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgbGFiZWxzOiB4UmFuZ2UsXHJcbiAgICAgICAgZGF0YXNldHM6IFt7XHJcbiAgICAgICAgICAgIGxhYmVsOiAndVt4XSBQb21payB2IG9kdmlzbm9zdGkgb2QgcmF6ZGFsamUnLFxyXG4gICAgICAgICAgICBmaWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI1NSwgOTksIDEzMiknLFxyXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYigyNTUsIDk5LCAxMzIpJyxcclxuICAgICAgICAgICAgZGF0YTogc29sdXRpb25zLFxyXG4gICAgICAgICAgICB0ZW5zaW9uOiAwLjAsXHJcbiAgICAgICAgfV1cclxuICAgIH07XHJcblxyXG4gICAgLy8gPC9ibG9jazpzZXR1cD5cclxuICAgIFxyXG4gICAgLy8gPGJsb2NrOmNvbmZpZzowPlxyXG4gICAgY29uc3QgY29uZmlnID0ge1xyXG4gICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NhbGVzOiB7XHJcbiAgICAgICAgICAgICAgICB5QXhlczogW3tcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZUxhYmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnUG9taWsgdSBbbV0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMjAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgeEF4ZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVMYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFN0cmluZzogJ1JhemRhbGphIG5vc2lsY2EgeCBbbV0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMjAsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICAgICAgfSAgIFxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG4gICAgLy8gPC9ibG9jazpjb25maWc+XHJcbiAgICBsZXQgbXlDaGFydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteUNoYXJ0Jyk7XHJcblxyXG4gICAgbGV0IG15Q2hhcnQyID0gbmV3IENoYXJ0KG15Q2hhcnQsIGNvbmZpZyk7XHJcbiAgICAvKiBjb25zb2xlLmxvZyhteUNoYXJ0KTsgKi9cclxufVxyXG5cclxubGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbmltZy5zcmMgPSBzbGlrYTtcclxuXHJcbmxldCBzcmMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNsaWthXCIpO1xyXG5zcmMuYXBwZW5kQ2hpbGQoaW1nKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/slika.png":
/*!***********************!*\
  !*** ./src/slika.png ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "6952ba378173272f566a.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;